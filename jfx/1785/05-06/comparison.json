{"files":[{"patch":"@@ -1,736 +0,0 @@\n-cmake_minimum_required(VERSION 3.18)\n-\n-file(STRINGS \"configure.ac\" CONFIGURE_AC_LINES)\n-foreach(line ${CONFIGURE_AC_LINES})\n-    if(line MATCHES [[^m4_define\\(\\[(MAJOR_VERSION|MINOR_VERSION|MICRO_VERSION)\\],[ \\t]*([0-9]+)\\)$]])\n-        set(LIBXML_${CMAKE_MATCH_1} ${CMAKE_MATCH_2})\n-    elseif(line MATCHES \"^(LIBXML_MAJOR_VERSION|LIBXML_MINOR_VERSION|LIBXML_MICRO_VERSION)=([0-9]+)$\")\n-        set(${CMAKE_MATCH_1} ${CMAKE_MATCH_2})\n-    endif()\n-endforeach()\n-set(VERSION \"${LIBXML_MAJOR_VERSION}.${LIBXML_MINOR_VERSION}.${LIBXML_MICRO_VERSION}\")\n-\n-project(libxml2 VERSION ${VERSION} LANGUAGES C)\n-\n-include(CheckCSourceCompiles)\n-include(CheckFunctionExists)\n-include(CheckIncludeFiles)\n-include(CheckLibraryExists)\n-include(CheckLinkerFlag)\n-include(CheckStructHasMember)\n-include(CheckSymbolExists)\n-include(CMakePackageConfigHelpers)\n-include(FindPkgConfig)\n-include(GNUInstallDirs)\n-\n-option(BUILD_SHARED_LIBS \"Build shared libraries\" ON)\n-set(LIBXML2_WITH_AUTOMATA ON)\n-option(LIBXML2_WITH_C14N \"Add the Canonicalization support\" ON)\n-option(LIBXML2_WITH_CATALOG \"Add the Catalog support\" ON)\n-option(LIBXML2_WITH_DEBUG \"Add the debugging module\" ON)\n-set(LIBXML2_WITH_EXPR ON)\n-option(LIBXML2_WITH_FTP \"Add the FTP support\" OFF)\n-option(LIBXML2_WITH_HTML \"Add the HTML support\" ON)\n-option(LIBXML2_WITH_HTTP \"Add the HTTP support\" OFF)\n-option(LIBXML2_WITH_ICONV \"Add ICONV support\" ON)\n-option(LIBXML2_WITH_ICU \"Add ICU support\" OFF)\n-option(LIBXML2_WITH_ISO8859X \"Add ISO8859X support if no iconv\" ON)\n-option(LIBXML2_WITH_LEGACY \"Add deprecated APIs for compatibility\" OFF)\n-option(LIBXML2_WITH_LZMA \"Use liblzma\" OFF)\n-option(LIBXML2_WITH_MODULES \"Add the dynamic modules support\" ON)\n-option(LIBXML2_WITH_OUTPUT \"Add the serialization support\" ON)\n-option(LIBXML2_WITH_PATTERN \"Add the xmlPattern selection interface\" ON)\n-option(LIBXML2_WITH_PROGRAMS \"Build programs\" ON)\n-option(LIBXML2_WITH_PUSH \"Add the PUSH parser interfaces\" ON)\n-option(LIBXML2_WITH_PYTHON \"Build Python bindings\" ON)\n-option(LIBXML2_WITH_READER \"Add the xmlReader parsing interface\" ON)\n-option(LIBXML2_WITH_REGEXPS \"Add Regular Expressions support\" ON)\n-option(LIBXML2_WITH_SAX1 \"Add the older SAX1 interface\" ON)\n-option(LIBXML2_WITH_SCHEMAS \"Add Relax-NG and Schemas support\" ON)\n-option(LIBXML2_WITH_SCHEMATRON \"Add Schematron support\" ON)\n-option(LIBXML2_WITH_TESTS \"Build tests\" ON)\n-option(LIBXML2_WITH_THREADS \"Add multithread support\" ON)\n-option(LIBXML2_WITH_THREAD_ALLOC \"Add per-thread memory\" OFF)\n-option(LIBXML2_WITH_TLS \"Enable thread-local storage\" OFF)\n-option(LIBXML2_WITH_TREE \"Add the DOM like tree manipulation APIs\" ON)\n-set(LIBXML2_WITH_UNICODE ON)\n-option(LIBXML2_WITH_VALID \"Add the DTD validation support\" ON)\n-option(LIBXML2_WITH_WRITER \"Add the xmlWriter saving interface\" ON)\n-option(LIBXML2_WITH_XINCLUDE \"Add the XInclude support\" ON)\n-option(LIBXML2_WITH_XPATH \"Add the XPATH support\" ON)\n-option(LIBXML2_WITH_XPTR \"Add the XPointer support\" ON)\n-option(LIBXML2_WITH_XPTR_LOCS \"Add support for XPointer locations\" OFF)\n-option(LIBXML2_WITH_ZLIB \"Use libz\" OFF)\n-set(LIBXML2_XMLCONF_WORKING_DIR ${CMAKE_CURRENT_BINARY_DIR} CACHE PATH \"Working directory for XML Conformance Test Suite\")\n-\n-if(LIBXML2_WITH_PYTHON)\n-    check_include_files(unistd.h HAVE_UNISTD_H)\n-    check_symbol_exists(F_GETFL fcntl.h HAVE_F_GETFL)\n-    find_package(Python COMPONENTS Interpreter Development REQUIRED)\n-    #set(LIBXML2_PYTHON_INSTALL_DIR ${Python_SITEARCH} CACHE PATH \"Python bindings install directory\")\n-    set(LIBXML2_PYTHON_INSTALL_DIR \"${CMAKE_INSTALL_PREFIX}\/python\"\n-        CACHE PATH \"Python bindings install directory\")\n-endif()\n-\n-foreach(VARIABLE IN ITEMS WITH_AUTOMATA WITH_C14N WITH_CATALOG WITH_DEBUG WITH_EXPR WITH_FTP WITH_HTML WITH_HTTP WITH_ICONV WITH_ICU WITH_ISO8859X WITH_LEGACY WITH_LZMA WITH_MODULES WITH_OUTPUT WITH_PATTERN WITH_PUSH WITH_READER WITH_REGEXPS WITH_SAX1 WITH_SCHEMAS WITH_SCHEMATRON WITH_THREADS WITH_THREAD_ALLOC WITH_TREE WITH_UNICODE WITH_VALID WITH_WRITER WITH_XINCLUDE WITH_XPATH WITH_XPTR WITH_XPTR_LOCS WITH_ZLIB)\n-    if(LIBXML2_${VARIABLE})\n-        set(${VARIABLE} 1)\n-    else()\n-        set(${VARIABLE} 0)\n-    endif()\n-endforeach()\n-\n-set(LIBXML_VERSION ${VERSION})\n-set(LIBXML_VERSION_EXTRA \"\")\n-math(EXPR LIBXML_VERSION_NUMBER \"\n-    ${LIBXML_MAJOR_VERSION} * 10000 +\n-    ${LIBXML_MINOR_VERSION} * 100 +\n-    ${LIBXML_MICRO_VERSION}\n-\")\n-\n-set(MODULE_EXTENSION \"${CMAKE_SHARED_LIBRARY_SUFFIX}\")\n-\n-set(PACKAGE \"libxml2\")\n-set(PACKAGE_NAME \"libxml2\")\n-set(PACKAGE_STRING \"libxml2 ${VERSION}\")\n-set(PACKAGE_TARNAME \"libxml2\")\n-set(PACKAGE_URL \"https:\/\/gitlab.gnome.org\/GNOME\/libxml2\")\n-set(PACKAGE_VERSION ${VERSION})\n-\n-if(LIBXML2_WITH_ICONV)\n-    find_package(Iconv REQUIRED)\n-endif()\n-\n-if(LIBXML2_WITH_ICU)\n-    find_package(ICU REQUIRED COMPONENTS data i18n uc)\n-endif()\n-\n-if(LIBXML2_WITH_LZMA)\n-    find_package(LibLZMA REQUIRED)\n-endif()\n-\n-if(LIBXML2_WITH_THREADS)\n-    find_package(Threads REQUIRED)\n-    set(THREAD_LIBS ${CMAKE_THREAD_LIBS_INIT})\n-    list(APPEND CMAKE_REQUIRED_LIBRARIES Threads::Threads)\n-endif()\n-\n-if(LIBXML2_WITH_ZLIB)\n-    find_package(ZLIB REQUIRED)\n-endif()\n-\n-if (NOT MSVC)\n-    check_c_source_compiles(\"\n-        void __attribute__((destructor))\n-        f(void) {}\n-        int main(void) { return 0; }\n-    \" HAVE_ATTRIBUTE_DESTRUCTOR)\n-    if(HAVE_ATTRIBUTE_DESTRUCTOR)\n-        set(ATTRIBUTE_DESTRUCTOR \"__attribute__((destructor))\")\n-    endif()\n-    check_include_files(arpa\/inet.h HAVE_ARPA_INET_H)\n-    check_function_exists(class HAVE_CLASS)\n-    check_include_files(dlfcn.h HAVE_DLFCN_H)\n-    check_library_exists(dl dlopen \"\" HAVE_DLOPEN)\n-    check_include_files(dl.h HAVE_DL_H)\n-    check_include_files(fcntl.h HAVE_FCNTL_H)\n-    check_function_exists(fpclass HAVE_FPCLASS)\n-    check_function_exists(ftime HAVE_FTIME)\n-    check_function_exists(getentropy HAVE_GETENTROPY)\n-    check_function_exists(gettimeofday HAVE_GETTIMEOFDAY)\n-    check_library_exists(history append_history \"\" HAVE_LIBHISTORY)\n-    check_library_exists(readline readline \"\" HAVE_LIBREADLINE)\n-    check_function_exists(mmap HAVE_MMAP)\n-    check_function_exists(munmap HAVE_MUNMAP)\n-    check_include_files(netdb.h HAVE_NETDB_H)\n-    check_include_files(netinet\/in.h HAVE_NETINET_IN_H)\n-    check_include_files(poll.h HAVE_POLL_H)\n-    check_library_exists(dld shl_load \"\" HAVE_SHLLOAD)\n-    check_function_exists(stat HAVE_STAT)\n-    check_include_files(stdint.h HAVE_STDINT_H)\n-    check_include_files(sys\/mman.h HAVE_SYS_MMAN_H)\n-    if (APPLE)\n-        # In old macOS SDKs (ex: 10.15), sys\/random.h fails to include header files it needs, so add them here.\n-        check_include_files(\"Availability.h;stddef.h;sys\/random.h\" HAVE_SYS_RANDOM_H)\n-    else()\n-        check_include_files(sys\/random.h HAVE_SYS_RANDOM_H)\n-    endif()\n-    check_include_files(sys\/select.h HAVE_SYS_SELECT_H)\n-    check_include_files(sys\/socket.h HAVE_SYS_SOCKET_H)\n-    check_include_files(sys\/stat.h HAVE_SYS_STAT_H)\n-    check_include_files(sys\/timeb.h HAVE_SYS_TIMEB_H)\n-    check_include_files(sys\/time.h HAVE_SYS_TIME_H)\n-    check_include_files(unistd.h HAVE_UNISTD_H)\n-    check_c_source_compiles(\"\n-        #include <stddef.h>\n-        #include <sys\/socket.h>\n-        int main() { (void) getsockopt(1, 1, 1, NULL, (socklen_t*) NULL); return 0; }\n-    \" XML_SOCKLEN_T_SOCKLEN_T)\n-    if(XML_SOCKLEN_T_SOCKLEN_T)\n-        set(XML_SOCKLEN_T socklen_t)\n-    else()\n-        check_c_source_compiles(\"\n-            #include <stddef.h>\n-            #include <sys\/socket.h>\n-            int main() { (void) getsockopt(1, 1, 1, NULL, (size_t*) NULL); return 0; }\n-        \" XML_SOCKLEN_T_SIZE_T)\n-        if(XML_SOCKLEN_T_SIZE_T)\n-            set(XML_SOCKLEN_T size_t)\n-        else()\n-            check_c_source_compiles(\"\n-                #include <stddef.h>\n-                #include <sys\/socket.h>\n-                int main() { (void) getsockopt (1, 1, 1, NULL, (int*) NULL); return 0; }\n-            \" XML_SOCKLEN_T_INT)\n-            set(XML_SOCKLEN_T int)\n-        endif()\n-    endif()\n-endif()\n-\n-if(LIBXML2_WITH_TLS)\n-    check_c_source_compiles(\n-        \"_Thread_local int v; int main(){return 0;}\"\n-        XML_THREAD_LOCAL_C11\n-    )\n-    if (XML_THREAD_LOCAL_C11)\n-        set(XML_THREAD_LOCAL \"_Thread_local\")\n-    else()\n-        check_c_source_compiles(\n-            \"__thread int v; int main(){return 0;}\"\n-            XML_THREAD_LOCAL_THREAD\n-        )\n-        if (XML_THREAD_LOCAL_THREAD)\n-            set(XML_THREAD_LOCAL \"__thread\")\n-        else()\n-            check_c_source_compiles(\n-                \"__declspec(thread) int v; int main(){return 0;}\"\n-                XML_THREAD_LOCAL_DECLSPEC\n-            )\n-            if (XML_THREAD_LOCAL_DECLSPEC)\n-                set(XML_THREAD_LOCAL \"__declspec(thread)\")\n-            endif()\n-        endif()\n-    endif()\n-endif()\n-\n-set(\n-    LIBXML2_HDRS\n-    include\/libxml\/c14n.h\n-    include\/libxml\/catalog.h\n-    include\/libxml\/chvalid.h\n-    include\/libxml\/debugXML.h\n-    include\/libxml\/dict.h\n-    include\/libxml\/encoding.h\n-    include\/libxml\/entities.h\n-    include\/libxml\/globals.h\n-    include\/libxml\/hash.h\n-    include\/libxml\/HTMLparser.h\n-    include\/libxml\/HTMLtree.h\n-    include\/libxml\/list.h\n-    include\/libxml\/nanoftp.h\n-    include\/libxml\/nanohttp.h\n-    include\/libxml\/parser.h\n-    include\/libxml\/parserInternals.h\n-    include\/libxml\/pattern.h\n-    include\/libxml\/relaxng.h\n-    include\/libxml\/SAX.h\n-    include\/libxml\/SAX2.h\n-    include\/libxml\/schemasInternals.h\n-    include\/libxml\/schematron.h\n-    include\/libxml\/threads.h\n-    include\/libxml\/tree.h\n-    include\/libxml\/uri.h\n-    include\/libxml\/valid.h\n-    include\/libxml\/xinclude.h\n-    include\/libxml\/xlink.h\n-    include\/libxml\/xmlIO.h\n-    include\/libxml\/xmlautomata.h\n-    include\/libxml\/xmlerror.h\n-    include\/libxml\/xmlexports.h\n-    include\/libxml\/xmlmemory.h\n-    include\/libxml\/xmlmodule.h\n-    include\/libxml\/xmlreader.h\n-    include\/libxml\/xmlregexp.h\n-    include\/libxml\/xmlsave.h\n-    include\/libxml\/xmlschemas.h\n-    include\/libxml\/xmlschemastypes.h\n-    include\/libxml\/xmlstring.h\n-    include\/libxml\/xmlunicode.h\n-    include\/libxml\/xmlwriter.h\n-    include\/libxml\/xpath.h\n-    include\/libxml\/xpathInternals.h\n-    include\/libxml\/xpointer.h\n-)\n-\n-set(\n-    LIBXML2_SRCS\n-    buf.c\n-    c14n.c\n-    catalog.c\n-    chvalid.c\n-    debugXML.c\n-    dict.c\n-    encoding.c\n-    entities.c\n-    error.c\n-    globals.c\n-    hash.c\n-    HTMLparser.c\n-    HTMLtree.c\n-    legacy.c\n-    list.c\n-    nanoftp.c\n-    nanohttp.c\n-    parser.c\n-    parserInternals.c\n-    pattern.c\n-    relaxng.c\n-    SAX.c\n-    SAX2.c\n-    schematron.c\n-    threads.c\n-    tree.c\n-    uri.c\n-    valid.c\n-    xinclude.c\n-    xlink.c\n-    xmlIO.c\n-    xmlmemory.c\n-    xmlmodule.c\n-    xmlreader.c\n-    xmlregexp.c\n-    xmlsave.c\n-    xmlschemas.c\n-    xmlschemastypes.c\n-    xmlstring.c\n-    xmlunicode.c\n-    xmlwriter.c\n-    xpath.c\n-    xpointer.c\n-    xzlib.c\n-)\n-\n-if(WIN32)\n-    list(APPEND LIBXML2_SRCS win32\/libxml2.rc)\n-    file(\n-        WRITE\n-        ${CMAKE_CURRENT_BINARY_DIR}\/rcVersion.h\n-        \"#define LIBXML_MAJOR_VERSION ${LIBXML_MAJOR_VERSION}\\n\"\n-        \"#define LIBXML_MINOR_VERSION ${LIBXML_MINOR_VERSION}\\n\"\n-        \"#define LIBXML_MICRO_VERSION ${LIBXML_MICRO_VERSION}\\n\"\n-        \"#define LIBXML_DOTTED_VERSION \\\"${VERSION}\\\"\\n\"\n-    )\n-endif()\n-\n-add_library(LibXml2 ${LIBXML2_HDRS} ${LIBXML2_SRCS})\n-add_library(LibXml2::LibXml2 ALIAS LibXml2)\n-\n-target_compile_definitions(LibXml2 PRIVATE SYSCONFDIR=\"${CMAKE_INSTALL_FULL_SYSCONFDIR}\")\n-\n-if(LIBXML2_WITH_THREADS)\n-    if(NOT WIN32)\n-        check_include_files(pthread.h HAVE_PTHREAD_H)\n-    endif()\n-endif()\n-\n-target_include_directories(\n-    LibXml2\n-    PUBLIC\n-    $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>\n-    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}\/include>\n-    $<INSTALL_INTERFACE:$<INSTALL_PREFIX>\/${CMAKE_INSTALL_INCLUDEDIR}\/libxml2>\n-)\n-\n-if(LIBXML2_WITH_MODULES)\n-    if(HAVE_DLOPEN)\n-        target_link_libraries(LibXml2 PRIVATE dl)\n-        set(MODULE_PLATFORM_LIBS \"-ldl\")\n-    endif()\n-\n-    if(HAVE_SHLLOAD)\n-        target_link_libraries(LibXml2 PRIVATE dld)\n-        set(MODULE_PLATFORM_LIBS \"-ldld\")\n-    endif()\n-endif()\n-\n-if(UNIX)\n-    target_link_libraries(LibXml2 PRIVATE m)\n-    set(LIBM \"-lm\")\n-endif()\n-\n-if(WIN32)\n-    target_link_libraries(LibXml2 PRIVATE ws2_32)\n-    set(WINSOCK_LIBS \"-lws2_32\")\n-    target_link_libraries(LibXml2 PRIVATE bcrypt)\n-    set(CRYPTO_LIBS \"-lbcrypt\")\n-endif()\n-\n-if(LIBXML2_WITH_ICONV)\n-    target_link_libraries(LibXml2 PUBLIC Iconv::Iconv)\n-    if(NOT Iconv_IS_BUILT_IN)\n-        set(ICONV_LIBS \"-liconv\")\n-    endif()\n-endif()\n-\n-if(LIBXML2_WITH_ICU)\n-    target_link_libraries(LibXml2 PRIVATE ICU::data ICU::i18n ICU::uc)\n-    if(WIN32)\n-        set(ICU_LDFLAGS \"-licudt -licuin -licuuc\")\n-    else()\n-        set(ICU_LDFLAGS \"-licudata -licui18n -licuuc\")\n-    endif()\n-    list(APPEND XML_PRIVATE_LIBS \"${ICU_LDFLAGS}\")\n-    pkg_check_modules(ICU_PC IMPORTED_TARGET icu-i18n)\n-    if(ICU_PC_FOUND)\n-        list(APPEND XML_PC_REQUIRES icu-i18n)\n-    else()\n-        list(APPEND XML_PC_LIBS \"${ICU_LDFLAGS}\")\n-    endif()\n-endif()\n-\n-if(LIBXML2_WITH_LZMA)\n-    target_link_libraries(LibXml2 PRIVATE LibLZMA::LibLZMA)\n-    set(LibLZMA_LDFLAGS \"-llzma\")\n-    list(APPEND XML_PRIVATE_LIBS \"${LibLZMA_LDFLAGS}\")\n-    pkg_check_modules(LibLZMA_PC IMPORTED_TARGET liblzma)\n-    if(LibLZMA_PC_FOUND)\n-        list(APPEND XML_PC_REQUIRES liblzma)\n-    else()\n-        list(APPEND XML_PC_LIBS \"${LibLZMA_LDFLAGS}\")\n-    endif()\n-endif()\n-\n-if(LIBXML2_WITH_THREADS)\n-    target_link_libraries(LibXml2 PRIVATE Threads::Threads)\n-endif()\n-\n-if(LIBXML2_WITH_ZLIB)\n-    target_link_libraries(LibXml2 PRIVATE ZLIB::ZLIB)\n-    set(ZLIB_LDFLAGS \"-lz\")\n-    list(APPEND XML_PRIVATE_LIBS \"${ZLIB_LDFLAGS}\")\n-    pkg_check_modules(ZLIB_PC IMPORTED_TARGET zlib)\n-    if(ZLIB_PC_FOUND)\n-        list(APPEND XML_PC_REQUIRES zlib)\n-    else()\n-        list(APPEND XML_PC_LIBS \"${ZLIB_LDFLAGS}\")\n-    endif()\n-endif()\n-\n-if(CMAKE_C_COMPILER_ID MATCHES \"Clang\" OR CMAKE_C_COMPILER_ID STREQUAL \"GNU\")\n-    # These compiler flags can break the checks above so keep them here.\n-    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -pedantic -Wall -Wextra -Wshadow \\\n--Wpointer-arith -Wcast-align -Wwrite-strings \\\n--Wstrict-prototypes -Wmissing-prototypes \\\n--Wno-long-long -Wno-format-extra-args\")\n-\n-    if(BUILD_SHARED_LIBS AND UNIX AND NOT APPLE)\n-        check_linker_flag(C \"LINKER:--undefined-version\" FLAG_UNDEFINED_VERSION)\n-        if (FLAG_UNDEFINED_VERSION)\n-            target_link_options(LibXml2 PRIVATE \"LINKER:--undefined-version\")\n-        endif()\n-        target_link_options(LibXml2 PRIVATE \"LINKER:--version-script=${CMAKE_CURRENT_SOURCE_DIR}\/libxml2.syms\")\n-    endif()\n-endif()\n-\n-set_target_properties(\n-    LibXml2\n-    PROPERTIES\n-    IMPORT_PREFIX lib\n-    OUTPUT_NAME xml2\n-    POSITION_INDEPENDENT_CODE ON\n-    PREFIX lib\n-    VERSION ${PROJECT_VERSION}\n-    SOVERSION ${LIBXML_MAJOR_VERSION}\n-)\n-\n-if(MSVC)\n-    if(BUILD_SHARED_LIBS)\n-        set_target_properties(\n-            LibXml2\n-            PROPERTIES\n-            DEBUG_POSTFIX d\n-        )\n-    else()\n-        set_target_properties(\n-            LibXml2\n-            PROPERTIES\n-            DEBUG_POSTFIX sd\n-            MINSIZEREL_POSTFIX s\n-            RELEASE_POSTFIX s\n-            RELWITHDEBINFO_POSTFIX s\n-        )\n-    endif()\n-endif()\n-\n-install(FILES ${LIBXML2_HDRS} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\/libxml2\/libxml COMPONENT development)\n-\n-install(\n-    TARGETS    LibXml2\n-    EXPORT LibXml2\n-    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT development\n-    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT runtime NAMELINK_COMPONENT development\n-    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT runtime\n-)\n-\n-if(MSVC AND BUILD_SHARED_LIBS)\n-    install(FILES $<TARGET_PDB_FILE:LibXml2> DESTINATION ${CMAKE_INSTALL_BINDIR} CONFIGURATIONS Debug RelWithDebInfo COMPONENT debug)\n-endif()\n-\n-if(LIBXML2_WITH_PROGRAMS)\n-    set(\n-        PROGRAMS\n-        xmlcatalog\n-        xmllint\n-    )\n-    foreach(PROGRAM ${PROGRAMS})\n-        add_executable(${PROGRAM} ${PROGRAM}.c)\n-        add_executable(LibXml2::${PROGRAM} ALIAS ${PROGRAM})\n-        target_compile_definitions(${PROGRAM} PRIVATE SYSCONFDIR=\"${CMAKE_INSTALL_FULL_SYSCONFDIR}\")\n-        target_link_libraries(${PROGRAM} LibXml2)\n-        if(HAVE_LIBHISTORY)\n-            target_link_libraries(${PROGRAM} history)\n-        endif()\n-        if(HAVE_LIBREADLINE)\n-            target_link_libraries(${PROGRAM} readline)\n-        endif()\n-        install(TARGETS    ${PROGRAM} EXPORT LibXml2 RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT programs)\n-    endforeach()\n-endif()\n-\n-if(LIBXML2_WITH_TESTS)\n-    enable_testing()\n-    set(\n-        TESTS\n-        runtest\n-        runxmlconf\n-        runsuite\n-        testapi\n-        testchar\n-        testdict\n-        testModule\n-        testlimits\n-        testparser\n-        testrecurse\n-        testThreads\n-    )\n-    foreach(TEST ${TESTS})\n-        add_executable(${TEST} ${TEST}.c)\n-        target_compile_definitions(${TEST} PRIVATE SYSCONFDIR=\"${CMAKE_INSTALL_FULL_SYSCONFDIR}\")\n-        target_link_libraries(${TEST} LibXml2)\n-    endforeach()\n-    if(Threads_FOUND)\n-        foreach(TEST runtest testThreads)\n-            target_link_libraries(${TEST} Threads::Threads)\n-        endforeach()\n-    endif()\n-    add_test(NAME runtest COMMAND runtest --out ${CMAKE_CURRENT_BINARY_DIR} WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n-    add_test(NAME runsuite COMMAND runsuite WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n-    if(EXISTS ${LIBXML2_XMLCONF_WORKING_DIR}\/xmlconf\/xmlconf.xml)\n-        add_test(NAME runxmlconf COMMAND runxmlconf WORKING_DIRECTORY ${LIBXML2_XMLCONF_WORKING_DIR})\n-    endif()\n-    if(NOT WIN32)\n-        add_test(NAME testapi COMMAND testapi)\n-    endif()\n-    add_test(NAME testchar COMMAND testchar)\n-    add_test(NAME testdict COMMAND testdict)\n-    add_test(NAME testparser COMMAND testparser WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n-    add_test(NAME testrecurse COMMAND testrecurse WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n-    add_test(NAME testThreads COMMAND testThreads WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n-endif()\n-\n-if(LIBXML2_WITH_PYTHON)\n-    execute_process(\n-        COMMAND\n-        ${Python_EXECUTABLE}\n-        ${CMAKE_CURRENT_SOURCE_DIR}\/python\/generator.py\n-        ${CMAKE_CURRENT_SOURCE_DIR}\/doc\/libxml2-api.xml\n-        ${CMAKE_CURRENT_SOURCE_DIR}\/python\/libxml2-python-api.xml\n-        WORKING_DIRECTORY\n-        ${CMAKE_CURRENT_BINARY_DIR}\n-    )\n-    file(READ python\/libxml.py LIBXML_PY)\n-    file(WRITE ${CMAKE_CURRENT_BINARY_DIR}\/libxml2.py.in \"${LIBXML_PY}\")\n-    file(READ ${CMAKE_CURRENT_BINARY_DIR}\/libxml2class.py LIBXML2CLASS_PY)\n-    file(APPEND ${CMAKE_CURRENT_BINARY_DIR}\/libxml2.py.in \"${LIBXML2CLASS_PY}\")\n-    configure_file(${CMAKE_CURRENT_BINARY_DIR}\/libxml2.py.in libxml2.py COPYONLY)\n-    add_library(\n-        LibXml2Mod SHARED\n-        libxml2-py.c\n-        libxml2-py.h\n-        python\/libxml.c\n-        python\/libxml_wrap.h\n-        python\/types.c\n-    )\n-    target_include_directories(\n-        LibXml2Mod\n-        PUBLIC\n-        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}\/python>\n-    )\n-    target_link_libraries(LibXml2Mod LibXml2 Python::Python)\n-    set_target_properties(\n-        LibXml2Mod\n-        PROPERTIES\n-        IMPORT_PREFIX lib\n-        OUTPUT_NAME xml2mod\n-        PREFIX lib\n-        VERSION ${PROJECT_VERSION}\n-    )\n-    if (WIN32)\n-        set_target_properties(LibXml2Mod PROPERTIES SUFFIX \".pyd\")\n-    endif()\n-    install(\n-        TARGETS    LibXml2Mod\n-        ARCHIVE DESTINATION ${LIBXML2_PYTHON_INSTALL_DIR} COMPONENT development\n-        LIBRARY DESTINATION ${LIBXML2_PYTHON_INSTALL_DIR} COMPONENT runtime NAMELINK_COMPONENT development\n-        RUNTIME DESTINATION ${LIBXML2_PYTHON_INSTALL_DIR} COMPONENT runtime\n-    )\n-    if(MSVC AND BUILD_SHARED_LIBS)\n-        install(FILES $<TARGET_PDB_FILE:LibXml2Mod> DESTINATION ${LIBXML2_PYTHON_INSTALL_DIR} CONFIGURATIONS Debug RelWithDebInfo COMPONENT debug)\n-    endif()\n-    install(FILES python\/drv_libxml2.py DESTINATION ${LIBXML2_PYTHON_INSTALL_DIR} COMPONENT runtime)\n-    install(FILES ${CMAKE_CURRENT_BINARY_DIR}\/libxml2.py DESTINATION ${LIBXML2_PYTHON_INSTALL_DIR} COMPONENT runtime)\n-endif()\n-\n-install(FILES doc\/xml2-config.1 DESTINATION ${CMAKE_INSTALL_MANDIR}\/man1 COMPONENT documentation)\n-install(FILES doc\/xmlcatalog.1 DESTINATION ${CMAKE_INSTALL_MANDIR}\/man1 COMPONENT documentation)\n-install(FILES doc\/xmllint.1 DESTINATION ${CMAKE_INSTALL_MANDIR}\/man1 COMPONENT documentation)\n-install(DIRECTORY doc\/ DESTINATION ${CMAKE_INSTALL_DOCDIR} COMPONENT documentation\n-    PATTERN \"Makefile.*\" EXCLUDE\n-    PATTERN \"*.1\" EXCLUDE\n-    PATTERN \"*.py\" EXCLUDE\n-    PATTERN \"*.res\" EXCLUDE\n-    PATTERN \"*.xml\" EXCLUDE\n-    PATTERN \"*.xsl\" EXCLUDE)\n-\n-configure_package_config_file(\n-    libxml2-config.cmake.cmake.in libxml2-config.cmake\n-    INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}\/cmake\/libxml2-${PROJECT_VERSION}\n-)\n-\n-install(\n-    FILES ${CMAKE_CURRENT_BINARY_DIR}\/libxml2-config.cmake\n-    DESTINATION ${CMAKE_INSTALL_LIBDIR}\/cmake\/libxml2-${PROJECT_VERSION}\n-    COMPONENT development\n-)\n-\n-write_basic_package_version_file(\n-    ${CMAKE_CURRENT_BINARY_DIR}\/libxml2-config-version.cmake\n-    VERSION ${PROJECT_VERSION}\n-    COMPATIBILITY SameMajorVersion\n-)\n-\n-install(\n-    FILES ${CMAKE_CURRENT_BINARY_DIR}\/libxml2-config-version.cmake\n-    DESTINATION ${CMAKE_INSTALL_LIBDIR}\/cmake\/libxml2-${PROJECT_VERSION}\n-    COMPONENT development\n-)\n-\n-install(\n-    EXPORT LibXml2\n-    DESTINATION ${CMAKE_INSTALL_LIBDIR}\/cmake\/libxml2-${PROJECT_VERSION}\n-    NAMESPACE LibXml2::\n-    FILE libxml2-export.cmake\n-    COMPONENT development\n-)\n-\n-if(MSVC)\n-    configure_file(include\/win32config.h config.h COPYONLY)\n-else()\n-    configure_file(config.h.cmake.in config.h)\n-endif()\n-configure_file(include\/libxml\/xmlversion.h.in libxml\/xmlversion.h)\n-install(FILES ${CMAKE_CURRENT_BINARY_DIR}\/libxml\/xmlversion.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\/libxml2\/libxml COMPONENT development)\n-\n-if(LIBXML2_WITH_PYTHON)\n-    set(prefix \"${CMAKE_INSTALL_PREFIX}\")\n-    configure_file(python\/setup.py.in setup.py @ONLY)\n-endif()\n-\n-set(NON_PC_LIBS \"${THREAD_LIBS} ${ICONV_LIBS} ${LIBM} ${WINSOCK_LIBS} ${CRYPTO_LIBS}\")\n-list(APPEND XML_PC_LIBS \"${NON_PC_LIBS}\")\n-list(APPEND XML_PRIVATE_LIBS \"${NON_PC_LIBS}\")\n-list(REMOVE_DUPLICATES XML_PC_LIBS)\n-list(REMOVE_DUPLICATES XML_PRIVATE_LIBS)\n-\n-list(JOIN XML_PC_REQUIRES \" \" XML_PC_REQUIRES)\n-list(JOIN XML_PC_LIBS \" \" XML_PC_LIBS)\n-list(JOIN XML_PRIVATE_LIBS \" \" XML_PRIVATE_LIBS)\n-\n-set(XML_INCLUDEDIR \"-I\\${includedir}\/libxml2\")\n-set(XML_LIBDIR \"-L\\${libdir}\")\n-set(XML_LIBS \"-lxml2\")\n-\n-if(BUILD_SHARED_LIBS)\n-    set(XML_PC_PRIVATE \".private\")\n-    set(XML_PC_LIBS_PRIVATE \"\n-Libs.private:\")\n-else()\n-    target_compile_definitions(LibXml2 PUBLIC LIBXML_STATIC)\n-    set(XML_CFLAGS \"-DLIBXML_STATIC\")\n-    set(XML_PRIVATE_LIBS_NO_SHARED \"${XML_PRIVATE_LIBS}\")\n-endif()\n-\n-file(RELATIVE_PATH PACKAGE_RELATIVE_PATH \"${CMAKE_INSTALL_FULL_LIBDIR}\/pkgconfig\" \"${CMAKE_INSTALL_PREFIX}\")\n-string(REGEX REPLACE \"\/$\" \"\" PACKAGE_RELATIVE_PATH \"${PACKAGE_RELATIVE_PATH}\")\n-\n-if(WIN32)\n-    set(prefix \"\\${pcfiledir}\/${PACKAGE_RELATIVE_PATH}\")\n-else()\n-    set(prefix \"${CMAKE_INSTALL_PREFIX}\")\n-endif()\n-set(exec_prefix \"\\${prefix}\")\n-set(libdir \"\\${prefix}\/${CMAKE_INSTALL_LIBDIR}\")\n-set(includedir \"\\${prefix}\/${CMAKE_INSTALL_INCLUDEDIR}\")\n-configure_file(libxml-2.0.pc.in libxml-2.0.pc @ONLY)\n-install(FILES ${CMAKE_CURRENT_BINARY_DIR}\/libxml-2.0.pc DESTINATION ${CMAKE_INSTALL_LIBDIR}\/pkgconfig COMPONENT development)\n-\n-if(WIN32)\n-    set(prefix \"\\$(cd \\\"\\$(dirname \\\"\\$0\\\")\\\"; pwd -P)\/..\")\n-endif()\n-configure_file(xml2-config.in xml2-config @ONLY)\n-install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}\/xml2-config DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT development)\n-\n-if(UNIX)\n-    install(FILES ${CMAKE_CURRENT_SOURCE_DIR}\/libxml.m4 DESTINATION ${CMAKE_INSTALL_DATADIR}\/aclocal)\n-endif()\n-\n-set(XML_INCLUDEDIR \"-I${CMAKE_INSTALL_FULL_INCLUDEDIR}\/libxml2\")\n-set(XML_LIBDIR \"-L${CMAKE_INSTALL_FULL_LIBDIR}\")\n-\n-set(CPACK_COMPONENT_DEVELOPMENT_DEPENDS runtime)\n-set(CPACK_COMPONENT_PROGRAMS_DEPENDS runtime)\n-set(CPACK_DEB_COMPONENT_INSTALL ON)\n-set(CPACK_DEBIAN_DEVELOPMENT_PACKAGE_DEPENDS \"${PACKAGE_TARNAME}\")\n-set(CPACK_DEBIAN_DEVELOPMENT_PACKAGE_NAME \"${PACKAGE_TARNAME}-dev\")\n-set(CPACK_DEBIAN_DEVELOPMENT_PACKAGE_SECTION \"libdevel\")\n-set(CPACK_DEBIAN_PACKAGE_HOMEPAGE ${PACKAGE_URL})\n-set(CPACK_DEBIAN_PACKAGE_NAME ${PACKAGE_TARNAME})\n-set(CPACK_DEBIAN_PACKAGE_SECTION \"devel\")\n-set(CPACK_DEBIAN_PROGRAMS_PACKAGE_DEPENDS \"${PACKAGE_TARNAME}\")\n-set(CPACK_DEBIAN_PROGRAMS_PACKAGE_NAME \"${PACKAGE_TARNAME}-utils\")\n-set(CPACK_DEBIAN_PROGRAMS_PACKAGE_SECTION \"utils\")\n-set(CPACK_DEBIAN_RUNTIME_PACKAGE_NAME ${PACKAGE_TARNAME})\n-set(CPACK_DEBIAN_RUNTIME_PACKAGE_RECOMMENDS \"${PACKAGE_TARNAME}-utils\")\n-set(CPACK_DEBIAN_RUNTIME_PACKAGE_SECTION \"libs\")\n-set(CPACK_NSIS_PACKAGE_NAME ${PACKAGE_STRING})\n-set(CPACK_NSIS_URL_INFO_ABOUT ${PACKAGE_URL})\n-set(CPACK_PACKAGE_DISPLAY_NAME ${PACKAGE_STRING})\n-set(CPACK_PACKAGE_INSTALL_DIRECTORY \"${PACKAGE_TARNAME}-${PACKAGE_VERSION}\")\n-set(CPACK_PACKAGE_NAME ${PACKAGE_TARNAME})\n-set(CPACK_PACKAGE_VERSION ${PACKAGE_VERSION})\n-set(CPACK_PACKAGE_VERSION_MAJOR ${LIBXML_MAJOR_VERSION})\n-set(CPACK_PACKAGE_VERSION_MINOR ${LIBXML_MINOR_VERSION})\n-set(CPACK_PACKAGE_VERSION_PATCH ${LIBXML_MICRO_VERSION})\n-set(CPACK_RESOURCE_FILE_LICENSE ${CMAKE_CURRENT_SOURCE_DIR}\/Copyright)\n-set(CPACK_RPM_COMPONENT_INSTALL ON)\n-set(CPACK_RPM_development_PACKAGE_NAME \"${PACKAGE_NAME}-devel\")\n-set(CPACK_RPM_development_PACKAGE_REQUIRES \"${PACKAGE_NAME}\")\n-set(CPACK_RPM_PACKAGE_GROUP \"Development\/Libraries\")\n-set(CPACK_RPM_PACKAGE_NAME ${PACKAGE_TARNAME})\n-set(CPACK_RPM_PACKAGE_URL ${PACKAGE_URL})\n-set(CPACK_RPM_programs_PACKAGE_NAME \"${PACKAGE_NAME}-utils\")\n-set(CPACK_RPM_programs_PACKAGE_REQUIRES \"${PACKAGE_NAME}\")\n-set(CPACK_RPM_runtime_PACKAGE_NAME \"${PACKAGE_NAME}\")\n-set(CPACK_RPM_runtime_PACKAGE_SUGGESTS \"${PACKAGE_NAME}-utils\")\n-\n-include(CPack)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/CMakeLists.txt","additions":0,"deletions":736,"binary":false,"changes":736,"status":"deleted"},{"patch":"@@ -1,426 +0,0 @@\n-## Process this file with automake to produce Makefile.in\n-\n-ACLOCAL_AMFLAGS = -I m4\n-\n-SUBDIRS = include . doc example xstc\n-if WITH_PYTHON\n-SUBDIRS += python\n-endif\n-if WITH_GLOB\n-SUBDIRS += fuzz\n-endif\n-\n-DIST_SUBDIRS = include . doc example fuzz python xstc\n-\n-AM_CPPFLAGS = -I$(top_builddir)\/include -I$(srcdir)\/include -DSYSCONFDIR='\"$(sysconfdir)\"'\n-\n-check_PROGRAMS = \\\n-\trunsuite \\\n-\truntest \\\n-\trunxmlconf \\\n-\ttestModule \\\n-\ttestThreads \\\n-\ttestapi \\\n-\ttestchar \\\n-\ttestdict \\\n-\ttestlimits \\\n-\ttestparser \\\n-\ttestrecurse\n-\n-bin_PROGRAMS = xmllint xmlcatalog\n-\n-bin_SCRIPTS = xml2-config\n-\n-lib_LTLIBRARIES = libxml2.la\n-libxml2_la_CFLAGS = $(AM_CFLAGS) $(XML_PRIVATE_CFLAGS)\n-libxml2_la_LIBADD = $(XML_PRIVATE_LIBS)\n-\n-libxml2_la_LDFLAGS = $(AM_LDFLAGS) -no-undefined \\\n-\t\t     -version-info $(LIBXML_VERSION_INFO) \\\n-\t\t     $(MODULE_PLATFORM_LIBS)\n-if USE_VERSION_SCRIPT\n-libxml2_la_LDFLAGS += $(VERSION_SCRIPT_FLAGS)$(srcdir)\/libxml2.syms\n-endif\n-\n-libxml2_la_SOURCES = buf.c chvalid.c dict.c entities.c encoding.c error.c \\\n-\t\t     globals.c hash.c list.c parser.c parserInternals.c \\\n-\t\t     SAX2.c threads.c tree.c uri.c valid.c xmlIO.c \\\n-\t\t     xmlmemory.c xmlstring.c\n-if WITH_C14N_SOURCES\n-libxml2_la_SOURCES += c14n.c\n-endif\n-if WITH_CATALOG_SOURCES\n-libxml2_la_SOURCES += catalog.c\n-endif\n-if WITH_DEBUG_SOURCES\n-libxml2_la_SOURCES += debugXML.c\n-endif\n-if WITH_FTP_SOURCES\n-libxml2_la_SOURCES += nanoftp.c\n-endif\n-if WITH_HTML_SOURCES\n-libxml2_la_SOURCES += HTMLparser.c HTMLtree.c\n-endif\n-if WITH_HTTP_SOURCES\n-libxml2_la_SOURCES += nanohttp.c\n-endif\n-if WITH_LEGACY_SOURCES\n-libxml2_la_SOURCES += legacy.c\n-if WITH_SAX1_SOURCES\n-libxml2_la_SOURCES += SAX.c\n-endif\n-endif\n-if WITH_LZMA_SOURCES\n-libxml2_la_SOURCES += xzlib.c\n-endif\n-if WITH_MODULES_SOURCES\n-libxml2_la_SOURCES += xmlmodule.c\n-endif\n-if WITH_OUTPUT_SOURCES\n-libxml2_la_SOURCES += xmlsave.c\n-endif\n-if WITH_PATTERN_SOURCES\n-libxml2_la_SOURCES += pattern.c\n-endif\n-if WITH_READER_SOURCES\n-libxml2_la_SOURCES += xmlreader.c\n-endif\n-if WITH_REGEXPS_SOURCES\n-libxml2_la_SOURCES += xmlregexp.c xmlunicode.c\n-endif\n-if WITH_SCHEMAS_SOURCES\n-libxml2_la_SOURCES += relaxng.c xmlschemas.c xmlschemastypes.c\n-if !WITH_XPATH_SOURCES\n-libxml2_la_SOURCES += xpath.c\n-endif\n-endif\n-if WITH_SCHEMATRON_SOURCES\n-libxml2_la_SOURCES += schematron.c\n-endif\n-if WITH_WRITER_SOURCES\n-libxml2_la_SOURCES += xmlwriter.c\n-endif\n-if WITH_XINCLUDE_SOURCES\n-libxml2_la_SOURCES += xinclude.c\n-endif\n-if WITH_XPATH_SOURCES\n-libxml2_la_SOURCES += xpath.c\n-endif\n-if WITH_XPTR_SOURCES\n-libxml2_la_SOURCES += xlink.c xpointer.c\n-endif\n-\n-DEPS = libxml2.la\n-LDADDS = libxml2.la\n-\n-\n-m4datadir = $(datadir)\/aclocal\n-dist_m4data_DATA = libxml.m4\n-\n-runtest_SOURCES=runtest.c\n-runtest_DEPENDENCIES = $(DEPS)\n-runtest_LDADD= $(BASE_THREAD_LIBS) $(THREAD_LIBS) $(LDADDS)\n-\n-testrecurse_SOURCES=testrecurse.c\n-testrecurse_DEPENDENCIES = $(DEPS)\n-testrecurse_LDADD= $(LDADDS)\n-\n-testlimits_SOURCES=testlimits.c\n-testlimits_DEPENDENCIES = $(DEPS)\n-testlimits_LDADD= $(LDADDS)\n-\n-testchar_SOURCES=testchar.c\n-testchar_DEPENDENCIES = $(DEPS)\n-testchar_LDADD= $(LDADDS)\n-\n-testdict_SOURCES=testdict.c\n-testdict_DEPENDENCIES = $(DEPS)\n-testdict_LDADD= $(LDADDS)\n-\n-testparser_SOURCES=testparser.c\n-testparser_DEPENDENCIES = $(DEPS)\n-testparser_LDADD= $(LDADDS)\n-\n-runsuite_SOURCES=runsuite.c\n-runsuite_DEPENDENCIES = $(DEPS)\n-runsuite_LDADD= $(LDADDS)\n-\n-xmllint_SOURCES=xmllint.c\n-xmllint_CFLAGS = $(AM_CFLAGS) $(RDL_CFLAGS) $(ICONV_CFLAGS)\n-xmllint_DEPENDENCIES = $(DEPS)\n-xmllint_LDADD=  $(RDL_LIBS) $(LDADDS)\n-\n-xmlcatalog_SOURCES=xmlcatalog.c\n-xmlcatalog_CFLAGS = $(AM_CFLAGS) $(RDL_CFLAGS) $(ICONV_CFLAGS)\n-xmlcatalog_DEPENDENCIES = $(DEPS)\n-xmlcatalog_LDADD = $(RDL_LIBS) $(LDADDS)\n-\n-testThreads_SOURCES = testThreads.c\n-testThreads_DEPENDENCIES = $(DEPS)\n-testThreads_LDADD= $(BASE_THREAD_LIBS) $(THREAD_LIBS) $(LDADDS)\n-\n-testModule_SOURCES=testModule.c\n-testModule_DEPENDENCIES = $(DEPS)\n-testModule_LDADD= $(LDADDS)\n-\n-noinst_LTLIBRARIES = testdso.la\n-testdso_la_SOURCES = testdso.c\n-testdso_la_LDFLAGS = $(AM_LDFLAGS) \\\n-\t\t     -module -no-undefined -avoid-version -rpath $(libdir)\n-\n-# that one forces the rebuild when \"make rebuild\" is run on doc\/\n-rebuild_testapi:\n-\t-@(if [ \"$(PYTHON)\" != \"\" ] ; then \\\n-\t    $(PYTHON) $(srcdir)\/gentest.py $(srcdir) ; fi )\n-\n-testapi_SOURCES=testapi.c\n-testapi_DEPENDENCIES = $(DEPS)\n-testapi_LDADD= $(LDADDS)\n-\n-runxmlconf_SOURCES=runxmlconf.c\n-runxmlconf_DEPENDENCIES = $(DEPS)\n-runxmlconf_LDADD= $(LDADDS)\n-\n-check-local:\n-\t[ -d test   ] || $(LN_S) $(srcdir)\/test   .\n-\t[ -d result ] || $(LN_S) $(srcdir)\/result .\n-\t$(CHECKER) .\/runtest$(EXEEXT)\n-\t$(CHECKER) .\/testrecurse$(EXEEXT)\n-\t$(CHECKER) .\/testapi$(EXEEXT)\n-\t$(CHECKER) .\/testchar$(EXEEXT)\n-\t$(CHECKER) .\/testdict$(EXEEXT)\n-\t$(CHECKER) .\/testparser$(EXEEXT)\n-\t$(CHECKER) .\/testModule$(EXEEXT)\n-\t$(CHECKER) .\/testThreads$(EXEEXT)\n-\t$(CHECKER) .\/runxmlconf$(EXEEXT)\n-\t$(CHECKER) .\/runsuite$(EXEEXT)\n-\n-# Compatibility name of the check target\n-runtests: check\n-\n-check-valgrind valgrind:\n-\t@echo '## Running the regression tests under Valgrind'\n-\t@echo '## Go get a cup of coffee it is gonna take a while ...'\n-\t$(MAKE) CHECKER='valgrind -q' check\n-\n-asan:\n-\t@echo '## rebuilding for ASAN'\n-\t.\/configure CFLAGS=\"-fsanitize=address,undefined -Wformat -Werror=format-security -Werror=array-bounds -g\" CXXFLAGS=\"-fsanitize=address,undefined -Wformat -Werror=format-security -Werror=array-bounds -g\" LDFLAGS=\"-fsanitize=address,undefined\" CC=\"clang\" CXX=\"clang++\" --disable-shared ; OptimOff  ; $(MAKE) clean ; $(MAKE)\n-\n-# Old test suite. This should be ported to C.\n-\n-OLD_TESTS = Timingtests\n-if WITH_CATALOG_SOURCES\n-OLD_TESTS += Catatests\n-endif\n-if WITH_DEBUG_SOURCES\n-OLD_TESTS += Scripttests\n-endif\n-if WITH_SCHEMAS_SOURCES\n-if WITH_PYTHON\n-OLD_TESTS += RelaxNGPythonTests SchemasPythonTests\n-endif\n-endif\n-if WITH_SCHEMATRON_SOURCES\n-OLD_TESTS += Schematrontests\n-endif\n-if WITH_VALID_SOURCES\n-OLD_TESTS += VTimingtests\n-endif\n-\n-tests: $(OLD_TESTS)\n-\n-Scripttests : xmllint$(EXEEXT)\n-\t@echo \"## Scripts regression tests\"\n-\t@echo \"## Some of the base computations may be different if srcdir != .\"\n-\t-@(for i in $(srcdir)\/test\/scripts\/*.script ; do \\\n-\t  name=`basename $$i .script`; \\\n-\t  xml=$(srcdir)\/test\/scripts\/`basename $$i .script`.xml; \\\n-\t  if [ -f $$xml ] ; then \\\n-\t  if [ ! -f $(srcdir)\/result\/scripts\/$$name ] ; then \\\n-\t      echo New test file $$name ; \\\n-\t      $(CHECKER) $(top_builddir)\/xmllint --shell $$xml < $$i > $(srcdir)\/result\/scripts\/$$name 2> $(srcdir)\/result\/scripts\/$$name.err ; \\\n-\t  else \\\n-\t      log=`$(CHECKER) $(top_builddir)\/xmllint --shell $$xml < $$i > result.$$name 2> result.$$name.err ; \\\n-\t      diff $(srcdir)\/result\/scripts\/$$name result.$$name ; \\\n-\t      diff $(srcdir)\/result\/scripts\/$$name.err result.$$name.err` ; \\\n-\t      if [ -n \"$$log\" ] ; then echo $$name result ; echo \"$$log\" ; fi ; \\\n-\t      rm result.$$name result.$$name.err ; \\\n-\t  fi ; fi ; done)\n-\n-Catatests : xmlcatalog$(EXEEXT)\n-\t@echo \"## Catalog regression tests\"\n-\t-@(for i in $(srcdir)\/test\/catalogs\/*.script ; do \\\n-\t  name=`basename $$i .script`; \\\n-\t  xml=$(srcdir)\/test\/catalogs\/`basename $$i .script`.xml; \\\n-\t  if [ -f $$xml ] ; then \\\n-\t  if [ ! -f $(srcdir)\/result\/catalogs\/$$name ] ; then \\\n-\t      echo New test file $$name ; \\\n-\t      $(CHECKER) $(top_builddir)\/xmlcatalog --shell $$xml < $$i 2>&1 > $(srcdir)\/result\/catalogs\/$$name ; \\\n-\t  else \\\n-\t      log=`$(CHECKER) $(top_builddir)\/xmlcatalog --shell $$xml < $$i 2>&1 > result.$$name ; \\\n-\t      diff $(srcdir)\/result\/catalogs\/$$name result.$$name` ; \\\n-\t      if [ -n \"$$log\" ] ; then echo $$name result ; echo \"$$log\" ; fi ; \\\n-\t      rm result.$$name ; \\\n-\t  fi ; fi ; done)\n-\t-@(for i in $(srcdir)\/test\/catalogs\/*.script ; do \\\n-\t  name=`basename $$i .script`; \\\n-\t  sgml=$(srcdir)\/test\/catalogs\/`basename $$i .script`.sgml; \\\n-\t  if [ -f $$sgml ] ; then \\\n-\t  if [ ! -f $(srcdir)\/result\/catalogs\/$$name ] ; then \\\n-\t      echo New test file $$name ; \\\n-\t      $(CHECKER) $(top_builddir)\/xmlcatalog --shell $$sgml < $$i > $(srcdir)\/result\/catalogs\/$$name ; \\\n-\t  else \\\n-\t      log=`$(CHECKER) $(top_builddir)\/xmlcatalog --shell $$sgml < $$i > result.$$name ; \\\n-\t      diff $(srcdir)\/result\/catalogs\/$$name result.$$name` ; \\\n-\t      if [ -n \"$$log\" ] ; then echo $$name result ; echo \"$$log\" ; fi ; \\\n-\t      rm result.$$name ; \\\n-\t  fi ; fi ; done)\n-\t@echo \"## Add and del operations on XML Catalogs\"\n-\t-@($(CHECKER) $(top_builddir)\/xmlcatalog --create --noout $(srcdir)\/result\/catalogs\/mycatalog; \\\n-\t$(CHECKER) $(top_builddir)\/xmlcatalog --noout --add public Pubid sysid $(srcdir)\/result\/catalogs\/mycatalog; \\\n-\t$(CHECKER) $(top_builddir)\/xmlcatalog --noout --add public Pubid2 sysid2 $(srcdir)\/result\/catalogs\/mycatalog; \\\n-\t$(CHECKER) $(top_builddir)\/xmlcatalog --noout --add public Pubid3 sysid3 $(srcdir)\/result\/catalogs\/mycatalog; \\\n-\tdiff result\/catalogs\/mycatalog.full $(srcdir)\/result\/catalogs\/mycatalog; \\\n-\t$(CHECKER) $(top_builddir)\/xmlcatalog --noout --del sysid $(srcdir)\/result\/catalogs\/mycatalog; \\\n-\t$(CHECKER) $(top_builddir)\/xmlcatalog --noout --del sysid3 $(srcdir)\/result\/catalogs\/mycatalog; \\\n-\t$(CHECKER) $(top_builddir)\/xmlcatalog --noout --del sysid2 $(srcdir)\/result\/catalogs\/mycatalog; \\\n-\tdiff result\/catalogs\/mycatalog.empty $(srcdir)\/result\/catalogs\/mycatalog; \\\n-\trm -f $(srcdir)\/result\/catalogs\/mycatalog)\n-\n-dba100000.xml: dbgenattr.pl\n-\t@echo \"## generating dba100000.xml\"\n-\t@($(PERL) $(top_srcdir)\/dbgenattr.pl 100000 > dba100000.xml)\n-\n-Timingtests: xmllint$(EXEEXT) dba100000.xml\n-\t@echo \"## Timing tests to try to detect performance\"\n-\t@echo \"## as well a memory usage breakage when streaming\"\n-\t@echo \"## 1\/ using the file interface\"\n-\t@echo \"## 2\/ using the memory interface\"\n-\t@echo \"## 3\/ repeated DOM parsing\"\n-\t@echo \"## 4\/ repeated DOM validation\"\n-\t-@($(top_builddir)\/xmllint --stream --timing dba100000.xml; \\\n-\t   if [ \"$$MEM\" != \"\" ] ; then echo Using $$MEM bytes ; fi ; \\\n-\t   exit 0)\n-\t-@($(top_builddir)\/xmllint --stream --timing --memory dba100000.xml; \\\n-\t   if [ \"$$MEM\" != \"\" ] ; then echo Using $$MEM bytes ; fi ; \\\n-\t   exit 0)\n-\t-@($(top_builddir)\/xmllint --noout --timing --repeat $(srcdir)\/test\/valid\/REC-xml-19980210.xml; \\\n-\t   if [ \"$$MEM\" != \"\" ] ; then echo Using $$MEM bytes ; fi ; \\\n-\t   exit 0)\n-\n-VTimingtests: xmllint$(EXEEXT)\n-\t-@($(top_builddir)\/xmllint --noout --timing --valid --repeat $(srcdir)\/test\/valid\/REC-xml-19980210.xml; \\\n-\t   if [ \"$$MEM\" != \"\" ] ; then echo Using $$MEM bytes ; fi ; \\\n-\t   exit 0)\n-\n-Schematrontests: xmllint$(EXEEXT)\n-\t@echo \"## Schematron regression tests\"\n-\t-@(for i in $(srcdir)\/test\/schematron\/*.sct ; do \\\n-\t  name=`basename $$i | sed 's+\\.sct++'`; \\\n-\t  for j in $(srcdir)\/test\/schematron\/\"$$name\"_*.xml ; do \\\n-\t      if [ -f $$j ] ; then \\\n-\t      xno=`basename $$j | sed 's+.*_\\(.*\\).xml+\\1+'`; \\\n-\t      if [ ! -f $(srcdir)\/result\/schematron\/\"$$name\"_\"$$xno\" ]; \\\n-\t      then \\\n-\t\t  echo New test file \"$$name\"_\"$$xno\" ; \\\n-\t\t  $(CHECKER) $(top_builddir)\/xmllint$(EXEEXT) --schematron $$i $$j \\\n-\t\t    > $(srcdir)\/result\/schematron\/\"$$name\"_\"$$xno\" \\\n-\t\t    2> $(srcdir)\/result\/schematron\/\"$$name\"_\"$$xno\".err; \\\n-\t      else \\\n-\t          log=`$(CHECKER) $(top_builddir)\/xmllint$(EXEEXT) --schematron $$i $$j \\\n-\t\t    > res.$$name 2> err.$$name;\\\n-\t          diff $(srcdir)\/result\/schematron\/\"$$name\"_\"$$xno\" \\\n-\t\t       res.$$name;\\\n-\t          diff $(srcdir)\/result\/schematron\/\"$$name\"_\"$$xno\".err \\\n-\t\t       err.$$name | grep -v \"error detected at\";\\\n-\t\t  grep Unimplemented err.$$name`; \\\n-\t\t  if [ -n \"$$log\" ] ; then echo \"$$name\"_\"$$xno\" result ; echo \"$$log\" ; fi ; \\\n-\t          rm res.$$name err.$$name ; \\\n-\t       fi ; fi ; \\\n-\t  done; done)\n-\n-RelaxNGPythonTests:\n-\t@(if [ -x $(PYTHON) ] ; then \\\n-\t    PYTHONPATH=$(top_builddir)\/python:$(top_builddir)\/python\/.libs:$$PYTHONPATH ; \\\n-\t    export PYTHONPATH; \\\n-\t    LD_LIBRARY_PATH=\"$(top_builddir)\/.libs:$$LD_LIBRARY_PATH\" ; \\\n-\t    export LD_LIBRARY_PATH; \\\n-\t    echo \"## Relax-NG Python based test suite 1\" ; \\\n-\t    $(CHECKER) $(PYTHON) $(srcdir)\/check-relaxng-test-suite.py ; \\\n-\t    echo \"## Relax-NG Python based test suite 2\" ; \\\n-\t    $(CHECKER) $(PYTHON) $(srcdir)\/check-relaxng-test-suite2.py ; \\\n-\t  fi)\n-\n-SchemasPythonTests:\n-\t@(if [ -x $(PYTHON) ] ; then \\\n-\t    PYTHONPATH=$(top_builddir)\/python:$(top_builddir)\/python\/.libs:$$PYTHONPATH; \\\n-\t    export PYTHONPATH; \\\n-\t    LD_LIBRARY_PATH=\"$(top_builddir)\/.libs:$$LD_LIBRARY_PATH\" ; \\\n-\t    export LD_LIBRARY_PATH; \\\n-\t    echo \"## XML Schemas datatypes Python based test suite\" ; \\\n-\t    echo \"## It is normal to see 11 errors reported\" ; \\\n-\t    $(CHECKER) $(PYTHON) $(srcdir)\/check-xsddata-test-suite.py ; \\\n-\t  fi)\n-\t@(if [ -x $(PYTHON) -a -d xstc ] ; then cd xstc ; $(MAKE) CHECKER=\"$(CHECKER)\" pytests ; fi)\n-\n-cleanup:\n-\t-@(find . -name .\\#\\* -exec rm {} \\;)\n-\t-@(find . -name \\*.gcda -o -name \\*.gcno -exec rm -f {} \\;)\n-\t-@(find . -name \\*.orig -o -name \\*.rej -o -name \\*.old -exec rm -f {} \\;)\n-\n-dist-hook: cleanup\n-\t(cd $(srcdir) ; tar -cf - --exclude .git win32 os400 test result) | (cd $(distdir); tar xf -)\n-\n-CLEANFILES = runsuite.log runxmlconf.log test.out *.gcda *.gcno *.res\n-DISTCLEANFILES = COPYING missing.lst\n-\n-EXTRA_DIST = Copyright check-xml-test-suite.py gentest.py \\\n-\t     check-relaxng-test-suite.py check-relaxng-test-suite2.py \\\n-\t     check-xsddata-test-suite.py check-xinclude-test-suite.py \\\n-\t     libxml2-config.cmake.in autogen.sh \\\n-\t     libxml.h \\\n-\t     genUnicode.py \\\n-\t     dbgen.pl dbgenattr.pl \\\n-\t     libxml2.syms timsort.h \\\n-\t     README.zOS README.md \\\n-\t     CMakeLists.txt config.h.cmake.in libxml2-config.cmake.cmake.in \\\n-\t     meson.build meson_options.txt\n-\n-\n-pkgconfigdir = $(libdir)\/pkgconfig\n-pkgconfig_DATA = libxml-2.0.pc\n-\n-cmakedir = $(libdir)\/cmake\/libxml2\n-cmake_DATA = libxml2-config.cmake\n-\n-tst: tst.c\n-\t$(CC) $(CFLAGS) -Iinclude -o tst tst.c .libs\/libxml2.a -lpthread -lm -lz -llzma\n-\n-sparse: clean\n-\t$(MAKE) CC=cgcc\n-\n-#\n-# Coverage support, largely borrowed from libvirt\n-# Both binaries comes from the lcov package in Fedora\n-#\n-LCOV = \/usr\/bin\/lcov\n-GENHTML = \/usr\/bin\/genhtml\n-\n-cov: clean-cov\n-\tif [ \"`echo $(AM_LDFLAGS) | grep coverage`\" = \"\" ] ; then \\\n-\t    echo not configured with coverage; exit 1 ; fi\n-\tif [ ! -x $(LCOV) -o ! -x $(GENHTML) ] ; then \\\n-\t    echo Need $(LCOV) and $(GENHTML) excecutables; exit 1 ; fi\n-\t-@($(MAKE) check)\n-\t-@(.\/runsuite$(EXEEXT))\n-\tmkdir $(top_builddir)\/coverage\n-\t$(LCOV) -c -o $(top_builddir)\/coverage\/libxml2.info.tmp -d $(top_srcdir)\n-\t$(LCOV) -r $(top_builddir)\/coverage\/libxml2.info.tmp -o $(top_builddir)\/coverage\/libxml2.info *usr*\n-\trm $(top_builddir)\/coverage\/libxml2.info.tmp\n-\t$(GENHTML) -s -t \"libxml2\" -o $(top_builddir)\/coverage --legend $(top_builddir)\/coverage\/libxml2.info\n-\techo \"Coverage report is in $(top_builddir)\/coverage\/index.html\"\n-\n-clean-cov:\n-\trm -rf $(top_builddir)\/coverage\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/Makefile.am","additions":0,"deletions":426,"binary":false,"changes":426,"status":"deleted"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * SAX.c : Old SAX v1 handlers to build a tree.\n- *         Deprecated except for compatibility\n- *\n- * See Copyright for the status of this software.\n- *\n- * Daniel Veillard <daniel@veillard.com>\n- *\/\n-\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-#include <stdlib.h>\n-#include <string.h>\n-#include <libxml\/xmlmemory.h>\n-#include <libxml\/tree.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/valid.h>\n-#include <libxml\/entities.h>\n-#include <libxml\/xmlerror.h>\n-#include <libxml\/debugXML.h>\n-#include <libxml\/xmlIO.h>\n-#include <libxml\/SAX.h>\n-#include <libxml\/uri.h>\n-#include <libxml\/valid.h>\n-#include <libxml\/HTMLtree.h>\n-#include <libxml\/SAX2.h>\n-\n-#ifdef LIBXML_LEGACY_ENABLED\n-#ifdef LIBXML_SAX1_ENABLED\n-\/**\n- * initxmlDefaultSAXHandler:\n- * @hdlr:  the SAX handler\n- * @warning:  flag if non-zero sets the handler warning procedure\n- *\n- * Initialize the default XML SAX version 1 handler\n- * DEPRECATED: use xmlSAX2InitDefaultSAXHandler() for the new SAX2 blocks\n- *\/\n-void\n-initxmlDefaultSAXHandler(xmlSAXHandlerV1 *hdlr, int warning)\n-{\n-\n-    if(hdlr->initialized == 1)\n-    return;\n-\n-    hdlr->internalSubset = xmlSAX2InternalSubset;\n-    hdlr->externalSubset = xmlSAX2ExternalSubset;\n-    hdlr->isStandalone = xmlSAX2IsStandalone;\n-    hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;\n-    hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;\n-    hdlr->resolveEntity = xmlSAX2ResolveEntity;\n-    hdlr->getEntity = xmlSAX2GetEntity;\n-    hdlr->getParameterEntity = xmlSAX2GetParameterEntity;\n-    hdlr->entityDecl = xmlSAX2EntityDecl;\n-    hdlr->attributeDecl = xmlSAX2AttributeDecl;\n-    hdlr->elementDecl = xmlSAX2ElementDecl;\n-    hdlr->notationDecl = xmlSAX2NotationDecl;\n-    hdlr->unparsedEntityDecl = xmlSAX2UnparsedEntityDecl;\n-    hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;\n-    hdlr->startDocument = xmlSAX2StartDocument;\n-    hdlr->endDocument = xmlSAX2EndDocument;\n-    hdlr->startElement = xmlSAX2StartElement;\n-    hdlr->endElement = xmlSAX2EndElement;\n-    hdlr->reference = xmlSAX2Reference;\n-    hdlr->characters = xmlSAX2Characters;\n-    hdlr->cdataBlock = xmlSAX2CDataBlock;\n-    hdlr->ignorableWhitespace = xmlSAX2Characters;\n-    hdlr->processingInstruction = xmlSAX2ProcessingInstruction;\n-    if (warning == 0)\n-    hdlr->warning = NULL;\n-    else\n-    hdlr->warning = xmlParserWarning;\n-    hdlr->error = xmlParserError;\n-    hdlr->fatalError = xmlParserError;\n-\n-    hdlr->initialized = 1;\n-}\n-\n-#ifdef LIBXML_HTML_ENABLED\n-\n-\/**\n- * inithtmlDefaultSAXHandler:\n- * @hdlr:  the SAX handler\n- *\n- * Initialize the default HTML SAX version 1 handler\n- * DEPRECATED: use xmlSAX2InitHtmlDefaultSAXHandler() for the new SAX2 blocks\n- *\/\n-void\n-inithtmlDefaultSAXHandler(xmlSAXHandlerV1 *hdlr)\n-{\n-    if(hdlr->initialized == 1)\n-    return;\n-\n-    hdlr->internalSubset = xmlSAX2InternalSubset;\n-    hdlr->externalSubset = NULL;\n-    hdlr->isStandalone = NULL;\n-    hdlr->hasInternalSubset = NULL;\n-    hdlr->hasExternalSubset = NULL;\n-    hdlr->resolveEntity = NULL;\n-    hdlr->getEntity = xmlSAX2GetEntity;\n-    hdlr->getParameterEntity = NULL;\n-    hdlr->entityDecl = NULL;\n-    hdlr->attributeDecl = NULL;\n-    hdlr->elementDecl = NULL;\n-    hdlr->notationDecl = NULL;\n-    hdlr->unparsedEntityDecl = NULL;\n-    hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;\n-    hdlr->startDocument = xmlSAX2StartDocument;\n-    hdlr->endDocument = xmlSAX2EndDocument;\n-    hdlr->startElement = xmlSAX2StartElement;\n-    hdlr->endElement = xmlSAX2EndElement;\n-    hdlr->reference = NULL;\n-    hdlr->characters = xmlSAX2Characters;\n-    hdlr->cdataBlock = xmlSAX2CDataBlock;\n-    hdlr->ignorableWhitespace = xmlSAX2IgnorableWhitespace;\n-    hdlr->processingInstruction = xmlSAX2ProcessingInstruction;\n-    hdlr->comment = xmlSAX2Comment;\n-    hdlr->warning = xmlParserWarning;\n-    hdlr->error = xmlParserError;\n-    hdlr->fatalError = xmlParserError;\n-\n-    hdlr->initialized = 1;\n-}\n-\n-#endif \/* LIBXML_HTML_ENABLED *\/\n-\n-#endif \/* LIBXML_SAX1_ENABLED *\/\n-\n-#endif \/* LIBXML_LEGACY_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/SAX.c","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -1,2215 +0,0 @@\n-\/*\n- * \"Canonical XML\" implementation\n- * http:\/\/www.w3.org\/TR\/xml-c14n\n- *\n- * \"Exclusive XML Canonicalization\" implementation\n- * http:\/\/www.w3.org\/TR\/xml-exc-c14n\n- *\n- * See Copyright for the status of this software.\n- *\n- * Author: Aleksey Sanin <aleksey@aleksey.com>\n- *\/\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-#ifdef LIBXML_C14N_ENABLED\n-\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include <libxml\/tree.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/uri.h>\n-#include <libxml\/xmlerror.h>\n-#include <libxml\/xpathInternals.h>\n-#include <libxml\/c14n.h>\n-\n-#include \"private\/error.h\"\n-#include \"private\/io.h\"\n-\n-\/************************************************************************\n- *                                    *\n- *        Some declaration better left private ATM        *\n- *                                    *\n- ************************************************************************\/\n-\n-typedef enum {\n-    XMLC14N_BEFORE_DOCUMENT_ELEMENT = 0,\n-    XMLC14N_INSIDE_DOCUMENT_ELEMENT = 1,\n-    XMLC14N_AFTER_DOCUMENT_ELEMENT = 2\n-} xmlC14NPosition;\n-\n-typedef struct _xmlC14NVisibleNsStack {\n-    int nsCurEnd;           \/* number of nodes in the set *\/\n-    int nsPrevStart;        \/* the beginning of the stack for previous visible node *\/\n-    int nsPrevEnd;          \/* the end of the stack for previous visible node *\/\n-    int nsMax;              \/* size of the array as allocated *\/\n-    xmlNsPtr    *nsTab;        \/* array of ns in no particular order *\/\n-    xmlNodePtr    *nodeTab;   \/* array of nodes in no particular order *\/\n-} xmlC14NVisibleNsStack, *xmlC14NVisibleNsStackPtr;\n-\n-typedef struct _xmlC14NCtx {\n-    \/* input parameters *\/\n-    xmlDocPtr doc;\n-    xmlC14NIsVisibleCallback is_visible_callback;\n-    void* user_data;\n-    int with_comments;\n-    xmlOutputBufferPtr buf;\n-\n-    \/* position in the XML document *\/\n-    xmlC14NPosition pos;\n-    int parent_is_doc;\n-    xmlC14NVisibleNsStackPtr ns_rendered;\n-\n-    \/* C14N mode *\/\n-    xmlC14NMode mode;\n-\n-    \/* exclusive canonicalization *\/\n-    xmlChar **inclusive_ns_prefixes;\n-\n-    \/* error number *\/\n-    int error;\n-} xmlC14NCtx, *xmlC14NCtxPtr;\n-\n-static xmlC14NVisibleNsStackPtr    xmlC14NVisibleNsStackCreate    (void);\n-static void     xmlC14NVisibleNsStackDestroy    (xmlC14NVisibleNsStackPtr cur);\n-static int      xmlC14NVisibleNsStackAdd        (xmlC14NVisibleNsStackPtr cur,\n-                                                 xmlNsPtr ns,\n-                                                 xmlNodePtr node);\n-static void            xmlC14NVisibleNsStackSave    (xmlC14NVisibleNsStackPtr cur,\n-                                 xmlC14NVisibleNsStackPtr state);\n-static void            xmlC14NVisibleNsStackRestore    (xmlC14NVisibleNsStackPtr cur,\n-                                 xmlC14NVisibleNsStackPtr state);\n-static void            xmlC14NVisibleNsStackShift    (xmlC14NVisibleNsStackPtr cur);\n-static int            xmlC14NVisibleNsStackFind    (xmlC14NVisibleNsStackPtr cur,\n-                                 xmlNsPtr ns);\n-static int            xmlExcC14NVisibleNsStackFind    (xmlC14NVisibleNsStackPtr cur,\n-                                 xmlNsPtr ns,\n-                                 xmlC14NCtxPtr ctx);\n-\n-static int            xmlC14NIsNodeInNodeset        (void *user_data,\n-                                 xmlNodePtr node,\n-                                 xmlNodePtr parent);\n-\n-\n-\n-static int xmlC14NProcessNode(xmlC14NCtxPtr ctx, xmlNodePtr cur);\n-static int xmlC14NProcessNodeList(xmlC14NCtxPtr ctx, xmlNodePtr cur);\n-typedef enum {\n-    XMLC14N_NORMALIZE_ATTR = 0,\n-    XMLC14N_NORMALIZE_COMMENT = 1,\n-    XMLC14N_NORMALIZE_PI = 2,\n-    XMLC14N_NORMALIZE_TEXT = 3\n-} xmlC14NNormalizationMode;\n-\n-static xmlChar *xmlC11NNormalizeString(const xmlChar * input,\n-                                       xmlC14NNormalizationMode mode);\n-\n-#define    xmlC11NNormalizeAttr( a ) \\\n-    xmlC11NNormalizeString((a), XMLC14N_NORMALIZE_ATTR)\n-#define    xmlC11NNormalizeComment( a ) \\\n-    xmlC11NNormalizeString((a), XMLC14N_NORMALIZE_COMMENT)\n-#define    xmlC11NNormalizePI( a )    \\\n-    xmlC11NNormalizeString((a), XMLC14N_NORMALIZE_PI)\n-#define    xmlC11NNormalizeText( a ) \\\n-    xmlC11NNormalizeString((a), XMLC14N_NORMALIZE_TEXT)\n-\n-#define    xmlC14NIsVisible( ctx, node, parent ) \\\n-     (((ctx)->is_visible_callback != NULL) ? \\\n-    (ctx)->is_visible_callback((ctx)->user_data, \\\n-        (xmlNodePtr)(node), (xmlNodePtr)(parent)) : 1)\n-\n-#define    xmlC14NIsExclusive( ctx ) \\\n-    ( (ctx)->mode == XML_C14N_EXCLUSIVE_1_0 )\n-\n-\/************************************************************************\n- *                                    *\n- *        Some factorized error routines                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlC14NErrMemory:\n- * @extra:  extra information\n- *\n- * Handle a redefinition of memory error\n- *\/\n-static void\n-xmlC14NErrMemory(xmlC14NCtxPtr ctxt)\n-{\n-    if (ctxt != NULL)\n-        ctxt->error = XML_ERR_NO_MEMORY;\n-\n-    xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_C14N, NULL);\n-}\n-\n-static void\n-xmlC14NErrFull(xmlC14NCtxPtr ctxt, xmlNodePtr node, int code, const char *str1,\n-               const char *msg, ...)\n-{\n-    va_list ap;\n-    int res;\n-\n-    if (ctxt != NULL)\n-        ctxt->error = code;\n-\n-    va_start(ap, msg);\n-    res = xmlVRaiseError(NULL, NULL, NULL, ctxt, node,\n-                         XML_FROM_C14N, code, XML_ERR_ERROR, NULL, 0,\n-                         str1, NULL, NULL, 0, 0,\n-                         msg, ap);\n-    va_end(ap);\n-    if (res < 0)\n-        xmlC14NErrMemory(ctxt);\n-}\n-\n-\/**\n- * xmlC14NErrParam:\n- * @extra:  extra information\n- *\n- * Handle a param error\n- *\/\n-static void\n-xmlC14NErrParam(xmlC14NCtxPtr ctxt)\n-{\n-    xmlC14NErrFull(ctxt, NULL, XML_ERR_ARGUMENT, NULL,\n-           \"Invalid argument\\n\", NULL);\n-}\n-\n-\/**\n- * xmlC14NErrInvalidNode:\n- * @extra:  extra information\n- *\n- * Handle an invalid node error\n- *\/\n-static void\n-xmlC14NErrInvalidNode(xmlC14NCtxPtr ctxt, const char *node_type,\n-                      const char *extra)\n-{\n-    xmlC14NErrFull(ctxt, NULL, XML_C14N_INVALID_NODE, extra,\n-           \"Node %s is invalid here : %s\\n\", node_type, extra);\n-}\n-\n-\/**\n- * xmlC14NErrUnknownNode:\n- * @extra:  extra information\n- *\n- * Handle an unknown node error\n- *\/\n-static void\n-xmlC14NErrUnknownNode(xmlC14NCtxPtr ctxt, int node_type, const char *extra)\n-{\n-    xmlC14NErrFull(ctxt, NULL, XML_C14N_UNKNOW_NODE, extra,\n-           \"Unknown node type %d found : %s\\n\", node_type, extra);\n-}\n-\n-\/**\n- * xmlC14NErrRelativeNamespace:\n- * @extra:  extra information\n- *\n- * Handle a relative namespace error\n- *\/\n-static void\n-xmlC14NErrRelativeNamespace(xmlC14NCtxPtr ctxt, const char *ns_uri)\n-{\n-    xmlC14NErrFull(ctxt, NULL, XML_C14N_RELATIVE_NAMESPACE, ns_uri,\n-           \"Relative namespace UR is invalid here : %s\\n\", ns_uri);\n-}\n-\n-\n-\n-\/**\n- * xmlC14NErr:\n- * @ctxt:  a C14N evaluation context\n- * @node:  the context node\n- * @error:  the error code\n- * @msg:  the message\n- * @extra:  extra information\n- *\n- * Handle an error\n- *\/\n-static void\n-xmlC14NErr(xmlC14NCtxPtr ctxt, xmlNodePtr node, int error,\n-           const char * msg)\n-{\n-    xmlC14NErrFull(ctxt, node, error, NULL, \"%s\", msg);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        The implementation internals                *\n- *                                    *\n- ************************************************************************\/\n-#define XML_NAMESPACES_DEFAULT        16\n-\n-static int\n-xmlC14NIsNodeInNodeset(void *user_data, xmlNodePtr node, xmlNodePtr parent) {\n-    xmlNodeSetPtr nodes = (xmlNodeSetPtr) user_data;\n-    if((nodes != NULL) && (node != NULL)) {\n-    if(node->type != XML_NAMESPACE_DECL) {\n-        return(xmlXPathNodeSetContains(nodes, node));\n-    } else {\n-        xmlNs ns;\n-\n-        memcpy(&ns, node, sizeof(ns));\n-\n-        \/* this is a libxml hack! check xpath.c for details *\/\n-        if((parent != NULL) && (parent->type == XML_ATTRIBUTE_NODE)) {\n-        ns.next = (xmlNsPtr)parent->parent;\n-        } else {\n-        ns.next = (xmlNsPtr)parent;\n-        }\n-\n-        \/*\n-         * If the input is an XPath node-set, then the node-set must explicitly\n-         * contain every node to be rendered to the canonical form.\n-         *\/\n-        return(xmlXPathNodeSetContains(nodes, (xmlNodePtr)&ns));\n-    }\n-    }\n-    return(1);\n-}\n-\n-static xmlC14NVisibleNsStackPtr\n-xmlC14NVisibleNsStackCreate(void) {\n-    xmlC14NVisibleNsStackPtr ret;\n-\n-    ret = (xmlC14NVisibleNsStackPtr) xmlMalloc(sizeof(xmlC14NVisibleNsStack));\n-    if (ret == NULL)\n-    return(NULL);\n-    memset(ret, 0, sizeof(xmlC14NVisibleNsStack));\n-    return(ret);\n-}\n-\n-static void\n-xmlC14NVisibleNsStackDestroy(xmlC14NVisibleNsStackPtr cur) {\n-    if(cur == NULL) {\n-        xmlC14NErrParam(NULL);\n-        return;\n-    }\n-    if(cur->nsTab != NULL) {\n-    memset(cur->nsTab, 0, cur->nsMax * sizeof(xmlNsPtr));\n-    xmlFree(cur->nsTab);\n-    }\n-    if(cur->nodeTab != NULL) {\n-    memset(cur->nodeTab, 0, cur->nsMax * sizeof(xmlNodePtr));\n-    xmlFree(cur->nodeTab);\n-    }\n-    memset(cur, 0, sizeof(xmlC14NVisibleNsStack));\n-    xmlFree(cur);\n-\n-}\n-\n-static int\n-xmlC14NVisibleNsStackAdd(xmlC14NVisibleNsStackPtr cur, xmlNsPtr ns, xmlNodePtr node) {\n-    if((cur == NULL) ||\n-       ((cur->nsTab == NULL) && (cur->nodeTab != NULL)) ||\n-       ((cur->nsTab != NULL) && (cur->nodeTab == NULL)))\n-    return (1);\n-\n-    if ((cur->nsTab == NULL) && (cur->nodeTab == NULL)) {\n-        cur->nsTab = (xmlNsPtr*) xmlMalloc(XML_NAMESPACES_DEFAULT * sizeof(xmlNsPtr));\n-        cur->nodeTab = (xmlNodePtr*) xmlMalloc(XML_NAMESPACES_DEFAULT * sizeof(xmlNodePtr));\n-    if ((cur->nsTab == NULL) || (cur->nodeTab == NULL))\n-        return (-1);\n-    memset(cur->nsTab, 0 , XML_NAMESPACES_DEFAULT * sizeof(xmlNsPtr));\n-    memset(cur->nodeTab, 0 , XML_NAMESPACES_DEFAULT * sizeof(xmlNodePtr));\n-        cur->nsMax = XML_NAMESPACES_DEFAULT;\n-    } else if(cur->nsMax == cur->nsCurEnd) {\n-    void *tmp;\n-    int tmpSize;\n-\n-    tmpSize = 2 * cur->nsMax;\n-    tmp = xmlRealloc(cur->nsTab, tmpSize * sizeof(xmlNsPtr));\n-    if (tmp == NULL)\n-        return (-1);\n-    cur->nsTab = (xmlNsPtr*)tmp;\n-\n-    tmp = xmlRealloc(cur->nodeTab, tmpSize * sizeof(xmlNodePtr));\n-    if (tmp == NULL)\n-        return (-1);\n-    cur->nodeTab = (xmlNodePtr*)tmp;\n-\n-    cur->nsMax = tmpSize;\n-    }\n-    cur->nsTab[cur->nsCurEnd] = ns;\n-    cur->nodeTab[cur->nsCurEnd] = node;\n-\n-    ++cur->nsCurEnd;\n-\n-    return (0);\n-}\n-\n-static void\n-xmlC14NVisibleNsStackSave(xmlC14NVisibleNsStackPtr cur, xmlC14NVisibleNsStackPtr state) {\n-    if((cur == NULL) || (state == NULL)) {\n-        xmlC14NErrParam(NULL);\n-    return;\n-    }\n-\n-    state->nsCurEnd = cur->nsCurEnd;\n-    state->nsPrevStart = cur->nsPrevStart;\n-    state->nsPrevEnd = cur->nsPrevEnd;\n-}\n-\n-static void\n-xmlC14NVisibleNsStackRestore(xmlC14NVisibleNsStackPtr cur, xmlC14NVisibleNsStackPtr state) {\n-    if((cur == NULL) || (state == NULL)) {\n-        xmlC14NErrParam(NULL);\n-    return;\n-    }\n-    cur->nsCurEnd = state->nsCurEnd;\n-    cur->nsPrevStart = state->nsPrevStart;\n-    cur->nsPrevEnd = state->nsPrevEnd;\n-}\n-\n-static void\n-xmlC14NVisibleNsStackShift(xmlC14NVisibleNsStackPtr cur) {\n-    if(cur == NULL) {\n-        xmlC14NErrParam(NULL);\n-    return;\n-    }\n-    cur->nsPrevStart = cur->nsPrevEnd;\n-    cur->nsPrevEnd = cur->nsCurEnd;\n-}\n-\n-static int\n-xmlC14NStrEqual(const xmlChar *str1, const xmlChar *str2) {\n-    if (str1 == str2) return(1);\n-    if (str1 == NULL) return((*str2) == '\\0');\n-    if (str2 == NULL) return((*str1) == '\\0');\n-    do {\n-    if (*str1++ != *str2) return(0);\n-    } while (*str2++);\n-    return(1);\n-}\n-\n-\/**\n- * xmlC14NVisibleNsStackFind:\n- * @ctx:        the C14N context\n- * @ns:            the namespace to check\n- *\n- * Checks whether the given namespace was already rendered or not\n- *\n- * Returns 1 if we already wrote this namespace or 0 otherwise\n- *\/\n-static int\n-xmlC14NVisibleNsStackFind(xmlC14NVisibleNsStackPtr cur, xmlNsPtr ns)\n-{\n-    int i;\n-    const xmlChar *prefix;\n-    const xmlChar *href;\n-    int has_empty_ns;\n-\n-    if(cur == NULL) {\n-        xmlC14NErrParam(NULL);\n-        return (0);\n-    }\n-\n-    \/*\n-     * if the default namespace xmlns=\"\" is not defined yet then\n-     * we do not want to print it out\n-     *\/\n-    prefix = ((ns == NULL) || (ns->prefix == NULL)) ? BAD_CAST \"\" : ns->prefix;\n-    href = ((ns == NULL) || (ns->href == NULL)) ? BAD_CAST \"\" : ns->href;\n-    has_empty_ns = (xmlC14NStrEqual(prefix, NULL) && xmlC14NStrEqual(href, NULL));\n-\n-    if (cur->nsTab != NULL) {\n-    int start = (has_empty_ns) ? 0 : cur->nsPrevStart;\n-        for (i = cur->nsCurEnd - 1; i >= start; --i) {\n-            xmlNsPtr ns1 = cur->nsTab[i];\n-\n-        if(xmlC14NStrEqual(prefix, (ns1 != NULL) ? ns1->prefix : NULL)) {\n-        return(xmlC14NStrEqual(href, (ns1 != NULL) ? ns1->href : NULL));\n-        }\n-        }\n-    }\n-    return(has_empty_ns);\n-}\n-\n-static int\n-xmlExcC14NVisibleNsStackFind(xmlC14NVisibleNsStackPtr cur, xmlNsPtr ns, xmlC14NCtxPtr ctx) {\n-    int i;\n-    const xmlChar *prefix;\n-    const xmlChar *href;\n-    int has_empty_ns;\n-\n-    if(cur == NULL) {\n-        xmlC14NErrParam(ctx);\n-        return (0);\n-    }\n-\n-    \/*\n-     * if the default namespace xmlns=\"\" is not defined yet then\n-     * we do not want to print it out\n-     *\/\n-    prefix = ((ns == NULL) || (ns->prefix == NULL)) ? BAD_CAST \"\" : ns->prefix;\n-    href = ((ns == NULL) || (ns->href == NULL)) ? BAD_CAST \"\" : ns->href;\n-    has_empty_ns = (xmlC14NStrEqual(prefix, NULL) && xmlC14NStrEqual(href, NULL));\n-\n-    if (cur->nsTab != NULL) {\n-    int start = 0;\n-        for (i = cur->nsCurEnd - 1; i >= start; --i) {\n-            xmlNsPtr ns1 = cur->nsTab[i];\n-\n-        if(xmlC14NStrEqual(prefix, (ns1 != NULL) ? ns1->prefix : NULL)) {\n-        if(xmlC14NStrEqual(href, (ns1 != NULL) ? ns1->href : NULL)) {\n-            return(xmlC14NIsVisible(ctx, ns1, cur->nodeTab[i]));\n-        } else {\n-            return(0);\n-        }\n-        }\n-        }\n-    }\n-    return(has_empty_ns);\n-}\n-\n-\n-\n-\n-\/**\n- * xmlC14NIsXmlNs:\n- * @ns:        the namespace to check\n- *\n- * Checks whether the given namespace is a default \"xml:\" namespace\n- * with href=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n- *\n- * Returns 1 if the node is default or 0 otherwise\n- *\/\n-\n-\/* todo: make it a define? *\/\n-static int\n-xmlC14NIsXmlNs(xmlNsPtr ns)\n-{\n-    return ((ns != NULL) &&\n-            (xmlStrEqual(ns->prefix, BAD_CAST \"xml\")) &&\n-            (xmlStrEqual(ns->href, XML_XML_NAMESPACE)));\n-}\n-\n-\n-\/**\n- * xmlC14NNsCompare:\n- * @ns1:        the pointer to first namespace\n- * @ns2:        the pointer to second namespace\n- *\n- * Compares the namespaces by names (prefixes).\n- *\n- * Returns -1 if ns1 < ns2, 0 if ns1 == ns2 or 1 if ns1 > ns2.\n- *\/\n-static int\n-xmlC14NNsCompare(const void *data1, const void *data2)\n-{\n-    const xmlNs *ns1 = data1;\n-    const xmlNs *ns2 = data2;\n-    if (ns1 == ns2)\n-        return (0);\n-    if (ns1 == NULL)\n-        return (-1);\n-    if (ns2 == NULL)\n-        return (1);\n-\n-    return (xmlStrcmp(ns1->prefix, ns2->prefix));\n-}\n-\n-\n-\/**\n- * xmlC14NPrintNamespaces:\n- * @ns:            the pointer to namespace\n- * @ctx:        the C14N context\n- *\n- * Prints the given namespace to the output buffer from C14N context.\n- *\n- * Returns 1 on success or 0 on fail.\n- *\/\n-static int\n-xmlC14NPrintNamespaces(const xmlNs *ns, xmlC14NCtxPtr ctx)\n-{\n-\n-    if ((ns == NULL) || (ctx == NULL)) {\n-        xmlC14NErrParam(ctx);\n-        return 0;\n-    }\n-\n-    if (ns->prefix != NULL) {\n-        xmlOutputBufferWriteString(ctx->buf, \" xmlns:\");\n-        xmlOutputBufferWriteString(ctx->buf, (const char *) ns->prefix);\n-        xmlOutputBufferWriteString(ctx->buf, \"=\");\n-    } else {\n-        xmlOutputBufferWriteString(ctx->buf, \" xmlns=\");\n-    }\n-    if(ns->href != NULL) {\n-    xmlOutputBufferWriteQuotedString(ctx->buf, ns->href);\n-    } else {\n-        xmlOutputBufferWriteString(ctx->buf, \"\\\"\\\"\");\n-    }\n-    return (1);\n-}\n-\n-static int\n-xmlC14NPrintNamespacesWalker(const void *ns, void *ctx) {\n-    return xmlC14NPrintNamespaces(ns, ctx);\n-}\n-\n-\/**\n- * xmlC14NProcessNamespacesAxis:\n- * @ctx:        the C14N context\n- * @node:        the current node\n- *\n- * Prints out canonical namespace axis of the current node to the\n- * buffer from C14N context as follows\n- *\n- * Canonical XML v 1.0 (http:\/\/www.w3.org\/TR\/xml-c14n)\n- *\n- * Namespace Axis\n- * Consider a list L containing only namespace nodes in the\n- * axis and in the node-set in lexicographic order (ascending). To begin\n- * processing L, if the first node is not the default namespace node (a node\n- * with no namespace URI and no local name), then generate a space followed\n- * by xmlns=\"\" if and only if the following conditions are met:\n- *    - the element E that owns the axis is in the node-set\n- *    - The nearest ancestor element of E in the node-set has a default\n- *        namespace node in the node-set (default namespace nodes always\n- *      have non-empty values in XPath)\n- * The latter condition eliminates unnecessary occurrences of xmlns=\"\" in\n- * the canonical form since an element only receives an xmlns=\"\" if its\n- * default namespace is empty and if it has an immediate parent in the\n- * canonical form that has a non-empty default namespace. To finish\n- * processing  L, simply process every namespace node in L, except omit\n- * namespace node with local name xml, which defines the xml prefix,\n- * if its string value is http:\/\/www.w3.org\/XML\/1998\/namespace.\n- *\n- * Exclusive XML Canonicalization v 1.0 (http:\/\/www.w3.org\/TR\/xml-exc-c14n)\n- * Canonical XML applied to a document subset requires the search of the\n- * ancestor nodes of each orphan element node for attributes in the xml\n- * namespace, such as xml:lang and xml:space. These are copied into the\n- * element node except if a declaration of the same attribute is already\n- * in the attribute axis of the element (whether or not it is included in\n- * the document subset). This search and copying are omitted from the\n- * Exclusive XML Canonicalization method.\n- *\n- * Returns 0 on success or -1 on fail.\n- *\/\n-static int\n-xmlC14NProcessNamespacesAxis(xmlC14NCtxPtr ctx, xmlNodePtr cur, int visible)\n-{\n-    xmlNodePtr n;\n-    xmlNsPtr ns, tmp;\n-    xmlListPtr list;\n-    int already_rendered;\n-    int has_empty_ns = 0;\n-\n-    if ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {\n-        xmlC14NErrParam(ctx);\n-        return (-1);\n-    }\n-\n-    \/*\n-     * Create a sorted list to store element namespaces\n-     *\/\n-    list = xmlListCreate(NULL, xmlC14NNsCompare);\n-    if (list == NULL) {\n-        xmlC14NErrMemory(ctx);\n-        return (-1);\n-    }\n-\n-    \/* check all namespaces *\/\n-    for(n = cur; n != NULL; n = n->parent) {\n-    for(ns = n->nsDef; ns != NULL; ns = ns->next) {\n-        tmp = xmlSearchNs(cur->doc, cur, ns->prefix);\n-\n-        if((tmp == ns) && !xmlC14NIsXmlNs(ns) && xmlC14NIsVisible(ctx, ns, cur)) {\n-        already_rendered = xmlC14NVisibleNsStackFind(ctx->ns_rendered, ns);\n-        if(visible) {\n-                if (xmlC14NVisibleNsStackAdd(ctx->ns_rendered, ns, cur) < 0) {\n-                        xmlC14NErrMemory(ctx);\n-                        goto error;\n-                    }\n-        }\n-        if(!already_rendered) {\n-            xmlListInsert(list, ns);\n-        }\n-        if(xmlStrlen(ns->prefix) == 0) {\n-            has_empty_ns = 1;\n-        }\n-        }\n-    }\n-    }\n-\n-    \/**\n-     * if the first node is not the default namespace node (a node with no\n-     * namespace URI and no local name), then generate a space followed by\n-     * xmlns=\"\" if and only if the following conditions are met:\n-     *  - the element E that owns the axis is in the node-set\n-     *  - the nearest ancestor element of E in the node-set has a default\n-     *     namespace node in the node-set (default namespace nodes always\n-     *     have non-empty values in XPath)\n-     *\/\n-    if(visible && !has_empty_ns) {\n-        static xmlNs ns_default;\n-\n-        memset(&ns_default, 0, sizeof(ns_default));\n-        if(!xmlC14NVisibleNsStackFind(ctx->ns_rendered, &ns_default)) {\n-        xmlC14NPrintNamespaces(&ns_default, ctx);\n-    }\n-    }\n-\n-\n-    \/*\n-     * print out all elements from list\n-     *\/\n-    xmlListWalk(list, xmlC14NPrintNamespacesWalker, (void *) ctx);\n-\n-    \/*\n-     * Cleanup\n-     *\/\n-error:\n-    xmlListDelete(list);\n-    return (0);\n-}\n-\n-\n-\/**\n- * xmlExcC14NProcessNamespacesAxis:\n- * @ctx:        the C14N context\n- * @node:        the current node\n- *\n- * Prints out exclusive canonical namespace axis of the current node to the\n- * buffer from C14N context as follows\n- *\n- * Exclusive XML Canonicalization\n- * http:\/\/www.w3.org\/TR\/xml-exc-c14n\n- *\n- * If the element node is in the XPath subset then output the node in\n- * accordance with Canonical XML except for namespace nodes which are\n- * rendered as follows:\n- *\n- * 1. Render each namespace node iff:\n- *    * it is visibly utilized by the immediate parent element or one of\n- *      its attributes, or is present in InclusiveNamespaces PrefixList, and\n- *    * its prefix and value do not appear in ns_rendered. ns_rendered is\n- *      obtained by popping the state stack in order to obtain a list of\n- *      prefixes and their values which have already been rendered by\n- *      an output ancestor of the namespace node's parent element.\n- * 2. Append the rendered namespace node to the list ns_rendered of namespace\n- * nodes rendered by output ancestors. Push ns_rendered on state stack and\n- * recurse.\n- * 3. After the recursion returns, pop thestate stack.\n- *\n- *\n- * Returns 0 on success or -1 on fail.\n- *\/\n-static int\n-xmlExcC14NProcessNamespacesAxis(xmlC14NCtxPtr ctx, xmlNodePtr cur, int visible)\n-{\n-    xmlNsPtr ns;\n-    xmlListPtr list;\n-    xmlAttrPtr attr;\n-    int already_rendered;\n-    int has_empty_ns = 0;\n-    int has_visibly_utilized_empty_ns = 0;\n-    int has_empty_ns_in_inclusive_list = 0;\n-\n-    if ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {\n-        xmlC14NErrParam(ctx);\n-        return (-1);\n-    }\n-\n-    if(!xmlC14NIsExclusive(ctx)) {\n-        xmlC14NErrParam(ctx);\n-        return (-1);\n-\n-    }\n-\n-    \/*\n-     * Create a sorted list to store element namespaces\n-     *\/\n-    list = xmlListCreate(NULL, xmlC14NNsCompare);\n-    if (list == NULL) {\n-        xmlC14NErrMemory(ctx);\n-        return (-1);\n-    }\n-\n-    \/*\n-     * process inclusive namespaces:\n-     * All namespace nodes appearing on inclusive ns list are\n-     * handled as provided in Canonical XML\n-     *\/\n-    if(ctx->inclusive_ns_prefixes != NULL) {\n-    xmlChar *prefix;\n-    int i;\n-\n-    for (i = 0; ctx->inclusive_ns_prefixes[i] != NULL; ++i) {\n-        prefix = ctx->inclusive_ns_prefixes[i];\n-        \/*\n-         * Special values for namespace with empty prefix\n-         *\/\n-            if (xmlStrEqual(prefix, BAD_CAST \"#default\")\n-                || xmlStrEqual(prefix, BAD_CAST \"\")) {\n-                prefix = NULL;\n-        has_empty_ns_in_inclusive_list = 1;\n-            }\n-\n-        ns = xmlSearchNs(cur->doc, cur, prefix);\n-        if((ns != NULL) && !xmlC14NIsXmlNs(ns) && xmlC14NIsVisible(ctx, ns, cur)) {\n-        already_rendered = xmlC14NVisibleNsStackFind(ctx->ns_rendered, ns);\n-        if(visible) {\n-            if (xmlC14NVisibleNsStackAdd(ctx->ns_rendered, ns, cur) < 0) {\n-                        xmlC14NErrMemory(ctx);\n-                        goto error;\n-                    }\n-        }\n-        if(!already_rendered) {\n-            xmlListInsert(list, ns);\n-        }\n-        if(xmlStrlen(ns->prefix) == 0) {\n-            has_empty_ns = 1;\n-        }\n-        }\n-    }\n-    }\n-\n-    \/* add node namespace *\/\n-    if(cur->ns != NULL) {\n-    ns = cur->ns;\n-    } else {\n-        ns = xmlSearchNs(cur->doc, cur, NULL);\n-    has_visibly_utilized_empty_ns = 1;\n-    }\n-    if((ns != NULL) && !xmlC14NIsXmlNs(ns)) {\n-    if(visible && xmlC14NIsVisible(ctx, ns, cur)) {\n-        if(!xmlExcC14NVisibleNsStackFind(ctx->ns_rendered, ns, ctx)) {\n-        xmlListInsert(list, ns);\n-        }\n-    }\n-    if(visible) {\n-        if (xmlC14NVisibleNsStackAdd(ctx->ns_rendered, ns, cur) < 0) {\n-                xmlC14NErrMemory(ctx);\n-                goto error;\n-            }\n-    }\n-    if(xmlStrlen(ns->prefix) == 0) {\n-        has_empty_ns = 1;\n-    }\n-    }\n-\n-\n-    \/* add attributes *\/\n-    for(attr = cur->properties; attr != NULL; attr = attr->next) {\n-        \/*\n-         * we need to check that attribute is visible and has non\n-         * default namespace (XML Namespaces: \"default namespaces\n-     * do not apply directly to attributes\")\n-         *\/\n-    if((attr->ns != NULL) && !xmlC14NIsXmlNs(attr->ns) && xmlC14NIsVisible(ctx, attr, cur)) {\n-        already_rendered = xmlExcC14NVisibleNsStackFind(ctx->ns_rendered, attr->ns, ctx);\n-        if (xmlC14NVisibleNsStackAdd(ctx->ns_rendered, attr->ns, cur) < 0) {\n-                xmlC14NErrMemory(ctx);\n-                goto error;\n-            }\n-        if(!already_rendered && visible) {\n-        xmlListInsert(list, attr->ns);\n-        }\n-        if(xmlStrlen(attr->ns->prefix) == 0) {\n-        has_empty_ns = 1;\n-        }\n-    } else if((attr->ns != NULL) && (xmlStrlen(attr->ns->prefix) == 0) && (xmlStrlen(attr->ns->href) == 0)) {\n-        has_visibly_utilized_empty_ns = 1;\n-    }\n-    }\n-\n-    \/*\n-     * Process xmlns=\"\"\n-     *\/\n-    if(visible && has_visibly_utilized_empty_ns &&\n-        !has_empty_ns && !has_empty_ns_in_inclusive_list) {\n-        static xmlNs ns_default;\n-\n-        memset(&ns_default, 0, sizeof(ns_default));\n-\n-        already_rendered = xmlExcC14NVisibleNsStackFind(ctx->ns_rendered, &ns_default, ctx);\n-    if(!already_rendered) {\n-        xmlC14NPrintNamespaces(&ns_default, ctx);\n-    }\n-    } else if(visible && !has_empty_ns && has_empty_ns_in_inclusive_list) {\n-        static xmlNs ns_default;\n-\n-        memset(&ns_default, 0, sizeof(ns_default));\n-        if(!xmlC14NVisibleNsStackFind(ctx->ns_rendered, &ns_default)) {\n-        xmlC14NPrintNamespaces(&ns_default, ctx);\n-    }\n-    }\n-\n-\n-\n-    \/*\n-     * print out all elements from list\n-     *\/\n-    xmlListWalk(list, xmlC14NPrintNamespacesWalker, (void *) ctx);\n-\n-    \/*\n-     * Cleanup\n-     *\/\n-error:\n-    xmlListDelete(list);\n-    return (0);\n-}\n-\n-\n-\/**\n- * xmlC14NIsXmlAttr:\n- * @attr:        the attr to check\n- *\n- * Checks whether the given attribute is a default \"xml:\" namespace\n- * with href=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n- *\n- * Returns 1 if the node is default or 0 otherwise\n- *\/\n-\n-\/* todo: make it a define? *\/\n-static int\n-xmlC14NIsXmlAttr(xmlAttrPtr attr)\n-{\n-    return ((attr->ns != NULL) &&\n-           (xmlC14NIsXmlNs(attr->ns) != 0));\n-}\n-\n-\n-\/**\n- * xmlC14NAttrsCompare:\n- * @attr1:        the pointer tls o first attr\n- * @attr2:        the pointer to second attr\n- *\n- * Prints the given attribute to the output buffer from C14N context.\n- *\n- * Returns -1 if attr1 < attr2, 0 if attr1 == attr2 or 1 if attr1 > attr2.\n- *\/\n-static int\n-xmlC14NAttrsCompare(const void *data1, const void *data2)\n-{\n-    const xmlAttr *attr1 = data1;\n-    const xmlAttr *attr2 = data2;\n-    int ret = 0;\n-\n-    \/*\n-     * Simple cases\n-     *\/\n-    if (attr1 == attr2)\n-        return (0);\n-    if (attr1 == NULL)\n-        return (-1);\n-    if (attr2 == NULL)\n-        return (1);\n-    if (attr1->ns == attr2->ns) {\n-        return (xmlStrcmp(attr1->name, attr2->name));\n-    }\n-\n-    \/*\n-     * Attributes in the default namespace are first\n-     * because the default namespace is not applied to\n-     * unqualified attributes\n-     *\/\n-    if (attr1->ns == NULL)\n-        return (-1);\n-    if (attr2->ns == NULL)\n-        return (1);\n-    if (attr1->ns->prefix == NULL)\n-        return (-1);\n-    if (attr2->ns->prefix == NULL)\n-        return (1);\n-\n-    ret = xmlStrcmp(attr1->ns->href, attr2->ns->href);\n-    if (ret == 0) {\n-        ret = xmlStrcmp(attr1->name, attr2->name);\n-    }\n-    return (ret);\n-}\n-\n-\n-\/**\n- * xmlC14NPrintAttrs:\n- * @attr:        the pointer to attr\n- * @ctx:        the C14N context\n- *\n- * Prints out canonical attribute urrent node to the\n- * buffer from C14N context as follows\n- *\n- * Canonical XML v 1.0 (http:\/\/www.w3.org\/TR\/xml-c14n)\n- *\n- * Returns 1 on success or 0 on fail.\n- *\/\n-static int\n-xmlC14NPrintAttrs(const void *data, void *user)\n-{\n-    const xmlAttr *attr = data;\n-    xmlC14NCtxPtr ctx = (xmlC14NCtxPtr) user;\n-    xmlChar *value;\n-    xmlChar *buffer;\n-\n-    if ((attr == NULL) || (ctx == NULL)) {\n-        xmlC14NErrParam(ctx);\n-        return (0);\n-    }\n-\n-    xmlOutputBufferWriteString(ctx->buf, \" \");\n-    if (attr->ns != NULL && xmlStrlen(attr->ns->prefix) > 0) {\n-        xmlOutputBufferWriteString(ctx->buf,\n-                                   (const char *) attr->ns->prefix);\n-        xmlOutputBufferWriteString(ctx->buf, \":\");\n-    }\n-    xmlOutputBufferWriteString(ctx->buf, (const char *) attr->name);\n-    xmlOutputBufferWriteString(ctx->buf, \"=\\\"\");\n-\n-    value = xmlNodeListGetString(ctx->doc, attr->children, 1);\n-    \/* todo: should we log an error if value==NULL ? *\/\n-    if (value != NULL) {\n-        buffer = xmlC11NNormalizeAttr(value);\n-        xmlFree(value);\n-        if (buffer != NULL) {\n-            xmlOutputBufferWriteString(ctx->buf, (const char *) buffer);\n-            xmlFree(buffer);\n-        } else {\n-            xmlC14NErrMemory(ctx);\n-            return (0);\n-        }\n-    }\n-    xmlOutputBufferWriteString(ctx->buf, \"\\\"\");\n-    return (1);\n-}\n-\n-\/**\n- * xmlC14NFindHiddenParentAttr:\n- *\n- * Finds an attribute in a hidden parent node.\n- *\n- * Returns a pointer to the attribute node (if found) or NULL otherwise.\n- *\/\n-static xmlAttrPtr\n-xmlC14NFindHiddenParentAttr(xmlC14NCtxPtr ctx, xmlNodePtr cur, const xmlChar * name, const xmlChar * ns)\n-{\n-    xmlAttrPtr res;\n-    while((cur != NULL) && (!xmlC14NIsVisible(ctx, cur, cur->parent))) {\n-        res = xmlHasNsProp(cur, name, ns);\n-        if(res != NULL) {\n-            return res;\n-        }\n-\n-        cur = cur->parent;\n-    }\n-\n-    return NULL;\n-}\n-\n-\/**\n- * xmlC14NFixupBaseAttr:\n- *\n- * Fixes up the xml:base attribute\n- *\n- * Returns the newly created attribute or NULL\n- *\/\n-static xmlAttrPtr\n-xmlC14NFixupBaseAttr(xmlC14NCtxPtr ctx, xmlAttrPtr xml_base_attr)\n-{\n-    xmlChar * res = NULL;\n-    xmlNodePtr cur;\n-    xmlAttrPtr attr;\n-    xmlChar * tmp_str;\n-    xmlChar * tmp_str2;\n-    int tmp_str_len;\n-\n-    if ((ctx == NULL) || (xml_base_attr == NULL) || (xml_base_attr->parent == NULL)) {\n-        xmlC14NErrParam(ctx);\n-        return (NULL);\n-    }\n-\n-    \/* start from current value *\/\n-    res = xmlNodeListGetString(ctx->doc, xml_base_attr->children, 1);\n-    if(res == NULL) {\n-        xmlC14NErrMemory(ctx);\n-        return (NULL);\n-    }\n-\n-    \/* go up the stack until we find a node that we rendered already *\/\n-    cur = xml_base_attr->parent->parent;\n-    while((cur != NULL) && (!xmlC14NIsVisible(ctx, cur, cur->parent))) {\n-        int code;\n-\n-        attr = xmlHasNsProp(cur, BAD_CAST \"base\", XML_XML_NAMESPACE);\n-        if(attr != NULL) {\n-            \/* get attr value *\/\n-            tmp_str = xmlNodeListGetString(ctx->doc, attr->children, 1);\n-            if(tmp_str == NULL) {\n-                xmlFree(res);\n-\n-                xmlC14NErrMemory(ctx);\n-                return (NULL);\n-            }\n-\n-            \/* we need to add '\/' if our current base uri ends with '..' or '.'\n-            to ensure that we are forced to go \"up\" all the time *\/\n-            tmp_str_len = xmlStrlen(tmp_str);\n-            if(tmp_str_len > 1 && tmp_str[tmp_str_len - 2] == '.') {\n-                tmp_str2 = xmlStrcat(tmp_str, BAD_CAST \"\/\");\n-                if(tmp_str2 == NULL) {\n-                    xmlFree(tmp_str);\n-                    xmlFree(res);\n-\n-                    xmlC14NErrMemory(ctx);\n-                    return (NULL);\n-                }\n-\n-                tmp_str = tmp_str2;\n-            }\n-\n-            \/* build uri *\/\n-            code = xmlBuildURISafe(res, tmp_str, &tmp_str2);\n-            if (code != 0) {\n-                xmlFree(tmp_str);\n-                xmlFree(res);\n-\n-                if (code < 0)\n-                    xmlC14NErrMemory(ctx);\n-                else\n-                    xmlC14NErr(ctx, cur, XML_ERR_INVALID_URI,\n-                               \"processing xml:base attribute - \"\n-                               \"can't construct uri\");\n-                return (NULL);\n-            }\n-\n-            \/* cleanup and set the new res *\/\n-            xmlFree(tmp_str);\n-            xmlFree(res);\n-            res = tmp_str2;\n-        }\n-\n-        \/* next *\/\n-        cur = cur->parent;\n-    }\n-\n-    \/* check if result uri is empty or not *\/\n-    if((res == NULL) || xmlStrEqual(res, BAD_CAST \"\")) {\n-        xmlFree(res);\n-        return (NULL);\n-    }\n-\n-    \/* create and return the new attribute node *\/\n-    attr = xmlNewNsProp(NULL, xml_base_attr->ns, BAD_CAST \"base\", res);\n-    if(attr == NULL) {\n-        xmlFree(res);\n-\n-        xmlC14NErrMemory(ctx);\n-        return (NULL);\n-    }\n-\n-    \/* done *\/\n-    xmlFree(res);\n-    return (attr);\n-}\n-\n-\/**\n- * xmlC14NProcessAttrsAxis:\n- * @ctx:        the C14N context\n- * @cur:        the current node\n- * @parent_visible:    the visibility of parent node\n- * @all_parents_visible: the visibility of all parent nodes\n- *\n- * Prints out canonical attribute axis of the current node to the\n- * buffer from C14N context as follows\n- *\n- * Canonical XML v 1.0 (http:\/\/www.w3.org\/TR\/xml-c14n)\n- *\n- * Attribute Axis\n- * In lexicographic order (ascending), process each node that\n- * is in the element's attribute axis and in the node-set.\n- *\n- * The processing of an element node E MUST be modified slightly\n- * when an XPath node-set is given as input and the element's\n- * parent is omitted from the node-set.\n- *\n- *\n- * Exclusive XML Canonicalization v 1.0 (http:\/\/www.w3.org\/TR\/xml-exc-c14n)\n- *\n- * Canonical XML applied to a document subset requires the search of the\n- * ancestor nodes of each orphan element node for attributes in the xml\n- * namespace, such as xml:lang and xml:space. These are copied into the\n- * element node except if a declaration of the same attribute is already\n- * in the attribute axis of the element (whether or not it is included in\n- * the document subset). This search and copying are omitted from the\n- * Exclusive XML Canonicalization method.\n- *\n- * Returns 0 on success or -1 on fail.\n- *\/\n-static int\n-xmlC14NProcessAttrsAxis(xmlC14NCtxPtr ctx, xmlNodePtr cur, int parent_visible)\n-{\n-    xmlAttrPtr attr;\n-    xmlListPtr list;\n-    xmlAttrPtr attrs_to_delete = NULL;\n-\n-    \/* special processing for 1.1 spec *\/\n-    xmlAttrPtr xml_base_attr = NULL;\n-    xmlAttrPtr xml_lang_attr = NULL;\n-    xmlAttrPtr xml_space_attr = NULL;\n-\n-    if ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {\n-        xmlC14NErrParam(ctx);\n-        return (-1);\n-    }\n-\n-    \/*\n-     * Create a sorted list to store element attributes\n-     *\/\n-    list = xmlListCreate(NULL, xmlC14NAttrsCompare);\n-    if (list == NULL) {\n-        xmlC14NErrMemory(ctx);\n-        return (-1);\n-    }\n-\n-    switch(ctx->mode) {\n-    case XML_C14N_1_0:\n-        \/* The processing of an element node E MUST be modified slightly when an XPath node-set is\n-         * given as input and the element's parent is omitted from the node-set. The method for processing\n-         * the attribute axis of an element E in the node-set is enhanced. All element nodes along E's\n-         * ancestor axis are examined for nearest occurrences of attributes in the xml namespace, such\n-         * as xml:lang and xml:space (whether or not they are in the node-set). From this list of attributes,\n-         * remove any that are in E's attribute axis (whether or not they are in the node-set). Then,\n-         * lexicographically merge this attribute list with the nodes of E's attribute axis that are in\n-         * the node-set. The result of visiting the attribute axis is computed by processing the attribute\n-         * nodes in this merged attribute list.\n-         *\/\n-\n-        \/*\n-         * Add all visible attributes from current node.\n-         *\/\n-        attr = cur->properties;\n-        while (attr != NULL) {\n-            \/* check that attribute is visible *\/\n-            if (xmlC14NIsVisible(ctx, attr, cur)) {\n-                xmlListInsert(list, attr);\n-            }\n-            attr = attr->next;\n-        }\n-\n-        \/*\n-         * Handle xml attributes\n-         *\/\n-        if (parent_visible && (cur->parent != NULL) &&\n-            (!xmlC14NIsVisible(ctx, cur->parent, cur->parent->parent)))\n-        {\n-            xmlNodePtr tmp;\n-\n-            \/*\n-             * If XPath node-set is not specified then the parent is always\n-             * visible!\n-             *\/\n-            tmp = cur->parent;\n-            while (tmp != NULL) {\n-                attr = tmp->properties;\n-                while (attr != NULL) {\n-                    if (xmlC14NIsXmlAttr(attr) != 0) {\n-                        if (xmlListSearch(list, attr) == NULL) {\n-                            xmlListInsert(list, attr);\n-                        }\n-                    }\n-                    attr = attr->next;\n-                }\n-                tmp = tmp->parent;\n-            }\n-        }\n-\n-        \/* done *\/\n-        break;\n-    case XML_C14N_EXCLUSIVE_1_0:\n-        \/* attributes in the XML namespace, such as xml:lang and xml:space\n-         * are not imported into orphan nodes of the document subset\n-         *\/\n-\n-        \/*\n-         * Add all visible attributes from current node.\n-         *\/\n-        attr = cur->properties;\n-        while (attr != NULL) {\n-            \/* check that attribute is visible *\/\n-            if (xmlC14NIsVisible(ctx, attr, cur)) {\n-                xmlListInsert(list, attr);\n-            }\n-            attr = attr->next;\n-        }\n-\n-        \/* do nothing special for xml attributes *\/\n-        break;\n-    case XML_C14N_1_1:\n-        \/* The processing of an element node E MUST be modified slightly when an XPath node-set is\n-         * given as input and some of the element's ancestors are omitted from the node-set.\n-         *\n-         * Simple inheritable attributes are attributes that have a value that requires at most a simple\n-         * redeclaration. This redeclaration is done by supplying a new value in the child axis. The\n-         * redeclaration of a simple inheritable attribute A contained in one of E's ancestors is done\n-         * by supplying a value to an attribute Ae inside E with the same name. Simple inheritable attributes\n-         * are xml:lang and xml:space.\n-         *\n-         * The method for processing the attribute axis of an element E in the node-set is hence enhanced.\n-         * All element nodes along E's ancestor axis are examined for the nearest occurrences of simple\n-         * inheritable attributes in the xml namespace, such as xml:lang and xml:space (whether or not they\n-         * are in the node-set). From this list of attributes, any simple inheritable attributes that are\n-         * already in E's attribute axis (whether or not they are in the node-set) are removed. Then,\n-         * lexicographically merge this attribute list with the nodes of E's attribute axis that are in\n-         * the node-set. The result of visiting the attribute axis is computed by processing the attribute\n-         * nodes in this merged attribute list.\n-         *\n-         * The xml:id attribute is not a simple inheritable attribute and no processing of these attributes is\n-         * performed.\n-         *\n-         * The xml:base attribute is not a simple inheritable attribute and requires special processing beyond\n-         * a simple redeclaration.\n-         *\n-         * Attributes in the XML namespace other than xml:base, xml:id, xml:lang, and xml:space MUST be processed\n-         * as ordinary attributes.\n-         *\/\n-\n-        \/*\n-         * Add all visible attributes from current node.\n-         *\/\n-        attr = cur->properties;\n-        while (attr != NULL) {\n-            \/* special processing for XML attribute kiks in only when we have invisible parents *\/\n-            if ((!parent_visible) || (xmlC14NIsXmlAttr(attr) == 0)) {\n-                \/* check that attribute is visible *\/\n-                if (xmlC14NIsVisible(ctx, attr, cur)) {\n-                    xmlListInsert(list, attr);\n-                }\n-            } else {\n-                int matched = 0;\n-\n-                \/* check for simple inheritance attributes *\/\n-                if((!matched) && (xml_lang_attr == NULL) && xmlStrEqual(attr->name, BAD_CAST \"lang\")) {\n-                    xml_lang_attr = attr;\n-                    matched = 1;\n-                }\n-                if((!matched) && (xml_space_attr == NULL) && xmlStrEqual(attr->name, BAD_CAST \"space\")) {\n-                    xml_space_attr = attr;\n-                    matched = 1;\n-                }\n-\n-                \/* check for base attr *\/\n-                if((!matched) && (xml_base_attr == NULL) && xmlStrEqual(attr->name, BAD_CAST \"base\")) {\n-                    xml_base_attr = attr;\n-                    matched = 1;\n-                }\n-\n-                \/* otherwise, it is a normal attribute, so just check if it is visible *\/\n-                if((!matched) && xmlC14NIsVisible(ctx, attr, cur)) {\n-                    xmlListInsert(list, attr);\n-                }\n-            }\n-\n-            \/* move to the next one *\/\n-            attr = attr->next;\n-        }\n-\n-        \/* special processing for XML attribute kiks in only when we have invisible parents *\/\n-        if ((parent_visible)) {\n-\n-            \/* simple inheritance attributes - copy *\/\n-            if(xml_lang_attr == NULL) {\n-                xml_lang_attr = xmlC14NFindHiddenParentAttr(ctx, cur->parent, BAD_CAST \"lang\", XML_XML_NAMESPACE);\n-            }\n-            if(xml_lang_attr != NULL) {\n-                xmlListInsert(list, xml_lang_attr);\n-            }\n-            if(xml_space_attr == NULL) {\n-                xml_space_attr = xmlC14NFindHiddenParentAttr(ctx, cur->parent, BAD_CAST \"space\", XML_XML_NAMESPACE);\n-            }\n-            if(xml_space_attr != NULL) {\n-                xmlListInsert(list, xml_space_attr);\n-            }\n-\n-            \/* base uri attribute - fix up *\/\n-            if(xml_base_attr == NULL) {\n-                \/* if we don't have base uri attribute, check if we have a \"hidden\" one above *\/\n-                xml_base_attr = xmlC14NFindHiddenParentAttr(ctx, cur->parent, BAD_CAST \"base\", XML_XML_NAMESPACE);\n-            }\n-            if(xml_base_attr != NULL) {\n-                xml_base_attr = xmlC14NFixupBaseAttr(ctx, xml_base_attr);\n-                if(xml_base_attr != NULL) {\n-                    xmlListInsert(list, xml_base_attr);\n-\n-                    \/* note that we MUST delete returned attr node ourselves! *\/\n-                    xml_base_attr->next = attrs_to_delete;\n-                    attrs_to_delete = xml_base_attr;\n-                }\n-            }\n-        }\n-\n-        \/* done *\/\n-        break;\n-    }\n-\n-    \/*\n-     * print out all elements from list\n-     *\/\n-    xmlListWalk(list, xmlC14NPrintAttrs, (void *) ctx);\n-\n-    \/*\n-     * Cleanup\n-     *\/\n-    xmlFreePropList(attrs_to_delete);\n-    xmlListDelete(list);\n-    return (0);\n-}\n-\n-\/**\n- * xmlC14NCheckForRelativeNamespaces:\n- * @ctx:        the C14N context\n- * @cur:        the current element node\n- *\n- * Checks that current element node has no relative namespaces defined\n- *\n- * Returns 0 if the node has no relative namespaces or -1 otherwise.\n- *\/\n-static int\n-xmlC14NCheckForRelativeNamespaces(xmlC14NCtxPtr ctx, xmlNodePtr cur)\n-{\n-    xmlNsPtr ns;\n-\n-    if ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {\n-        xmlC14NErrParam(ctx);\n-        return (-1);\n-    }\n-\n-    ns = cur->nsDef;\n-    while (ns != NULL) {\n-        if (xmlStrlen(ns->href) > 0) {\n-            xmlURIPtr uri;\n-            int code;\n-\n-            code = xmlParseURISafe((const char *) ns->href, &uri);\n-            if (uri == NULL) {\n-                if (code < 0)\n-                    xmlC14NErrMemory(ctx);\n-                else\n-                    xmlC14NErr(ctx, cur, XML_ERR_INVALID_URI,\n-                               \"parsing namespace uri\");\n-                return (-1);\n-            }\n-            if (xmlStrlen((const xmlChar *) uri->scheme) == 0) {\n-                xmlC14NErrRelativeNamespace(ctx, uri->scheme);\n-                xmlFreeURI(uri);\n-                return (-1);\n-            }\n-            xmlFreeURI(uri);\n-        }\n-        ns = ns->next;\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlC14NProcessElementNode:\n- * @ctx:        the pointer to C14N context object\n- * @cur:        the node to process\n- * @visible:    this node is visible\n- * @all_parents_visible: whether all the parents of this node are visible\n- *\n- * Canonical XML v 1.0 (http:\/\/www.w3.org\/TR\/xml-c14n)\n- *\n- * Element Nodes\n- * If the element is not in the node-set, then the result is obtained\n- * by processing the namespace axis, then the attribute axis, then\n- * processing the child nodes of the element that are in the node-set\n- * (in document order). If the element is in the node-set, then the result\n- * is an open angle bracket (<), the element QName, the result of\n- * processing the namespace axis, the result of processing the attribute\n- * axis, a close angle bracket (>), the result of processing the child\n- * nodes of the element that are in the node-set (in document order), an\n- * open angle bracket, a forward slash (\/), the element QName, and a close\n- * angle bracket.\n- *\n- * Returns non-negative value on success or negative value on fail\n- *\/\n-static int\n-xmlC14NProcessElementNode(xmlC14NCtxPtr ctx, xmlNodePtr cur, int visible)\n-{\n-    int ret;\n-    xmlC14NVisibleNsStack state;\n-    int parent_is_doc = 0;\n-\n-    if ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {\n-        xmlC14NErrParam(ctx);\n-        return (-1);\n-    }\n-\n-    \/*\n-     * Check relative relative namespaces:\n-     * implementations of XML canonicalization MUST report an operation\n-     * failure on documents containing relative namespace URIs.\n-     *\/\n-    if (xmlC14NCheckForRelativeNamespaces(ctx, cur) < 0)\n-        return (-1);\n-\n-    \/*\n-     * Save ns_rendered stack position\n-     *\/\n-    memset(&state, 0, sizeof(state));\n-    xmlC14NVisibleNsStackSave(ctx->ns_rendered, &state);\n-\n-    if (visible) {\n-        if (ctx->parent_is_doc) {\n-        \/* save this flag into the stack *\/\n-        parent_is_doc = ctx->parent_is_doc;\n-        ctx->parent_is_doc = 0;\n-            ctx->pos = XMLC14N_INSIDE_DOCUMENT_ELEMENT;\n-        }\n-        xmlOutputBufferWriteString(ctx->buf, \"<\");\n-\n-        if ((cur->ns != NULL) && (xmlStrlen(cur->ns->prefix) > 0)) {\n-            xmlOutputBufferWriteString(ctx->buf,\n-                                       (const char *) cur->ns->prefix);\n-            xmlOutputBufferWriteString(ctx->buf, \":\");\n-        }\n-        xmlOutputBufferWriteString(ctx->buf, (const char *) cur->name);\n-    }\n-\n-    if (!xmlC14NIsExclusive(ctx)) {\n-        ret = xmlC14NProcessNamespacesAxis(ctx, cur, visible);\n-    } else {\n-        ret = xmlExcC14NProcessNamespacesAxis(ctx, cur, visible);\n-    }\n-    if (ret < 0)\n-        return (-1);\n-    \/* todo: shouldn't this go to \"visible only\"? *\/\n-    if(visible) {\n-    xmlC14NVisibleNsStackShift(ctx->ns_rendered);\n-    }\n-\n-    ret = xmlC14NProcessAttrsAxis(ctx, cur, visible);\n-    if (ret < 0)\n-    return (-1);\n-\n-    if (visible) {\n-        xmlOutputBufferWriteString(ctx->buf, \">\");\n-    }\n-    if (cur->children != NULL) {\n-        ret = xmlC14NProcessNodeList(ctx, cur->children);\n-        if (ret < 0)\n-            return (-1);\n-    }\n-    if (visible) {\n-        xmlOutputBufferWriteString(ctx->buf, \"<\/\");\n-        if ((cur->ns != NULL) && (xmlStrlen(cur->ns->prefix) > 0)) {\n-            xmlOutputBufferWriteString(ctx->buf,\n-                                       (const char *) cur->ns->prefix);\n-            xmlOutputBufferWriteString(ctx->buf, \":\");\n-        }\n-        xmlOutputBufferWriteString(ctx->buf, (const char *) cur->name);\n-        xmlOutputBufferWriteString(ctx->buf, \">\");\n-        if (parent_is_doc) {\n-        \/* restore this flag from the stack for next node *\/\n-            ctx->parent_is_doc = parent_is_doc;\n-        ctx->pos = XMLC14N_AFTER_DOCUMENT_ELEMENT;\n-        }\n-    }\n-\n-    \/*\n-     * Restore ns_rendered stack position\n-     *\/\n-    xmlC14NVisibleNsStackRestore(ctx->ns_rendered, &state);\n-    return (0);\n-}\n-\n-\/**\n- * xmlC14NProcessNode:\n- * @ctx:        the pointer to C14N context object\n- * @cur:        the node to process\n- *\n- * Processes the given node\n- *\n- * Returns non-negative value on success or negative value on fail\n- *\/\n-static int\n-xmlC14NProcessNode(xmlC14NCtxPtr ctx, xmlNodePtr cur)\n-{\n-    int ret = 0;\n-    int visible;\n-\n-    if ((ctx == NULL) || (cur == NULL)) {\n-        xmlC14NErrParam(ctx);\n-        return (-1);\n-    }\n-\n-    visible = xmlC14NIsVisible(ctx, cur, cur->parent);\n-    switch (cur->type) {\n-        case XML_ELEMENT_NODE:\n-            ret = xmlC14NProcessElementNode(ctx, cur, visible);\n-            break;\n-        case XML_CDATA_SECTION_NODE:\n-        case XML_TEXT_NODE:\n-            \/*\n-             * Text Nodes\n-             * the string value, except all ampersands are replaced\n-             * by &amp;, all open angle brackets (<) are replaced by &lt;, all closing\n-             * angle brackets (>) are replaced by &gt;, and all #xD characters are\n-             * replaced by &#xD;.\n-             *\/\n-            \/* cdata sections are processed as text nodes *\/\n-            \/* todo: verify that cdata sections are included in XPath nodes set *\/\n-            if ((visible) && (cur->content != NULL)) {\n-                xmlChar *buffer;\n-\n-                buffer = xmlC11NNormalizeText(cur->content);\n-                if (buffer != NULL) {\n-                    xmlOutputBufferWriteString(ctx->buf,\n-                                               (const char *) buffer);\n-                    xmlFree(buffer);\n-                } else {\n-                    xmlC14NErrMemory(ctx);\n-                    return (-1);\n-                }\n-            }\n-            break;\n-        case XML_PI_NODE:\n-            \/*\n-             * Processing Instruction (PI) Nodes-\n-             * The opening PI symbol (<?), the PI target name of the node,\n-             * a leading space and the string value if it is not empty, and\n-             * the closing PI symbol (?>). If the string value is empty,\n-             * then the leading space is not added. Also, a trailing #xA is\n-             * rendered after the closing PI symbol for PI children of the\n-             * root node with a lesser document order than the document\n-             * element, and a leading #xA is rendered before the opening PI\n-             * symbol of PI children of the root node with a greater document\n-             * order than the document element.\n-             *\/\n-            if (visible) {\n-                if (ctx->pos == XMLC14N_AFTER_DOCUMENT_ELEMENT) {\n-                    xmlOutputBufferWriteString(ctx->buf, \"\\x0A<?\");\n-                } else {\n-                    xmlOutputBufferWriteString(ctx->buf, \"<?\");\n-                }\n-\n-                xmlOutputBufferWriteString(ctx->buf,\n-                                           (const char *) cur->name);\n-                if ((cur->content != NULL) && (*(cur->content) != '\\0')) {\n-                    xmlChar *buffer;\n-\n-                    xmlOutputBufferWriteString(ctx->buf, \" \");\n-\n-                    \/* todo: do we need to normalize pi? *\/\n-                    buffer = xmlC11NNormalizePI(cur->content);\n-                    if (buffer != NULL) {\n-                        xmlOutputBufferWriteString(ctx->buf,\n-                                                   (const char *) buffer);\n-                        xmlFree(buffer);\n-                    } else {\n-                        xmlC14NErrMemory(ctx);\n-                        return (-1);\n-                    }\n-                }\n-\n-                if (ctx->pos == XMLC14N_BEFORE_DOCUMENT_ELEMENT) {\n-                    xmlOutputBufferWriteString(ctx->buf, \"?>\\x0A\");\n-                } else {\n-                    xmlOutputBufferWriteString(ctx->buf, \"?>\");\n-                }\n-            }\n-            break;\n-        case XML_COMMENT_NODE:\n-            \/*\n-             * Comment Nodes\n-             * Nothing if generating canonical XML without  comments. For\n-             * canonical XML with comments, generate the opening comment\n-             * symbol (<!--), the string value of the node, and the\n-             * closing comment symbol (-->). Also, a trailing #xA is rendered\n-             * after the closing comment symbol for comment children of the\n-             * root node with a lesser document order than the document\n-             * element, and a leading #xA is rendered before the opening\n-             * comment symbol of comment children of the root node with a\n-             * greater document order than the document element. (Comment\n-             * children of the root node represent comments outside of the\n-             * top-level document element and outside of the document type\n-             * declaration).\n-             *\/\n-            if (visible && ctx->with_comments) {\n-                if (ctx->pos == XMLC14N_AFTER_DOCUMENT_ELEMENT) {\n-                    xmlOutputBufferWriteString(ctx->buf, \"\\x0A<!--\");\n-                } else {\n-                    xmlOutputBufferWriteString(ctx->buf, \"<!--\");\n-                }\n-\n-                if (cur->content != NULL) {\n-                    xmlChar *buffer;\n-\n-                    \/* todo: do we need to normalize comment? *\/\n-                    buffer = xmlC11NNormalizeComment(cur->content);\n-                    if (buffer != NULL) {\n-                        xmlOutputBufferWriteString(ctx->buf,\n-                                                   (const char *) buffer);\n-                        xmlFree(buffer);\n-                    } else {\n-                        xmlC14NErrMemory(ctx);\n-                        return (-1);\n-                    }\n-                }\n-\n-                if (ctx->pos == XMLC14N_BEFORE_DOCUMENT_ELEMENT) {\n-                    xmlOutputBufferWriteString(ctx->buf, \"-->\\x0A\");\n-                } else {\n-                    xmlOutputBufferWriteString(ctx->buf, \"-->\");\n-                }\n-            }\n-            break;\n-        case XML_DOCUMENT_NODE:\n-        case XML_DOCUMENT_FRAG_NODE:   \/* should be processed as document? *\/\n-#ifdef LIBXML_HTML_ENABLED\n-        case XML_HTML_DOCUMENT_NODE:   \/* should be processed as document? *\/\n-#endif\n-            if (cur->children != NULL) {\n-                ctx->pos = XMLC14N_BEFORE_DOCUMENT_ELEMENT;\n-                ctx->parent_is_doc = 1;\n-                ret = xmlC14NProcessNodeList(ctx, cur->children);\n-            }\n-            break;\n-\n-        case XML_ATTRIBUTE_NODE:\n-            xmlC14NErrInvalidNode(ctx, \"XML_ATTRIBUTE_NODE\", \"processing node\");\n-            return (-1);\n-        case XML_NAMESPACE_DECL:\n-            xmlC14NErrInvalidNode(ctx, \"XML_NAMESPACE_DECL\", \"processing node\");\n-            return (-1);\n-        case XML_ENTITY_REF_NODE:\n-            xmlC14NErrInvalidNode(ctx, \"XML_ENTITY_REF_NODE\", \"processing node\");\n-            return (-1);\n-        case XML_ENTITY_NODE:\n-            xmlC14NErrInvalidNode(ctx, \"XML_ENTITY_NODE\", \"processing node\");\n-            return (-1);\n-\n-        case XML_DOCUMENT_TYPE_NODE:\n-        case XML_NOTATION_NODE:\n-        case XML_DTD_NODE:\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_ENTITY_DECL:\n-#ifdef LIBXML_XINCLUDE_ENABLED\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-#endif\n-            \/*\n-             * should be ignored according to \"W3C Canonical XML\"\n-             *\/\n-            break;\n-        default:\n-            xmlC14NErrUnknownNode(ctx, cur->type, \"processing node\");\n-            return (-1);\n-    }\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlC14NProcessNodeList:\n- * @ctx:        the pointer to C14N context object\n- * @cur:        the node to start from\n- *\n- * Processes all nodes in the row starting from cur.\n- *\n- * Returns non-negative value on success or negative value on fail\n- *\/\n-static int\n-xmlC14NProcessNodeList(xmlC14NCtxPtr ctx, xmlNodePtr cur)\n-{\n-    int ret;\n-\n-    if (ctx == NULL) {\n-        xmlC14NErrParam(ctx);\n-        return (-1);\n-    }\n-\n-    for (ret = 0; cur != NULL && ret >= 0; cur = cur->next) {\n-        ret = xmlC14NProcessNode(ctx, cur);\n-    }\n-    return (ret);\n-}\n-\n-\n-\/**\n- * xmlC14NFreeCtx:\n- * @ctx: the pointer to C14N context object\n- *\n- * Cleanups the C14N context object.\n- *\/\n-\n-static void\n-xmlC14NFreeCtx(xmlC14NCtxPtr ctx)\n-{\n-    if (ctx == NULL) {\n-        xmlC14NErrParam(ctx);\n-        return;\n-    }\n-\n-    if (ctx->ns_rendered != NULL) {\n-        xmlC14NVisibleNsStackDestroy(ctx->ns_rendered);\n-    }\n-    xmlFree(ctx);\n-}\n-\n-\/**\n- * xmlC14NNewCtx:\n- * @doc:        the XML document for canonization\n- * @is_visible_callback:the function to use to determine is node visible\n- *            or not\n- * @user_data:        the first parameter for @is_visible_callback function\n- *            (in most cases, it is nodes set)\n- * @mode:   the c14n mode (see @xmlC14NMode)\n- * @inclusive_ns_prefixe the list of inclusive namespace prefixes\n- *            ended with a NULL or NULL if there is no\n- *            inclusive namespaces (only for `\n- *            canonicalization)\n- * @with_comments:    include comments in the result (!=0) or not (==0)\n- * @buf:        the output buffer to store canonical XML; this\n- *            buffer MUST have encoder==NULL because C14N requires\n- *            UTF-8 output\n- *\n- * Creates new C14N context object to store C14N parameters.\n- *\n- * Returns pointer to newly created object (success) or NULL (fail)\n- *\/\n-static xmlC14NCtxPtr\n-xmlC14NNewCtx(xmlDocPtr doc,\n-          xmlC14NIsVisibleCallback is_visible_callback, void* user_data,\n-              xmlC14NMode mode, xmlChar ** inclusive_ns_prefixes,\n-              int with_comments, xmlOutputBufferPtr buf)\n-{\n-    xmlC14NCtxPtr ctx = NULL;\n-\n-    if ((doc == NULL) || (buf == NULL)) {\n-        xmlC14NErrParam(ctx);\n-        return (NULL);\n-    }\n-\n-    \/*\n-     *  Validate the encoding output buffer encoding\n-     *\/\n-    if (buf->encoder != NULL) {\n-        xmlC14NErr(ctx, (xmlNodePtr) doc, XML_C14N_REQUIRES_UTF8,\n-\"xmlC14NNewCtx: output buffer encoder != NULL but C14N requires UTF8 output\\n\");\n-        return (NULL);\n-    }\n-\n-    \/*\n-     * Allocate a new xmlC14NCtxPtr and fill the fields.\n-     *\/\n-    ctx = (xmlC14NCtxPtr) xmlMalloc(sizeof(xmlC14NCtx));\n-    if (ctx == NULL) {\n-    xmlC14NErrMemory(ctx);\n-        return (NULL);\n-    }\n-    memset(ctx, 0, sizeof(xmlC14NCtx));\n-\n-    \/*\n-     * initialize C14N context\n-     *\/\n-    ctx->doc = doc;\n-    ctx->with_comments = with_comments;\n-    ctx->is_visible_callback = is_visible_callback;\n-    ctx->user_data = user_data;\n-    ctx->buf = buf;\n-    ctx->parent_is_doc = 1;\n-    ctx->pos = XMLC14N_BEFORE_DOCUMENT_ELEMENT;\n-    ctx->ns_rendered = xmlC14NVisibleNsStackCreate();\n-\n-    if(ctx->ns_rendered == NULL) {\n-        xmlC14NErrMemory(ctx);\n-    xmlC14NFreeCtx(ctx);\n-        return (NULL);\n-    }\n-\n-    \/*\n-     * Set \"mode\" flag and remember list of inclusive prefixes\n-     * for exclusive c14n\n-     *\/\n-    ctx->mode = mode;\n-    if(xmlC14NIsExclusive(ctx)) {\n-        ctx->inclusive_ns_prefixes = inclusive_ns_prefixes;\n-    }\n-\n-    return (ctx);\n-}\n-\n-\/**\n- * xmlC14NExecute:\n- * @doc:        the XML document for canonization\n- * @is_visible_callback:the function to use to determine is node visible\n- *            or not\n- * @user_data:        the first parameter for @is_visible_callback function\n- *            (in most cases, it is nodes set)\n- * @mode:    the c14n mode (see @xmlC14NMode)\n- * @inclusive_ns_prefixes: the list of inclusive namespace prefixes\n- *            ended with a NULL or NULL if there is no\n- *            inclusive namespaces (only for exclusive\n- *            canonicalization, ignored otherwise)\n- * @with_comments:    include comments in the result (!=0) or not (==0)\n- * @buf:        the output buffer to store canonical XML; this\n- *            buffer MUST have encoder==NULL because C14N requires\n- *            UTF-8 output\n- *\n- * Dumps the canonized image of given XML document into the provided buffer.\n- * For details see \"Canonical XML\" (http:\/\/www.w3.org\/TR\/xml-c14n) or\n- * \"Exclusive XML Canonicalization\" (http:\/\/www.w3.org\/TR\/xml-exc-c14n)\n- *\n- * Returns non-negative value on success or a negative value on fail\n- *\/\n-int\n-xmlC14NExecute(xmlDocPtr doc, xmlC14NIsVisibleCallback is_visible_callback,\n-     void* user_data, int mode, xmlChar **inclusive_ns_prefixes,\n-     int with_comments, xmlOutputBufferPtr buf) {\n-\n-    xmlC14NCtxPtr ctx;\n-    xmlC14NMode c14n_mode = XML_C14N_1_0;\n-    int ret;\n-\n-    if ((buf == NULL) || (doc == NULL)) {\n-        xmlC14NErrParam(NULL);\n-        return (-1);\n-    }\n-\n-    \/* for backward compatibility, we have to have \"mode\" as \"int\"\n-       and here we check that user gives valid value *\/\n-    switch(mode) {\n-    case XML_C14N_1_0:\n-    case XML_C14N_EXCLUSIVE_1_0:\n-    case XML_C14N_1_1:\n-         c14n_mode = (xmlC14NMode)mode;\n-         break;\n-    default:\n-        xmlC14NErrParam(NULL);\n-        return (-1);\n-    }\n-\n-    \/*\n-     *  Validate the encoding output buffer encoding\n-     *\/\n-    if (buf->encoder != NULL) {\n-        xmlC14NErr(NULL, (xmlNodePtr) doc, XML_C14N_REQUIRES_UTF8,\n-\"xmlC14NExecute: output buffer encoder != NULL but C14N requires UTF8 output\\n\");\n-        return (-1);\n-    }\n-\n-    ctx = xmlC14NNewCtx(doc, is_visible_callback, user_data,\n-                c14n_mode, inclusive_ns_prefixes,\n-                    with_comments, buf);\n-    if (ctx == NULL) {\n-        xmlC14NErr(NULL, (xmlNodePtr) doc, XML_C14N_CREATE_CTXT,\n-           \"xmlC14NExecute: unable to create C14N context\\n\");\n-        return (-1);\n-    }\n-\n-\n-\n-    \/*\n-     * Root Node\n-     * The root node is the parent of the top-level document element. The\n-     * result of processing each of its child nodes that is in the node-set\n-     * in document order. The root node does not generate a byte order mark,\n-     * XML declaration, nor anything from within the document type\n-     * declaration.\n-     *\/\n-    if (doc->children != NULL) {\n-        ret = xmlC14NProcessNodeList(ctx, doc->children);\n-        if (ret < 0) {\n-            xmlC14NFreeCtx(ctx);\n-            return (-1);\n-        }\n-    }\n-\n-    \/*\n-     * Flush buffer to get number of bytes written\n-     *\/\n-    ret = xmlOutputBufferFlush(buf);\n-    if (ret < 0) {\n-        xmlC14NErr(ctx, NULL, buf->error, \"flushing output buffer\");\n-        xmlC14NFreeCtx(ctx);\n-        return (-1);\n-    }\n-\n-    \/*\n-     * Cleanup\n-     *\/\n-    xmlC14NFreeCtx(ctx);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlC14NDocSaveTo:\n- * @doc:        the XML document for canonization\n- * @nodes:        the nodes set to be included in the canonized image\n- *        or NULL if all document nodes should be included\n- * @mode:        the c14n mode (see @xmlC14NMode)\n- * @inclusive_ns_prefixes: the list of inclusive namespace prefixes\n- *            ended with a NULL or NULL if there is no\n- *            inclusive namespaces (only for exclusive\n- *            canonicalization, ignored otherwise)\n- * @with_comments:    include comments in the result (!=0) or not (==0)\n- * @buf:        the output buffer to store canonical XML; this\n- *            buffer MUST have encoder==NULL because C14N requires\n- *            UTF-8 output\n- *\n- * Dumps the canonized image of given XML document into the provided buffer.\n- * For details see \"Canonical XML\" (http:\/\/www.w3.org\/TR\/xml-c14n) or\n- * \"Exclusive XML Canonicalization\" (http:\/\/www.w3.org\/TR\/xml-exc-c14n)\n- *\n- * Returns non-negative value on success or a negative value on fail\n- *\/\n-int\n-xmlC14NDocSaveTo(xmlDocPtr doc, xmlNodeSetPtr nodes,\n-                 int mode, xmlChar ** inclusive_ns_prefixes,\n-                 int with_comments, xmlOutputBufferPtr buf) {\n-    return(xmlC14NExecute(doc,\n-            xmlC14NIsNodeInNodeset,\n-            nodes,\n-            mode,\n-            inclusive_ns_prefixes,\n-            with_comments,\n-            buf));\n-}\n-\n-\n-\/**\n- * xmlC14NDocDumpMemory:\n- * @doc:        the XML document for canonization\n- * @nodes:        the nodes set to be included in the canonized image\n- *        or NULL if all document nodes should be included\n- * @mode:        the c14n mode (see @xmlC14NMode)\n- * @inclusive_ns_prefixes: the list of inclusive namespace prefixes\n- *            ended with a NULL or NULL if there is no\n- *            inclusive namespaces (only for exclusive\n- *            canonicalization, ignored otherwise)\n- * @with_comments:    include comments in the result (!=0) or not (==0)\n- * @doc_txt_ptr:    the memory pointer for allocated canonical XML text;\n- *            the caller of this functions is responsible for calling\n- *            xmlFree() to free allocated memory\n- *\n- * Dumps the canonized image of given XML document into memory.\n- * For details see \"Canonical XML\" (http:\/\/www.w3.org\/TR\/xml-c14n) or\n- * \"Exclusive XML Canonicalization\" (http:\/\/www.w3.org\/TR\/xml-exc-c14n)\n- *\n- * Returns the number of bytes written on success or a negative value on fail\n- *\/\n-int\n-xmlC14NDocDumpMemory(xmlDocPtr doc, xmlNodeSetPtr nodes,\n-                     int mode, xmlChar ** inclusive_ns_prefixes,\n-                     int with_comments, xmlChar ** doc_txt_ptr)\n-{\n-    int ret;\n-    xmlOutputBufferPtr buf;\n-\n-    if (doc_txt_ptr == NULL) {\n-        xmlC14NErrParam(NULL);\n-        return (-1);\n-    }\n-\n-    *doc_txt_ptr = NULL;\n-\n-    \/*\n-     * create memory buffer with UTF8 (default) encoding\n-     *\/\n-    buf = xmlAllocOutputBuffer(NULL);\n-    if (buf == NULL) {\n-        xmlC14NErrMemory(NULL);\n-        return (-1);\n-    }\n-\n-    \/*\n-     * canonize document and write to buffer\n-     *\/\n-    ret = xmlC14NDocSaveTo(doc, nodes, mode, inclusive_ns_prefixes,\n-                           with_comments, buf);\n-    if (ret < 0) {\n-        (void) xmlOutputBufferClose(buf);\n-        return (-1);\n-    }\n-\n-    ret = xmlBufUse(buf->buffer);\n-    if (ret >= 0) {\n-        *doc_txt_ptr = xmlStrndup(xmlBufContent(buf->buffer), ret);\n-    }\n-    (void) xmlOutputBufferClose(buf);\n-\n-    if ((*doc_txt_ptr == NULL) && (ret >= 0)) {\n-        xmlC14NErrMemory(NULL);\n-        return (-1);\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlC14NDocSave:\n- * @doc:        the XML document for canonization\n- * @nodes:        the nodes set to be included in the canonized image\n- *        or NULL if all document nodes should be included\n- * @mode:        the c14n mode (see @xmlC14NMode)\n- * @inclusive_ns_prefixes: the list of inclusive namespace prefixes\n- *            ended with a NULL or NULL if there is no\n- *            inclusive namespaces (only for exclusive\n- *            canonicalization, ignored otherwise)\n- * @with_comments:    include comments in the result (!=0) or not (==0)\n- * @filename:        the filename to store canonical XML image\n- * @compression:    the compression level (zlib required):\n- *                -1 - libxml default,\n- *                 0 - uncompressed,\n- *                >0 - compression level\n- *\n- * Dumps the canonized image of given XML document into the file.\n- * For details see \"Canonical XML\" (http:\/\/www.w3.org\/TR\/xml-c14n) or\n- * \"Exclusive XML Canonicalization\" (http:\/\/www.w3.org\/TR\/xml-exc-c14n)\n- *\n- * Returns the number of bytes written success or a negative value on fail\n- *\/\n-int\n-xmlC14NDocSave(xmlDocPtr doc, xmlNodeSetPtr nodes,\n-               int mode, xmlChar ** inclusive_ns_prefixes,\n-               int with_comments, const char *filename, int compression)\n-{\n-    xmlOutputBufferPtr buf;\n-    int ret;\n-\n-    if (filename == NULL) {\n-        xmlC14NErrParam(NULL);\n-        return (-1);\n-    }\n-#ifdef LIBXML_ZLIB_ENABLED\n-    if (compression < 0)\n-        compression = xmlGetCompressMode();\n-#endif\n-\n-    \/*\n-     * save the content to a temp buffer, use default UTF8 encoding.\n-     *\/\n-    buf = xmlOutputBufferCreateFilename(filename, NULL, compression);\n-    if (buf == NULL) {\n-        xmlC14NErr(NULL, NULL, XML_IO_UNKNOWN, \"creating temporary filename\");\n-        return (-1);\n-    }\n-\n-    \/*\n-     * canonize document and write to buffer\n-     *\/\n-    ret = xmlC14NDocSaveTo(doc, nodes, mode, inclusive_ns_prefixes,\n-                           with_comments, buf);\n-    if (ret < 0) {\n-        (void) xmlOutputBufferClose(buf);\n-        return (-1);\n-    }\n-\n-    \/*\n-     * get the numbers of bytes written\n-     *\/\n-    ret = xmlOutputBufferClose(buf);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlC11NNormalizeString:\n- * @input:        the input string\n- * @mode:        the normalization mode (attribute, comment, PI or text)\n- *\n- * Converts a string to a canonical (normalized) format. The code is stolen\n- * from xmlEncodeEntitiesReentrant(). Added normalization of \\x09, \\x0a, \\x0A\n- * and the @mode parameter\n- *\n- * Returns a normalized string (caller is responsible for calling xmlFree())\n- * or NULL if an error occurs\n- *\/\n-static xmlChar *\n-xmlC11NNormalizeString(const xmlChar * input,\n-                       xmlC14NNormalizationMode mode)\n-{\n-    const xmlChar *cur = input;\n-    xmlChar *buffer = NULL;\n-    xmlChar *out = NULL;\n-    int buffer_size = 0;\n-\n-    if (input == NULL)\n-        return (NULL);\n-\n-    \/*\n-     * allocate an translation buffer.\n-     *\/\n-    buffer_size = 1000;\n-    buffer = (xmlChar *) xmlMallocAtomic(buffer_size);\n-    if (buffer == NULL)\n-        return (NULL);\n-    out = buffer;\n-\n-    while (*cur != '\\0') {\n-        if ((out - buffer) > (buffer_size - 10)) {\n-            xmlChar *tmp;\n-            int indx = out - buffer;\n-\n-            buffer_size *= 2;\n-            tmp = xmlRealloc(buffer, buffer_size);\n-            if (tmp == NULL) {\n-                xmlFree(buffer);\n-                return(NULL);\n-            }\n-            buffer = tmp;\n-            out = &buffer[indx];\n-        }\n-\n-        if ((*cur == '<') && ((mode == XMLC14N_NORMALIZE_ATTR) ||\n-                              (mode == XMLC14N_NORMALIZE_TEXT))) {\n-            *out++ = '&';\n-            *out++ = 'l';\n-            *out++ = 't';\n-            *out++ = ';';\n-        } else if ((*cur == '>') && (mode == XMLC14N_NORMALIZE_TEXT)) {\n-            *out++ = '&';\n-            *out++ = 'g';\n-            *out++ = 't';\n-            *out++ = ';';\n-        } else if ((*cur == '&') && ((mode == XMLC14N_NORMALIZE_ATTR) ||\n-                                     (mode == XMLC14N_NORMALIZE_TEXT))) {\n-            *out++ = '&';\n-            *out++ = 'a';\n-            *out++ = 'm';\n-            *out++ = 'p';\n-            *out++ = ';';\n-        } else if ((*cur == '\"') && (mode == XMLC14N_NORMALIZE_ATTR)) {\n-            *out++ = '&';\n-            *out++ = 'q';\n-            *out++ = 'u';\n-            *out++ = 'o';\n-            *out++ = 't';\n-            *out++ = ';';\n-        } else if ((*cur == '\\x09') && (mode == XMLC14N_NORMALIZE_ATTR)) {\n-            *out++ = '&';\n-            *out++ = '#';\n-            *out++ = 'x';\n-            *out++ = '9';\n-            *out++ = ';';\n-        } else if ((*cur == '\\x0A') && (mode == XMLC14N_NORMALIZE_ATTR)) {\n-            *out++ = '&';\n-            *out++ = '#';\n-            *out++ = 'x';\n-            *out++ = 'A';\n-            *out++ = ';';\n-        } else if ((*cur == '\\x0D') && ((mode == XMLC14N_NORMALIZE_ATTR) ||\n-                                        (mode == XMLC14N_NORMALIZE_TEXT) ||\n-                                        (mode == XMLC14N_NORMALIZE_COMMENT) ||\n-                    (mode == XMLC14N_NORMALIZE_PI))) {\n-            *out++ = '&';\n-            *out++ = '#';\n-            *out++ = 'x';\n-            *out++ = 'D';\n-            *out++ = ';';\n-        } else {\n-            \/*\n-             * Works because on UTF-8, all extended sequences cannot\n-             * result in bytes in the ASCII range.\n-             *\/\n-            *out++ = *cur;\n-        }\n-        cur++;\n-    }\n-    *out = 0;\n-    return (buffer);\n-}\n-\n-#endif \/* LIBXML_C14N_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/c14n.c","additions":0,"deletions":2215,"binary":false,"changes":2215,"status":"deleted"},{"patch":"@@ -1,3761 +0,0 @@\n-\/**\n- * catalog.c: set of generic Catalog related routines\n- *\n- * Reference:  SGML Open Technical Resolution TR9401:1997.\n- *             http:\/\/www.jclark.com\/sp\/catalog.htm\n- *\n- *             XML Catalogs Working Draft 06 August 2001\n- *             http:\/\/www.oasis-open.org\/committees\/entity\/spec-2001-08-06.html\n- *\n- * See Copyright for the status of this software.\n- *\n- * Daniel.Veillard@imag.fr\n- *\/\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-\n-#ifdef LIBXML_CATALOG_ENABLED\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#ifdef HAVE_SYS_STAT_H\n-#include <sys\/stat.h>\n-#endif\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#elif defined (_WIN32)\n-#include <io.h>\n-#endif\n-#ifdef HAVE_FCNTL_H\n-#include <fcntl.h>\n-#endif\n-#include <libxml\/xmlmemory.h>\n-#include <libxml\/hash.h>\n-#include <libxml\/uri.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/catalog.h>\n-#include <libxml\/xmlerror.h>\n-#include <libxml\/threads.h>\n-\n-#include \"private\/buf.h\"\n-#include \"private\/error.h\"\n-\n-#define MAX_DELEGATE    50\n-#define MAX_CATAL_DEPTH    50\n-\n-#ifdef _WIN32\n-# define PATH_SEPARATOR ';'\n-#else\n-# define PATH_SEPARATOR ':'\n-#endif\n-\n-#define XML_URN_PUBID \"urn:publicid:\"\n-#define XML_CATAL_BREAK ((xmlChar *) -1)\n-#ifndef XML_XML_DEFAULT_CATALOG\n-#define XML_XML_DEFAULT_CATALOG \"file:\/\/\" SYSCONFDIR \"\/xml\/catalog\"\n-#endif\n-#ifndef XML_SGML_DEFAULT_CATALOG\n-#define XML_SGML_DEFAULT_CATALOG \"file:\/\/\" SYSCONFDIR \"\/sgml\/catalog\"\n-#endif\n-\n-static xmlChar *xmlCatalogNormalizePublic(const xmlChar *pubID);\n-static int xmlExpandCatalog(xmlCatalogPtr catal, const char *filename);\n-\n-\/************************************************************************\n- *                                    *\n- *            Types, all private                *\n- *                                    *\n- ************************************************************************\/\n-\n-typedef enum {\n-    XML_CATA_REMOVED = -1,\n-    XML_CATA_NONE = 0,\n-    XML_CATA_CATALOG,\n-    XML_CATA_BROKEN_CATALOG,\n-    XML_CATA_NEXT_CATALOG,\n-    XML_CATA_GROUP,\n-    XML_CATA_PUBLIC,\n-    XML_CATA_SYSTEM,\n-    XML_CATA_REWRITE_SYSTEM,\n-    XML_CATA_DELEGATE_PUBLIC,\n-    XML_CATA_DELEGATE_SYSTEM,\n-    XML_CATA_URI,\n-    XML_CATA_REWRITE_URI,\n-    XML_CATA_DELEGATE_URI,\n-    SGML_CATA_SYSTEM,\n-    SGML_CATA_PUBLIC,\n-    SGML_CATA_ENTITY,\n-    SGML_CATA_PENTITY,\n-    SGML_CATA_DOCTYPE,\n-    SGML_CATA_LINKTYPE,\n-    SGML_CATA_NOTATION,\n-    SGML_CATA_DELEGATE,\n-    SGML_CATA_BASE,\n-    SGML_CATA_CATALOG,\n-    SGML_CATA_DOCUMENT,\n-    SGML_CATA_SGMLDECL\n-} xmlCatalogEntryType;\n-\n-typedef struct _xmlCatalogEntry xmlCatalogEntry;\n-typedef xmlCatalogEntry *xmlCatalogEntryPtr;\n-struct _xmlCatalogEntry {\n-    struct _xmlCatalogEntry *next;\n-    struct _xmlCatalogEntry *parent;\n-    struct _xmlCatalogEntry *children;\n-    xmlCatalogEntryType type;\n-    xmlChar *name;\n-    xmlChar *value;\n-    xmlChar *URL;  \/* The expanded URL using the base *\/\n-    xmlCatalogPrefer prefer;\n-    int dealloc;\n-    int depth;\n-    struct _xmlCatalogEntry *group;\n-};\n-\n-typedef enum {\n-    XML_XML_CATALOG_TYPE = 1,\n-    XML_SGML_CATALOG_TYPE\n-} xmlCatalogType;\n-\n-#define XML_MAX_SGML_CATA_DEPTH 10\n-struct _xmlCatalog {\n-    xmlCatalogType type;    \/* either XML or SGML *\/\n-\n-    \/*\n-     * SGML Catalogs are stored as a simple hash table of catalog entries\n-     * Catalog stack to check against overflows when building the\n-     * SGML catalog\n-     *\/\n-    char *catalTab[XML_MAX_SGML_CATA_DEPTH];    \/* stack of catals *\/\n-    int          catalNr;    \/* Number of current catal streams *\/\n-    int          catalMax;    \/* Max number of catal streams *\/\n-    xmlHashTablePtr sgml;\n-\n-    \/*\n-     * XML Catalogs are stored as a tree of Catalog entries\n-     *\/\n-    xmlCatalogPrefer prefer;\n-    xmlCatalogEntryPtr xml;\n-};\n-\n-\/************************************************************************\n- *                                    *\n- *            Global variables                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/*\n- * Those are preferences\n- *\/\n-static int xmlDebugCatalogs = 0;   \/* used for debugging *\/\n-static xmlCatalogAllow xmlCatalogDefaultAllow = XML_CATA_ALLOW_ALL;\n-static xmlCatalogPrefer xmlCatalogDefaultPrefer = XML_CATA_PREFER_PUBLIC;\n-\n-\/*\n- * Hash table containing all the trees of XML catalogs parsed by\n- * the application.\n- *\/\n-static xmlHashTablePtr xmlCatalogXMLFiles = NULL;\n-\n-\/*\n- * The default catalog in use by the application\n- *\/\n-static xmlCatalogPtr xmlDefaultCatalog = NULL;\n-\n-\/*\n- * A mutex for modifying the shared global catalog(s)\n- * xmlDefaultCatalog tree.\n- * It also protects xmlCatalogXMLFiles\n- * The core of this readers\/writer scheme is in xmlFetchXMLCatalogFile()\n- *\/\n-static xmlRMutexPtr xmlCatalogMutex = NULL;\n-\n-\/*\n- * Whether the catalog support was initialized.\n- *\/\n-static int xmlCatalogInitialized = 0;\n-\n-\/************************************************************************\n- *                                    *\n- *            Catalog error handlers                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlCatalogErrMemory:\n- * @extra:  extra information\n- *\n- * Handle an out of memory condition\n- *\/\n-static void\n-xmlCatalogErrMemory(void)\n-{\n-    xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_CATALOG, NULL);\n-}\n-\n-\/**\n- * xmlCatalogErr:\n- * @catal: the Catalog entry\n- * @node: the context node\n- * @msg:  the error message\n- * @extra:  extra information\n- *\n- * Handle a catalog error\n- *\/\n-static void LIBXML_ATTR_FORMAT(4,0)\n-xmlCatalogErr(xmlCatalogEntryPtr catal, xmlNodePtr node, int error,\n-               const char *msg, const xmlChar *str1, const xmlChar *str2,\n-           const xmlChar *str3)\n-{\n-    int res;\n-\n-    res = __xmlRaiseError(NULL, NULL, NULL, catal, node,\n-                          XML_FROM_CATALOG, error, XML_ERR_ERROR, NULL, 0,\n-                          (const char *) str1, (const char *) str2,\n-                          (const char *) str3, 0, 0,\n-                          msg, str1, str2, str3);\n-    if (res < 0)\n-        xmlCatalogErrMemory();\n-}\n-\n-\n-\/************************************************************************\n- *                                    *\n- *            Allocation and Freeing                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlNewCatalogEntry:\n- * @type:  type of entry\n- * @name:  name of the entry\n- * @value:  value of the entry\n- * @prefer:  the PUBLIC vs. SYSTEM current preference value\n- * @group:  for members of a group, the group entry\n- *\n- * create a new Catalog entry, this type is shared both by XML and\n- * SGML catalogs, but the acceptable types values differs.\n- *\n- * Returns the xmlCatalogEntryPtr or NULL in case of error\n- *\/\n-static xmlCatalogEntryPtr\n-xmlNewCatalogEntry(xmlCatalogEntryType type, const xmlChar *name,\n-       const xmlChar *value, const xmlChar *URL, xmlCatalogPrefer prefer,\n-       xmlCatalogEntryPtr group) {\n-    xmlCatalogEntryPtr ret;\n-    xmlChar *normid = NULL;\n-\n-    ret = (xmlCatalogEntryPtr) xmlMalloc(sizeof(xmlCatalogEntry));\n-    if (ret == NULL) {\n-        xmlCatalogErrMemory();\n-    return(NULL);\n-    }\n-    ret->next = NULL;\n-    ret->parent = NULL;\n-    ret->children = NULL;\n-    ret->type = type;\n-    if (type == XML_CATA_PUBLIC || type == XML_CATA_DELEGATE_PUBLIC) {\n-        normid = xmlCatalogNormalizePublic(name);\n-        if (normid != NULL)\n-            name = (*normid != 0 ? normid : NULL);\n-    }\n-    if (name != NULL)\n-    ret->name = xmlStrdup(name);\n-    else\n-    ret->name = NULL;\n-    if (normid != NULL)\n-        xmlFree(normid);\n-    if (value != NULL)\n-    ret->value = xmlStrdup(value);\n-    else\n-    ret->value = NULL;\n-    if (URL == NULL)\n-    URL = value;\n-    if (URL != NULL)\n-    ret->URL = xmlStrdup(URL);\n-    else\n-    ret->URL = NULL;\n-    ret->prefer = prefer;\n-    ret->dealloc = 0;\n-    ret->depth = 0;\n-    ret->group = group;\n-    return(ret);\n-}\n-\n-static void\n-xmlFreeCatalogEntryList(xmlCatalogEntryPtr ret);\n-\n-\/**\n- * xmlFreeCatalogEntry:\n- * @payload:  a Catalog entry\n- *\n- * Free the memory allocated to a Catalog entry\n- *\/\n-static void\n-xmlFreeCatalogEntry(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {\n-    xmlCatalogEntryPtr ret = (xmlCatalogEntryPtr) payload;\n-    if (ret == NULL)\n-    return;\n-    \/*\n-     * Entries stored in the file hash must be deallocated\n-     * only by the file hash cleaner !\n-     *\/\n-    if (ret->dealloc == 1)\n-    return;\n-\n-    if (xmlDebugCatalogs) {\n-    if (ret->name != NULL)\n-        fprintf(stderr,\n-            \"Free catalog entry %s\\n\", ret->name);\n-    else if (ret->value != NULL)\n-        fprintf(stderr,\n-            \"Free catalog entry %s\\n\", ret->value);\n-    else\n-        fprintf(stderr,\n-            \"Free catalog entry\\n\");\n-    }\n-\n-    if (ret->name != NULL)\n-    xmlFree(ret->name);\n-    if (ret->value != NULL)\n-    xmlFree(ret->value);\n-    if (ret->URL != NULL)\n-    xmlFree(ret->URL);\n-    xmlFree(ret);\n-}\n-\n-\/**\n- * xmlFreeCatalogEntryList:\n- * @ret:  a Catalog entry list\n- *\n- * Free the memory allocated to a full chained list of Catalog entries\n- *\/\n-static void\n-xmlFreeCatalogEntryList(xmlCatalogEntryPtr ret) {\n-    xmlCatalogEntryPtr next;\n-\n-    while (ret != NULL) {\n-    next = ret->next;\n-    xmlFreeCatalogEntry(ret, NULL);\n-    ret = next;\n-    }\n-}\n-\n-\/**\n- * xmlFreeCatalogHashEntryList:\n- * @payload:  a Catalog entry list\n- *\n- * Free the memory allocated to list of Catalog entries from the\n- * catalog file hash.\n- *\/\n-static void\n-xmlFreeCatalogHashEntryList(void *payload,\n-                            const xmlChar *name ATTRIBUTE_UNUSED) {\n-    xmlCatalogEntryPtr catal = (xmlCatalogEntryPtr) payload;\n-    xmlCatalogEntryPtr children, next;\n-\n-    if (catal == NULL)\n-    return;\n-\n-    children = catal->children;\n-    while (children != NULL) {\n-    next = children->next;\n-    children->dealloc = 0;\n-    children->children = NULL;\n-    xmlFreeCatalogEntry(children, NULL);\n-    children = next;\n-    }\n-    catal->dealloc = 0;\n-    xmlFreeCatalogEntry(catal, NULL);\n-}\n-\n-\/**\n- * xmlCreateNewCatalog:\n- * @type:  type of catalog\n- * @prefer:  the PUBLIC vs. SYSTEM current preference value\n- *\n- * create a new Catalog, this type is shared both by XML and\n- * SGML catalogs, but the acceptable types values differs.\n- *\n- * Returns the xmlCatalogPtr or NULL in case of error\n- *\/\n-static xmlCatalogPtr\n-xmlCreateNewCatalog(xmlCatalogType type, xmlCatalogPrefer prefer) {\n-    xmlCatalogPtr ret;\n-\n-    ret = (xmlCatalogPtr) xmlMalloc(sizeof(xmlCatalog));\n-    if (ret == NULL) {\n-        xmlCatalogErrMemory();\n-    return(NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlCatalog));\n-    ret->type = type;\n-    ret->catalNr = 0;\n-    ret->catalMax = XML_MAX_SGML_CATA_DEPTH;\n-    ret->prefer = prefer;\n-    if (ret->type == XML_SGML_CATALOG_TYPE)\n-    ret->sgml = xmlHashCreate(10);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlFreeCatalog:\n- * @catal:  a Catalog\n- *\n- * Free the memory allocated to a Catalog\n- *\/\n-void\n-xmlFreeCatalog(xmlCatalogPtr catal) {\n-    if (catal == NULL)\n-    return;\n-    if (catal->xml != NULL)\n-    xmlFreeCatalogEntryList(catal->xml);\n-    if (catal->sgml != NULL)\n-    xmlHashFree(catal->sgml, xmlFreeCatalogEntry);\n-    xmlFree(catal);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Serializing Catalogs                *\n- *                                    *\n- ************************************************************************\/\n-\n-#ifdef LIBXML_OUTPUT_ENABLED\n-\/**\n- * xmlCatalogDumpEntry:\n- * @entry:  the catalog entry\n- * @out:  the file.\n- *\n- * Serialize an SGML Catalog entry\n- *\/\n-static void\n-xmlCatalogDumpEntry(void *payload, void *data,\n-                    const xmlChar *name ATTRIBUTE_UNUSED) {\n-    xmlCatalogEntryPtr entry = (xmlCatalogEntryPtr) payload;\n-    FILE *out = (FILE *) data;\n-    if ((entry == NULL) || (out == NULL))\n-    return;\n-    switch (entry->type) {\n-    case SGML_CATA_ENTITY:\n-        fprintf(out, \"ENTITY \"); break;\n-    case SGML_CATA_PENTITY:\n-        fprintf(out, \"ENTITY %%\"); break;\n-    case SGML_CATA_DOCTYPE:\n-        fprintf(out, \"DOCTYPE \"); break;\n-    case SGML_CATA_LINKTYPE:\n-        fprintf(out, \"LINKTYPE \"); break;\n-    case SGML_CATA_NOTATION:\n-        fprintf(out, \"NOTATION \"); break;\n-    case SGML_CATA_PUBLIC:\n-        fprintf(out, \"PUBLIC \"); break;\n-    case SGML_CATA_SYSTEM:\n-        fprintf(out, \"SYSTEM \"); break;\n-    case SGML_CATA_DELEGATE:\n-        fprintf(out, \"DELEGATE \"); break;\n-    case SGML_CATA_BASE:\n-        fprintf(out, \"BASE \"); break;\n-    case SGML_CATA_CATALOG:\n-        fprintf(out, \"CATALOG \"); break;\n-    case SGML_CATA_DOCUMENT:\n-        fprintf(out, \"DOCUMENT \"); break;\n-    case SGML_CATA_SGMLDECL:\n-        fprintf(out, \"SGMLDECL \"); break;\n-    default:\n-        return;\n-    }\n-    switch (entry->type) {\n-    case SGML_CATA_ENTITY:\n-    case SGML_CATA_PENTITY:\n-    case SGML_CATA_DOCTYPE:\n-    case SGML_CATA_LINKTYPE:\n-    case SGML_CATA_NOTATION:\n-        fprintf(out, \"%s\", (const char *) entry->name); break;\n-    case SGML_CATA_PUBLIC:\n-    case SGML_CATA_SYSTEM:\n-    case SGML_CATA_SGMLDECL:\n-    case SGML_CATA_DOCUMENT:\n-    case SGML_CATA_CATALOG:\n-    case SGML_CATA_BASE:\n-    case SGML_CATA_DELEGATE:\n-        fprintf(out, \"\\\"%s\\\"\", entry->name); break;\n-    default:\n-        break;\n-    }\n-    switch (entry->type) {\n-    case SGML_CATA_ENTITY:\n-    case SGML_CATA_PENTITY:\n-    case SGML_CATA_DOCTYPE:\n-    case SGML_CATA_LINKTYPE:\n-    case SGML_CATA_NOTATION:\n-    case SGML_CATA_PUBLIC:\n-    case SGML_CATA_SYSTEM:\n-    case SGML_CATA_DELEGATE:\n-        fprintf(out, \" \\\"%s\\\"\", entry->value); break;\n-    default:\n-        break;\n-    }\n-    fprintf(out, \"\\n\");\n-}\n-\n-\/**\n- * xmlDumpXMLCatalogNode:\n- * @catal:  top catalog entry\n- * @catalog: pointer to the xml tree\n- * @doc: the containing document\n- * @ns: the current namespace\n- * @cgroup: group node for group members\n- *\n- * Serializes a Catalog entry, called by xmlDumpXMLCatalog and recursively\n- * for group entries\n- *\/\n-static void xmlDumpXMLCatalogNode(xmlCatalogEntryPtr catal, xmlNodePtr catalog,\n-            xmlDocPtr doc, xmlNsPtr ns, xmlCatalogEntryPtr cgroup) {\n-    xmlNodePtr node;\n-    xmlCatalogEntryPtr cur;\n-    \/*\n-     * add all the catalog entries\n-     *\/\n-    cur = catal;\n-    while (cur != NULL) {\n-        if (cur->group == cgroup) {\n-        switch (cur->type) {\n-            case XML_CATA_REMOVED:\n-            break;\n-            case XML_CATA_BROKEN_CATALOG:\n-            case XML_CATA_CATALOG:\n-            if (cur == catal) {\n-            cur = cur->children;\n-                continue;\n-            }\n-            break;\n-        case XML_CATA_NEXT_CATALOG:\n-            node = xmlNewDocNode(doc, ns, BAD_CAST \"nextCatalog\", NULL);\n-            xmlSetProp(node, BAD_CAST \"catalog\", cur->value);\n-            xmlAddChild(catalog, node);\n-                    break;\n-        case XML_CATA_NONE:\n-            break;\n-        case XML_CATA_GROUP:\n-            node = xmlNewDocNode(doc, ns, BAD_CAST \"group\", NULL);\n-            xmlSetProp(node, BAD_CAST \"id\", cur->name);\n-            if (cur->value != NULL) {\n-                xmlNsPtr xns;\n-            xns = xmlSearchNsByHref(doc, node, XML_XML_NAMESPACE);\n-            if (xns != NULL)\n-                xmlSetNsProp(node, xns, BAD_CAST \"base\",\n-                     cur->value);\n-            }\n-            switch (cur->prefer) {\n-            case XML_CATA_PREFER_NONE:\n-                    break;\n-            case XML_CATA_PREFER_PUBLIC:\n-                    xmlSetProp(node, BAD_CAST \"prefer\", BAD_CAST \"public\");\n-                break;\n-            case XML_CATA_PREFER_SYSTEM:\n-                    xmlSetProp(node, BAD_CAST \"prefer\", BAD_CAST \"system\");\n-                break;\n-            }\n-            xmlDumpXMLCatalogNode(cur->next, node, doc, ns, cur);\n-            xmlAddChild(catalog, node);\n-                break;\n-        case XML_CATA_PUBLIC:\n-            node = xmlNewDocNode(doc, ns, BAD_CAST \"public\", NULL);\n-            xmlSetProp(node, BAD_CAST \"publicId\", cur->name);\n-            xmlSetProp(node, BAD_CAST \"uri\", cur->value);\n-            xmlAddChild(catalog, node);\n-            break;\n-        case XML_CATA_SYSTEM:\n-            node = xmlNewDocNode(doc, ns, BAD_CAST \"system\", NULL);\n-            xmlSetProp(node, BAD_CAST \"systemId\", cur->name);\n-            xmlSetProp(node, BAD_CAST \"uri\", cur->value);\n-            xmlAddChild(catalog, node);\n-            break;\n-        case XML_CATA_REWRITE_SYSTEM:\n-            node = xmlNewDocNode(doc, ns, BAD_CAST \"rewriteSystem\", NULL);\n-            xmlSetProp(node, BAD_CAST \"systemIdStartString\", cur->name);\n-            xmlSetProp(node, BAD_CAST \"rewritePrefix\", cur->value);\n-            xmlAddChild(catalog, node);\n-            break;\n-        case XML_CATA_DELEGATE_PUBLIC:\n-            node = xmlNewDocNode(doc, ns, BAD_CAST \"delegatePublic\", NULL);\n-            xmlSetProp(node, BAD_CAST \"publicIdStartString\", cur->name);\n-            xmlSetProp(node, BAD_CAST \"catalog\", cur->value);\n-            xmlAddChild(catalog, node);\n-            break;\n-        case XML_CATA_DELEGATE_SYSTEM:\n-            node = xmlNewDocNode(doc, ns, BAD_CAST \"delegateSystem\", NULL);\n-            xmlSetProp(node, BAD_CAST \"systemIdStartString\", cur->name);\n-            xmlSetProp(node, BAD_CAST \"catalog\", cur->value);\n-            xmlAddChild(catalog, node);\n-            break;\n-        case XML_CATA_URI:\n-            node = xmlNewDocNode(doc, ns, BAD_CAST \"uri\", NULL);\n-            xmlSetProp(node, BAD_CAST \"name\", cur->name);\n-            xmlSetProp(node, BAD_CAST \"uri\", cur->value);\n-            xmlAddChild(catalog, node);\n-            break;\n-        case XML_CATA_REWRITE_URI:\n-            node = xmlNewDocNode(doc, ns, BAD_CAST \"rewriteURI\", NULL);\n-            xmlSetProp(node, BAD_CAST \"uriStartString\", cur->name);\n-            xmlSetProp(node, BAD_CAST \"rewritePrefix\", cur->value);\n-            xmlAddChild(catalog, node);\n-            break;\n-        case XML_CATA_DELEGATE_URI:\n-            node = xmlNewDocNode(doc, ns, BAD_CAST \"delegateURI\", NULL);\n-            xmlSetProp(node, BAD_CAST \"uriStartString\", cur->name);\n-            xmlSetProp(node, BAD_CAST \"catalog\", cur->value);\n-            xmlAddChild(catalog, node);\n-            break;\n-        case SGML_CATA_SYSTEM:\n-        case SGML_CATA_PUBLIC:\n-        case SGML_CATA_ENTITY:\n-        case SGML_CATA_PENTITY:\n-        case SGML_CATA_DOCTYPE:\n-        case SGML_CATA_LINKTYPE:\n-        case SGML_CATA_NOTATION:\n-        case SGML_CATA_DELEGATE:\n-        case SGML_CATA_BASE:\n-        case SGML_CATA_CATALOG:\n-        case SGML_CATA_DOCUMENT:\n-        case SGML_CATA_SGMLDECL:\n-            break;\n-        }\n-        }\n-    cur = cur->next;\n-    }\n-}\n-\n-static int\n-xmlDumpXMLCatalog(FILE *out, xmlCatalogEntryPtr catal) {\n-    int ret;\n-    xmlDocPtr doc;\n-    xmlNsPtr ns;\n-    xmlDtdPtr dtd;\n-    xmlNodePtr catalog;\n-    xmlOutputBufferPtr buf;\n-\n-    \/*\n-     * Rebuild a catalog\n-     *\/\n-    doc = xmlNewDoc(NULL);\n-    if (doc == NULL)\n-    return(-1);\n-    dtd = xmlNewDtd(doc, BAD_CAST \"catalog\",\n-           BAD_CAST \"-\/\/OASIS\/\/DTD Entity Resolution XML Catalog V1.0\/\/EN\",\n-BAD_CAST \"http:\/\/www.oasis-open.org\/committees\/entity\/release\/1.0\/catalog.dtd\");\n-\n-    xmlAddChild((xmlNodePtr) doc, (xmlNodePtr) dtd);\n-\n-    ns = xmlNewNs(NULL, XML_CATALOGS_NAMESPACE, NULL);\n-    if (ns == NULL) {\n-    xmlFreeDoc(doc);\n-    return(-1);\n-    }\n-    catalog = xmlNewDocNode(doc, ns, BAD_CAST \"catalog\", NULL);\n-    if (catalog == NULL) {\n-    xmlFreeNs(ns);\n-    xmlFreeDoc(doc);\n-    return(-1);\n-    }\n-    catalog->nsDef = ns;\n-    xmlAddChild((xmlNodePtr) doc, catalog);\n-\n-    xmlDumpXMLCatalogNode(catal, catalog, doc, ns, NULL);\n-\n-    \/*\n-     * reserialize it\n-     *\/\n-    buf = xmlOutputBufferCreateFile(out, NULL);\n-    if (buf == NULL) {\n-    xmlFreeDoc(doc);\n-    return(-1);\n-    }\n-    ret = xmlSaveFormatFileTo(buf, doc, NULL, 1);\n-\n-    \/*\n-     * Free it\n-     *\/\n-    xmlFreeDoc(doc);\n-\n-    return(ret);\n-}\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-\n-\/************************************************************************\n- *                                    *\n- *            Converting SGML Catalogs to XML            *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlCatalogConvertEntry:\n- * @entry:  the entry\n- * @catal:  pointer to the catalog being converted\n- *\n- * Convert one entry from the catalog\n- *\/\n-static void\n-xmlCatalogConvertEntry(void *payload, void *data,\n-                       const xmlChar *name ATTRIBUTE_UNUSED) {\n-    xmlCatalogEntryPtr entry = (xmlCatalogEntryPtr) payload;\n-    xmlCatalogPtr catal = (xmlCatalogPtr) data;\n-    if ((entry == NULL) || (catal == NULL) || (catal->sgml == NULL) ||\n-    (catal->xml == NULL))\n-    return;\n-    switch (entry->type) {\n-    case SGML_CATA_ENTITY:\n-        entry->type = XML_CATA_PUBLIC;\n-        break;\n-    case SGML_CATA_PENTITY:\n-        entry->type = XML_CATA_PUBLIC;\n-        break;\n-    case SGML_CATA_DOCTYPE:\n-        entry->type = XML_CATA_PUBLIC;\n-        break;\n-    case SGML_CATA_LINKTYPE:\n-        entry->type = XML_CATA_PUBLIC;\n-        break;\n-    case SGML_CATA_NOTATION:\n-        entry->type = XML_CATA_PUBLIC;\n-        break;\n-    case SGML_CATA_PUBLIC:\n-        entry->type = XML_CATA_PUBLIC;\n-        break;\n-    case SGML_CATA_SYSTEM:\n-        entry->type = XML_CATA_SYSTEM;\n-        break;\n-    case SGML_CATA_DELEGATE:\n-        entry->type = XML_CATA_DELEGATE_PUBLIC;\n-        break;\n-    case SGML_CATA_CATALOG:\n-        entry->type = XML_CATA_CATALOG;\n-        break;\n-    default:\n-        xmlHashRemoveEntry(catal->sgml, entry->name, xmlFreeCatalogEntry);\n-        return;\n-    }\n-    \/*\n-     * Conversion successful, remove from the SGML catalog\n-     * and add it to the default XML one\n-     *\/\n-    xmlHashRemoveEntry(catal->sgml, entry->name, NULL);\n-    entry->parent = catal->xml;\n-    entry->next = NULL;\n-    if (catal->xml->children == NULL)\n-    catal->xml->children = entry;\n-    else {\n-    xmlCatalogEntryPtr prev;\n-\n-    prev = catal->xml->children;\n-    while (prev->next != NULL)\n-        prev = prev->next;\n-    prev->next = entry;\n-    }\n-}\n-\n-\/**\n- * xmlConvertSGMLCatalog:\n- * @catal: the catalog\n- *\n- * Convert all the SGML catalog entries as XML ones\n- *\n- * Returns the number of entries converted if successful, -1 otherwise\n- *\/\n-int\n-xmlConvertSGMLCatalog(xmlCatalogPtr catal) {\n-\n-    if ((catal == NULL) || (catal->type != XML_SGML_CATALOG_TYPE))\n-    return(-1);\n-\n-    if (xmlDebugCatalogs) {\n-    fprintf(stderr,\n-        \"Converting SGML catalog to XML\\n\");\n-    }\n-    xmlHashScan(catal->sgml, xmlCatalogConvertEntry, &catal);\n-    return(0);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Helper function                    *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlCatalogUnWrapURN:\n- * @urn:  an \"urn:publicid:\" to unwrap\n- *\n- * Expand the URN into the equivalent Public Identifier\n- *\n- * Returns the new identifier or NULL, the string must be deallocated\n- *         by the caller.\n- *\/\n-static xmlChar *\n-xmlCatalogUnWrapURN(const xmlChar *urn) {\n-    xmlChar result[2000];\n-    unsigned int i = 0;\n-\n-    if (xmlStrncmp(urn, BAD_CAST XML_URN_PUBID, sizeof(XML_URN_PUBID) - 1))\n-    return(NULL);\n-    urn += sizeof(XML_URN_PUBID) - 1;\n-\n-    while (*urn != 0) {\n-    if (i > sizeof(result) - 4)\n-        break;\n-    if (*urn == '+') {\n-        result[i++] = ' ';\n-        urn++;\n-    } else if (*urn == ':') {\n-        result[i++] = '\/';\n-        result[i++] = '\/';\n-        urn++;\n-    } else if (*urn == ';') {\n-        result[i++] = ':';\n-        result[i++] = ':';\n-        urn++;\n-    } else if (*urn == '%') {\n-        if ((urn[1] == '2') && (urn[2] == 'B'))\n-        result[i++] = '+';\n-        else if ((urn[1] == '3') && (urn[2] == 'A'))\n-        result[i++] = ':';\n-        else if ((urn[1] == '2') && (urn[2] == 'F'))\n-        result[i++] = '\/';\n-        else if ((urn[1] == '3') && (urn[2] == 'B'))\n-        result[i++] = ';';\n-        else if ((urn[1] == '2') && (urn[2] == '7'))\n-        result[i++] = '\\'';\n-        else if ((urn[1] == '3') && (urn[2] == 'F'))\n-        result[i++] = '?';\n-        else if ((urn[1] == '2') && (urn[2] == '3'))\n-        result[i++] = '#';\n-        else if ((urn[1] == '2') && (urn[2] == '5'))\n-        result[i++] = '%';\n-        else {\n-        result[i++] = *urn;\n-        urn++;\n-        continue;\n-        }\n-        urn += 3;\n-    } else {\n-        result[i++] = *urn;\n-        urn++;\n-    }\n-    }\n-    result[i] = 0;\n-\n-    return(xmlStrdup(result));\n-}\n-\n-\/**\n- * xmlParseCatalogFile:\n- * @filename:  the filename\n- *\n- * parse an XML file and build a tree. It's like xmlParseFile()\n- * except it bypass all catalog lookups.\n- *\n- * Returns the resulting document tree or NULL in case of error\n- *\/\n-\n-xmlDocPtr\n-xmlParseCatalogFile(const char *filename) {\n-    xmlDocPtr ret;\n-    xmlParserCtxtPtr ctxt;\n-    xmlParserInputPtr inputStream;\n-    xmlParserInputBufferPtr buf;\n-\n-    ctxt = xmlNewParserCtxt();\n-    if (ctxt == NULL) {\n-        xmlCatalogErrMemory();\n-    return(NULL);\n-    }\n-\n-    buf = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);\n-    if (buf == NULL) {\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n-    }\n-\n-    inputStream = xmlNewInputStream(ctxt);\n-    if (inputStream == NULL) {\n-    xmlFreeParserInputBuffer(buf);\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n-    }\n-\n-    inputStream->filename = (char *) xmlCanonicPath((const xmlChar *)filename);\n-    inputStream->buf = buf;\n-    xmlBufResetInput(buf->buffer, inputStream);\n-\n-    inputPush(ctxt, inputStream);\n-\n-    ctxt->valid = 0;\n-    ctxt->validate = 0;\n-    ctxt->loadsubset = 0;\n-    ctxt->pedantic = 0;\n-    ctxt->dictNames = 1;\n-\n-    xmlParseDocument(ctxt);\n-\n-    if (ctxt->wellFormed)\n-    ret = ctxt->myDoc;\n-    else {\n-        ret = NULL;\n-        xmlFreeDoc(ctxt->myDoc);\n-        ctxt->myDoc = NULL;\n-    }\n-    xmlFreeParserCtxt(ctxt);\n-\n-    return(ret);\n-}\n-\n-\/**\n- * xmlLoadFileContent:\n- * @filename:  a file path\n- *\n- * Load a file content into memory.\n- *\n- * Returns a pointer to the 0 terminated string or NULL in case of error\n- *\/\n-static xmlChar *\n-xmlLoadFileContent(const char *filename)\n-{\n-#ifdef HAVE_STAT\n-    int fd;\n-#else\n-    FILE *fd;\n-#endif\n-    int len;\n-    long size;\n-\n-#ifdef HAVE_STAT\n-    struct stat info;\n-#endif\n-    xmlChar *content;\n-\n-    if (filename == NULL)\n-        return (NULL);\n-\n-#ifdef HAVE_STAT\n-    if (stat(filename, &info) < 0)\n-        return (NULL);\n-#endif\n-\n-#ifdef HAVE_STAT\n-    if ((fd = open(filename, O_RDONLY)) < 0)\n-#else\n-    if ((fd = fopen(filename, \"rb\")) == NULL)\n-#endif\n-    {\n-        return (NULL);\n-    }\n-#ifdef HAVE_STAT\n-    size = info.st_size;\n-#else\n-    if (fseek(fd, 0, SEEK_END) || (size = ftell(fd)) == EOF || fseek(fd, 0, SEEK_SET)) {        \/* File operations denied? ok, just close and return failure *\/\n-        fclose(fd);\n-        return (NULL);\n-    }\n-#endif\n-    content = (xmlChar*)xmlMallocAtomic(size + 10);\n-    if (content == NULL) {\n-        xmlCatalogErrMemory();\n-#ifdef HAVE_STAT\n-    close(fd);\n-#else\n-    fclose(fd);\n-#endif\n-        return (NULL);\n-    }\n-#ifdef HAVE_STAT\n-    len = read(fd, content, size);\n-    close(fd);\n-#else\n-    len = fread(content, 1, size, fd);\n-    fclose(fd);\n-#endif\n-    if (len < 0) {\n-        xmlFree(content);\n-        return (NULL);\n-    }\n-    content[len] = 0;\n-\n-    return(content);\n-}\n-\n-\/**\n- * xmlCatalogNormalizePublic:\n- * @pubID:  the public ID string\n- *\n- *  Normalizes the Public Identifier\n- *\n- * Implements 6.2. Public Identifier Normalization\n- * from http:\/\/www.oasis-open.org\/committees\/entity\/spec-2001-08-06.html\n- *\n- * Returns the new string or NULL, the string must be deallocated\n- *         by the caller.\n- *\/\n-static xmlChar *\n-xmlCatalogNormalizePublic(const xmlChar *pubID)\n-{\n-    int ok = 1;\n-    int white;\n-    const xmlChar *p;\n-    xmlChar *ret;\n-    xmlChar *q;\n-\n-    if (pubID == NULL)\n-        return(NULL);\n-\n-    white = 1;\n-    for (p = pubID;*p != 0 && ok;p++) {\n-        if (!xmlIsBlank_ch(*p))\n-            white = 0;\n-        else if (*p == 0x20 && !white)\n-            white = 1;\n-        else\n-            ok = 0;\n-    }\n-    if (ok && !white)    \/* is normalized *\/\n-        return(NULL);\n-\n-    ret = xmlStrdup(pubID);\n-    q = ret;\n-    white = 0;\n-    for (p = pubID;*p != 0;p++) {\n-        if (xmlIsBlank_ch(*p)) {\n-            if (q != ret)\n-                white = 1;\n-        } else {\n-            if (white) {\n-                *(q++) = 0x20;\n-                white = 0;\n-            }\n-            *(q++) = *p;\n-        }\n-    }\n-    *q = 0;\n-    return(ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            The XML Catalog parser                *\n- *                                    *\n- ************************************************************************\/\n-\n-static xmlCatalogEntryPtr\n-xmlParseXMLCatalogFile(xmlCatalogPrefer prefer, const xmlChar *filename);\n-static void\n-xmlParseXMLCatalogNodeList(xmlNodePtr cur, xmlCatalogPrefer prefer,\n-                       xmlCatalogEntryPtr parent, xmlCatalogEntryPtr cgroup);\n-static xmlChar *\n-xmlCatalogListXMLResolve(xmlCatalogEntryPtr catal, const xmlChar *pubID,\n-                  const xmlChar *sysID);\n-static xmlChar *\n-xmlCatalogListXMLResolveURI(xmlCatalogEntryPtr catal, const xmlChar *URI);\n-\n-\n-\/**\n- * xmlGetXMLCatalogEntryType:\n- * @name:  the name\n- *\n- * lookup the internal type associated to an XML catalog entry name\n- *\n- * Returns the type associated with that name\n- *\/\n-static xmlCatalogEntryType\n-xmlGetXMLCatalogEntryType(const xmlChar *name) {\n-    xmlCatalogEntryType type = XML_CATA_NONE;\n-    if (xmlStrEqual(name, (const xmlChar *) \"system\"))\n-    type = XML_CATA_SYSTEM;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"public\"))\n-    type = XML_CATA_PUBLIC;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"rewriteSystem\"))\n-    type = XML_CATA_REWRITE_SYSTEM;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"delegatePublic\"))\n-    type = XML_CATA_DELEGATE_PUBLIC;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"delegateSystem\"))\n-    type = XML_CATA_DELEGATE_SYSTEM;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"uri\"))\n-    type = XML_CATA_URI;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"rewriteURI\"))\n-    type = XML_CATA_REWRITE_URI;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"delegateURI\"))\n-    type = XML_CATA_DELEGATE_URI;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"nextCatalog\"))\n-    type = XML_CATA_NEXT_CATALOG;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"catalog\"))\n-    type = XML_CATA_CATALOG;\n-    return(type);\n-}\n-\n-\/**\n- * xmlParseXMLCatalogOneNode:\n- * @cur:  the XML node\n- * @type:  the type of Catalog entry\n- * @name:  the name of the node\n- * @attrName:  the attribute holding the value\n- * @uriAttrName:  the attribute holding the URI-Reference\n- * @prefer:  the PUBLIC vs. SYSTEM current preference value\n- * @cgroup:  the group which includes this node\n- *\n- * Finishes the examination of an XML tree node of a catalog and build\n- * a Catalog entry from it.\n- *\n- * Returns the new Catalog entry node or NULL in case of error.\n- *\/\n-static xmlCatalogEntryPtr\n-xmlParseXMLCatalogOneNode(xmlNodePtr cur, xmlCatalogEntryType type,\n-              const xmlChar *name, const xmlChar *attrName,\n-              const xmlChar *uriAttrName, xmlCatalogPrefer prefer,\n-              xmlCatalogEntryPtr cgroup) {\n-    int ok = 1;\n-    xmlChar *uriValue;\n-    xmlChar *nameValue = NULL;\n-    xmlChar *base = NULL;\n-    xmlChar *URL = NULL;\n-    xmlCatalogEntryPtr ret = NULL;\n-\n-    if (attrName != NULL) {\n-    nameValue = xmlGetProp(cur, attrName);\n-    if (nameValue == NULL) {\n-        xmlCatalogErr(ret, cur, XML_CATALOG_MISSING_ATTR,\n-              \"%s entry lacks '%s'\\n\", name, attrName, NULL);\n-        ok = 0;\n-    }\n-    }\n-    uriValue = xmlGetProp(cur, uriAttrName);\n-    if (uriValue == NULL) {\n-    xmlCatalogErr(ret, cur, XML_CATALOG_MISSING_ATTR,\n-        \"%s entry lacks '%s'\\n\", name, uriAttrName, NULL);\n-    ok = 0;\n-    }\n-    if (!ok) {\n-    if (nameValue != NULL)\n-        xmlFree(nameValue);\n-    if (uriValue != NULL)\n-        xmlFree(uriValue);\n-    return(NULL);\n-    }\n-\n-    base = xmlNodeGetBase(cur->doc, cur);\n-    URL = xmlBuildURI(uriValue, base);\n-    if (URL != NULL) {\n-    if (xmlDebugCatalogs > 1) {\n-        if (nameValue != NULL)\n-        fprintf(stderr,\n-            \"Found %s: '%s' '%s'\\n\", name, nameValue, URL);\n-        else\n-        fprintf(stderr,\n-            \"Found %s: '%s'\\n\", name, URL);\n-    }\n-    ret = xmlNewCatalogEntry(type, nameValue, uriValue, URL, prefer, cgroup);\n-    } else {\n-    xmlCatalogErr(ret, cur, XML_CATALOG_ENTRY_BROKEN,\n-        \"%s entry '%s' broken ?: %s\\n\", name, uriAttrName, uriValue);\n-    }\n-    if (nameValue != NULL)\n-    xmlFree(nameValue);\n-    if (uriValue != NULL)\n-    xmlFree(uriValue);\n-    if (base != NULL)\n-    xmlFree(base);\n-    if (URL != NULL)\n-    xmlFree(URL);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlParseXMLCatalogNode:\n- * @cur:  the XML node\n- * @prefer:  the PUBLIC vs. SYSTEM current preference value\n- * @parent:  the parent Catalog entry\n- * @cgroup:  the group which includes this node\n- *\n- * Examines an XML tree node of a catalog and build\n- * a Catalog entry from it adding it to its parent. The examination can\n- * be recursive.\n- *\/\n-static void\n-xmlParseXMLCatalogNode(xmlNodePtr cur, xmlCatalogPrefer prefer,\n-                   xmlCatalogEntryPtr parent, xmlCatalogEntryPtr cgroup)\n-{\n-    xmlChar *base = NULL;\n-    xmlCatalogEntryPtr entry = NULL;\n-\n-    if (cur == NULL)\n-        return;\n-    if (xmlStrEqual(cur->name, BAD_CAST \"group\")) {\n-        xmlChar *prop;\n-    xmlCatalogPrefer pref = XML_CATA_PREFER_NONE;\n-\n-        prop = xmlGetProp(cur, BAD_CAST \"prefer\");\n-        if (prop != NULL) {\n-            if (xmlStrEqual(prop, BAD_CAST \"system\")) {\n-                prefer = XML_CATA_PREFER_SYSTEM;\n-            } else if (xmlStrEqual(prop, BAD_CAST \"public\")) {\n-                prefer = XML_CATA_PREFER_PUBLIC;\n-            } else {\n-        xmlCatalogErr(parent, cur, XML_CATALOG_PREFER_VALUE,\n-                              \"Invalid value for prefer: '%s'\\n\",\n-                  prop, NULL, NULL);\n-            }\n-            xmlFree(prop);\n-        pref = prefer;\n-        }\n-    prop = xmlGetProp(cur, BAD_CAST \"id\");\n-    base = xmlGetNsProp(cur, BAD_CAST \"base\", XML_XML_NAMESPACE);\n-    entry = xmlNewCatalogEntry(XML_CATA_GROUP, prop, base, NULL, pref, cgroup);\n-    xmlFree(prop);\n-    } else if (xmlStrEqual(cur->name, BAD_CAST \"public\")) {\n-    entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_PUBLIC,\n-        BAD_CAST \"public\", BAD_CAST \"publicId\", BAD_CAST \"uri\", prefer, cgroup);\n-    } else if (xmlStrEqual(cur->name, BAD_CAST \"system\")) {\n-    entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_SYSTEM,\n-        BAD_CAST \"system\", BAD_CAST \"systemId\", BAD_CAST \"uri\", prefer, cgroup);\n-    } else if (xmlStrEqual(cur->name, BAD_CAST \"rewriteSystem\")) {\n-    entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_REWRITE_SYSTEM,\n-        BAD_CAST \"rewriteSystem\", BAD_CAST \"systemIdStartString\",\n-        BAD_CAST \"rewritePrefix\", prefer, cgroup);\n-    } else if (xmlStrEqual(cur->name, BAD_CAST \"delegatePublic\")) {\n-    entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_DELEGATE_PUBLIC,\n-        BAD_CAST \"delegatePublic\", BAD_CAST \"publicIdStartString\",\n-        BAD_CAST \"catalog\", prefer, cgroup);\n-    } else if (xmlStrEqual(cur->name, BAD_CAST \"delegateSystem\")) {\n-    entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_DELEGATE_SYSTEM,\n-        BAD_CAST \"delegateSystem\", BAD_CAST \"systemIdStartString\",\n-        BAD_CAST \"catalog\", prefer, cgroup);\n-    } else if (xmlStrEqual(cur->name, BAD_CAST \"uri\")) {\n-    entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_URI,\n-        BAD_CAST \"uri\", BAD_CAST \"name\",\n-        BAD_CAST \"uri\", prefer, cgroup);\n-    } else if (xmlStrEqual(cur->name, BAD_CAST \"rewriteURI\")) {\n-    entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_REWRITE_URI,\n-        BAD_CAST \"rewriteURI\", BAD_CAST \"uriStartString\",\n-        BAD_CAST \"rewritePrefix\", prefer, cgroup);\n-    } else if (xmlStrEqual(cur->name, BAD_CAST \"delegateURI\")) {\n-    entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_DELEGATE_URI,\n-        BAD_CAST \"delegateURI\", BAD_CAST \"uriStartString\",\n-        BAD_CAST \"catalog\", prefer, cgroup);\n-    } else if (xmlStrEqual(cur->name, BAD_CAST \"nextCatalog\")) {\n-    entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_NEXT_CATALOG,\n-        BAD_CAST \"nextCatalog\", NULL,\n-        BAD_CAST \"catalog\", prefer, cgroup);\n-    }\n-    if (entry != NULL) {\n-        if (parent != NULL) {\n-        entry->parent = parent;\n-        if (parent->children == NULL)\n-        parent->children = entry;\n-        else {\n-        xmlCatalogEntryPtr prev;\n-\n-        prev = parent->children;\n-        while (prev->next != NULL)\n-            prev = prev->next;\n-        prev->next = entry;\n-        }\n-    }\n-    if (entry->type == XML_CATA_GROUP) {\n-        \/*\n-         * Recurse to propagate prefer to the subtree\n-         * (xml:base handling is automated)\n-         *\/\n-            xmlParseXMLCatalogNodeList(cur->children, prefer, parent, entry);\n-    }\n-    }\n-    if (base != NULL)\n-    xmlFree(base);\n-}\n-\n-\/**\n- * xmlParseXMLCatalogNodeList:\n- * @cur:  the XML node list of siblings\n- * @prefer:  the PUBLIC vs. SYSTEM current preference value\n- * @parent:  the parent Catalog entry\n- * @cgroup:  the group which includes this list\n- *\n- * Examines a list of XML sibling nodes of a catalog and build\n- * a list of Catalog entry from it adding it to the parent.\n- * The examination will recurse to examine node subtrees.\n- *\/\n-static void\n-xmlParseXMLCatalogNodeList(xmlNodePtr cur, xmlCatalogPrefer prefer,\n-                       xmlCatalogEntryPtr parent, xmlCatalogEntryPtr cgroup) {\n-    while (cur != NULL) {\n-    if ((cur->ns != NULL) && (cur->ns->href != NULL) &&\n-        (xmlStrEqual(cur->ns->href, XML_CATALOGS_NAMESPACE))) {\n-        xmlParseXMLCatalogNode(cur, prefer, parent, cgroup);\n-    }\n-    cur = cur->next;\n-    }\n-    \/* TODO: sort the list according to REWRITE lengths and prefer value *\/\n-}\n-\n-\/**\n- * xmlParseXMLCatalogFile:\n- * @prefer:  the PUBLIC vs. SYSTEM current preference value\n- * @filename:  the filename for the catalog\n- *\n- * Parses the catalog file to extract the XML tree and then analyze the\n- * tree to build a list of Catalog entries corresponding to this catalog\n- *\n- * Returns the resulting Catalog entries list\n- *\/\n-static xmlCatalogEntryPtr\n-xmlParseXMLCatalogFile(xmlCatalogPrefer prefer, const xmlChar *filename) {\n-    xmlDocPtr doc;\n-    xmlNodePtr cur;\n-    xmlChar *prop;\n-    xmlCatalogEntryPtr parent = NULL;\n-\n-    if (filename == NULL)\n-        return(NULL);\n-\n-    doc = xmlParseCatalogFile((const char *) filename);\n-    if (doc == NULL) {\n-    if (xmlDebugCatalogs)\n-        fprintf(stderr,\n-            \"Failed to parse catalog %s\\n\", filename);\n-    return(NULL);\n-    }\n-\n-    if (xmlDebugCatalogs)\n-    fprintf(stderr,\n-        \"%d Parsing catalog %s\\n\", xmlGetThreadId(), filename);\n-\n-    cur = xmlDocGetRootElement(doc);\n-    if ((cur != NULL) && (xmlStrEqual(cur->name, BAD_CAST \"catalog\")) &&\n-    (cur->ns != NULL) && (cur->ns->href != NULL) &&\n-    (xmlStrEqual(cur->ns->href, XML_CATALOGS_NAMESPACE))) {\n-\n-    parent = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,\n-                    (const xmlChar *)filename, NULL, prefer, NULL);\n-        if (parent == NULL) {\n-        xmlFreeDoc(doc);\n-        return(NULL);\n-    }\n-\n-    prop = xmlGetProp(cur, BAD_CAST \"prefer\");\n-    if (prop != NULL) {\n-        if (xmlStrEqual(prop, BAD_CAST \"system\")) {\n-        prefer = XML_CATA_PREFER_SYSTEM;\n-        } else if (xmlStrEqual(prop, BAD_CAST \"public\")) {\n-        prefer = XML_CATA_PREFER_PUBLIC;\n-        } else {\n-        xmlCatalogErr(NULL, cur, XML_CATALOG_PREFER_VALUE,\n-                  \"Invalid value for prefer: '%s'\\n\",\n-                  prop, NULL, NULL);\n-        }\n-        xmlFree(prop);\n-    }\n-    cur = cur->children;\n-    xmlParseXMLCatalogNodeList(cur, prefer, parent, NULL);\n-    } else {\n-    xmlCatalogErr(NULL, (xmlNodePtr) doc, XML_CATALOG_NOT_CATALOG,\n-              \"File %s is not an XML Catalog\\n\",\n-              filename, NULL, NULL);\n-    xmlFreeDoc(doc);\n-    return(NULL);\n-    }\n-    xmlFreeDoc(doc);\n-    return(parent);\n-}\n-\n-\/**\n- * xmlFetchXMLCatalogFile:\n- * @catal:  an existing but incomplete catalog entry\n- *\n- * Fetch and parse the subcatalog referenced by an entry\n- *\n- * Returns 0 in case of success, -1 otherwise\n- *\/\n-static int\n-xmlFetchXMLCatalogFile(xmlCatalogEntryPtr catal) {\n-    xmlCatalogEntryPtr doc;\n-\n-    if (catal == NULL)\n-    return(-1);\n-    if (catal->URL == NULL)\n-    return(-1);\n-\n-    \/*\n-     * lock the whole catalog for modification\n-     *\/\n-    xmlRMutexLock(xmlCatalogMutex);\n-    if (catal->children != NULL) {\n-    \/* Okay someone else did it in the meantime *\/\n-    xmlRMutexUnlock(xmlCatalogMutex);\n-    return(0);\n-    }\n-\n-    if (xmlCatalogXMLFiles != NULL) {\n-    doc = (xmlCatalogEntryPtr)\n-        xmlHashLookup(xmlCatalogXMLFiles, catal->URL);\n-    if (doc != NULL) {\n-        if (xmlDebugCatalogs)\n-        fprintf(stderr,\n-            \"Found %s in file hash\\n\", catal->URL);\n-\n-        if (catal->type == XML_CATA_CATALOG)\n-        catal->children = doc->children;\n-        else\n-        catal->children = doc;\n-        catal->dealloc = 0;\n-        xmlRMutexUnlock(xmlCatalogMutex);\n-        return(0);\n-    }\n-    if (xmlDebugCatalogs)\n-        fprintf(stderr,\n-        \"%s not found in file hash\\n\", catal->URL);\n-    }\n-\n-    \/*\n-     * Fetch and parse. Note that xmlParseXMLCatalogFile does not\n-     * use the existing catalog, there is no recursion allowed at\n-     * that level.\n-     *\/\n-    doc = xmlParseXMLCatalogFile(catal->prefer, catal->URL);\n-    if (doc == NULL) {\n-    catal->type = XML_CATA_BROKEN_CATALOG;\n-    xmlRMutexUnlock(xmlCatalogMutex);\n-    return(-1);\n-    }\n-\n-    if (catal->type == XML_CATA_CATALOG)\n-    catal->children = doc->children;\n-    else\n-    catal->children = doc;\n-\n-    doc->dealloc = 1;\n-\n-    if (xmlCatalogXMLFiles == NULL)\n-    xmlCatalogXMLFiles = xmlHashCreate(10);\n-    if (xmlCatalogXMLFiles != NULL) {\n-    if (xmlDebugCatalogs)\n-        fprintf(stderr,\n-        \"%s added to file hash\\n\", catal->URL);\n-    xmlHashAddEntry(xmlCatalogXMLFiles, catal->URL, doc);\n-    }\n-    xmlRMutexUnlock(xmlCatalogMutex);\n-    return(0);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            XML Catalog handling                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlAddXMLCatalog:\n- * @catal:  top of an XML catalog\n- * @type:  the type of record to add to the catalog\n- * @orig:  the system, public or prefix to match (or NULL)\n- * @replace:  the replacement value for the match\n- *\n- * Add an entry in the XML catalog, it may overwrite existing but\n- * different entries.\n- *\n- * Returns 0 if successful, -1 otherwise\n- *\/\n-static int\n-xmlAddXMLCatalog(xmlCatalogEntryPtr catal, const xmlChar *type,\n-          const xmlChar *orig, const xmlChar *replace) {\n-    xmlCatalogEntryPtr cur;\n-    xmlCatalogEntryType typ;\n-    int doregister = 0;\n-\n-    if ((catal == NULL) ||\n-    ((catal->type != XML_CATA_CATALOG) &&\n-     (catal->type != XML_CATA_BROKEN_CATALOG)))\n-    return(-1);\n-    if (catal->children == NULL) {\n-    xmlFetchXMLCatalogFile(catal);\n-    }\n-    if (catal->children == NULL)\n-    doregister = 1;\n-\n-    typ = xmlGetXMLCatalogEntryType(type);\n-    if (typ == XML_CATA_NONE) {\n-    if (xmlDebugCatalogs)\n-        fprintf(stderr,\n-            \"Failed to add unknown element %s to catalog\\n\", type);\n-    return(-1);\n-    }\n-\n-    cur = catal->children;\n-    \/*\n-     * Might be a simple \"update in place\"\n-     *\/\n-    if (cur != NULL) {\n-    while (cur != NULL) {\n-        if ((orig != NULL) && (cur->type == typ) &&\n-        (xmlStrEqual(orig, cur->name))) {\n-        if (xmlDebugCatalogs)\n-            fprintf(stderr,\n-                \"Updating element %s to catalog\\n\", type);\n-        if (cur->value != NULL)\n-            xmlFree(cur->value);\n-        if (cur->URL != NULL)\n-            xmlFree(cur->URL);\n-        cur->value = xmlStrdup(replace);\n-        cur->URL = xmlStrdup(replace);\n-        return(0);\n-        }\n-        if (cur->next == NULL)\n-        break;\n-        cur = cur->next;\n-    }\n-    }\n-    if (xmlDebugCatalogs)\n-    fprintf(stderr,\n-        \"Adding element %s to catalog\\n\", type);\n-    if (cur == NULL)\n-    catal->children = xmlNewCatalogEntry(typ, orig, replace,\n-                                     NULL, catal->prefer, NULL);\n-    else\n-    cur->next = xmlNewCatalogEntry(typ, orig, replace,\n-                               NULL, catal->prefer, NULL);\n-    if (doregister) {\n-        catal->type = XML_CATA_CATALOG;\n-    cur = (xmlCatalogEntryPtr)xmlHashLookup(xmlCatalogXMLFiles, catal->URL);\n-    if (cur != NULL)\n-        cur->children = catal->children;\n-    }\n-\n-    return(0);\n-}\n-\n-\/**\n- * xmlDelXMLCatalog:\n- * @catal:  top of an XML catalog\n- * @value:  the value to remove from the catalog\n- *\n- * Remove entries in the XML catalog where the value or the URI\n- * is equal to @value\n- *\n- * Returns the number of entries removed if successful, -1 otherwise\n- *\/\n-static int\n-xmlDelXMLCatalog(xmlCatalogEntryPtr catal, const xmlChar *value) {\n-    xmlCatalogEntryPtr cur;\n-    int ret = 0;\n-\n-    if ((catal == NULL) ||\n-    ((catal->type != XML_CATA_CATALOG) &&\n-     (catal->type != XML_CATA_BROKEN_CATALOG)))\n-    return(-1);\n-    if (value == NULL)\n-    return(-1);\n-    if (catal->children == NULL) {\n-    xmlFetchXMLCatalogFile(catal);\n-    }\n-\n-    \/*\n-     * Scan the children\n-     *\/\n-    cur = catal->children;\n-    while (cur != NULL) {\n-    if (((cur->name != NULL) && (xmlStrEqual(value, cur->name))) ||\n-        (xmlStrEqual(value, cur->value))) {\n-        if (xmlDebugCatalogs) {\n-        if (cur->name != NULL)\n-            fprintf(stderr,\n-                \"Removing element %s from catalog\\n\", cur->name);\n-        else\n-            fprintf(stderr,\n-                \"Removing element %s from catalog\\n\", cur->value);\n-        }\n-        cur->type = XML_CATA_REMOVED;\n-    }\n-    cur = cur->next;\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlCatalogXMLResolve:\n- * @catal:  a catalog list\n- * @pubID:  the public ID string\n- * @sysID:  the system ID string\n- *\n- * Do a complete resolution lookup of an External Identifier for a\n- * list of catalog entries.\n- *\n- * Implements (or tries to) 7.1. External Identifier Resolution\n- * from http:\/\/www.oasis-open.org\/committees\/entity\/spec-2001-08-06.html\n- *\n- * Returns the URI of the resource or NULL if not found\n- *\/\n-static xmlChar *\n-xmlCatalogXMLResolve(xmlCatalogEntryPtr catal, const xmlChar *pubID,\n-                  const xmlChar *sysID) {\n-    xmlChar *ret = NULL;\n-    xmlCatalogEntryPtr cur;\n-    int haveDelegate = 0;\n-    int haveNext = 0;\n-\n-    \/*\n-     * protection against loops\n-     *\/\n-    if (catal->depth > MAX_CATAL_DEPTH) {\n-    xmlCatalogErr(catal, NULL, XML_CATALOG_RECURSION,\n-              \"Detected recursion in catalog %s\\n\",\n-              catal->name, NULL, NULL);\n-    return(NULL);\n-    }\n-    catal->depth++;\n-\n-    \/*\n-     * First tries steps 2\/ 3\/ 4\/ if a system ID is provided.\n-     *\/\n-    if (sysID != NULL) {\n-    xmlCatalogEntryPtr rewrite = NULL;\n-    int lenrewrite = 0, len;\n-    cur = catal;\n-    haveDelegate = 0;\n-    while (cur != NULL) {\n-        switch (cur->type) {\n-        case XML_CATA_SYSTEM:\n-            if (xmlStrEqual(sysID, cur->name)) {\n-            if (xmlDebugCatalogs)\n-                fprintf(stderr,\n-                    \"Found system match %s, using %s\\n\",\n-                            cur->name, cur->URL);\n-            catal->depth--;\n-            return(xmlStrdup(cur->URL));\n-            }\n-            break;\n-        case XML_CATA_REWRITE_SYSTEM:\n-            len = xmlStrlen(cur->name);\n-            if ((len > lenrewrite) &&\n-            (!xmlStrncmp(sysID, cur->name, len))) {\n-            lenrewrite = len;\n-            rewrite = cur;\n-            }\n-            break;\n-        case XML_CATA_DELEGATE_SYSTEM:\n-            if (!xmlStrncmp(sysID, cur->name, xmlStrlen(cur->name)))\n-            haveDelegate++;\n-            break;\n-        case XML_CATA_NEXT_CATALOG:\n-            haveNext++;\n-            break;\n-        default:\n-            break;\n-        }\n-        cur = cur->next;\n-    }\n-    if (rewrite != NULL) {\n-        if (xmlDebugCatalogs)\n-        fprintf(stderr,\n-            \"Using rewriting rule %s\\n\", rewrite->name);\n-        ret = xmlStrdup(rewrite->URL);\n-        if (ret != NULL)\n-        ret = xmlStrcat(ret, &sysID[lenrewrite]);\n-        catal->depth--;\n-        return(ret);\n-    }\n-    if (haveDelegate) {\n-        const xmlChar *delegates[MAX_DELEGATE];\n-        int nbList = 0, i;\n-\n-        \/*\n-         * Assume the entries have been sorted by decreasing substring\n-         * matches when the list was produced.\n-         *\/\n-        cur = catal;\n-        while (cur != NULL) {\n-        if ((cur->type == XML_CATA_DELEGATE_SYSTEM) &&\n-            (!xmlStrncmp(sysID, cur->name, xmlStrlen(cur->name)))) {\n-            for (i = 0;i < nbList;i++)\n-            if (xmlStrEqual(cur->URL, delegates[i]))\n-                break;\n-            if (i < nbList) {\n-            cur = cur->next;\n-            continue;\n-            }\n-            if (nbList < MAX_DELEGATE)\n-            delegates[nbList++] = cur->URL;\n-\n-            if (cur->children == NULL) {\n-            xmlFetchXMLCatalogFile(cur);\n-            }\n-            if (cur->children != NULL) {\n-            if (xmlDebugCatalogs)\n-                fprintf(stderr,\n-                    \"Trying system delegate %s\\n\", cur->URL);\n-            ret = xmlCatalogListXMLResolve(\n-                cur->children, NULL, sysID);\n-            if (ret != NULL) {\n-                catal->depth--;\n-                return(ret);\n-            }\n-            }\n-        }\n-        cur = cur->next;\n-        }\n-        \/*\n-         * Apply the cut algorithm explained in 4\/\n-         *\/\n-        catal->depth--;\n-        return(XML_CATAL_BREAK);\n-    }\n-    }\n-    \/*\n-     * Then tries 5\/ 6\/ if a public ID is provided\n-     *\/\n-    if (pubID != NULL) {\n-    cur = catal;\n-    haveDelegate = 0;\n-    while (cur != NULL) {\n-        switch (cur->type) {\n-        case XML_CATA_PUBLIC:\n-            if (xmlStrEqual(pubID, cur->name)) {\n-            if (xmlDebugCatalogs)\n-                fprintf(stderr,\n-                    \"Found public match %s\\n\", cur->name);\n-            catal->depth--;\n-            return(xmlStrdup(cur->URL));\n-            }\n-            break;\n-        case XML_CATA_DELEGATE_PUBLIC:\n-            if (!xmlStrncmp(pubID, cur->name, xmlStrlen(cur->name)) &&\n-            (cur->prefer == XML_CATA_PREFER_PUBLIC))\n-            haveDelegate++;\n-            break;\n-        case XML_CATA_NEXT_CATALOG:\n-            if (sysID == NULL)\n-            haveNext++;\n-            break;\n-        default:\n-            break;\n-        }\n-        cur = cur->next;\n-    }\n-    if (haveDelegate) {\n-        const xmlChar *delegates[MAX_DELEGATE];\n-        int nbList = 0, i;\n-\n-        \/*\n-         * Assume the entries have been sorted by decreasing substring\n-         * matches when the list was produced.\n-         *\/\n-        cur = catal;\n-        while (cur != NULL) {\n-        if ((cur->type == XML_CATA_DELEGATE_PUBLIC) &&\n-            (cur->prefer == XML_CATA_PREFER_PUBLIC) &&\n-            (!xmlStrncmp(pubID, cur->name, xmlStrlen(cur->name)))) {\n-\n-            for (i = 0;i < nbList;i++)\n-            if (xmlStrEqual(cur->URL, delegates[i]))\n-                break;\n-            if (i < nbList) {\n-            cur = cur->next;\n-            continue;\n-            }\n-            if (nbList < MAX_DELEGATE)\n-            delegates[nbList++] = cur->URL;\n-\n-            if (cur->children == NULL) {\n-            xmlFetchXMLCatalogFile(cur);\n-            }\n-            if (cur->children != NULL) {\n-            if (xmlDebugCatalogs)\n-                fprintf(stderr,\n-                    \"Trying public delegate %s\\n\", cur->URL);\n-            ret = xmlCatalogListXMLResolve(\n-                cur->children, pubID, NULL);\n-            if (ret != NULL) {\n-                catal->depth--;\n-                return(ret);\n-            }\n-            }\n-        }\n-        cur = cur->next;\n-        }\n-        \/*\n-         * Apply the cut algorithm explained in 4\/\n-         *\/\n-        catal->depth--;\n-        return(XML_CATAL_BREAK);\n-    }\n-    }\n-    if (haveNext) {\n-    cur = catal;\n-    while (cur != NULL) {\n-        if (cur->type == XML_CATA_NEXT_CATALOG) {\n-        if (cur->children == NULL) {\n-            xmlFetchXMLCatalogFile(cur);\n-        }\n-        if (cur->children != NULL) {\n-            ret = xmlCatalogListXMLResolve(cur->children, pubID, sysID);\n-            if (ret != NULL) {\n-            catal->depth--;\n-            return(ret);\n-            } else if (catal->depth > MAX_CATAL_DEPTH) {\n-                return(NULL);\n-            }\n-        }\n-        }\n-        cur = cur->next;\n-    }\n-    }\n-\n-    catal->depth--;\n-    return(NULL);\n-}\n-\n-\/**\n- * xmlCatalogXMLResolveURI:\n- * @catal:  a catalog list\n- * @URI:  the URI\n- * @sysID:  the system ID string\n- *\n- * Do a complete resolution lookup of an External Identifier for a\n- * list of catalog entries.\n- *\n- * Implements (or tries to) 7.2.2. URI Resolution\n- * from http:\/\/www.oasis-open.org\/committees\/entity\/spec-2001-08-06.html\n- *\n- * Returns the URI of the resource or NULL if not found\n- *\/\n-static xmlChar *\n-xmlCatalogXMLResolveURI(xmlCatalogEntryPtr catal, const xmlChar *URI) {\n-    xmlChar *ret = NULL;\n-    xmlCatalogEntryPtr cur;\n-    int haveDelegate = 0;\n-    int haveNext = 0;\n-    xmlCatalogEntryPtr rewrite = NULL;\n-    int lenrewrite = 0, len;\n-\n-    if (catal == NULL)\n-    return(NULL);\n-\n-    if (URI == NULL)\n-    return(NULL);\n-\n-    if (catal->depth > MAX_CATAL_DEPTH) {\n-    xmlCatalogErr(catal, NULL, XML_CATALOG_RECURSION,\n-              \"Detected recursion in catalog %s\\n\",\n-              catal->name, NULL, NULL);\n-    return(NULL);\n-    }\n-\n-    \/*\n-     * First tries steps 2\/ 3\/ 4\/ if a system ID is provided.\n-     *\/\n-    cur = catal;\n-    haveDelegate = 0;\n-    while (cur != NULL) {\n-    switch (cur->type) {\n-        case XML_CATA_URI:\n-        if (xmlStrEqual(URI, cur->name)) {\n-            if (xmlDebugCatalogs)\n-            fprintf(stderr,\n-                \"Found URI match %s\\n\", cur->name);\n-            return(xmlStrdup(cur->URL));\n-        }\n-        break;\n-        case XML_CATA_REWRITE_URI:\n-        len = xmlStrlen(cur->name);\n-        if ((len > lenrewrite) &&\n-            (!xmlStrncmp(URI, cur->name, len))) {\n-            lenrewrite = len;\n-            rewrite = cur;\n-        }\n-        break;\n-        case XML_CATA_DELEGATE_URI:\n-        if (!xmlStrncmp(URI, cur->name, xmlStrlen(cur->name)))\n-            haveDelegate++;\n-        break;\n-        case XML_CATA_NEXT_CATALOG:\n-        haveNext++;\n-        break;\n-        default:\n-        break;\n-    }\n-    cur = cur->next;\n-    }\n-    if (rewrite != NULL) {\n-    if (xmlDebugCatalogs)\n-        fprintf(stderr,\n-            \"Using rewriting rule %s\\n\", rewrite->name);\n-    ret = xmlStrdup(rewrite->URL);\n-    if (ret != NULL)\n-        ret = xmlStrcat(ret, &URI[lenrewrite]);\n-    return(ret);\n-    }\n-    if (haveDelegate) {\n-    const xmlChar *delegates[MAX_DELEGATE];\n-    int nbList = 0, i;\n-\n-    \/*\n-     * Assume the entries have been sorted by decreasing substring\n-     * matches when the list was produced.\n-     *\/\n-    cur = catal;\n-    while (cur != NULL) {\n-        if (((cur->type == XML_CATA_DELEGATE_SYSTEM) ||\n-             (cur->type == XML_CATA_DELEGATE_URI)) &&\n-        (!xmlStrncmp(URI, cur->name, xmlStrlen(cur->name)))) {\n-        for (i = 0;i < nbList;i++)\n-            if (xmlStrEqual(cur->URL, delegates[i]))\n-            break;\n-        if (i < nbList) {\n-            cur = cur->next;\n-            continue;\n-        }\n-        if (nbList < MAX_DELEGATE)\n-            delegates[nbList++] = cur->URL;\n-\n-        if (cur->children == NULL) {\n-            xmlFetchXMLCatalogFile(cur);\n-        }\n-        if (cur->children != NULL) {\n-            if (xmlDebugCatalogs)\n-            fprintf(stderr,\n-                \"Trying URI delegate %s\\n\", cur->URL);\n-            ret = xmlCatalogListXMLResolveURI(\n-                cur->children, URI);\n-            if (ret != NULL)\n-            return(ret);\n-        }\n-        }\n-        cur = cur->next;\n-    }\n-    \/*\n-     * Apply the cut algorithm explained in 4\/\n-     *\/\n-    return(XML_CATAL_BREAK);\n-    }\n-    if (haveNext) {\n-    cur = catal;\n-    while (cur != NULL) {\n-        if (cur->type == XML_CATA_NEXT_CATALOG) {\n-        if (cur->children == NULL) {\n-            xmlFetchXMLCatalogFile(cur);\n-        }\n-        if (cur->children != NULL) {\n-            ret = xmlCatalogListXMLResolveURI(cur->children, URI);\n-            if (ret != NULL)\n-            return(ret);\n-        }\n-        }\n-        cur = cur->next;\n-    }\n-    }\n-\n-    return(NULL);\n-}\n-\n-\/**\n- * xmlCatalogListXMLResolve:\n- * @catal:  a catalog list\n- * @pubID:  the public ID string\n- * @sysID:  the system ID string\n- *\n- * Do a complete resolution lookup of an External Identifier for a\n- * list of catalogs\n- *\n- * Implements (or tries to) 7.1. External Identifier Resolution\n- * from http:\/\/www.oasis-open.org\/committees\/entity\/spec-2001-08-06.html\n- *\n- * Returns the URI of the resource or NULL if not found\n- *\/\n-static xmlChar *\n-xmlCatalogListXMLResolve(xmlCatalogEntryPtr catal, const xmlChar *pubID,\n-                  const xmlChar *sysID) {\n-    xmlChar *ret = NULL;\n-    xmlChar *urnID = NULL;\n-    xmlChar *normid;\n-\n-    if (catal == NULL)\n-        return(NULL);\n-    if ((pubID == NULL) && (sysID == NULL))\n-    return(NULL);\n-\n-    normid = xmlCatalogNormalizePublic(pubID);\n-    if (normid != NULL)\n-        pubID = (*normid != 0 ? normid : NULL);\n-\n-    if (!xmlStrncmp(pubID, BAD_CAST XML_URN_PUBID, sizeof(XML_URN_PUBID) - 1)) {\n-    urnID = xmlCatalogUnWrapURN(pubID);\n-    if (xmlDebugCatalogs) {\n-        if (urnID == NULL)\n-        fprintf(stderr,\n-            \"Public URN ID %s expanded to NULL\\n\", pubID);\n-        else\n-        fprintf(stderr,\n-            \"Public URN ID expanded to %s\\n\", urnID);\n-    }\n-    ret = xmlCatalogListXMLResolve(catal, urnID, sysID);\n-    if (urnID != NULL)\n-        xmlFree(urnID);\n-    if (normid != NULL)\n-        xmlFree(normid);\n-    return(ret);\n-    }\n-    if (!xmlStrncmp(sysID, BAD_CAST XML_URN_PUBID, sizeof(XML_URN_PUBID) - 1)) {\n-    urnID = xmlCatalogUnWrapURN(sysID);\n-    if (xmlDebugCatalogs) {\n-        if (urnID == NULL)\n-        fprintf(stderr,\n-            \"System URN ID %s expanded to NULL\\n\", sysID);\n-        else\n-        fprintf(stderr,\n-            \"System URN ID expanded to %s\\n\", urnID);\n-    }\n-    if (pubID == NULL)\n-        ret = xmlCatalogListXMLResolve(catal, urnID, NULL);\n-    else if (xmlStrEqual(pubID, urnID))\n-        ret = xmlCatalogListXMLResolve(catal, pubID, NULL);\n-    else {\n-        ret = xmlCatalogListXMLResolve(catal, pubID, urnID);\n-    }\n-    if (urnID != NULL)\n-        xmlFree(urnID);\n-    if (normid != NULL)\n-        xmlFree(normid);\n-    return(ret);\n-    }\n-    while (catal != NULL) {\n-    if (catal->type == XML_CATA_CATALOG) {\n-        if (catal->children == NULL) {\n-        xmlFetchXMLCatalogFile(catal);\n-        }\n-        if (catal->children != NULL) {\n-        ret = xmlCatalogXMLResolve(catal->children, pubID, sysID);\n-        if (ret != NULL) {\n-            break;\n-                } else if (catal->children->depth > MAX_CATAL_DEPTH) {\n-                ret = NULL;\n-            break;\n-            }\n-        }\n-    }\n-    catal = catal->next;\n-    }\n-    if (normid != NULL)\n-    xmlFree(normid);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlCatalogListXMLResolveURI:\n- * @catal:  a catalog list\n- * @URI:  the URI\n- *\n- * Do a complete resolution lookup of an URI for a list of catalogs\n- *\n- * Implements (or tries to) 7.2. URI Resolution\n- * from http:\/\/www.oasis-open.org\/committees\/entity\/spec-2001-08-06.html\n- *\n- * Returns the URI of the resource or NULL if not found\n- *\/\n-static xmlChar *\n-xmlCatalogListXMLResolveURI(xmlCatalogEntryPtr catal, const xmlChar *URI) {\n-    xmlChar *ret = NULL;\n-    xmlChar *urnID = NULL;\n-\n-    if (catal == NULL)\n-        return(NULL);\n-    if (URI == NULL)\n-    return(NULL);\n-\n-    if (!xmlStrncmp(URI, BAD_CAST XML_URN_PUBID, sizeof(XML_URN_PUBID) - 1)) {\n-    urnID = xmlCatalogUnWrapURN(URI);\n-    if (xmlDebugCatalogs) {\n-        if (urnID == NULL)\n-        fprintf(stderr,\n-            \"URN ID %s expanded to NULL\\n\", URI);\n-        else\n-        fprintf(stderr,\n-            \"URN ID expanded to %s\\n\", urnID);\n-    }\n-    ret = xmlCatalogListXMLResolve(catal, urnID, NULL);\n-    if (urnID != NULL)\n-        xmlFree(urnID);\n-    return(ret);\n-    }\n-    while (catal != NULL) {\n-    if (catal->type == XML_CATA_CATALOG) {\n-        if (catal->children == NULL) {\n-        xmlFetchXMLCatalogFile(catal);\n-        }\n-        if (catal->children != NULL) {\n-        ret = xmlCatalogXMLResolveURI(catal->children, URI);\n-        if (ret != NULL)\n-            return(ret);\n-        }\n-    }\n-    catal = catal->next;\n-    }\n-    return(ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            The SGML Catalog parser                *\n- *                                    *\n- ************************************************************************\/\n-\n-\n-#define RAW *cur\n-#define NEXT cur++;\n-#define SKIP(x) cur += x;\n-\n-#define SKIP_BLANKS while (IS_BLANK_CH(*cur)) NEXT;\n-\n-\/**\n- * xmlParseSGMLCatalogComment:\n- * @cur:  the current character\n- *\n- * Skip a comment in an SGML catalog\n- *\n- * Returns new current character\n- *\/\n-static const xmlChar *\n-xmlParseSGMLCatalogComment(const xmlChar *cur) {\n-    if ((cur[0] != '-') || (cur[1] != '-'))\n-    return(cur);\n-    SKIP(2);\n-    while ((cur[0] != 0) && ((cur[0] != '-') || ((cur[1] != '-'))))\n-    NEXT;\n-    if (cur[0] == 0) {\n-    return(NULL);\n-    }\n-    return(cur + 2);\n-}\n-\n-\/**\n- * xmlParseSGMLCatalogPubid:\n- * @cur:  the current character\n- * @id:  the return location\n- *\n- * Parse an SGML catalog ID\n- *\n- * Returns new current character and store the value in @id\n- *\/\n-static const xmlChar *\n-xmlParseSGMLCatalogPubid(const xmlChar *cur, xmlChar **id) {\n-    xmlChar *buf = NULL, *tmp;\n-    int len = 0;\n-    int size = 50;\n-    xmlChar stop;\n-\n-    *id = NULL;\n-\n-    if (RAW == '\"') {\n-        NEXT;\n-    stop = '\"';\n-    } else if (RAW == '\\'') {\n-        NEXT;\n-    stop = '\\'';\n-    } else {\n-    stop = ' ';\n-    }\n-    buf = (xmlChar *) xmlMallocAtomic(size);\n-    if (buf == NULL) {\n-        xmlCatalogErrMemory();\n-    return(NULL);\n-    }\n-    while (IS_PUBIDCHAR_CH(*cur) || (*cur == '?')) {\n-    if ((*cur == stop) && (stop != ' '))\n-        break;\n-    if ((stop == ' ') && (IS_BLANK_CH(*cur)))\n-        break;\n-    if (len + 1 >= size) {\n-        size *= 2;\n-        tmp = (xmlChar *) xmlRealloc(buf, size);\n-        if (tmp == NULL) {\n-        xmlCatalogErrMemory();\n-        xmlFree(buf);\n-        return(NULL);\n-        }\n-        buf = tmp;\n-    }\n-    buf[len++] = *cur;\n-    NEXT;\n-    }\n-    buf[len] = 0;\n-    if (stop == ' ') {\n-    if (!IS_BLANK_CH(*cur)) {\n-        xmlFree(buf);\n-        return(NULL);\n-    }\n-    } else {\n-    if (*cur != stop) {\n-        xmlFree(buf);\n-        return(NULL);\n-    }\n-    NEXT;\n-    }\n-    *id = buf;\n-    return(cur);\n-}\n-\n-\/**\n- * xmlParseSGMLCatalogName:\n- * @cur:  the current character\n- * @name:  the return location\n- *\n- * Parse an SGML catalog name\n- *\n- * Returns new current character and store the value in @name\n- *\/\n-static const xmlChar *\n-xmlParseSGMLCatalogName(const xmlChar *cur, xmlChar **name) {\n-    xmlChar buf[XML_MAX_NAMELEN + 5];\n-    int len = 0;\n-    int c;\n-\n-    *name = NULL;\n-\n-    \/*\n-     * Handler for more complex cases\n-     *\/\n-    c = *cur;\n-    if ((!IS_LETTER(c) && (c != '_') && (c != ':'))) {\n-    return(NULL);\n-    }\n-\n-    while (((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n-            (c == '.') || (c == '-') ||\n-        (c == '_') || (c == ':'))) {\n-    buf[len++] = c;\n-    cur++;\n-    c = *cur;\n-    if (len >= XML_MAX_NAMELEN)\n-        return(NULL);\n-    }\n-    *name = xmlStrndup(buf, len);\n-    return(cur);\n-}\n-\n-\/**\n- * xmlGetSGMLCatalogEntryType:\n- * @name:  the entry name\n- *\n- * Get the Catalog entry type for a given SGML Catalog name\n- *\n- * Returns Catalog entry type\n- *\/\n-static xmlCatalogEntryType\n-xmlGetSGMLCatalogEntryType(const xmlChar *name) {\n-    xmlCatalogEntryType type = XML_CATA_NONE;\n-    if (xmlStrEqual(name, (const xmlChar *) \"SYSTEM\"))\n-    type = SGML_CATA_SYSTEM;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"PUBLIC\"))\n-    type = SGML_CATA_PUBLIC;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"DELEGATE\"))\n-    type = SGML_CATA_DELEGATE;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"ENTITY\"))\n-    type = SGML_CATA_ENTITY;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"DOCTYPE\"))\n-    type = SGML_CATA_DOCTYPE;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"LINKTYPE\"))\n-    type = SGML_CATA_LINKTYPE;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"NOTATION\"))\n-    type = SGML_CATA_NOTATION;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"SGMLDECL\"))\n-    type = SGML_CATA_SGMLDECL;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"DOCUMENT\"))\n-    type = SGML_CATA_DOCUMENT;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"CATALOG\"))\n-    type = SGML_CATA_CATALOG;\n-    else if (xmlStrEqual(name, (const xmlChar *) \"BASE\"))\n-    type = SGML_CATA_BASE;\n-    return(type);\n-}\n-\n-\/**\n- * xmlParseSGMLCatalog:\n- * @catal:  the SGML Catalog\n- * @value:  the content of the SGML Catalog serialization\n- * @file:  the filepath for the catalog\n- * @super:  should this be handled as a Super Catalog in which case\n- *          parsing is not recursive\n- *\n- * Parse an SGML catalog content and fill up the @catal hash table with\n- * the new entries found.\n- *\n- * Returns 0 in case of success, -1 in case of error.\n- *\/\n-static int\n-xmlParseSGMLCatalog(xmlCatalogPtr catal, const xmlChar *value,\n-                const char *file, int super) {\n-    const xmlChar *cur = value;\n-    xmlChar *base = NULL;\n-    int res;\n-\n-    if ((cur == NULL) || (file == NULL))\n-        return(-1);\n-    base = xmlStrdup((const xmlChar *) file);\n-\n-    while ((cur != NULL) && (cur[0] != 0)) {\n-    SKIP_BLANKS;\n-    if (cur[0] == 0)\n-        break;\n-    if ((cur[0] == '-') && (cur[1] == '-')) {\n-        cur = xmlParseSGMLCatalogComment(cur);\n-        if (cur == NULL) {\n-        \/* error *\/\n-        break;\n-        }\n-    } else {\n-        xmlChar *sysid = NULL;\n-        xmlChar *name = NULL;\n-        xmlCatalogEntryType type = XML_CATA_NONE;\n-\n-        cur = xmlParseSGMLCatalogName(cur, &name);\n-        if (cur == NULL || name == NULL) {\n-        \/* error *\/\n-        break;\n-        }\n-        if (!IS_BLANK_CH(*cur)) {\n-        \/* error *\/\n-        xmlFree(name);\n-        break;\n-        }\n-        SKIP_BLANKS;\n-        if (xmlStrEqual(name, (const xmlChar *) \"SYSTEM\"))\n-                type = SGML_CATA_SYSTEM;\n-        else if (xmlStrEqual(name, (const xmlChar *) \"PUBLIC\"))\n-                type = SGML_CATA_PUBLIC;\n-        else if (xmlStrEqual(name, (const xmlChar *) \"DELEGATE\"))\n-                type = SGML_CATA_DELEGATE;\n-        else if (xmlStrEqual(name, (const xmlChar *) \"ENTITY\"))\n-                type = SGML_CATA_ENTITY;\n-        else if (xmlStrEqual(name, (const xmlChar *) \"DOCTYPE\"))\n-                type = SGML_CATA_DOCTYPE;\n-        else if (xmlStrEqual(name, (const xmlChar *) \"LINKTYPE\"))\n-                type = SGML_CATA_LINKTYPE;\n-        else if (xmlStrEqual(name, (const xmlChar *) \"NOTATION\"))\n-                type = SGML_CATA_NOTATION;\n-        else if (xmlStrEqual(name, (const xmlChar *) \"SGMLDECL\"))\n-                type = SGML_CATA_SGMLDECL;\n-        else if (xmlStrEqual(name, (const xmlChar *) \"DOCUMENT\"))\n-                type = SGML_CATA_DOCUMENT;\n-        else if (xmlStrEqual(name, (const xmlChar *) \"CATALOG\"))\n-                type = SGML_CATA_CATALOG;\n-        else if (xmlStrEqual(name, (const xmlChar *) \"BASE\"))\n-                type = SGML_CATA_BASE;\n-        else if (xmlStrEqual(name, (const xmlChar *) \"OVERRIDE\")) {\n-        xmlFree(name);\n-        cur = xmlParseSGMLCatalogName(cur, &name);\n-        if (name == NULL) {\n-            \/* error *\/\n-            break;\n-        }\n-        xmlFree(name);\n-        continue;\n-        }\n-        xmlFree(name);\n-        name = NULL;\n-\n-        switch(type) {\n-        case SGML_CATA_ENTITY:\n-            if (*cur == '%')\n-            type = SGML_CATA_PENTITY;\n-                    \/* Falls through. *\/\n-        case SGML_CATA_PENTITY:\n-        case SGML_CATA_DOCTYPE:\n-        case SGML_CATA_LINKTYPE:\n-        case SGML_CATA_NOTATION:\n-            cur = xmlParseSGMLCatalogName(cur, &name);\n-            if (cur == NULL) {\n-            \/* error *\/\n-            break;\n-            }\n-            if (!IS_BLANK_CH(*cur)) {\n-            \/* error *\/\n-            break;\n-            }\n-            SKIP_BLANKS;\n-            cur = xmlParseSGMLCatalogPubid(cur, &sysid);\n-            if (cur == NULL) {\n-            \/* error *\/\n-            break;\n-            }\n-            break;\n-        case SGML_CATA_PUBLIC:\n-        case SGML_CATA_SYSTEM:\n-        case SGML_CATA_DELEGATE:\n-            cur = xmlParseSGMLCatalogPubid(cur, &name);\n-            if (cur == NULL) {\n-            \/* error *\/\n-            break;\n-            }\n-            if (type != SGML_CATA_SYSTEM) {\n-                xmlChar *normid;\n-\n-                normid = xmlCatalogNormalizePublic(name);\n-                if (normid != NULL) {\n-                    if (name != NULL)\n-                        xmlFree(name);\n-                    if (*normid != 0)\n-                        name = normid;\n-                    else {\n-                        xmlFree(normid);\n-                        name = NULL;\n-                    }\n-                }\n-            }\n-            if (!IS_BLANK_CH(*cur)) {\n-            \/* error *\/\n-            break;\n-            }\n-            SKIP_BLANKS;\n-            cur = xmlParseSGMLCatalogPubid(cur, &sysid);\n-            if (cur == NULL) {\n-            \/* error *\/\n-            break;\n-            }\n-            break;\n-        case SGML_CATA_BASE:\n-        case SGML_CATA_CATALOG:\n-        case SGML_CATA_DOCUMENT:\n-        case SGML_CATA_SGMLDECL:\n-            cur = xmlParseSGMLCatalogPubid(cur, &sysid);\n-            if (cur == NULL) {\n-            \/* error *\/\n-            break;\n-            }\n-            break;\n-        default:\n-            break;\n-        }\n-        if (cur == NULL) {\n-        if (name != NULL)\n-            xmlFree(name);\n-        if (sysid != NULL)\n-            xmlFree(sysid);\n-        break;\n-        } else if (type == SGML_CATA_BASE) {\n-        if (base != NULL)\n-            xmlFree(base);\n-        base = xmlStrdup(sysid);\n-        } else if ((type == SGML_CATA_PUBLIC) ||\n-               (type == SGML_CATA_SYSTEM)) {\n-        xmlChar *filename;\n-\n-        filename = xmlBuildURI(sysid, base);\n-        if (filename != NULL) {\n-            xmlCatalogEntryPtr entry;\n-\n-            entry = xmlNewCatalogEntry(type, name, filename,\n-                                   NULL, XML_CATA_PREFER_NONE, NULL);\n-            res = xmlHashAddEntry(catal->sgml, name, entry);\n-            if (res < 0) {\n-            xmlFreeCatalogEntry(entry, NULL);\n-            }\n-            xmlFree(filename);\n-        }\n-\n-        } else if (type == SGML_CATA_CATALOG) {\n-        if (super) {\n-            xmlCatalogEntryPtr entry;\n-\n-            entry = xmlNewCatalogEntry(type, sysid, NULL, NULL,\n-                                   XML_CATA_PREFER_NONE, NULL);\n-            res = xmlHashAddEntry(catal->sgml, sysid, entry);\n-            if (res < 0) {\n-            xmlFreeCatalogEntry(entry, NULL);\n-            }\n-        } else {\n-            xmlChar *filename;\n-\n-            filename = xmlBuildURI(sysid, base);\n-            if (filename != NULL) {\n-            xmlExpandCatalog(catal, (const char *)filename);\n-            xmlFree(filename);\n-            }\n-        }\n-        }\n-        \/*\n-         * drop anything else we won't handle it\n-         *\/\n-        if (name != NULL)\n-        xmlFree(name);\n-        if (sysid != NULL)\n-        xmlFree(sysid);\n-    }\n-    }\n-    if (base != NULL)\n-    xmlFree(base);\n-    if (cur == NULL)\n-    return(-1);\n-    return(0);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            SGML Catalog handling                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlCatalogGetSGMLPublic:\n- * @catal:  an SGML catalog hash\n- * @pubID:  the public ID string\n- *\n- * Try to lookup the catalog local reference associated to a public ID\n- *\n- * Returns the local resource if found or NULL otherwise.\n- *\/\n-static const xmlChar *\n-xmlCatalogGetSGMLPublic(xmlHashTablePtr catal, const xmlChar *pubID) {\n-    xmlCatalogEntryPtr entry;\n-    xmlChar *normid;\n-\n-    if (catal == NULL)\n-    return(NULL);\n-\n-    normid = xmlCatalogNormalizePublic(pubID);\n-    if (normid != NULL)\n-        pubID = (*normid != 0 ? normid : NULL);\n-\n-    entry = (xmlCatalogEntryPtr) xmlHashLookup(catal, pubID);\n-    if (entry == NULL) {\n-    if (normid != NULL)\n-        xmlFree(normid);\n-    return(NULL);\n-    }\n-    if (entry->type == SGML_CATA_PUBLIC) {\n-    if (normid != NULL)\n-        xmlFree(normid);\n-    return(entry->URL);\n-    }\n-    if (normid != NULL)\n-        xmlFree(normid);\n-    return(NULL);\n-}\n-\n-\/**\n- * xmlCatalogGetSGMLSystem:\n- * @catal:  an SGML catalog hash\n- * @sysID:  the system ID string\n- *\n- * Try to lookup the catalog local reference for a system ID\n- *\n- * Returns the local resource if found or NULL otherwise.\n- *\/\n-static const xmlChar *\n-xmlCatalogGetSGMLSystem(xmlHashTablePtr catal, const xmlChar *sysID) {\n-    xmlCatalogEntryPtr entry;\n-\n-    if (catal == NULL)\n-    return(NULL);\n-\n-    entry = (xmlCatalogEntryPtr) xmlHashLookup(catal, sysID);\n-    if (entry == NULL)\n-    return(NULL);\n-    if (entry->type == SGML_CATA_SYSTEM)\n-    return(entry->URL);\n-    return(NULL);\n-}\n-\n-\/**\n- * xmlCatalogSGMLResolve:\n- * @catal:  the SGML catalog\n- * @pubID:  the public ID string\n- * @sysID:  the system ID string\n- *\n- * Do a complete resolution lookup of an External Identifier\n- *\n- * Returns the URI of the resource or NULL if not found\n- *\/\n-static const xmlChar *\n-xmlCatalogSGMLResolve(xmlCatalogPtr catal, const xmlChar *pubID,\n-                  const xmlChar *sysID) {\n-    const xmlChar *ret = NULL;\n-\n-    if (catal->sgml == NULL)\n-    return(NULL);\n-\n-    if (pubID != NULL)\n-    ret = xmlCatalogGetSGMLPublic(catal->sgml, pubID);\n-    if (ret != NULL)\n-    return(ret);\n-    if (sysID != NULL)\n-    ret = xmlCatalogGetSGMLSystem(catal->sgml, sysID);\n-    if (ret != NULL)\n-    return(ret);\n-    return(NULL);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Specific Public interfaces            *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlLoadSGMLSuperCatalog:\n- * @filename:  a file path\n- *\n- * Load an SGML super catalog. It won't expand CATALOG or DELEGATE\n- * references. This is only needed for manipulating SGML Super Catalogs\n- * like adding and removing CATALOG or DELEGATE entries.\n- *\n- * Returns the catalog parsed or NULL in case of error\n- *\/\n-xmlCatalogPtr\n-xmlLoadSGMLSuperCatalog(const char *filename)\n-{\n-    xmlChar *content;\n-    xmlCatalogPtr catal;\n-    int ret;\n-\n-    content = xmlLoadFileContent(filename);\n-    if (content == NULL)\n-        return(NULL);\n-\n-    catal = xmlCreateNewCatalog(XML_SGML_CATALOG_TYPE, xmlCatalogDefaultPrefer);\n-    if (catal == NULL) {\n-    xmlFree(content);\n-    return(NULL);\n-    }\n-\n-    ret = xmlParseSGMLCatalog(catal, content, filename, 1);\n-    xmlFree(content);\n-    if (ret < 0) {\n-    xmlFreeCatalog(catal);\n-    return(NULL);\n-    }\n-    return (catal);\n-}\n-\n-\/**\n- * xmlLoadACatalog:\n- * @filename:  a file path\n- *\n- * Load the catalog and build the associated data structures.\n- * This can be either an XML Catalog or an SGML Catalog\n- * It will recurse in SGML CATALOG entries. On the other hand XML\n- * Catalogs are not handled recursively.\n- *\n- * Returns the catalog parsed or NULL in case of error\n- *\/\n-xmlCatalogPtr\n-xmlLoadACatalog(const char *filename)\n-{\n-    xmlChar *content;\n-    xmlChar *first;\n-    xmlCatalogPtr catal;\n-    int ret;\n-\n-    content = xmlLoadFileContent(filename);\n-    if (content == NULL)\n-        return(NULL);\n-\n-\n-    first = content;\n-\n-    while ((*first != 0) && (*first != '-') && (*first != '<') &&\n-       (!(((*first >= 'A') && (*first <= 'Z')) ||\n-          ((*first >= 'a') && (*first <= 'z')))))\n-    first++;\n-\n-    if (*first != '<') {\n-    catal = xmlCreateNewCatalog(XML_SGML_CATALOG_TYPE, xmlCatalogDefaultPrefer);\n-    if (catal == NULL) {\n-        xmlFree(content);\n-        return(NULL);\n-    }\n-        ret = xmlParseSGMLCatalog(catal, content, filename, 0);\n-    if (ret < 0) {\n-        xmlFreeCatalog(catal);\n-        xmlFree(content);\n-        return(NULL);\n-    }\n-    } else {\n-    catal = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE, xmlCatalogDefaultPrefer);\n-    if (catal == NULL) {\n-        xmlFree(content);\n-        return(NULL);\n-    }\n-        catal->xml = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,\n-               NULL, BAD_CAST filename, xmlCatalogDefaultPrefer, NULL);\n-    }\n-    xmlFree(content);\n-    return (catal);\n-}\n-\n-\/**\n- * xmlExpandCatalog:\n- * @catal:  a catalog\n- * @filename:  a file path\n- *\n- * Load the catalog and expand the existing catal structure.\n- * This can be either an XML Catalog or an SGML Catalog\n- *\n- * Returns 0 in case of success, -1 in case of error\n- *\/\n-static int\n-xmlExpandCatalog(xmlCatalogPtr catal, const char *filename)\n-{\n-    int ret;\n-\n-    if ((catal == NULL) || (filename == NULL))\n-    return(-1);\n-\n-\n-    if (catal->type == XML_SGML_CATALOG_TYPE) {\n-    xmlChar *content;\n-\n-    content = xmlLoadFileContent(filename);\n-    if (content == NULL)\n-        return(-1);\n-\n-        ret = xmlParseSGMLCatalog(catal, content, filename, 0);\n-    if (ret < 0) {\n-        xmlFree(content);\n-        return(-1);\n-    }\n-    xmlFree(content);\n-    } else {\n-    xmlCatalogEntryPtr tmp, cur;\n-    tmp = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,\n-               NULL, BAD_CAST filename, xmlCatalogDefaultPrefer, NULL);\n-\n-    cur = catal->xml;\n-    if (cur == NULL) {\n-        catal->xml = tmp;\n-    } else {\n-        while (cur->next != NULL) cur = cur->next;\n-        cur->next = tmp;\n-    }\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlACatalogResolveSystem:\n- * @catal:  a Catalog\n- * @sysID:  the system ID string\n- *\n- * Try to lookup the catalog resource for a system ID\n- *\n- * Returns the resource if found or NULL otherwise, the value returned\n- *      must be freed by the caller.\n- *\/\n-xmlChar *\n-xmlACatalogResolveSystem(xmlCatalogPtr catal, const xmlChar *sysID) {\n-    xmlChar *ret = NULL;\n-\n-    if ((sysID == NULL) || (catal == NULL))\n-    return(NULL);\n-\n-    if (xmlDebugCatalogs)\n-    fprintf(stderr,\n-        \"Resolve sysID %s\\n\", sysID);\n-\n-    if (catal->type == XML_XML_CATALOG_TYPE) {\n-    ret = xmlCatalogListXMLResolve(catal->xml, NULL, sysID);\n-    if (ret == XML_CATAL_BREAK)\n-        ret = NULL;\n-    } else {\n-    const xmlChar *sgml;\n-\n-    sgml = xmlCatalogGetSGMLSystem(catal->sgml, sysID);\n-    if (sgml != NULL)\n-        ret = xmlStrdup(sgml);\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlACatalogResolvePublic:\n- * @catal:  a Catalog\n- * @pubID:  the public ID string\n- *\n- * Try to lookup the catalog local reference associated to a public ID in that catalog\n- *\n- * Returns the local resource if found or NULL otherwise, the value returned\n- *      must be freed by the caller.\n- *\/\n-xmlChar *\n-xmlACatalogResolvePublic(xmlCatalogPtr catal, const xmlChar *pubID) {\n-    xmlChar *ret = NULL;\n-\n-    if ((pubID == NULL) || (catal == NULL))\n-    return(NULL);\n-\n-    if (xmlDebugCatalogs)\n-    fprintf(stderr,\n-        \"Resolve pubID %s\\n\", pubID);\n-\n-    if (catal->type == XML_XML_CATALOG_TYPE) {\n-    ret = xmlCatalogListXMLResolve(catal->xml, pubID, NULL);\n-    if (ret == XML_CATAL_BREAK)\n-        ret = NULL;\n-    } else {\n-    const xmlChar *sgml;\n-\n-    sgml = xmlCatalogGetSGMLPublic(catal->sgml, pubID);\n-    if (sgml != NULL)\n-        ret = xmlStrdup(sgml);\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlACatalogResolve:\n- * @catal:  a Catalog\n- * @pubID:  the public ID string\n- * @sysID:  the system ID string\n- *\n- * Do a complete resolution lookup of an External Identifier\n- *\n- * Returns the URI of the resource or NULL if not found, it must be freed\n- *      by the caller.\n- *\/\n-xmlChar *\n-xmlACatalogResolve(xmlCatalogPtr catal, const xmlChar * pubID,\n-                   const xmlChar * sysID)\n-{\n-    xmlChar *ret = NULL;\n-\n-    if (((pubID == NULL) && (sysID == NULL)) || (catal == NULL))\n-        return (NULL);\n-\n-    if (xmlDebugCatalogs) {\n-         if ((pubID != NULL) && (sysID != NULL)) {\n-             fprintf(stderr,\n-                             \"Resolve: pubID %s sysID %s\\n\", pubID, sysID);\n-         } else if (pubID != NULL) {\n-             fprintf(stderr,\n-                             \"Resolve: pubID %s\\n\", pubID);\n-         } else {\n-             fprintf(stderr,\n-                             \"Resolve: sysID %s\\n\", sysID);\n-         }\n-    }\n-\n-    if (catal->type == XML_XML_CATALOG_TYPE) {\n-        ret = xmlCatalogListXMLResolve(catal->xml, pubID, sysID);\n-    if (ret == XML_CATAL_BREAK)\n-        ret = NULL;\n-    } else {\n-        const xmlChar *sgml;\n-\n-        sgml = xmlCatalogSGMLResolve(catal, pubID, sysID);\n-        if (sgml != NULL)\n-            ret = xmlStrdup(sgml);\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlACatalogResolveURI:\n- * @catal:  a Catalog\n- * @URI:  the URI\n- *\n- * Do a complete resolution lookup of an URI\n- *\n- * Returns the URI of the resource or NULL if not found, it must be freed\n- *      by the caller.\n- *\/\n-xmlChar *\n-xmlACatalogResolveURI(xmlCatalogPtr catal, const xmlChar *URI) {\n-    xmlChar *ret = NULL;\n-\n-    if ((URI == NULL) || (catal == NULL))\n-    return(NULL);\n-\n-    if (xmlDebugCatalogs)\n-    fprintf(stderr,\n-        \"Resolve URI %s\\n\", URI);\n-\n-    if (catal->type == XML_XML_CATALOG_TYPE) {\n-    ret = xmlCatalogListXMLResolveURI(catal->xml, URI);\n-    if (ret == XML_CATAL_BREAK)\n-        ret = NULL;\n-    } else {\n-    const xmlChar *sgml;\n-\n-    sgml = xmlCatalogSGMLResolve(catal, NULL, URI);\n-    if (sgml != NULL)\n-            ret = xmlStrdup(sgml);\n-    }\n-    return(ret);\n-}\n-\n-#ifdef LIBXML_OUTPUT_ENABLED\n-\/**\n- * xmlACatalogDump:\n- * @catal:  a Catalog\n- * @out:  the file.\n- *\n- * Dump the given catalog to the given file.\n- *\/\n-void\n-xmlACatalogDump(xmlCatalogPtr catal, FILE *out) {\n-    if ((out == NULL) || (catal == NULL))\n-    return;\n-\n-    if (catal->type == XML_XML_CATALOG_TYPE) {\n-    xmlDumpXMLCatalog(out, catal->xml);\n-    } else {\n-    xmlHashScan(catal->sgml, xmlCatalogDumpEntry, out);\n-    }\n-}\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-\n-\/**\n- * xmlACatalogAdd:\n- * @catal:  a Catalog\n- * @type:  the type of record to add to the catalog\n- * @orig:  the system, public or prefix to match\n- * @replace:  the replacement value for the match\n- *\n- * Add an entry in the catalog, it may overwrite existing but\n- * different entries.\n- *\n- * Returns 0 if successful, -1 otherwise\n- *\/\n-int\n-xmlACatalogAdd(xmlCatalogPtr catal, const xmlChar * type,\n-              const xmlChar * orig, const xmlChar * replace)\n-{\n-    int res = -1;\n-\n-    if (catal == NULL)\n-    return(-1);\n-\n-    if (catal->type == XML_XML_CATALOG_TYPE) {\n-        res = xmlAddXMLCatalog(catal->xml, type, orig, replace);\n-    } else {\n-        xmlCatalogEntryType cattype;\n-\n-        cattype = xmlGetSGMLCatalogEntryType(type);\n-        if (cattype != XML_CATA_NONE) {\n-            xmlCatalogEntryPtr entry;\n-\n-            entry = xmlNewCatalogEntry(cattype, orig, replace, NULL,\n-                                       XML_CATA_PREFER_NONE, NULL);\n-        if (catal->sgml == NULL)\n-        catal->sgml = xmlHashCreate(10);\n-            res = xmlHashAddEntry(catal->sgml, orig, entry);\n-            if (res < 0)\n-                xmlFreeCatalogEntry(entry, NULL);\n-        }\n-    }\n-    return (res);\n-}\n-\n-\/**\n- * xmlACatalogRemove:\n- * @catal:  a Catalog\n- * @value:  the value to remove\n- *\n- * Remove an entry from the catalog\n- *\n- * Returns the number of entries removed if successful, -1 otherwise\n- *\/\n-int\n-xmlACatalogRemove(xmlCatalogPtr catal, const xmlChar *value) {\n-    int res = -1;\n-\n-    if ((catal == NULL) || (value == NULL))\n-    return(-1);\n-\n-    if (catal->type == XML_XML_CATALOG_TYPE) {\n-    res = xmlDelXMLCatalog(catal->xml, value);\n-    } else {\n-    res = xmlHashRemoveEntry(catal->sgml, value, xmlFreeCatalogEntry);\n-    if (res == 0)\n-        res = 1;\n-    }\n-    return(res);\n-}\n-\n-\/**\n- * xmlNewCatalog:\n- * @sgml:  should this create an SGML catalog\n- *\n- * create a new Catalog.\n- *\n- * Returns the xmlCatalogPtr or NULL in case of error\n- *\/\n-xmlCatalogPtr\n-xmlNewCatalog(int sgml) {\n-    xmlCatalogPtr catal = NULL;\n-\n-    if (sgml) {\n-    catal = xmlCreateNewCatalog(XML_SGML_CATALOG_TYPE,\n-                            xmlCatalogDefaultPrefer);\n-        if ((catal != NULL) && (catal->sgml == NULL))\n-        catal->sgml = xmlHashCreate(10);\n-    } else\n-    catal = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,\n-                            xmlCatalogDefaultPrefer);\n-    return(catal);\n-}\n-\n-\/**\n- * xmlCatalogIsEmpty:\n- * @catal:  should this create an SGML catalog\n- *\n- * Check is a catalog is empty\n- *\n- * Returns 1 if the catalog is empty, 0 if not, amd -1 in case of error.\n- *\/\n-int\n-xmlCatalogIsEmpty(xmlCatalogPtr catal) {\n-    if (catal == NULL)\n-    return(-1);\n-\n-    if (catal->type == XML_XML_CATALOG_TYPE) {\n-    if (catal->xml == NULL)\n-        return(1);\n-    if ((catal->xml->type != XML_CATA_CATALOG) &&\n-        (catal->xml->type != XML_CATA_BROKEN_CATALOG))\n-        return(-1);\n-    if (catal->xml->children == NULL)\n-        return(1);\n-        return(0);\n-    } else {\n-    int res;\n-\n-    if (catal->sgml == NULL)\n-        return(1);\n-    res = xmlHashSize(catal->sgml);\n-    if (res == 0)\n-        return(1);\n-    if (res < 0)\n-        return(-1);\n-    }\n-    return(0);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *   Public interfaces manipulating the global shared default catalog    *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlInitializeCatalogData:\n- *\n- * Do the catalog initialization only of global data, doesn't try to load\n- * any catalog actually.\n- * this function is not thread safe, catalog initialization should\n- * preferably be done once at startup\n- *\/\n-static void\n-xmlInitializeCatalogData(void) {\n-    if (xmlCatalogInitialized != 0)\n-    return;\n-\n-    if (getenv(\"XML_DEBUG_CATALOG\"))\n-    xmlDebugCatalogs = 1;\n-    xmlCatalogMutex = xmlNewRMutex();\n-\n-    xmlCatalogInitialized = 1;\n-}\n-\/**\n- * xmlInitializeCatalog:\n- *\n- * Do the catalog initialization.\n- * this function is not thread safe, catalog initialization should\n- * preferably be done once at startup\n- *\/\n-void\n-xmlInitializeCatalog(void) {\n-    if (xmlCatalogInitialized != 0)\n-    return;\n-\n-    xmlInitializeCatalogData();\n-    xmlRMutexLock(xmlCatalogMutex);\n-\n-    if (getenv(\"XML_DEBUG_CATALOG\"))\n-    xmlDebugCatalogs = 1;\n-\n-    if (xmlDefaultCatalog == NULL) {\n-    const char *catalogs;\n-    char *path;\n-    const char *cur, *paths;\n-    xmlCatalogPtr catal;\n-    xmlCatalogEntryPtr *nextent;\n-\n-    catalogs = (const char *) getenv(\"XML_CATALOG_FILES\");\n-    if (catalogs == NULL)\n-        catalogs = XML_XML_DEFAULT_CATALOG;\n-\n-    catal = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,\n-        xmlCatalogDefaultPrefer);\n-    if (catal != NULL) {\n-        \/* the XML_CATALOG_FILES envvar is allowed to contain a\n-           space-separated list of entries. *\/\n-        cur = catalogs;\n-        nextent = &catal->xml;\n-        while (*cur != '\\0') {\n-        while (xmlIsBlank_ch(*cur))\n-            cur++;\n-        if (*cur != 0) {\n-            paths = cur;\n-            while ((*cur != 0) && (!xmlIsBlank_ch(*cur)))\n-            cur++;\n-            path = (char *) xmlStrndup((const xmlChar *)paths, cur - paths);\n-            if (path != NULL) {\n-            *nextent = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,\n-                NULL, BAD_CAST path, xmlCatalogDefaultPrefer, NULL);\n-            if (*nextent != NULL)\n-                nextent = &((*nextent)->next);\n-            xmlFree(path);\n-            }\n-        }\n-        }\n-        xmlDefaultCatalog = catal;\n-    }\n-    }\n-\n-    xmlRMutexUnlock(xmlCatalogMutex);\n-}\n-\n-\n-\/**\n- * xmlLoadCatalog:\n- * @filename:  a file path\n- *\n- * Load the catalog and makes its definitions effective for the default\n- * external entity loader. It will recurse in SGML CATALOG entries.\n- * this function is not thread safe, catalog initialization should\n- * preferably be done once at startup\n- *\n- * Returns 0 in case of success -1 in case of error\n- *\/\n-int\n-xmlLoadCatalog(const char *filename)\n-{\n-    int ret;\n-    xmlCatalogPtr catal;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalogData();\n-\n-    xmlRMutexLock(xmlCatalogMutex);\n-\n-    if (xmlDefaultCatalog == NULL) {\n-    catal = xmlLoadACatalog(filename);\n-    if (catal == NULL) {\n-        xmlRMutexUnlock(xmlCatalogMutex);\n-        return(-1);\n-    }\n-\n-    xmlDefaultCatalog = catal;\n-    xmlRMutexUnlock(xmlCatalogMutex);\n-    return(0);\n-    }\n-\n-    ret = xmlExpandCatalog(xmlDefaultCatalog, filename);\n-    xmlRMutexUnlock(xmlCatalogMutex);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlLoadCatalogs:\n- * @pathss:  a list of directories separated by a colon or a space.\n- *\n- * Load the catalogs and makes their definitions effective for the default\n- * external entity loader.\n- * this function is not thread safe, catalog initialization should\n- * preferably be done once at startup\n- *\/\n-void\n-xmlLoadCatalogs(const char *pathss) {\n-    const char *cur;\n-    const char *paths;\n-    xmlChar *path;\n-#ifdef _WIN32\n-    int i, iLen;\n-#endif\n-\n-    if (pathss == NULL)\n-    return;\n-\n-    cur = pathss;\n-    while (*cur != 0) {\n-    while (xmlIsBlank_ch(*cur)) cur++;\n-    if (*cur != 0) {\n-        paths = cur;\n-        while ((*cur != 0) && (*cur != PATH_SEPARATOR) && (!xmlIsBlank_ch(*cur)))\n-        cur++;\n-        path = xmlStrndup((const xmlChar *)paths, cur - paths);\n-        if (path != NULL) {\n-#ifdef _WIN32\n-        iLen = strlen((const char*)path);\n-        for(i = 0; i < iLen; i++) {\n-            if(path[i] == '\\\\') {\n-                path[i] = '\/';\n-            }\n-        }\n-#endif\n-        xmlLoadCatalog((const char *) path);\n-        xmlFree(path);\n-        }\n-    }\n-    while (*cur == PATH_SEPARATOR)\n-        cur++;\n-    }\n-}\n-\n-\/**\n- * xmlCatalogCleanup:\n- *\n- * Free up all the memory associated with catalogs\n- *\/\n-void\n-xmlCatalogCleanup(void) {\n-    if (xmlCatalogInitialized == 0)\n-        return;\n-\n-    xmlRMutexLock(xmlCatalogMutex);\n-    if (xmlDebugCatalogs)\n-    fprintf(stderr,\n-        \"Catalogs cleanup\\n\");\n-    if (xmlCatalogXMLFiles != NULL)\n-    xmlHashFree(xmlCatalogXMLFiles, xmlFreeCatalogHashEntryList);\n-    xmlCatalogXMLFiles = NULL;\n-    if (xmlDefaultCatalog != NULL)\n-    xmlFreeCatalog(xmlDefaultCatalog);\n-    xmlDefaultCatalog = NULL;\n-    xmlDebugCatalogs = 0;\n-    xmlCatalogInitialized = 0;\n-    xmlRMutexUnlock(xmlCatalogMutex);\n-    xmlFreeRMutex(xmlCatalogMutex);\n-}\n-\n-\/**\n- * xmlCatalogResolveSystem:\n- * @sysID:  the system ID string\n- *\n- * Try to lookup the catalog resource for a system ID\n- *\n- * Returns the resource if found or NULL otherwise, the value returned\n- *      must be freed by the caller.\n- *\/\n-xmlChar *\n-xmlCatalogResolveSystem(const xmlChar *sysID) {\n-    xmlChar *ret;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalog();\n-\n-    ret = xmlACatalogResolveSystem(xmlDefaultCatalog, sysID);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlCatalogResolvePublic:\n- * @pubID:  the public ID string\n- *\n- * Try to lookup the catalog reference associated to a public ID\n- *\n- * Returns the resource if found or NULL otherwise, the value returned\n- *      must be freed by the caller.\n- *\/\n-xmlChar *\n-xmlCatalogResolvePublic(const xmlChar *pubID) {\n-    xmlChar *ret;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalog();\n-\n-    ret = xmlACatalogResolvePublic(xmlDefaultCatalog, pubID);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlCatalogResolve:\n- * @pubID:  the public ID string\n- * @sysID:  the system ID string\n- *\n- * Do a complete resolution lookup of an External Identifier\n- *\n- * Returns the URI of the resource or NULL if not found, it must be freed\n- *      by the caller.\n- *\/\n-xmlChar *\n-xmlCatalogResolve(const xmlChar *pubID, const xmlChar *sysID) {\n-    xmlChar *ret;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalog();\n-\n-    ret = xmlACatalogResolve(xmlDefaultCatalog, pubID, sysID);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlCatalogResolveURI:\n- * @URI:  the URI\n- *\n- * Do a complete resolution lookup of an URI\n- *\n- * Returns the URI of the resource or NULL if not found, it must be freed\n- *      by the caller.\n- *\/\n-xmlChar *\n-xmlCatalogResolveURI(const xmlChar *URI) {\n-    xmlChar *ret;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalog();\n-\n-    ret = xmlACatalogResolveURI(xmlDefaultCatalog, URI);\n-    return(ret);\n-}\n-\n-#ifdef LIBXML_OUTPUT_ENABLED\n-\/**\n- * xmlCatalogDump:\n- * @out:  the file.\n- *\n- * Dump all the global catalog content to the given file.\n- *\/\n-void\n-xmlCatalogDump(FILE *out) {\n-    if (out == NULL)\n-    return;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalog();\n-\n-    xmlACatalogDump(xmlDefaultCatalog, out);\n-}\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-\n-\/**\n- * xmlCatalogAdd:\n- * @type:  the type of record to add to the catalog\n- * @orig:  the system, public or prefix to match\n- * @replace:  the replacement value for the match\n- *\n- * Add an entry in the catalog, it may overwrite existing but\n- * different entries.\n- * If called before any other catalog routine, allows to override the\n- * default shared catalog put in place by xmlInitializeCatalog();\n- *\n- * Returns 0 if successful, -1 otherwise\n- *\/\n-int\n-xmlCatalogAdd(const xmlChar *type, const xmlChar *orig, const xmlChar *replace) {\n-    int res = -1;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalogData();\n-\n-    xmlRMutexLock(xmlCatalogMutex);\n-    \/*\n-     * Specific case where one want to override the default catalog\n-     * put in place by xmlInitializeCatalog();\n-     *\/\n-    if ((xmlDefaultCatalog == NULL) &&\n-    (xmlStrEqual(type, BAD_CAST \"catalog\"))) {\n-    xmlDefaultCatalog = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,\n-                                  xmlCatalogDefaultPrefer);\n-    if (xmlDefaultCatalog != NULL) {\n-       xmlDefaultCatalog->xml = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,\n-                    orig, NULL,  xmlCatalogDefaultPrefer, NULL);\n-    }\n-    xmlRMutexUnlock(xmlCatalogMutex);\n-    return(0);\n-    }\n-\n-    res = xmlACatalogAdd(xmlDefaultCatalog, type, orig, replace);\n-    xmlRMutexUnlock(xmlCatalogMutex);\n-    return(res);\n-}\n-\n-\/**\n- * xmlCatalogRemove:\n- * @value:  the value to remove\n- *\n- * Remove an entry from the catalog\n- *\n- * Returns the number of entries removed if successful, -1 otherwise\n- *\/\n-int\n-xmlCatalogRemove(const xmlChar *value) {\n-    int res;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalog();\n-\n-    xmlRMutexLock(xmlCatalogMutex);\n-    res = xmlACatalogRemove(xmlDefaultCatalog, value);\n-    xmlRMutexUnlock(xmlCatalogMutex);\n-    return(res);\n-}\n-\n-\/**\n- * xmlCatalogConvert:\n- *\n- * Convert all the SGML catalog entries as XML ones\n- *\n- * Returns the number of entries converted if successful, -1 otherwise\n- *\/\n-int\n-xmlCatalogConvert(void) {\n-    int res = -1;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalog();\n-\n-    xmlRMutexLock(xmlCatalogMutex);\n-    res = xmlConvertSGMLCatalog(xmlDefaultCatalog);\n-    xmlRMutexUnlock(xmlCatalogMutex);\n-    return(res);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *    Public interface manipulating the common preferences        *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlCatalogGetDefaults:\n- *\n- * Used to get the user preference w.r.t. to what catalogs should\n- * be accepted\n- *\n- * Returns the current xmlCatalogAllow value\n- *\/\n-xmlCatalogAllow\n-xmlCatalogGetDefaults(void) {\n-    return(xmlCatalogDefaultAllow);\n-}\n-\n-\/**\n- * xmlCatalogSetDefaults:\n- * @allow:  what catalogs should be accepted\n- *\n- * Used to set the user preference w.r.t. to what catalogs should\n- * be accepted\n- *\/\n-void\n-xmlCatalogSetDefaults(xmlCatalogAllow allow) {\n-    if (xmlDebugCatalogs) {\n-    switch (allow) {\n-        case XML_CATA_ALLOW_NONE:\n-        fprintf(stderr,\n-            \"Disabling catalog usage\\n\");\n-        break;\n-        case XML_CATA_ALLOW_GLOBAL:\n-        fprintf(stderr,\n-            \"Allowing only global catalogs\\n\");\n-        break;\n-        case XML_CATA_ALLOW_DOCUMENT:\n-        fprintf(stderr,\n-            \"Allowing only catalogs from the document\\n\");\n-        break;\n-        case XML_CATA_ALLOW_ALL:\n-        fprintf(stderr,\n-            \"Allowing all catalogs\\n\");\n-        break;\n-    }\n-    }\n-    xmlCatalogDefaultAllow = allow;\n-}\n-\n-\/**\n- * xmlCatalogSetDefaultPrefer:\n- * @prefer:  the default preference for delegation\n- *\n- * Allows to set the preference between public and system for deletion\n- * in XML Catalog resolution. C.f. section 4.1.1 of the spec\n- * Values accepted are XML_CATA_PREFER_PUBLIC or XML_CATA_PREFER_SYSTEM\n- *\n- * Returns the previous value of the default preference for delegation\n- *\/\n-xmlCatalogPrefer\n-xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer) {\n-    xmlCatalogPrefer ret = xmlCatalogDefaultPrefer;\n-\n-    if (prefer == XML_CATA_PREFER_NONE)\n-    return(ret);\n-\n-    if (xmlDebugCatalogs) {\n-    switch (prefer) {\n-        case XML_CATA_PREFER_PUBLIC:\n-        fprintf(stderr,\n-            \"Setting catalog preference to PUBLIC\\n\");\n-        break;\n-        case XML_CATA_PREFER_SYSTEM:\n-        fprintf(stderr,\n-            \"Setting catalog preference to SYSTEM\\n\");\n-        break;\n-        default:\n-        return(ret);\n-    }\n-    }\n-    xmlCatalogDefaultPrefer = prefer;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlCatalogSetDebug:\n- * @level:  the debug level of catalogs required\n- *\n- * Used to set the debug level for catalog operation, 0 disable\n- * debugging, 1 enable it\n- *\n- * Returns the previous value of the catalog debugging level\n- *\/\n-int\n-xmlCatalogSetDebug(int level) {\n-    int ret = xmlDebugCatalogs;\n-\n-    if (level <= 0)\n-        xmlDebugCatalogs = 0;\n-    else\n-    xmlDebugCatalogs = level;\n-    return(ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *   Minimal interfaces used for per-document catalogs by the parser    *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlCatalogFreeLocal:\n- * @catalogs:  a document's list of catalogs\n- *\n- * Free up the memory associated to the catalog list\n- *\/\n-void\n-xmlCatalogFreeLocal(void *catalogs) {\n-    xmlCatalogEntryPtr catal;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalog();\n-\n-    catal = (xmlCatalogEntryPtr) catalogs;\n-    if (catal != NULL)\n-    xmlFreeCatalogEntryList(catal);\n-}\n-\n-\n-\/**\n- * xmlCatalogAddLocal:\n- * @catalogs:  a document's list of catalogs\n- * @URL:  the URL to a new local catalog\n- *\n- * Add the new entry to the catalog list\n- *\n- * Returns the updated list\n- *\/\n-void *\n-xmlCatalogAddLocal(void *catalogs, const xmlChar *URL) {\n-    xmlCatalogEntryPtr catal, add;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalog();\n-\n-    if (URL == NULL)\n-    return(catalogs);\n-\n-    if (xmlDebugCatalogs)\n-    fprintf(stderr,\n-        \"Adding document catalog %s\\n\", URL);\n-\n-    add = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL, URL, NULL,\n-                         xmlCatalogDefaultPrefer, NULL);\n-    if (add == NULL)\n-    return(catalogs);\n-\n-    catal = (xmlCatalogEntryPtr) catalogs;\n-    if (catal == NULL)\n-    return((void *) add);\n-\n-    while (catal->next != NULL)\n-    catal = catal->next;\n-    catal->next = add;\n-    return(catalogs);\n-}\n-\n-\/**\n- * xmlCatalogLocalResolve:\n- * @catalogs:  a document's list of catalogs\n- * @pubID:  the public ID string\n- * @sysID:  the system ID string\n- *\n- * Do a complete resolution lookup of an External Identifier using a\n- * document's private catalog list\n- *\n- * Returns the URI of the resource or NULL if not found, it must be freed\n- *      by the caller.\n- *\/\n-xmlChar *\n-xmlCatalogLocalResolve(void *catalogs, const xmlChar *pubID,\n-                   const xmlChar *sysID) {\n-    xmlCatalogEntryPtr catal;\n-    xmlChar *ret;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalog();\n-\n-    if ((pubID == NULL) && (sysID == NULL))\n-    return(NULL);\n-\n-    if (xmlDebugCatalogs) {\n-        if ((pubID != NULL) && (sysID != NULL)) {\n-            fprintf(stderr,\n-                            \"Local Resolve: pubID %s sysID %s\\n\", pubID, sysID);\n-        } else if (pubID != NULL) {\n-            fprintf(stderr,\n-                            \"Local Resolve: pubID %s\\n\", pubID);\n-        } else {\n-            fprintf(stderr,\n-                            \"Local Resolve: sysID %s\\n\", sysID);\n-        }\n-    }\n-\n-    catal = (xmlCatalogEntryPtr) catalogs;\n-    if (catal == NULL)\n-    return(NULL);\n-    ret = xmlCatalogListXMLResolve(catal, pubID, sysID);\n-    if ((ret != NULL) && (ret != XML_CATAL_BREAK))\n-    return(ret);\n-    return(NULL);\n-}\n-\n-\/**\n- * xmlCatalogLocalResolveURI:\n- * @catalogs:  a document's list of catalogs\n- * @URI:  the URI\n- *\n- * Do a complete resolution lookup of an URI using a\n- * document's private catalog list\n- *\n- * Returns the URI of the resource or NULL if not found, it must be freed\n- *      by the caller.\n- *\/\n-xmlChar *\n-xmlCatalogLocalResolveURI(void *catalogs, const xmlChar *URI) {\n-    xmlCatalogEntryPtr catal;\n-    xmlChar *ret;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalog();\n-\n-    if (URI == NULL)\n-    return(NULL);\n-\n-    if (xmlDebugCatalogs)\n-    fprintf(stderr,\n-        \"Resolve URI %s\\n\", URI);\n-\n-    catal = (xmlCatalogEntryPtr) catalogs;\n-    if (catal == NULL)\n-    return(NULL);\n-    ret = xmlCatalogListXMLResolveURI(catal, URI);\n-    if ((ret != NULL) && (ret != XML_CATAL_BREAK))\n-    return(ret);\n-    return(NULL);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Deprecated interfaces                *\n- *                                    *\n- ************************************************************************\/\n-\/**\n- * xmlCatalogGetSystem:\n- * @sysID:  the system ID string\n- *\n- * Try to lookup the catalog reference associated to a system ID\n- * DEPRECATED, use xmlCatalogResolveSystem()\n- *\n- * Returns the resource if found or NULL otherwise.\n- *\/\n-const xmlChar *\n-xmlCatalogGetSystem(const xmlChar *sysID) {\n-    xmlChar *ret;\n-    static xmlChar result[1000];\n-    static int msg = 0;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalog();\n-\n-    if (msg == 0) {\n-    fprintf(stderr,\n-        \"Use of deprecated xmlCatalogGetSystem() call\\n\");\n-    msg++;\n-    }\n-\n-    if (sysID == NULL)\n-    return(NULL);\n-\n-    \/*\n-     * Check first the XML catalogs\n-     *\/\n-    if (xmlDefaultCatalog != NULL) {\n-    ret = xmlCatalogListXMLResolve(xmlDefaultCatalog->xml, NULL, sysID);\n-    if ((ret != NULL) && (ret != XML_CATAL_BREAK)) {\n-        snprintf((char *) result, sizeof(result) - 1, \"%s\", (char *) ret);\n-        result[sizeof(result) - 1] = 0;\n-        return(result);\n-    }\n-    }\n-\n-    if (xmlDefaultCatalog != NULL)\n-    return(xmlCatalogGetSGMLSystem(xmlDefaultCatalog->sgml, sysID));\n-    return(NULL);\n-}\n-\n-\/**\n- * xmlCatalogGetPublic:\n- * @pubID:  the public ID string\n- *\n- * Try to lookup the catalog reference associated to a public ID\n- * DEPRECATED, use xmlCatalogResolvePublic()\n- *\n- * Returns the resource if found or NULL otherwise.\n- *\/\n-const xmlChar *\n-xmlCatalogGetPublic(const xmlChar *pubID) {\n-    xmlChar *ret;\n-    static xmlChar result[1000];\n-    static int msg = 0;\n-\n-    if (!xmlCatalogInitialized)\n-    xmlInitializeCatalog();\n-\n-    if (msg == 0) {\n-    fprintf(stderr,\n-        \"Use of deprecated xmlCatalogGetPublic() call\\n\");\n-    msg++;\n-    }\n-\n-    if (pubID == NULL)\n-    return(NULL);\n-\n-    \/*\n-     * Check first the XML catalogs\n-     *\/\n-    if (xmlDefaultCatalog != NULL) {\n-    ret = xmlCatalogListXMLResolve(xmlDefaultCatalog->xml, pubID, NULL);\n-    if ((ret != NULL) && (ret != XML_CATAL_BREAK)) {\n-        snprintf((char *) result, sizeof(result) - 1, \"%s\", (char *) ret);\n-        result[sizeof(result) - 1] = 0;\n-        return(result);\n-    }\n-    }\n-\n-    if (xmlDefaultCatalog != NULL)\n-    return(xmlCatalogGetSGMLPublic(xmlDefaultCatalog->sgml, pubID));\n-    return(NULL);\n-}\n-\n-#endif \/* LIBXML_CATALOG_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/catalog.c","additions":0,"deletions":3761,"binary":false,"changes":3761,"status":"deleted"},{"patch":"@@ -1,361 +0,0 @@\n-name xmlIsChar\n-ur 0x9 \n-ur 0xA \n-ur 0xD \n-ur 0x20..0xFF \n-ur 0x0100..0xD7FF \n-ur 0xE000..0xFFFD \n-ur 0x10000..0x10FFFF\n-end xmlIsChar\n-\n-name xmlIsPubidChar\n-ur 0x20 0x0d 0x0a 'a'..'z' 'A'..'Z' '0'..'9'\n-ur '-' 0x27 '(' ')' '+' ',' '.' '\/'\n-ur ':' '=' '?' ';' '!' '*' '#' '@'\n-ur '$' '_' '%'\n-end\n-\n-name xmlIsBlank\n-ur 0x09 0x0a 0x0d 0x20\n-end xmlIsBlank\n-\n-name xmlIsBaseChar\n-ur 0x0041..0x005A \n-ur 0x0061..0x007A \n-ur 0x00C0..0x00D6 \n-ur 0x00D8..0x00F6 \n-ur 0x00F8..0x00FF \n-ur 0x0100..0x0131 \n-ur 0x0134..0x013E \n-ur 0x0141..0x0148 \n-ur 0x014A..0x017E \n-ur 0x0180..0x01C3 \n-ur 0x01CD..0x01F0 \n-ur 0x01F4..0x01F5 \n-ur 0x01FA..0x0217 \n-ur 0x0250..0x02A8 \n-ur 0x02BB..0x02C1 \n-ur 0x0386 \n-ur 0x0388..0x038A \n-ur 0x038C \n-ur 0x038E..0x03A1 \n-ur 0x03A3..0x03CE \n-ur 0x03D0..0x03D6 \n-ur 0x03DA \n-ur 0x03DC \n-ur 0x03DE \n-ur 0x03E0 \n-ur 0x03E2..0x03F3 \n-ur 0x0401..0x040C \n-ur 0x040E..0x044F \n-ur 0x0451..0x045C \n-ur 0x045E..0x0481 \n-ur 0x0490..0x04C4 \n-ur 0x04C7..0x04C8 \n-ur 0x04CB..0x04CC \n-ur 0x04D0..0x04EB \n-ur 0x04EE..0x04F5 \n-ur 0x04F8..0x04F9 \n-ur 0x0531..0x0556 \n-ur 0x0559 \n-ur 0x0561..0x0586 \n-ur 0x05D0..0x05EA \n-ur 0x05F0..0x05F2 \n-ur 0x0621..0x063A \n-ur 0x0641..0x064A \n-ur 0x0671..0x06B7 \n-ur 0x06BA..0x06BE \n-ur 0x06C0..0x06CE \n-ur 0x06D0..0x06D3 \n-ur 0x06D5 \n-ur 0x06E5..0x06E6 \n-ur 0x0905..0x0939 \n-ur 0x093D \n-ur 0x0958..0x0961 \n-ur 0x0985..0x098C \n-ur 0x098F..0x0990 \n-ur 0x0993..0x09A8 \n-ur 0x09AA..0x09B0 \n-ur 0x09B2 \n-ur 0x09B6..0x09B9 \n-ur 0x09DC..0x09DD \n-ur 0x09DF..0x09E1 \n-ur 0x09F0..0x09F1 \n-ur 0x0A05..0x0A0A \n-ur 0x0A0F..0x0A10 \n-ur 0x0A13..0x0A28 \n-ur 0x0A2A..0x0A30 \n-ur 0x0A32..0x0A33 \n-ur 0x0A35..0x0A36 \n-ur 0x0A38..0x0A39 \n-ur 0x0A59..0x0A5C \n-ur 0x0A5E \n-ur 0x0A72..0x0A74 \n-ur 0x0A85..0x0A8B \n-ur 0x0A8D \n-ur 0x0A8F..0x0A91 \n-ur 0x0A93..0x0AA8 \n-ur 0x0AAA..0x0AB0 \n-ur 0x0AB2..0x0AB3 \n-ur 0x0AB5..0x0AB9 \n-ur 0x0ABD \n-ur 0x0AE0 \n-ur 0x0B05..0x0B0C \n-ur 0x0B0F..0x0B10 \n-ur 0x0B13..0x0B28 \n-ur 0x0B2A..0x0B30 \n-ur 0x0B32..0x0B33 \n-ur 0x0B36..0x0B39 \n-ur 0x0B3D \n-ur 0x0B5C..0x0B5D \n-ur 0x0B5F..0x0B61 \n-ur 0x0B85..0x0B8A \n-ur 0x0B8E..0x0B90 \n-ur 0x0B92..0x0B95 \n-ur 0x0B99..0x0B9A \n-ur 0x0B9C \n-ur 0x0B9E..0x0B9F \n-ur 0x0BA3..0x0BA4 \n-ur 0x0BA8..0x0BAA \n-ur 0x0BAE..0x0BB5 \n-ur 0x0BB7..0x0BB9 \n-ur 0x0C05..0x0C0C \n-ur 0x0C0E..0x0C10 \n-ur 0x0C12..0x0C28 \n-ur 0x0C2A..0x0C33 \n-ur 0x0C35..0x0C39 \n-ur 0x0C60..0x0C61 \n-ur 0x0C85..0x0C8C \n-ur 0x0C8E..0x0C90 \n-ur 0x0C92..0x0CA8 \n-ur 0x0CAA..0x0CB3 \n-ur 0x0CB5..0x0CB9 \n-ur 0x0CDE \n-ur 0x0CE0..0x0CE1 \n-ur 0x0D05..0x0D0C \n-ur 0x0D0E..0x0D10 \n-ur 0x0D12..0x0D28 \n-ur 0x0D2A..0x0D39 \n-ur 0x0D60..0x0D61 \n-ur 0x0E01..0x0E2E \n-ur 0x0E30 \n-ur 0x0E32..0x0E33 \n-ur 0x0E40..0x0E45 \n-ur 0x0E81..0x0E82 \n-ur 0x0E84 \n-ur 0x0E87..0x0E88 \n-ur 0x0E8A \n-ur 0x0E8D \n-ur 0x0E94..0x0E97 \n-ur 0x0E99..0x0E9F \n-ur 0x0EA1..0x0EA3 \n-ur 0x0EA5 \n-ur 0x0EA7 \n-ur 0x0EAA..0x0EAB \n-ur 0x0EAD..0x0EAE \n-ur 0x0EB0 \n-ur 0x0EB2..0x0EB3 \n-ur 0x0EBD \n-ur 0x0EC0..0x0EC4 \n-ur 0x0F40..0x0F47 \n-ur 0x0F49..0x0F69 \n-ur 0x10A0..0x10C5 \n-ur 0x10D0..0x10F6 \n-ur 0x1100 \n-ur 0x1102..0x1103 \n-ur 0x1105..0x1107 \n-ur 0x1109 \n-ur 0x110B..0x110C \n-ur 0x110E..0x1112 \n-ur 0x113C \n-ur 0x113E \n-ur 0x1140 \n-ur 0x114C \n-ur 0x114E \n-ur 0x1150 \n-ur 0x1154..0x1155 \n-ur 0x1159 \n-ur 0x115F..0x1161 \n-ur 0x1163 \n-ur 0x1165 \n-ur 0x1167 \n-ur 0x1169 \n-ur 0x116D..0x116E \n-ur 0x1172..0x1173 \n-ur 0x1175 \n-ur 0x119E \n-ur 0x11A8 \n-ur 0x11AB \n-ur 0x11AE..0x11AF \n-ur 0x11B7..0x11B8 \n-ur 0x11BA \n-ur 0x11BC..0x11C2 \n-ur 0x11EB \n-ur 0x11F0 \n-ur 0x11F9 \n-ur 0x1E00..0x1E9B \n-ur 0x1EA0..0x1EF9 \n-ur 0x1F00..0x1F15 \n-ur 0x1F18..0x1F1D \n-ur 0x1F20..0x1F45 \n-ur 0x1F48..0x1F4D \n-ur 0x1F50..0x1F57 \n-ur 0x1F59 \n-ur 0x1F5B \n-ur 0x1F5D \n-ur 0x1F5F..0x1F7D \n-ur 0x1F80..0x1FB4 \n-ur 0x1FB6..0x1FBC \n-ur 0x1FBE \n-ur 0x1FC2..0x1FC4 \n-ur 0x1FC6..0x1FCC \n-ur 0x1FD0..0x1FD3 \n-ur 0x1FD6..0x1FDB \n-ur 0x1FE0..0x1FEC \n-ur 0x1FF2..0x1FF4 \n-ur 0x1FF6..0x1FFC \n-ur 0x2126 \n-ur 0x212A..0x212B \n-ur 0x212E \n-ur 0x2180..0x2182 \n-ur 0x3041..0x3094 \n-ur 0x30A1..0x30FA \n-ur 0x3105..0x312C \n-ur 0xAC00..0xD7A3\n-end xmlIsBaseChar\n-\n-name xmlIsIdeographic\n-ur 0x4E00..0x9FA5 \n-ur 0x3007 \n-ur 0x3021..0x3029\n-end xmlIsIdeographic\n-\n-name xmlIsCombining\n-ur 0x0300..0x0345 \n-ur 0x0360..0x0361 \n-ur 0x0483..0x0486 \n-ur 0x0591..0x05A1 \n-ur 0x05A3..0x05B9 \n-ur 0x05BB..0x05BD \n-ur 0x05BF \n-ur 0x05C1..0x05C2 \n-ur 0x05C4 \n-ur 0x064B..0x0652 \n-ur 0x0670 \n-ur 0x06D6..0x06DC \n-ur 0x06DD..0x06DF \n-ur 0x06E0..0x06E4 \n-ur 0x06E7..0x06E8 \n-ur 0x06EA..0x06ED \n-ur 0x0901..0x0903 \n-ur 0x093C \n-ur 0x093E..0x094C \n-ur 0x094D \n-ur 0x0951..0x0954 \n-ur 0x0962..0x0963 \n-ur 0x0981..0x0983 \n-ur 0x09BC \n-ur 0x09BE \n-ur 0x09BF \n-ur 0x09C0..0x09C4 \n-ur 0x09C7..0x09C8 \n-ur 0x09CB..0x09CD \n-ur 0x09D7 \n-ur 0x09E2..0x09E3 \n-ur 0x0A02 \n-ur 0x0A3C \n-ur 0x0A3E \n-ur 0x0A3F \n-ur 0x0A40..0x0A42 \n-ur 0x0A47..0x0A48 \n-ur 0x0A4B..0x0A4D \n-ur 0x0A70..0x0A71 \n-ur 0x0A81..0x0A83 \n-ur 0x0ABC \n-ur 0x0ABE..0x0AC5 \n-ur 0x0AC7..0x0AC9 \n-ur 0x0ACB..0x0ACD \n-ur 0x0B01..0x0B03 \n-ur 0x0B3C \n-ur 0x0B3E..0x0B43 \n-ur 0x0B47..0x0B48 \n-ur 0x0B4B..0x0B4D \n-ur 0x0B56..0x0B57 \n-ur 0x0B82..0x0B83 \n-ur 0x0BBE..0x0BC2 \n-ur 0x0BC6..0x0BC8 \n-ur 0x0BCA..0x0BCD \n-ur 0x0BD7 \n-ur 0x0C01..0x0C03 \n-ur 0x0C3E..0x0C44 \n-ur 0x0C46..0x0C48 \n-ur 0x0C4A..0x0C4D \n-ur 0x0C55..0x0C56 \n-ur 0x0C82..0x0C83 \n-ur 0x0CBE..0x0CC4 \n-ur 0x0CC6..0x0CC8 \n-ur 0x0CCA..0x0CCD \n-ur 0x0CD5..0x0CD6 \n-ur 0x0D02..0x0D03 \n-ur 0x0D3E..0x0D43 \n-ur 0x0D46..0x0D48 \n-ur 0x0D4A..0x0D4D \n-ur 0x0D57 \n-ur 0x0E31 \n-ur 0x0E34..0x0E3A \n-ur 0x0E47..0x0E4E \n-ur 0x0EB1 \n-ur 0x0EB4..0x0EB9 \n-ur 0x0EBB..0x0EBC \n-ur 0x0EC8..0x0ECD \n-ur 0x0F18..0x0F19 \n-ur 0x0F35 \n-ur 0x0F37 \n-ur 0x0F39 \n-ur 0x0F3E \n-ur 0x0F3F \n-ur 0x0F71..0x0F84 \n-ur 0x0F86..0x0F8B \n-ur 0x0F90..0x0F95 \n-ur 0x0F97 \n-ur 0x0F99..0x0FAD \n-ur 0x0FB1..0x0FB7 \n-ur 0x0FB9 \n-ur 0x20D0..0x20DC \n-ur 0x20E1 \n-ur 0x302A..0x302F \n-ur 0x3099 \n-ur 0x309A\n-end xmlIsCombining\n-\n-name xmlIsDigit\n-ur 0x0030..0x0039 \n-ur 0x0660..0x0669 \n-ur 0x06F0..0x06F9 \n-ur 0x0966..0x096F \n-ur 0x09E6..0x09EF \n-ur 0x0A66..0x0A6F \n-ur 0x0AE6..0x0AEF \n-ur 0x0B66..0x0B6F \n-ur 0x0BE7..0x0BEF \n-ur 0x0C66..0x0C6F \n-ur 0x0CE6..0x0CEF \n-ur 0x0D66..0x0D6F \n-ur 0x0E50..0x0E59 \n-ur 0x0ED0..0x0ED9 \n-ur 0x0F20..0x0F29\n-end xmlIsDigit\n-\n-name xmlIsExtender\n-ur 0x00B7 \n-ur 0x02D0 \n-ur 0x02D1 \n-ur 0x0387 \n-ur 0x0640 \n-ur 0x0E46 \n-ur 0x0EC6 \n-ur 0x3005 \n-ur 0x3031..0x3035 \n-ur 0x309D..0x309E \n-ur 0x30FC..0x30FE\n-end xmlIsExtender\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/chvalid.def","additions":0,"deletions":361,"binary":false,"changes":361,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-\/* A form that will not confuse apibuild.py *\/\n-#cmakedefine ATTRIBUTE_DESTRUCTOR @ATTRIBUTE_DESTRUCTOR@\n-\n-\/* Define to 1 if you have the <arpa\/inet.h> header file. *\/\n-#cmakedefine HAVE_ARPA_INET_H 1\n-\n-\/* Define if __attribute__((destructor)) is accepted *\/\n-#cmakedefine HAVE_ATTRIBUTE_DESTRUCTOR 1\n-\n-\/* Define to 1 if you have the <dlfcn.h> header file. *\/\n-#cmakedefine HAVE_DLFCN_H 1\n-\n-\/* Have dlopen based dso *\/\n-#cmakedefine HAVE_DLOPEN 1\n-\n-\/* Define to 1 if you have the <dl.h> header file. *\/\n-#cmakedefine HAVE_DL_H 1\n-\n-\/* Define to 1 if you have the <fcntl.h> header file. *\/\n-#cmakedefine HAVE_FCNTL_H 1\n-\n-\/* Define to 1 if you have the `ftime' function. *\/\n-#cmakedefine HAVE_FTIME 1\n-\n-\/* Define to 1 if you have the `getentropy' function. *\/\n-#cmakedefine HAVE_GETENTROPY 1\n-\n-\/* Define to 1 if you have the `gettimeofday' function. *\/\n-#cmakedefine HAVE_GETTIMEOFDAY 1\n-\n-\/* Define if history library is there (-lhistory) *\/\n-#cmakedefine HAVE_LIBHISTORY 1\n-\n-\/* Define if readline library is there (-lreadline) *\/\n-#cmakedefine HAVE_LIBREADLINE 1\n-\n-\/* Define to 1 if you have the `mmap' function. *\/\n-#cmakedefine HAVE_MMAP 1\n-\n-\/* Define to 1 if you have the `munmap' function. *\/\n-#cmakedefine HAVE_MUNMAP 1\n-\n-\/* mmap() is no good without munmap() *\/\n-#if defined(HAVE_MMAP) && !defined(HAVE_MUNMAP)\n-#  undef \/**\/ HAVE_MMAP\n-#endif\n-\n-\/* Define to 1 if you have the <netdb.h> header file. *\/\n-#cmakedefine HAVE_NETDB_H 1\n-\n-\/* Define to 1 if you have the <netinet\/in.h> header file. *\/\n-#cmakedefine HAVE_NETINET_IN_H 1\n-\n-\/* Define to 1 if you have the <poll.h> header file. *\/\n-#cmakedefine HAVE_POLL_H 1\n-\n-\/* Define to 1 if you have the <pthread.h> header file. *\/\n-#cmakedefine HAVE_PTHREAD_H 1\n-\n-\/* Have shl_load based dso *\/\n-#cmakedefine HAVE_SHLLOAD 1\n-\n-\/* Define to 1 if you have the `stat' function. *\/\n-#cmakedefine HAVE_STAT 1\n-\n-\/* Define to 1 if you have the <stdint.h> header file. *\/\n-#cmakedefine HAVE_STDINT_H 1\n-\n-\/* Define to 1 if you have the <sys\/mman.h> header file. *\/\n-#cmakedefine HAVE_SYS_MMAN_H 1\n-\n-\/* Define to 1 if you have the <sys\/random.h> header file. *\/\n-#cmakedefine HAVE_SYS_RANDOM_H 1\n-\n-\/* Define to 1 if you have the <sys\/select.h> header file. *\/\n-#cmakedefine HAVE_SYS_SELECT_H 1\n-\n-\/* Define to 1 if you have the <sys\/socket.h> header file. *\/\n-#cmakedefine HAVE_SYS_SOCKET_H 1\n-\n-\/* Define to 1 if you have the <sys\/stat.h> header file. *\/\n-#cmakedefine HAVE_SYS_STAT_H 1\n-\n-\/* Define to 1 if you have the <sys\/timeb.h> header file. *\/\n-#cmakedefine HAVE_SYS_TIMEB_H 1\n-\n-\/* Define to 1 if you have the <sys\/time.h> header file. *\/\n-#cmakedefine HAVE_SYS_TIME_H 1\n-\n-\/* Define to 1 if you have the <unistd.h> header file. *\/\n-#cmakedefine HAVE_UNISTD_H 1\n-\n-\/* Define to 1 if you have the <zlib.h> header file. *\/\n-#cmakedefine HAVE_ZLIB_H 1\n-\n-\/* Support for IPv6 *\/\n-#cmakedefine SUPPORT_IP6 1\n-\n-\/* Version number of package *\/\n-#cmakedefine VERSION \"@VERSION@\"\n-\n-\/* Determine what socket length (socklen_t) data type is *\/\n-#cmakedefine XML_SOCKLEN_T @XML_SOCKLEN_T@\n-\n-\/* TLS specifier *\/\n-#cmakedefine XML_THREAD_LOCAL @XML_THREAD_LOCAL@\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/config.h.cmake.in","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -1,1155 +0,0 @@\n-dnl Process this file with autoconf to produce a configure script.\n-AC_PREREQ([2.63])\n-\n-m4_define([MAJOR_VERSION], 2)\n-m4_define([MINOR_VERSION], 13)\n-m4_define([MICRO_VERSION], 8)\n-\n-AC_INIT([libxml2],[MAJOR_VERSION.MINOR_VERSION.MICRO_VERSION])\n-AC_CONFIG_SRCDIR([entities.c])\n-AC_CONFIG_HEADERS([config.h])\n-AC_CONFIG_MACRO_DIR([m4])\n-AC_CONFIG_AUX_DIR([.])\n-AC_CANONICAL_HOST\n-\n-LIBXML_MAJOR_VERSION=MAJOR_VERSION\n-LIBXML_MINOR_VERSION=MINOR_VERSION\n-LIBXML_MICRO_VERSION=MICRO_VERSION\n-LIBXML_MICRO_VERSION_SUFFIX=\n-LIBXML_VERSION=$LIBXML_MAJOR_VERSION.$LIBXML_MINOR_VERSION.$LIBXML_MICRO_VERSION$LIBXML_MICRO_VERSION_SUFFIX\n-LIBXML_VERSION_INFO=`expr $LIBXML_MAJOR_VERSION + $LIBXML_MINOR_VERSION`:$LIBXML_MICRO_VERSION:$LIBXML_MINOR_VERSION\n-\n-LIBXML_VERSION_NUMBER=`expr $LIBXML_MAJOR_VERSION \\* 10000 + $LIBXML_MINOR_VERSION \\* 100 + $LIBXML_MICRO_VERSION`\n-\n-if test -d .git ; then\n-  extra=`git describe 2>\/dev\/null`\n-  echo extra=$extra\n-  if test \"$extra\" != \"\"\n-  then\n-      LIBXML_VERSION_EXTRA=\"-GIT$extra\"\n-  fi\n-fi\n-\n-AC_SUBST(LIBXML_MAJOR_VERSION)\n-AC_SUBST(LIBXML_MINOR_VERSION)\n-AC_SUBST(LIBXML_MICRO_VERSION)\n-AC_SUBST(LIBXML_VERSION)\n-AC_SUBST(LIBXML_VERSION_INFO)\n-AC_SUBST(LIBXML_VERSION_NUMBER)\n-AC_SUBST(LIBXML_VERSION_EXTRA)\n-\n-VERSION=${LIBXML_VERSION}\n-\n-AM_INIT_AUTOMAKE([1.16.3 foreign no-dist-gzip dist-xz])\n-AM_MAINTAINER_MODE([enable])\n-AM_SILENT_RULES([yes])\n-\n-dnl Checks for programs.\n-AC_PROG_CC\n-AC_PROG_INSTALL\n-AC_PROG_LN_S\n-AC_PROG_MKDIR_P\n-AC_PATH_PROG(TAR, tar, \/bin\/tar)\n-AC_PATH_PROG(PERL, perl, \/usr\/bin\/perl)\n-AC_PATH_PROG(WGET, wget, \/usr\/bin\/wget)\n-AC_PATH_PROG(XSLTPROC, xsltproc, \/usr\/bin\/xsltproc)\n-PKG_PROG_PKG_CONFIG\n-\n-LT_INIT([disable-static])\n-LT_LIB_M\n-\n-dnl\n-dnl We process the AC_ARG_WITH first so that later we can modify\n-dnl some of them to try to prevent impossible combinations.  This\n-dnl also allows up so alphabetize the choices\n-dnl\n-\n-AC_ARG_WITH(c14n,\n-[  --with-c14n             Canonical XML 1.0 support (on)])\n-AC_ARG_WITH(catalog,\n-[  --with-catalog          XML Catalogs support (on)])\n-AC_ARG_WITH(debug,\n-[  --with-debug            debugging module and shell (on)])\n-AC_ARG_WITH(ftp,\n-[  --with-ftp              FTP support (off)])\n-AC_ARG_WITH(history,\n-[  --with-history          history support for shell (off)])\n-AC_ARG_WITH(readline,\n-[  --with-readline[[=DIR]]   use readline in DIR (for shell history)])\n-AC_ARG_WITH(html,\n-[  --with-html             HTML parser (on)])\n-AC_ARG_WITH(http,\n-[  --with-http             HTTP support (off)])\n-AC_ARG_WITH(iconv,\n-[  --with-iconv[[=DIR]]      iconv support (on)])\n-AC_ARG_WITH(icu,\n-[  --with-icu              ICU support (off)])\n-AC_ARG_WITH(iso8859x,\n-[  --with-iso8859x         ISO-8859-X support if no iconv (on)])\n-AC_ARG_WITH(lzma,\n-[  --with-lzma[[=DIR]]       use liblzma in DIR (off)])\n-AC_ARG_WITH(modules,\n-[  --with-modules          dynamic modules support (on)])\n-AC_ARG_WITH(output,\n-[  --with-output           serialization support (on)])\n-AC_ARG_WITH(pattern,\n-[  --with-pattern          xmlPattern selection interface (on)])\n-AC_ARG_WITH(push,\n-[  --with-push             push parser interfaces (on)])\n-AC_ARG_WITH(python,\n-[  --with-python           Python bindings (on)])\n-AC_ARG_WITH(reader,\n-[  --with-reader           xmlReader parsing interface (on)])\n-AC_ARG_WITH(regexps,\n-[  --with-regexps          regular expressions support (on)])\n-AC_ARG_WITH(sax1,\n-[  --with-sax1             older SAX1 interface (on)])\n-AC_ARG_WITH(schemas,\n-[  --with-schemas          XML Schemas 1.0 and RELAX NG support (on)])\n-AC_ARG_WITH(schematron,\n-[  --with-schematron       Schematron support (on)])\n-AC_ARG_WITH(threads,\n-[  --with-threads          multithreading support (on)])\n-AC_ARG_WITH(thread-alloc,\n-[  --with-thread-alloc     per-thread malloc hooks (off)])\n-AC_ARG_WITH(tree,\n-[  --with-tree             DOM like tree manipulation APIs (on)])\n-AC_ARG_WITH(valid,\n-[  --with-valid            DTD validation support (on)])\n-AC_ARG_WITH(writer,\n-[  --with-writer           xmlWriter serialization interface (on)])\n-AC_ARG_WITH(xinclude,\n-[  --with-xinclude         XInclude 1.0 support (on)])\n-AC_ARG_WITH(xpath,\n-[  --with-xpath            XPath 1.0 support (on)])\n-AC_ARG_WITH(xptr,\n-[  --with-xptr             XPointer support (on)])\n-AC_ARG_WITH(xptr-locs,\n-[  --with-xptr-locs        XPointer ranges and points (off)])\n-AC_ARG_WITH(zlib,\n-[  --with-zlib[[=DIR]]       use libz in DIR (off)])\n-\n-AC_ARG_WITH(minimum,\n-[  --with-minimum          build a minimally sized library (off)])\n-AC_ARG_WITH(legacy,\n-[  --with-legacy           maximum ABI compatibility (off)])\n-\n-AC_ARG_WITH(tls,\n-[  --with-tls              thread-local storage (off)])\n-\n-dnl\n-dnl Legacy defaults\n-dnl\n-if test \"$with_legacy\" = \"yes\"; then\n-    if test \"$with_http\" = \"\"; then\n-        with_http=yes\n-    fi\n-    if test \"$with_lzma\" = \"\"; then\n-        with_lzma=yes\n-    fi\n-    if test \"$with_zlib\" = \"\"; then\n-        with_zlib=yes\n-    fi\n-fi\n-\n-dnl\n-dnl hard dependencies on options\n-dnl\n-if test \"$with_c14n\" = \"yes\"; then\n-    if test \"$with_output\" = \"no\"; then\n-        echo WARNING: --with-c14n overrides --without-output\n-    fi\n-    with_output=yes\n-    if test \"$with_xpath\" = \"no\"; then\n-        echo WARNING: --with-c14n overrides --without-xpath\n-    fi\n-    with_xpath=yes\n-fi\n-if test \"$with_schemas\" = \"yes\"; then\n-    if test \"$with_pattern\" = \"no\"; then\n-        echo WARNING: --with-schemas overrides --without-pattern\n-    fi\n-    with_pattern=yes\n-    if test \"$with_regexps\" = \"no\"; then\n-        echo WARNING: --with-schemas overrides --without-regexps\n-    fi\n-    with_regexps=yes\n-fi\n-if test \"$with_schematron\" = \"yes\"; then\n-    if test \"$with_pattern\" = \"no\"; then\n-        echo WARNING: --with-schematron overrides --without-pattern\n-    fi\n-    with_pattern=yes\n-    if test \"$with_tree\" = \"no\"; then\n-        echo WARNING: --with-schematron overrides --without-tree\n-    fi\n-    with_tree=yes\n-    if test \"$with_xpath\" = \"no\"; then\n-        echo WARNING: --with-schematron overrides --without-xpath\n-    fi\n-    with_xpath=yes\n-fi\n-if test \"$with_reader\" = \"yes\"; then\n-    if test \"$with_push\" = \"no\"; then\n-        echo WARNING: --with-reader overrides --without-push\n-    fi\n-    with_push=yes\n-    if test \"$with_tree\" = \"no\"; then\n-        echo WARNING: --with-reader overrides --without-tree\n-    fi\n-    with_tree=yes\n-fi\n-if test \"$with_writer\" = \"yes\"; then\n-    if test \"$with_output\" = \"no\"; then\n-        echo WARNING: --with-writer overrides --without-output\n-    fi\n-    with_output=yes\n-    if test \"$with_push\" = \"no\"; then\n-        echo WARNING: --with-writer overrides --without-push\n-    fi\n-    with_push=yes\n-fi\n-if test \"$with_xinclude\" = \"yes\"; then\n-    if test \"$with_xpath\" = \"no\"; then\n-        echo WARNING: --with-xinclude overrides --without-xpath\n-    fi\n-    with_xpath=yes\n-fi\n-if test \"$with_xptr_locs\" = \"yes\"; then\n-    if test \"$with_xptr\" = \"no\"; then\n-        echo WARNING: --with-xptr-locs overrides --without-xptr\n-    fi\n-    with_xptr=yes\n-fi\n-if test \"$with_xptr\" = \"yes\"; then\n-    if test \"$with_xpath\" = \"no\"; then\n-        echo WARNING: --with-xptr overrides --without-xpath\n-    fi\n-    with_xpath=yes\n-fi\n-\n-if test \"$with_minimum\" = \"yes\"; then\n-    dnl\n-    dnl option to build a minimal libxml2 library\n-    dnl\n-    echo \"Configuring for a minimal library\"\n-    test \"$with_c14n\" = \"\" && with_c14n=no\n-    test \"$with_catalog\" = \"\" && with_catalog=no\n-    test \"$with_debug\" = \"\" && with_debug=no\n-    test \"$with_history\" = \"\" && with_history=no\n-    test \"$with_html\" = \"\" && with_html=no\n-    test \"$with_http\" = \"\" && with_http=no\n-    test \"$with_iconv\" = \"\" && with_iconv=no\n-    test \"$with_iso8859x\" = \"\" && with_iso8859x=no\n-    test \"$with_lzma\" = \"\" && with_lzma=no\n-    test \"$with_output\" = \"\" && with_output=no\n-    test \"$with_pattern\" = \"\" && with_pattern=no\n-    test \"$with_push\" = \"\" && with_push=no\n-    test \"$with_python\" = \"\" && with_python=no\n-    test \"$with_reader\" = \"\" && with_reader=no\n-    test \"$with_readline\" = \"\" && with_readline=no\n-    test \"$with_regexps\" = \"\" && with_regexps=no\n-    test \"$with_sax1\" = \"\" && with_sax1=no\n-    test \"$with_schemas\" = \"\" && with_schemas=no\n-    test \"$with_schematron\" = \"\" && with_schematron=no\n-    test \"$with_threads\" = \"\" && with_threads=no\n-    test \"$with_thread_alloc\" = \"\" && with_thread_alloc=no\n-    test \"$with_tree\" = \"\" && with_tree=no\n-    test \"$with_valid\" = \"\" && with_valid=no\n-    test \"$with_writer\" = \"\" && with_writer=no\n-    test \"$with_xinclude\" = \"\" && with_xinclude=no\n-    test \"$with_xpath\" = \"\" && with_xpath=no\n-    test \"$with_xptr\" = \"\" && with_xptr=no\n-    test \"$with_zlib\" = \"\" && with_zlib=no\n-    test \"$with_modules\" = \"\" && with_modules=no\n-else\n-    dnl\n-    dnl Disable dependent modules\n-    dnl\n-    if test \"$with_output\" = \"no\"; then\n-        with_c14n=no\n-        with_writer=no\n-    fi\n-    if test \"$with_pattern\" = \"no\"; then\n-        with_schemas=no\n-        with_schematron=no\n-    fi\n-    if test \"$with_push\" = \"no\"; then\n-        with_reader=no\n-        with_writer=no\n-    fi\n-    if test \"$with_regexps\" = \"no\"; then\n-        with_schemas=no\n-    fi\n-    if test \"$with_tree\" = \"no\"; then\n-        with_reader=no\n-        with_schematron=no\n-    fi\n-    if test \"$with_xpath\" = \"no\"; then\n-        with_c14n=no\n-        with_schematron=no\n-        with_xinclude=no\n-        with_xptr=no\n-    fi\n-fi\n-\n-XML_PRIVATE_LIBS=\n-XML_PRIVATE_CFLAGS=\n-XML_PC_LIBS=\n-XML_PC_REQUIRES=\n-\n-dnl\n-dnl Checks for header files.\n-dnl\n-AC_CHECK_HEADERS([stdint.h])\n-AC_CHECK_HEADERS([fcntl.h unistd.h sys\/stat.h])\n-AC_CHECK_HEADERS([sys\/mman.h])\n-AC_CHECK_HEADERS([sys\/time.h sys\/timeb.h])\n-AC_CHECK_HEADERS([sys\/random.h])\n-AC_CHECK_HEADERS([dl.h dlfcn.h])\n-AC_CHECK_HEADERS([glob.h])\n-AM_CONDITIONAL(WITH_GLOB, test \"$ac_cv_header_glob_h\" = \"yes\")\n-\n-dnl Checks for library functions.\n-AC_CHECK_FUNCS([gettimeofday ftime stat mmap munmap])\n-\n-AH_VERBATIM([HAVE_MUNMAP_AFTER],[\/* mmap() is no good without munmap() *\/\n-#if defined(HAVE_MMAP) && !defined(HAVE_MUNMAP)\n-#  undef \/**\/ HAVE_MMAP\n-#endif])\n-\n-AC_CHECK_DECL([getentropy],\n-              [AC_DEFINE([HAVE_GETENTROPY], [1], [getentropy])], [],\n-              [#include <sys\/random.h>])\n-\n-dnl\n-dnl Checks for inet libraries\n-dnl\n-if test \"$with_http\" = \"yes\" || test \"$with_ftp\" = \"yes\"; then\n-    AC_CHECK_HEADERS([sys\/socket.h netinet\/in.h arpa\/inet.h netdb.h])\n-    AC_CHECK_HEADERS([sys\/select.h poll.h])\n-\n-    case \"$host\" in\n-        *-*-mingw*)\n-            dnl AC_SEARCH_LIBS doesn't work because of non-standard calling\n-            dnl conventions on 32-bit Windows.\n-            NET_LIBS=\"$NET_LIBS -lws2_32\"\n-            ;;\n-        *)\n-            _libs=$LIBS\n-            AC_SEARCH_LIBS(gethostbyname, [nsl], [\n-                if test \"$ac_cv_search_gethostbyname\" != \"none required\"; then\n-                    NET_LIBS=\"$NET_LIBS $ac_cv_search_gethostbyname\"\n-                fi], [:], [$NET_LIBS])\n-            AC_SEARCH_LIBS(connect, [bsd socket inet], [\n-                if test \"$ac_cv_search_connect\" != \"none required\"; then\n-                    NET_LIBS=\"$NET_LIBS $ac_cv_search_connect\"\n-                fi], [:], [$NET_LIBS])\n-            LIBS=$_libs\n-            ;;\n-    esac\n-\n-    dnl Determine what socket length (socklen_t) data type is\n-    AC_MSG_CHECKING([for type of socket length (socklen_t)])\n-    AC_TRY_COMPILE2([\n-    #include <stddef.h>\n-    #ifdef _WIN32\n-      #include <ws2tcpip.h>\n-    #else\n-      #include <sys\/socket.h>\n-    #endif],[\n-    (void)getsockopt (1, 1, 1, NULL, (socklen_t *)NULL)],[\n-      AC_MSG_RESULT(socklen_t *)\n-      XML_SOCKLEN_T=socklen_t],[\n-      AC_TRY_COMPILE2([\n-    #include <stddef.h>\n-    #include <sys\/socket.h>],[\n-    (void)getsockopt (1, 1, 1, NULL, (size_t *)NULL)],[\n-        AC_MSG_RESULT(size_t *)\n-        XML_SOCKLEN_T=size_t],[\n-        AC_TRY_COMPILE2([\n-    #include <stddef.h>\n-    #include <sys\/socket.h>],[\n-    (void)getsockopt (1, 1, 1, NULL, (int *)NULL)],[\n-          AC_MSG_RESULT(int *)\n-          XML_SOCKLEN_T=int],[\n-          AC_MSG_WARN(could not determine)\n-          XML_SOCKLEN_T=\"int\"])])])\n-    AC_DEFINE_UNQUOTED(XML_SOCKLEN_T, $XML_SOCKLEN_T, [Determine what socket length (socklen_t) data type is])\n-\n-    dnl\n-    dnl Checking for availability of IPv6\n-    dnl\n-    AC_ARG_ENABLE(ipv6, [  --enable-ipv6[[=yes\/no]]  enables compilation of IPv6 code [[default=yes]]],, enable_ipv6=yes)\n-    if test \"$with_minimum\" = \"yes\"\n-    then\n-        enable_ipv6=no\n-    fi\n-    if test $enable_ipv6 = yes; then\n-        AC_MSG_CHECKING([whether to enable IPv6])\n-        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n-            #ifdef _WIN32\n-              #include <winsock2.h>\n-            #else\n-              #include <sys\/socket.h>\n-              #ifdef HAVE_NETDB_H\n-                #include <netdb.h>\n-              #endif\n-            #endif\n-            ]], [[\n-            struct sockaddr_storage ss;\n-            socket(AF_INET6, SOCK_STREAM, 0);\n-            getaddrinfo(0, 0, 0, 0);\n-            ]])], [\n-            AC_DEFINE([SUPPORT_IP6], [], [Support for IPv6])\n-            AC_MSG_RESULT([yes])], [\n-            AC_MSG_RESULT([no])]\n-        )\n-    fi\n-fi\n-\n-dnl\n-dnl Extra flags\n-dnl\n-XML_LIBDIR='-L${libdir}'\n-XML_INCLUDEDIR='-I${includedir}\/libxml2'\n-XML_CFLAGS=\"\"\n-\n-dnl Thread-local storage\n-if test \"$with_tls\" = \"yes\"; then\n-    AC_COMPILE_IFELSE([\n-        AC_LANG_SOURCE([_Thread_local int v;]) ], [\n-        AC_DEFINE([XML_THREAD_LOCAL], [_Thread_local], [TLS specifier]) ], [\n-    AC_COMPILE_IFELSE([\n-        AC_LANG_SOURCE([__thread int v;]) ], [\n-        AC_DEFINE([XML_THREAD_LOCAL], [__thread], [TLS specifier]) ], [\n-    AC_COMPILE_IFELSE([\n-        AC_LANG_SOURCE([__declspec(thread) int v;]) ], [\n-        AC_DEFINE([XML_THREAD_LOCAL], [__declspec(thread)], [TLS specifier]) ], [\n-    WARN_NO_TLS=1 ])])])\n-fi\n-\n-dnl Checking whether __attribute__((destructor)) is accepted by the compiler\n-AC_MSG_CHECKING([whether __attribute__((destructor)) is accepted])\n-AC_TRY_COMPILE2([\n-void __attribute__((destructor))\n-f(void) {}], [], [\n-  AC_MSG_RESULT(yes)\n-  AC_DEFINE([HAVE_ATTRIBUTE_DESTRUCTOR], [1],[Define if __attribute__((destructor)) is accepted])\n-  AC_DEFINE([ATTRIBUTE_DESTRUCTOR], [__attribute__((destructor))],[A form that will not confuse apibuild.py])],[\n-  AC_MSG_RESULT(no)])\n-\n-dnl\n-dnl Linker version scripts for symbol versioning\n-dnl\n-VERSION_SCRIPT_FLAGS=\n-# lt_cv_prog_gnu_ld is from libtool 2.+\n-if test \"$lt_cv_prog_gnu_ld\" = yes; then\n-  case $host in\n-    *-*-cygwin* | *-*-mingw* | *-*-msys* )\n-      ;;\n-    *)\n-      dnl lld 16 defaults to --no-undefined-version but the version script\n-      dnl can contain symbols disabled by configuration options.\n-      AX_APPEND_LINK_FLAGS([-Wl,--undefined-version], [VERSION_SCRIPT_FLAGS])\n-      AX_APPEND_FLAG([-Wl,--version-script=], [VERSION_SCRIPT_FLAGS])\n-      ;;\n-  esac\n-else\n-  case $host in\n-  *-*-sunos*) VERSION_SCRIPT_FLAGS=\"-Wl,-M -Wl,\";;\n-  esac\n-fi\n-AC_SUBST(VERSION_SCRIPT_FLAGS)\n-AM_CONDITIONAL([USE_VERSION_SCRIPT], [test -n \"$VERSION_SCRIPT_FLAGS\"])\n-\n-dnl\n-dnl Workaround for native compilers\n-dnl  HP  : http:\/\/bugs.gnome.org\/db\/31\/3163.html\n-dnl  DEC : Enable NaN\/Inf\n-dnl\n-if test \"${GCC}\" != \"yes\" ; then\n-    case \"${host}\" in\n-          hppa*-*-hpux* )\n-\t       AM_CFLAGS=\"${AM_CFLAGS} -Wp,-H30000\"\n-\t       ;;\n-          *-dec-osf* )\n-               AM_CFLAGS=\"${AM_CFLAGS} -ieee\"\n-               ;;\n-\t  alpha*-*-linux* )\n-\t       AM_CFLAGS=\"${AM_CFLAGS} -ieee\"\n-\t       ;;\n-    esac\n-else\n-    # warnings we'd like to see\n-    AM_CFLAGS=\"${AM_CFLAGS} -pedantic -Wall -Wextra -Wshadow -Wpointer-arith -Wcast-align -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes\"\n-    # warnings we'd like to suppress\n-    AM_CFLAGS=\"${AM_CFLAGS} -Wno-long-long -Wno-format-extra-args\"\n-    case \"${host}\" in\n-          alpha*-*-linux* )\n-\t       AM_CFLAGS=\"${AM_CFLAGS} -mieee\"\n-\t       ;;\n-\t  alpha*-*-osf* )\n-\t       AM_CFLAGS=\"${AM_CFLAGS} -mieee\"\n-\t       ;;\n-    esac\n-fi\n-case ${host} in\n-    *-*-solaris*)\n-        XML_LIBDIR=\"${XML_LIBDIR} -R${libdir}\"\n-        ;;\n-    *-*-cygwin* | *-*-mingw* | *-*-msys* )\n-        # If the host is Windows, and shared libraries are disabled, we\n-        # need to add -DLIBXML_STATIC to AM_CFLAGS in order for linking to\n-        # work properly (without it, xmlexports.h would force the use of\n-        # DLL imports, which obviously aren't present in a static\n-        # library).\n-        if test \"x$enable_shared\" = \"xno\"; then\n-            XML_CFLAGS=\"$XML_CFLAGS -DLIBXML_STATIC\"\n-            AM_CFLAGS=\"$AM_CFLAGS -DLIBXML_STATIC\"\n-        fi\n-        ;;\n-esac\n-\n-\n-dnl\n-dnl Simple API modules\n-dnl\n-\n-if test \"$with_tree\" = \"no\" ; then\n-    echo Disabling DOM like tree manipulation APIs\n-    WITH_TREE=0\n-else\n-    WITH_TREE=1\n-fi\n-AC_SUBST(WITH_TREE)\n-\n-if test \"$with_ftp\" != \"yes\" ; then\n-    WITH_FTP=0\n-else\n-    echo Enabling FTP support\n-    WITH_FTP=1\n-fi\n-AC_SUBST(WITH_FTP)\n-AM_CONDITIONAL(WITH_FTP_SOURCES, test \"$WITH_FTP\" = \"1\")\n-\n-if test \"$with_http\" != \"yes\" ; then\n-    WITH_HTTP=0\n-else\n-    echo Enabling HTTP support\n-    WITH_HTTP=1\n-fi\n-AC_SUBST(WITH_HTTP)\n-AM_CONDITIONAL(WITH_HTTP_SOURCES, test \"$WITH_HTTP\" = \"1\")\n-\n-if test \"$with_legacy\" != \"yes\" ; then\n-    WITH_LEGACY=0\n-else\n-    echo Enabling deprecated APIs\n-    WITH_LEGACY=1\n-fi\n-AC_SUBST(WITH_LEGACY)\n-AM_CONDITIONAL(WITH_LEGACY_SOURCES, test \"$WITH_LEGACY\" = \"1\")\n-\n-if test \"$with_reader\" = \"no\" ; then\n-    echo Disabling the xmlReader parsing interface\n-    WITH_READER=0\n-else\n-    WITH_READER=1\n-fi\n-AC_SUBST(WITH_READER)\n-AM_CONDITIONAL(WITH_READER_SOURCES, test \"$WITH_READER\" = \"1\")\n-\n-if test \"$with_writer\" = \"no\" ; then\n-    echo Disabling the xmlWriter saving interface\n-    WITH_WRITER=0\n-else\n-    WITH_WRITER=1\n-fi\n-AC_SUBST(WITH_WRITER)\n-AM_CONDITIONAL(WITH_WRITER_SOURCES, test \"$WITH_WRITER\" = \"1\")\n-\n-if test \"$with_pattern\" = \"no\" ; then\n-    echo Disabling the xmlPattern parsing interface\n-    WITH_PATTERN=0\n-else\n-    WITH_PATTERN=1\n-fi\n-AC_SUBST(WITH_PATTERN)\n-AM_CONDITIONAL(WITH_PATTERN_SOURCES, test \"$WITH_PATTERN\" = \"1\")\n-\n-if test \"$with_sax1\" = \"no\" ; then\n-    echo Disabling the older SAX1 interface\n-    WITH_SAX1=0\n-else\n-    WITH_SAX1=1\n-fi\n-AC_SUBST(WITH_SAX1)\n-AM_CONDITIONAL(WITH_SAX1_SOURCES, test \"$WITH_SAX1\" = \"1\")\n-\n-if test \"$with_push\" = \"no\" ; then\n-    echo Disabling the PUSH parser interfaces\n-    WITH_PUSH=0\n-else\n-    WITH_PUSH=1\n-fi\n-AC_SUBST(WITH_PUSH)\n-\n-if test \"$with_html\" = \"no\" ; then\n-    echo Disabling HTML support\n-    WITH_HTML=0\n-else\n-    WITH_HTML=1\n-fi\n-AC_SUBST(WITH_HTML)\n-AM_CONDITIONAL(WITH_HTML_SOURCES, test \"$WITH_HTML\" = \"1\")\n-\n-if test \"$with_valid\" = \"no\" ; then\n-    echo Disabling DTD validation support\n-    WITH_VALID=0\n-else\n-    WITH_VALID=1\n-fi\n-AC_SUBST(WITH_VALID)\n-AM_CONDITIONAL(WITH_VALID_SOURCES, test \"$WITH_VALID\" = \"1\")\n-\n-if test \"$with_catalog\" = \"no\" ; then\n-    echo Disabling Catalog support\n-    WITH_CATALOG=0\n-else\n-    WITH_CATALOG=1\n-fi\n-AC_SUBST(WITH_CATALOG)\n-AM_CONDITIONAL(WITH_CATALOG_SOURCES, test \"$WITH_CATALOG\" = \"1\")\n-\n-if test \"$with_xptr\" = \"no\" ; then\n-    echo Disabling XPointer support\n-    WITH_XPTR=0\n-    WITH_XPTR_LOCS=0\n-else\n-    WITH_XPTR=1\n-fi\n-AC_SUBST(WITH_XPTR)\n-AM_CONDITIONAL(WITH_XPTR_SOURCES, test \"$WITH_XPTR\" = \"1\")\n-\n-if test \"$with_xptr_locs\" != \"yes\" ; then\n-    WITH_XPTR_LOCS=0\n-else\n-    echo Enabling Xpointer locations support\n-    WITH_XPTR_LOCS=1\n-fi\n-AC_SUBST(WITH_XPTR_LOCS)\n-\n-if test \"$with_c14n\" = \"no\" ; then\n-    echo Disabling C14N support\n-    WITH_C14N=0\n-else\n-    WITH_C14N=1\n-fi\n-AC_SUBST(WITH_C14N)\n-AM_CONDITIONAL(WITH_C14N_SOURCES, test \"$WITH_C14N\" = \"1\")\n-\n-if test \"$with_xinclude\" = \"no\" ; then\n-    echo Disabling XInclude support\n-    WITH_XINCLUDE=0\n-else\n-    WITH_XINCLUDE=1\n-fi\n-AC_SUBST(WITH_XINCLUDE)\n-AM_CONDITIONAL(WITH_XINCLUDE_SOURCES, test \"$WITH_XINCLUDE\" = \"1\")\n-\n-if test \"$with_schematron\" = \"no\" ; then\n-    echo \"Disabling Schematron support\"\n-    WITH_SCHEMATRON=0\n-else\n-    WITH_SCHEMATRON=1\n-fi\n-AC_SUBST(WITH_SCHEMATRON)\n-AM_CONDITIONAL(WITH_SCHEMATRON_SOURCES, test \"$WITH_SCHEMATRON\" = \"1\")\n-\n-if test \"$with_xpath\" = \"no\" ; then\n-    echo Disabling XPATH support\n-    WITH_XPATH=0\n-else\n-    WITH_XPATH=1\n-fi\n-AC_SUBST(WITH_XPATH)\n-AM_CONDITIONAL(WITH_XPATH_SOURCES, test \"$WITH_XPATH\" = \"1\")\n-\n-if test \"$with_output\" = \"no\" ; then\n-    echo Disabling serialization\/saving support\n-    WITH_OUTPUT=0\n-else\n-    WITH_OUTPUT=1\n-fi\n-AC_SUBST(WITH_OUTPUT)\n-AM_CONDITIONAL(WITH_OUTPUT_SOURCES, test \"$WITH_OUTPUT\" = \"1\")\n-\n-if test \"$WITH_ICONV\" != \"1\" && test \"$with_iso8859x\" = \"no\" ; then\n-    echo Disabling ISO8859X support\n-    WITH_ISO8859X=0\n-else\n-    WITH_ISO8859X=1\n-fi\n-AC_SUBST(WITH_ISO8859X)\n-\n-if test \"$with_schemas\" = \"no\" ; then\n-    echo \"Disabling Schemas\/Relax-NG support\"\n-    WITH_SCHEMAS=0\n-else\n-    WITH_SCHEMAS=1\n-fi\n-AC_SUBST(WITH_SCHEMAS)\n-AM_CONDITIONAL(WITH_SCHEMAS_SOURCES, test \"$WITH_SCHEMAS\" = \"1\")\n-\n-if test \"$with_regexps\" = \"no\" ; then\n-    echo Disabling Regexps support\n-    WITH_REGEXPS=0\n-else\n-    WITH_REGEXPS=1\n-fi\n-AC_SUBST(WITH_REGEXPS)\n-AM_CONDITIONAL(WITH_REGEXPS_SOURCES, test \"$WITH_REGEXPS\" = \"1\")\n-\n-if test \"$with_debug\" = \"no\" ; then\n-    echo Disabling DEBUG support\n-    WITH_DEBUG=0\n-else\n-    WITH_DEBUG=1\n-fi\n-AC_SUBST(WITH_DEBUG)\n-AM_CONDITIONAL(WITH_DEBUG_SOURCES, test \"$WITH_DEBUG\" = \"1\")\n-\n-dnl\n-dnl Check for Python\n-dnl\n-\n-AS_IF([test \"x$with_python\" != \"xno\"], [\n-    AM_PATH_PYTHON\n-    PKG_CHECK_MODULES([PYTHON], [python-${PYTHON_VERSION}])\n-])\n-AM_CONDITIONAL([WITH_PYTHON], [test \"x$with_python\" != \"xno\"])\n-\n-dnl\n-dnl Extra Python flags for Windows\n-dnl\n-PYTHON_LDFLAGS=\n-if test \"${PYTHON}\" != \"\"; then\n-    case \"$host\" in\n-        *-*-mingw* )\n-            PYTHON_LDFLAGS=\"-no-undefined -shrext .pyd\"\n-            ;;\n-        *-*-cygwin* |*-*-msys* )\n-            PYTHON_LDFLAGS=\"-no-undefined\"\n-            ;;\n-    esac\n-fi\n-AC_SUBST(PYTHON_LDFLAGS)\n-\n-dnl\n-dnl Check for DSO support\n-dnl\n-WITH_MODULES=0\n-\n-if test \"$with_modules\" != \"no\" ; then\n-    case \"$host\" in\n-        *-*-cygwin* | *-*-msys* )\n-            MODULE_EXTENSION=\".dll\"\n-            ;;\n-        *-*-mingw*)\n-            MODULE_EXTENSION=\".dll\"\n-            WITH_MODULES=1\n-            ;;\n-        *-*-hpux*)\n-\t    MODULE_EXTENSION=\".sl\"\n-\t    ;;\n-        *)\n-\t    MODULE_EXTENSION=\".so\"\n-\t    ;;\n-    esac\n-\n-    if test \"$WITH_MODULES\" = \"0\"; then\n-        _libs=$LIBS\n-        AC_SEARCH_LIBS([dlopen], [dl], [\n-            WITH_MODULES=1\n-            if test \"$ac_cv_search_dlopen\" != \"none required\"; then\n-                MODULE_PLATFORM_LIBS=$ac_cv_search_dlopen\n-            fi\n-            AC_DEFINE([HAVE_DLOPEN], [], [Have dlopen based dso])], [\n-            AC_SEARCH_LIBS([shl_load], [dld], [\n-                WITH_MODULES=1\n-                if test \"$ac_cv_search_shl_load\" != \"none required\"; then\n-                    MODULE_PLATFORM_LIBS=$ac_cv_search_shl_load\n-                fi\n-                AC_DEFINE([HAVE_SHLLOAD], [], [Have shl_load based dso])])])\n-        LIBS=$_libs\n-    fi\n-fi\n-\n-AC_SUBST(WITH_MODULES)\n-AC_SUBST(MODULE_PLATFORM_LIBS)\n-AC_SUBST(MODULE_EXTENSION)\n-AM_CONDITIONAL(WITH_MODULES_SOURCES, test \"$WITH_MODULES\" = \"1\")\n-\n-dnl\n-dnl Thread-related stuff\n-dnl\n-THREAD_LIBS=\"\"\n-BASE_THREAD_LIBS=\"\"\n-WITH_THREADS=0\n-WITH_THREAD_ALLOC=0\n-\n-if test \"$with_threads\" = \"no\" ; then\n-    echo Disabling multithreaded support\n-else\n-    case $host_os in\n-        *mingw*)\n-            dnl Default to native threads on Windows\n-            WITH_THREADS=\"1\"\n-            ;;\n-        *)\n-            dnl Use pthread by default in other cases\n-            _libs=$LIBS\n-            AC_CHECK_HEADERS(pthread.h,\n-                AC_SEARCH_LIBS([pthread_create], [pthread], [\n-                    WITH_THREADS=\"1\"\n-                    if test \"$ac_cv_search_pthread_create\" != \"none required\"; then\n-                        THREAD_LIBS=$ac_cv_search_pthread_create\n-                    fi\n-                    AC_DEFINE([HAVE_PTHREAD_H], [],\n-                              [Define if <pthread.h> is there])]))\n-            LIBS=$_libs\n-            ;;\n-    esac\n-\n-    case $host_os in\n-        *linux*)\n-            if test \"${GCC}\" = \"yes\" ; then\n-                BASE_THREAD_LIBS=\"$THREAD_LIBS\"\n-                THREAD_LIBS=\"\"\n-            fi\n-            ;;\n-    esac\n-fi\n-if test \"$with_thread_alloc\" = \"yes\" && test \"$WITH_THREADS\" = \"1\" ; then\n-    WITH_THREAD_ALLOC=1\n-fi\n-\n-AC_SUBST(THREAD_LIBS)\n-AC_SUBST(BASE_THREAD_LIBS)\n-AC_SUBST(WITH_THREADS)\n-AC_SUBST(WITH_THREAD_ALLOC)\n-\n-dnl\n-dnl xmllint shell history\n-dnl\n-if test \"$with_history\" = \"yes\" && test \"$with_readline\" != \"no\"; then\n-    echo Enabling xmllint shell history\n-    dnl check for terminal library. this is a very cool solution\n-    dnl from octave's configure.in\n-    unset tcap\n-    for termlib in ncurses curses termcap terminfo termlib; do\n-\tAC_CHECK_LIB(${termlib}, tputs, [tcap=\"-l$termlib\"])\n-\ttest -n \"$tcap\" && break\n-    done\n-\n-    _cppflags=$CPPFLAGS\n-    _libs=$LIBS\n-    if test \"$with_readline\" != \"\" && test \"$with_readline\" != \"yes\"; then\n-        RDL_DIR=$with_readline\n-        CPPFLAGS=\"${CPPFLAGS} -I$RDL_DIR\/include\"\n-        LIBS=\"${LIBS} -L$RDL_DIR\/lib\"\n-    fi\n-    AC_CHECK_HEADER(readline\/history.h,\n-\tAC_CHECK_LIB(history, append_history,[\n-\t    RDL_LIBS=\"-lhistory\"\n-            if test \"x${RDL_DIR}\" != \"x\"; then\n-                RDL_CFLAGS=\"-I$RDL_DIR\/include\"\n-                RDL_LIBS=\"-L$RDL_DIR\/lib $RDL_LIBS\"\n-            fi\n-\t    AC_DEFINE([HAVE_LIBHISTORY], [], [Define if history library is there (-lhistory)])]))\n-    AC_CHECK_HEADER(readline\/readline.h,\n-\tAC_CHECK_LIB(readline, readline,[\n-\t    RDL_LIBS=\"-lreadline $RDL_LIBS $tcap\"\n-            if test \"x$RDL_DIR\" != \"x\"; then\n-                RDL_CFLAGS=\"-I$RDL_DIR\/include\"\n-                RDL_LIBS=\"-L$RDL_DIR\/lib $RDL_LIBS\"\n-            fi\n-\t    AC_DEFINE([HAVE_LIBREADLINE], [], [Define if readline library is there (-lreadline)])], , $tcap))\n-    CPPFLAGS=$_cppflags\n-    LIBS=$_libs\n-fi\n-AC_SUBST(RDL_CFLAGS)\n-AC_SUBST(RDL_LIBS)\n-\n-dnl\n-dnl Checks for zlib library.\n-dnl\n-WITH_ZLIB=0\n-\n-if test \"$with_zlib\" != \"no\" && test \"$with_zlib\" != \"\"; then\n-    echo \"Enabling zlib compression support\"\n-\n-    if test \"$with_zlib\" != \"yes\"; then\n-        Z_DIR=$with_zlib\n-    fi\n-\n-    # Don't run pkg-config if with_zlib contains a path.\n-    if test \"x$Z_DIR\" = \"x\"; then\n-        # Try pkg-config first so that static linking works.\n-        PKG_CHECK_MODULES([Z],[zlib],\n-            [WITH_ZLIB=1; XML_PC_REQUIRES=\"${XML_PC_REQUIRES} zlib\"],\n-            [:])\n-    fi\n-\n-    if test \"$WITH_ZLIB\" = \"0\"; then\n-        _cppflags=$CPPFLAGS\n-        _libs=$LIBS\n-        if test \"x$Z_DIR\" != \"x\"; then\n-            CPPFLAGS=\"${CPPFLAGS} -I$Z_DIR\/include\"\n-            LIBS=\"${LIBS} -L$Z_DIR\/lib\"\n-        fi\n-        AC_CHECK_HEADERS(zlib.h,\n-            AC_CHECK_LIB(z, gzread,[\n-                WITH_ZLIB=1\n-                if test \"x${Z_DIR}\" != \"x\"; then\n-                    Z_CFLAGS=\"-I${Z_DIR}\/include\"\n-                    Z_LIBS=\"-L${Z_DIR}\/lib -lz\"\n-                    [case ${host} in\n-                        *-*-solaris*)\n-                            Z_LIBS=\"-L${Z_DIR}\/lib -R${Z_DIR}\/lib -lz\"\n-                            ;;\n-                    esac]\n-                else\n-                    Z_LIBS=\"-lz\"\n-                fi])\n-                XML_PC_LIBS=\"${XML_PC_LIBS} ${Z_LIBS}\"\n-            )\n-        CPPFLAGS=$_cppflags\n-        LIBS=$_libs\n-    fi\n-\n-    XML_PRIVATE_CFLAGS=\"${XML_PRIVATE_CFLAGS} ${Z_CFLAGS}\"\n-    XML_PRIVATE_LIBS=\"${XML_PRIVATE_LIBS} ${Z_LIBS}\"\n-fi\n-AC_SUBST(WITH_ZLIB)\n-\n-dnl\n-dnl Checks for lzma library.\n-dnl\n-WITH_LZMA=0\n-\n-if test \"$with_lzma\" != \"no\" && test \"$with_lzma\" != \"\"; then\n-    echo \"Enabling lzma compression support\"\n-\n-    if test \"$with_lzma\" != \"yes\"; then\n-        LZMA_DIR=$with_lzma\n-    fi\n-\n-    # Don't run pkg-config if with_lzma contains a path.\n-    if test \"x$LZMA_DIR\" = \"x\"; then\n-        # Try pkg-config first so that static linking works.\n-        PKG_CHECK_MODULES([LZMA],[liblzma],\n-            [WITH_LZMA=1; XML_PC_REQUIRES=\"${XML_PC_REQUIRES} liblzma\"],\n-            [:])\n-    fi\n-\n-    # If pkg-config failed, fall back to AC_CHECK_LIB. This\n-    # will not pick up the necessary LIBS flags for liblzma's\n-    # private dependencies, though, so static linking may fail.\n-    if test \"$WITH_LZMA\" = \"0\"; then\n-        _cppflags=$CPPFLAGS\n-        _libs=$LIBS\n-        if test \"x$LZMA_DIR\" != \"x\"; then\n-            CPPFLAGS=\"${CPPFLAGS} -I$LZMA_DIR\/include\"\n-            LIBS=\"${LIBS} -L$LZMA_DIR\/lib\"\n-        fi\n-        AC_CHECK_HEADERS(lzma.h,\n-            AC_CHECK_LIB(lzma, lzma_code,[\n-                WITH_LZMA=1\n-                if test \"x${LZMA_DIR}\" != \"x\"; then\n-                    LZMA_CFLAGS=\"-I${LZMA_DIR}\/include\"\n-                    LZMA_LIBS=\"-L${LZMA_DIR}\/lib -llzma\"\n-                else\n-                    LZMA_LIBS=\"-llzma\"\n-                fi])\n-                XML_PC_LIBS=\"${XML_PC_LIBS} ${LZMA_LIBS}\"\n-            )\n-        CPPFLAGS=$_cppflags\n-        LIBS=$_libs\n-    fi\n-\n-    XML_PRIVATE_CFLAGS=\"${XML_PRIVATE_CFLAGS} ${LZMA_CFLAGS}\"\n-    XML_PRIVATE_LIBS=\"${XML_PRIVATE_LIBS} ${LZMA_LIBS}\"\n-fi\n-AC_SUBST(WITH_LZMA)\n-AM_CONDITIONAL(WITH_LZMA_SOURCES, test \"$WITH_LZMA\" = \"1\")\n-\n-dnl\n-dnl Checks for iconv library.\n-dnl\n-WITH_ICONV=0\n-\n-if test \"$with_iconv\" = \"no\" ; then\n-    echo Disabling ICONV support\n-else\n-    _cppflags=$CPPFLAGS\n-    _libs=$LIBS\n-    if test \"$with_iconv\" != \"yes\" && test \"$with_iconv\" != \"\" ; then\n-\tICONV_DIR=$with_iconv\n-\tCPPFLAGS=\"$CPPFLAGS -I$ICONV_DIR\/include\"\n-\tLIBS=\"$LIBS -L$ICONV_DIR\/lib\"\n-    fi\n-    AC_MSG_CHECKING([for libiconv])\n-    AC_LINK_IFELSE([\n-        AC_LANG_PROGRAM([#include <iconv.h>], [iconv_open(0,0);])\n-    ], [\n-        WITH_ICONV=1\n-        AC_MSG_RESULT([none required])\n-    ], [\n-        LIBS=\"$LIBS -liconv\"\n-        AC_LINK_IFELSE([\n-            AC_LANG_PROGRAM([#include <iconv.h>], [iconv_open(0,0);])\n-        ], [\n-            WITH_ICONV=1\n-            ICONV_LIBS=\"-liconv\"\n-            AC_MSG_RESULT([yes])\n-        ], [\n-            AC_MSG_RESULT([no])\n-        ])\n-    ])\n-    if test \"$WITH_ICONV\" = \"1\" && test \"$ICONV_DIR\" != \"\"; then\n-        ICONV_CFLAGS=\"-I$ICONV_DIR\/include\"\n-        ICONV_LIBS=\"-L$ICONV_DIR\/lib $ICONV_LIBS\"\n-\t# Export this since our headers include iconv.h\n-\tXML_INCLUDEDIR=\"$XML_INCLUDEDIR -I$ICONV_DIR\/include\"\n-    fi\n-    CPPFLAGS=$_cppflags\n-    LIBS=$_libs\n-fi\n-AC_SUBST(WITH_ICONV)\n-AC_SUBST(ICONV_CFLAGS)\n-\n-dnl\n-dnl Checks for ICU library.\n-dnl\n-WITH_ICU=0\n-\n-if test \"$with_icu\" != \"no\" && test \"$with_icu\" != \"\" ; then\n-    echo Enabling ICU support\n-\n-    # Try pkg-config first so that static linking works.\n-    # If this succeeeds, we ignore the WITH_ICU directory.\n-    PKG_CHECK_MODULES([ICU], [icu-i18n], [\n-        WITH_ICU=1; XML_PC_REQUIRES=\"${XML_PC_REQUIRES} icu-i18n\"\n-        m4_ifdef([PKG_CHECK_VAR],\n-            [PKG_CHECK_VAR([ICU_DEFS], [icu-i18n], [DEFS])])\n-        if test \"x$ICU_DEFS\" != \"x\"; then\n-            ICU_CFLAGS=\"$ICU_CFLAGS $ICU_DEFS\"\n-        fi],[:])\n-\n-    if test \"$WITH_ICU\" = \"0\"; then\n-        ICU_CONFIG=icu-config\n-        if ${ICU_CONFIG} --cflags >\/dev\/null 2>&1\n-        then\n-            WITH_ICU=1\n-            ICU_CFLAGS=`${ICU_CONFIG} --cflags`\n-            ICU_LIBS=`${ICU_CONFIG} --ldflags`\n-            XML_PC_LIBS=\"${XML_PC_LIBS} ${ICU_LIBS}\"\n-        else\n-            _cppflags=\"${CPPFLAGS}\"\n-            _libs=\"${LIBS}\"\n-            if test \"$with_icu\" != \"yes\" ; then\n-                ICU_DIR=$with_icu\n-                CPPFLAGS=\"${CPPFLAGS} -I$ICU_DIR\/include\"\n-                LIBS=\"${LIBS} -L$ICU_DIR\/lib\"\n-            fi\n-\n-            AC_CHECK_HEADER(unicode\/ucnv.h, [\n-                AC_CHECK_LIB([icucore], [ucnv_open], [\n-                    WITH_ICU=1\n-                    ICU_LIBS=-licucore\n-                    if test \"$ICU_DIR\" != \"\"; then\n-                        ICU_CFLAGS=\"-I$ICU_DIR\/include\"\n-                        ICU_LIBS=\"-L$ICU_DIR\/lib $ICU_LIBS\"\n-                    fi])])\n-                    XML_PC_LIBS=\"${XML_PC_LIBS} ${ICU_LIBS}\"\n-            CPPFLAGS=$_cppflags\n-            LIBS=$_libs\n-        fi\n-    fi\n-\n-    XML_PRIVATE_CFLAGS=\"${XML_PRIVATE_CFLAGS} ${ICU_CFLAGS}\"\n-    XML_PRIVATE_LIBS=\"${XML_PRIVATE_LIBS} ${ICU_LIBS}\"\n-fi\n-AC_SUBST(WITH_ICU)\n-\n-dnl\n-dnl Crypto libraries\n-dnl\n-case \"$host\" in\n-    *-*-mingw*)\n-        CRYPTO_LIBS=\"-lbcrypt\"\n-        ;;\n-esac\n-\n-XML_LIBS=\"-lxml2\"\n-XML_LIBTOOLLIBS=\"libxml2.la\"\n-NON_PC_LIBS=\"${THREAD_LIBS} ${ICONV_LIBS} ${LIBM} ${NET_LIBS} ${CRYPTO_LIBS}\"\n-XML_PC_LIBS=\"${XML_PC_LIBS} ${NON_PC_LIBS}\"\n-XML_PRIVATE_LIBS=\"${XML_PRIVATE_LIBS} ${NON_PC_LIBS}\"\n-XML_PRIVATE_CFLAGS=\"${XML_PRIVATE_CFLAGS} ${ICONV_CFLAGS}\"\n-\n-dnl When static-only:\n-dnl * Duplicate xml-config static --libs into --dynamic.\n-dnl * Fold pkg-config private fields into main fields.\n-if test \"x$enable_shared\" = \"xno\"; then\n-  XML_PRIVATE_LIBS_NO_SHARED=\"${XML_PRIVATE_LIBS}\"\n-  XML_PC_PRIVATE=\n-  XML_PC_LIBS_PRIVATE=\n-else\n-  XML_PRIVATE_LIBS_NO_SHARED=\n-  XML_PC_PRIVATE=\".private\"\n-  XML_PC_LIBS_PRIVATE=\"\n-Libs.private:\"\n-fi\n-AC_SUBST(XML_PRIVATE_LIBS_NO_SHARED)\n-AC_SUBST(XML_PC_PRIVATE)\n-AC_SUBST(XML_PC_LIBS_PRIVATE)\n-AM_SUBST_NOTMAKE(XML_PRIVATE_LIBS_NO_SHARED)\n-AM_SUBST_NOTMAKE(XML_PC_PRIVATE)\n-AM_SUBST_NOTMAKE(XML_PC_LIBS_PRIVATE)\n-\n-AC_SUBST(XML_PC_LIBS)\n-AC_SUBST(XML_PC_REQUIRES)\n-AM_SUBST_NOTMAKE(XML_PC_LIBS)\n-AM_SUBST_NOTMAKE(XML_PC_REQUIRES)\n-\n-AC_SUBST(AM_CFLAGS)\n-AC_SUBST(AM_LDFLAGS)\n-AC_SUBST(XML_CFLAGS)\n-\n-AC_SUBST(XML_LIBDIR)\n-AC_SUBST(XML_LIBS)\n-AC_SUBST(XML_PRIVATE_LIBS)\n-AC_SUBST(XML_PRIVATE_CFLAGS)\n-AC_SUBST(XML_LIBTOOLLIBS)\n-AC_SUBST(XML_INCLUDEDIR)\n-\n-dnl for the spec file\n-RELDATE=`date +'%a %b %e %Y'`\n-AC_SUBST(RELDATE)\n-\n-# keep on one line for cygwin c.f. #130896\n-AC_CONFIG_FILES([Makefile include\/Makefile include\/libxml\/Makefile include\/private\/Makefile doc\/Makefile doc\/devhelp\/Makefile example\/Makefile fuzz\/Makefile python\/Makefile python\/tests\/Makefile xstc\/Makefile include\/libxml\/xmlversion.h libxml-2.0.pc libxml-2.0-uninstalled.pc libxml2-config.cmake])\n-AC_CONFIG_FILES([python\/setup.py], [chmod +x python\/setup.py])\n-AC_CONFIG_FILES([xml2-config], [chmod +x xml2-config])\n-AC_OUTPUT\n-\n-if test \"$WARN_NO_TLS\" != \"\"; then\n-    echo \"================================================================\"\n-    echo \"WARNING: Your C compiler appears to not support thread-local\"\n-    echo \"storage. Future versions of libxml2 will require this feature\"\n-    echo \"for multi-threading.\"\n-    echo \"================================================================\"\n-fi\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/configure.ac","additions":0,"deletions":1155,"binary":false,"changes":1155,"status":"deleted"},{"patch":"@@ -1,3416 +0,0 @@\n-\/*\n- * debugXML.c : This is a set of routines used for debugging the tree\n- *              produced by the XML parser.\n- *\n- * See Copyright for the status of this software.\n- *\n- * Daniel Veillard <daniel@veillard.com>\n- *\/\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-#ifdef LIBXML_DEBUG_ENABLED\n-\n-#include <string.h>\n-#include <stdlib.h>\n-\n-#include <libxml\/xmlmemory.h>\n-#include <libxml\/tree.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/debugXML.h>\n-#include <libxml\/HTMLtree.h>\n-#include <libxml\/HTMLparser.h>\n-#include <libxml\/xmlerror.h>\n-#include <libxml\/xpathInternals.h>\n-#include <libxml\/uri.h>\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-#include <libxml\/relaxng.h>\n-#endif\n-\n-#include \"private\/error.h\"\n-\n-#define DUMP_TEXT_TYPE 1\n-\n-typedef struct _xmlDebugCtxt xmlDebugCtxt;\n-typedef xmlDebugCtxt *xmlDebugCtxtPtr;\n-struct _xmlDebugCtxt {\n-    FILE *output;               \/* the output file *\/\n-    char shift[101];            \/* used for indenting *\/\n-    int depth;                  \/* current depth *\/\n-    xmlDocPtr doc;              \/* current document *\/\n-    xmlNodePtr node;        \/* current node *\/\n-    xmlDictPtr dict;        \/* the doc dictionary *\/\n-    int check;                  \/* do just checkings *\/\n-    int errors;                 \/* number of errors found *\/\n-    int nodict;            \/* if the document has no dictionary *\/\n-    int options;        \/* options *\/\n-};\n-\n-static void xmlCtxtDumpNodeList(xmlDebugCtxtPtr ctxt, xmlNodePtr node);\n-\n-static void\n-xmlCtxtDumpInitCtxt(xmlDebugCtxtPtr ctxt)\n-{\n-    int i;\n-\n-    ctxt->depth = 0;\n-    ctxt->check = 0;\n-    ctxt->errors = 0;\n-    ctxt->output = stdout;\n-    ctxt->doc = NULL;\n-    ctxt->node = NULL;\n-    ctxt->dict = NULL;\n-    ctxt->nodict = 0;\n-    ctxt->options = 0;\n-    for (i = 0; i < 100; i++)\n-        ctxt->shift[i] = ' ';\n-    ctxt->shift[100] = 0;\n-}\n-\n-static void\n-xmlCtxtDumpCleanCtxt(xmlDebugCtxtPtr ctxt ATTRIBUTE_UNUSED)\n-{\n- \/* remove the ATTRIBUTE_UNUSED when this is added *\/\n-}\n-\n-\/**\n- * xmlNsCheckScope:\n- * @node: the node\n- * @ns: the namespace node\n- *\n- * Check that a given namespace is in scope on a node.\n- *\n- * Returns 1 if in scope, -1 in case of argument error,\n- *         -2 if the namespace is not in scope, and -3 if not on\n- *         an ancestor node.\n- *\/\n-static int\n-xmlNsCheckScope(xmlNodePtr node, xmlNsPtr ns)\n-{\n-    xmlNsPtr cur;\n-\n-    if ((node == NULL) || (ns == NULL))\n-        return(-1);\n-\n-    if ((node->type != XML_ELEMENT_NODE) &&\n-    (node->type != XML_ATTRIBUTE_NODE) &&\n-    (node->type != XML_DOCUMENT_NODE) &&\n-    (node->type != XML_TEXT_NODE) &&\n-    (node->type != XML_HTML_DOCUMENT_NODE) &&\n-    (node->type != XML_XINCLUDE_START))\n-    return(-2);\n-\n-    while ((node != NULL) &&\n-           ((node->type == XML_ELEMENT_NODE) ||\n-            (node->type == XML_ATTRIBUTE_NODE) ||\n-            (node->type == XML_TEXT_NODE) ||\n-        (node->type == XML_XINCLUDE_START))) {\n-    if ((node->type == XML_ELEMENT_NODE) ||\n-        (node->type == XML_XINCLUDE_START)) {\n-        cur = node->nsDef;\n-        while (cur != NULL) {\n-            if (cur == ns)\n-            return(1);\n-        if (xmlStrEqual(cur->prefix, ns->prefix))\n-            return(-2);\n-        cur = cur->next;\n-        }\n-    }\n-    node = node->parent;\n-    }\n-    \/* the xml namespace may be declared on the document node *\/\n-    if ((node != NULL) &&\n-        ((node->type == XML_DOCUMENT_NODE) ||\n-     (node->type == XML_HTML_DOCUMENT_NODE))) {\n-     xmlNsPtr oldNs = ((xmlDocPtr) node)->oldNs;\n-     if (oldNs == ns)\n-         return(1);\n-    }\n-    return(-3);\n-}\n-\n-static void\n-xmlCtxtDumpSpaces(xmlDebugCtxtPtr ctxt)\n-{\n-    if (ctxt->check)\n-        return;\n-    if ((ctxt->output != NULL) && (ctxt->depth > 0)) {\n-        if (ctxt->depth < 50)\n-            fprintf(ctxt->output, \"%s\", &ctxt->shift[100 - 2 * ctxt->depth]);\n-        else\n-            fprintf(ctxt->output, \"%s\", ctxt->shift);\n-    }\n-}\n-\n-\/**\n- * xmlDebugErr:\n- * @ctxt:  a debug context\n- * @error:  the error code\n- *\n- * Handle a debug error.\n- *\/\n-static void\n-xmlDebugErr(xmlDebugCtxtPtr ctxt, int error, const char *msg)\n-{\n-    ctxt->errors++;\n-    fprintf(ctxt->output, \"ERROR %d: %s\", error, msg);\n-}\n-static void LIBXML_ATTR_FORMAT(3,0)\n-xmlDebugErr2(xmlDebugCtxtPtr ctxt, int error, const char *msg, int extra)\n-{\n-    ctxt->errors++;\n-    fprintf(ctxt->output, \"ERROR %d: \", error);\n-    fprintf(ctxt->output, msg, extra);\n-}\n-static void LIBXML_ATTR_FORMAT(3,0)\n-xmlDebugErr3(xmlDebugCtxtPtr ctxt, int error, const char *msg, const char *extra)\n-{\n-    ctxt->errors++;\n-    fprintf(ctxt->output, \"ERROR %d: \", error);\n-    fprintf(ctxt->output, msg, extra);\n-}\n-\n-\/**\n- * xmlCtxtNsCheckScope:\n- * @ctxt: the debugging context\n- * @node: the node\n- * @ns: the namespace node\n- *\n- * Report if a given namespace is is not in scope.\n- *\/\n-static void\n-xmlCtxtNsCheckScope(xmlDebugCtxtPtr ctxt, xmlNodePtr node, xmlNsPtr ns)\n-{\n-    int ret;\n-\n-    ret = xmlNsCheckScope(node, ns);\n-    if (ret == -2) {\n-        if (ns->prefix == NULL)\n-        xmlDebugErr(ctxt, XML_CHECK_NS_SCOPE,\n-            \"Reference to default namespace not in scope\\n\");\n-    else\n-        xmlDebugErr3(ctxt, XML_CHECK_NS_SCOPE,\n-             \"Reference to namespace '%s' not in scope\\n\",\n-             (char *) ns->prefix);\n-    }\n-    if (ret == -3) {\n-        if (ns->prefix == NULL)\n-        xmlDebugErr(ctxt, XML_CHECK_NS_ANCESTOR,\n-            \"Reference to default namespace not on ancestor\\n\");\n-    else\n-        xmlDebugErr3(ctxt, XML_CHECK_NS_ANCESTOR,\n-             \"Reference to namespace '%s' not on ancestor\\n\",\n-             (char *) ns->prefix);\n-    }\n-}\n-\n-\/**\n- * xmlCtxtCheckString:\n- * @ctxt: the debug context\n- * @str: the string\n- *\n- * Do debugging on the string, currently it just checks the UTF-8 content\n- *\/\n-static void\n-xmlCtxtCheckString(xmlDebugCtxtPtr ctxt, const xmlChar * str)\n-{\n-    if (str == NULL) return;\n-    if (ctxt->check) {\n-        if (!xmlCheckUTF8(str)) {\n-        xmlDebugErr3(ctxt, XML_CHECK_NOT_UTF8,\n-             \"String is not UTF-8 %s\", (const char *) str);\n-    }\n-    }\n-}\n-\n-\/**\n- * xmlCtxtCheckName:\n- * @ctxt: the debug context\n- * @name: the name\n- *\n- * Do debugging on the name, for example the dictionary status and\n- * conformance to the Name production.\n- *\/\n-static void\n-xmlCtxtCheckName(xmlDebugCtxtPtr ctxt, const xmlChar * name)\n-{\n-    if (ctxt->check) {\n-    if (name == NULL) {\n-        xmlDebugErr(ctxt, XML_CHECK_NO_NAME, \"Name is NULL\");\n-        return;\n-    }\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n-        if (xmlValidateName(name, 0)) {\n-        xmlDebugErr3(ctxt, XML_CHECK_NOT_NCNAME,\n-             \"Name is not an NCName '%s'\", (const char *) name);\n-    }\n-#endif\n-    if ((ctxt->dict != NULL) &&\n-        (!xmlDictOwns(ctxt->dict, name)) &&\n-            ((ctxt->doc == NULL) ||\n-             ((ctxt->doc->parseFlags & (XML_PARSE_SAX1 | XML_PARSE_NODICT)) == 0))) {\n-        xmlDebugErr3(ctxt, XML_CHECK_OUTSIDE_DICT,\n-             \"Name is not from the document dictionary '%s'\",\n-             (const char *) name);\n-    }\n-    }\n-}\n-\n-static void\n-xmlCtxtGenericNodeCheck(xmlDebugCtxtPtr ctxt, xmlNodePtr node) {\n-    xmlDocPtr doc;\n-    xmlDictPtr dict;\n-\n-    doc = node->doc;\n-\n-    if (node->parent == NULL)\n-        xmlDebugErr(ctxt, XML_CHECK_NO_PARENT,\n-                \"Node has no parent\\n\");\n-    if (node->doc == NULL) {\n-        xmlDebugErr(ctxt, XML_CHECK_NO_DOC,\n-                \"Node has no doc\\n\");\n-        dict = NULL;\n-    } else {\n-    dict = doc->dict;\n-    if ((dict == NULL) && (ctxt->nodict == 0)) {\n-#if 0\n-            \/* deactivated right now as it raises too many errors *\/\n-        if (doc->type == XML_DOCUMENT_NODE)\n-        xmlDebugErr(ctxt, XML_CHECK_NO_DICT,\n-                \"Document has no dictionary\\n\");\n-#endif\n-        ctxt->nodict = 1;\n-    }\n-    if (ctxt->doc == NULL)\n-        ctxt->doc = doc;\n-\n-    if (ctxt->dict == NULL) {\n-        ctxt->dict = dict;\n-    }\n-    }\n-    if ((node->parent != NULL) && (node->doc != node->parent->doc) &&\n-        (!xmlStrEqual(node->name, BAD_CAST \"pseudoroot\")))\n-        xmlDebugErr(ctxt, XML_CHECK_WRONG_DOC,\n-                \"Node doc differs from parent's one\\n\");\n-    if (node->prev == NULL) {\n-        if (node->type == XML_ATTRIBUTE_NODE) {\n-        if ((node->parent != NULL) &&\n-            (node != (xmlNodePtr) node->parent->properties))\n-        xmlDebugErr(ctxt, XML_CHECK_NO_PREV,\n-                    \"Attr has no prev and not first of attr list\\n\");\n-\n-        } else if ((node->parent != NULL) && (node->parent->children != node))\n-        xmlDebugErr(ctxt, XML_CHECK_NO_PREV,\n-                    \"Node has no prev and not first of parent list\\n\");\n-    } else {\n-        if (node->prev->next != node)\n-        xmlDebugErr(ctxt, XML_CHECK_WRONG_PREV,\n-                        \"Node prev->next : back link wrong\\n\");\n-    }\n-    if (node->next == NULL) {\n-    if ((node->parent != NULL) && (node->type != XML_ATTRIBUTE_NODE) &&\n-        (node->parent->last != node) &&\n-        (node->parent->type == XML_ELEMENT_NODE))\n-        xmlDebugErr(ctxt, XML_CHECK_NO_NEXT,\n-                    \"Node has no next and not last of parent list\\n\");\n-    } else {\n-        if (node->next->prev != node)\n-        xmlDebugErr(ctxt, XML_CHECK_WRONG_NEXT,\n-                    \"Node next->prev : forward link wrong\\n\");\n-        if (node->next->parent != node->parent)\n-        xmlDebugErr(ctxt, XML_CHECK_WRONG_PARENT,\n-                    \"Node next->prev : forward link wrong\\n\");\n-    }\n-    if (node->type == XML_ELEMENT_NODE) {\n-        xmlNsPtr ns;\n-\n-    ns = node->nsDef;\n-    while (ns != NULL) {\n-        xmlCtxtNsCheckScope(ctxt, node, ns);\n-        ns = ns->next;\n-    }\n-    if (node->ns != NULL)\n-        xmlCtxtNsCheckScope(ctxt, node, node->ns);\n-    } else if (node->type == XML_ATTRIBUTE_NODE) {\n-    if (node->ns != NULL)\n-        xmlCtxtNsCheckScope(ctxt, node, node->ns);\n-    }\n-\n-    if ((node->type != XML_ELEMENT_NODE) &&\n-    (node->type != XML_ATTRIBUTE_NODE) &&\n-    (node->type != XML_ELEMENT_DECL) &&\n-    (node->type != XML_ATTRIBUTE_DECL) &&\n-    (node->type != XML_DTD_NODE) &&\n-    (node->type != XML_HTML_DOCUMENT_NODE) &&\n-    (node->type != XML_DOCUMENT_NODE)) {\n-    if (node->content != NULL)\n-        xmlCtxtCheckString(ctxt, (const xmlChar *) node->content);\n-    }\n-    switch (node->type) {\n-        case XML_ELEMENT_NODE:\n-        case XML_ATTRIBUTE_NODE:\n-        xmlCtxtCheckName(ctxt, node->name);\n-        break;\n-        case XML_TEXT_NODE:\n-        if ((node->name == xmlStringText) ||\n-            (node->name == xmlStringTextNoenc))\n-        break;\n-        \/* some case of entity substitution can lead to this *\/\n-        if ((ctxt->dict != NULL) &&\n-            (node->name == xmlDictLookup(ctxt->dict, BAD_CAST \"nbktext\",\n-                                     7)))\n-        break;\n-\n-        xmlDebugErr3(ctxt, XML_CHECK_WRONG_NAME,\n-             \"Text node has wrong name '%s'\",\n-             (const char *) node->name);\n-        break;\n-        case XML_COMMENT_NODE:\n-        if (node->name == xmlStringComment)\n-        break;\n-        xmlDebugErr3(ctxt, XML_CHECK_WRONG_NAME,\n-             \"Comment node has wrong name '%s'\",\n-             (const char *) node->name);\n-        break;\n-        case XML_PI_NODE:\n-        xmlCtxtCheckName(ctxt, node->name);\n-        break;\n-        case XML_CDATA_SECTION_NODE:\n-        if (node->name == NULL)\n-        break;\n-        xmlDebugErr3(ctxt, XML_CHECK_NAME_NOT_NULL,\n-             \"CData section has non NULL name '%s'\",\n-             (const char *) node->name);\n-        break;\n-        case XML_ENTITY_REF_NODE:\n-        case XML_ENTITY_NODE:\n-        case XML_DOCUMENT_TYPE_NODE:\n-        case XML_DOCUMENT_FRAG_NODE:\n-        case XML_NOTATION_NODE:\n-        case XML_DTD_NODE:\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_ENTITY_DECL:\n-        case XML_NAMESPACE_DECL:\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        case XML_DOCUMENT_NODE:\n-        case XML_HTML_DOCUMENT_NODE:\n-        break;\n-    }\n-}\n-\n-static void\n-xmlCtxtDumpString(xmlDebugCtxtPtr ctxt, const xmlChar * str)\n-{\n-    int i;\n-\n-    if (ctxt->check) {\n-        return;\n-    }\n-    \/* TODO: check UTF8 content of the string *\/\n-    if (str == NULL) {\n-        fprintf(ctxt->output, \"(NULL)\");\n-        return;\n-    }\n-    for (i = 0; i < 40; i++)\n-        if (str[i] == 0)\n-            return;\n-        else if (IS_BLANK_CH(str[i]))\n-            fputc(' ', ctxt->output);\n-        else if (str[i] >= 0x80)\n-            fprintf(ctxt->output, \"#%X\", str[i]);\n-        else\n-            fputc(str[i], ctxt->output);\n-    fprintf(ctxt->output, \"...\");\n-}\n-\n-static void\n-xmlCtxtDumpDtdNode(xmlDebugCtxtPtr ctxt, xmlDtdPtr dtd)\n-{\n-    xmlCtxtDumpSpaces(ctxt);\n-\n-    if (dtd == NULL) {\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \"DTD node is NULL\\n\");\n-        return;\n-    }\n-\n-    if (dtd->type != XML_DTD_NODE) {\n-    xmlDebugErr(ctxt, XML_CHECK_NOT_DTD,\n-                \"Node is not a DTD\");\n-        return;\n-    }\n-    if (!ctxt->check) {\n-        if (dtd->name != NULL)\n-            fprintf(ctxt->output, \"DTD(%s)\", (char *) dtd->name);\n-        else\n-            fprintf(ctxt->output, \"DTD\");\n-        if (dtd->ExternalID != NULL)\n-            fprintf(ctxt->output, \", PUBLIC %s\", (char *) dtd->ExternalID);\n-        if (dtd->SystemID != NULL)\n-            fprintf(ctxt->output, \", SYSTEM %s\", (char *) dtd->SystemID);\n-        fprintf(ctxt->output, \"\\n\");\n-    }\n-    \/*\n-     * Do a bit of checking\n-     *\/\n-    xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) dtd);\n-}\n-\n-static void\n-xmlCtxtDumpAttrDecl(xmlDebugCtxtPtr ctxt, xmlAttributePtr attr)\n-{\n-    xmlCtxtDumpSpaces(ctxt);\n-\n-    if (attr == NULL) {\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \"Attribute declaration is NULL\\n\");\n-        return;\n-    }\n-    if (attr->type != XML_ATTRIBUTE_DECL) {\n-    xmlDebugErr(ctxt, XML_CHECK_NOT_ATTR_DECL,\n-                \"Node is not an attribute declaration\");\n-        return;\n-    }\n-    if (attr->name != NULL) {\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \"ATTRDECL(%s)\", (char *) attr->name);\n-    } else\n-    xmlDebugErr(ctxt, XML_CHECK_NO_NAME,\n-                \"Node attribute declaration has no name\");\n-    if (attr->elem != NULL) {\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \" for %s\", (char *) attr->elem);\n-    } else\n-    xmlDebugErr(ctxt, XML_CHECK_NO_ELEM,\n-                \"Node attribute declaration has no element name\");\n-    if (!ctxt->check) {\n-        switch (attr->atype) {\n-            case XML_ATTRIBUTE_CDATA:\n-                fprintf(ctxt->output, \" CDATA\");\n-                break;\n-            case XML_ATTRIBUTE_ID:\n-                fprintf(ctxt->output, \" ID\");\n-                break;\n-            case XML_ATTRIBUTE_IDREF:\n-                fprintf(ctxt->output, \" IDREF\");\n-                break;\n-            case XML_ATTRIBUTE_IDREFS:\n-                fprintf(ctxt->output, \" IDREFS\");\n-                break;\n-            case XML_ATTRIBUTE_ENTITY:\n-                fprintf(ctxt->output, \" ENTITY\");\n-                break;\n-            case XML_ATTRIBUTE_ENTITIES:\n-                fprintf(ctxt->output, \" ENTITIES\");\n-                break;\n-            case XML_ATTRIBUTE_NMTOKEN:\n-                fprintf(ctxt->output, \" NMTOKEN\");\n-                break;\n-            case XML_ATTRIBUTE_NMTOKENS:\n-                fprintf(ctxt->output, \" NMTOKENS\");\n-                break;\n-            case XML_ATTRIBUTE_ENUMERATION:\n-                fprintf(ctxt->output, \" ENUMERATION\");\n-                break;\n-            case XML_ATTRIBUTE_NOTATION:\n-                fprintf(ctxt->output, \" NOTATION \");\n-                break;\n-        }\n-        if (attr->tree != NULL) {\n-            int indx;\n-            xmlEnumerationPtr cur = attr->tree;\n-\n-            for (indx = 0; indx < 5; indx++) {\n-                if (indx != 0)\n-                    fprintf(ctxt->output, \"|%s\", (char *) cur->name);\n-                else\n-                    fprintf(ctxt->output, \" (%s\", (char *) cur->name);\n-                cur = cur->next;\n-                if (cur == NULL)\n-                    break;\n-            }\n-            if (cur == NULL)\n-                fprintf(ctxt->output, \")\");\n-            else\n-                fprintf(ctxt->output, \"...)\");\n-        }\n-        switch (attr->def) {\n-            case XML_ATTRIBUTE_NONE:\n-                break;\n-            case XML_ATTRIBUTE_REQUIRED:\n-                fprintf(ctxt->output, \" REQUIRED\");\n-                break;\n-            case XML_ATTRIBUTE_IMPLIED:\n-                fprintf(ctxt->output, \" IMPLIED\");\n-                break;\n-            case XML_ATTRIBUTE_FIXED:\n-                fprintf(ctxt->output, \" FIXED\");\n-                break;\n-        }\n-        if (attr->defaultValue != NULL) {\n-            fprintf(ctxt->output, \"\\\"\");\n-            xmlCtxtDumpString(ctxt, attr->defaultValue);\n-            fprintf(ctxt->output, \"\\\"\");\n-        }\n-        fprintf(ctxt->output, \"\\n\");\n-    }\n-\n-    \/*\n-     * Do a bit of checking\n-     *\/\n-    xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) attr);\n-}\n-\n-static void\n-xmlCtxtDumpElemDecl(xmlDebugCtxtPtr ctxt, xmlElementPtr elem)\n-{\n-    xmlCtxtDumpSpaces(ctxt);\n-\n-    if (elem == NULL) {\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \"Element declaration is NULL\\n\");\n-        return;\n-    }\n-    if (elem->type != XML_ELEMENT_DECL) {\n-    xmlDebugErr(ctxt, XML_CHECK_NOT_ELEM_DECL,\n-                \"Node is not an element declaration\");\n-        return;\n-    }\n-    if (elem->name != NULL) {\n-        if (!ctxt->check) {\n-            fprintf(ctxt->output, \"ELEMDECL(\");\n-            xmlCtxtDumpString(ctxt, elem->name);\n-            fprintf(ctxt->output, \")\");\n-        }\n-    } else\n-    xmlDebugErr(ctxt, XML_CHECK_NO_NAME,\n-                \"Element declaration has no name\");\n-    if (!ctxt->check) {\n-        switch (elem->etype) {\n-            case XML_ELEMENT_TYPE_UNDEFINED:\n-                fprintf(ctxt->output, \", UNDEFINED\");\n-                break;\n-            case XML_ELEMENT_TYPE_EMPTY:\n-                fprintf(ctxt->output, \", EMPTY\");\n-                break;\n-            case XML_ELEMENT_TYPE_ANY:\n-                fprintf(ctxt->output, \", ANY\");\n-                break;\n-            case XML_ELEMENT_TYPE_MIXED:\n-                fprintf(ctxt->output, \", MIXED \");\n-                break;\n-            case XML_ELEMENT_TYPE_ELEMENT:\n-                fprintf(ctxt->output, \", MIXED \");\n-                break;\n-        }\n-        if ((elem->type != XML_ELEMENT_NODE) && (elem->content != NULL)) {\n-            char buf[5001];\n-\n-            buf[0] = 0;\n-            xmlSnprintfElementContent(buf, 5000, elem->content, 1);\n-            buf[5000] = 0;\n-            fprintf(ctxt->output, \"%s\", buf);\n-        }\n-        fprintf(ctxt->output, \"\\n\");\n-    }\n-\n-    \/*\n-     * Do a bit of checking\n-     *\/\n-    xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) elem);\n-}\n-\n-static void\n-xmlCtxtDumpEntityDecl(xmlDebugCtxtPtr ctxt, xmlEntityPtr ent)\n-{\n-    xmlCtxtDumpSpaces(ctxt);\n-\n-    if (ent == NULL) {\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \"Entity declaration is NULL\\n\");\n-        return;\n-    }\n-    if (ent->type != XML_ENTITY_DECL) {\n-    xmlDebugErr(ctxt, XML_CHECK_NOT_ENTITY_DECL,\n-                \"Node is not an entity declaration\");\n-        return;\n-    }\n-    if (ent->name != NULL) {\n-        if (!ctxt->check) {\n-            fprintf(ctxt->output, \"ENTITYDECL(\");\n-            xmlCtxtDumpString(ctxt, ent->name);\n-            fprintf(ctxt->output, \")\");\n-        }\n-    } else\n-    xmlDebugErr(ctxt, XML_CHECK_NO_NAME,\n-                \"Entity declaration has no name\");\n-    if (!ctxt->check) {\n-        switch (ent->etype) {\n-            case XML_INTERNAL_GENERAL_ENTITY:\n-                fprintf(ctxt->output, \", internal\\n\");\n-                break;\n-            case XML_EXTERNAL_GENERAL_PARSED_ENTITY:\n-                fprintf(ctxt->output, \", external parsed\\n\");\n-                break;\n-            case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:\n-                fprintf(ctxt->output, \", unparsed\\n\");\n-                break;\n-            case XML_INTERNAL_PARAMETER_ENTITY:\n-                fprintf(ctxt->output, \", parameter\\n\");\n-                break;\n-            case XML_EXTERNAL_PARAMETER_ENTITY:\n-                fprintf(ctxt->output, \", external parameter\\n\");\n-                break;\n-            case XML_INTERNAL_PREDEFINED_ENTITY:\n-                fprintf(ctxt->output, \", predefined\\n\");\n-                break;\n-        }\n-        if (ent->ExternalID) {\n-            xmlCtxtDumpSpaces(ctxt);\n-            fprintf(ctxt->output, \" ExternalID=%s\\n\",\n-                    (char *) ent->ExternalID);\n-        }\n-        if (ent->SystemID) {\n-            xmlCtxtDumpSpaces(ctxt);\n-            fprintf(ctxt->output, \" SystemID=%s\\n\",\n-                    (char *) ent->SystemID);\n-        }\n-        if (ent->URI != NULL) {\n-            xmlCtxtDumpSpaces(ctxt);\n-            fprintf(ctxt->output, \" URI=%s\\n\", (char *) ent->URI);\n-        }\n-        if (ent->content) {\n-            xmlCtxtDumpSpaces(ctxt);\n-            fprintf(ctxt->output, \" content=\");\n-            xmlCtxtDumpString(ctxt, ent->content);\n-            fprintf(ctxt->output, \"\\n\");\n-        }\n-    }\n-\n-    \/*\n-     * Do a bit of checking\n-     *\/\n-    xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) ent);\n-}\n-\n-static void\n-xmlCtxtDumpNamespace(xmlDebugCtxtPtr ctxt, xmlNsPtr ns)\n-{\n-    xmlCtxtDumpSpaces(ctxt);\n-\n-    if (ns == NULL) {\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \"namespace node is NULL\\n\");\n-        return;\n-    }\n-    if (ns->type != XML_NAMESPACE_DECL) {\n-    xmlDebugErr(ctxt, XML_CHECK_NOT_NS_DECL,\n-                \"Node is not a namespace declaration\");\n-        return;\n-    }\n-    if (ns->href == NULL) {\n-        if (ns->prefix != NULL)\n-        xmlDebugErr3(ctxt, XML_CHECK_NO_HREF,\n-                    \"Incomplete namespace %s href=NULL\\n\",\n-                    (char *) ns->prefix);\n-        else\n-        xmlDebugErr(ctxt, XML_CHECK_NO_HREF,\n-                    \"Incomplete default namespace href=NULL\\n\");\n-    } else {\n-        if (!ctxt->check) {\n-            if (ns->prefix != NULL)\n-                fprintf(ctxt->output, \"namespace %s href=\",\n-                        (char *) ns->prefix);\n-            else\n-                fprintf(ctxt->output, \"default namespace href=\");\n-\n-            xmlCtxtDumpString(ctxt, ns->href);\n-            fprintf(ctxt->output, \"\\n\");\n-        }\n-    }\n-}\n-\n-static void\n-xmlCtxtDumpNamespaceList(xmlDebugCtxtPtr ctxt, xmlNsPtr ns)\n-{\n-    while (ns != NULL) {\n-        xmlCtxtDumpNamespace(ctxt, ns);\n-        ns = ns->next;\n-    }\n-}\n-\n-static void\n-xmlCtxtDumpEntity(xmlDebugCtxtPtr ctxt, xmlEntityPtr ent)\n-{\n-    xmlCtxtDumpSpaces(ctxt);\n-\n-    if (ent == NULL) {\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \"Entity is NULL\\n\");\n-        return;\n-    }\n-    if (!ctxt->check) {\n-        switch (ent->etype) {\n-            case XML_INTERNAL_GENERAL_ENTITY:\n-                fprintf(ctxt->output, \"INTERNAL_GENERAL_ENTITY \");\n-                break;\n-            case XML_EXTERNAL_GENERAL_PARSED_ENTITY:\n-                fprintf(ctxt->output, \"EXTERNAL_GENERAL_PARSED_ENTITY \");\n-                break;\n-            case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:\n-                fprintf(ctxt->output, \"EXTERNAL_GENERAL_UNPARSED_ENTITY \");\n-                break;\n-            case XML_INTERNAL_PARAMETER_ENTITY:\n-                fprintf(ctxt->output, \"INTERNAL_PARAMETER_ENTITY \");\n-                break;\n-            case XML_EXTERNAL_PARAMETER_ENTITY:\n-                fprintf(ctxt->output, \"EXTERNAL_PARAMETER_ENTITY \");\n-                break;\n-            default:\n-                fprintf(ctxt->output, \"ENTITY_%d ! \", (int) ent->etype);\n-        }\n-        fprintf(ctxt->output, \"%s\\n\", ent->name);\n-        if (ent->ExternalID) {\n-            xmlCtxtDumpSpaces(ctxt);\n-            fprintf(ctxt->output, \"ExternalID=%s\\n\",\n-                    (char *) ent->ExternalID);\n-        }\n-        if (ent->SystemID) {\n-            xmlCtxtDumpSpaces(ctxt);\n-            fprintf(ctxt->output, \"SystemID=%s\\n\", (char *) ent->SystemID);\n-        }\n-        if (ent->URI) {\n-            xmlCtxtDumpSpaces(ctxt);\n-            fprintf(ctxt->output, \"URI=%s\\n\", (char *) ent->URI);\n-        }\n-        if (ent->content) {\n-            xmlCtxtDumpSpaces(ctxt);\n-            fprintf(ctxt->output, \"content=\");\n-            xmlCtxtDumpString(ctxt, ent->content);\n-            fprintf(ctxt->output, \"\\n\");\n-        }\n-    }\n-}\n-\n-\/**\n- * xmlCtxtDumpAttr:\n- * @output:  the FILE * for the output\n- * @attr:  the attribute\n- * @depth:  the indentation level.\n- *\n- * Dumps debug information for the attribute\n- *\/\n-static void\n-xmlCtxtDumpAttr(xmlDebugCtxtPtr ctxt, xmlAttrPtr attr)\n-{\n-    xmlCtxtDumpSpaces(ctxt);\n-\n-    if (attr == NULL) {\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \"Attr is NULL\");\n-        return;\n-    }\n-    if (!ctxt->check) {\n-        fprintf(ctxt->output, \"ATTRIBUTE \");\n-    xmlCtxtDumpString(ctxt, attr->name);\n-        fprintf(ctxt->output, \"\\n\");\n-        if (attr->children != NULL) {\n-            ctxt->depth++;\n-            xmlCtxtDumpNodeList(ctxt, attr->children);\n-            ctxt->depth--;\n-        }\n-    }\n-    if (attr->name == NULL)\n-    xmlDebugErr(ctxt, XML_CHECK_NO_NAME,\n-                \"Attribute has no name\");\n-\n-    \/*\n-     * Do a bit of checking\n-     *\/\n-    xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) attr);\n-}\n-\n-\/**\n- * xmlCtxtDumpAttrList:\n- * @output:  the FILE * for the output\n- * @attr:  the attribute list\n- * @depth:  the indentation level.\n- *\n- * Dumps debug information for the attribute list\n- *\/\n-static void\n-xmlCtxtDumpAttrList(xmlDebugCtxtPtr ctxt, xmlAttrPtr attr)\n-{\n-    while (attr != NULL) {\n-        xmlCtxtDumpAttr(ctxt, attr);\n-        attr = attr->next;\n-    }\n-}\n-\n-\/**\n- * xmlCtxtDumpOneNode:\n- * @output:  the FILE * for the output\n- * @node:  the node\n- * @depth:  the indentation level.\n- *\n- * Dumps debug information for the element node, it is not recursive\n- *\/\n-static void\n-xmlCtxtDumpOneNode(xmlDebugCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    if (node == NULL) {\n-        if (!ctxt->check) {\n-            xmlCtxtDumpSpaces(ctxt);\n-            fprintf(ctxt->output, \"node is NULL\\n\");\n-        }\n-        return;\n-    }\n-    ctxt->node = node;\n-\n-    switch (node->type) {\n-        case XML_ELEMENT_NODE:\n-            if (!ctxt->check) {\n-                xmlCtxtDumpSpaces(ctxt);\n-                fprintf(ctxt->output, \"ELEMENT \");\n-                if ((node->ns != NULL) && (node->ns->prefix != NULL)) {\n-                    xmlCtxtDumpString(ctxt, node->ns->prefix);\n-                    fprintf(ctxt->output, \":\");\n-                }\n-                xmlCtxtDumpString(ctxt, node->name);\n-                fprintf(ctxt->output, \"\\n\");\n-            }\n-            break;\n-        case XML_ATTRIBUTE_NODE:\n-            if (!ctxt->check)\n-                xmlCtxtDumpSpaces(ctxt);\n-            fprintf(ctxt->output, \"Error, ATTRIBUTE found here\\n\");\n-            xmlCtxtGenericNodeCheck(ctxt, node);\n-            return;\n-        case XML_TEXT_NODE:\n-            if (!ctxt->check) {\n-                xmlCtxtDumpSpaces(ctxt);\n-                if (node->name == (const xmlChar *) xmlStringTextNoenc)\n-                    fprintf(ctxt->output, \"TEXT no enc\");\n-                else\n-                    fprintf(ctxt->output, \"TEXT\");\n-        if (ctxt->options & DUMP_TEXT_TYPE) {\n-            if (node->content == (xmlChar *) &(node->properties))\n-            fprintf(ctxt->output, \" compact\\n\");\n-            else if (xmlDictOwns(ctxt->dict, node->content) == 1)\n-            fprintf(ctxt->output, \" interned\\n\");\n-            else\n-            fprintf(ctxt->output, \"\\n\");\n-        } else\n-            fprintf(ctxt->output, \"\\n\");\n-            }\n-            break;\n-        case XML_CDATA_SECTION_NODE:\n-            if (!ctxt->check) {\n-                xmlCtxtDumpSpaces(ctxt);\n-                fprintf(ctxt->output, \"CDATA_SECTION\\n\");\n-            }\n-            break;\n-        case XML_ENTITY_REF_NODE:\n-            if (!ctxt->check) {\n-                xmlCtxtDumpSpaces(ctxt);\n-                fprintf(ctxt->output, \"ENTITY_REF(%s)\\n\",\n-                        (char *) node->name);\n-            }\n-            break;\n-        case XML_ENTITY_NODE:\n-            if (!ctxt->check) {\n-                xmlCtxtDumpSpaces(ctxt);\n-                fprintf(ctxt->output, \"ENTITY\\n\");\n-            }\n-            break;\n-        case XML_PI_NODE:\n-            if (!ctxt->check) {\n-                xmlCtxtDumpSpaces(ctxt);\n-                fprintf(ctxt->output, \"PI %s\\n\", (char *) node->name);\n-            }\n-            break;\n-        case XML_COMMENT_NODE:\n-            if (!ctxt->check) {\n-                xmlCtxtDumpSpaces(ctxt);\n-                fprintf(ctxt->output, \"COMMENT\\n\");\n-            }\n-            break;\n-        case XML_DOCUMENT_NODE:\n-        case XML_HTML_DOCUMENT_NODE:\n-            if (!ctxt->check) {\n-                xmlCtxtDumpSpaces(ctxt);\n-            }\n-            fprintf(ctxt->output, \"Error, DOCUMENT found here\\n\");\n-            xmlCtxtGenericNodeCheck(ctxt, node);\n-            return;\n-        case XML_DOCUMENT_TYPE_NODE:\n-            if (!ctxt->check) {\n-                xmlCtxtDumpSpaces(ctxt);\n-                fprintf(ctxt->output, \"DOCUMENT_TYPE\\n\");\n-            }\n-            break;\n-        case XML_DOCUMENT_FRAG_NODE:\n-            if (!ctxt->check) {\n-                xmlCtxtDumpSpaces(ctxt);\n-                fprintf(ctxt->output, \"DOCUMENT_FRAG\\n\");\n-            }\n-            break;\n-        case XML_NOTATION_NODE:\n-            if (!ctxt->check) {\n-                xmlCtxtDumpSpaces(ctxt);\n-                fprintf(ctxt->output, \"NOTATION\\n\");\n-            }\n-            break;\n-        case XML_DTD_NODE:\n-            xmlCtxtDumpDtdNode(ctxt, (xmlDtdPtr) node);\n-            return;\n-        case XML_ELEMENT_DECL:\n-            xmlCtxtDumpElemDecl(ctxt, (xmlElementPtr) node);\n-            return;\n-        case XML_ATTRIBUTE_DECL:\n-            xmlCtxtDumpAttrDecl(ctxt, (xmlAttributePtr) node);\n-            return;\n-        case XML_ENTITY_DECL:\n-            xmlCtxtDumpEntityDecl(ctxt, (xmlEntityPtr) node);\n-            return;\n-        case XML_NAMESPACE_DECL:\n-            xmlCtxtDumpNamespace(ctxt, (xmlNsPtr) node);\n-            return;\n-        case XML_XINCLUDE_START:\n-            if (!ctxt->check) {\n-                xmlCtxtDumpSpaces(ctxt);\n-                fprintf(ctxt->output, \"INCLUDE START\\n\");\n-            }\n-            return;\n-        case XML_XINCLUDE_END:\n-            if (!ctxt->check) {\n-                xmlCtxtDumpSpaces(ctxt);\n-                fprintf(ctxt->output, \"INCLUDE END\\n\");\n-            }\n-            return;\n-        default:\n-            if (!ctxt->check)\n-                xmlCtxtDumpSpaces(ctxt);\n-        xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,\n-                    \"Unknown node type %d\\n\", node->type);\n-            return;\n-    }\n-    if (node->doc == NULL) {\n-        if (!ctxt->check) {\n-            xmlCtxtDumpSpaces(ctxt);\n-        }\n-        fprintf(ctxt->output, \"PBM: doc == NULL !!!\\n\");\n-    }\n-    ctxt->depth++;\n-    if ((node->type == XML_ELEMENT_NODE) && (node->nsDef != NULL))\n-        xmlCtxtDumpNamespaceList(ctxt, node->nsDef);\n-    if ((node->type == XML_ELEMENT_NODE) && (node->properties != NULL))\n-        xmlCtxtDumpAttrList(ctxt, node->properties);\n-    if (node->type != XML_ENTITY_REF_NODE) {\n-        if ((node->type != XML_ELEMENT_NODE) && (node->content != NULL)) {\n-            if (!ctxt->check) {\n-                xmlCtxtDumpSpaces(ctxt);\n-                fprintf(ctxt->output, \"content=\");\n-                xmlCtxtDumpString(ctxt, node->content);\n-                fprintf(ctxt->output, \"\\n\");\n-            }\n-        }\n-    } else {\n-        xmlEntityPtr ent;\n-\n-        ent = xmlGetDocEntity(node->doc, node->name);\n-        if (ent != NULL)\n-            xmlCtxtDumpEntity(ctxt, ent);\n-    }\n-    ctxt->depth--;\n-\n-    \/*\n-     * Do a bit of checking\n-     *\/\n-    xmlCtxtGenericNodeCheck(ctxt, node);\n-}\n-\n-\/**\n- * xmlCtxtDumpNode:\n- * @output:  the FILE * for the output\n- * @node:  the node\n- * @depth:  the indentation level.\n- *\n- * Dumps debug information for the element node, it is recursive\n- *\/\n-static void\n-xmlCtxtDumpNode(xmlDebugCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    if (node == NULL) {\n-        if (!ctxt->check) {\n-            xmlCtxtDumpSpaces(ctxt);\n-            fprintf(ctxt->output, \"node is NULL\\n\");\n-        }\n-        return;\n-    }\n-    xmlCtxtDumpOneNode(ctxt, node);\n-    if ((node->type != XML_NAMESPACE_DECL) &&\n-        (node->children != NULL) && (node->type != XML_ENTITY_REF_NODE)) {\n-        ctxt->depth++;\n-        xmlCtxtDumpNodeList(ctxt, node->children);\n-        ctxt->depth--;\n-    }\n-}\n-\n-\/**\n- * xmlCtxtDumpNodeList:\n- * @output:  the FILE * for the output\n- * @node:  the node list\n- * @depth:  the indentation level.\n- *\n- * Dumps debug information for the list of element node, it is recursive\n- *\/\n-static void\n-xmlCtxtDumpNodeList(xmlDebugCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    while (node != NULL) {\n-        xmlCtxtDumpNode(ctxt, node);\n-        node = node->next;\n-    }\n-}\n-\n-static void\n-xmlCtxtDumpDocHead(xmlDebugCtxtPtr ctxt, xmlDocPtr doc)\n-{\n-    if (doc == NULL) {\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \"DOCUMENT == NULL !\\n\");\n-        return;\n-    }\n-    ctxt->node = (xmlNodePtr) doc;\n-\n-    switch (doc->type) {\n-        case XML_ELEMENT_NODE:\n-        xmlDebugErr(ctxt, XML_CHECK_FOUND_ELEMENT,\n-                    \"Misplaced ELEMENT node\\n\");\n-            break;\n-        case XML_ATTRIBUTE_NODE:\n-        xmlDebugErr(ctxt, XML_CHECK_FOUND_ATTRIBUTE,\n-                    \"Misplaced ATTRIBUTE node\\n\");\n-            break;\n-        case XML_TEXT_NODE:\n-        xmlDebugErr(ctxt, XML_CHECK_FOUND_TEXT,\n-                    \"Misplaced TEXT node\\n\");\n-            break;\n-        case XML_CDATA_SECTION_NODE:\n-        xmlDebugErr(ctxt, XML_CHECK_FOUND_CDATA,\n-                    \"Misplaced CDATA node\\n\");\n-            break;\n-        case XML_ENTITY_REF_NODE:\n-        xmlDebugErr(ctxt, XML_CHECK_FOUND_ENTITYREF,\n-                    \"Misplaced ENTITYREF node\\n\");\n-            break;\n-        case XML_ENTITY_NODE:\n-        xmlDebugErr(ctxt, XML_CHECK_FOUND_ENTITY,\n-                    \"Misplaced ENTITY node\\n\");\n-            break;\n-        case XML_PI_NODE:\n-        xmlDebugErr(ctxt, XML_CHECK_FOUND_PI,\n-                    \"Misplaced PI node\\n\");\n-            break;\n-        case XML_COMMENT_NODE:\n-        xmlDebugErr(ctxt, XML_CHECK_FOUND_COMMENT,\n-                    \"Misplaced COMMENT node\\n\");\n-            break;\n-        case XML_DOCUMENT_NODE:\n-        if (!ctxt->check)\n-        fprintf(ctxt->output, \"DOCUMENT\\n\");\n-            break;\n-        case XML_HTML_DOCUMENT_NODE:\n-        if (!ctxt->check)\n-        fprintf(ctxt->output, \"HTML DOCUMENT\\n\");\n-            break;\n-        case XML_DOCUMENT_TYPE_NODE:\n-        xmlDebugErr(ctxt, XML_CHECK_FOUND_DOCTYPE,\n-                    \"Misplaced DOCTYPE node\\n\");\n-            break;\n-        case XML_DOCUMENT_FRAG_NODE:\n-        xmlDebugErr(ctxt, XML_CHECK_FOUND_FRAGMENT,\n-                    \"Misplaced FRAGMENT node\\n\");\n-            break;\n-        case XML_NOTATION_NODE:\n-        xmlDebugErr(ctxt, XML_CHECK_FOUND_NOTATION,\n-                    \"Misplaced NOTATION node\\n\");\n-            break;\n-        default:\n-        xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,\n-                    \"Unknown node type %d\\n\", doc->type);\n-    }\n-}\n-\n-\/**\n- * xmlCtxtDumpDocumentHead:\n- * @output:  the FILE * for the output\n- * @doc:  the document\n- *\n- * Dumps debug information concerning the document, not recursive\n- *\/\n-static void\n-xmlCtxtDumpDocumentHead(xmlDebugCtxtPtr ctxt, xmlDocPtr doc)\n-{\n-    if (doc == NULL) return;\n-    xmlCtxtDumpDocHead(ctxt, doc);\n-    if (!ctxt->check) {\n-        if (doc->name != NULL) {\n-            fprintf(ctxt->output, \"name=\");\n-            xmlCtxtDumpString(ctxt, BAD_CAST doc->name);\n-            fprintf(ctxt->output, \"\\n\");\n-        }\n-        if (doc->version != NULL) {\n-            fprintf(ctxt->output, \"version=\");\n-            xmlCtxtDumpString(ctxt, doc->version);\n-            fprintf(ctxt->output, \"\\n\");\n-        }\n-        if (doc->encoding != NULL) {\n-            fprintf(ctxt->output, \"encoding=\");\n-            xmlCtxtDumpString(ctxt, doc->encoding);\n-            fprintf(ctxt->output, \"\\n\");\n-        }\n-        if (doc->URL != NULL) {\n-            fprintf(ctxt->output, \"URL=\");\n-            xmlCtxtDumpString(ctxt, doc->URL);\n-            fprintf(ctxt->output, \"\\n\");\n-        }\n-        if (doc->standalone)\n-            fprintf(ctxt->output, \"standalone=true\\n\");\n-    }\n-    if (doc->oldNs != NULL)\n-        xmlCtxtDumpNamespaceList(ctxt, doc->oldNs);\n-}\n-\n-\/**\n- * xmlCtxtDumpDocument:\n- * @output:  the FILE * for the output\n- * @doc:  the document\n- *\n- * Dumps debug information for the document, it's recursive\n- *\/\n-static void\n-xmlCtxtDumpDocument(xmlDebugCtxtPtr ctxt, xmlDocPtr doc)\n-{\n-    if (doc == NULL) {\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \"DOCUMENT == NULL !\\n\");\n-        return;\n-    }\n-    xmlCtxtDumpDocumentHead(ctxt, doc);\n-    if (((doc->type == XML_DOCUMENT_NODE) ||\n-         (doc->type == XML_HTML_DOCUMENT_NODE))\n-        && (doc->children != NULL)) {\n-        ctxt->depth++;\n-        xmlCtxtDumpNodeList(ctxt, doc->children);\n-        ctxt->depth--;\n-    }\n-}\n-\n-static void\n-xmlCtxtDumpEntityCallback(void *payload, void *data,\n-                          const xmlChar *name ATTRIBUTE_UNUSED)\n-{\n-    xmlEntityPtr cur = (xmlEntityPtr) payload;\n-    xmlDebugCtxtPtr ctxt = (xmlDebugCtxtPtr) data;\n-    if (cur == NULL) {\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \"Entity is NULL\");\n-        return;\n-    }\n-    if (!ctxt->check) {\n-        fprintf(ctxt->output, \"%s : \", (char *) cur->name);\n-        switch (cur->etype) {\n-            case XML_INTERNAL_GENERAL_ENTITY:\n-                fprintf(ctxt->output, \"INTERNAL GENERAL, \");\n-                break;\n-            case XML_EXTERNAL_GENERAL_PARSED_ENTITY:\n-                fprintf(ctxt->output, \"EXTERNAL PARSED, \");\n-                break;\n-            case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:\n-                fprintf(ctxt->output, \"EXTERNAL UNPARSED, \");\n-                break;\n-            case XML_INTERNAL_PARAMETER_ENTITY:\n-                fprintf(ctxt->output, \"INTERNAL PARAMETER, \");\n-                break;\n-            case XML_EXTERNAL_PARAMETER_ENTITY:\n-                fprintf(ctxt->output, \"EXTERNAL PARAMETER, \");\n-                break;\n-            default:\n-        xmlDebugErr2(ctxt, XML_CHECK_ENTITY_TYPE,\n-                 \"Unknown entity type %d\\n\", cur->etype);\n-        }\n-        if (cur->ExternalID != NULL)\n-            fprintf(ctxt->output, \"ID \\\"%s\\\"\", (char *) cur->ExternalID);\n-        if (cur->SystemID != NULL)\n-            fprintf(ctxt->output, \"SYSTEM \\\"%s\\\"\", (char *) cur->SystemID);\n-        if (cur->orig != NULL)\n-            fprintf(ctxt->output, \"\\n orig \\\"%s\\\"\", (char *) cur->orig);\n-        if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL))\n-            fprintf(ctxt->output, \"\\n content \\\"%s\\\"\",\n-                    (char *) cur->content);\n-        fprintf(ctxt->output, \"\\n\");\n-    }\n-}\n-\n-\/**\n- * xmlCtxtDumpEntities:\n- * @output:  the FILE * for the output\n- * @doc:  the document\n- *\n- * Dumps debug information for all the entities in use by the document\n- *\/\n-static void\n-xmlCtxtDumpEntities(xmlDebugCtxtPtr ctxt, xmlDocPtr doc)\n-{\n-    if (doc == NULL) return;\n-    xmlCtxtDumpDocHead(ctxt, doc);\n-    if ((doc->intSubset != NULL) && (doc->intSubset->entities != NULL)) {\n-        xmlEntitiesTablePtr table = (xmlEntitiesTablePtr)\n-            doc->intSubset->entities;\n-\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \"Entities in internal subset\\n\");\n-        xmlHashScan(table, xmlCtxtDumpEntityCallback, ctxt);\n-    } else\n-        fprintf(ctxt->output, \"No entities in internal subset\\n\");\n-    if ((doc->extSubset != NULL) && (doc->extSubset->entities != NULL)) {\n-        xmlEntitiesTablePtr table = (xmlEntitiesTablePtr)\n-            doc->extSubset->entities;\n-\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \"Entities in external subset\\n\");\n-        xmlHashScan(table, xmlCtxtDumpEntityCallback, ctxt);\n-    } else if (!ctxt->check)\n-        fprintf(ctxt->output, \"No entities in external subset\\n\");\n-}\n-\n-\/**\n- * xmlCtxtDumpDTD:\n- * @output:  the FILE * for the output\n- * @dtd:  the DTD\n- *\n- * Dumps debug information for the DTD\n- *\/\n-static void\n-xmlCtxtDumpDTD(xmlDebugCtxtPtr ctxt, xmlDtdPtr dtd)\n-{\n-    if (dtd == NULL) {\n-        if (!ctxt->check)\n-            fprintf(ctxt->output, \"DTD is NULL\\n\");\n-        return;\n-    }\n-    xmlCtxtDumpDtdNode(ctxt, dtd);\n-    if (dtd->children == NULL)\n-        fprintf(ctxt->output, \"    DTD is empty\\n\");\n-    else {\n-        ctxt->depth++;\n-        xmlCtxtDumpNodeList(ctxt, dtd->children);\n-        ctxt->depth--;\n-    }\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Public entry points for dump            *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlDebugDumpString:\n- * @output:  the FILE * for the output\n- * @str:  the string\n- *\n- * Dumps information about the string, shorten it if necessary\n- *\/\n-void\n-xmlDebugDumpString(FILE * output, const xmlChar * str)\n-{\n-    int i;\n-\n-    if (output == NULL)\n-    output = stdout;\n-    if (str == NULL) {\n-        fprintf(output, \"(NULL)\");\n-        return;\n-    }\n-    for (i = 0; i < 40; i++)\n-        if (str[i] == 0)\n-            return;\n-        else if (IS_BLANK_CH(str[i]))\n-            fputc(' ', output);\n-        else if (str[i] >= 0x80)\n-            fprintf(output, \"#%X\", str[i]);\n-        else\n-            fputc(str[i], output);\n-    fprintf(output, \"...\");\n-}\n-\n-\/**\n- * xmlDebugDumpAttr:\n- * @output:  the FILE * for the output\n- * @attr:  the attribute\n- * @depth:  the indentation level.\n- *\n- * Dumps debug information for the attribute\n- *\/\n-void\n-xmlDebugDumpAttr(FILE *output, xmlAttrPtr attr, int depth) {\n-    xmlDebugCtxt ctxt;\n-\n-    if (output == NULL) return;\n-    xmlCtxtDumpInitCtxt(&ctxt);\n-    ctxt.output = output;\n-    ctxt.depth = depth;\n-    xmlCtxtDumpAttr(&ctxt, attr);\n-    xmlCtxtDumpCleanCtxt(&ctxt);\n-}\n-\n-\n-\/**\n- * xmlDebugDumpEntities:\n- * @output:  the FILE * for the output\n- * @doc:  the document\n- *\n- * Dumps debug information for all the entities in use by the document\n- *\/\n-void\n-xmlDebugDumpEntities(FILE * output, xmlDocPtr doc)\n-{\n-    xmlDebugCtxt ctxt;\n-\n-    if (output == NULL) return;\n-    xmlCtxtDumpInitCtxt(&ctxt);\n-    ctxt.output = output;\n-    xmlCtxtDumpEntities(&ctxt, doc);\n-    xmlCtxtDumpCleanCtxt(&ctxt);\n-}\n-\n-\/**\n- * xmlDebugDumpAttrList:\n- * @output:  the FILE * for the output\n- * @attr:  the attribute list\n- * @depth:  the indentation level.\n- *\n- * Dumps debug information for the attribute list\n- *\/\n-void\n-xmlDebugDumpAttrList(FILE * output, xmlAttrPtr attr, int depth)\n-{\n-    xmlDebugCtxt ctxt;\n-\n-    if (output == NULL) return;\n-    xmlCtxtDumpInitCtxt(&ctxt);\n-    ctxt.output = output;\n-    ctxt.depth = depth;\n-    xmlCtxtDumpAttrList(&ctxt, attr);\n-    xmlCtxtDumpCleanCtxt(&ctxt);\n-}\n-\n-\/**\n- * xmlDebugDumpOneNode:\n- * @output:  the FILE * for the output\n- * @node:  the node\n- * @depth:  the indentation level.\n- *\n- * Dumps debug information for the element node, it is not recursive\n- *\/\n-void\n-xmlDebugDumpOneNode(FILE * output, xmlNodePtr node, int depth)\n-{\n-    xmlDebugCtxt ctxt;\n-\n-    if (output == NULL) return;\n-    xmlCtxtDumpInitCtxt(&ctxt);\n-    ctxt.output = output;\n-    ctxt.depth = depth;\n-    xmlCtxtDumpOneNode(&ctxt, node);\n-    xmlCtxtDumpCleanCtxt(&ctxt);\n-}\n-\n-\/**\n- * xmlDebugDumpNode:\n- * @output:  the FILE * for the output\n- * @node:  the node\n- * @depth:  the indentation level.\n- *\n- * Dumps debug information for the element node, it is recursive\n- *\/\n-void\n-xmlDebugDumpNode(FILE * output, xmlNodePtr node, int depth)\n-{\n-    xmlDebugCtxt ctxt;\n-\n-    if (output == NULL)\n-    output = stdout;\n-    xmlCtxtDumpInitCtxt(&ctxt);\n-    ctxt.output = output;\n-    ctxt.depth = depth;\n-    xmlCtxtDumpNode(&ctxt, node);\n-    xmlCtxtDumpCleanCtxt(&ctxt);\n-}\n-\n-\/**\n- * xmlDebugDumpNodeList:\n- * @output:  the FILE * for the output\n- * @node:  the node list\n- * @depth:  the indentation level.\n- *\n- * Dumps debug information for the list of element node, it is recursive\n- *\/\n-void\n-xmlDebugDumpNodeList(FILE * output, xmlNodePtr node, int depth)\n-{\n-    xmlDebugCtxt ctxt;\n-\n-    if (output == NULL)\n-    output = stdout;\n-    xmlCtxtDumpInitCtxt(&ctxt);\n-    ctxt.output = output;\n-    ctxt.depth = depth;\n-    xmlCtxtDumpNodeList(&ctxt, node);\n-    xmlCtxtDumpCleanCtxt(&ctxt);\n-}\n-\n-\/**\n- * xmlDebugDumpDocumentHead:\n- * @output:  the FILE * for the output\n- * @doc:  the document\n- *\n- * Dumps debug information concerning the document, not recursive\n- *\/\n-void\n-xmlDebugDumpDocumentHead(FILE * output, xmlDocPtr doc)\n-{\n-    xmlDebugCtxt ctxt;\n-\n-    if (output == NULL)\n-    output = stdout;\n-    xmlCtxtDumpInitCtxt(&ctxt);\n-    ctxt.options |= DUMP_TEXT_TYPE;\n-    ctxt.output = output;\n-    xmlCtxtDumpDocumentHead(&ctxt, doc);\n-    xmlCtxtDumpCleanCtxt(&ctxt);\n-}\n-\n-\/**\n- * xmlDebugDumpDocument:\n- * @output:  the FILE * for the output\n- * @doc:  the document\n- *\n- * Dumps debug information for the document, it's recursive\n- *\/\n-void\n-xmlDebugDumpDocument(FILE * output, xmlDocPtr doc)\n-{\n-    xmlDebugCtxt ctxt;\n-\n-    if (output == NULL)\n-    output = stdout;\n-    xmlCtxtDumpInitCtxt(&ctxt);\n-    ctxt.options |= DUMP_TEXT_TYPE;\n-    ctxt.output = output;\n-    xmlCtxtDumpDocument(&ctxt, doc);\n-    xmlCtxtDumpCleanCtxt(&ctxt);\n-}\n-\n-\/**\n- * xmlDebugDumpDTD:\n- * @output:  the FILE * for the output\n- * @dtd:  the DTD\n- *\n- * Dumps debug information for the DTD\n- *\/\n-void\n-xmlDebugDumpDTD(FILE * output, xmlDtdPtr dtd)\n-{\n-    xmlDebugCtxt ctxt;\n-\n-    if (output == NULL)\n-    output = stdout;\n-    xmlCtxtDumpInitCtxt(&ctxt);\n-    ctxt.options |= DUMP_TEXT_TYPE;\n-    ctxt.output = output;\n-    xmlCtxtDumpDTD(&ctxt, dtd);\n-    xmlCtxtDumpCleanCtxt(&ctxt);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Public entry points for checkings        *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlDebugCheckDocument:\n- * @output:  the FILE * for the output\n- * @doc:  the document\n- *\n- * Check the document for potential content problems, and output\n- * the errors to @output\n- *\n- * Returns the number of errors found\n- *\/\n-int\n-xmlDebugCheckDocument(FILE * output, xmlDocPtr doc)\n-{\n-    xmlDebugCtxt ctxt;\n-\n-    if (output == NULL)\n-    output = stdout;\n-    xmlCtxtDumpInitCtxt(&ctxt);\n-    ctxt.output = output;\n-    ctxt.check = 1;\n-    xmlCtxtDumpDocument(&ctxt, doc);\n-    xmlCtxtDumpCleanCtxt(&ctxt);\n-    return(ctxt.errors);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Helpers for Shell                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlLsCountNode:\n- * @node:  the node to count\n- *\n- * Count the children of @node.\n- *\n- * Returns the number of children of @node.\n- *\/\n-int\n-xmlLsCountNode(xmlNodePtr node) {\n-    int ret = 0;\n-    xmlNodePtr list = NULL;\n-\n-    if (node == NULL)\n-    return(0);\n-\n-    switch (node->type) {\n-    case XML_ELEMENT_NODE:\n-        list = node->children;\n-        break;\n-    case XML_DOCUMENT_NODE:\n-    case XML_HTML_DOCUMENT_NODE:\n-        list = ((xmlDocPtr) node)->children;\n-        break;\n-    case XML_ATTRIBUTE_NODE:\n-        list = ((xmlAttrPtr) node)->children;\n-        break;\n-    case XML_TEXT_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_PI_NODE:\n-    case XML_COMMENT_NODE:\n-        if (node->content != NULL) {\n-        ret = xmlStrlen(node->content);\n-            }\n-        break;\n-    case XML_ENTITY_REF_NODE:\n-    case XML_DOCUMENT_TYPE_NODE:\n-    case XML_ENTITY_NODE:\n-    case XML_DOCUMENT_FRAG_NODE:\n-    case XML_NOTATION_NODE:\n-    case XML_DTD_NODE:\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_ENTITY_DECL:\n-    case XML_NAMESPACE_DECL:\n-    case XML_XINCLUDE_START:\n-    case XML_XINCLUDE_END:\n-        ret = 1;\n-        break;\n-    }\n-    for (;list != NULL;ret++)\n-        list = list->next;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlLsOneNode:\n- * @output:  the FILE * for the output\n- * @node:  the node to dump\n- *\n- * Dump to @output the type and name of @node.\n- *\/\n-void\n-xmlLsOneNode(FILE *output, xmlNodePtr node) {\n-    if (output == NULL) return;\n-    if (node == NULL) {\n-    fprintf(output, \"NULL\\n\");\n-    return;\n-    }\n-    switch (node->type) {\n-    case XML_ELEMENT_NODE:\n-        fprintf(output, \"-\");\n-        break;\n-    case XML_ATTRIBUTE_NODE:\n-        fprintf(output, \"a\");\n-        break;\n-    case XML_TEXT_NODE:\n-        fprintf(output, \"t\");\n-        break;\n-    case XML_CDATA_SECTION_NODE:\n-        fprintf(output, \"C\");\n-        break;\n-    case XML_ENTITY_REF_NODE:\n-        fprintf(output, \"e\");\n-        break;\n-    case XML_ENTITY_NODE:\n-        fprintf(output, \"E\");\n-        break;\n-    case XML_PI_NODE:\n-        fprintf(output, \"p\");\n-        break;\n-    case XML_COMMENT_NODE:\n-        fprintf(output, \"c\");\n-        break;\n-    case XML_DOCUMENT_NODE:\n-        fprintf(output, \"d\");\n-        break;\n-    case XML_HTML_DOCUMENT_NODE:\n-        fprintf(output, \"h\");\n-        break;\n-    case XML_DOCUMENT_TYPE_NODE:\n-        fprintf(output, \"T\");\n-        break;\n-    case XML_DOCUMENT_FRAG_NODE:\n-        fprintf(output, \"F\");\n-        break;\n-    case XML_NOTATION_NODE:\n-        fprintf(output, \"N\");\n-        break;\n-    case XML_NAMESPACE_DECL:\n-        fprintf(output, \"n\");\n-        break;\n-    default:\n-        fprintf(output, \"?\");\n-    }\n-    if (node->type != XML_NAMESPACE_DECL) {\n-    if (node->properties != NULL)\n-        fprintf(output, \"a\");\n-    else\n-        fprintf(output, \"-\");\n-    if (node->nsDef != NULL)\n-        fprintf(output, \"n\");\n-    else\n-        fprintf(output, \"-\");\n-    }\n-\n-    fprintf(output, \" %8d \", xmlLsCountNode(node));\n-\n-    switch (node->type) {\n-    case XML_ELEMENT_NODE:\n-        if (node->name != NULL) {\n-                if ((node->ns != NULL) && (node->ns->prefix != NULL))\n-                    fprintf(output, \"%s:\", node->ns->prefix);\n-        fprintf(output, \"%s\", (const char *) node->name);\n-            }\n-        break;\n-    case XML_ATTRIBUTE_NODE:\n-        if (node->name != NULL)\n-        fprintf(output, \"%s\", (const char *) node->name);\n-        break;\n-    case XML_TEXT_NODE:\n-        if (node->content != NULL) {\n-        xmlDebugDumpString(output, node->content);\n-            }\n-        break;\n-    case XML_CDATA_SECTION_NODE:\n-        break;\n-    case XML_ENTITY_REF_NODE:\n-        if (node->name != NULL)\n-        fprintf(output, \"%s\", (const char *) node->name);\n-        break;\n-    case XML_ENTITY_NODE:\n-        if (node->name != NULL)\n-        fprintf(output, \"%s\", (const char *) node->name);\n-        break;\n-    case XML_PI_NODE:\n-        if (node->name != NULL)\n-        fprintf(output, \"%s\", (const char *) node->name);\n-        break;\n-    case XML_COMMENT_NODE:\n-        break;\n-    case XML_DOCUMENT_NODE:\n-        break;\n-    case XML_HTML_DOCUMENT_NODE:\n-        break;\n-    case XML_DOCUMENT_TYPE_NODE:\n-        break;\n-    case XML_DOCUMENT_FRAG_NODE:\n-        break;\n-    case XML_NOTATION_NODE:\n-        break;\n-    case XML_NAMESPACE_DECL: {\n-        xmlNsPtr ns = (xmlNsPtr) node;\n-\n-        if (ns->prefix == NULL)\n-        fprintf(output, \"default -> %s\", (char *)ns->href);\n-        else\n-        fprintf(output, \"%s -> %s\", (char *)ns->prefix,\n-            (char *)ns->href);\n-        break;\n-    }\n-    default:\n-        if (node->name != NULL)\n-        fprintf(output, \"%s\", (const char *) node->name);\n-    }\n-    fprintf(output, \"\\n\");\n-}\n-\n-\/**\n- * xmlBoolToText:\n- * @boolval: a bool to turn into text\n- *\n- * Convenient way to turn bool into text\n- *\n- * Returns a pointer to either \"True\" or \"False\"\n- *\/\n-const char *\n-xmlBoolToText(int boolval)\n-{\n-    if (boolval)\n-        return(\"True\");\n-    else\n-        return(\"False\");\n-}\n-\n-#ifdef LIBXML_XPATH_ENABLED\n-\/****************************************************************\n- *                                *\n- *        The XML shell related functions            *\n- *                                *\n- ****************************************************************\/\n-\n-\n-\n-\/*\n- * TODO: Improvement\/cleanups for the XML shell\n- *     - allow to shell out an editor on a subpart\n- *     - cleanup function registrations (with help) and calling\n- *     - provide registration routines\n- *\/\n-\n-\/**\n- * xmlShellPrintXPathError:\n- * @errorType: valid xpath error id\n- * @arg: the argument that cause xpath to fail\n- *\n- * Print the xpath error to libxml default error channel\n- *\/\n-void\n-xmlShellPrintXPathError(int errorType, const char *arg)\n-{\n-    const char *default_arg = \"Result\";\n-\n-    if (!arg)\n-        arg = default_arg;\n-\n-    switch (errorType) {\n-        case XPATH_UNDEFINED:\n-            fprintf(stderr,\n-                            \"%s: no such node\\n\", arg);\n-            break;\n-\n-        case XPATH_BOOLEAN:\n-            fprintf(stderr,\n-                            \"%s is a Boolean\\n\", arg);\n-            break;\n-        case XPATH_NUMBER:\n-            fprintf(stderr,\n-                            \"%s is a number\\n\", arg);\n-            break;\n-        case XPATH_STRING:\n-            fprintf(stderr,\n-                            \"%s is a string\\n\", arg);\n-            break;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        case XPATH_POINT:\n-            fprintf(stderr,\n-                            \"%s is a point\\n\", arg);\n-            break;\n-        case XPATH_RANGE:\n-            fprintf(stderr,\n-                            \"%s is a range\\n\", arg);\n-            break;\n-        case XPATH_LOCATIONSET:\n-            fprintf(stderr,\n-                            \"%s is a range\\n\", arg);\n-            break;\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-        case XPATH_USERS:\n-            fprintf(stderr,\n-                            \"%s is user-defined\\n\", arg);\n-            break;\n-        case XPATH_XSLT_TREE:\n-            fprintf(stderr,\n-                            \"%s is an XSLT value tree\\n\", arg);\n-            break;\n-    }\n-#if 0\n-    fprintf(stderr,\n-                    \"Try casting the result string function (xpath builtin)\\n\",\n-                    arg);\n-#endif\n-}\n-\n-\n-#ifdef LIBXML_OUTPUT_ENABLED\n-\/**\n- * xmlShellPrintNodeCtxt:\n- * @ctxt : a non-null shell context\n- * @node : a non-null node to print to the output FILE\n- *\n- * Print node to the output FILE\n- *\/\n-static void\n-xmlShellPrintNodeCtxt(xmlShellCtxtPtr ctxt,xmlNodePtr node)\n-{\n-    FILE *fp;\n-\n-    if (!node)\n-        return;\n-    if (ctxt == NULL)\n-    fp = stdout;\n-    else\n-    fp = ctxt->output;\n-\n-    if (node->type == XML_DOCUMENT_NODE)\n-        xmlDocDump(fp, (xmlDocPtr) node);\n-    else if (node->type == XML_ATTRIBUTE_NODE)\n-        xmlDebugDumpAttrList(fp, (xmlAttrPtr) node, 0);\n-    else\n-        xmlElemDump(fp, node->doc, node);\n-\n-    fprintf(fp, \"\\n\");\n-}\n-\n-\/**\n- * xmlShellPrintNode:\n- * @node : a non-null node to print to the output FILE\n- *\n- * Print node to the output FILE\n- *\/\n-void\n-xmlShellPrintNode(xmlNodePtr node)\n-{\n-    xmlShellPrintNodeCtxt(NULL, node);\n-}\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-\n-\/**\n- * xmlShellPrintXPathResultCtxt:\n- * @ctxt: a valid shell context\n- * @list: a valid result generated by an xpath evaluation\n- *\n- * Prints result to the output FILE\n- *\/\n-static void\n-xmlShellPrintXPathResultCtxt(xmlShellCtxtPtr ctxt,xmlXPathObjectPtr list)\n-{\n-    if (!ctxt)\n-       return;\n-\n-    if (list != NULL) {\n-        switch (list->type) {\n-            case XPATH_NODESET:{\n-#ifdef LIBXML_OUTPUT_ENABLED\n-                    int indx;\n-\n-                    if (list->nodesetval) {\n-                        for (indx = 0; indx < list->nodesetval->nodeNr;\n-                             indx++) {\n-                            xmlShellPrintNodeCtxt(ctxt,\n-                    list->nodesetval->nodeTab[indx]);\n-                        }\n-                    } else {\n-                        fprintf(ctxt->output,\n-                                        \"Empty node set\\n\");\n-                    }\n-                    break;\n-#else\n-            fprintf(ctxt->output,\n-                    \"Node set\\n\");\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-                }\n-            case XPATH_BOOLEAN:\n-                fprintf(ctxt->output,\n-                                \"Is a Boolean:%s\\n\",\n-                                xmlBoolToText(list->boolval));\n-                break;\n-            case XPATH_NUMBER:\n-                fprintf(ctxt->output,\n-                                \"Is a number:%0g\\n\", list->floatval);\n-                break;\n-            case XPATH_STRING:\n-                fprintf(ctxt->output,\n-                                \"Is a string:%s\\n\", list->stringval);\n-                break;\n-\n-            default:\n-                xmlShellPrintXPathError(list->type, NULL);\n-        }\n-    }\n-}\n-\n-\/**\n- * xmlShellPrintXPathResult:\n- * @list: a valid result generated by an xpath evaluation\n- *\n- * Prints result to the output FILE\n- *\/\n-void\n-xmlShellPrintXPathResult(xmlXPathObjectPtr list)\n-{\n-    xmlShellPrintXPathResultCtxt(NULL, list);\n-}\n-\n-\/**\n- * xmlShellList:\n- * @ctxt:  the shell context\n- * @arg:  unused\n- * @node:  a node\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"ls\"\n- * Does an Unix like listing of the given node (like a directory)\n- *\n- * Returns 0\n- *\/\n-int\n-xmlShellList(xmlShellCtxtPtr ctxt,\n-             char *arg ATTRIBUTE_UNUSED, xmlNodePtr node,\n-             xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    xmlNodePtr cur;\n-    if (!ctxt)\n-        return (0);\n-    if (node == NULL) {\n-    fprintf(ctxt->output, \"NULL\\n\");\n-    return (0);\n-    }\n-    if ((node->type == XML_DOCUMENT_NODE) ||\n-        (node->type == XML_HTML_DOCUMENT_NODE)) {\n-        cur = ((xmlDocPtr) node)->children;\n-    } else if (node->type == XML_NAMESPACE_DECL) {\n-        xmlLsOneNode(ctxt->output, node);\n-        return (0);\n-    } else if (node->children != NULL) {\n-        cur = node->children;\n-    } else {\n-        xmlLsOneNode(ctxt->output, node);\n-        return (0);\n-    }\n-    while (cur != NULL) {\n-        xmlLsOneNode(ctxt->output, cur);\n-        cur = cur->next;\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlShellBase:\n- * @ctxt:  the shell context\n- * @arg:  unused\n- * @node:  a node\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"base\"\n- * dumps the current XML base of the node\n- *\n- * Returns 0\n- *\/\n-int\n-xmlShellBase(xmlShellCtxtPtr ctxt,\n-             char *arg ATTRIBUTE_UNUSED, xmlNodePtr node,\n-             xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    xmlChar *base;\n-    if (!ctxt)\n-        return 0;\n-    if (node == NULL) {\n-    fprintf(ctxt->output, \"NULL\\n\");\n-    return (0);\n-    }\n-\n-    base = xmlNodeGetBase(node->doc, node);\n-\n-    if (base == NULL) {\n-        fprintf(ctxt->output, \" No base found !!!\\n\");\n-    } else {\n-        fprintf(ctxt->output, \"%s\\n\", base);\n-        xmlFree(base);\n-    }\n-    return (0);\n-}\n-\n-#ifdef LIBXML_TREE_ENABLED\n-\/**\n- * xmlShellSetBase:\n- * @ctxt:  the shell context\n- * @arg:  the new base\n- * @node:  a node\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"setbase\"\n- * change the current XML base of the node\n- *\n- * Returns 0\n- *\/\n-static int\n-xmlShellSetBase(xmlShellCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-             char *arg ATTRIBUTE_UNUSED, xmlNodePtr node,\n-             xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    xmlNodeSetBase(node, (xmlChar*) arg);\n-    return (0);\n-}\n-#endif\n-\n-#ifdef LIBXML_XPATH_ENABLED\n-\/**\n- * xmlShellRegisterNamespace:\n- * @ctxt:  the shell context\n- * @arg:  a string in prefix=nsuri format\n- * @node:  unused\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"setns\"\n- * register\/unregister a prefix=namespace pair\n- * on the XPath context\n- *\n- * Returns 0 on success and a negative value otherwise.\n- *\/\n-static int\n-xmlShellRegisterNamespace(xmlShellCtxtPtr ctxt, char *arg,\n-      xmlNodePtr node ATTRIBUTE_UNUSED, xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    xmlChar* nsListDup;\n-    xmlChar* prefix;\n-    xmlChar* href;\n-    xmlChar* next;\n-\n-    nsListDup = xmlStrdup((xmlChar *) arg);\n-    next = nsListDup;\n-    while(next != NULL) {\n-    \/* skip spaces *\/\n-    \/*while((*next) == ' ') next++;*\/\n-    if((*next) == '\\0') break;\n-\n-    \/* find prefix *\/\n-    prefix = next;\n-    next = (xmlChar*)xmlStrchr(next, '=');\n-    if(next == NULL) {\n-        fprintf(ctxt->output, \"setns: prefix=[nsuri] required\\n\");\n-        xmlFree(nsListDup);\n-        return(-1);\n-    }\n-    *(next++) = '\\0';\n-\n-    \/* find href *\/\n-    href = next;\n-    next = (xmlChar*)xmlStrchr(next, ' ');\n-    if(next != NULL) {\n-        *(next++) = '\\0';\n-    }\n-\n-    \/* do register namespace *\/\n-    if(xmlXPathRegisterNs(ctxt->pctxt, prefix, href) != 0) {\n-        fprintf(ctxt->output,\"Error: unable to register NS with prefix=\\\"%s\\\" and href=\\\"%s\\\"\\n\", prefix, href);\n-        xmlFree(nsListDup);\n-        return(-1);\n-    }\n-    }\n-\n-    xmlFree(nsListDup);\n-    return(0);\n-}\n-\/**\n- * xmlShellRegisterRootNamespaces:\n- * @ctxt:  the shell context\n- * @arg:  unused\n- * @node:  the root element\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"setrootns\"\n- * which registers all namespaces declarations found on the root element.\n- *\n- * Returns 0 on success and a negative value otherwise.\n- *\/\n-static int\n-xmlShellRegisterRootNamespaces(xmlShellCtxtPtr ctxt, char *arg ATTRIBUTE_UNUSED,\n-      xmlNodePtr root, xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    xmlNsPtr ns;\n-\n-    if ((root == NULL) || (root->type != XML_ELEMENT_NODE) ||\n-        (root->nsDef == NULL) || (ctxt == NULL) || (ctxt->pctxt == NULL))\n-    return(-1);\n-    ns = root->nsDef;\n-    while (ns != NULL) {\n-        if (ns->prefix == NULL)\n-        xmlXPathRegisterNs(ctxt->pctxt, BAD_CAST \"defaultns\", ns->href);\n-    else\n-        xmlXPathRegisterNs(ctxt->pctxt, ns->prefix, ns->href);\n-        ns = ns->next;\n-    }\n-    return(0);\n-}\n-#endif\n-\n-\/**\n- * xmlShellGrep:\n- * @ctxt:  the shell context\n- * @arg:  the string or regular expression to find\n- * @node:  a node\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"grep\"\n- * dumps information about the node (namespace, attributes, content).\n- *\n- * Returns 0\n- *\/\n-static int\n-xmlShellGrep(xmlShellCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-            char *arg, xmlNodePtr node, xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    if (!ctxt)\n-        return (0);\n-    if (node == NULL)\n-    return (0);\n-    if (arg == NULL)\n-    return (0);\n-#ifdef LIBXML_REGEXP_ENABLED\n-    if ((xmlStrchr((xmlChar *) arg, '?')) ||\n-    (xmlStrchr((xmlChar *) arg, '*')) ||\n-    (xmlStrchr((xmlChar *) arg, '.')) ||\n-    (xmlStrchr((xmlChar *) arg, '['))) {\n-    }\n-#endif\n-    while (node != NULL) {\n-        if (node->type == XML_COMMENT_NODE) {\n-        if (xmlStrstr(node->content, (xmlChar *) arg)) {\n-\n-        fprintf(ctxt->output, \"%s : \", xmlGetNodePath(node));\n-                xmlShellList(ctxt, NULL, node, NULL);\n-        }\n-        } else if (node->type == XML_TEXT_NODE) {\n-        if (xmlStrstr(node->content, (xmlChar *) arg)) {\n-\n-        fprintf(ctxt->output, \"%s : \", xmlGetNodePath(node->parent));\n-                xmlShellList(ctxt, NULL, node->parent, NULL);\n-        }\n-        }\n-\n-        \/*\n-         * Browse the full subtree, deep first\n-         *\/\n-\n-        if ((node->type == XML_DOCUMENT_NODE) ||\n-            (node->type == XML_HTML_DOCUMENT_NODE)) {\n-            node = ((xmlDocPtr) node)->children;\n-        } else if ((node->children != NULL)\n-                   && (node->type != XML_ENTITY_REF_NODE)) {\n-            \/* deep first *\/\n-            node = node->children;\n-        } else if (node->next != NULL) {\n-            \/* then siblings *\/\n-            node = node->next;\n-        } else {\n-            \/* go up to parents->next if needed *\/\n-            while (node != NULL) {\n-                if (node->parent != NULL) {\n-                    node = node->parent;\n-                }\n-                if (node->next != NULL) {\n-                    node = node->next;\n-                    break;\n-                }\n-                if (node->parent == NULL) {\n-                    node = NULL;\n-                    break;\n-                }\n-            }\n-    }\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlShellDir:\n- * @ctxt:  the shell context\n- * @arg:  unused\n- * @node:  a node\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"dir\"\n- * dumps information about the node (namespace, attributes, content).\n- *\n- * Returns 0\n- *\/\n-int\n-xmlShellDir(xmlShellCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-            char *arg ATTRIBUTE_UNUSED, xmlNodePtr node,\n-            xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    if (!ctxt)\n-        return (0);\n-    if (node == NULL) {\n-    fprintf(ctxt->output, \"NULL\\n\");\n-    return (0);\n-    }\n-    if ((node->type == XML_DOCUMENT_NODE) ||\n-        (node->type == XML_HTML_DOCUMENT_NODE)) {\n-        xmlDebugDumpDocumentHead(ctxt->output, (xmlDocPtr) node);\n-    } else if (node->type == XML_ATTRIBUTE_NODE) {\n-        xmlDebugDumpAttr(ctxt->output, (xmlAttrPtr) node, 0);\n-    } else {\n-        xmlDebugDumpOneNode(ctxt->output, node, 0);\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlShellSetContent:\n- * @ctxt:  the shell context\n- * @value:  the content as a string\n- * @node:  a node\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"dir\"\n- * dumps information about the node (namespace, attributes, content).\n- *\n- * Returns 0\n- *\/\n-static int\n-xmlShellSetContent(xmlShellCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-            char *value, xmlNodePtr node,\n-            xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    xmlNodePtr results;\n-    xmlParserErrors ret;\n-\n-    if (!ctxt)\n-        return (0);\n-    if (node == NULL) {\n-    fprintf(ctxt->output, \"NULL\\n\");\n-    return (0);\n-    }\n-    if (value == NULL) {\n-        fprintf(ctxt->output, \"NULL\\n\");\n-    return (0);\n-    }\n-\n-    ret = xmlParseInNodeContext(node, value, strlen(value), 0, &results);\n-    if (ret == XML_ERR_OK) {\n-    if (node->children != NULL) {\n-        xmlFreeNodeList(node->children);\n-        node->children = NULL;\n-        node->last = NULL;\n-    }\n-    xmlAddChildList(node, results);\n-    } else {\n-        fprintf(ctxt->output, \"failed to parse content\\n\");\n-    }\n-    return (0);\n-}\n-\n-static void\n-xmlShellPrintf(void *ctx, const char *msg, ...) {\n-    xmlShellCtxtPtr sctxt = ctx;\n-    va_list ap;\n-\n-    va_start(ap, msg);\n-    vfprintf(sctxt->output, msg, ap);\n-    va_end(ap);\n-}\n-\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-\/**\n- * xmlShellRNGValidate:\n- * @ctxt:  the shell context\n- * @schemas:  the path to the Relax-NG schemas\n- * @node:  a node\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"relaxng\"\n- * validating the instance against a Relax-NG schemas\n- *\n- * Returns 0\n- *\/\n-static int\n-xmlShellRNGValidate(xmlShellCtxtPtr sctxt, char *schemas,\n-            xmlNodePtr node ATTRIBUTE_UNUSED,\n-        xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    xmlRelaxNGPtr relaxngschemas;\n-    xmlRelaxNGParserCtxtPtr ctxt;\n-    xmlRelaxNGValidCtxtPtr vctxt;\n-    int ret;\n-\n-    ctxt = xmlRelaxNGNewParserCtxt(schemas);\n-    xmlRelaxNGSetParserErrors(ctxt, xmlShellPrintf, xmlShellPrintf, sctxt);\n-    relaxngschemas = xmlRelaxNGParse(ctxt);\n-    xmlRelaxNGFreeParserCtxt(ctxt);\n-    if (relaxngschemas == NULL) {\n-    fprintf(sctxt->output,\n-        \"Relax-NG schema %s failed to compile\\n\", schemas);\n-    return(-1);\n-    }\n-    vctxt = xmlRelaxNGNewValidCtxt(relaxngschemas);\n-    xmlRelaxNGSetValidErrors(vctxt, xmlShellPrintf, xmlShellPrintf, sctxt);\n-    ret = xmlRelaxNGValidateDoc(vctxt, sctxt->doc);\n-    if (ret == 0) {\n-    fprintf(sctxt->output, \"%s validates\\n\", sctxt->filename);\n-    } else if (ret > 0) {\n-    fprintf(sctxt->output, \"%s fails to validate\\n\", sctxt->filename);\n-    } else {\n-    fprintf(sctxt->output, \"%s validation generated an internal error\\n\",\n-           sctxt->filename);\n-    }\n-    xmlRelaxNGFreeValidCtxt(vctxt);\n-    if (relaxngschemas != NULL)\n-    xmlRelaxNGFree(relaxngschemas);\n-    return(0);\n-}\n-#endif\n-\n-#ifdef LIBXML_OUTPUT_ENABLED\n-\/**\n- * xmlShellCat:\n- * @ctxt:  the shell context\n- * @arg:  unused\n- * @node:  a node\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"cat\"\n- * dumps the serialization node content (XML or HTML).\n- *\n- * Returns 0\n- *\/\n-int\n-xmlShellCat(xmlShellCtxtPtr ctxt, char *arg ATTRIBUTE_UNUSED,\n-            xmlNodePtr node, xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    if (!ctxt)\n-        return (0);\n-    if (node == NULL) {\n-    fprintf(ctxt->output, \"NULL\\n\");\n-    return (0);\n-    }\n-    if (ctxt->doc->type == XML_HTML_DOCUMENT_NODE) {\n-#ifdef LIBXML_HTML_ENABLED\n-        if (node->type == XML_HTML_DOCUMENT_NODE)\n-            htmlDocDump(ctxt->output, (htmlDocPtr) node);\n-        else\n-            htmlNodeDumpFile(ctxt->output, ctxt->doc, node);\n-#else\n-        if (node->type == XML_DOCUMENT_NODE)\n-            xmlDocDump(ctxt->output, (xmlDocPtr) node);\n-        else\n-            xmlElemDump(ctxt->output, ctxt->doc, node);\n-#endif \/* LIBXML_HTML_ENABLED *\/\n-    } else {\n-        if (node->type == XML_DOCUMENT_NODE)\n-            xmlDocDump(ctxt->output, (xmlDocPtr) node);\n-        else\n-            xmlElemDump(ctxt->output, ctxt->doc, node);\n-    }\n-    fprintf(ctxt->output, \"\\n\");\n-    return (0);\n-}\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-\n-\/**\n- * xmlShellLoad:\n- * @ctxt:  the shell context\n- * @filename:  the file name\n- * @node:  unused\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"load\"\n- * loads a new document specified by the filename\n- *\n- * Returns 0 or -1 if loading failed\n- *\/\n-int\n-xmlShellLoad(xmlShellCtxtPtr ctxt, char *filename,\n-             xmlNodePtr node ATTRIBUTE_UNUSED,\n-             xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    xmlDocPtr doc;\n-    int html = 0;\n-\n-    if ((ctxt == NULL) || (filename == NULL)) return(-1);\n-    if (ctxt->doc != NULL)\n-        html = (ctxt->doc->type == XML_HTML_DOCUMENT_NODE);\n-\n-    if (html) {\n-#ifdef LIBXML_HTML_ENABLED\n-        doc = htmlParseFile(filename, NULL);\n-#else\n-        fprintf(ctxt->output, \"HTML support not compiled in\\n\");\n-        doc = NULL;\n-#endif \/* LIBXML_HTML_ENABLED *\/\n-    } else {\n-        doc = xmlReadFile(filename,NULL,0);\n-    }\n-    if (doc != NULL) {\n-        if (ctxt->loaded == 1) {\n-            xmlFreeDoc(ctxt->doc);\n-        }\n-        ctxt->loaded = 1;\n-#ifdef LIBXML_XPATH_ENABLED\n-        xmlXPathFreeContext(ctxt->pctxt);\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-        xmlFree(ctxt->filename);\n-        ctxt->doc = doc;\n-        ctxt->node = (xmlNodePtr) doc;\n-#ifdef LIBXML_XPATH_ENABLED\n-        ctxt->pctxt = xmlXPathNewContext(doc);\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-        ctxt->filename = (char *) xmlCanonicPath((xmlChar *) filename);\n-    } else\n-        return (-1);\n-    return (0);\n-}\n-\n-#ifdef LIBXML_OUTPUT_ENABLED\n-\/**\n- * xmlShellWrite:\n- * @ctxt:  the shell context\n- * @filename:  the file name\n- * @node:  a node in the tree\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"write\"\n- * Write the current node to the filename, it saves the serialization\n- * of the subtree under the @node specified\n- *\n- * Returns 0 or -1 in case of error\n- *\/\n-int\n-xmlShellWrite(xmlShellCtxtPtr ctxt, char *filename, xmlNodePtr node,\n-              xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    if (node == NULL)\n-        return (-1);\n-    if ((filename == NULL) || (filename[0] == 0)) {\n-        return (-1);\n-    }\n-#ifdef W_OK\n-    if (access((char *) filename, W_OK)) {\n-        fprintf(ctxt->output,\n-                        \"Cannot write to %s\\n\", filename);\n-        return (-1);\n-    }\n-#endif\n-    switch (node->type) {\n-        case XML_DOCUMENT_NODE:\n-            if (xmlSaveFile((char *) filename, ctxt->doc) < -1) {\n-                fprintf(ctxt->output,\n-                                \"Failed to write to %s\\n\", filename);\n-                return (-1);\n-            }\n-            break;\n-        case XML_HTML_DOCUMENT_NODE:\n-#ifdef LIBXML_HTML_ENABLED\n-            if (htmlSaveFile((char *) filename, ctxt->doc) < 0) {\n-                fprintf(ctxt->output,\n-                                \"Failed to write to %s\\n\", filename);\n-                return (-1);\n-            }\n-#else\n-            if (xmlSaveFile((char *) filename, ctxt->doc) < -1) {\n-                fprintf(ctxt->output,\n-                                \"Failed to write to %s\\n\", filename);\n-                return (-1);\n-            }\n-#endif \/* LIBXML_HTML_ENABLED *\/\n-            break;\n-        default:{\n-                FILE *f;\n-\n-                f = fopen((char *) filename, \"w\");\n-                if (f == NULL) {\n-                    fprintf(ctxt->output,\n-                                    \"Failed to write to %s\\n\", filename);\n-                    return (-1);\n-                }\n-                xmlElemDump(f, ctxt->doc, node);\n-                fclose(f);\n-            }\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlShellSave:\n- * @ctxt:  the shell context\n- * @filename:  the file name (optional)\n- * @node:  unused\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"save\"\n- * Write the current document to the filename, or it's original name\n- *\n- * Returns 0 or -1 in case of error\n- *\/\n-int\n-xmlShellSave(xmlShellCtxtPtr ctxt, char *filename,\n-             xmlNodePtr node ATTRIBUTE_UNUSED,\n-             xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    if ((ctxt == NULL) || (ctxt->doc == NULL))\n-        return (-1);\n-    if ((filename == NULL) || (filename[0] == 0))\n-        filename = ctxt->filename;\n-    if (filename == NULL)\n-        return (-1);\n-#ifdef W_OK\n-    if (access((char *) filename, W_OK)) {\n-        fprintf(ctxt->output,\n-                        \"Cannot save to %s\\n\", filename);\n-        return (-1);\n-    }\n-#endif\n-    switch (ctxt->doc->type) {\n-        case XML_DOCUMENT_NODE:\n-            if (xmlSaveFile((char *) filename, ctxt->doc) < 0) {\n-                fprintf(ctxt->output,\n-                                \"Failed to save to %s\\n\", filename);\n-            }\n-            break;\n-        case XML_HTML_DOCUMENT_NODE:\n-#ifdef LIBXML_HTML_ENABLED\n-            if (htmlSaveFile((char *) filename, ctxt->doc) < 0) {\n-                fprintf(ctxt->output,\n-                                \"Failed to save to %s\\n\", filename);\n-            }\n-#else\n-            if (xmlSaveFile((char *) filename, ctxt->doc) < 0) {\n-                fprintf(ctxt->output,\n-                                \"Failed to save to %s\\n\", filename);\n-            }\n-#endif \/* LIBXML_HTML_ENABLED *\/\n-            break;\n-        default:\n-            fprintf(ctxt->output,\n-        \"To save to subparts of a document use the 'write' command\\n\");\n-            return (-1);\n-\n-    }\n-    return (0);\n-}\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-\n-#ifdef LIBXML_VALID_ENABLED\n-\/**\n- * xmlShellValidate:\n- * @ctxt:  the shell context\n- * @dtd:  the DTD URI (optional)\n- * @node:  unused\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"validate\"\n- * Validate the document, if a DTD path is provided, then the validation\n- * is done against the given DTD.\n- *\n- * Returns 0 or -1 in case of error\n- *\/\n-int\n-xmlShellValidate(xmlShellCtxtPtr ctxt, char *dtd,\n-                 xmlNodePtr node ATTRIBUTE_UNUSED,\n-                 xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    xmlValidCtxt vctxt;\n-    int res = -1;\n-\n-    if ((ctxt == NULL) || (ctxt->doc == NULL)) return(-1);\n-    memset(&vctxt, 0, sizeof(vctxt));\n-    vctxt.error = xmlShellPrintf;\n-    vctxt.warning = xmlShellPrintf;\n-    vctxt.userData = ctxt;\n-\n-    if ((dtd == NULL) || (dtd[0] == 0)) {\n-        res = xmlValidateDocument(&vctxt, ctxt->doc);\n-    } else {\n-        xmlDtdPtr subset;\n-\n-        subset = xmlParseDTD(NULL, (xmlChar *) dtd);\n-        if (subset != NULL) {\n-            res = xmlValidateDtd(&vctxt, ctxt->doc, subset);\n-\n-            xmlFreeDtd(subset);\n-        }\n-    }\n-    return (res);\n-}\n-#endif \/* LIBXML_VALID_ENABLED *\/\n-\n-\/**\n- * xmlShellDu:\n- * @ctxt:  the shell context\n- * @arg:  unused\n- * @tree:  a node defining a subtree\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"du\"\n- * show the structure of the subtree under node @tree\n- * If @tree is null, the command works on the current node.\n- *\n- * Returns 0 or -1 in case of error\n- *\/\n-int\n-xmlShellDu(xmlShellCtxtPtr ctxt,\n-           char *arg ATTRIBUTE_UNUSED, xmlNodePtr tree,\n-           xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    xmlNodePtr node;\n-    int indent = 0, i;\n-\n-    if (!ctxt)\n-    return (-1);\n-\n-    if (tree == NULL)\n-        return (-1);\n-    node = tree;\n-    while (node != NULL) {\n-        if ((node->type == XML_DOCUMENT_NODE) ||\n-            (node->type == XML_HTML_DOCUMENT_NODE)) {\n-            fprintf(ctxt->output, \"\/\\n\");\n-        } else if (node->type == XML_ELEMENT_NODE) {\n-            for (i = 0; i < indent; i++)\n-                fprintf(ctxt->output, \"  \");\n-            if ((node->ns) && (node->ns->prefix))\n-                fprintf(ctxt->output, \"%s:\", node->ns->prefix);\n-            fprintf(ctxt->output, \"%s\\n\", node->name);\n-        } else {\n-        }\n-\n-        \/*\n-         * Browse the full subtree, deep first\n-         *\/\n-\n-        if ((node->type == XML_DOCUMENT_NODE) ||\n-            (node->type == XML_HTML_DOCUMENT_NODE)) {\n-            node = ((xmlDocPtr) node)->children;\n-        } else if ((node->children != NULL)\n-                   && (node->type != XML_ENTITY_REF_NODE)) {\n-            \/* deep first *\/\n-            node = node->children;\n-            indent++;\n-        } else if ((node != tree) && (node->next != NULL)) {\n-            \/* then siblings *\/\n-            node = node->next;\n-        } else if (node != tree) {\n-            \/* go up to parents->next if needed *\/\n-            while (node != tree) {\n-                if (node->parent != NULL) {\n-                    node = node->parent;\n-                    indent--;\n-                }\n-                if ((node != tree) && (node->next != NULL)) {\n-                    node = node->next;\n-                    break;\n-                }\n-                if (node->parent == NULL) {\n-                    node = NULL;\n-                    break;\n-                }\n-                if (node == tree) {\n-                    node = NULL;\n-                    break;\n-                }\n-            }\n-            \/* exit condition *\/\n-            if (node == tree)\n-                node = NULL;\n-        } else\n-            node = NULL;\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlShellPwd:\n- * @ctxt:  the shell context\n- * @buffer:  the output buffer\n- * @node:  a node\n- * @node2:  unused\n- *\n- * Implements the XML shell function \"pwd\"\n- * Show the full path from the root to the node, if needed building\n- * thumblers when similar elements exists at a given ancestor level.\n- * The output is compatible with XPath commands.\n- *\n- * Returns 0 or -1 in case of error\n- *\/\n-int\n-xmlShellPwd(xmlShellCtxtPtr ctxt ATTRIBUTE_UNUSED, char *buffer,\n-            xmlNodePtr node, xmlNodePtr node2 ATTRIBUTE_UNUSED)\n-{\n-    xmlChar *path;\n-\n-    if ((node == NULL) || (buffer == NULL))\n-        return (-1);\n-\n-    path = xmlGetNodePath(node);\n-    if (path == NULL)\n-    return (-1);\n-\n-    \/*\n-     * This test prevents buffer overflow, because this routine\n-     * is only called by xmlShell, in which the second argument is\n-     * 500 chars long.\n-     * It is a dirty hack before a cleaner solution is found.\n-     * Documentation should mention that the second argument must\n-     * be at least 500 chars long, and could be stripped if too long.\n-     *\/\n-    snprintf(buffer, 499, \"%s\", path);\n-    buffer[499] = '0';\n-    xmlFree(path);\n-\n-    return (0);\n-}\n-\n-\/**\n- * xmlShell:\n- * @doc:  the initial document\n- * @filename:  the output buffer\n- * @input:  the line reading function\n- * @output:  the output FILE*, defaults to stdout if NULL\n- *\n- * Implements the XML shell\n- * This allow to load, validate, view, modify and save a document\n- * using a environment similar to a UNIX commandline.\n- *\/\n-void\n-xmlShell(xmlDocPtr doc, const char *filename, xmlShellReadlineFunc input,\n-         FILE * output)\n-{\n-    char prompt[500] = \"\/ > \";\n-    char *cmdline = NULL, *cur;\n-    char command[100];\n-    char arg[400];\n-    int i;\n-    xmlShellCtxtPtr ctxt;\n-    xmlXPathObjectPtr list;\n-\n-    if (doc == NULL)\n-        return;\n-    if (filename == NULL)\n-        return;\n-    if (input == NULL)\n-        return;\n-    if (output == NULL)\n-        output = stdout;\n-    ctxt = (xmlShellCtxtPtr) xmlMalloc(sizeof(xmlShellCtxt));\n-    if (ctxt == NULL)\n-        return;\n-    ctxt->loaded = 0;\n-    ctxt->doc = doc;\n-    ctxt->input = input;\n-    ctxt->output = output;\n-    ctxt->filename = (char *) xmlStrdup((xmlChar *) filename);\n-    ctxt->node = (xmlNodePtr) ctxt->doc;\n-\n-#ifdef LIBXML_XPATH_ENABLED\n-    ctxt->pctxt = xmlXPathNewContext(ctxt->doc);\n-    if (ctxt->pctxt == NULL) {\n-        xmlFree(ctxt);\n-        return;\n-    }\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-    while (1) {\n-        if (ctxt->node == (xmlNodePtr) ctxt->doc)\n-            snprintf(prompt, sizeof(prompt), \"%s > \", \"\/\");\n-        else if ((ctxt->node != NULL) && (ctxt->node->name) &&\n-                 (ctxt->node->ns) && (ctxt->node->ns->prefix))\n-            snprintf(prompt, sizeof(prompt), \"%s:%s > \",\n-                     (ctxt->node->ns->prefix), ctxt->node->name);\n-        else if ((ctxt->node != NULL) && (ctxt->node->name))\n-            snprintf(prompt, sizeof(prompt), \"%s > \", ctxt->node->name);\n-        else\n-            snprintf(prompt, sizeof(prompt), \"? > \");\n-        prompt[sizeof(prompt) - 1] = 0;\n-\n-        \/*\n-         * Get a new command line\n-         *\/\n-        cmdline = ctxt->input(prompt);\n-        if (cmdline == NULL)\n-            break;\n-\n-        \/*\n-         * Parse the command itself\n-         *\/\n-        cur = cmdline;\n-        while ((*cur == ' ') || (*cur == '\\t'))\n-            cur++;\n-        i = 0;\n-        while ((*cur != ' ') && (*cur != '\\t') &&\n-               (*cur != '\\n') && (*cur != '\\r')) {\n-            if (*cur == 0)\n-                break;\n-            command[i++] = *cur++;\n-        }\n-        command[i] = 0;\n-        if (i == 0)\n-            continue;\n-\n-        \/*\n-         * Parse the argument\n-         *\/\n-        while ((*cur == ' ') || (*cur == '\\t'))\n-            cur++;\n-        i = 0;\n-        while ((*cur != '\\n') && (*cur != '\\r') && (*cur != 0)) {\n-            if (*cur == 0)\n-                break;\n-            arg[i++] = *cur++;\n-        }\n-        arg[i] = 0;\n-\n-        \/*\n-         * start interpreting the command\n-         *\/\n-        if (!strcmp(command, \"exit\"))\n-            break;\n-        if (!strcmp(command, \"quit\"))\n-            break;\n-        if (!strcmp(command, \"bye\"))\n-            break;\n-        if (!strcmp(command, \"help\")) {\n-          fprintf(ctxt->output, \"\\tbase         display XML base of the node\\n\");\n-          fprintf(ctxt->output, \"\\tsetbase URI  change the XML base of the node\\n\");\n-          fprintf(ctxt->output, \"\\tbye          leave shell\\n\");\n-          fprintf(ctxt->output, \"\\tcat [node]   display node or current node\\n\");\n-          fprintf(ctxt->output, \"\\tcd [path]    change directory to path or to root\\n\");\n-          fprintf(ctxt->output, \"\\tdir [path]   dumps information about the node (namespace, attributes, content)\\n\");\n-          fprintf(ctxt->output, \"\\tdu [path]    show the structure of the subtree under path or the current node\\n\");\n-          fprintf(ctxt->output, \"\\texit         leave shell\\n\");\n-          fprintf(ctxt->output, \"\\thelp         display this help\\n\");\n-          fprintf(ctxt->output, \"\\tfree         display memory usage\\n\");\n-          fprintf(ctxt->output, \"\\tload [name]  load a new document with name\\n\");\n-          fprintf(ctxt->output, \"\\tls [path]    list contents of path or the current directory\\n\");\n-          fprintf(ctxt->output, \"\\tset xml_fragment replace the current node content with the fragment parsed in context\\n\");\n-#ifdef LIBXML_XPATH_ENABLED\n-          fprintf(ctxt->output, \"\\txpath expr   evaluate the XPath expression in that context and print the result\\n\");\n-          fprintf(ctxt->output, \"\\tsetns nsreg  register a namespace to a prefix in the XPath evaluation context\\n\");\n-          fprintf(ctxt->output, \"\\t             format for nsreg is: prefix=[nsuri] (i.e. prefix= unsets a prefix)\\n\");\n-          fprintf(ctxt->output, \"\\tsetrootns    register all namespace found on the root element\\n\");\n-          fprintf(ctxt->output, \"\\t             the default namespace if any uses 'defaultns' prefix\\n\");\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-          fprintf(ctxt->output, \"\\tpwd          display current working directory\\n\");\n-          fprintf(ctxt->output, \"\\twhereis      display absolute path of [path] or current working directory\\n\");\n-          fprintf(ctxt->output, \"\\tquit         leave shell\\n\");\n-#ifdef LIBXML_OUTPUT_ENABLED\n-          fprintf(ctxt->output, \"\\tsave [name]  save this document to name or the original name\\n\");\n-          fprintf(ctxt->output, \"\\twrite [name] write the current node to the filename\\n\");\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-#ifdef LIBXML_VALID_ENABLED\n-          fprintf(ctxt->output, \"\\tvalidate     check the document for errors\\n\");\n-#endif \/* LIBXML_VALID_ENABLED *\/\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-          fprintf(ctxt->output, \"\\trelaxng rng  validate the document against the Relax-NG schemas\\n\");\n-#endif\n-          fprintf(ctxt->output, \"\\tgrep string  search for a string in the subtree\\n\");\n-#ifdef LIBXML_VALID_ENABLED\n-        } else if (!strcmp(command, \"validate\")) {\n-            xmlShellValidate(ctxt, arg, NULL, NULL);\n-#endif \/* LIBXML_VALID_ENABLED *\/\n-        } else if (!strcmp(command, \"load\")) {\n-            xmlShellLoad(ctxt, arg, NULL, NULL);\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-        } else if (!strcmp(command, \"relaxng\")) {\n-            xmlShellRNGValidate(ctxt, arg, NULL, NULL);\n-#endif\n-#ifdef LIBXML_OUTPUT_ENABLED\n-        } else if (!strcmp(command, \"save\")) {\n-            xmlShellSave(ctxt, arg, NULL, NULL);\n-        } else if (!strcmp(command, \"write\")) {\n-        if (arg[0] == 0)\n-        fprintf(ctxt->output,\n-                        \"Write command requires a filename argument\\n\");\n-        else\n-        xmlShellWrite(ctxt, arg, ctxt->node, NULL);\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-        } else if (!strcmp(command, \"grep\")) {\n-            xmlShellGrep(ctxt, arg, ctxt->node, NULL);\n-        } else if (!strcmp(command, \"pwd\")) {\n-            char dir[500];\n-\n-            if (!xmlShellPwd(ctxt, dir, ctxt->node, NULL))\n-                fprintf(ctxt->output, \"%s\\n\", dir);\n-        } else if (!strcmp(command, \"du\")) {\n-            if (arg[0] == 0) {\n-                xmlShellDu(ctxt, NULL, ctxt->node, NULL);\n-            } else {\n-                ctxt->pctxt->node = ctxt->node;\n-#ifdef LIBXML_XPATH_ENABLED\n-                ctxt->pctxt->node = ctxt->node;\n-                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);\n-#else\n-                list = NULL;\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-                if (list != NULL) {\n-                    switch (list->type) {\n-                        case XPATH_UNDEFINED:\n-                            fprintf(ctxt->output,\n-                                            \"%s: no such node\\n\", arg);\n-                            break;\n-                        case XPATH_NODESET:{\n-                            int indx;\n-\n-                            if (list->nodesetval == NULL)\n-                                break;\n-\n-                            for (indx = 0;\n-                                 indx < list->nodesetval->nodeNr;\n-                                 indx++)\n-                                xmlShellDu(ctxt, NULL,\n-                                           list->nodesetval->\n-                                           nodeTab[indx], NULL);\n-                            break;\n-                        }\n-                        case XPATH_BOOLEAN:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a Boolean\\n\", arg);\n-                            break;\n-                        case XPATH_NUMBER:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a number\\n\", arg);\n-                            break;\n-                        case XPATH_STRING:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a string\\n\", arg);\n-                            break;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-                        case XPATH_POINT:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a point\\n\", arg);\n-                            break;\n-                        case XPATH_RANGE:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a range\\n\", arg);\n-                            break;\n-                        case XPATH_LOCATIONSET:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a range\\n\", arg);\n-                            break;\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-                        case XPATH_USERS:\n-                            fprintf(ctxt->output,\n-                                            \"%s is user-defined\\n\", arg);\n-                            break;\n-                        case XPATH_XSLT_TREE:\n-                            fprintf(ctxt->output,\n-                                            \"%s is an XSLT value tree\\n\",\n-                                            arg);\n-                            break;\n-                    }\n-#ifdef LIBXML_XPATH_ENABLED\n-                    xmlXPathFreeObject(list);\n-#endif\n-                } else {\n-                    fprintf(ctxt->output,\n-                                    \"%s: no such node\\n\", arg);\n-                }\n-                ctxt->pctxt->node = NULL;\n-            }\n-        } else if (!strcmp(command, \"base\")) {\n-            xmlShellBase(ctxt, NULL, ctxt->node, NULL);\n-        } else if (!strcmp(command, \"set\")) {\n-        xmlShellSetContent(ctxt, arg, ctxt->node, NULL);\n-#ifdef LIBXML_XPATH_ENABLED\n-        } else if (!strcmp(command, \"setns\")) {\n-            if (arg[0] == 0) {\n-        fprintf(ctxt->output,\n-                \"setns: prefix=[nsuri] required\\n\");\n-            } else {\n-                xmlShellRegisterNamespace(ctxt, arg, NULL, NULL);\n-            }\n-        } else if (!strcmp(command, \"setrootns\")) {\n-        xmlNodePtr root;\n-\n-        root = xmlDocGetRootElement(ctxt->doc);\n-        xmlShellRegisterRootNamespaces(ctxt, NULL, root, NULL);\n-        } else if (!strcmp(command, \"xpath\")) {\n-            if (arg[0] == 0) {\n-        fprintf(ctxt->output,\n-                \"xpath: expression required\\n\");\n-        } else {\n-                ctxt->pctxt->node = ctxt->node;\n-                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);\n-        xmlXPathDebugDumpObject(ctxt->output, list, 0);\n-        xmlXPathFreeObject(list);\n-        }\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-#ifdef LIBXML_TREE_ENABLED\n-        } else if (!strcmp(command, \"setbase\")) {\n-            xmlShellSetBase(ctxt, arg, ctxt->node, NULL);\n-#endif\n-        } else if ((!strcmp(command, \"ls\")) || (!strcmp(command, \"dir\"))) {\n-            int dir = (!strcmp(command, \"dir\"));\n-\n-            if (arg[0] == 0) {\n-                if (dir)\n-                    xmlShellDir(ctxt, NULL, ctxt->node, NULL);\n-                else\n-                    xmlShellList(ctxt, NULL, ctxt->node, NULL);\n-            } else {\n-                ctxt->pctxt->node = ctxt->node;\n-#ifdef LIBXML_XPATH_ENABLED\n-                ctxt->pctxt->node = ctxt->node;\n-                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);\n-#else\n-                list = NULL;\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-                if (list != NULL) {\n-                    switch (list->type) {\n-                        case XPATH_UNDEFINED:\n-                            fprintf(ctxt->output,\n-                                            \"%s: no such node\\n\", arg);\n-                            break;\n-                        case XPATH_NODESET:{\n-                                int indx;\n-\n-                if (list->nodesetval == NULL)\n-                    break;\n-\n-                                for (indx = 0;\n-                                     indx < list->nodesetval->nodeNr;\n-                                     indx++) {\n-                                    if (dir)\n-                                        xmlShellDir(ctxt, NULL,\n-                                                    list->nodesetval->\n-                                                    nodeTab[indx], NULL);\n-                                    else\n-                                        xmlShellList(ctxt, NULL,\n-                                                     list->nodesetval->\n-                                                     nodeTab[indx], NULL);\n-                                }\n-                                break;\n-                            }\n-                        case XPATH_BOOLEAN:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a Boolean\\n\", arg);\n-                            break;\n-                        case XPATH_NUMBER:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a number\\n\", arg);\n-                            break;\n-                        case XPATH_STRING:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a string\\n\", arg);\n-                            break;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-                        case XPATH_POINT:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a point\\n\", arg);\n-                            break;\n-                        case XPATH_RANGE:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a range\\n\", arg);\n-                            break;\n-                        case XPATH_LOCATIONSET:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a range\\n\", arg);\n-                            break;\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-                        case XPATH_USERS:\n-                            fprintf(ctxt->output,\n-                                            \"%s is user-defined\\n\", arg);\n-                            break;\n-                        case XPATH_XSLT_TREE:\n-                            fprintf(ctxt->output,\n-                                            \"%s is an XSLT value tree\\n\",\n-                                            arg);\n-                            break;\n-                    }\n-#ifdef LIBXML_XPATH_ENABLED\n-                    xmlXPathFreeObject(list);\n-#endif\n-                } else {\n-                    fprintf(ctxt->output,\n-                                    \"%s: no such node\\n\", arg);\n-                }\n-                ctxt->pctxt->node = NULL;\n-            }\n-        } else if (!strcmp(command, \"whereis\")) {\n-            char dir[500];\n-\n-            if (arg[0] == 0) {\n-                if (!xmlShellPwd(ctxt, dir, ctxt->node, NULL))\n-                    fprintf(ctxt->output, \"%s\\n\", dir);\n-            } else {\n-                ctxt->pctxt->node = ctxt->node;\n-#ifdef LIBXML_XPATH_ENABLED\n-                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);\n-#else\n-                list = NULL;\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-                if (list != NULL) {\n-                    switch (list->type) {\n-                        case XPATH_UNDEFINED:\n-                            fprintf(ctxt->output,\n-                                            \"%s: no such node\\n\", arg);\n-                            break;\n-                        case XPATH_NODESET:{\n-                                int indx;\n-\n-                if (list->nodesetval == NULL)\n-                    break;\n-\n-                                for (indx = 0;\n-                                     indx < list->nodesetval->nodeNr;\n-                                     indx++) {\n-                                    if (!xmlShellPwd(ctxt, dir, list->nodesetval->\n-                                                     nodeTab[indx], NULL))\n-                                        fprintf(ctxt->output, \"%s\\n\", dir);\n-                                }\n-                                break;\n-                            }\n-                        case XPATH_BOOLEAN:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a Boolean\\n\", arg);\n-                            break;\n-                        case XPATH_NUMBER:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a number\\n\", arg);\n-                            break;\n-                        case XPATH_STRING:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a string\\n\", arg);\n-                            break;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-                        case XPATH_POINT:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a point\\n\", arg);\n-                            break;\n-                        case XPATH_RANGE:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a range\\n\", arg);\n-                            break;\n-                        case XPATH_LOCATIONSET:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a range\\n\", arg);\n-                            break;\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-                        case XPATH_USERS:\n-                            fprintf(ctxt->output,\n-                                            \"%s is user-defined\\n\", arg);\n-                            break;\n-                        case XPATH_XSLT_TREE:\n-                            fprintf(ctxt->output,\n-                                            \"%s is an XSLT value tree\\n\",\n-                                            arg);\n-                            break;\n-                    }\n-#ifdef LIBXML_XPATH_ENABLED\n-                    xmlXPathFreeObject(list);\n-#endif\n-                } else {\n-                    fprintf(ctxt->output,\n-                                    \"%s: no such node\\n\", arg);\n-                }\n-                ctxt->pctxt->node = NULL;\n-            }\n-        } else if (!strcmp(command, \"cd\")) {\n-            if (arg[0] == 0) {\n-                ctxt->node = (xmlNodePtr) ctxt->doc;\n-            } else {\n-#ifdef LIBXML_XPATH_ENABLED\n-                int l;\n-\n-                ctxt->pctxt->node = ctxt->node;\n-        l = strlen(arg);\n-        if ((l >= 2) && (arg[l - 1] == '\/'))\n-            arg[l - 1] = 0;\n-                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);\n-#else\n-                list = NULL;\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-                if (list != NULL) {\n-                    switch (list->type) {\n-                        case XPATH_UNDEFINED:\n-                            fprintf(ctxt->output,\n-                                            \"%s: no such node\\n\", arg);\n-                            break;\n-                        case XPATH_NODESET:\n-                            if (list->nodesetval != NULL) {\n-                if (list->nodesetval->nodeNr == 1) {\n-                    ctxt->node = list->nodesetval->nodeTab[0];\n-                    if ((ctxt->node != NULL) &&\n-                        (ctxt->node->type ==\n-                     XML_NAMESPACE_DECL)) {\n-                    fprintf(ctxt->output,\n-                            \"cannot cd to namespace\\n\");\n-                    ctxt->node = NULL;\n-                    }\n-                } else\n-                    fprintf(ctxt->output,\n-                            \"%s is a %d Node Set\\n\",\n-                            arg,\n-                            list->nodesetval->nodeNr);\n-                            } else\n-                                fprintf(ctxt->output,\n-                                                \"%s is an empty Node Set\\n\",\n-                                                arg);\n-                            break;\n-                        case XPATH_BOOLEAN:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a Boolean\\n\", arg);\n-                            break;\n-                        case XPATH_NUMBER:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a number\\n\", arg);\n-                            break;\n-                        case XPATH_STRING:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a string\\n\", arg);\n-                            break;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-                        case XPATH_POINT:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a point\\n\", arg);\n-                            break;\n-                        case XPATH_RANGE:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a range\\n\", arg);\n-                            break;\n-                        case XPATH_LOCATIONSET:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a range\\n\", arg);\n-                            break;\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-                        case XPATH_USERS:\n-                            fprintf(ctxt->output,\n-                                            \"%s is user-defined\\n\", arg);\n-                            break;\n-                        case XPATH_XSLT_TREE:\n-                            fprintf(ctxt->output,\n-                                            \"%s is an XSLT value tree\\n\",\n-                                            arg);\n-                            break;\n-                    }\n-#ifdef LIBXML_XPATH_ENABLED\n-                    xmlXPathFreeObject(list);\n-#endif\n-                } else {\n-                    fprintf(ctxt->output,\n-                                    \"%s: no such node\\n\", arg);\n-                }\n-                ctxt->pctxt->node = NULL;\n-            }\n-#ifdef LIBXML_OUTPUT_ENABLED\n-        } else if (!strcmp(command, \"cat\")) {\n-            if (arg[0] == 0) {\n-                xmlShellCat(ctxt, NULL, ctxt->node, NULL);\n-            } else {\n-                ctxt->pctxt->node = ctxt->node;\n-#ifdef LIBXML_XPATH_ENABLED\n-                ctxt->pctxt->node = ctxt->node;\n-                list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);\n-#else\n-                list = NULL;\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-                if (list != NULL) {\n-                    switch (list->type) {\n-                        case XPATH_UNDEFINED:\n-                            fprintf(ctxt->output,\n-                                            \"%s: no such node\\n\", arg);\n-                            break;\n-                        case XPATH_NODESET:{\n-                                int indx;\n-\n-                if (list->nodesetval == NULL)\n-                    break;\n-\n-                                for (indx = 0;\n-                                     indx < list->nodesetval->nodeNr;\n-                                     indx++) {\n-                                    if (i > 0)\n-                                        fprintf(ctxt->output, \" -------\\n\");\n-                                    xmlShellCat(ctxt, NULL,\n-                                                list->nodesetval->\n-                                                nodeTab[indx], NULL);\n-                                }\n-                                break;\n-                            }\n-                        case XPATH_BOOLEAN:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a Boolean\\n\", arg);\n-                            break;\n-                        case XPATH_NUMBER:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a number\\n\", arg);\n-                            break;\n-                        case XPATH_STRING:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a string\\n\", arg);\n-                            break;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-                        case XPATH_POINT:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a point\\n\", arg);\n-                            break;\n-                        case XPATH_RANGE:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a range\\n\", arg);\n-                            break;\n-                        case XPATH_LOCATIONSET:\n-                            fprintf(ctxt->output,\n-                                            \"%s is a range\\n\", arg);\n-                            break;\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-                        case XPATH_USERS:\n-                            fprintf(ctxt->output,\n-                                            \"%s is user-defined\\n\", arg);\n-                            break;\n-                        case XPATH_XSLT_TREE:\n-                            fprintf(ctxt->output,\n-                                            \"%s is an XSLT value tree\\n\",\n-                                            arg);\n-                            break;\n-                    }\n-#ifdef LIBXML_XPATH_ENABLED\n-                    xmlXPathFreeObject(list);\n-#endif\n-                } else {\n-                    fprintf(ctxt->output,\n-                                    \"%s: no such node\\n\", arg);\n-                }\n-                ctxt->pctxt->node = NULL;\n-            }\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-        } else {\n-            fprintf(ctxt->output,\n-                            \"Unknown command %s\\n\", command);\n-        }\n-        free(cmdline);          \/* not xmlFree here ! *\/\n-    cmdline = NULL;\n-    }\n-#ifdef LIBXML_XPATH_ENABLED\n-    xmlXPathFreeContext(ctxt->pctxt);\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-    if (ctxt->loaded) {\n-        xmlFreeDoc(ctxt->doc);\n-    }\n-    if (ctxt->filename != NULL)\n-        xmlFree(ctxt->filename);\n-    xmlFree(ctxt);\n-    if (cmdline != NULL)\n-        free(cmdline);          \/* not xmlFree here ! *\/\n-}\n-\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-\n-#endif \/* LIBXML_DEBUG_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/debugXML.c","additions":0,"deletions":3416,"binary":false,"changes":3416,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-## Process this file with automake to produce Makefile.in\n-SUBDIRS=libxml private\n-\n-EXTRA_DIST = win32config.h wsockcompat.h meson.build\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/Makefile.am","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-## Process this file with automake to produce Makefile.in\n-\n-xmlincdir = $(includedir)\/libxml2\/libxml\n-\n-xmlinc_HEADERS = \\\n-\t\tSAX.h \\\n-\t\tentities.h \\\n-\t\tencoding.h \\\n-\t\tparser.h \\\n-\t\tparserInternals.h \\\n-\t\txmlerror.h \\\n-\t\tHTMLparser.h \\\n-\t\tHTMLtree.h \\\n-\t\tdebugXML.h \\\n-\t\ttree.h \\\n-\t\tlist.h \\\n-\t\thash.h \\\n-\t\txpath.h \\\n-\t\txpathInternals.h \\\n-\t\txpointer.h \\\n-\t\txinclude.h \\\n-\t\txmlIO.h \\\n-\t\txmlmemory.h \\\n-\t\tnanohttp.h \\\n-\t\tnanoftp.h \\\n-\t\turi.h \\\n-\t\tvalid.h \\\n-\t\txlink.h \\\n-\t\tcatalog.h \\\n-\t\tthreads.h \\\n-\t\tglobals.h \\\n-\t\tc14n.h \\\n-\t\txmlautomata.h \\\n-\t\txmlregexp.h \\\n-\t\txmlmodule.h \\\n-\t\txmlschemas.h \\\n-\t\tschemasInternals.h \\\n-\t\txmlschemastypes.h \\\n-\t\txmlstring.h \\\n-\t\txmlunicode.h \\\n-\t\txmlreader.h \\\n-\t\trelaxng.h \\\n-\t\tdict.h \\\n-\t\tSAX2.h \\\n-\t\txmlexports.h \\\n-\t\txmlwriter.h \\\n-\t\tchvalid.h \\\n-\t\tpattern.h \\\n-\t\txmlsave.h \\\n-\t\tschematron.h\n-\n-nodist_xmlinc_HEADERS = xmlversion.h\n-\n-EXTRA_DIST = xmlversion.h.in meson.build\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/Makefile.am","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,101 +0,0 @@\n-\n-## xmlversion.h\n-xmlversion_h = configuration_data()\n-xmlversion_h.set('VERSION', meson.project_version())\n-xmlversion_h.set('LIBXML_VERSION_NUMBER', v_nbr.to_string())\n-xmlversion_h.set('LIBXML_VERSION_EXTRA', v_extra)\n-xmlversion_h.set10('WITH_C14N', want_c14n)\n-xmlversion_h.set10('WITH_CATALOG', want_catalog)\n-xmlversion_h.set10('WITH_DEBUG', want_debug)\n-xmlversion_h.set10('WITH_FTP', want_ftp)\n-xmlversion_h.set10('WITH_HTML', want_html)\n-xmlversion_h.set10('WITH_HTTP', want_http)\n-xmlversion_h.set10('WITH_ICONV', iconv_dep.found())\n-xmlversion_h.set10('WITH_ICU', icu_dep.found())\n-xmlversion_h.set10('WITH_ISO8859X', want_iso8859x)\n-xmlversion_h.set10('WITH_LEGACY', want_legacy)\n-xmlversion_h.set10('WITH_LZMA', lzma_dep.found())\n-xmlversion_h.set10('WITH_MODULES', dl_dep.found())\n-xmlversion_h.set('MODULE_EXTENSION', module_extension)\n-xmlversion_h.set10('WITH_OUTPUT', want_output)\n-xmlversion_h.set10('WITH_PATTERN', want_pattern)\n-xmlversion_h.set10('WITH_PUSH', want_push)\n-xmlversion_h.set10('WITH_READER', want_reader)\n-xmlversion_h.set10('WITH_REGEXPS', want_regexps)\n-xmlversion_h.set10('WITH_SAX1', want_sax1)\n-xmlversion_h.set10('WITH_SCHEMAS', want_schemas)\n-xmlversion_h.set10('WITH_SCHEMATRON', want_schematron)\n-xmlversion_h.set10('WITH_THREADS', threads_dep.found())\n-xmlversion_h.set10('WITH_THREAD_ALLOC', want_thread_alloc)\n-xmlversion_h.set10('WITH_TREE', want_tree)\n-xmlversion_h.set10('WITH_VALID', want_valid)\n-xmlversion_h.set10('WITH_WRITER', want_writer)\n-xmlversion_h.set10('WITH_XINCLUDE', want_xinclude)\n-xmlversion_h.set10('WITH_XPATH', want_xpath)\n-xmlversion_h.set10('WITH_XPTR', want_xptr)\n-xmlversion_h.set10('WITH_XPTR_LOCS', want_xptr_locs)\n-xmlversion_h.set10('WITH_ZLIB', zlib_dep.found())\n-\n-configure_file(\n-    input: 'xmlversion.h.in',\n-    output: 'xmlversion.h',\n-    configuration: xmlversion_h,\n-    install_dir: dir_pkginclude + '\/libxml',\n-)\n-\n-#vcs_tag(\n-#  command : [ 'git', 'describe', '2>\/dev\/null' ],\n-#  input : 'xmlversion.h.in',\n-#  output : 'xmlversion.h',\n-#  replace_string : 'LIBXML_VERSION_EXTRA'\n-#)\n-\n-libxml_headers = files(\n-    'HTMLparser.h',\n-    'HTMLtree.h',\n-    'SAX.h',\n-    'SAX2.h',\n-    'c14n.h',\n-    'catalog.h',\n-    'chvalid.h',\n-    'debugXML.h',\n-    'dict.h',\n-    'encoding.h',\n-    'entities.h',\n-    'globals.h',\n-    'hash.h',\n-    'list.h',\n-    'nanoftp.h',\n-    'nanohttp.h',\n-    'parser.h',\n-    'parserInternals.h',\n-    'pattern.h',\n-    'relaxng.h',\n-    'schemasInternals.h',\n-    'schematron.h',\n-    'threads.h',\n-    'tree.h',\n-    'uri.h',\n-    'valid.h',\n-    'xinclude.h',\n-    'xlink.h',\n-    'xmlIO.h',\n-    'xmlautomata.h',\n-    'xmlerror.h',\n-    'xmlexports.h',\n-    'xmlmemory.h',\n-    'xmlmodule.h',\n-    'xmlreader.h',\n-    'xmlregexp.h',\n-    'xmlsave.h',\n-    'xmlschemas.h',\n-    'xmlschemastypes.h',\n-    'xmlstring.h',\n-    'xmlunicode.h',\n-    'xmlwriter.h',\n-    'xpath.h',\n-    'xpathInternals.h',\n-    'xpointer.h',\n-)\n-\n-install_headers(libxml_headers, install_dir: dir_pkginclude \/ 'libxml')\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/meson.build","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -1,347 +0,0 @@\n-\/*\n- * Summary: compile-time version information\n- * Description: compile-time version information for the XML library\n- *\n- * Copy: See Copyright for the status of this software.\n- *\n- * Author: Daniel Veillard\n- *\/\n-\n-#ifndef __XML_VERSION_H__\n-#define __XML_VERSION_H__\n-\n-\/**\n- * LIBXML_DOTTED_VERSION:\n- *\n- * the version string like \"1.2.3\"\n- *\/\n-#define LIBXML_DOTTED_VERSION \"@VERSION@\"\n-\n-\/**\n- * LIBXML_VERSION:\n- *\n- * the version number: 1.2.3 value is 10203\n- *\/\n-#define LIBXML_VERSION @LIBXML_VERSION_NUMBER@\n-\n-\/**\n- * LIBXML_VERSION_STRING:\n- *\n- * the version number string, 1.2.3 value is \"10203\"\n- *\/\n-#define LIBXML_VERSION_STRING \"@LIBXML_VERSION_NUMBER@\"\n-\n-\/**\n- * LIBXML_VERSION_EXTRA:\n- *\n- * extra version information, used to show a git commit description\n- *\/\n-#define LIBXML_VERSION_EXTRA \"@LIBXML_VERSION_EXTRA@\"\n-\n-\/**\n- * LIBXML_TEST_VERSION:\n- *\n- * Macro to check that the libxml version in use is compatible with\n- * the version the software has been compiled against\n- *\/\n-#define LIBXML_TEST_VERSION xmlCheckVersion(@LIBXML_VERSION_NUMBER@);\n-\n-\/**\n- * LIBXML_THREAD_ENABLED:\n- *\n- * Whether the thread support is configured in\n- *\/\n-#if @WITH_THREADS@\n-#define LIBXML_THREAD_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_THREAD_ALLOC_ENABLED:\n- *\n- * Whether the allocation hooks are per-thread\n- *\/\n-#if @WITH_THREAD_ALLOC@\n-#define LIBXML_THREAD_ALLOC_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_TREE_ENABLED:\n- *\n- * Whether the DOM like tree manipulation API support is configured in\n- *\/\n-#if @WITH_TREE@\n-#define LIBXML_TREE_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_OUTPUT_ENABLED:\n- *\n- * Whether the serialization\/saving support is configured in\n- *\/\n-#if @WITH_OUTPUT@\n-#define LIBXML_OUTPUT_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_PUSH_ENABLED:\n- *\n- * Whether the push parsing interfaces are configured in\n- *\/\n-#if @WITH_PUSH@\n-#define LIBXML_PUSH_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_READER_ENABLED:\n- *\n- * Whether the xmlReader parsing interface is configured in\n- *\/\n-#if @WITH_READER@\n-#define LIBXML_READER_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_PATTERN_ENABLED:\n- *\n- * Whether the xmlPattern node selection interface is configured in\n- *\/\n-#if @WITH_PATTERN@\n-#define LIBXML_PATTERN_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_WRITER_ENABLED:\n- *\n- * Whether the xmlWriter saving interface is configured in\n- *\/\n-#if @WITH_WRITER@\n-#define LIBXML_WRITER_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_SAX1_ENABLED:\n- *\n- * Whether the older SAX1 interface is configured in\n- *\/\n-#if @WITH_SAX1@\n-#define LIBXML_SAX1_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_FTP_ENABLED:\n- *\n- * Whether the FTP support is configured in\n- *\/\n-#if @WITH_FTP@\n-#define LIBXML_FTP_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_HTTP_ENABLED:\n- *\n- * Whether the HTTP support is configured in\n- *\/\n-#if @WITH_HTTP@\n-#define LIBXML_HTTP_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_VALID_ENABLED:\n- *\n- * Whether the DTD validation support is configured in\n- *\/\n-#if @WITH_VALID@\n-#define LIBXML_VALID_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_HTML_ENABLED:\n- *\n- * Whether the HTML support is configured in\n- *\/\n-#if @WITH_HTML@\n-#define LIBXML_HTML_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_LEGACY_ENABLED:\n- *\n- * Whether the deprecated APIs are compiled in for compatibility\n- *\/\n-#if @WITH_LEGACY@\n-#define LIBXML_LEGACY_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_C14N_ENABLED:\n- *\n- * Whether the Canonicalization support is configured in\n- *\/\n-#if @WITH_C14N@\n-#define LIBXML_C14N_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_CATALOG_ENABLED:\n- *\n- * Whether the Catalog support is configured in\n- *\/\n-#if @WITH_CATALOG@\n-#define LIBXML_CATALOG_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_XPATH_ENABLED:\n- *\n- * Whether XPath is configured in\n- *\/\n-#if @WITH_XPATH@\n-#define LIBXML_XPATH_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_XPTR_ENABLED:\n- *\n- * Whether XPointer is configured in\n- *\/\n-#if @WITH_XPTR@\n-#define LIBXML_XPTR_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_XPTR_LOCS_ENABLED:\n- *\n- * Whether support for XPointer locations is configured in\n- *\/\n-#if @WITH_XPTR_LOCS@\n-#define LIBXML_XPTR_LOCS_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_XINCLUDE_ENABLED:\n- *\n- * Whether XInclude is configured in\n- *\/\n-#if @WITH_XINCLUDE@\n-#define LIBXML_XINCLUDE_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_ICONV_ENABLED:\n- *\n- * Whether iconv support is available\n- *\/\n-#if @WITH_ICONV@\n-#define LIBXML_ICONV_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_ICU_ENABLED:\n- *\n- * Whether icu support is available\n- *\/\n-#if @WITH_ICU@\n-#define LIBXML_ICU_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_ISO8859X_ENABLED:\n- *\n- * Whether ISO-8859-* support is made available in case iconv is not\n- *\/\n-#if @WITH_ISO8859X@\n-#define LIBXML_ISO8859X_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_DEBUG_ENABLED:\n- *\n- * Whether Debugging module is configured in\n- *\/\n-#if @WITH_DEBUG@\n-#define LIBXML_DEBUG_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_UNICODE_ENABLED:\n- *\n- * Whether the Unicode related interfaces are compiled in\n- *\/\n-#if @WITH_REGEXPS@\n-#define LIBXML_UNICODE_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_REGEXP_ENABLED:\n- *\n- * Whether the regular expressions interfaces are compiled in\n- *\/\n-#if @WITH_REGEXPS@\n-#define LIBXML_REGEXP_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_AUTOMATA_ENABLED:\n- *\n- * Whether the automata interfaces are compiled in\n- *\/\n-#if @WITH_REGEXPS@\n-#define LIBXML_AUTOMATA_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_SCHEMAS_ENABLED:\n- *\n- * Whether the Schemas validation interfaces are compiled in\n- *\/\n-#if @WITH_SCHEMAS@\n-#define LIBXML_SCHEMAS_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_SCHEMATRON_ENABLED:\n- *\n- * Whether the Schematron validation interfaces are compiled in\n- *\/\n-#if @WITH_SCHEMATRON@\n-#define LIBXML_SCHEMATRON_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_MODULES_ENABLED:\n- *\n- * Whether the module interfaces are compiled in\n- *\/\n-#if @WITH_MODULES@\n-#define LIBXML_MODULES_ENABLED\n-\/**\n- * LIBXML_MODULE_EXTENSION:\n- *\n- * the string suffix used by dynamic modules (usually shared libraries)\n- *\/\n-#define LIBXML_MODULE_EXTENSION \"@MODULE_EXTENSION@\" \n-#endif\n-\n-\/**\n- * LIBXML_ZLIB_ENABLED:\n- *\n- * Whether the Zlib support is compiled in\n- *\/\n-#if @WITH_ZLIB@\n-#define LIBXML_ZLIB_ENABLED\n-#endif\n-\n-\/**\n- * LIBXML_LZMA_ENABLED:\n- *\n- * Whether the Lzma support is compiled in\n- *\/\n-#if @WITH_LZMA@\n-#define LIBXML_LZMA_ENABLED\n-#endif\n-\n-#include <libxml\/xmlexports.h>\n-\n-#endif\n-\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlversion.h.in","additions":0,"deletions":347,"binary":false,"changes":347,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-\n-inc_dir = include_directories('.')\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/meson.build","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,19 +0,0 @@\n-EXTRA_DIST = \\\n-\tbuf.h \\\n-\tdict.h \\\n-\tenc.h \\\n-\tentities.h \\\n-\terror.h \\\n-\tglobals.h \\\n-\thtml.h \\\n-\tio.h \\\n-\tmemory.h \\\n-\tparser.h \\\n-\tregexp.h \\\n-\tsave.h \\\n-\tstring.h \\\n-\tthreads.h \\\n-\ttree.h \\\n-\txinclude.h \\\n-\txpath.h \\\n-\txzlib.h\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/Makefile.am","additions":0,"deletions":19,"binary":false,"changes":19,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-#ifndef XML_INCLUDE_H_PRIVATE__\n-#define XML_INCLUDE_H_PRIVATE__\n-\n-#include <libxml\/xinclude.h>\n-\n-XML_HIDDEN int\n-xmlXIncludeSetStreamingMode(xmlXIncludeCtxtPtr ctxt, int mode);\n-\n-#endif \/* XML_INCLUDE_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/xinclude.h","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/**\n- * xzlib.h: header for the front end for the transparent support of lzma\n- *          compression at the I\/O layer\n- *\n- * See Copyright for the status of this software.\n- *\n- * Anders F Bjorklund <afb@users.sourceforge.net>\n- *\/\n-\n-#ifndef LIBXML2_XZLIB_H\n-#define LIBXML2_XZLIB_H\n-\n-#include <libxml\/xmlversion.h>\n-\n-#ifdef LIBXML_LZMA_ENABLED\n-\n-typedef void *xzFile;           \/* opaque lzma file descriptor *\/\n-\n-XML_HIDDEN xzFile\n-__libxml2_xzopen(const char *path, const char *mode);\n-XML_HIDDEN xzFile\n-__libxml2_xzdopen(const char *path, int fd, const char *mode);\n-XML_HIDDEN int\n-__libxml2_xzread(xzFile file, void *buf, unsigned len);\n-XML_HIDDEN int\n-__libxml2_xzclose(xzFile file);\n-XML_HIDDEN int\n-__libxml2_xzcompressed(xzFile f);\n-\n-#endif \/* LIBXML_LZMA_ENABLED *\/\n-\n-#endif \/* LIBXML2_XZLIB_H *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/xzlib.h","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-prefix=\n-exec_prefix=\n-libdir=${pcfiledir}\n-includedir=${pcfiledir}\/include\n-modules=@WITH_MODULES@\n-\n-Name: libXML\n-Version: @VERSION@\n-Description: libXML library version2.\n-Requires@XML_PC_PRIVATE@: @XML_PC_REQUIRES@\n-Libs: -L${libdir} @XML_LIBS@ @XML_PC_LIBS_PRIVATE@ @XML_PC_LIBS@ @LIBS@\n-Cflags: @XML_INCLUDEDIR@ @XML_CFLAGS@\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml-2.0-uninstalled.pc.in","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-prefix=@prefix@\n-exec_prefix=@exec_prefix@\n-libdir=@libdir@\n-includedir=@includedir@\n-modules=@WITH_MODULES@\n-\n-Name: libXML\n-Version: @VERSION@\n-Description: libXML library version2.\n-Requires@XML_PC_PRIVATE@: @XML_PC_REQUIRES@\n-Libs: -L${libdir} @XML_LIBS@ @XML_PC_LIBS_PRIVATE@ @XML_PC_LIBS@ @LIBS@\n-Cflags: @XML_INCLUDEDIR@ @XML_CFLAGS@\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml-2.0.pc.in","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -1,14 +0,0 @@\n-dnl AM_PATH_XML2([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])\n-dnl Test for XML, and define XML_CPPFLAGS and XML_LIBS\n-dnl\n-AC_DEFUN([AM_PATH_XML2],[\n-  m4_warn([obsolete], [AM_PATH_XML2 is deprecated, use PKG_CHECK_MODULES instead])\n-  AC_REQUIRE([PKG_PROG_PKG_CONFIG])\n-\n-  verdep=ifelse([$1], [], [], [\">= $1\"])\n-  PKG_CHECK_MODULES(XML, [libxml-2.0 $verdep], [$2], [$3])\n-\n-  XML_CPPFLAGS=$XML_CFLAGS\n-  AC_SUBST(XML_CPPFLAGS)\n-  AC_SUBST(XML_LIBS)\n-])\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml.m4","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -1,145 +0,0 @@\n-# libxml2-config.cmake\n-# --------------------\n-#\n-# Libxml2 cmake module.\n-# This module sets the following variables:\n-#\n-# ::\n-#\n-#   LIBXML2_FOUND              - True if libxml2 headers and libraries were found\n-#   LIBXML2_INCLUDE_DIR        - Directory where LibXml2 headers are located.\n-#   LIBXML2_INCLUDE_DIRS       - list of the include directories needed to use LibXml2.\n-#   LIBXML2_LIBRARY            - path to the LibXml2 library.\n-#   LIBXML2_LIBRARIES          - xml2 libraries to link against.\n-#   LIBXML2_DEFINITIONS        - the compiler switches required for using LibXml2.\n-#   LIBXML2_VERSION_MAJOR      - The major version of libxml2.\n-#   LIBXML2_VERSION_MINOR      - The minor version of libxml2.\n-#   LIBXML2_VERSION_PATCH      - The patch version of libxml2.\n-#   LIBXML2_VERSION_STRING     - version number as a string (ex: \"2.3.4\")\n-#   LIBXML2_MODULES            - whether libxml2 has dso support\n-#   LIBXML2_XMLLINT_EXECUTABLE - path to the XML checking tool xmllint coming with LibXml2\n-#\n-# The following targets are defined:\n-#\n-#   LibXml2::LibXml2          - the LibXml2 library\n-#   LibXml2::xmllint          - the xmllint command-line executable\n-\n-get_filename_component(_libxml2_rootdir ${CMAKE_CURRENT_LIST_DIR}\/..\/..\/..\/ ABSOLUTE)\n-\n-set(LIBXML2_VERSION_MAJOR  @LIBXML_MAJOR_VERSION@)\n-set(LIBXML2_VERSION_MINOR  @LIBXML_MINOR_VERSION@)\n-set(LIBXML2_VERSION_MICRO  @LIBXML_MICRO_VERSION@)\n-set(LIBXML2_VERSION_STRING \"@VERSION@\")\n-set(LIBXML2_DEFINITIONS    \"@XML_CFLAGS@\")\n-set(LIBXML2_INSTALL_PREFIX ${_libxml2_rootdir})\n-set(LIBXML2_INCLUDE_DIR    ${_libxml2_rootdir}\/include\/libxml2)\n-set(LIBXML2_LIBRARY_DIR    ${_libxml2_rootdir}\/lib)\n-\n-find_library(LIBXML2_LIBRARY NAMES xml2 HINTS ${LIBXML2_LIBRARY_DIR} NO_DEFAULT_PATH)\n-find_program(LIBXML2_XMLCATALOG_EXECUTABLE NAMES xmlcatalog HINTS ${_libxml2_rootdir}\/bin NO_DEFAULT_PATH)\n-find_program(LIBXML2_XMLLINT_EXECUTABLE NAMES xmllint HINTS ${_libxml2_rootdir}\/bin NO_DEFAULT_PATH)\n-\n-set(LIBXML2_LIBRARIES ${LIBXML2_LIBRARY})\n-set(LIBXML2_INCLUDE_DIRS ${LIBXML2_INCLUDE_DIR})\n-unset(LIBXML2_INTERFACE_LINK_LIBRARIES)\n-\n-include(CMakeFindDependencyMacro)\n-\n-set(LIBXML2_WITH_ICONV @WITH_ICONV@)\n-set(LIBXML2_WITH_THREADS @WITH_THREADS@)\n-set(LIBXML2_WITH_ICU @WITH_ICU@)\n-set(LIBXML2_WITH_LZMA @WITH_LZMA@)\n-set(LIBXML2_WITH_ZLIB @WITH_ZLIB@)\n-\n-if(LIBXML2_WITH_ICONV)\n-  find_dependency(Iconv)\n-  list(APPEND LIBXML2_LIBRARIES    ${Iconv_LIBRARIES})\n-  list(APPEND LIBXML2_INCLUDE_DIRS ${Iconv_INCLUDE_DIRS})\n-  list(APPEND LIBXML2_INTERFACE_LINK_LIBRARIES \"Iconv::Iconv\")\n-  if(NOT Iconv_FOUND)\n-    set(${CMAKE_FIND_PACKAGE_NAME}_FOUND FALSE)\n-    set(${CMAKE_FIND_PACKAGE_NAME}_NOT_FOUND_MESSAGE \"Iconv dependency was not found\")\n-    return()\n-  endif()\n-endif()\n-\n-if(LIBXML2_WITH_THREADS)\n-  find_dependency(Threads)\n-  list(APPEND LIBXML2_LIBRARIES    ${CMAKE_THREAD_LIBS_INIT})\n-  list(APPEND LIBXML2_INTERFACE_LINK_LIBRARIES \"\\$<LINK_ONLY:Threads::Threads>\")\n-  if(NOT Threads_FOUND)\n-    set(${CMAKE_FIND_PACKAGE_NAME}_FOUND FALSE)\n-    set(${CMAKE_FIND_PACKAGE_NAME}_NOT_FOUND_MESSAGE \"Threads dependency was not found\")\n-    return()\n-  endif()\n-endif()\n-\n-if(LIBXML2_WITH_ICU)\n-  find_dependency(ICU COMPONENTS data i18n uc)\n-  list(APPEND LIBXML2_LIBRARIES    ${ICU_LIBRARIES})\n-  list(APPEND LIBXML2_INTERFACE_LINK_LIBRARIES \"\\$<LINK_ONLY:ICU::data>;\\$<LINK_ONLY:ICU::i18n>;\\$<LINK_ONLY:ICU::uc>\")\n-  if(NOT ICU_FOUND)\n-    set(${CMAKE_FIND_PACKAGE_NAME}_FOUND FALSE)\n-    set(${CMAKE_FIND_PACKAGE_NAME}_NOT_FOUND_MESSAGE \"ICU dependency was not found\")\n-    return()\n-  endif()\n-endif()\n-\n-if(LIBXML2_WITH_LZMA)\n-  find_dependency(LibLZMA)\n-  list(APPEND LIBXML2_LIBRARIES    ${LIBLZMA_LIBRARIES})\n-  list(APPEND LIBXML2_INTERFACE_LINK_LIBRARIES \"\\$<LINK_ONLY:LibLZMA::LibLZMA>\")\n-  if(NOT LibLZMA_FOUND)\n-    set(${CMAKE_FIND_PACKAGE_NAME}_FOUND FALSE)\n-    set(${CMAKE_FIND_PACKAGE_NAME}_NOT_FOUND_MESSAGE \"LibLZMA dependency was not found\")\n-    return()\n-  endif()\n-endif()\n-\n-if(LIBXML2_WITH_ZLIB)\n-  find_dependency(ZLIB)\n-  list(APPEND LIBXML2_LIBRARIES    ${ZLIB_LIBRARIES})\n-  list(APPEND LIBXML2_INTERFACE_LINK_LIBRARIES \"\\$<LINK_ONLY:ZLIB::ZLIB>\")\n-  if(NOT ZLIB_FOUND)\n-    set(${CMAKE_FIND_PACKAGE_NAME}_FOUND FALSE)\n-    set(${CMAKE_FIND_PACKAGE_NAME}_NOT_FOUND_MESSAGE \"ZLIB dependency was not found\")\n-    return()\n-  endif()\n-endif()\n-\n-if(UNIX)\n-  list(APPEND LIBXML2_LIBRARIES    m)\n-  list(APPEND LIBXML2_INTERFACE_LINK_LIBRARIES \"\\$<LINK_ONLY:m>\")\n-endif()\n-\n-if(WIN32)\n-  list(APPEND LIBXML2_LIBRARIES    ws2_32;Bcrypt)\n-  list(APPEND LIBXML2_INTERFACE_LINK_LIBRARIES \"\\$<LINK_ONLY:ws2_32>;\\$<LINK_ONLY:Bcrypt>\")\n-endif()\n-\n-# whether libxml2 has dso support\n-set(LIBXML2_MODULES @WITH_MODULES@)\n-\n-mark_as_advanced(LIBXML2_LIBRARY LIBXML2_XMLCATALOG_EXECUTABLE LIBXML2_XMLLINT_EXECUTABLE)\n-\n-if(DEFINED LIBXML2_LIBRARY AND DEFINED LIBXML2_INCLUDE_DIRS)\n-  set(LIBXML2_FOUND TRUE)\n-endif()\n-\n-if(NOT TARGET LibXml2::LibXml2 AND DEFINED LIBXML2_LIBRARY AND DEFINED LIBXML2_INCLUDE_DIRS)\n-  add_library(LibXml2::LibXml2 UNKNOWN IMPORTED)\n-  set_target_properties(LibXml2::LibXml2 PROPERTIES IMPORTED_LOCATION \"${LIBXML2_LIBRARY}\")\n-  set_target_properties(LibXml2::LibXml2 PROPERTIES INTERFACE_COMPILE_OPTIONS \"${LIBXML2_DEFINITIONS}\")\n-  set_target_properties(LibXml2::LibXml2 PROPERTIES INTERFACE_INCLUDE_DIRECTORIES \"${LIBXML2_INCLUDE_DIRS}\")\n-  set_target_properties(LibXml2::LibXml2 PROPERTIES INTERFACE_LINK_LIBRARIES \"${LIBXML2_INTERFACE_LINK_LIBRARIES}\")\n-endif()\n-\n-if(NOT TARGET LibXml2::xmlcatalog AND DEFINED LIBXML2_XMLCATALOG_EXECUTABLE)\n-  add_executable(LibXml2::xmlcatalog IMPORTED)\n-  set_target_properties(LibXml2::xmlcatalog PROPERTIES IMPORTED_LOCATION \"${LIBXML2_XMLCATALOG_EXECUTABLE}\")\n-endif()\n-\n-if(NOT TARGET LibXml2::xmllint AND DEFINED LIBXML2_XMLLINT_EXECUTABLE)\n-  add_executable(LibXml2::xmllint IMPORTED)\n-  set_target_properties(LibXml2::xmllint PROPERTIES IMPORTED_LOCATION \"${LIBXML2_XMLLINT_EXECUTABLE}\")\n-endif()\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml2-config.cmake.in","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -1,2285 +0,0 @@\n-#\n-# Retained for backward compatibility. Don't add new symbols.\n-#\n-\n-LIBXML2_2.4.30 {\n-    global:\n-\n-# debugXML\n-  xmlBoolToText;\n-  xmlDebugDumpAttr;\n-  xmlDebugDumpAttrList;\n-  xmlDebugDumpDTD;\n-  xmlDebugDumpDocument;\n-  xmlDebugDumpDocumentHead;\n-  xmlDebugDumpEntities;\n-  xmlDebugDumpNode;\n-  xmlDebugDumpNodeList;\n-  xmlDebugDumpOneNode;\n-  xmlDebugDumpString;\n-  xmlLsCountNode;\n-  xmlLsOneNode;\n-  xmlShell;\n-  xmlShellBase;\n-  xmlShellCat;\n-  xmlShellDir;\n-  xmlShellDu;\n-  xmlShellList;\n-  xmlShellLoad;\n-  xmlShellPrintNode;\n-  xmlShellPrintXPathError;\n-  xmlShellPrintXPathResult;\n-  xmlShellPwd;\n-  xmlShellSave;\n-  xmlShellValidate;\n-  xmlShellWrite;\n-\n-# xpointer\n-  xmlXPtrBuildNodeList;\n-  xmlXPtrEval;\n-  xmlXPtrEvalRangePredicate;\n-  xmlXPtrFreeLocationSet;\n-  xmlXPtrLocationSetAdd;\n-  xmlXPtrLocationSetCreate;\n-  xmlXPtrLocationSetDel;\n-  xmlXPtrLocationSetMerge;\n-  xmlXPtrLocationSetRemove;\n-  xmlXPtrNewCollapsedRange;\n-  xmlXPtrNewContext;\n-  xmlXPtrNewLocationSetNodeSet;\n-  xmlXPtrNewLocationSetNodes;\n-  xmlXPtrNewRange;\n-  xmlXPtrNewRangeNodeObject;\n-  xmlXPtrNewRangeNodePoint;\n-  xmlXPtrNewRangeNodes;\n-  xmlXPtrNewRangePointNode;\n-  xmlXPtrNewRangePoints;\n-  xmlXPtrRangeToFunction;\n-  xmlXPtrWrapLocationSet;\n-\n-# SAX\n-  attribute;\n-  attributeDecl;\n-  cdataBlock;\n-  characters;\n-  checkNamespace;\n-  comment;\n-\n-# SAX2\n-# docbDefaultSAXHandlerInit; removed in 2.10.0\n-\n-# SAX\n-  elementDecl;\n-  endDocument;\n-  endElement;\n-  entityDecl;\n-  externalSubset;\n-  getColumnNumber;\n-  getEntity;\n-  getLineNumber;\n-  getNamespace;\n-  getParameterEntity;\n-  getPublicId;\n-  getSystemId;\n-  globalNamespace;\n-  hasExternalSubset;\n-  hasInternalSubset;\n-\n-# SAX2\n-  htmlDefaultSAXHandlerInit;\n-\n-# SAX\n-  ignorableWhitespace;\n-# initdocbDefaultSAXHandler; removed in 2.10.0\n-  inithtmlDefaultSAXHandler;\n-  initxmlDefaultSAXHandler;\n-  internalSubset;\n-  isStandalone;\n-  namespaceDecl;\n-  notationDecl;\n-  processingInstruction;\n-  reference;\n-  resolveEntity;\n-  setDocumentLocator;\n-  setNamespace;\n-  startDocument;\n-  startElement;\n-  unparsedEntityDecl;\n-\n-# SAX2\n-  xmlDefaultSAXHandlerInit;\n-\n-# parserInternals\n-  htmlCreateFileParserCtxt;\n-  htmlInitAutoClose;\n-  inputPop;\n-  inputPush;\n-  namePop;\n-  namePush;\n-  nodePop;\n-  nodePush;\n-  xmlCheckLanguageID;\n-  xmlCopyChar;\n-  xmlCopyCharMultiByte;\n-  xmlCreateEntityParserCtxt;\n-  xmlCreateFileParserCtxt;\n-  xmlCreateMemoryParserCtxt;\n-  xmlCurrentChar;\n-  xmlDecodeEntities;\n-  xmlFreeInputStream;\n-  xmlHandleEntity;\n-\n-# chvalid\n-  xmlIsBaseChar;\n-  xmlIsBlank;\n-  xmlIsChar;\n-  xmlIsCombining;\n-  xmlIsDigit;\n-  xmlIsExtender;\n-  xmlIsIdeographic;\n-\n-# parserInternals\n-  xmlIsLetter;\n-\n-# chvalid\n-  xmlIsPubidChar;\n-\n-# parserInternals\n-  xmlNamespaceParseNCName;\n-  xmlNamespaceParseNSDef;\n-  xmlNamespaceParseQName;\n-  xmlNewEntityInputStream;\n-  xmlNewInputFromFile;\n-  xmlNewInputStream;\n-\n-# parser\n-  xmlNewParserCtxt;\n-\n-# parserInternals\n-  xmlNewStringInputStream;\n-  xmlNextChar;\n-  xmlParseAttValue;\n-  xmlParseAttribute;\n-  xmlParseAttributeListDecl;\n-  xmlParseAttributeType;\n-  xmlParseCDSect;\n-  xmlParseCharData;\n-  xmlParseCharRef;\n-  xmlParseComment;\n-  xmlParseContent;\n-  xmlParseDefaultDecl;\n-  xmlParseDocTypeDecl;\n-  xmlParseElement;\n-  xmlParseElementChildrenContentDecl;\n-  xmlParseElementContentDecl;\n-  xmlParseElementDecl;\n-  xmlParseElementMixedContentDecl;\n-  xmlParseEncName;\n-  xmlParseEncodingDecl;\n-  xmlParseEndTag;\n-  xmlParseEntityDecl;\n-  xmlParseEntityRef;\n-  xmlParseEntityValue;\n-  xmlParseEnumeratedType;\n-  xmlParseEnumerationType;\n-  xmlParseExternalID;\n-  xmlParseExternalSubset;\n-  xmlParseMarkupDecl;\n-  xmlParseMisc;\n-  xmlParseName;\n-  xmlParseNamespace;\n-  xmlParseNmtoken;\n-  xmlParseNotationDecl;\n-  xmlParseNotationType;\n-  xmlParsePEReference;\n-  xmlParsePI;\n-  xmlParsePITarget;\n-  xmlParsePubidLiteral;\n-  xmlParseQuotedString;\n-  xmlParseReference;\n-  xmlParseSDDecl;\n-  xmlParseStartTag;\n-  xmlParseSystemLiteral;\n-  xmlParseTextDecl;\n-  xmlParseVersionInfo;\n-  xmlParseVersionNum;\n-  xmlParseXMLDecl;\n-  xmlParserHandlePEReference;\n-  xmlParserHandleReference;\n-  xmlParserInputShrink;\n-  xmlPopInput;\n-  xmlPushInput;\n-  xmlScanName;\n-  xmlSetEntityReferenceFunc;\n-  xmlSkipBlankChars;\n-  xmlSplitQName;\n-  xmlStringComment; # variable\n-  xmlStringCurrentChar;\n-  xmlStringDecodeEntities;\n-  xmlStringText; # variable\n-  xmlStringTextNoenc; # variable\n-  xmlSwitchEncoding;\n-  xmlSwitchToEncoding;\n-\n-# c14n\n-  xmlC14NDocDumpMemory;\n-  xmlC14NDocSave;\n-  xmlC14NDocSaveTo;\n-  xmlC14NExecute;\n-\n-# catalog\n-  xmlACatalogAdd;\n-  xmlACatalogDump;\n-  xmlACatalogRemove;\n-  xmlACatalogResolve;\n-  xmlACatalogResolvePublic;\n-  xmlACatalogResolveSystem;\n-  xmlACatalogResolveURI;\n-  xmlCatalogAdd;\n-  xmlCatalogAddLocal;\n-  xmlCatalogCleanup;\n-  xmlCatalogConvert;\n-  xmlCatalogDump;\n-  xmlCatalogFreeLocal;\n-  xmlCatalogGetDefaults;\n-  xmlCatalogGetPublic;\n-  xmlCatalogGetSystem;\n-  xmlCatalogIsEmpty;\n-  xmlCatalogLocalResolve;\n-  xmlCatalogLocalResolveURI;\n-  xmlCatalogRemove;\n-  xmlCatalogResolve;\n-  xmlCatalogResolvePublic;\n-  xmlCatalogResolveSystem;\n-  xmlCatalogResolveURI;\n-  xmlCatalogSetDebug;\n-  xmlCatalogSetDefaultPrefer;\n-  xmlCatalogSetDefaults;\n-  xmlConvertSGMLCatalog;\n-  xmlFreeCatalog;\n-  xmlInitializeCatalog;\n-  xmlLoadACatalog;\n-  xmlLoadCatalog;\n-  xmlLoadCatalogs;\n-  xmlLoadSGMLSuperCatalog;\n-  xmlNewCatalog;\n-  xmlParseCatalogFile;\n-\n-# xpathInternals\n-  valuePop;\n-  valuePush;\n-  xmlXPathAddValues;\n-  xmlXPathBooleanFunction;\n-  xmlXPathCeilingFunction;\n-  xmlXPathCompareValues;\n-  xmlXPathConcatFunction;\n-  xmlXPathContainsFunction;\n-  xmlXPathCountFunction;\n-  xmlXPathDebugDumpCompExpr;\n-  xmlXPathDebugDumpObject;\n-  xmlXPathDifference;\n-  xmlXPathDistinct;\n-  xmlXPathDistinctSorted;\n-  xmlXPathDivValues;\n-  xmlXPathEqualValues;\n-  xmlXPathEvalExpr;\n-  xmlXPathEvaluatePredicateResult;\n-  xmlXPathFalseFunction;\n-  xmlXPathFloorFunction;\n-  xmlXPathFreeParserContext;\n-  xmlXPathFunctionLookup;\n-  xmlXPathFunctionLookupNS;\n-  xmlXPathHasSameNodes;\n-  xmlXPathIdFunction;\n-  xmlXPathIntersection;\n-  xmlXPathIsNodeType;\n-  xmlXPathLangFunction;\n-  xmlXPathLastFunction;\n-  xmlXPathLeading;\n-  xmlXPathLeadingSorted;\n-  xmlXPathLocalNameFunction;\n-  xmlXPathModValues;\n-  xmlXPathMultValues;\n-  xmlXPathNamespaceURIFunction;\n-  xmlXPathNewBoolean;\n-  xmlXPathNewCString;\n-  xmlXPathNewFloat;\n-  xmlXPathNewNodeSet;\n-  xmlXPathNewNodeSetList;\n-  xmlXPathNewParserContext;\n-  xmlXPathNewString;\n-  xmlXPathNewValueTree;\n-  xmlXPathNextAncestor;\n-  xmlXPathNextAncestorOrSelf;\n-  xmlXPathNextAttribute;\n-  xmlXPathNextChild;\n-  xmlXPathNextDescendant;\n-  xmlXPathNextDescendantOrSelf;\n-  xmlXPathNextFollowing;\n-  xmlXPathNextFollowingSibling;\n-  xmlXPathNextNamespace;\n-  xmlXPathNextParent;\n-  xmlXPathNextPreceding;\n-  xmlXPathNextPrecedingSibling;\n-  xmlXPathNextSelf;\n-  xmlXPathNodeLeading;\n-  xmlXPathNodeLeadingSorted;\n-  xmlXPathNodeSetAdd;\n-  xmlXPathNodeSetAddNs;\n-  xmlXPathNodeSetAddUnique;\n-  xmlXPathNodeSetContains;\n-  xmlXPathNodeSetDel;\n-  xmlXPathNodeSetFreeNs;\n-  xmlXPathNodeSetMerge;\n-  xmlXPathNodeSetRemove;\n-  xmlXPathNodeSetSort;\n-  xmlXPathNodeTrailing;\n-  xmlXPathNodeTrailingSorted;\n-  xmlXPathNormalizeFunction;\n-  xmlXPathNotEqualValues;\n-  xmlXPathNotFunction;\n-  xmlXPathNsLookup;\n-  xmlXPathNumberFunction;\n-  xmlXPathParseNCName;\n-  xmlXPathParseName;\n-  xmlXPathPopBoolean;\n-  xmlXPathPopExternal;\n-  xmlXPathPopNodeSet;\n-  xmlXPathPopNumber;\n-  xmlXPathPopString;\n-  xmlXPathPositionFunction;\n-  xmlXPathRegisterAllFunctions;\n-  xmlXPathRegisterFunc;\n-  xmlXPathRegisterFuncLookup;\n-  xmlXPathRegisterFuncNS;\n-  xmlXPathRegisterNs;\n-  xmlXPathRegisterVariable;\n-  xmlXPathRegisterVariableLookup;\n-  xmlXPathRegisterVariableNS;\n-  xmlXPathRegisteredFuncsCleanup;\n-  xmlXPathRegisteredNsCleanup;\n-  xmlXPathRegisteredVariablesCleanup;\n-  xmlXPathRoot;\n-  xmlXPathRoundFunction;\n-  xmlXPathStartsWithFunction;\n-  xmlXPathStringEvalNumber;\n-  xmlXPathStringFunction;\n-  xmlXPathStringLengthFunction;\n-  xmlXPathSubValues;\n-  xmlXPathSubstringAfterFunction;\n-  xmlXPathSubstringBeforeFunction;\n-  xmlXPathSubstringFunction;\n-  xmlXPathSumFunction;\n-  xmlXPathTrailing;\n-  xmlXPathTrailingSorted;\n-  xmlXPathTranslateFunction;\n-  xmlXPathTrueFunction;\n-  xmlXPathValueFlipSign;\n-  xmlXPathVariableLookup;\n-  xmlXPathVariableLookupNS;\n-  xmlXPathWrapCString;\n-  xmlXPathWrapExternal;\n-  xmlXPathWrapNodeSet;\n-  xmlXPathWrapString;\n-  xmlXPatherror;\n-\n-# xmlautomata\n-  xmlAutomataCompile;\n-  xmlAutomataGetInitState;\n-  xmlAutomataIsDeterminist;\n-  xmlAutomataNewAllTrans;\n-  xmlAutomataNewCountTrans;\n-  xmlAutomataNewCountedTrans;\n-  xmlAutomataNewCounter;\n-  xmlAutomataNewCounterTrans;\n-  xmlAutomataNewEpsilon;\n-  xmlAutomataNewOnceTrans;\n-  xmlAutomataNewState;\n-  xmlAutomataNewTransition;\n-  xmlAutomataSetFinalState;\n-  xmlFreeAutomata;\n-  xmlNewAutomata;\n-\n-# HTMLtree\n-  htmlDocContentDumpFormatOutput;\n-  htmlDocContentDumpOutput;\n-  htmlDocDump;\n-  htmlDocDumpMemory;\n-  htmlGetMetaEncoding;\n-  htmlIsBooleanAttr;\n-  htmlNewDoc;\n-  htmlNewDocNoDtD;\n-  htmlNodeDump;\n-  htmlNodeDumpFile;\n-  htmlNodeDumpFileFormat;\n-  htmlNodeDumpFormatOutput;\n-  htmlNodeDumpOutput;\n-  htmlSaveFile;\n-  htmlSaveFileEnc;\n-  htmlSaveFileFormat;\n-  htmlSetMetaEncoding;\n-\n-# nanoftp\n-  xmlNanoFTPCheckResponse;\n-  xmlNanoFTPCleanup;\n-  xmlNanoFTPClose;\n-  xmlNanoFTPCloseConnection;\n-  xmlNanoFTPConnect;\n-  xmlNanoFTPConnectTo;\n-  xmlNanoFTPCwd;\n-  xmlNanoFTPFreeCtxt;\n-  xmlNanoFTPGet;\n-  xmlNanoFTPGetConnection;\n-  xmlNanoFTPGetResponse;\n-  xmlNanoFTPGetSocket;\n-  xmlNanoFTPInit;\n-  xmlNanoFTPList;\n-  xmlNanoFTPNewCtxt;\n-  xmlNanoFTPOpen;\n-  xmlNanoFTPProxy;\n-  xmlNanoFTPQuit;\n-  xmlNanoFTPRead;\n-  xmlNanoFTPScanProxy;\n-  xmlNanoFTPUpdateURL;\n-\n-# DOCBparser\n-# docbCreateFileParserCtxt; removed in 2.10.0\n-# docbCreatePushParserCtxt; removed in 2.10.0\n-# docbEncodeEntities; removed in 2.10.0\n-# docbFreeParserCtxt; removed in 2.10.0\n-# docbParseChunk; removed in 2.10.0\n-# docbParseDoc; removed in 2.10.0\n-# docbParseDocument; removed in 2.10.0\n-# docbParseFile; removed in 2.10.0\n-# docbSAXParseDoc; removed in 2.10.0\n-# docbSAXParseFile; removed in 2.10.0\n-\n-# xpath\n-  xmlXPathCastBooleanToNumber;\n-  xmlXPathCastBooleanToString;\n-  xmlXPathCastNodeSetToBoolean;\n-  xmlXPathCastNodeSetToNumber;\n-  xmlXPathCastNodeSetToString;\n-  xmlXPathCastNodeToNumber;\n-  xmlXPathCastNodeToString;\n-  xmlXPathCastNumberToBoolean;\n-  xmlXPathCastNumberToString;\n-  xmlXPathCastStringToBoolean;\n-  xmlXPathCastStringToNumber;\n-  xmlXPathCastToBoolean;\n-  xmlXPathCastToNumber;\n-  xmlXPathCastToString;\n-  xmlXPathCmpNodes;\n-  xmlXPathCompile;\n-  xmlXPathCompiledEval;\n-  xmlXPathConvertBoolean;\n-  xmlXPathConvertNumber;\n-  xmlXPathConvertString;\n-  xmlXPathEval;\n-  xmlXPathEvalExpression;\n-  xmlXPathEvalPredicate;\n-  xmlXPathFreeCompExpr;\n-  xmlXPathFreeContext;\n-  xmlXPathFreeNodeSet;\n-  xmlXPathFreeNodeSetList;\n-  xmlXPathFreeObject;\n-  xmlXPathInit;\n-  xmlXPathIsInf;\n-  xmlXPathIsNaN;\n-  xmlXPathNAN; # variable\n-  xmlXPathNINF; # variable\n-  xmlXPathNewContext;\n-  xmlXPathNodeSetCreate;\n-  xmlXPathObjectCopy;\n-  xmlXPathPINF; # variable\n-\n-# xlink\n-  xlinkGetDefaultDetect;\n-  xlinkGetDefaultHandler;\n-  xlinkIsLink;\n-  xlinkSetDefaultDetect;\n-  xlinkSetDefaultHandler;\n-\n-# entities\n-  xmlAddDocEntity;\n-  xmlAddDtdEntity;\n-  xmlCleanupPredefinedEntities;\n-  xmlCopyEntitiesTable;\n-  xmlCreateEntitiesTable;\n-  xmlDumpEntitiesTable;\n-  xmlDumpEntityDecl;\n-  xmlEncodeEntities;\n-  xmlEncodeEntitiesReentrant;\n-  xmlEncodeSpecialChars;\n-  xmlFreeEntitiesTable;\n-  xmlGetDocEntity;\n-  xmlGetDtdEntity;\n-  xmlGetParameterEntity;\n-  xmlGetPredefinedEntity;\n-  xmlInitializePredefinedEntities;\n-\n-# xinclude\n-  xmlXIncludeProcess;\n-\n-# list\n-  xmlLinkGetData;\n-  xmlListAppend;\n-  xmlListClear;\n-  xmlListCopy;\n-  xmlListCreate;\n-  xmlListDelete;\n-  xmlListDup;\n-  xmlListEmpty;\n-  xmlListEnd;\n-  xmlListFront;\n-  xmlListInsert;\n-  xmlListMerge;\n-  xmlListPopBack;\n-  xmlListPopFront;\n-  xmlListPushBack;\n-  xmlListPushFront;\n-  xmlListRemoveAll;\n-  xmlListRemoveFirst;\n-  xmlListRemoveLast;\n-  xmlListReverse;\n-  xmlListReverseSearch;\n-  xmlListReverseWalk;\n-  xmlListSearch;\n-  xmlListSize;\n-  xmlListSort;\n-  xmlListWalk;\n-\n-# xmlmemory\n-  xmlInitMemory;\n-  xmlMallocLoc;\n-  xmlMemDisplay;\n-  xmlMemFree;\n-  xmlMemGet;\n-  xmlMemMalloc;\n-  xmlMemRealloc;\n-  xmlMemSetup;\n-  xmlMemShow;\n-  xmlMemStrdupLoc;\n-  xmlMemUsed;\n-  xmlMemoryDump;\n-  xmlMemoryStrdup;\n-  xmlReallocLoc;\n-\n-# xmlIO\n-  xmlAllocOutputBuffer;\n-  xmlAllocParserInputBuffer;\n-  xmlCheckFilename;\n-  xmlCleanupInputCallbacks;\n-  xmlCleanupOutputCallbacks;\n-  xmlFileClose;\n-  xmlFileMatch;\n-  xmlFileOpen;\n-  xmlFileRead;\n-  xmlFreeParserInputBuffer;\n-  xmlIOFTPClose;\n-  xmlIOFTPMatch;\n-  xmlIOFTPOpen;\n-  xmlIOFTPRead;\n-  xmlIOHTTPClose;\n-  xmlIOHTTPMatch;\n-  xmlIOHTTPOpen;\n-  xmlIOHTTPOpenW;\n-  xmlIOHTTPRead;\n-  xmlNoNetExternalEntityLoader;\n-  xmlNormalizeWindowsPath;\n-  xmlOutputBufferClose;\n-  xmlOutputBufferCreateFd;\n-  xmlOutputBufferCreateFile;\n-  xmlOutputBufferCreateFilename;\n-  xmlOutputBufferCreateIO;\n-  xmlOutputBufferFlush;\n-  xmlOutputBufferWrite;\n-  xmlOutputBufferWriteString;\n-  xmlParserGetDirectory;\n-  xmlParserInputBufferCreateFd;\n-  xmlParserInputBufferCreateFile;\n-  xmlParserInputBufferCreateFilename;\n-  xmlParserInputBufferCreateIO;\n-  xmlParserInputBufferCreateMem;\n-  xmlParserInputBufferGrow;\n-  xmlParserInputBufferPush;\n-  xmlParserInputBufferRead;\n-  xmlRegisterDefaultInputCallbacks;\n-  xmlRegisterDefaultOutputCallbacks;\n-  xmlRegisterHTTPPostCallbacks;\n-  xmlRegisterInputCallbacks;\n-  xmlRegisterOutputCallbacks;\n-\n-# xmlversion\n-  xmlCheckVersion;\n-\n-# valid\n-  xmlAddAttributeDecl;\n-  xmlAddElementDecl;\n-  xmlAddID;\n-  xmlAddNotationDecl;\n-  xmlAddRef;\n-  xmlCopyAttributeTable;\n-  xmlCopyElementContent;\n-  xmlCopyElementTable;\n-  xmlCopyEnumeration;\n-  xmlCopyNotationTable;\n-  xmlCreateEnumeration;\n-  xmlDumpAttributeDecl;\n-  xmlDumpAttributeTable;\n-  xmlDumpElementDecl;\n-  xmlDumpElementTable;\n-  xmlDumpNotationDecl;\n-  xmlDumpNotationTable;\n-  xmlFreeAttributeTable;\n-  xmlFreeElementContent;\n-  xmlFreeElementTable;\n-  xmlFreeEnumeration;\n-  xmlFreeIDTable;\n-  xmlFreeNotationTable;\n-  xmlFreeRefTable;\n-  xmlGetDtdAttrDesc;\n-  xmlGetDtdElementDesc;\n-  xmlGetDtdNotationDesc;\n-  xmlGetDtdQAttrDesc;\n-  xmlGetDtdQElementDesc;\n-  xmlGetID;\n-  xmlGetRefs;\n-  xmlIsID;\n-  xmlIsMixedElement;\n-  xmlIsRef;\n-  xmlNewElementContent;\n-  xmlRemoveID;\n-  xmlRemoveRef;\n-  xmlSnprintfElementContent;\n-\n-# tree\n-  xmlSplitQName2;\n-\n-# valid\n-  xmlSprintfElementContent;\n-  xmlValidBuildContentModel;\n-  xmlValidCtxtNormalizeAttributeValue;\n-  xmlValidGetPotentialChildren;\n-  xmlValidGetValidElements;\n-  xmlValidNormalizeAttributeValue;\n-  xmlValidateAttributeDecl;\n-  xmlValidateAttributeValue;\n-  xmlValidateDocument;\n-  xmlValidateDocumentFinal;\n-  xmlValidateDtd;\n-  xmlValidateDtdFinal;\n-  xmlValidateElement;\n-  xmlValidateElementDecl;\n-  xmlValidateNameValue;\n-  xmlValidateNamesValue;\n-  xmlValidateNmtokenValue;\n-  xmlValidateNmtokensValue;\n-  xmlValidateNotationDecl;\n-  xmlValidateNotationUse;\n-  xmlValidateOneAttribute;\n-  xmlValidateOneElement;\n-  xmlValidateOneNamespace;\n-  xmlValidateRoot;\n-\n-# HTMLparser\n-  UTF8ToHtml;\n-  htmlAutoCloseTag;\n-  htmlCreatePushParserCtxt;\n-  htmlEncodeEntities;\n-  htmlEntityLookup;\n-  htmlEntityValueLookup;\n-  htmlFreeParserCtxt;\n-  htmlHandleOmittedElem;\n-  htmlIsAutoClosed;\n-  htmlIsScriptAttribute;\n-  htmlParseCharRef;\n-  htmlParseChunk;\n-  htmlParseDoc;\n-  htmlParseDocument;\n-  htmlParseElement;\n-  htmlParseEntityRef;\n-  htmlParseFile;\n-  htmlSAXParseDoc;\n-  htmlSAXParseFile;\n-  htmlTagLookup;\n-\n-# xmlstring\n-  xmlCharStrdup;\n-  xmlCharStrndup;\n-\n-# parser\n-  xmlCleanupParser;\n-  xmlClearNodeInfoSeq;\n-  xmlClearParserCtxt;\n-  xmlCreateDocParserCtxt;\n-  xmlCreateIOParserCtxt;\n-  xmlCreatePushParserCtxt;\n-  xmlFreeParserCtxt;\n-  xmlGetExternalEntityLoader;\n-  xmlGetFeature;\n-  xmlGetFeaturesList;\n-\n-# globals\n-  xmlGetWarningsDefaultValue; # variable\n-\n-# parser\n-  xmlIOParseDTD;\n-  xmlInitNodeInfoSeq;\n-  xmlInitParser;\n-  xmlInitParserCtxt;\n-  xmlKeepBlanksDefault;\n-  xmlLineNumbersDefault;\n-  xmlLoadExternalEntity;\n-  xmlNewIOInputStream;\n-  xmlParseBalancedChunkMemory;\n-  xmlParseBalancedChunkMemoryRecover;\n-  xmlParseChunk;\n-  xmlParseCtxtExternalEntity;\n-  xmlParseDTD;\n-  xmlParseDoc;\n-  xmlParseDocument;\n-  xmlParseEntity;\n-  xmlParseExtParsedEnt;\n-  xmlParseExternalEntity;\n-  xmlParseFile;\n-  xmlParseMemory;\n-  xmlParserAddNodeInfo;\n-  xmlParserFindNodeInfo;\n-  xmlParserFindNodeInfoIndex;\n-  xmlParserInputGrow;\n-  xmlParserInputRead;\n-  xmlPedanticParserDefault;\n-  xmlRecoverDoc;\n-  xmlRecoverFile;\n-  xmlRecoverMemory;\n-  xmlSAXParseDTD;\n-  xmlSAXParseDoc;\n-  xmlSAXParseEntity;\n-  xmlSAXParseFile;\n-  xmlSAXParseFileWithData;\n-  xmlSAXParseMemory;\n-  xmlSAXParseMemoryWithData;\n-  xmlSAXUserParseFile;\n-  xmlSAXUserParseMemory;\n-  xmlSetExternalEntityLoader;\n-  xmlSetFeature;\n-  xmlSetupParserForBuffer;\n-  xmlStopParser;\n-\n-# xmlstring\n-  xmlStrEqual;\n-  xmlStrcasecmp;\n-  xmlStrcasestr;\n-  xmlStrcat;\n-  xmlStrchr;\n-  xmlStrcmp;\n-  xmlStrdup;\n-  xmlStrlen;\n-  xmlStrncasecmp;\n-  xmlStrncat;\n-  xmlStrncmp;\n-  xmlStrndup;\n-  xmlStrstr;\n-  xmlStrsub;\n-\n-# parser\n-  xmlSubstituteEntitiesDefault;\n-\n-# xmlreader\n-  xmlFreeTextReader;\n-  xmlNewTextReader;\n-  xmlNewTextReaderFilename;\n-  xmlTextReaderAttributeCount;\n-  xmlTextReaderBaseUri;\n-  xmlTextReaderDepth;\n-  xmlTextReaderHasAttributes;\n-  xmlTextReaderHasValue;\n-  xmlTextReaderIsDefault;\n-  xmlTextReaderIsEmptyElement;\n-  xmlTextReaderLocalName;\n-  xmlTextReaderName;\n-  xmlTextReaderNamespaceUri;\n-  xmlTextReaderNodeType;\n-  xmlTextReaderPrefix;\n-  xmlTextReaderQuoteChar;\n-  xmlTextReaderRead;\n-  xmlTextReaderValue;\n-  xmlTextReaderXmlLang;\n-\n-# globals\n-# docbDefaultSAXHandler; removed in 2.10.0\n-  htmlDefaultSAXHandler; # variable\n-  xmlDefaultSAXHandler; # variable\n-  xmlDefaultSAXLocator; # variable\n-  xmlDoValidityCheckingDefaultValue; # variable\n-  xmlFree; # variable\n-  xmlGenericError; # variable\n-  xmlGenericErrorContext; # variable\n-  xmlInitializeGlobalState;\n-  xmlKeepBlanksDefaultValue; # variable\n-  xmlLineNumbersDefaultValue; # variable\n-  xmlLoadExtDtdDefaultValue; # variable\n-  xmlMalloc; # variable\n-  xmlMemStrdup; # variable\n-  xmlParserDebugEntities; # variable\n-  xmlParserVersion; # variable\n-  xmlPedanticParserDefaultValue; # variable\n-  xmlRealloc; # variable\n-  xmlSaveNoEmptyTags; # variable\n-  xmlSubstituteEntitiesDefaultValue; # variable\n-  xmlTreeIndentString; # variable\n-\n-# threads\n-  xmlCleanupThreads;\n-  xmlFreeMutex;\n-  xmlFreeRMutex;\n-  xmlGetGlobalState;\n-  xmlGetThreadId;\n-  xmlInitThreads;\n-  xmlIsMainThread;\n-  xmlLockLibrary;\n-  xmlMutexLock;\n-  xmlMutexUnlock;\n-  xmlNewMutex;\n-  xmlNewRMutex;\n-  xmlRMutexLock;\n-  xmlRMutexUnlock;\n-  xmlUnlockLibrary;\n-\n-# hash\n-  xmlHashAddEntry;\n-  xmlHashAddEntry2;\n-  xmlHashAddEntry3;\n-  xmlHashCopy;\n-  xmlHashCreate;\n-  xmlHashFree;\n-  xmlHashLookup;\n-  xmlHashLookup2;\n-  xmlHashLookup3;\n-  xmlHashRemoveEntry;\n-  xmlHashRemoveEntry2;\n-  xmlHashRemoveEntry3;\n-  xmlHashScan;\n-  xmlHashScan3;\n-  xmlHashScanFull;\n-  xmlHashScanFull3;\n-  xmlHashSize;\n-  xmlHashUpdateEntry;\n-  xmlHashUpdateEntry2;\n-  xmlHashUpdateEntry3;\n-\n-# xmlerror\n-  initGenericErrorDefaultFunc;\n-  xmlParserError;\n-  xmlParserPrintFileContext;\n-  xmlParserPrintFileInfo;\n-  xmlParserValidityError;\n-  xmlParserValidityWarning;\n-  xmlParserWarning;\n-  xmlSetGenericErrorFunc;\n-\n-# globals\n-  oldXMLWDcompatibility; # variable\n-\n-# tree\n-  xmlAddChild;\n-  xmlAddChildList;\n-  xmlAddNextSibling;\n-  xmlAddPrevSibling;\n-  xmlAddSibling;\n-  xmlBufferAdd;\n-  xmlBufferAddHead;\n-\n-# globals\n-  xmlBufferAllocScheme; # variable\n-\n-# tree\n-  xmlBufferCCat;\n-  xmlBufferCat;\n-  xmlBufferContent;\n-  xmlBufferCreate;\n-  xmlBufferCreateSize;\n-  xmlBufferDump;\n-  xmlBufferEmpty;\n-  xmlBufferFree;\n-  xmlBufferGrow;\n-  xmlBufferLength;\n-  xmlBufferResize;\n-  xmlBufferSetAllocationScheme;\n-  xmlBufferShrink;\n-  xmlBufferWriteCHAR;\n-  xmlBufferWriteChar;\n-  xmlBufferWriteQuotedString;\n-  xmlCopyDoc;\n-  xmlCopyDtd;\n-  xmlCopyNamespace;\n-  xmlCopyNamespaceList;\n-  xmlCopyNode;\n-  xmlCopyNodeList;\n-  xmlCopyProp;\n-  xmlCopyPropList;\n-  xmlCreateIntSubset;\n-\n-# globals\n-  xmlDefaultBufferSize; # variable\n-\n-# tree\n-  xmlDocCopyNode;\n-  xmlDocDump;\n-  xmlDocDumpFormatMemory;\n-  xmlDocDumpFormatMemoryEnc;\n-  xmlDocDumpMemory;\n-  xmlDocDumpMemoryEnc;\n-  xmlDocFormatDump;\n-  xmlDocGetRootElement;\n-  xmlDocSetRootElement;\n-  xmlElemDump;\n-  xmlFreeDoc;\n-  xmlFreeDtd;\n-  xmlFreeNode;\n-  xmlFreeNodeList;\n-  xmlFreeNs;\n-  xmlFreeNsList;\n-  xmlFreeProp;\n-  xmlFreePropList;\n-  xmlGetBufferAllocationScheme;\n-  xmlGetCompressMode;\n-  xmlGetDocCompressMode;\n-  xmlGetIntSubset;\n-  xmlGetLastChild;\n-  xmlGetLineNo;\n-  xmlGetNodePath;\n-  xmlGetNsList;\n-  xmlGetNsProp;\n-  xmlGetProp;\n-  xmlHasNsProp;\n-  xmlHasProp;\n-\n-# globals\n-  xmlIndentTreeOutput; # variable\n-\n-# tree\n-  xmlIsBlankNode;\n-  xmlIsXHTML;\n-  xmlNewCDataBlock;\n-  xmlNewCharRef;\n-  xmlNewChild;\n-  xmlNewComment;\n-  xmlNewDoc;\n-  xmlNewDocComment;\n-  xmlNewDocFragment;\n-  xmlNewDocNode;\n-  xmlNewDocNodeEatName;\n-  xmlNewDocProp;\n-  xmlNewDocRawNode;\n-  xmlNewDocText;\n-  xmlNewDocTextLen;\n-  xmlNewDtd;\n-  xmlNewGlobalNs;\n-  xmlNewNode;\n-  xmlNewNodeEatName;\n-  xmlNewNs;\n-  xmlNewNsProp;\n-  xmlNewNsPropEatName;\n-  xmlNewPI;\n-  xmlNewProp;\n-  xmlNewReference;\n-  xmlNewText;\n-  xmlNewTextChild;\n-  xmlNewTextLen;\n-  xmlNodeAddContent;\n-  xmlNodeAddContentLen;\n-  xmlNodeDump;\n-  xmlNodeDumpOutput;\n-  xmlNodeGetBase;\n-  xmlNodeGetContent;\n-  xmlNodeGetLang;\n-  xmlNodeGetSpacePreserve;\n-  xmlNodeIsText;\n-  xmlNodeListGetRawString;\n-  xmlNodeListGetString;\n-  xmlNodeSetBase;\n-  xmlNodeSetContent;\n-  xmlNodeSetContentLen;\n-  xmlNodeSetLang;\n-  xmlNodeSetName;\n-  xmlNodeSetSpacePreserve;\n-  xmlReconciliateNs;\n-  xmlRemoveProp;\n-  xmlReplaceNode;\n-  xmlSaveFile;\n-  xmlSaveFileEnc;\n-  xmlSaveFileTo;\n-  xmlSaveFormatFile;\n-  xmlSaveFormatFileEnc;\n-  xmlSaveFormatFileTo;\n-  xmlSearchNs;\n-  xmlSearchNsByHref;\n-  xmlSetBufferAllocationScheme;\n-  xmlSetCompressMode;\n-  xmlSetDocCompressMode;\n-  xmlSetListDoc;\n-  xmlSetNs;\n-  xmlSetNsProp;\n-  xmlSetProp;\n-  xmlSetTreeDoc;\n-  xmlStringGetNodeList;\n-  xmlStringLenGetNodeList;\n-  xmlTextConcat;\n-  xmlTextMerge;\n-  xmlUnlinkNode;\n-  xmlUnsetNsProp;\n-  xmlUnsetProp;\n-\n-# xmlregexp\n-  xmlRegExecPushString;\n-  xmlRegFreeExecCtxt;\n-  xmlRegFreeRegexp;\n-  xmlRegNewExecCtxt;\n-  xmlRegexpCompile;\n-  xmlRegexpExec;\n-  xmlRegexpIsDeterminist;\n-  xmlRegexpPrint;\n-\n-# nanohttp\n-  xmlNanoHTTPAuthHeader;\n-  xmlNanoHTTPCleanup;\n-  xmlNanoHTTPClose;\n-  xmlNanoHTTPFetch;\n-  xmlNanoHTTPInit;\n-  xmlNanoHTTPMethod;\n-  xmlNanoHTTPMethodRedir;\n-  xmlNanoHTTPOpen;\n-  xmlNanoHTTPOpenRedir;\n-  xmlNanoHTTPRead;\n-  xmlNanoHTTPReturnCode;\n-  xmlNanoHTTPSave;\n-  xmlNanoHTTPScanProxy;\n-\n-# xmlunicode\n-  xmlUCSIsAlphabeticPresentationForms;\n-  xmlUCSIsArabic;\n-  xmlUCSIsArabicPresentationFormsA;\n-  xmlUCSIsArabicPresentationFormsB;\n-  xmlUCSIsArmenian;\n-  xmlUCSIsArrows;\n-  xmlUCSIsBasicLatin;\n-  xmlUCSIsBengali;\n-  xmlUCSIsBlock;\n-  xmlUCSIsBlockElements;\n-  xmlUCSIsBopomofo;\n-  xmlUCSIsBopomofoExtended;\n-  xmlUCSIsBoxDrawing;\n-  xmlUCSIsBraillePatterns;\n-  xmlUCSIsByzantineMusicalSymbols;\n-  xmlUCSIsCJKCompatibility;\n-  xmlUCSIsCJKCompatibilityForms;\n-  xmlUCSIsCJKCompatibilityIdeographs;\n-  xmlUCSIsCJKCompatibilityIdeographsSupplement;\n-  xmlUCSIsCJKRadicalsSupplement;\n-  xmlUCSIsCJKSymbolsandPunctuation;\n-  xmlUCSIsCJKUnifiedIdeographs;\n-  xmlUCSIsCJKUnifiedIdeographsExtensionA;\n-  xmlUCSIsCJKUnifiedIdeographsExtensionB;\n-  xmlUCSIsCat;\n-  xmlUCSIsCatC;\n-  xmlUCSIsCatCc;\n-  xmlUCSIsCatCf;\n-  xmlUCSIsCatCo;\n-  xmlUCSIsCatCs;\n-  xmlUCSIsCatL;\n-  xmlUCSIsCatLl;\n-  xmlUCSIsCatLm;\n-  xmlUCSIsCatLo;\n-  xmlUCSIsCatLt;\n-  xmlUCSIsCatLu;\n-  xmlUCSIsCatM;\n-  xmlUCSIsCatMc;\n-  xmlUCSIsCatMe;\n-  xmlUCSIsCatMn;\n-  xmlUCSIsCatN;\n-  xmlUCSIsCatNd;\n-  xmlUCSIsCatNl;\n-  xmlUCSIsCatNo;\n-  xmlUCSIsCatP;\n-  xmlUCSIsCatPc;\n-  xmlUCSIsCatPd;\n-  xmlUCSIsCatPe;\n-  xmlUCSIsCatPf;\n-  xmlUCSIsCatPi;\n-  xmlUCSIsCatPo;\n-  xmlUCSIsCatPs;\n-  xmlUCSIsCatS;\n-  xmlUCSIsCatSc;\n-  xmlUCSIsCatSk;\n-  xmlUCSIsCatSm;\n-  xmlUCSIsCatSo;\n-  xmlUCSIsCatZ;\n-  xmlUCSIsCatZl;\n-  xmlUCSIsCatZp;\n-  xmlUCSIsCatZs;\n-  xmlUCSIsCherokee;\n-  xmlUCSIsCombiningDiacriticalMarks;\n-  xmlUCSIsCombiningHalfMarks;\n-  xmlUCSIsCombiningMarksforSymbols;\n-  xmlUCSIsControlPictures;\n-  xmlUCSIsCurrencySymbols;\n-  xmlUCSIsCyrillic;\n-  xmlUCSIsDeseret;\n-  xmlUCSIsDevanagari;\n-  xmlUCSIsDingbats;\n-  xmlUCSIsEnclosedAlphanumerics;\n-  xmlUCSIsEnclosedCJKLettersandMonths;\n-  xmlUCSIsEthiopic;\n-  xmlUCSIsGeneralPunctuation;\n-  xmlUCSIsGeometricShapes;\n-  xmlUCSIsGeorgian;\n-  xmlUCSIsGothic;\n-  xmlUCSIsGreek;\n-  xmlUCSIsGreekExtended;\n-  xmlUCSIsGujarati;\n-  xmlUCSIsGurmukhi;\n-  xmlUCSIsHalfwidthandFullwidthForms;\n-  xmlUCSIsHangulCompatibilityJamo;\n-  xmlUCSIsHangulJamo;\n-  xmlUCSIsHangulSyllables;\n-  xmlUCSIsHebrew;\n-  xmlUCSIsHighPrivateUseSurrogates;\n-  xmlUCSIsHighSurrogates;\n-  xmlUCSIsHiragana;\n-  xmlUCSIsIPAExtensions;\n-  xmlUCSIsIdeographicDescriptionCharacters;\n-  xmlUCSIsKanbun;\n-  xmlUCSIsKangxiRadicals;\n-  xmlUCSIsKannada;\n-  xmlUCSIsKatakana;\n-  xmlUCSIsKhmer;\n-  xmlUCSIsLao;\n-  xmlUCSIsLatin1Supplement;\n-  xmlUCSIsLatinExtendedA;\n-  xmlUCSIsLatinExtendedAdditional;\n-  xmlUCSIsLatinExtendedB;\n-  xmlUCSIsLetterlikeSymbols;\n-  xmlUCSIsLowSurrogates;\n-  xmlUCSIsMalayalam;\n-  xmlUCSIsMathematicalAlphanumericSymbols;\n-  xmlUCSIsMathematicalOperators;\n-  xmlUCSIsMiscellaneousSymbols;\n-  xmlUCSIsMiscellaneousTechnical;\n-  xmlUCSIsMongolian;\n-  xmlUCSIsMusicalSymbols;\n-  xmlUCSIsMyanmar;\n-  xmlUCSIsNumberForms;\n-  xmlUCSIsOgham;\n-  xmlUCSIsOldItalic;\n-  xmlUCSIsOpticalCharacterRecognition;\n-  xmlUCSIsOriya;\n-  xmlUCSIsPrivateUse;\n-  xmlUCSIsRunic;\n-  xmlUCSIsSinhala;\n-  xmlUCSIsSmallFormVariants;\n-  xmlUCSIsSpacingModifierLetters;\n-  xmlUCSIsSpecials;\n-  xmlUCSIsSuperscriptsandSubscripts;\n-  xmlUCSIsSyriac;\n-  xmlUCSIsTags;\n-  xmlUCSIsTamil;\n-  xmlUCSIsTelugu;\n-  xmlUCSIsThaana;\n-  xmlUCSIsThai;\n-  xmlUCSIsTibetan;\n-  xmlUCSIsUnifiedCanadianAboriginalSyllabics;\n-  xmlUCSIsYiRadicals;\n-  xmlUCSIsYiSyllables;\n-\n-# uri\n-  xmlBuildURI;\n-  xmlCreateURI;\n-  xmlFreeURI;\n-  xmlNormalizeURIPath;\n-  xmlParseURI;\n-  xmlParseURIReference;\n-  xmlPrintURI;\n-  xmlSaveUri;\n-  xmlURIEscape;\n-  xmlURIEscapeStr;\n-  xmlURIUnescapeString;\n-\n-# encoding\n-  UTF8Toisolat1;\n-  isolat1ToUTF8;\n-  xmlAddEncodingAlias;\n-  xmlCharEncCloseFunc;\n-  xmlCharEncFirstLine;\n-  xmlCharEncInFunc;\n-  xmlCharEncOutFunc;\n-\n-# xmlstring\n-  xmlCheckUTF8;\n-\n-# encoding\n-  xmlCleanupCharEncodingHandlers;\n-  xmlCleanupEncodingAliases;\n-  xmlDelEncodingAlias;\n-  xmlDetectCharEncoding;\n-  xmlFindCharEncodingHandler;\n-  xmlGetCharEncodingHandler;\n-  xmlGetCharEncodingName;\n-  xmlGetEncodingAlias;\n-\n-# xmlstring\n-  xmlGetUTF8Char;\n-\n-# encoding\n-  xmlInitCharEncodingHandlers;\n-  xmlNewCharEncodingHandler;\n-  xmlParseCharEncoding;\n-  xmlRegisterCharEncodingHandler;\n-\n-# xmlstring\n-  xmlUTF8Strlen;\n-  xmlUTF8Strloc;\n-  xmlUTF8Strndup;\n-  xmlUTF8Strpos;\n-  xmlUTF8Strsize;\n-  xmlUTF8Strsub;\n-} ;\n-\n-LIBXML2_2.5.0 {\n-    global:\n-\n-# globals\n-  xmlDeregisterNodeDefault;\n-  xmlDeregisterNodeDefaultValue; # variable\n-  xmlRegisterNodeDefault;\n-  xmlRegisterNodeDefaultValue; # variable\n-\n-# xmlreader\n-  xmlTextReaderClose;\n-  xmlTextReaderCurrentDoc;\n-  xmlTextReaderCurrentNode;\n-  xmlTextReaderGetAttributeNo;\n-  xmlTextReaderGetAttributeNs;\n-  xmlTextReaderGetAttribute;\n-  xmlTextReaderGetParserProp;\n-  xmlTextReaderGetRemainder;\n-  xmlTextReaderLookupNamespace;\n-  xmlTextReaderMoveToAttributeNo;\n-  xmlTextReaderMoveToAttributeNs;\n-  xmlTextReaderMoveToAttribute;\n-  xmlTextReaderMoveToElement;\n-  xmlTextReaderMoveToFirstAttribute;\n-  xmlTextReaderMoveToNextAttribute;\n-  xmlTextReaderNormalization;\n-  xmlTextReaderReadAttributeValue;\n-  xmlTextReaderReadInnerXml;\n-  xmlTextReaderReadOuterXml;\n-  xmlTextReaderReadState;\n-  xmlTextReaderReadString;\n-  xmlTextReaderSetParserProp;\n-\n-# valid\n-  xmlValidatePopElement;\n-  xmlValidatePushCData;\n-  xmlValidatePushElement;\n-} LIBXML2_2.4.30;\n-\n-LIBXML2_2.5.2 {\n-    global:\n-\n-# tree\n-  xmlGetNoNsProp;\n-\n-# HTMLparser\n-  htmlAttrAllowed;\n-  htmlElementAllowedHere;\n-  htmlElementStatusHere;\n-  htmlNodeStatus;\n-\n-# relaxng\n-  xmlRelaxNGCleanupTypes;\n-  xmlRelaxNGDump;\n-  xmlRelaxNGFreeParserCtxt;\n-  xmlRelaxNGFree;\n-  xmlRelaxNGFreeValidCtxt;\n-  xmlRelaxNGNewMemParserCtxt;\n-  xmlRelaxNGNewParserCtxt;\n-  xmlRelaxNGNewValidCtxt;\n-  xmlRelaxNGParse;\n-  xmlRelaxNGSetParserErrors;\n-  xmlRelaxNGSetValidErrors;\n-  xmlRelaxNGValidateDoc;\n-\n-# xmlreader\n-  xmlTextReaderGetErrorHandler;\n-  xmlTextReaderLocatorBaseURI;\n-  xmlTextReaderLocatorLineNumber;\n-  xmlTextReaderSetErrorHandler;\n-\n-# relaxng\n-# xmlRelaxNGValidateStream; removed in 2.5.5\n-} LIBXML2_2.5.0;\n-\n-LIBXML2_2.5.4 {\n-    global:\n-\n-# uri\n-  xmlCanonicPath;\n-\n-# relaxng\n-  xmlRelaxNGDumpTree;\n-\n-# tree\n-  xmlValidateName;\n-  xmlValidateNCName;\n-  xmlValidateNMToken;\n-  xmlValidateQName;\n-} LIBXML2_2.5.2;\n-\n-LIBXML2_2.5.5 {\n-    global:\n-\n-# nanoftp\n-  xmlNanoFTPDele;\n-} LIBXML2_2.5.4;\n-\n-LIBXML2_2.5.6 {\n-    global:\n-\n-# xpath\n-  xmlXPathOrderDocElems;\n-} LIBXML2_2.5.5;\n-\n-LIBXML2_2.5.7 {\n-    global:\n-\n-# HTMLparser\n-  htmlCreateMemoryParserCtxt;\n-\n-# xmlautomata\n-  xmlAutomataNewTransition2;\n-\n-# tree\n-  xmlBuildQName;\n-\n-# xmlmemory\n-  xmlGcMemGet;\n-  xmlGcMemSetup;\n-\n-# globals\n-  xmlMallocAtomic; # variable\n-\n-# xmlregexp\n-  xmlRegExecPushString2;\n-\n-# relaxng\n-  xmlRelaxNGNewDocParserCtxt;\n-  xmlRelaxNGValidateFullElement;\n-  xmlRelaxNGValidatePopElement;\n-  xmlRelaxNGValidatePushCData;\n-  xmlRelaxNGValidatePushElement;\n-\n-# xmlreader\n-  xmlTextReaderExpand;\n-  xmlTextReaderIsValid;\n-  xmlTextReaderNext;\n-  xmlTextReaderRelaxNGSetSchema;\n-  xmlTextReaderRelaxNGValidate;\n-} LIBXML2_2.5.6;\n-\n-LIBXML2_2.5.8 {\n-    global:\n-\n-# globals\n-  xmlCleanupGlobals;\n-  xmlInitGlobals;\n-\n-# valid\n-  xmlFreeValidCtxt;\n-  xmlNewValidCtxt;\n-\n-# schemasInternals\n-  xmlSchemaFreeType;\n-\n-# xmlschemas\n-  xmlSchemaDump;\n-  xmlSchemaFreeParserCtxt;\n-  xmlSchemaFreeValidCtxt;\n-  xmlSchemaFree;\n-  xmlSchemaNewMemParserCtxt;\n-  xmlSchemaNewParserCtxt;\n-  xmlSchemaNewValidCtxt;\n-  xmlSchemaParse;\n-  xmlSchemaSetParserErrors;\n-  xmlSchemaSetValidErrors;\n-  xmlSchemaValidateDoc;\n-  xmlSchemaValidateStream;\n-\n-# xmlschemastypes\n-  xmlSchemaCheckFacet;\n-  xmlSchemaCleanupTypes;\n-  xmlSchemaCompareValues;\n-  xmlSchemaFreeFacet;\n-  xmlSchemaFreeValue;\n-  xmlSchemaGetPredefinedType;\n-  xmlSchemaInitTypes;\n-  xmlSchemaNewFacet;\n-  xmlSchemaValidateFacet;\n-  xmlSchemaValidatePredefinedType;\n-  xmlSchemaValPredefTypeNode;\n-\n-# globals\n-  xmlThrDefBufferAllocScheme;\n-  xmlThrDefDefaultBufferSize;\n-  xmlThrDefDeregisterNodeDefault;\n-  xmlThrDefDoValidityCheckingDefaultValue;\n-  xmlThrDefGetWarningsDefaultValue;\n-  xmlThrDefIndentTreeOutput;\n-  xmlThrDefKeepBlanksDefaultValue;\n-  xmlThrDefLineNumbersDefaultValue;\n-  xmlThrDefLoadExtDtdDefaultValue;\n-  xmlThrDefParserDebugEntities;\n-  xmlThrDefPedanticParserDefaultValue;\n-  xmlThrDefRegisterNodeDefault;\n-  xmlThrDefSaveNoEmptyTags;\n-  xmlThrDefSetGenericErrorFunc;\n-  xmlThrDefSubstituteEntitiesDefaultValue;\n-  xmlThrDefTreeIndentString;\n-} LIBXML2_2.5.7;\n-\n-LIBXML2_2.5.9 {\n-    global:\n-\n-# xmlmemory\n-  xmlMallocAtomicLoc;\n-\n-# relaxng\n-  xmlRelaxNGGetParserErrors;\n-  xmlRelaxNGGetValidErrors;\n-\n-# tree\n-  xmlSplitQName3;\n-\n-# xmlstring\n-  xmlUTF8Charcmp;\n-  xmlUTF8Size;\n-\n-# xinclude\n-  xmlXIncludeProcessTree;\n-} LIBXML2_2.5.8;\n-\n-LIBXML2_2.6.0 {\n-    global:\n-\n-# SAX2\n-  xmlSAX2AttributeDecl;\n-  xmlSAX2CDataBlock;\n-  xmlSAX2Characters;\n-  xmlSAX2Comment;\n-  xmlSAX2ElementDecl;\n-  xmlSAX2EndDocument;\n-  xmlSAX2EndElementNs;\n-  xmlSAX2EndElement;\n-  xmlSAX2EntityDecl;\n-  xmlSAX2ExternalSubset;\n-  xmlSAX2GetColumnNumber;\n-  xmlSAX2GetEntity;\n-  xmlSAX2GetLineNumber;\n-  xmlSAX2GetParameterEntity;\n-  xmlSAX2GetPublicId;\n-  xmlSAX2GetSystemId;\n-  xmlSAX2HasExternalSubset;\n-  xmlSAX2HasInternalSubset;\n-  xmlSAX2IgnorableWhitespace;\n-  xmlSAX2InitDefaultSAXHandler;\n-# xmlSAX2InitDocbDefaultSAXHandler; removed in 2.10.0\n-  xmlSAX2InitHtmlDefaultSAXHandler;\n-  xmlSAX2InternalSubset;\n-  xmlSAX2IsStandalone;\n-  xmlSAX2NotationDecl;\n-  xmlSAX2ProcessingInstruction;\n-  xmlSAX2Reference;\n-  xmlSAX2ResolveEntity;\n-  xmlSAX2SetDocumentLocator;\n-  xmlSAX2StartDocument;\n-  xmlSAX2StartElementNs;\n-  xmlSAX2StartElement;\n-  xmlSAX2UnparsedEntityDecl;\n-  xmlSAXDefaultVersion;\n-  xmlSAXVersion;\n-\n-# HTMLparser\n-  htmlCtxtReadDoc;\n-  htmlCtxtReadFd;\n-  htmlCtxtReadFile;\n-  htmlCtxtReadIO;\n-  htmlCtxtReadMemory;\n-  htmlCtxtReset;\n-  htmlCtxtUseOptions;\n-  htmlReadDoc;\n-  htmlReadFd;\n-  htmlReadFile;\n-  htmlReadIO;\n-  htmlReadMemory;\n-\n-# tree\n-  xmlBufferCreateStatic;\n-\n-# chvalid\n-  xmlCharInRange;\n-\n-# xmlIO\n-  xmlCheckHTTPInput;\n-\n-# xmlerror\n-  xmlCopyError;\n-  xmlCtxtGetLastError;\n-  xmlGetLastError;\n-  xmlResetError;\n-  xmlResetLastError;\n-  xmlSetStructuredErrorFunc;\n-\n-# parser\n-  xmlCtxtReadDoc;\n-  xmlCtxtReadFd;\n-  xmlCtxtReadFile;\n-  xmlCtxtReadIO;\n-  xmlCtxtReadMemory;\n-\n-# xmlerror\n-  xmlCtxtResetLastError;\n-\n-# parser\n-  xmlCtxtReset;\n-  xmlCtxtUseOptions;\n-  xmlReadDoc;\n-  xmlReadFd;\n-  xmlReadFile;\n-  xmlReadIO;\n-  xmlReadMemory;\n-\n-# xmlstring\n-  xmlStrPrintf;\n-  xmlStrQEqual;\n-\n-# dict\n-  xmlDictCreate;\n-  xmlDictFree;\n-  xmlDictLookup;\n-  xmlDictOwns;\n-  xmlDictQLookup;\n-  xmlDictReference;\n-  xmlDictSize;\n-\n-# parserInternals\n-  xmlErrMemory;\n-  xmlParserMaxDepth; # variable\n-  xmlStringLenDecodeEntities;\n-  xmlSwitchInputEncoding;\n-\n-# xmlwriter\n-  xmlFreeTextWriter;\n-  xmlNewTextWriterFilename;\n-  xmlNewTextWriterMemory;\n-  xmlNewTextWriter;\n-  xmlTextWriterEndAttribute;\n-  xmlTextWriterEndCDATA;\n-  xmlTextWriterEndDocument;\n-  xmlTextWriterEndDTD;\n-  xmlTextWriterEndElement;\n-  xmlTextWriterEndPI;\n-  xmlTextWriterFlush;\n-  xmlTextWriterFullEndElement;\n-  xmlTextWriterStartAttributeNS;\n-  xmlTextWriterStartAttribute;\n-  xmlTextWriterStartCDATA;\n-  xmlTextWriterStartDocument;\n-  xmlTextWriterStartDTDAttlist;\n-  xmlTextWriterStartDTDElement;\n-  xmlTextWriterStartDTDEntity;\n-  xmlTextWriterStartDTD;\n-  xmlTextWriterStartElementNS;\n-  xmlTextWriterStartElement;\n-  xmlTextWriterStartPI;\n-  xmlTextWriterWriteAttributeNS;\n-  xmlTextWriterWriteAttribute;\n-  xmlTextWriterWriteBase64;\n-  xmlTextWriterWriteBinHex;\n-  xmlTextWriterWriteCDATA;\n-  xmlTextWriterWriteComment;\n-  xmlTextWriterWriteDTDAttlist;\n-  xmlTextWriterWriteDTDElement;\n-  xmlTextWriterWriteDTDEntity;\n-  xmlTextWriterWriteDTDExternalEntity;\n-  xmlTextWriterWriteDTDInternalEntity;\n-  xmlTextWriterWriteDTDNotation;\n-  xmlTextWriterWriteDTD;\n-  xmlTextWriterWriteElementNS;\n-  xmlTextWriterWriteElement;\n-  xmlTextWriterWriteFormatAttributeNS;\n-  xmlTextWriterWriteFormatAttribute;\n-  xmlTextWriterWriteFormatCDATA;\n-  xmlTextWriterWriteFormatComment;\n-  xmlTextWriterWriteFormatDTDAttlist;\n-  xmlTextWriterWriteFormatDTDElement;\n-  xmlTextWriterWriteFormatDTDInternalEntity;\n-  xmlTextWriterWriteFormatDTD;\n-  xmlTextWriterWriteFormatElementNS;\n-  xmlTextWriterWriteFormatElement;\n-  xmlTextWriterWriteFormatPI;\n-  xmlTextWriterWriteFormatRaw;\n-  xmlTextWriterWriteFormatString;\n-  xmlTextWriterWritePI;\n-  xmlTextWriterWriteRawLen;\n-  xmlTextWriterWriteRaw;\n-  xmlTextWriterWriteString;\n-  xmlTextWriterWriteVFormatAttributeNS;\n-  xmlTextWriterWriteVFormatAttribute;\n-  xmlTextWriterWriteVFormatCDATA;\n-  xmlTextWriterWriteVFormatComment;\n-  xmlTextWriterWriteVFormatDTDAttlist;\n-  xmlTextWriterWriteVFormatDTDElement;\n-  xmlTextWriterWriteVFormatDTDInternalEntity;\n-  xmlTextWriterWriteVFormatDTD;\n-  xmlTextWriterWriteVFormatElementNS;\n-  xmlTextWriterWriteVFormatElement;\n-  xmlTextWriterWriteVFormatPI;\n-  xmlTextWriterWriteVFormatRaw;\n-  xmlTextWriterWriteVFormatString;\n-\n-# hash\n-  xmlHashQLookup2;\n-  xmlHashQLookup3;\n-  xmlHashQLookup;\n-\n-# chvalid\n-  xmlIsBaseCharGroup; # variable\n-  xmlIsCharGroup; # variable\n-  xmlIsCombiningGroup; # variable\n-  xmlIsDigitGroup; # variable\n-  xmlIsExtenderGroup; # variable\n-  xmlIsIdeographicGroup; # variable\n-  xmlIsPubidChar_tab; # variable\n-\n-# globals\n-  xmlLastError; # variable\n-\n-# nanohttp\n-  xmlNanoHTTPEncoding;\n-  xmlNanoHTTPMimeType;\n-  xmlNanoHTTPRedir;\n-\n-# tree\n-  xmlNodeBufGetContent;\n-\n-# xmlIO\n-  xmlParserInputBufferCreateStatic;\n-\n-# xmlreader\n-  xmlReaderForDoc;\n-  xmlReaderForFd;\n-  xmlReaderForFile;\n-  xmlReaderForIO;\n-  xmlReaderForMemory;\n-  xmlReaderNewDoc;\n-  xmlReaderNewFd;\n-  xmlReaderNewFile;\n-  xmlReaderNewIO;\n-  xmlReaderNewMemory;\n-  xmlReaderNewWalker;\n-  xmlReaderWalker;\n-  xmlTextReaderConstBaseUri;\n-  xmlTextReaderConstLocalName;\n-  xmlTextReaderConstNamespaceUri;\n-  xmlTextReaderConstName;\n-  xmlTextReaderConstPrefix;\n-  xmlTextReaderConstString;\n-  xmlTextReaderConstValue;\n-  xmlTextReaderConstXmlLang;\n-  xmlTextReaderNextSibling;\n-  xmlTextReaderPreserve;\n-\n-# globals\n-  xmlStructuredError; # variable\n-  xmlThrDefSetStructuredErrorFunc;\n-\n-# xpathInternals\n-  xmlXPathErr;\n-\n-# SAX2\n-# xmlSAX2CheckNamespace; removed in 2.6.10\n-# xmlSAX2GetNamespace; removed in 2.6.10\n-# xmlSAX2GlobalNamespace; removed in 2.6.10\n-# xmlSAX2NamespaceDecl; removed in 2.6.10\n-# xmlSAX2SetNamespace; removed in 2.6.10\n-} LIBXML2_2.5.9;\n-\n-LIBXML2_2.6.1 {\n-    global:\n-\n-# parser\n-  xmlCtxtResetPush;\n-} LIBXML2_2.6.0;\n-\n-LIBXML2_2.6.2 {\n-    global:\n-\n-# parserInternals\n-  xmlCreateURLParserCtxt;\n-\n-# xmlschemas\n-  xmlSchemaNewDocParserCtxt;\n-\n-# xmlstring\n-  xmlStrVPrintf;\n-\n-# xinclude\n-  xmlXIncludeFreeContext;\n-  xmlXIncludeNewContext;\n-  xmlXIncludeProcessNode;\n-} LIBXML2_2.6.1;\n-\n-LIBXML2_2.6.3 {\n-    global:\n-\n-# pattern\n-  xmlFreePatternList;\n-  xmlFreePattern;\n-  xmlPatterncompile;\n-  xmlPatternMatch;\n-\n-# xmlwriter\n-  xmlNewTextWriterDoc;\n-  xmlNewTextWriterPushParser;\n-  xmlNewTextWriterTree;\n-\n-# xmlreader\n-  xmlTextReaderPreservePattern;\n-\n-# xmlunicode\n-  xmlUCSIsAegeanNumbers;\n-  xmlUCSIsBuhid;\n-  xmlUCSIsCombiningDiacriticalMarksforSymbols;\n-  xmlUCSIsCypriotSyllabary;\n-  xmlUCSIsCyrillicSupplement;\n-  xmlUCSIsGreekandCoptic;\n-  xmlUCSIsHanunoo;\n-  xmlUCSIsKatakanaPhoneticExtensions;\n-  xmlUCSIsKhmerSymbols;\n-  xmlUCSIsLimbu;\n-  xmlUCSIsLinearBIdeograms;\n-  xmlUCSIsLinearBSyllabary;\n-  xmlUCSIsMiscellaneousMathematicalSymbolsA;\n-  xmlUCSIsMiscellaneousMathematicalSymbolsB;\n-  xmlUCSIsMiscellaneousSymbolsandArrows;\n-  xmlUCSIsOsmanya;\n-  xmlUCSIsPhoneticExtensions;\n-  xmlUCSIsPrivateUseArea;\n-  xmlUCSIsShavian;\n-  xmlUCSIsSupplementalArrowsA;\n-  xmlUCSIsSupplementalArrowsB;\n-  xmlUCSIsSupplementalMathematicalOperators;\n-  xmlUCSIsSupplementaryPrivateUseAreaA;\n-  xmlUCSIsSupplementaryPrivateUseAreaB;\n-  xmlUCSIsTagalog;\n-  xmlUCSIsTagbanwa;\n-  xmlUCSIsTaiLe;\n-  xmlUCSIsTaiXuanJingSymbols;\n-  xmlUCSIsUgaritic;\n-  xmlUCSIsVariationSelectorsSupplement;\n-  xmlUCSIsVariationSelectors;\n-  xmlUCSIsYijingHexagramSymbols;\n-\n-# xinclude\n-  xmlXIncludeProcessFlags;\n-  xmlXIncludeProcessTreeFlags;\n-  xmlXIncludeSetFlags;\n-} LIBXML2_2.6.2;\n-\n-LIBXML2_2.6.5 {\n-    global:\n-\n-# xmlmemory\n-  xmlCleanupMemory;\n-\n-# dict\n-  xmlDictCreateSub;\n-\n-# relaxng\n-  xmlRelaxParserSetFlag;\n-\n-# xmlstring\n-  xmlStrncatNew;\n-\n-# xmlwriter\n-  xmlTextWriterSetIndentString;\n-  xmlTextWriterSetIndent;\n-\n-# xpath\n-  xmlXPathCtxtCompile;\n-} LIBXML2_2.6.3;\n-\n-LIBXML2_2.6.6 {\n-    global:\n-\n-# tree\n-  xmlAttrSerializeTxtContent;\n-\n-# parser\n-  xmlByteConsumed;\n-\n-# xmlreader\n-  xmlTextReaderSetStructuredErrorHandler;\n-} LIBXML2_2.6.5;\n-\n-LIBXML2_2.6.7 {\n-    global:\n-\n-# xmlwriter\n-  xmlTextWriterEndComment;\n-  xmlTextWriterStartComment;\n-} LIBXML2_2.6.6;\n-\n-LIBXML2_2.6.8 {\n-    global:\n-\n-# xmlsave\n-  xmlSaveClose;\n-  xmlSaveDoc;\n-  xmlSaveFlush;\n-  xmlSaveToFd;\n-  xmlSaveToFilename;\n-  xmlSaveToIO;\n-  xmlSaveTree;\n-\n-# xmlwriter\n-  xmlTextWriterEndDTDAttlist;\n-  xmlTextWriterEndDTDElement;\n-  xmlTextWriterEndDTDEntity;\n-  xmlTextWriterWriteDTDExternalEntityContents;\n-} LIBXML2_2.6.7;\n-\n-LIBXML2_2.6.10 {\n-    global:\n-\n-# xmlIO\n-  xmlOutputBufferWriteEscape;\n-  xmlPopInputCallbacks;\n-\n-# xmlsave\n-  xmlSaveSetAttrEscape;\n-  xmlSaveSetEscape;\n-} LIBXML2_2.6.8;\n-\n-LIBXML2_2.6.11 {\n-    global:\n-\n-# uri\n-  xmlBuildRelativeURI;\n-\n-# globals\n-  xmlOutputBufferCreateFilenameDefault;\n-  xmlOutputBufferCreateFilenameValue; # variable\n-  xmlParserInputBufferCreateFilenameDefault;\n-  xmlParserInputBufferCreateFilenameValue; # variable\n-  xmlThrDefOutputBufferCreateFilenameDefault;\n-  xmlThrDefParserInputBufferCreateFilenameDefault;\n-\n-# schemasInternals\n-  xmlSchemaFreeWildcard;\n-\n-# xmlschemastypes\n-  xmlSchemaCollapseString;\n-  xmlSchemaGetBuiltInListSimpleTypeItemType;\n-  xmlSchemaGetBuiltInType;\n-  xmlSchemaIsBuiltInTypeFacet;\n-  xmlSchemaValidateListSimpleTypeFacet;\n-} LIBXML2_2.6.10;\n-\n-LIBXML2_2.6.12 {\n-    global:\n-\n-# parser\n-  xmlParseInNodeContext;\n-\n-# xmlschemastypes\n-  xmlSchemaGetFacetValueAsULong;\n-  xmlSchemaValidateLengthFacet;\n-  xmlSchemaValPredefTypeNodeNoNorm;\n-\n-# xmlschemas\n-  xmlSchemaGetParserErrors;\n-  xmlSchemaGetValidErrors;\n-} LIBXML2_2.6.11;\n-\n-LIBXML2_2.6.14 {\n-    global:\n-\n-# xmlautomata\n-  xmlAutomataNewCountTrans2;\n-  xmlAutomataNewOnceTrans2;\n-\n-# nanohttp\n-  xmlNanoHTTPContentLength;\n-\n-# xmlschemas\n-  xmlSchemaSetValidOptions;\n-  xmlSchemaValidateOneElement;\n-  xmlSchemaValidCtxtGetOptions;\n-} LIBXML2_2.6.12;\n-\n-LIBXML2_2.6.15 {\n-    global:\n-\n-# debugXML\n-  xmlDebugCheckDocument;\n-\n-# tree\n-  xmlDocCopyNodeList;\n-  xmlNewDocPI;\n-\n-# xmlreader\n-  xmlTextReaderConstEncoding;\n-  xmlTextReaderConstXmlVersion;\n-  xmlTextReaderIsNamespaceDecl;\n-  xmlTextReaderStandalone;\n-} LIBXML2_2.6.14;\n-\n-LIBXML2_2.6.16 {\n-    global:\n-\n-# xmlmemory\n-  xmlMemBlocks;\n-\n-# relaxng\n-  xmlRelaxNGInitTypes;\n-} LIBXML2_2.6.15;\n-\n-LIBXML2_2.6.17 {\n-    global:\n-\n-# dict\n-  xmlDictExists;\n-\n-# xmlmodule\n-  xmlModuleClose;\n-  xmlModuleFree;\n-  xmlModuleOpen;\n-  xmlModuleSymbol;\n-\n-# xmlregexp\n-  xmlRegExecErrInfo;\n-  xmlRegExecNextValues;\n-\n-# xmlschemastypes\n-  xmlSchemaWhiteSpaceReplace;\n-\n-# xmlreader\n-  xmlTextReaderGetParserColumnNumber;\n-  xmlTextReaderGetParserLineNumber;\n-} LIBXML2_2.6.16;\n-\n-LIBXML2_2.6.18 {\n-    global:\n-\n-# valid\n-  xmlCopyDocElementContent;\n-  xmlFreeDocElementContent;\n-  xmlNewDocElementContent;\n-\n-# dict\n-  xmlDictCleanup;\n-\n-# hash\n-  xmlHashCreateDict;\n-\n-# pattern\n-  xmlFreeStreamCtxt;\n-  xmlPatternFromRoot;\n-  xmlPatternGetStreamCtxt;\n-  xmlPatternMaxDepth;\n-  xmlPatternStreamable;\n-  xmlStreamPop;\n-  xmlStreamPushAttr;\n-  xmlStreamPush;\n-\n-# xmlschemastypes\n-  xmlSchemaCompareValuesWhtsp;\n-  xmlSchemaCopyValue;\n-  xmlSchemaGetCanonValue;\n-  xmlSchemaNewNOTATIONValue;\n-  xmlSchemaNewStringValue;\n-\n-# xmlreader\n-  xmlTextReaderByteConsumed;\n-} LIBXML2_2.6.17;\n-\n-LIBXML2_2.6.19 {\n-    global:\n-\n-# xmlschemastypes\n-  xmlSchemaGetValType;\n-  xmlSchemaValidateFacetWhtsp;\n-  xmlSchemaValidateLengthFacetWhtsp;\n-} LIBXML2_2.6.18;\n-\n-LIBXML2_2.6.20 {\n-    global:\n-\n-# tree\n-  xmlDOMWrapAdoptNode;\n-  xmlDOMWrapFreeCtxt;\n-  xmlDOMWrapNewCtxt;\n-  xmlDOMWrapReconcileNamespaces;\n-  xmlDOMWrapRemoveNode;\n-\n-# xmlschemastypes\n-  xmlSchemaGetCanonValueWhtsp;\n-  xmlSchemaNewQNameValue;\n-  xmlSchemaValueAppend;\n-  xmlSchemaValueGetAsBoolean;\n-  xmlSchemaValueGetAsString;\n-  xmlSchemaValueGetNext;\n-\n-# xmlschemas\n-  xmlSchemaIsValid;\n-  xmlSchemaSAXPlug;\n-  xmlSchemaSAXUnplug;\n-  xmlSchemaValidateFile;\n-\n-# xmlreader\n-  xmlTextReaderSchemaValidate;\n-  xmlTextReaderSetSchema;\n-} LIBXML2_2.6.19;\n-\n-LIBXML2_2.6.21 {\n-    global:\n-\n-# xmlautomata\n-  xmlAutomataNewNegTrans;\n-\n-# xmlregexp\n-# emptyExp; removed in 2.9.10\n-# forbiddenExp; removed in 2.9.10\n-# xmlExpCtxtNbCons; removed in 2.9.10\n-# xmlExpCtxtNbNodes; removed in 2.9.10\n-# xmlExpDump; removed in 2.9.10\n-# xmlExpExpDerive; removed in 2.9.10\n-# xmlExpFreeCtxt; removed in 2.9.10\n-# xmlExpFree; removed in 2.9.10\n-# xmlExpGetLanguage; removed in 2.9.10\n-# xmlExpGetStart; removed in 2.9.10\n-# xmlExpIsNillable; removed in 2.9.10\n-# xmlExpMaxToken; removed in 2.9.10\n-# xmlExpNewAtom; removed in 2.9.10\n-# xmlExpNewCtxt; removed in 2.9.10\n-# xmlExpNewOr; removed in 2.9.10\n-# xmlExpNewRange; removed in 2.9.10\n-# xmlExpNewSeq; removed in 2.9.10\n-# xmlExpParse; removed in 2.9.10\n-# xmlExpRef; removed in 2.9.10\n-# xmlExpStringDerive; removed in 2.9.10\n-# xmlExpSubsume; removed in 2.9.10\n-\n-# parser\n-  xmlHasFeature;\n-\n-# uri\n-  xmlParseURIRaw;\n-\n-# pattern\n-  xmlPatternMinDepth;\n-\n-# relaxng\n-  xmlRelaxNGSetValidStructuredErrors;\n-\n-# xmlschemas\n-  xmlSchemaSetValidStructuredErrors;\n-\n-# schematron\n-  xmlSchematronFreeParserCtxt;\n-  xmlSchematronFree;\n-  xmlSchematronFreeValidCtxt;\n-  xmlSchematronNewDocParserCtxt;\n-  xmlSchematronNewMemParserCtxt;\n-  xmlSchematronNewParserCtxt;\n-  xmlSchematronNewValidCtxt;\n-  xmlSchematronParse;\n-  xmlSchematronValidateDoc;\n-} LIBXML2_2.6.20;\n-\n-LIBXML2_2.6.23 {\n-    global:\n-\n-# HTMLtree\n-  htmlDocDumpMemoryFormat;\n-\n-# xmlIO\n-  xmlOutputBufferCreateBuffer;\n-\n-# xmlsave\n-  xmlSaveToBuffer;# suppressed in 2.6.11, readded in 2.6.23\n-\n-\n-# xmlschemas\n-  xmlSchemaSetParserStructuredErrors;\n-\n-# pattern\n-  xmlStreamPushNode;\n-  xmlStreamWantsAnyNode;\n-\n-# xmlreader\n-  xmlTextReaderSchemaValidateCtxt;\n-} LIBXML2_2.6.21;\n-\n-LIBXML2_2.6.24 {\n-    global:\n-\n-# tree\n-  xmlDOMWrapCloneNode;\n-\n-# relaxng\n-  xmlRelaxNGSetParserStructuredErrors;\n-} LIBXML2_2.6.23;\n-\n-LIBXML2_2.6.25 {\n-    global:\n-\n-# xpath\n-  xmlXPathContextSetCache;\n-} LIBXML2_2.6.24;\n-\n-LIBXML2_2.6.27 {\n-    global:\n-\n-# HTMLparser\n-  htmlNewParserCtxt;\n-\n-# uri\n-  xmlPathToURI;\n-\n-# xinclude\n-  xmlXIncludeProcessFlagsData;\n-\n-# xpath\n-  xmlXPathCompiledEvalToBoolean;\n-} LIBXML2_2.6.25;\n-\n-LIBXML2_2.6.28 {\n-    global:\n-\n-# xmlreader\n-  xmlTextReaderSetup;\n-} LIBXML2_2.6.27;\n-\n-LIBXML2_2.6.29 {\n-    global:\n-\n-# threads\n-  xmlDllMain;\n-} LIBXML2_2.6.28;\n-\n-LIBXML2_2.6.32 {\n-    global:\n-\n-# schematron\n-  xmlSchematronSetValidStructuredErrors;\n-} LIBXML2_2.6.29;\n-\n-LIBXML2_2.7.0 {\n-    global:\n-\n-# xmlmemory\n-  xmlMemDisplayLast;\n-\n-# entities\n-  xmlNewEntity;\n-\n-# xmlschemas\n-  xmlSchemaValidCtxtGetParserCtxt;\n-} LIBXML2_2.6.32;\n-\n-LIBXML2_2.7.3 {\n-    global:\n-\n-# tree\n-  xmlChildElementCount;\n-  xmlFirstElementChild;\n-  xmlLastElementChild;\n-  xmlNextElementSibling;\n-  xmlPreviousElementSibling;\n-} LIBXML2_2.7.0;\n-\n-LIBXML2_2.7.4 {\n-    global:\n-\n-# globals\n-  xmlStructuredErrorContext; # variable\n-\n-# xinclude\n-  xmlXIncludeProcessTreeFlagsData;\n-} LIBXML2_2.7.3;\n-\n-LIBXML2_2.8.0 {\n-    global:\n-\n-# xmlreader\n-  xmlTextReaderRelaxNGValidateCtxt;\n-\n-# tree\n-  xmlBufferDetach;\n-\n-# dict\n-  xmlInitializeDict;\n-} LIBXML2_2.7.4;\n-\n-LIBXML2_2.9.0 {\n-    global:\n-\n-# tree\n-  xmlBufContent;\n-  xmlBufEnd;\n-  xmlBufGetNodeContent;\n-  xmlBufNodeDump;\n-  xmlBufShrink;\n-  xmlBufUse;\n-\n-# dict\n-  xmlDictGetUsage;\n-  xmlDictSetLimit;\n-\n-# xmlschemas\n-  xmlSchemaValidateSetFilename;\n-  xmlSchemaValidateSetLocator;\n-\n-# xmlIO\n-  xmlOutputBufferGetContent;\n-  xmlOutputBufferGetSize;\n-\n-# xmlwriter\n-  xmlTextWriterSetQuoteChar;\n-} LIBXML2_2.8.0;\n-\n-LIBXML2_2.9.1 {\n-    global:\n-\n-# xpath\n-  xmlXPathNodeEval;\n-  xmlXPathSetContextNode;\n-} LIBXML2_2.9.0;\n-\n-LIBXML2_2.9.8 {\n-    global:\n-\n-# hash\n-  xmlHashDefaultDeallocator;\n-} LIBXML2_2.9.1;\n-\n-LIBXML2_2.9.11 {\n-    global:\n-\n-# xmlIO\n-  xmlPopOutputCallbacks;\n-} LIBXML2_2.9.8;\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml2.syms","additions":0,"deletions":2285,"binary":false,"changes":2285,"status":"deleted"},{"patch":"@@ -1,10839 +0,0 @@\n-\/*\n- * relaxng.c : implementation of the Relax-NG handling and validity checking\n- *\n- * See Copyright for the status of this software.\n- *\n- * Daniel Veillard <veillard@redhat.com>\n- *\/\n-\n-\/**\n- * TODO:\n- * - add support for DTD compatibility spec\n- *   http:\/\/www.oasis-open.org\/committees\/relax-ng\/compatibility-20011203.html\n- * - report better mem allocations pbms at runtime and abort immediately.\n- *\/\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-\n-#include <string.h>\n-#include <stdio.h>\n-#include <stddef.h>\n-#include <libxml\/xmlmemory.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/hash.h>\n-#include <libxml\/uri.h>\n-\n-#include <libxml\/relaxng.h>\n-\n-#include <libxml\/xmlschemastypes.h>\n-#include <libxml\/xmlautomata.h>\n-#include <libxml\/xmlregexp.h>\n-#include <libxml\/xmlschemastypes.h>\n-\n-#include \"private\/error.h\"\n-#include \"private\/regexp.h\"\n-#include \"private\/string.h\"\n-\n-\/*\n- * The Relax-NG namespace\n- *\/\n-static const xmlChar *xmlRelaxNGNs = (const xmlChar *)\n-    \"http:\/\/relaxng.org\/ns\/structure\/1.0\";\n-\n-#define IS_RELAXNG(node, typ)                        \\\n-   ((node != NULL) && (node->ns != NULL) &&                \\\n-    (node->type == XML_ELEMENT_NODE) &&                    \\\n-    (xmlStrEqual(node->name, (const xmlChar *) typ)) &&        \\\n-    (xmlStrEqual(node->ns->href, xmlRelaxNGNs)))\n-\n-\n-#define MAX_ERROR 5\n-\n-typedef struct _xmlRelaxNGSchema xmlRelaxNGSchema;\n-typedef xmlRelaxNGSchema *xmlRelaxNGSchemaPtr;\n-\n-typedef struct _xmlRelaxNGDefine xmlRelaxNGDefine;\n-typedef xmlRelaxNGDefine *xmlRelaxNGDefinePtr;\n-\n-typedef struct _xmlRelaxNGDocument xmlRelaxNGDocument;\n-typedef xmlRelaxNGDocument *xmlRelaxNGDocumentPtr;\n-\n-typedef struct _xmlRelaxNGInclude xmlRelaxNGInclude;\n-typedef xmlRelaxNGInclude *xmlRelaxNGIncludePtr;\n-\n-typedef enum {\n-    XML_RELAXNG_COMBINE_UNDEFINED = 0,  \/* undefined *\/\n-    XML_RELAXNG_COMBINE_CHOICE, \/* choice *\/\n-    XML_RELAXNG_COMBINE_INTERLEAVE      \/* interleave *\/\n-} xmlRelaxNGCombine;\n-\n-typedef enum {\n-    XML_RELAXNG_CONTENT_ERROR = -1,\n-    XML_RELAXNG_CONTENT_EMPTY = 0,\n-    XML_RELAXNG_CONTENT_SIMPLE,\n-    XML_RELAXNG_CONTENT_COMPLEX\n-} xmlRelaxNGContentType;\n-\n-typedef struct _xmlRelaxNGGrammar xmlRelaxNGGrammar;\n-typedef xmlRelaxNGGrammar *xmlRelaxNGGrammarPtr;\n-\n-struct _xmlRelaxNGGrammar {\n-    xmlRelaxNGGrammarPtr parent;        \/* the parent grammar if any *\/\n-    xmlRelaxNGGrammarPtr children;      \/* the children grammar if any *\/\n-    xmlRelaxNGGrammarPtr next;  \/* the next grammar if any *\/\n-    xmlRelaxNGDefinePtr start;  \/* <start> content *\/\n-    xmlRelaxNGCombine combine;  \/* the default combine value *\/\n-    xmlRelaxNGDefinePtr startList;      \/* list of <start> definitions *\/\n-    xmlHashTablePtr defs;       \/* define* *\/\n-    xmlHashTablePtr refs;       \/* references *\/\n-};\n-\n-\n-typedef enum {\n-    XML_RELAXNG_NOOP = -1,      \/* a no operation from simplification  *\/\n-    XML_RELAXNG_EMPTY = 0,      \/* an empty pattern *\/\n-    XML_RELAXNG_NOT_ALLOWED,    \/* not allowed top *\/\n-    XML_RELAXNG_EXCEPT,         \/* except present in nameclass defs *\/\n-    XML_RELAXNG_TEXT,           \/* textual content *\/\n-    XML_RELAXNG_ELEMENT,        \/* an element *\/\n-    XML_RELAXNG_DATATYPE,       \/* external data type definition *\/\n-    XML_RELAXNG_PARAM,          \/* external data type parameter *\/\n-    XML_RELAXNG_VALUE,          \/* value from an external data type definition *\/\n-    XML_RELAXNG_LIST,           \/* a list of patterns *\/\n-    XML_RELAXNG_ATTRIBUTE,      \/* an attribute following a pattern *\/\n-    XML_RELAXNG_DEF,            \/* a definition *\/\n-    XML_RELAXNG_REF,            \/* reference to a definition *\/\n-    XML_RELAXNG_EXTERNALREF,    \/* reference to an external def *\/\n-    XML_RELAXNG_PARENTREF,      \/* reference to a def in the parent grammar *\/\n-    XML_RELAXNG_OPTIONAL,       \/* optional patterns *\/\n-    XML_RELAXNG_ZEROORMORE,     \/* zero or more non empty patterns *\/\n-    XML_RELAXNG_ONEORMORE,      \/* one or more non empty patterns *\/\n-    XML_RELAXNG_CHOICE,         \/* a choice between non empty patterns *\/\n-    XML_RELAXNG_GROUP,          \/* a pair\/group of non empty patterns *\/\n-    XML_RELAXNG_INTERLEAVE,     \/* interleaving choice of non-empty patterns *\/\n-    XML_RELAXNG_START           \/* Used to keep track of starts on grammars *\/\n-} xmlRelaxNGType;\n-\n-#define IS_NULLABLE        (1 << 0)\n-#define IS_NOT_NULLABLE        (1 << 1)\n-#define IS_INDETERMINIST    (1 << 2)\n-#define IS_MIXED        (1 << 3)\n-#define IS_TRIABLE        (1 << 4)\n-#define IS_PROCESSED        (1 << 5)\n-#define IS_COMPILABLE        (1 << 6)\n-#define IS_NOT_COMPILABLE    (1 << 7)\n-#define IS_EXTERNAL_REF            (1 << 8)\n-\n-struct _xmlRelaxNGDefine {\n-    xmlRelaxNGType type;        \/* the type of definition *\/\n-    xmlNodePtr node;            \/* the node in the source *\/\n-    xmlChar *name;              \/* the element local name if present *\/\n-    xmlChar *ns;                \/* the namespace local name if present *\/\n-    xmlChar *value;             \/* value when available *\/\n-    void *data;                 \/* data lib or specific pointer *\/\n-    xmlRelaxNGDefinePtr content;        \/* the expected content *\/\n-    xmlRelaxNGDefinePtr parent; \/* the parent definition, if any *\/\n-    xmlRelaxNGDefinePtr next;   \/* list within grouping sequences *\/\n-    xmlRelaxNGDefinePtr attrs;  \/* list of attributes for elements *\/\n-    xmlRelaxNGDefinePtr nameClass;      \/* the nameClass definition if any *\/\n-    xmlRelaxNGDefinePtr nextHash;       \/* next define in defs\/refs hash tables *\/\n-    short depth;                \/* used for the cycle detection *\/\n-    short dflags;               \/* define related flags *\/\n-    xmlRegexpPtr contModel;     \/* a compiled content model if available *\/\n-};\n-\n-\/**\n- * _xmlRelaxNG:\n- *\n- * A RelaxNGs definition\n- *\/\n-struct _xmlRelaxNG {\n-    void *_private;             \/* unused by the library for users or bindings *\/\n-    xmlRelaxNGGrammarPtr topgrammar;\n-    xmlDocPtr doc;\n-\n-    int idref;                  \/* requires idref checking *\/\n-\n-    xmlHashTablePtr defs;       \/* define *\/\n-    xmlHashTablePtr refs;       \/* references *\/\n-    xmlRelaxNGDocumentPtr documents;    \/* all the documents loaded *\/\n-    xmlRelaxNGIncludePtr includes;      \/* all the includes loaded *\/\n-    int defNr;                  \/* number of defines used *\/\n-    xmlRelaxNGDefinePtr *defTab;        \/* pointer to the allocated definitions *\/\n-\n-};\n-\n-#define XML_RELAXNG_IN_ATTRIBUTE    (1 << 0)\n-#define XML_RELAXNG_IN_ONEORMORE    (1 << 1)\n-#define XML_RELAXNG_IN_LIST        (1 << 2)\n-#define XML_RELAXNG_IN_DATAEXCEPT    (1 << 3)\n-#define XML_RELAXNG_IN_START        (1 << 4)\n-#define XML_RELAXNG_IN_OOMGROUP        (1 << 5)\n-#define XML_RELAXNG_IN_OOMINTERLEAVE    (1 << 6)\n-#define XML_RELAXNG_IN_EXTERNALREF    (1 << 7)\n-#define XML_RELAXNG_IN_ANYEXCEPT    (1 << 8)\n-#define XML_RELAXNG_IN_NSEXCEPT        (1 << 9)\n-\n-struct _xmlRelaxNGParserCtxt {\n-    void *userData;             \/* user specific data block *\/\n-    xmlRelaxNGValidityErrorFunc error;  \/* the callback in case of errors *\/\n-    xmlRelaxNGValidityWarningFunc warning;      \/* the callback in case of warning *\/\n-    xmlStructuredErrorFunc serror;\n-    xmlRelaxNGValidErr err;\n-\n-    xmlRelaxNGPtr schema;       \/* The schema in use *\/\n-    xmlRelaxNGGrammarPtr grammar;       \/* the current grammar *\/\n-    xmlRelaxNGGrammarPtr parentgrammar; \/* the parent grammar *\/\n-    int flags;                  \/* parser flags *\/\n-    int nbErrors;               \/* number of errors at parse time *\/\n-    int nbWarnings;             \/* number of warnings at parse time *\/\n-    const xmlChar *define;      \/* the current define scope *\/\n-    xmlRelaxNGDefinePtr def;    \/* the current define *\/\n-\n-    int nbInterleaves;\n-    xmlHashTablePtr interleaves;        \/* keep track of all the interleaves *\/\n-\n-    xmlRelaxNGDocumentPtr documents;    \/* all the documents loaded *\/\n-    xmlRelaxNGIncludePtr includes;      \/* all the includes loaded *\/\n-    xmlChar *URL;\n-    xmlDocPtr document;\n-\n-    int defNr;                  \/* number of defines used *\/\n-    int defMax;                 \/* number of defines allocated *\/\n-    xmlRelaxNGDefinePtr *defTab;        \/* pointer to the allocated definitions *\/\n-\n-    const char *buffer;\n-    int size;\n-\n-    \/* the document stack *\/\n-    xmlRelaxNGDocumentPtr doc;  \/* Current parsed external ref *\/\n-    int docNr;                  \/* Depth of the parsing stack *\/\n-    int docMax;                 \/* Max depth of the parsing stack *\/\n-    xmlRelaxNGDocumentPtr *docTab;      \/* array of docs *\/\n-\n-    \/* the include stack *\/\n-    xmlRelaxNGIncludePtr inc;   \/* Current parsed include *\/\n-    int incNr;                  \/* Depth of the include parsing stack *\/\n-    int incMax;                 \/* Max depth of the parsing stack *\/\n-    xmlRelaxNGIncludePtr *incTab;       \/* array of incs *\/\n-\n-    int idref;                  \/* requires idref checking *\/\n-\n-    \/* used to compile content models *\/\n-    xmlAutomataPtr am;          \/* the automata *\/\n-    xmlAutomataStatePtr state;  \/* used to build the automata *\/\n-\n-    int crng;            \/* compact syntax and other flags *\/\n-    int freedoc;        \/* need to free the document *\/\n-};\n-\n-#define FLAGS_IGNORABLE        1\n-#define FLAGS_NEGATIVE        2\n-#define FLAGS_MIXED_CONTENT    4\n-#define FLAGS_NOERROR        8\n-\n-\/**\n- * xmlRelaxNGInterleaveGroup:\n- *\n- * A RelaxNGs partition set associated to lists of definitions\n- *\/\n-typedef struct _xmlRelaxNGInterleaveGroup xmlRelaxNGInterleaveGroup;\n-typedef xmlRelaxNGInterleaveGroup *xmlRelaxNGInterleaveGroupPtr;\n-struct _xmlRelaxNGInterleaveGroup {\n-    xmlRelaxNGDefinePtr rule;   \/* the rule to satisfy *\/\n-    xmlRelaxNGDefinePtr *defs;  \/* the array of element definitions *\/\n-    xmlRelaxNGDefinePtr *attrs; \/* the array of attributes definitions *\/\n-};\n-\n-#define IS_DETERMINIST        1\n-#define IS_NEEDCHECK        2\n-\n-\/**\n- * xmlRelaxNGPartitions:\n- *\n- * A RelaxNGs partition associated to an interleave group\n- *\/\n-typedef struct _xmlRelaxNGPartition xmlRelaxNGPartition;\n-typedef xmlRelaxNGPartition *xmlRelaxNGPartitionPtr;\n-struct _xmlRelaxNGPartition {\n-    int nbgroups;               \/* number of groups in the partitions *\/\n-    xmlHashTablePtr triage;     \/* hash table used to direct nodes to the\n-                                 * right group when possible *\/\n-    int flags;                  \/* determinist ? *\/\n-    xmlRelaxNGInterleaveGroupPtr *groups;\n-};\n-\n-\/**\n- * xmlRelaxNGValidState:\n- *\n- * A RelaxNGs validation state\n- *\/\n-#define MAX_ATTR 20\n-typedef struct _xmlRelaxNGValidState xmlRelaxNGValidState;\n-typedef xmlRelaxNGValidState *xmlRelaxNGValidStatePtr;\n-struct _xmlRelaxNGValidState {\n-    xmlNodePtr node;            \/* the current node *\/\n-    xmlNodePtr seq;             \/* the sequence of children left to validate *\/\n-    int nbAttrs;                \/* the number of attributes *\/\n-    int maxAttrs;               \/* the size of attrs *\/\n-    int nbAttrLeft;             \/* the number of attributes left to validate *\/\n-    xmlChar *value;             \/* the value when operating on string *\/\n-    xmlChar *endvalue;          \/* the end value when operating on string *\/\n-    xmlAttrPtr *attrs;          \/* the array of attributes *\/\n-};\n-\n-\/**\n- * xmlRelaxNGStates:\n- *\n- * A RelaxNGs container for validation state\n- *\/\n-typedef struct _xmlRelaxNGStates xmlRelaxNGStates;\n-typedef xmlRelaxNGStates *xmlRelaxNGStatesPtr;\n-struct _xmlRelaxNGStates {\n-    int nbState;                \/* the number of states *\/\n-    int maxState;               \/* the size of the array *\/\n-    xmlRelaxNGValidStatePtr *tabState;\n-};\n-\n-#define ERROR_IS_DUP    1\n-\n-\/**\n- * xmlRelaxNGValidError:\n- *\n- * A RelaxNGs validation error\n- *\/\n-typedef struct _xmlRelaxNGValidError xmlRelaxNGValidError;\n-typedef xmlRelaxNGValidError *xmlRelaxNGValidErrorPtr;\n-struct _xmlRelaxNGValidError {\n-    xmlRelaxNGValidErr err;     \/* the error number *\/\n-    int flags;                  \/* flags *\/\n-    xmlNodePtr node;            \/* the current node *\/\n-    xmlNodePtr seq;             \/* the current child *\/\n-    const xmlChar *arg1;        \/* first arg *\/\n-    const xmlChar *arg2;        \/* second arg *\/\n-};\n-\n-\/**\n- * xmlRelaxNGValidCtxt:\n- *\n- * A RelaxNGs validation context\n- *\/\n-\n-struct _xmlRelaxNGValidCtxt {\n-    void *userData;             \/* user specific data block *\/\n-    xmlRelaxNGValidityErrorFunc error;  \/* the callback in case of errors *\/\n-    xmlRelaxNGValidityWarningFunc warning;      \/* the callback in case of warning *\/\n-    xmlStructuredErrorFunc serror;\n-    int nbErrors;               \/* number of errors in validation *\/\n-\n-    xmlRelaxNGPtr schema;       \/* The schema in use *\/\n-    xmlDocPtr doc;              \/* the document being validated *\/\n-    int flags;                  \/* validation flags *\/\n-    int depth;                  \/* validation depth *\/\n-    int idref;                  \/* requires idref checking *\/\n-    int errNo;                  \/* the first error found *\/\n-\n-    \/*\n-     * Errors accumulated in branches may have to be stacked to be\n-     * provided back when it's sure they affect validation.\n-     *\/\n-    xmlRelaxNGValidErrorPtr err;        \/* Last error *\/\n-    int errNr;                  \/* Depth of the error stack *\/\n-    int errMax;                 \/* Max depth of the error stack *\/\n-    xmlRelaxNGValidErrorPtr errTab;     \/* stack of errors *\/\n-\n-    xmlRelaxNGValidStatePtr state;      \/* the current validation state *\/\n-    xmlRelaxNGStatesPtr states; \/* the accumulated state list *\/\n-\n-    xmlRelaxNGStatesPtr freeState;      \/* the pool of free valid states *\/\n-    int freeStatesNr;\n-    int freeStatesMax;\n-    xmlRelaxNGStatesPtr *freeStates;    \/* the pool of free state groups *\/\n-\n-    \/*\n-     * This is used for \"progressive\" validation\n-     *\/\n-    xmlRegExecCtxtPtr elem;     \/* the current element regexp *\/\n-    int elemNr;                 \/* the number of element validated *\/\n-    int elemMax;                \/* the max depth of elements *\/\n-    xmlRegExecCtxtPtr *elemTab; \/* the stack of regexp runtime *\/\n-    int pstate;                 \/* progressive state *\/\n-    xmlNodePtr pnode;           \/* the current node *\/\n-    xmlRelaxNGDefinePtr pdef;   \/* the non-streamable definition *\/\n-    int perr;                   \/* signal error in content model\n-                                 * outside the regexp *\/\n-};\n-\n-\/**\n- * xmlRelaxNGInclude:\n- *\n- * Structure associated to a RelaxNGs document element\n- *\/\n-struct _xmlRelaxNGInclude {\n-    xmlRelaxNGIncludePtr next;  \/* keep a chain of includes *\/\n-    xmlChar *href;              \/* the normalized href value *\/\n-    xmlDocPtr doc;              \/* the associated XML document *\/\n-    xmlRelaxNGDefinePtr content;        \/* the definitions *\/\n-    xmlRelaxNGPtr schema;       \/* the schema *\/\n-};\n-\n-\/**\n- * xmlRelaxNGDocument:\n- *\n- * Structure associated to a RelaxNGs document element\n- *\/\n-struct _xmlRelaxNGDocument {\n-    xmlRelaxNGDocumentPtr next; \/* keep a chain of documents *\/\n-    xmlChar *href;              \/* the normalized href value *\/\n-    xmlDocPtr doc;              \/* the associated XML document *\/\n-    xmlRelaxNGDefinePtr content;        \/* the definitions *\/\n-    xmlRelaxNGPtr schema;       \/* the schema *\/\n-    int externalRef;            \/* 1 if an external ref *\/\n-};\n-\n-\n-\/************************************************************************\n- *                                    *\n- *        Some factorized error routines                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlRngPErrMemory:\n- * @ctxt:  an Relax-NG parser context\n- * @extra:  extra information\n- *\n- * Handle a redefinition of attribute error\n- *\/\n-static void\n-xmlRngPErrMemory(xmlRelaxNGParserCtxtPtr ctxt)\n-{\n-    xmlStructuredErrorFunc schannel = NULL;\n-    xmlGenericErrorFunc channel = NULL;\n-    void *data = NULL;\n-\n-    if (ctxt != NULL) {\n-        if (ctxt->serror != NULL)\n-        schannel = ctxt->serror;\n-    else\n-        channel = ctxt->error;\n-        data = ctxt->userData;\n-        ctxt->nbErrors++;\n-    }\n-\n-    xmlRaiseMemoryError(schannel, channel, data, XML_FROM_RELAXNGP, NULL);\n-}\n-\n-\/**\n- * xmlRngVErrMemory:\n- * @ctxt:  a Relax-NG validation context\n- * @extra:  extra information\n- *\n- * Handle a redefinition of attribute error\n- *\/\n-static void\n-xmlRngVErrMemory(xmlRelaxNGValidCtxtPtr ctxt)\n-{\n-    xmlStructuredErrorFunc schannel = NULL;\n-    xmlGenericErrorFunc channel = NULL;\n-    void *data = NULL;\n-\n-    if (ctxt != NULL) {\n-        if (ctxt->serror != NULL)\n-        schannel = ctxt->serror;\n-    else\n-        channel = ctxt->error;\n-        data = ctxt->userData;\n-        ctxt->nbErrors++;\n-    }\n-\n-    xmlRaiseMemoryError(schannel, channel, data, XML_FROM_RELAXNGV, NULL);\n-}\n-\n-\/**\n- * xmlRngPErr:\n- * @ctxt:  a Relax-NG parser context\n- * @node:  the node raising the error\n- * @error:  the error code\n- * @msg:  message\n- * @str1:  extra info\n- * @str2:  extra info\n- *\n- * Handle a Relax NG Parsing error\n- *\/\n-static void LIBXML_ATTR_FORMAT(4,0)\n-xmlRngPErr(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node, int error,\n-           const char *msg, const xmlChar * str1, const xmlChar * str2)\n-{\n-    xmlStructuredErrorFunc schannel = NULL;\n-    xmlGenericErrorFunc channel = NULL;\n-    void *data = NULL;\n-    int res;\n-\n-    if (ctxt != NULL) {\n-        if (ctxt->serror != NULL)\n-        schannel = ctxt->serror;\n-    else\n-        channel = ctxt->error;\n-        data = ctxt->userData;\n-        ctxt->nbErrors++;\n-    }\n-\n-    if ((channel == NULL) && (schannel == NULL)) {\n-        channel = xmlGenericError;\n-        data = xmlGenericErrorContext;\n-    }\n-\n-    res = __xmlRaiseError(schannel, channel, data, NULL, node,\n-                          XML_FROM_RELAXNGP, error, XML_ERR_ERROR, NULL, 0,\n-                          (const char *) str1, (const char *) str2, NULL, 0, 0,\n-                          msg, str1, str2);\n-    if (res < 0)\n-        xmlRngPErrMemory(ctxt);\n-}\n-\n-\/**\n- * xmlRngVErr:\n- * @ctxt:  a Relax-NG validation context\n- * @node:  the node raising the error\n- * @error:  the error code\n- * @msg:  message\n- * @str1:  extra info\n- * @str2:  extra info\n- *\n- * Handle a Relax NG Validation error\n- *\/\n-static void LIBXML_ATTR_FORMAT(4,0)\n-xmlRngVErr(xmlRelaxNGValidCtxtPtr ctxt, xmlNodePtr node, int error,\n-           const char *msg, const xmlChar * str1, const xmlChar * str2)\n-{\n-    xmlStructuredErrorFunc schannel = NULL;\n-    xmlGenericErrorFunc channel = NULL;\n-    void *data = NULL;\n-    int res;\n-\n-    if (ctxt != NULL) {\n-        if (ctxt->serror != NULL)\n-        schannel = ctxt->serror;\n-    else\n-        channel = ctxt->error;\n-        data = ctxt->userData;\n-        ctxt->nbErrors++;\n-    }\n-\n-    if ((channel == NULL) && (schannel == NULL)) {\n-        channel = xmlGenericError;\n-        data = xmlGenericErrorContext;\n-    }\n-\n-    res = __xmlRaiseError(schannel, channel, data, NULL, node,\n-                          XML_FROM_RELAXNGV, error, XML_ERR_ERROR, NULL, 0,\n-                          (const char *) str1, (const char *) str2, NULL, 0, 0,\n-                          msg, str1, str2);\n-    if (res < 0)\n-        xmlRngVErrMemory(ctxt);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Preliminary type checking interfaces            *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlRelaxNGTypeHave:\n- * @data:  data needed for the library\n- * @type:  the type name\n- * @value:  the value to check\n- *\n- * Function provided by a type library to check if a type is exported\n- *\n- * Returns 1 if yes, 0 if no and -1 in case of error.\n- *\/\n-typedef int (*xmlRelaxNGTypeHave) (void *data, const xmlChar * type);\n-\n-\/**\n- * xmlRelaxNGTypeCheck:\n- * @data:  data needed for the library\n- * @type:  the type name\n- * @value:  the value to check\n- * @result:  place to store the result if needed\n- *\n- * Function provided by a type library to check if a value match a type\n- *\n- * Returns 1 if yes, 0 if no and -1 in case of error.\n- *\/\n-typedef int (*xmlRelaxNGTypeCheck) (void *data, const xmlChar * type,\n-                                    const xmlChar * value, void **result,\n-                                    xmlNodePtr node);\n-\n-\/**\n- * xmlRelaxNGFacetCheck:\n- * @data:  data needed for the library\n- * @type:  the type name\n- * @facet:  the facet name\n- * @val:  the facet value\n- * @strval:  the string value\n- * @value:  the value to check\n- *\n- * Function provided by a type library to check a value facet\n- *\n- * Returns 1 if yes, 0 if no and -1 in case of error.\n- *\/\n-typedef int (*xmlRelaxNGFacetCheck) (void *data, const xmlChar * type,\n-                                     const xmlChar * facet,\n-                                     const xmlChar * val,\n-                                     const xmlChar * strval, void *value);\n-\n-\/**\n- * xmlRelaxNGTypeFree:\n- * @data:  data needed for the library\n- * @result:  the value to free\n- *\n- * Function provided by a type library to free a returned result\n- *\/\n-typedef void (*xmlRelaxNGTypeFree) (void *data, void *result);\n-\n-\/**\n- * xmlRelaxNGTypeCompare:\n- * @data:  data needed for the library\n- * @type:  the type name\n- * @value1:  the first value\n- * @value2:  the second value\n- *\n- * Function provided by a type library to compare two values accordingly\n- * to a type.\n- *\n- * Returns 1 if yes, 0 if no and -1 in case of error.\n- *\/\n-typedef int (*xmlRelaxNGTypeCompare) (void *data, const xmlChar * type,\n-                                      const xmlChar * value1,\n-                                      xmlNodePtr ctxt1,\n-                                      void *comp1,\n-                                      const xmlChar * value2,\n-                                      xmlNodePtr ctxt2);\n-typedef struct _xmlRelaxNGTypeLibrary xmlRelaxNGTypeLibrary;\n-typedef xmlRelaxNGTypeLibrary *xmlRelaxNGTypeLibraryPtr;\n-struct _xmlRelaxNGTypeLibrary {\n-    const xmlChar *namespace;   \/* the datatypeLibrary value *\/\n-    void *data;                 \/* data needed for the library *\/\n-    xmlRelaxNGTypeHave have;    \/* the export function *\/\n-    xmlRelaxNGTypeCheck check;  \/* the checking function *\/\n-    xmlRelaxNGTypeCompare comp; \/* the compare function *\/\n-    xmlRelaxNGFacetCheck facet; \/* the facet check function *\/\n-    xmlRelaxNGTypeFree freef;   \/* the freeing function *\/\n-};\n-\n-\/************************************************************************\n- *                                    *\n- *            Allocation functions                *\n- *                                    *\n- ************************************************************************\/\n-static void xmlRelaxNGFreeGrammar(xmlRelaxNGGrammarPtr grammar);\n-static void xmlRelaxNGFreeDefine(xmlRelaxNGDefinePtr define);\n-static void xmlRelaxNGNormExtSpace(xmlChar * value);\n-static void xmlRelaxNGFreeInnerSchema(xmlRelaxNGPtr schema);\n-static int xmlRelaxNGEqualValidState(xmlRelaxNGValidCtxtPtr ctxt\n-                                     ATTRIBUTE_UNUSED,\n-                                     xmlRelaxNGValidStatePtr state1,\n-                                     xmlRelaxNGValidStatePtr state2);\n-static void xmlRelaxNGFreeValidState(xmlRelaxNGValidCtxtPtr ctxt,\n-                                     xmlRelaxNGValidStatePtr state);\n-\n-\/**\n- * xmlRelaxNGFreeDocument:\n- * @docu:  a document structure\n- *\n- * Deallocate a RelaxNG document structure.\n- *\/\n-static void\n-xmlRelaxNGFreeDocument(xmlRelaxNGDocumentPtr docu)\n-{\n-    if (docu == NULL)\n-        return;\n-\n-    if (docu->href != NULL)\n-        xmlFree(docu->href);\n-    if (docu->doc != NULL)\n-        xmlFreeDoc(docu->doc);\n-    if (docu->schema != NULL)\n-        xmlRelaxNGFreeInnerSchema(docu->schema);\n-    xmlFree(docu);\n-}\n-\n-\/**\n- * xmlRelaxNGFreeDocumentList:\n- * @docu:  a list of  document structure\n- *\n- * Deallocate a RelaxNG document structures.\n- *\/\n-static void\n-xmlRelaxNGFreeDocumentList(xmlRelaxNGDocumentPtr docu)\n-{\n-    xmlRelaxNGDocumentPtr next;\n-\n-    while (docu != NULL) {\n-        next = docu->next;\n-        xmlRelaxNGFreeDocument(docu);\n-        docu = next;\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGFreeInclude:\n- * @incl:  a include structure\n- *\n- * Deallocate a RelaxNG include structure.\n- *\/\n-static void\n-xmlRelaxNGFreeInclude(xmlRelaxNGIncludePtr incl)\n-{\n-    if (incl == NULL)\n-        return;\n-\n-    if (incl->href != NULL)\n-        xmlFree(incl->href);\n-    if (incl->doc != NULL)\n-        xmlFreeDoc(incl->doc);\n-    if (incl->schema != NULL)\n-        xmlRelaxNGFree(incl->schema);\n-    xmlFree(incl);\n-}\n-\n-\/**\n- * xmlRelaxNGFreeIncludeList:\n- * @incl:  a include structure list\n- *\n- * Deallocate a RelaxNG include structure.\n- *\/\n-static void\n-xmlRelaxNGFreeIncludeList(xmlRelaxNGIncludePtr incl)\n-{\n-    xmlRelaxNGIncludePtr next;\n-\n-    while (incl != NULL) {\n-        next = incl->next;\n-        xmlRelaxNGFreeInclude(incl);\n-        incl = next;\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGNewRelaxNG:\n- * @ctxt:  a Relax-NG validation context (optional)\n- *\n- * Allocate a new RelaxNG structure.\n- *\n- * Returns the newly allocated structure or NULL in case or error\n- *\/\n-static xmlRelaxNGPtr\n-xmlRelaxNGNewRelaxNG(xmlRelaxNGParserCtxtPtr ctxt)\n-{\n-    xmlRelaxNGPtr ret;\n-\n-    ret = (xmlRelaxNGPtr) xmlMalloc(sizeof(xmlRelaxNG));\n-    if (ret == NULL) {\n-        xmlRngPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlRelaxNG));\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGFreeInnerSchema:\n- * @schema:  a schema structure\n- *\n- * Deallocate a RelaxNG schema structure.\n- *\/\n-static void\n-xmlRelaxNGFreeInnerSchema(xmlRelaxNGPtr schema)\n-{\n-    if (schema == NULL)\n-        return;\n-\n-    if (schema->doc != NULL)\n-        xmlFreeDoc(schema->doc);\n-    if (schema->defTab != NULL) {\n-        int i;\n-\n-        for (i = 0; i < schema->defNr; i++)\n-            xmlRelaxNGFreeDefine(schema->defTab[i]);\n-        xmlFree(schema->defTab);\n-    }\n-\n-    xmlFree(schema);\n-}\n-\n-\/**\n- * xmlRelaxNGFree:\n- * @schema:  a schema structure\n- *\n- * Deallocate a RelaxNG structure.\n- *\/\n-void\n-xmlRelaxNGFree(xmlRelaxNGPtr schema)\n-{\n-    if (schema == NULL)\n-        return;\n-\n-    if (schema->topgrammar != NULL)\n-        xmlRelaxNGFreeGrammar(schema->topgrammar);\n-    if (schema->doc != NULL)\n-        xmlFreeDoc(schema->doc);\n-    if (schema->documents != NULL)\n-        xmlRelaxNGFreeDocumentList(schema->documents);\n-    if (schema->includes != NULL)\n-        xmlRelaxNGFreeIncludeList(schema->includes);\n-    if (schema->defTab != NULL) {\n-        int i;\n-\n-        for (i = 0; i < schema->defNr; i++)\n-            xmlRelaxNGFreeDefine(schema->defTab[i]);\n-        xmlFree(schema->defTab);\n-    }\n-\n-    xmlFree(schema);\n-}\n-\n-\/**\n- * xmlRelaxNGNewGrammar:\n- * @ctxt:  a Relax-NG validation context (optional)\n- *\n- * Allocate a new RelaxNG grammar.\n- *\n- * Returns the newly allocated structure or NULL in case or error\n- *\/\n-static xmlRelaxNGGrammarPtr\n-xmlRelaxNGNewGrammar(xmlRelaxNGParserCtxtPtr ctxt)\n-{\n-    xmlRelaxNGGrammarPtr ret;\n-\n-    ret = (xmlRelaxNGGrammarPtr) xmlMalloc(sizeof(xmlRelaxNGGrammar));\n-    if (ret == NULL) {\n-        xmlRngPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlRelaxNGGrammar));\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGFreeGrammar:\n- * @grammar:  a grammar structure\n- *\n- * Deallocate a RelaxNG grammar structure.\n- *\/\n-static void\n-xmlRelaxNGFreeGrammar(xmlRelaxNGGrammarPtr grammar)\n-{\n-    if (grammar == NULL)\n-        return;\n-\n-    if (grammar->children != NULL) {\n-        xmlRelaxNGFreeGrammar(grammar->children);\n-    }\n-    if (grammar->next != NULL) {\n-        xmlRelaxNGFreeGrammar(grammar->next);\n-    }\n-    if (grammar->refs != NULL) {\n-        xmlHashFree(grammar->refs, NULL);\n-    }\n-    if (grammar->defs != NULL) {\n-        xmlHashFree(grammar->defs, NULL);\n-    }\n-\n-    xmlFree(grammar);\n-}\n-\n-\/**\n- * xmlRelaxNGNewDefine:\n- * @ctxt:  a Relax-NG validation context\n- * @node:  the node in the input document.\n- *\n- * Allocate a new RelaxNG define.\n- *\n- * Returns the newly allocated structure or NULL in case or error\n- *\/\n-static xmlRelaxNGDefinePtr\n-xmlRelaxNGNewDefine(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlRelaxNGDefinePtr ret;\n-\n-    if (ctxt->defMax == 0) {\n-        ctxt->defMax = 16;\n-        ctxt->defNr = 0;\n-        ctxt->defTab = (xmlRelaxNGDefinePtr *)\n-            xmlMalloc(ctxt->defMax * sizeof(xmlRelaxNGDefinePtr));\n-        if (ctxt->defTab == NULL) {\n-            xmlRngPErrMemory(ctxt);\n-            return (NULL);\n-        }\n-    } else if (ctxt->defMax <= ctxt->defNr) {\n-        xmlRelaxNGDefinePtr *tmp;\n-\n-        ctxt->defMax *= 2;\n-        tmp = (xmlRelaxNGDefinePtr *) xmlRealloc(ctxt->defTab,\n-                                                 ctxt->defMax *\n-                                                 sizeof\n-                                                 (xmlRelaxNGDefinePtr));\n-        if (tmp == NULL) {\n-            xmlRngPErrMemory(ctxt);\n-            return (NULL);\n-        }\n-        ctxt->defTab = tmp;\n-    }\n-    ret = (xmlRelaxNGDefinePtr) xmlMalloc(sizeof(xmlRelaxNGDefine));\n-    if (ret == NULL) {\n-        xmlRngPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlRelaxNGDefine));\n-    ctxt->defTab[ctxt->defNr++] = ret;\n-    ret->node = node;\n-    ret->depth = -1;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGFreePartition:\n- * @partitions:  a partition set structure\n- *\n- * Deallocate RelaxNG partition set structures.\n- *\/\n-static void\n-xmlRelaxNGFreePartition(xmlRelaxNGPartitionPtr partitions)\n-{\n-    xmlRelaxNGInterleaveGroupPtr group;\n-    int j;\n-\n-    if (partitions != NULL) {\n-        if (partitions->groups != NULL) {\n-            for (j = 0; j < partitions->nbgroups; j++) {\n-                group = partitions->groups[j];\n-                if (group != NULL) {\n-                    if (group->defs != NULL)\n-                        xmlFree(group->defs);\n-                    if (group->attrs != NULL)\n-                        xmlFree(group->attrs);\n-                    xmlFree(group);\n-                }\n-            }\n-            xmlFree(partitions->groups);\n-        }\n-        if (partitions->triage != NULL) {\n-            xmlHashFree(partitions->triage, NULL);\n-        }\n-        xmlFree(partitions);\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGFreeDefine:\n- * @define:  a define structure\n- *\n- * Deallocate a RelaxNG define structure.\n- *\/\n-static void\n-xmlRelaxNGFreeDefine(xmlRelaxNGDefinePtr define)\n-{\n-    if (define == NULL)\n-        return;\n-\n-    if ((define->type == XML_RELAXNG_VALUE) && (define->attrs != NULL)) {\n-        xmlRelaxNGTypeLibraryPtr lib;\n-\n-        lib = (xmlRelaxNGTypeLibraryPtr) define->data;\n-        if ((lib != NULL) && (lib->freef != NULL))\n-            lib->freef(lib->data, (void *) define->attrs);\n-    }\n-    if ((define->data != NULL) && (define->type == XML_RELAXNG_INTERLEAVE))\n-        xmlRelaxNGFreePartition((xmlRelaxNGPartitionPtr) define->data);\n-    if ((define->data != NULL) && (define->type == XML_RELAXNG_CHOICE))\n-        xmlHashFree((xmlHashTablePtr) define->data, NULL);\n-    if (define->name != NULL)\n-        xmlFree(define->name);\n-    if (define->ns != NULL)\n-        xmlFree(define->ns);\n-    if (define->value != NULL)\n-        xmlFree(define->value);\n-    if (define->contModel != NULL)\n-        xmlRegFreeRegexp(define->contModel);\n-    xmlFree(define);\n-}\n-\n-\/**\n- * xmlRelaxNGNewStates:\n- * @ctxt:  a Relax-NG validation context\n- * @size:  the default size for the container\n- *\n- * Allocate a new RelaxNG validation state container\n- *\n- * Returns the newly allocated structure or NULL in case or error\n- *\/\n-static xmlRelaxNGStatesPtr\n-xmlRelaxNGNewStates(xmlRelaxNGValidCtxtPtr ctxt, int size)\n-{\n-    xmlRelaxNGStatesPtr ret;\n-\n-    if ((ctxt != NULL) &&\n-        (ctxt->freeStates != NULL) && (ctxt->freeStatesNr > 0)) {\n-        ctxt->freeStatesNr--;\n-        ret = ctxt->freeStates[ctxt->freeStatesNr];\n-        ret->nbState = 0;\n-        return (ret);\n-    }\n-    if (size < 16)\n-        size = 16;\n-\n-    ret = (xmlRelaxNGStatesPtr) xmlMalloc(sizeof(xmlRelaxNGStates) +\n-                                          (size -\n-                                           1) *\n-                                          sizeof(xmlRelaxNGValidStatePtr));\n-    if (ret == NULL) {\n-        xmlRngVErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    ret->nbState = 0;\n-    ret->maxState = size;\n-    ret->tabState = (xmlRelaxNGValidStatePtr *) xmlMalloc((size) *\n-                                                          sizeof\n-                                                          (xmlRelaxNGValidStatePtr));\n-    if (ret->tabState == NULL) {\n-        xmlRngVErrMemory(ctxt);\n-        xmlFree(ret);\n-        return (NULL);\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGAddStateUniq:\n- * @ctxt:  a Relax-NG validation context\n- * @states:  the states container\n- * @state:  the validation state\n- *\n- * Add a RelaxNG validation state to the container without checking\n- * for unicity.\n- *\n- * Return 1 in case of success and 0 if this is a duplicate and -1 on error\n- *\/\n-static int\n-xmlRelaxNGAddStatesUniq(xmlRelaxNGValidCtxtPtr ctxt,\n-                        xmlRelaxNGStatesPtr states,\n-                        xmlRelaxNGValidStatePtr state)\n-{\n-    if (state == NULL) {\n-        return (-1);\n-    }\n-    if (states->nbState >= states->maxState) {\n-        xmlRelaxNGValidStatePtr *tmp;\n-        int size;\n-\n-        size = states->maxState * 2;\n-        tmp = (xmlRelaxNGValidStatePtr *) xmlRealloc(states->tabState,\n-                                                     (size) *\n-                                                     sizeof\n-                                                     (xmlRelaxNGValidStatePtr));\n-        if (tmp == NULL) {\n-            xmlRngVErrMemory(ctxt);\n-            return (-1);\n-        }\n-        states->tabState = tmp;\n-        states->maxState = size;\n-    }\n-    states->tabState[states->nbState++] = state;\n-    return (1);\n-}\n-\n-\/**\n- * xmlRelaxNGAddState:\n- * @ctxt:  a Relax-NG validation context\n- * @states:  the states container\n- * @state:  the validation state\n- *\n- * Add a RelaxNG validation state to the container\n- *\n- * Return 1 in case of success and 0 if this is a duplicate and -1 on error\n- *\/\n-static int\n-xmlRelaxNGAddStates(xmlRelaxNGValidCtxtPtr ctxt,\n-                    xmlRelaxNGStatesPtr states,\n-                    xmlRelaxNGValidStatePtr state)\n-{\n-    int i;\n-\n-    if (state == NULL || states == NULL) {\n-        return (-1);\n-    }\n-    if (states->nbState >= states->maxState) {\n-        xmlRelaxNGValidStatePtr *tmp;\n-        int size;\n-\n-        size = states->maxState * 2;\n-        tmp = (xmlRelaxNGValidStatePtr *) xmlRealloc(states->tabState,\n-                                                     (size) *\n-                                                     sizeof\n-                                                     (xmlRelaxNGValidStatePtr));\n-        if (tmp == NULL) {\n-            xmlRngVErrMemory(ctxt);\n-            return (-1);\n-        }\n-        states->tabState = tmp;\n-        states->maxState = size;\n-    }\n-    for (i = 0; i < states->nbState; i++) {\n-        if (xmlRelaxNGEqualValidState(ctxt, state, states->tabState[i])) {\n-            xmlRelaxNGFreeValidState(ctxt, state);\n-            return (0);\n-        }\n-    }\n-    states->tabState[states->nbState++] = state;\n-    return (1);\n-}\n-\n-\/**\n- * xmlRelaxNGFreeStates:\n- * @ctxt:  a Relax-NG validation context\n- * @states:  the container\n- *\n- * Free a RelaxNG validation state container\n- *\/\n-static void\n-xmlRelaxNGFreeStates(xmlRelaxNGValidCtxtPtr ctxt,\n-                     xmlRelaxNGStatesPtr states)\n-{\n-    if (states == NULL)\n-        return;\n-    if ((ctxt != NULL) && (ctxt->freeStates == NULL)) {\n-        ctxt->freeStatesMax = 40;\n-        ctxt->freeStatesNr = 0;\n-        ctxt->freeStates = (xmlRelaxNGStatesPtr *)\n-            xmlMalloc(ctxt->freeStatesMax * sizeof(xmlRelaxNGStatesPtr));\n-        if (ctxt->freeStates == NULL) {\n-            xmlRngVErrMemory(ctxt);\n-        }\n-    } else if ((ctxt != NULL)\n-               && (ctxt->freeStatesNr >= ctxt->freeStatesMax)) {\n-        xmlRelaxNGStatesPtr *tmp;\n-\n-        tmp = (xmlRelaxNGStatesPtr *) xmlRealloc(ctxt->freeStates,\n-                                                 2 * ctxt->freeStatesMax *\n-                                                 sizeof\n-                                                 (xmlRelaxNGStatesPtr));\n-        if (tmp == NULL) {\n-            xmlRngVErrMemory(ctxt);\n-            xmlFree(states->tabState);\n-            xmlFree(states);\n-            return;\n-        }\n-        ctxt->freeStates = tmp;\n-        ctxt->freeStatesMax *= 2;\n-    }\n-    if ((ctxt == NULL) || (ctxt->freeStates == NULL)) {\n-        xmlFree(states->tabState);\n-        xmlFree(states);\n-    } else {\n-        ctxt->freeStates[ctxt->freeStatesNr++] = states;\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGNewValidState:\n- * @ctxt:  a Relax-NG validation context\n- * @node:  the current node or NULL for the document\n- *\n- * Allocate a new RelaxNG validation state\n- *\n- * Returns the newly allocated structure or NULL in case or error\n- *\/\n-static xmlRelaxNGValidStatePtr\n-xmlRelaxNGNewValidState(xmlRelaxNGValidCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlRelaxNGValidStatePtr ret;\n-    xmlAttrPtr attr;\n-    xmlAttrPtr attrs[MAX_ATTR];\n-    int nbAttrs = 0;\n-    xmlNodePtr root = NULL;\n-\n-    if (node == NULL) {\n-        root = xmlDocGetRootElement(ctxt->doc);\n-        if (root == NULL)\n-            return (NULL);\n-    } else {\n-        attr = node->properties;\n-        while (attr != NULL) {\n-            if (nbAttrs < MAX_ATTR)\n-                attrs[nbAttrs++] = attr;\n-            else\n-                nbAttrs++;\n-            attr = attr->next;\n-        }\n-    }\n-    if ((ctxt->freeState != NULL) && (ctxt->freeState->nbState > 0)) {\n-        ctxt->freeState->nbState--;\n-        ret = ctxt->freeState->tabState[ctxt->freeState->nbState];\n-    } else {\n-        ret =\n-            (xmlRelaxNGValidStatePtr)\n-            xmlMalloc(sizeof(xmlRelaxNGValidState));\n-        if (ret == NULL) {\n-            xmlRngVErrMemory(ctxt);\n-            return (NULL);\n-        }\n-        memset(ret, 0, sizeof(xmlRelaxNGValidState));\n-    }\n-    ret->value = NULL;\n-    ret->endvalue = NULL;\n-    if (node == NULL) {\n-        ret->node = (xmlNodePtr) ctxt->doc;\n-        ret->seq = root;\n-    } else {\n-        ret->node = node;\n-        ret->seq = node->children;\n-    }\n-    ret->nbAttrs = 0;\n-    if (nbAttrs > 0) {\n-        if (ret->attrs == NULL) {\n-            if (nbAttrs < 4)\n-                ret->maxAttrs = 4;\n-            else\n-                ret->maxAttrs = nbAttrs;\n-            ret->attrs = (xmlAttrPtr *) xmlMalloc(ret->maxAttrs *\n-                                                  sizeof(xmlAttrPtr));\n-            if (ret->attrs == NULL) {\n-                xmlRngVErrMemory(ctxt);\n-                return (ret);\n-            }\n-        } else if (ret->maxAttrs < nbAttrs) {\n-            xmlAttrPtr *tmp;\n-\n-            tmp = (xmlAttrPtr *) xmlRealloc(ret->attrs, nbAttrs *\n-                                            sizeof(xmlAttrPtr));\n-            if (tmp == NULL) {\n-                xmlRngVErrMemory(ctxt);\n-                return (ret);\n-            }\n-            ret->attrs = tmp;\n-            ret->maxAttrs = nbAttrs;\n-        }\n-        ret->nbAttrs = nbAttrs;\n-        if (nbAttrs < MAX_ATTR) {\n-            memcpy(ret->attrs, attrs, sizeof(xmlAttrPtr) * nbAttrs);\n-        } else {\n-            attr = node->properties;\n-            nbAttrs = 0;\n-            while (attr != NULL) {\n-                ret->attrs[nbAttrs++] = attr;\n-                attr = attr->next;\n-            }\n-        }\n-    }\n-    ret->nbAttrLeft = ret->nbAttrs;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGCopyValidState:\n- * @ctxt:  a Relax-NG validation context\n- * @state:  a validation state\n- *\n- * Copy the validation state\n- *\n- * Returns the newly allocated structure or NULL in case or error\n- *\/\n-static xmlRelaxNGValidStatePtr\n-xmlRelaxNGCopyValidState(xmlRelaxNGValidCtxtPtr ctxt,\n-                         xmlRelaxNGValidStatePtr state)\n-{\n-    xmlRelaxNGValidStatePtr ret;\n-    unsigned int maxAttrs;\n-    xmlAttrPtr *attrs;\n-\n-    if (state == NULL)\n-        return (NULL);\n-    if ((ctxt->freeState != NULL) && (ctxt->freeState->nbState > 0)) {\n-        ctxt->freeState->nbState--;\n-        ret = ctxt->freeState->tabState[ctxt->freeState->nbState];\n-    } else {\n-        ret =\n-            (xmlRelaxNGValidStatePtr)\n-            xmlMalloc(sizeof(xmlRelaxNGValidState));\n-        if (ret == NULL) {\n-            xmlRngVErrMemory(ctxt);\n-            return (NULL);\n-        }\n-        memset(ret, 0, sizeof(xmlRelaxNGValidState));\n-    }\n-    attrs = ret->attrs;\n-    maxAttrs = ret->maxAttrs;\n-    memcpy(ret, state, sizeof(xmlRelaxNGValidState));\n-    ret->attrs = attrs;\n-    ret->maxAttrs = maxAttrs;\n-    if (state->nbAttrs > 0) {\n-        if (ret->attrs == NULL) {\n-            ret->maxAttrs = state->maxAttrs;\n-            ret->attrs = (xmlAttrPtr *) xmlMalloc(ret->maxAttrs *\n-                                                  sizeof(xmlAttrPtr));\n-            if (ret->attrs == NULL) {\n-                xmlRngVErrMemory(ctxt);\n-                ret->nbAttrs = 0;\n-                return (ret);\n-            }\n-        } else if (ret->maxAttrs < state->nbAttrs) {\n-            xmlAttrPtr *tmp;\n-\n-            tmp = (xmlAttrPtr *) xmlRealloc(ret->attrs, state->maxAttrs *\n-                                            sizeof(xmlAttrPtr));\n-            if (tmp == NULL) {\n-                xmlRngVErrMemory(ctxt);\n-                ret->nbAttrs = 0;\n-                return (ret);\n-            }\n-            ret->maxAttrs = state->maxAttrs;\n-            ret->attrs = tmp;\n-        }\n-        memcpy(ret->attrs, state->attrs,\n-               state->nbAttrs * sizeof(xmlAttrPtr));\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGEqualValidState:\n- * @ctxt:  a Relax-NG validation context\n- * @state1:  a validation state\n- * @state2:  a validation state\n- *\n- * Compare the validation states for equality\n- *\n- * Returns 1 if equal, 0 otherwise\n- *\/\n-static int\n-xmlRelaxNGEqualValidState(xmlRelaxNGValidCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-                          xmlRelaxNGValidStatePtr state1,\n-                          xmlRelaxNGValidStatePtr state2)\n-{\n-    int i;\n-\n-    if ((state1 == NULL) || (state2 == NULL))\n-        return (0);\n-    if (state1 == state2)\n-        return (1);\n-    if (state1->node != state2->node)\n-        return (0);\n-    if (state1->seq != state2->seq)\n-        return (0);\n-    if (state1->nbAttrLeft != state2->nbAttrLeft)\n-        return (0);\n-    if (state1->nbAttrs != state2->nbAttrs)\n-        return (0);\n-    if (state1->endvalue != state2->endvalue)\n-        return (0);\n-    if ((state1->value != state2->value) &&\n-        (!xmlStrEqual(state1->value, state2->value)))\n-        return (0);\n-    for (i = 0; i < state1->nbAttrs; i++) {\n-        if (state1->attrs[i] != state2->attrs[i])\n-            return (0);\n-    }\n-    return (1);\n-}\n-\n-\/**\n- * xmlRelaxNGFreeValidState:\n- * @state:  a validation state structure\n- *\n- * Deallocate a RelaxNG validation state structure.\n- *\/\n-static void\n-xmlRelaxNGFreeValidState(xmlRelaxNGValidCtxtPtr ctxt,\n-                         xmlRelaxNGValidStatePtr state)\n-{\n-    if (state == NULL)\n-        return;\n-\n-    if ((ctxt != NULL) && (ctxt->freeState == NULL)) {\n-        ctxt->freeState = xmlRelaxNGNewStates(ctxt, 40);\n-    }\n-    if ((ctxt == NULL) || (ctxt->freeState == NULL)) {\n-        if (state->attrs != NULL)\n-            xmlFree(state->attrs);\n-        xmlFree(state);\n-    } else {\n-        xmlRelaxNGAddStatesUniq(ctxt, ctxt->freeState, state);\n-    }\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Semi internal functions                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlRelaxParserSetFlag:\n- * @ctxt: a RelaxNG parser context\n- * @flags: a set of flags values\n- *\n- * Semi private function used to pass information to a parser context\n- * which are a combination of xmlRelaxNGParserFlag .\n- *\n- * Returns 0 if success and -1 in case of error\n- *\/\n-int\n-xmlRelaxParserSetFlag(xmlRelaxNGParserCtxtPtr ctxt, int flags)\n-{\n-    if (ctxt == NULL) return(-1);\n-    if (flags & XML_RELAXNGP_FREE_DOC) {\n-        ctxt->crng |= XML_RELAXNGP_FREE_DOC;\n-    flags -= XML_RELAXNGP_FREE_DOC;\n-    }\n-    if (flags & XML_RELAXNGP_CRNG) {\n-        ctxt->crng |= XML_RELAXNGP_CRNG;\n-    flags -= XML_RELAXNGP_CRNG;\n-    }\n-    if (flags != 0) return(-1);\n-    return(0);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Document functions                *\n- *                                    *\n- ************************************************************************\/\n-static xmlDocPtr xmlRelaxNGCleanupDoc(xmlRelaxNGParserCtxtPtr ctxt,\n-                                      xmlDocPtr doc);\n-\n-static xmlDoc *\n-xmlRelaxReadFile(xmlRelaxNGParserCtxtPtr ctxt, const char *filename) {\n-    xmlParserCtxtPtr pctxt;\n-    xmlDocPtr doc;\n-\n-    pctxt = xmlNewParserCtxt();\n-    if (pctxt == NULL) {\n-        xmlRngPErrMemory(ctxt);\n-        return(NULL);\n-    }\n-    if (ctxt->serror != NULL)\n-        xmlCtxtSetErrorHandler(pctxt, ctxt->serror, ctxt->userData);\n-    doc = xmlCtxtReadFile(pctxt, filename, NULL, 0);\n-    xmlFreeParserCtxt(pctxt);\n-\n-    return(doc);\n-}\n-\n-static xmlDoc *\n-xmlRelaxReadMemory(xmlRelaxNGParserCtxtPtr ctxt, const char *buf, int size) {\n-    xmlParserCtxtPtr pctxt;\n-    xmlDocPtr doc;\n-\n-    pctxt = xmlNewParserCtxt();\n-    if (pctxt == NULL) {\n-        xmlRngPErrMemory(ctxt);\n-        return(NULL);\n-    }\n-    if (ctxt->serror != NULL)\n-        xmlCtxtSetErrorHandler(pctxt, ctxt->serror, ctxt->userData);\n-    doc = xmlCtxtReadMemory(pctxt, buf, size, NULL, NULL, 0);\n-    xmlFreeParserCtxt(pctxt);\n-\n-    return(doc);\n-}\n-\n-\/**\n- * xmlRelaxNGIncludePush:\n- * @ctxt:  the parser context\n- * @value:  the element doc\n- *\n- * Pushes a new include on top of the include stack\n- *\n- * Returns 0 in case of error, the index in the stack otherwise\n- *\/\n-static int\n-xmlRelaxNGIncludePush(xmlRelaxNGParserCtxtPtr ctxt,\n-                      xmlRelaxNGIncludePtr value)\n-{\n-    if (ctxt->incTab == NULL) {\n-        ctxt->incMax = 4;\n-        ctxt->incNr = 0;\n-        ctxt->incTab =\n-            (xmlRelaxNGIncludePtr *) xmlMalloc(ctxt->incMax *\n-                                               sizeof(ctxt->incTab[0]));\n-        if (ctxt->incTab == NULL) {\n-            xmlRngPErrMemory(ctxt);\n-            return (0);\n-        }\n-    }\n-    if (ctxt->incNr >= ctxt->incMax) {\n-        ctxt->incMax *= 2;\n-        ctxt->incTab =\n-            (xmlRelaxNGIncludePtr *) xmlRealloc(ctxt->incTab,\n-                                                ctxt->incMax *\n-                                                sizeof(ctxt->incTab[0]));\n-        if (ctxt->incTab == NULL) {\n-            xmlRngPErrMemory(ctxt);\n-            return (0);\n-        }\n-    }\n-    ctxt->incTab[ctxt->incNr] = value;\n-    ctxt->inc = value;\n-    return (ctxt->incNr++);\n-}\n-\n-\/**\n- * xmlRelaxNGIncludePop:\n- * @ctxt: the parser context\n- *\n- * Pops the top include from the include stack\n- *\n- * Returns the include just removed\n- *\/\n-static xmlRelaxNGIncludePtr\n-xmlRelaxNGIncludePop(xmlRelaxNGParserCtxtPtr ctxt)\n-{\n-    xmlRelaxNGIncludePtr ret;\n-\n-    if (ctxt->incNr <= 0)\n-        return (NULL);\n-    ctxt->incNr--;\n-    if (ctxt->incNr > 0)\n-        ctxt->inc = ctxt->incTab[ctxt->incNr - 1];\n-    else\n-        ctxt->inc = NULL;\n-    ret = ctxt->incTab[ctxt->incNr];\n-    ctxt->incTab[ctxt->incNr] = NULL;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGRemoveRedefine:\n- * @ctxt: the parser context\n- * @URL:  the normalized URL\n- * @target:  the included target\n- * @name:  the define name to eliminate\n- *\n- * Applies the elimination algorithm of 4.7\n- *\n- * Returns 0 in case of error, 1 in case of success.\n- *\/\n-static int\n-xmlRelaxNGRemoveRedefine(xmlRelaxNGParserCtxtPtr ctxt,\n-                         const xmlChar * URL ATTRIBUTE_UNUSED,\n-                         xmlNodePtr target, const xmlChar * name)\n-{\n-    int found = 0;\n-    xmlNodePtr tmp, tmp2;\n-    xmlChar *name2;\n-\n-    tmp = target;\n-    while (tmp != NULL) {\n-        tmp2 = tmp->next;\n-        if ((name == NULL) && (IS_RELAXNG(tmp, \"start\"))) {\n-            found = 1;\n-            xmlUnlinkNode(tmp);\n-            xmlFreeNode(tmp);\n-        } else if ((name != NULL) && (IS_RELAXNG(tmp, \"define\"))) {\n-            name2 = xmlGetProp(tmp, BAD_CAST \"name\");\n-            xmlRelaxNGNormExtSpace(name2);\n-            if (name2 != NULL) {\n-                if (xmlStrEqual(name, name2)) {\n-                    found = 1;\n-                    xmlUnlinkNode(tmp);\n-                    xmlFreeNode(tmp);\n-                }\n-                xmlFree(name2);\n-            }\n-        } else if (IS_RELAXNG(tmp, \"include\")) {\n-            xmlChar *href = NULL;\n-            xmlRelaxNGDocumentPtr inc = tmp->psvi;\n-\n-            if ((inc != NULL) && (inc->doc != NULL) &&\n-                (inc->doc->children != NULL)) {\n-\n-                if (xmlStrEqual\n-                    (inc->doc->children->name, BAD_CAST \"grammar\")) {\n-                    if (xmlRelaxNGRemoveRedefine(ctxt, href,\n-                                                 xmlDocGetRootElement(inc->doc)->children,\n-                                                 name) == 1) {\n-                        found = 1;\n-                    }\n-                }\n-            }\n-            if (xmlRelaxNGRemoveRedefine(ctxt, URL, tmp->children, name) == 1) {\n-                found = 1;\n-            }\n-        }\n-        tmp = tmp2;\n-    }\n-    return (found);\n-}\n-\n-\/**\n- * xmlRelaxNGLoadInclude:\n- * @ctxt: the parser context\n- * @URL:  the normalized URL\n- * @node: the include node.\n- * @ns:  the namespace passed from the context.\n- *\n- * First lookup if the document is already loaded into the parser context,\n- * check against recursion. If not found the resource is loaded and\n- * the content is preprocessed before being returned back to the caller.\n- *\n- * Returns the xmlRelaxNGIncludePtr or NULL in case of error\n- *\/\n-static xmlRelaxNGIncludePtr\n-xmlRelaxNGLoadInclude(xmlRelaxNGParserCtxtPtr ctxt, const xmlChar * URL,\n-                      xmlNodePtr node, const xmlChar * ns)\n-{\n-    xmlRelaxNGIncludePtr ret = NULL;\n-    xmlDocPtr doc;\n-    int i;\n-    xmlNodePtr root, cur;\n-\n-    \/*\n-     * check against recursion in the stack\n-     *\/\n-    for (i = 0; i < ctxt->incNr; i++) {\n-        if (xmlStrEqual(ctxt->incTab[i]->href, URL)) {\n-            xmlRngPErr(ctxt, NULL, XML_RNGP_INCLUDE_RECURSE,\n-                       \"Detected an Include recursion for %s\\n\", URL,\n-                       NULL);\n-            return (NULL);\n-        }\n-    }\n-\n-    \/*\n-     * load the document\n-     *\/\n-    doc = xmlRelaxReadFile(ctxt, (const char *) URL);\n-    if (doc == NULL) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_PARSE_ERROR,\n-                   \"xmlRelaxNG: could not load %s\\n\", URL, NULL);\n-        return (NULL);\n-    }\n-\n-    \/*\n-     * Allocate the document structures and register it first.\n-     *\/\n-    ret = (xmlRelaxNGIncludePtr) xmlMalloc(sizeof(xmlRelaxNGInclude));\n-    if (ret == NULL) {\n-        xmlRngPErrMemory(ctxt);\n-        xmlFreeDoc(doc);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlRelaxNGInclude));\n-    ret->doc = doc;\n-    ret->href = xmlStrdup(URL);\n-    ret->next = ctxt->includes;\n-    ctxt->includes = ret;\n-\n-    \/*\n-     * transmit the ns if needed\n-     *\/\n-    if (ns != NULL) {\n-        root = xmlDocGetRootElement(doc);\n-        if (root != NULL) {\n-            if (xmlHasProp(root, BAD_CAST \"ns\") == NULL) {\n-                xmlSetProp(root, BAD_CAST \"ns\", ns);\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * push it on the stack\n-     *\/\n-    xmlRelaxNGIncludePush(ctxt, ret);\n-\n-    \/*\n-     * Some preprocessing of the document content, this include recursing\n-     * in the include stack.\n-     *\/\n-\n-    doc = xmlRelaxNGCleanupDoc(ctxt, doc);\n-    if (doc == NULL) {\n-        ctxt->inc = NULL;\n-        return (NULL);\n-    }\n-\n-    \/*\n-     * Pop up the include from the stack\n-     *\/\n-    xmlRelaxNGIncludePop(ctxt);\n-\n-    \/*\n-     * Check that the top element is a grammar\n-     *\/\n-    root = xmlDocGetRootElement(doc);\n-    if (root == NULL) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_EMPTY,\n-                   \"xmlRelaxNG: included document is empty %s\\n\", URL,\n-                   NULL);\n-        return (NULL);\n-    }\n-    if (!IS_RELAXNG(root, \"grammar\")) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_GRAMMAR_MISSING,\n-                   \"xmlRelaxNG: included document %s root is not a grammar\\n\",\n-                   URL, NULL);\n-        return (NULL);\n-    }\n-\n-    \/*\n-     * Elimination of redefined rules in the include.\n-     *\/\n-    cur = node->children;\n-    while (cur != NULL) {\n-        if (IS_RELAXNG(cur, \"start\")) {\n-            int found = 0;\n-\n-            found =\n-                xmlRelaxNGRemoveRedefine(ctxt, URL, root->children, NULL);\n-            if (!found) {\n-                xmlRngPErr(ctxt, node, XML_RNGP_START_MISSING,\n-                           \"xmlRelaxNG: include %s has a start but not the included grammar\\n\",\n-                           URL, NULL);\n-            }\n-        } else if (IS_RELAXNG(cur, \"define\")) {\n-            xmlChar *name;\n-\n-            name = xmlGetProp(cur, BAD_CAST \"name\");\n-            if (name == NULL) {\n-                xmlRngPErr(ctxt, node, XML_RNGP_NAME_MISSING,\n-                           \"xmlRelaxNG: include %s has define without name\\n\",\n-                           URL, NULL);\n-            } else {\n-                int found;\n-\n-                xmlRelaxNGNormExtSpace(name);\n-                found = xmlRelaxNGRemoveRedefine(ctxt, URL,\n-                                                 root->children, name);\n-                if (!found) {\n-                    xmlRngPErr(ctxt, node, XML_RNGP_DEFINE_MISSING,\n-                               \"xmlRelaxNG: include %s has a define %s but not the included grammar\\n\",\n-                               URL, name);\n-                }\n-                xmlFree(name);\n-            }\n-        }\n-        if (IS_RELAXNG(cur, \"div\") && cur->children != NULL) {\n-            cur = cur->children;\n-        } else {\n-            if (cur->next != NULL) {\n-                cur = cur->next;\n-            } else {\n-                while (cur->parent != node && cur->parent->next == NULL) {\n-                    cur = cur->parent;\n-                }\n-                cur = cur->parent != node ? cur->parent->next : NULL;\n-            }\n-        }\n-    }\n-\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGValidErrorPush:\n- * @ctxt:  the validation context\n- * @err:  the error code\n- * @arg1:  the first string argument\n- * @arg2:  the second string argument\n- * @dup:  arg need to be duplicated\n- *\n- * Pushes a new error on top of the error stack\n- *\n- * Returns 0 in case of error, the index in the stack otherwise\n- *\/\n-static int\n-xmlRelaxNGValidErrorPush(xmlRelaxNGValidCtxtPtr ctxt,\n-                         xmlRelaxNGValidErr err, const xmlChar * arg1,\n-                         const xmlChar * arg2, int dup)\n-{\n-    xmlRelaxNGValidErrorPtr cur;\n-\n-    if (ctxt->errTab == NULL) {\n-        ctxt->errMax = 8;\n-        ctxt->errNr = 0;\n-        ctxt->errTab =\n-            (xmlRelaxNGValidErrorPtr) xmlMalloc(ctxt->errMax *\n-                                                sizeof\n-                                                (xmlRelaxNGValidError));\n-        if (ctxt->errTab == NULL) {\n-            xmlRngVErrMemory(ctxt);\n-            return (0);\n-        }\n-        ctxt->err = NULL;\n-    }\n-    if (ctxt->errNr >= ctxt->errMax) {\n-        ctxt->errMax *= 2;\n-        ctxt->errTab =\n-            (xmlRelaxNGValidErrorPtr) xmlRealloc(ctxt->errTab,\n-                                                 ctxt->errMax *\n-                                                 sizeof\n-                                                 (xmlRelaxNGValidError));\n-        if (ctxt->errTab == NULL) {\n-            xmlRngVErrMemory(ctxt);\n-            return (0);\n-        }\n-        ctxt->err = &ctxt->errTab[ctxt->errNr - 1];\n-    }\n-    if ((ctxt->err != NULL) && (ctxt->state != NULL) &&\n-        (ctxt->err->node == ctxt->state->node) && (ctxt->err->err == err))\n-        return (ctxt->errNr);\n-    cur = &ctxt->errTab[ctxt->errNr];\n-    cur->err = err;\n-    if (dup) {\n-        cur->arg1 = xmlStrdup(arg1);\n-        cur->arg2 = xmlStrdup(arg2);\n-        cur->flags = ERROR_IS_DUP;\n-    } else {\n-        cur->arg1 = arg1;\n-        cur->arg2 = arg2;\n-        cur->flags = 0;\n-    }\n-    if (ctxt->state != NULL) {\n-        cur->node = ctxt->state->node;\n-        cur->seq = ctxt->state->seq;\n-    } else {\n-        cur->node = NULL;\n-        cur->seq = NULL;\n-    }\n-    ctxt->err = cur;\n-    return (ctxt->errNr++);\n-}\n-\n-\/**\n- * xmlRelaxNGValidErrorPop:\n- * @ctxt: the validation context\n- *\n- * Pops the top error from the error stack\n- *\/\n-static void\n-xmlRelaxNGValidErrorPop(xmlRelaxNGValidCtxtPtr ctxt)\n-{\n-    xmlRelaxNGValidErrorPtr cur;\n-\n-    if (ctxt->errNr <= 0) {\n-        ctxt->err = NULL;\n-        return;\n-    }\n-    ctxt->errNr--;\n-    if (ctxt->errNr > 0)\n-        ctxt->err = &ctxt->errTab[ctxt->errNr - 1];\n-    else\n-        ctxt->err = NULL;\n-    cur = &ctxt->errTab[ctxt->errNr];\n-    if (cur->flags & ERROR_IS_DUP) {\n-        if (cur->arg1 != NULL)\n-            xmlFree((xmlChar *) cur->arg1);\n-        cur->arg1 = NULL;\n-        if (cur->arg2 != NULL)\n-            xmlFree((xmlChar *) cur->arg2);\n-        cur->arg2 = NULL;\n-        cur->flags = 0;\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGDocumentPush:\n- * @ctxt:  the parser context\n- * @value:  the element doc\n- *\n- * Pushes a new doc on top of the doc stack\n- *\n- * Returns 0 in case of error, the index in the stack otherwise\n- *\/\n-static int\n-xmlRelaxNGDocumentPush(xmlRelaxNGParserCtxtPtr ctxt,\n-                       xmlRelaxNGDocumentPtr value)\n-{\n-    if (ctxt->docTab == NULL) {\n-        ctxt->docMax = 4;\n-        ctxt->docNr = 0;\n-        ctxt->docTab =\n-            (xmlRelaxNGDocumentPtr *) xmlMalloc(ctxt->docMax *\n-                                                sizeof(ctxt->docTab[0]));\n-        if (ctxt->docTab == NULL) {\n-            xmlRngPErrMemory(ctxt);\n-            return (0);\n-        }\n-    }\n-    if (ctxt->docNr >= ctxt->docMax) {\n-        ctxt->docMax *= 2;\n-        ctxt->docTab =\n-            (xmlRelaxNGDocumentPtr *) xmlRealloc(ctxt->docTab,\n-                                                 ctxt->docMax *\n-                                                 sizeof(ctxt->docTab[0]));\n-        if (ctxt->docTab == NULL) {\n-            xmlRngPErrMemory(ctxt);\n-            return (0);\n-        }\n-    }\n-    ctxt->docTab[ctxt->docNr] = value;\n-    ctxt->doc = value;\n-    return (ctxt->docNr++);\n-}\n-\n-\/**\n- * xmlRelaxNGDocumentPop:\n- * @ctxt: the parser context\n- *\n- * Pops the top doc from the doc stack\n- *\n- * Returns the doc just removed\n- *\/\n-static xmlRelaxNGDocumentPtr\n-xmlRelaxNGDocumentPop(xmlRelaxNGParserCtxtPtr ctxt)\n-{\n-    xmlRelaxNGDocumentPtr ret;\n-\n-    if (ctxt->docNr <= 0)\n-        return (NULL);\n-    ctxt->docNr--;\n-    if (ctxt->docNr > 0)\n-        ctxt->doc = ctxt->docTab[ctxt->docNr - 1];\n-    else\n-        ctxt->doc = NULL;\n-    ret = ctxt->docTab[ctxt->docNr];\n-    ctxt->docTab[ctxt->docNr] = NULL;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGLoadExternalRef:\n- * @ctxt: the parser context\n- * @URL:  the normalized URL\n- * @ns:  the inherited ns if any\n- *\n- * First lookup if the document is already loaded into the parser context,\n- * check against recursion. If not found the resource is loaded and\n- * the content is preprocessed before being returned back to the caller.\n- *\n- * Returns the xmlRelaxNGDocumentPtr or NULL in case of error\n- *\/\n-static xmlRelaxNGDocumentPtr\n-xmlRelaxNGLoadExternalRef(xmlRelaxNGParserCtxtPtr ctxt,\n-                          const xmlChar * URL, const xmlChar * ns)\n-{\n-    xmlRelaxNGDocumentPtr ret = NULL;\n-    xmlDocPtr doc;\n-    xmlNodePtr root;\n-    int i;\n-\n-    \/*\n-     * check against recursion in the stack\n-     *\/\n-    for (i = 0; i < ctxt->docNr; i++) {\n-        if (xmlStrEqual(ctxt->docTab[i]->href, URL)) {\n-            xmlRngPErr(ctxt, NULL, XML_RNGP_EXTERNALREF_RECURSE,\n-                       \"Detected an externalRef recursion for %s\\n\", URL,\n-                       NULL);\n-            return (NULL);\n-        }\n-    }\n-\n-    \/*\n-     * load the document\n-     *\/\n-    doc = xmlRelaxReadFile(ctxt, (const char *) URL);\n-    if (doc == NULL) {\n-        xmlRngPErr(ctxt, NULL, XML_RNGP_PARSE_ERROR,\n-                   \"xmlRelaxNG: could not load %s\\n\", URL, NULL);\n-        return (NULL);\n-    }\n-\n-    \/*\n-     * Allocate the document structures and register it first.\n-     *\/\n-    ret = (xmlRelaxNGDocumentPtr) xmlMalloc(sizeof(xmlRelaxNGDocument));\n-    if (ret == NULL) {\n-        xmlRngPErrMemory(ctxt);\n-        xmlFreeDoc(doc);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlRelaxNGDocument));\n-    ret->doc = doc;\n-    ret->href = xmlStrdup(URL);\n-    ret->next = ctxt->documents;\n-    ret->externalRef = 1;\n-    ctxt->documents = ret;\n-\n-    \/*\n-     * transmit the ns if needed\n-     *\/\n-    if (ns != NULL) {\n-        root = xmlDocGetRootElement(doc);\n-        if (root != NULL) {\n-            if (xmlHasProp(root, BAD_CAST \"ns\") == NULL) {\n-                xmlSetProp(root, BAD_CAST \"ns\", ns);\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * push it on the stack and register it in the hash table\n-     *\/\n-    xmlRelaxNGDocumentPush(ctxt, ret);\n-\n-    \/*\n-     * Some preprocessing of the document content\n-     *\/\n-    doc = xmlRelaxNGCleanupDoc(ctxt, doc);\n-    if (doc == NULL) {\n-        ctxt->doc = NULL;\n-        return (NULL);\n-    }\n-\n-    xmlRelaxNGDocumentPop(ctxt);\n-\n-    return (ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Error functions                    *\n- *                                    *\n- ************************************************************************\/\n-\n-#define VALID_ERR(a) xmlRelaxNGAddValidError(ctxt, a, NULL, NULL, 0);\n-#define VALID_ERR2(a, b) xmlRelaxNGAddValidError(ctxt, a, b, NULL, 0);\n-#define VALID_ERR3(a, b, c) xmlRelaxNGAddValidError(ctxt, a, b, c, 0);\n-#define VALID_ERR2P(a, b) xmlRelaxNGAddValidError(ctxt, a, b, NULL, 1);\n-#define VALID_ERR3P(a, b, c) xmlRelaxNGAddValidError(ctxt, a, b, c, 1);\n-\n-static const char *\n-xmlRelaxNGDefName(xmlRelaxNGDefinePtr def)\n-{\n-    if (def == NULL)\n-        return (\"none\");\n-    switch (def->type) {\n-        case XML_RELAXNG_EMPTY:\n-            return (\"empty\");\n-        case XML_RELAXNG_NOT_ALLOWED:\n-            return (\"notAllowed\");\n-        case XML_RELAXNG_EXCEPT:\n-            return (\"except\");\n-        case XML_RELAXNG_TEXT:\n-            return (\"text\");\n-        case XML_RELAXNG_ELEMENT:\n-            return (\"element\");\n-        case XML_RELAXNG_DATATYPE:\n-            return (\"datatype\");\n-        case XML_RELAXNG_VALUE:\n-            return (\"value\");\n-        case XML_RELAXNG_LIST:\n-            return (\"list\");\n-        case XML_RELAXNG_ATTRIBUTE:\n-            return (\"attribute\");\n-        case XML_RELAXNG_DEF:\n-            return (\"def\");\n-        case XML_RELAXNG_REF:\n-            return (\"ref\");\n-        case XML_RELAXNG_EXTERNALREF:\n-            return (\"externalRef\");\n-        case XML_RELAXNG_PARENTREF:\n-            return (\"parentRef\");\n-        case XML_RELAXNG_OPTIONAL:\n-            return (\"optional\");\n-        case XML_RELAXNG_ZEROORMORE:\n-            return (\"zeroOrMore\");\n-        case XML_RELAXNG_ONEORMORE:\n-            return (\"oneOrMore\");\n-        case XML_RELAXNG_CHOICE:\n-            return (\"choice\");\n-        case XML_RELAXNG_GROUP:\n-            return (\"group\");\n-        case XML_RELAXNG_INTERLEAVE:\n-            return (\"interleave\");\n-        case XML_RELAXNG_START:\n-            return (\"start\");\n-        case XML_RELAXNG_NOOP:\n-            return (\"noop\");\n-        case XML_RELAXNG_PARAM:\n-            return (\"param\");\n-    }\n-    return (\"unknown\");\n-}\n-\n-\/**\n- * xmlRelaxNGGetErrorString:\n- * @err:  the error code\n- * @arg1:  the first string argument\n- * @arg2:  the second string argument\n- *\n- * computes a formatted error string for the given error code and args\n- *\n- * Returns the error string, it must be deallocated by the caller\n- *\/\n-static xmlChar *\n-xmlRelaxNGGetErrorString(xmlRelaxNGValidErr err, const xmlChar * arg1,\n-                         const xmlChar * arg2)\n-{\n-    char msg[1000];\n-    xmlChar *result;\n-\n-    if (arg1 == NULL)\n-        arg1 = BAD_CAST \"\";\n-    if (arg2 == NULL)\n-        arg2 = BAD_CAST \"\";\n-\n-    msg[0] = 0;\n-    switch (err) {\n-        case XML_RELAXNG_OK:\n-            return (NULL);\n-        case XML_RELAXNG_ERR_MEMORY:\n-            return (xmlCharStrdup(\"out of memory\\n\"));\n-        case XML_RELAXNG_ERR_TYPE:\n-            snprintf(msg, 1000, \"failed to validate type %s\\n\", arg1);\n-            break;\n-        case XML_RELAXNG_ERR_TYPEVAL:\n-            snprintf(msg, 1000, \"Type %s doesn't allow value '%s'\\n\", arg1,\n-                     arg2);\n-            break;\n-        case XML_RELAXNG_ERR_DUPID:\n-            snprintf(msg, 1000, \"ID %s redefined\\n\", arg1);\n-            break;\n-        case XML_RELAXNG_ERR_TYPECMP:\n-            snprintf(msg, 1000, \"failed to compare type %s\\n\", arg1);\n-            break;\n-        case XML_RELAXNG_ERR_NOSTATE:\n-            return (xmlCharStrdup(\"Internal error: no state\\n\"));\n-        case XML_RELAXNG_ERR_NODEFINE:\n-            return (xmlCharStrdup(\"Internal error: no define\\n\"));\n-        case XML_RELAXNG_ERR_INTERNAL:\n-            snprintf(msg, 1000, \"Internal error: %s\\n\", arg1);\n-            break;\n-        case XML_RELAXNG_ERR_LISTEXTRA:\n-            snprintf(msg, 1000, \"Extra data in list: %s\\n\", arg1);\n-            break;\n-        case XML_RELAXNG_ERR_INTERNODATA:\n-            return (xmlCharStrdup\n-                    (\"Internal: interleave block has no data\\n\"));\n-        case XML_RELAXNG_ERR_INTERSEQ:\n-            return (xmlCharStrdup(\"Invalid sequence in interleave\\n\"));\n-        case XML_RELAXNG_ERR_INTEREXTRA:\n-            snprintf(msg, 1000, \"Extra element %s in interleave\\n\", arg1);\n-            break;\n-        case XML_RELAXNG_ERR_ELEMNAME:\n-            snprintf(msg, 1000, \"Expecting element %s, got %s\\n\", arg1,\n-                     arg2);\n-            break;\n-        case XML_RELAXNG_ERR_ELEMNONS:\n-            snprintf(msg, 1000, \"Expecting a namespace for element %s\\n\",\n-                     arg1);\n-            break;\n-        case XML_RELAXNG_ERR_ELEMWRONGNS:\n-            snprintf(msg, 1000,\n-                     \"Element %s has wrong namespace: expecting %s\\n\", arg1,\n-                     arg2);\n-            break;\n-        case XML_RELAXNG_ERR_ELEMWRONG:\n-            snprintf(msg, 1000, \"Did not expect element %s there\\n\", arg1);\n-            break;\n-        case XML_RELAXNG_ERR_TEXTWRONG:\n-            snprintf(msg, 1000,\n-                     \"Did not expect text in element %s content\\n\", arg1);\n-            break;\n-        case XML_RELAXNG_ERR_ELEMEXTRANS:\n-            snprintf(msg, 1000, \"Expecting no namespace for element %s\\n\",\n-                     arg1);\n-            break;\n-        case XML_RELAXNG_ERR_ELEMNOTEMPTY:\n-            snprintf(msg, 1000, \"Expecting element %s to be empty\\n\", arg1);\n-            break;\n-        case XML_RELAXNG_ERR_NOELEM:\n-            snprintf(msg, 1000, \"Expecting an element %s, got nothing\\n\",\n-                     arg1);\n-            break;\n-        case XML_RELAXNG_ERR_NOTELEM:\n-            return (xmlCharStrdup(\"Expecting an element got text\\n\"));\n-        case XML_RELAXNG_ERR_ATTRVALID:\n-            snprintf(msg, 1000, \"Element %s failed to validate attributes\\n\",\n-                     arg1);\n-            break;\n-        case XML_RELAXNG_ERR_CONTENTVALID:\n-            snprintf(msg, 1000, \"Element %s failed to validate content\\n\",\n-                     arg1);\n-            break;\n-        case XML_RELAXNG_ERR_EXTRACONTENT:\n-            snprintf(msg, 1000, \"Element %s has extra content: %s\\n\",\n-                     arg1, arg2);\n-            break;\n-        case XML_RELAXNG_ERR_INVALIDATTR:\n-            snprintf(msg, 1000, \"Invalid attribute %s for element %s\\n\",\n-                     arg1, arg2);\n-            break;\n-        case XML_RELAXNG_ERR_LACKDATA:\n-            snprintf(msg, 1000, \"Datatype element %s contains no data\\n\",\n-                     arg1);\n-            break;\n-        case XML_RELAXNG_ERR_DATAELEM:\n-            snprintf(msg, 1000, \"Datatype element %s has child elements\\n\",\n-                     arg1);\n-            break;\n-        case XML_RELAXNG_ERR_VALELEM:\n-            snprintf(msg, 1000, \"Value element %s has child elements\\n\",\n-                     arg1);\n-            break;\n-        case XML_RELAXNG_ERR_LISTELEM:\n-            snprintf(msg, 1000, \"List element %s has child elements\\n\",\n-                     arg1);\n-            break;\n-        case XML_RELAXNG_ERR_DATATYPE:\n-            snprintf(msg, 1000, \"Error validating datatype %s\\n\", arg1);\n-            break;\n-        case XML_RELAXNG_ERR_VALUE:\n-            snprintf(msg, 1000, \"Error validating value %s\\n\", arg1);\n-            break;\n-        case XML_RELAXNG_ERR_LIST:\n-            return (xmlCharStrdup(\"Error validating list\\n\"));\n-        case XML_RELAXNG_ERR_NOGRAMMAR:\n-            return (xmlCharStrdup(\"No top grammar defined\\n\"));\n-        case XML_RELAXNG_ERR_EXTRADATA:\n-            return (xmlCharStrdup(\"Extra data in the document\\n\"));\n-        default:\n-            return (xmlCharStrdup(\"Unknown error !\\n\"));\n-    }\n-    if (msg[0] == 0) {\n-        snprintf(msg, 1000, \"Unknown error code %d\\n\", err);\n-    }\n-    msg[1000 - 1] = 0;\n-    result = xmlCharStrdup(msg);\n-    return (xmlEscapeFormatString(&result));\n-}\n-\n-\/**\n- * xmlRelaxNGShowValidError:\n- * @ctxt:  the validation context\n- * @err:  the error number\n- * @node:  the node\n- * @child:  the node child generating the problem.\n- * @arg1:  the first argument\n- * @arg2:  the second argument\n- *\n- * Show a validation error.\n- *\/\n-static void\n-xmlRelaxNGShowValidError(xmlRelaxNGValidCtxtPtr ctxt,\n-                         xmlRelaxNGValidErr err, xmlNodePtr node,\n-                         xmlNodePtr child, const xmlChar * arg1,\n-                         const xmlChar * arg2)\n-{\n-    xmlChar *msg;\n-\n-    if (ctxt->flags & FLAGS_NOERROR)\n-        return;\n-\n-    msg = xmlRelaxNGGetErrorString(err, arg1, arg2);\n-    if (msg == NULL)\n-        return;\n-\n-    if (ctxt->errNo == XML_RELAXNG_OK)\n-        ctxt->errNo = err;\n-    xmlRngVErr(ctxt, (child == NULL ? node : child), err,\n-               (const char *) msg, arg1, arg2);\n-    xmlFree(msg);\n-}\n-\n-\/**\n- * xmlRelaxNGPopErrors:\n- * @ctxt:  the validation context\n- * @level:  the error level in the stack\n- *\n- * pop and discard all errors until the given level is reached\n- *\/\n-static void\n-xmlRelaxNGPopErrors(xmlRelaxNGValidCtxtPtr ctxt, int level)\n-{\n-    int i;\n-    xmlRelaxNGValidErrorPtr err;\n-\n-    for (i = level; i < ctxt->errNr; i++) {\n-        err = &ctxt->errTab[i];\n-        if (err->flags & ERROR_IS_DUP) {\n-            if (err->arg1 != NULL)\n-                xmlFree((xmlChar *) err->arg1);\n-            err->arg1 = NULL;\n-            if (err->arg2 != NULL)\n-                xmlFree((xmlChar *) err->arg2);\n-            err->arg2 = NULL;\n-            err->flags = 0;\n-        }\n-    }\n-    ctxt->errNr = level;\n-    if (ctxt->errNr <= 0)\n-        ctxt->err = NULL;\n-}\n-\n-\/**\n- * xmlRelaxNGDumpValidError:\n- * @ctxt:  the validation context\n- *\n- * Show all validation error over a given index.\n- *\/\n-static void\n-xmlRelaxNGDumpValidError(xmlRelaxNGValidCtxtPtr ctxt)\n-{\n-    int i, j, k;\n-    xmlRelaxNGValidErrorPtr err, dup;\n-\n-    for (i = 0, k = 0; i < ctxt->errNr; i++) {\n-        err = &ctxt->errTab[i];\n-        if (k < MAX_ERROR) {\n-            for (j = 0; j < i; j++) {\n-                dup = &ctxt->errTab[j];\n-                if ((err->err == dup->err) && (err->node == dup->node) &&\n-                    (xmlStrEqual(err->arg1, dup->arg1)) &&\n-                    (xmlStrEqual(err->arg2, dup->arg2))) {\n-                    goto skip;\n-                }\n-            }\n-            xmlRelaxNGShowValidError(ctxt, err->err, err->node, err->seq,\n-                                     err->arg1, err->arg2);\n-            k++;\n-        }\n-      skip:\n-        if (err->flags & ERROR_IS_DUP) {\n-            if (err->arg1 != NULL)\n-                xmlFree((xmlChar *) err->arg1);\n-            err->arg1 = NULL;\n-            if (err->arg2 != NULL)\n-                xmlFree((xmlChar *) err->arg2);\n-            err->arg2 = NULL;\n-            err->flags = 0;\n-        }\n-    }\n-    ctxt->errNr = 0;\n-}\n-\n-\/**\n- * xmlRelaxNGAddValidError:\n- * @ctxt:  the validation context\n- * @err:  the error number\n- * @arg1:  the first argument\n- * @arg2:  the second argument\n- * @dup:  need to dup the args\n- *\n- * Register a validation error, either generating it if it's sure\n- * or stacking it for later handling if unsure.\n- *\/\n-static void\n-xmlRelaxNGAddValidError(xmlRelaxNGValidCtxtPtr ctxt,\n-                        xmlRelaxNGValidErr err, const xmlChar * arg1,\n-                        const xmlChar * arg2, int dup)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    if (ctxt->flags & FLAGS_NOERROR)\n-        return;\n-\n-    \/*\n-     * generate the error directly\n-     *\/\n-    if (((ctxt->flags & FLAGS_IGNORABLE) == 0) ||\n-     (ctxt->flags & FLAGS_NEGATIVE)) {\n-        xmlNodePtr node, seq;\n-\n-        \/*\n-         * Flush first any stacked error which might be the\n-         * real cause of the problem.\n-         *\/\n-        if (ctxt->errNr != 0)\n-            xmlRelaxNGDumpValidError(ctxt);\n-        if (ctxt->state != NULL) {\n-            node = ctxt->state->node;\n-            seq = ctxt->state->seq;\n-        } else {\n-            node = seq = NULL;\n-        }\n-        if ((node == NULL) && (seq == NULL)) {\n-            node = ctxt->pnode;\n-        }\n-        xmlRelaxNGShowValidError(ctxt, err, node, seq, arg1, arg2);\n-    }\n-    \/*\n-     * Stack the error for later processing if needed\n-     *\/\n-    else {\n-        xmlRelaxNGValidErrorPush(ctxt, err, arg1, arg2, dup);\n-    }\n-}\n-\n-\n-\/************************************************************************\n- *                                    *\n- *            Type library hooks                *\n- *                                    *\n- ************************************************************************\/\n-static xmlChar *xmlRelaxNGNormalize(xmlRelaxNGValidCtxtPtr ctxt,\n-                                    const xmlChar * str);\n-\n-\/**\n- * xmlRelaxNGSchemaTypeHave:\n- * @data:  data needed for the library\n- * @type:  the type name\n- *\n- * Check if the given type is provided by\n- * the W3C XMLSchema Datatype library.\n- *\n- * Returns 1 if yes, 0 if no and -1 in case of error.\n- *\/\n-static int\n-xmlRelaxNGSchemaTypeHave(void *data ATTRIBUTE_UNUSED, const xmlChar * type)\n-{\n-    xmlSchemaTypePtr typ;\n-\n-    if (type == NULL)\n-        return (-1);\n-    typ = xmlSchemaGetPredefinedType(type,\n-                                     BAD_CAST\n-                                     \"http:\/\/www.w3.org\/2001\/XMLSchema\");\n-    if (typ == NULL)\n-        return (0);\n-    return (1);\n-}\n-\n-\/**\n- * xmlRelaxNGSchemaTypeCheck:\n- * @data:  data needed for the library\n- * @type:  the type name\n- * @value:  the value to check\n- * @node:  the node\n- *\n- * Check if the given type and value are validated by\n- * the W3C XMLSchema Datatype library.\n- *\n- * Returns 1 if yes, 0 if no and -1 in case of error.\n- *\/\n-static int\n-xmlRelaxNGSchemaTypeCheck(void *data ATTRIBUTE_UNUSED,\n-                          const xmlChar * type,\n-                          const xmlChar * value,\n-                          void **result, xmlNodePtr node)\n-{\n-    xmlSchemaTypePtr typ;\n-    int ret;\n-\n-    if ((type == NULL) || (value == NULL))\n-        return (-1);\n-    typ = xmlSchemaGetPredefinedType(type,\n-                                     BAD_CAST\n-                                     \"http:\/\/www.w3.org\/2001\/XMLSchema\");\n-    if (typ == NULL)\n-        return (-1);\n-    ret = xmlSchemaValPredefTypeNode(typ, value,\n-                                     (xmlSchemaValPtr *) result, node);\n-    if (ret == 2)               \/* special ID error code *\/\n-        return (2);\n-    if (ret == 0)\n-        return (1);\n-    if (ret > 0)\n-        return (0);\n-    return (-1);\n-}\n-\n-\/**\n- * xmlRelaxNGSchemaFacetCheck:\n- * @data:  data needed for the library\n- * @type:  the type name\n- * @facet:  the facet name\n- * @val:  the facet value\n- * @strval:  the string value\n- * @value:  the value to check\n- *\n- * Function provided by a type library to check a value facet\n- *\n- * Returns 1 if yes, 0 if no and -1 in case of error.\n- *\/\n-static int\n-xmlRelaxNGSchemaFacetCheck(void *data ATTRIBUTE_UNUSED,\n-                           const xmlChar * type, const xmlChar * facetname,\n-                           const xmlChar * val, const xmlChar * strval,\n-                           void *value)\n-{\n-    xmlSchemaFacetPtr facet;\n-    xmlSchemaTypePtr typ;\n-    int ret;\n-\n-    if ((type == NULL) || (strval == NULL))\n-        return (-1);\n-    typ = xmlSchemaGetPredefinedType(type,\n-                                     BAD_CAST\n-                                     \"http:\/\/www.w3.org\/2001\/XMLSchema\");\n-    if (typ == NULL)\n-        return (-1);\n-\n-    facet = xmlSchemaNewFacet();\n-    if (facet == NULL)\n-        return (-1);\n-\n-    if (xmlStrEqual(facetname, BAD_CAST \"minInclusive\")) {\n-        facet->type = XML_SCHEMA_FACET_MININCLUSIVE;\n-    } else if (xmlStrEqual(facetname, BAD_CAST \"minExclusive\")) {\n-        facet->type = XML_SCHEMA_FACET_MINEXCLUSIVE;\n-    } else if (xmlStrEqual(facetname, BAD_CAST \"maxInclusive\")) {\n-        facet->type = XML_SCHEMA_FACET_MAXINCLUSIVE;\n-    } else if (xmlStrEqual(facetname, BAD_CAST \"maxExclusive\")) {\n-        facet->type = XML_SCHEMA_FACET_MAXEXCLUSIVE;\n-    } else if (xmlStrEqual(facetname, BAD_CAST \"totalDigits\")) {\n-        facet->type = XML_SCHEMA_FACET_TOTALDIGITS;\n-    } else if (xmlStrEqual(facetname, BAD_CAST \"fractionDigits\")) {\n-        facet->type = XML_SCHEMA_FACET_FRACTIONDIGITS;\n-    } else if (xmlStrEqual(facetname, BAD_CAST \"pattern\")) {\n-        facet->type = XML_SCHEMA_FACET_PATTERN;\n-    } else if (xmlStrEqual(facetname, BAD_CAST \"enumeration\")) {\n-        facet->type = XML_SCHEMA_FACET_ENUMERATION;\n-    } else if (xmlStrEqual(facetname, BAD_CAST \"whiteSpace\")) {\n-        facet->type = XML_SCHEMA_FACET_WHITESPACE;\n-    } else if (xmlStrEqual(facetname, BAD_CAST \"length\")) {\n-        facet->type = XML_SCHEMA_FACET_LENGTH;\n-    } else if (xmlStrEqual(facetname, BAD_CAST \"maxLength\")) {\n-        facet->type = XML_SCHEMA_FACET_MAXLENGTH;\n-    } else if (xmlStrEqual(facetname, BAD_CAST \"minLength\")) {\n-        facet->type = XML_SCHEMA_FACET_MINLENGTH;\n-    } else {\n-        xmlSchemaFreeFacet(facet);\n-        return (-1);\n-    }\n-    facet->value = val;\n-    ret = xmlSchemaCheckFacet(facet, typ, NULL, type);\n-    if (ret != 0) {\n-        xmlSchemaFreeFacet(facet);\n-        return (-1);\n-    }\n-    ret = xmlSchemaValidateFacet(typ, facet, strval, value);\n-    xmlSchemaFreeFacet(facet);\n-    if (ret != 0)\n-        return (-1);\n-    return (0);\n-}\n-\n-\/**\n- * xmlRelaxNGSchemaFreeValue:\n- * @data:  data needed for the library\n- * @value:  the value to free\n- *\n- * Function provided by a type library to free a Schemas value\n- *\n- * Returns 1 if yes, 0 if no and -1 in case of error.\n- *\/\n-static void\n-xmlRelaxNGSchemaFreeValue(void *data ATTRIBUTE_UNUSED, void *value)\n-{\n-    xmlSchemaFreeValue(value);\n-}\n-\n-\/**\n- * xmlRelaxNGSchemaTypeCompare:\n- * @data:  data needed for the library\n- * @type:  the type name\n- * @value1:  the first value\n- * @value2:  the second value\n- *\n- * Compare two values for equality accordingly a type from the W3C XMLSchema\n- * Datatype library.\n- *\n- * Returns 1 if equal, 0 if no and -1 in case of error.\n- *\/\n-static int\n-xmlRelaxNGSchemaTypeCompare(void *data ATTRIBUTE_UNUSED,\n-                            const xmlChar * type,\n-                            const xmlChar * value1,\n-                            xmlNodePtr ctxt1,\n-                            void *comp1,\n-                            const xmlChar * value2, xmlNodePtr ctxt2)\n-{\n-    int ret;\n-    xmlSchemaTypePtr typ;\n-    xmlSchemaValPtr res1 = NULL, res2 = NULL;\n-\n-    if ((type == NULL) || (value1 == NULL) || (value2 == NULL))\n-        return (-1);\n-    typ = xmlSchemaGetPredefinedType(type,\n-                                     BAD_CAST\n-                                     \"http:\/\/www.w3.org\/2001\/XMLSchema\");\n-    if (typ == NULL)\n-        return (-1);\n-    if (comp1 == NULL) {\n-        ret = xmlSchemaValPredefTypeNode(typ, value1, &res1, ctxt1);\n-        if (ret != 0)\n-            return (-1);\n-        if (res1 == NULL)\n-            return (-1);\n-    } else {\n-        res1 = (xmlSchemaValPtr) comp1;\n-    }\n-    ret = xmlSchemaValPredefTypeNode(typ, value2, &res2, ctxt2);\n-    if (ret != 0) {\n-    if (res1 != (xmlSchemaValPtr) comp1)\n-        xmlSchemaFreeValue(res1);\n-        return (-1);\n-    }\n-    ret = xmlSchemaCompareValues(res1, res2);\n-    if (res1 != (xmlSchemaValPtr) comp1)\n-        xmlSchemaFreeValue(res1);\n-    xmlSchemaFreeValue(res2);\n-    if (ret == -2)\n-        return (-1);\n-    if (ret == 0)\n-        return (1);\n-    return (0);\n-}\n-\n-\/**\n- * xmlRelaxNGDefaultTypeHave:\n- * @data:  data needed for the library\n- * @type:  the type name\n- *\n- * Check if the given type is provided by\n- * the default datatype library.\n- *\n- * Returns 1 if yes, 0 if no and -1 in case of error.\n- *\/\n-static int\n-xmlRelaxNGDefaultTypeHave(void *data ATTRIBUTE_UNUSED,\n-                          const xmlChar * type)\n-{\n-    if (type == NULL)\n-        return (-1);\n-    if (xmlStrEqual(type, BAD_CAST \"string\"))\n-        return (1);\n-    if (xmlStrEqual(type, BAD_CAST \"token\"))\n-        return (1);\n-    return (0);\n-}\n-\n-\/**\n- * xmlRelaxNGDefaultTypeCheck:\n- * @data:  data needed for the library\n- * @type:  the type name\n- * @value:  the value to check\n- * @node:  the node\n- *\n- * Check if the given type and value are validated by\n- * the default datatype library.\n- *\n- * Returns 1 if yes, 0 if no and -1 in case of error.\n- *\/\n-static int\n-xmlRelaxNGDefaultTypeCheck(void *data ATTRIBUTE_UNUSED,\n-                           const xmlChar * type ATTRIBUTE_UNUSED,\n-                           const xmlChar * value ATTRIBUTE_UNUSED,\n-                           void **result ATTRIBUTE_UNUSED,\n-                           xmlNodePtr node ATTRIBUTE_UNUSED)\n-{\n-    if (value == NULL)\n-        return (-1);\n-    if (xmlStrEqual(type, BAD_CAST \"string\"))\n-        return (1);\n-    if (xmlStrEqual(type, BAD_CAST \"token\")) {\n-        return (1);\n-    }\n-\n-    return (0);\n-}\n-\n-\/**\n- * xmlRelaxNGDefaultTypeCompare:\n- * @data:  data needed for the library\n- * @type:  the type name\n- * @value1:  the first value\n- * @value2:  the second value\n- *\n- * Compare two values accordingly a type from the default\n- * datatype library.\n- *\n- * Returns 1 if yes, 0 if no and -1 in case of error.\n- *\/\n-static int\n-xmlRelaxNGDefaultTypeCompare(void *data ATTRIBUTE_UNUSED,\n-                             const xmlChar * type,\n-                             const xmlChar * value1,\n-                             xmlNodePtr ctxt1 ATTRIBUTE_UNUSED,\n-                             void *comp1 ATTRIBUTE_UNUSED,\n-                             const xmlChar * value2,\n-                             xmlNodePtr ctxt2 ATTRIBUTE_UNUSED)\n-{\n-    int ret = -1;\n-\n-    if (xmlStrEqual(type, BAD_CAST \"string\")) {\n-        ret = xmlStrEqual(value1, value2);\n-    } else if (xmlStrEqual(type, BAD_CAST \"token\")) {\n-        if (!xmlStrEqual(value1, value2)) {\n-            xmlChar *nval, *nvalue;\n-\n-            \/*\n-             * TODO: trivial optimizations are possible by\n-             * computing at compile-time\n-             *\/\n-            nval = xmlRelaxNGNormalize(NULL, value1);\n-            nvalue = xmlRelaxNGNormalize(NULL, value2);\n-\n-            if ((nval == NULL) || (nvalue == NULL))\n-                ret = -1;\n-            else if (xmlStrEqual(nval, nvalue))\n-                ret = 1;\n-            else\n-                ret = 0;\n-            if (nval != NULL)\n-                xmlFree(nval);\n-            if (nvalue != NULL)\n-                xmlFree(nvalue);\n-        } else\n-            ret = 1;\n-    }\n-    return (ret);\n-}\n-\n-static int xmlRelaxNGTypeInitialized = 0;\n-static xmlHashTablePtr xmlRelaxNGRegisteredTypes = NULL;\n-\n-\/**\n- * xmlRelaxNGFreeTypeLibrary:\n- * @lib:  the type library structure\n- * @namespace:  the URI bound to the library\n- *\n- * Free the structure associated to the type library\n- *\/\n-static void\n-xmlRelaxNGFreeTypeLibrary(void *payload,\n-                          const xmlChar * namespace ATTRIBUTE_UNUSED)\n-{\n-    xmlRelaxNGTypeLibraryPtr lib = (xmlRelaxNGTypeLibraryPtr) payload;\n-    if (lib == NULL)\n-        return;\n-    if (lib->namespace != NULL)\n-        xmlFree((xmlChar *) lib->namespace);\n-    xmlFree(lib);\n-}\n-\n-\/**\n- * xmlRelaxNGRegisterTypeLibrary:\n- * @namespace:  the URI bound to the library\n- * @data:  data associated to the library\n- * @have:  the provide function\n- * @check:  the checking function\n- * @comp:  the comparison function\n- *\n- * Register a new type library\n- *\n- * Returns 0 in case of success and -1 in case of error.\n- *\/\n-static int\n-xmlRelaxNGRegisterTypeLibrary(const xmlChar * namespace, void *data,\n-                              xmlRelaxNGTypeHave have,\n-                              xmlRelaxNGTypeCheck check,\n-                              xmlRelaxNGTypeCompare comp,\n-                              xmlRelaxNGFacetCheck facet,\n-                              xmlRelaxNGTypeFree freef)\n-{\n-    xmlRelaxNGTypeLibraryPtr lib;\n-    int ret;\n-\n-    if ((xmlRelaxNGRegisteredTypes == NULL) || (namespace == NULL) ||\n-        (check == NULL) || (comp == NULL))\n-        return (-1);\n-    if (xmlHashLookup(xmlRelaxNGRegisteredTypes, namespace) != NULL)\n-        return (-1);\n-    lib =\n-        (xmlRelaxNGTypeLibraryPtr)\n-        xmlMalloc(sizeof(xmlRelaxNGTypeLibrary));\n-    if (lib == NULL) {\n-        xmlRngVErrMemory(NULL);\n-        return (-1);\n-    }\n-    memset(lib, 0, sizeof(xmlRelaxNGTypeLibrary));\n-    lib->namespace = xmlStrdup(namespace);\n-    lib->data = data;\n-    lib->have = have;\n-    lib->comp = comp;\n-    lib->check = check;\n-    lib->facet = facet;\n-    lib->freef = freef;\n-    ret = xmlHashAddEntry(xmlRelaxNGRegisteredTypes, namespace, lib);\n-    if (ret < 0) {\n-        xmlRelaxNGFreeTypeLibrary(lib, namespace);\n-        return (-1);\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlRelaxNGInitTypes:\n- *\n- * Initialize the default type libraries.\n- *\n- * Returns 0 in case of success and -1 in case of error.\n- *\/\n-int\n-xmlRelaxNGInitTypes(void)\n-{\n-    if (xmlRelaxNGTypeInitialized != 0)\n-        return (0);\n-    xmlRelaxNGRegisteredTypes = xmlHashCreate(10);\n-    if (xmlRelaxNGRegisteredTypes == NULL)\n-        return (-1);\n-    xmlRelaxNGRegisterTypeLibrary(BAD_CAST\n-                                  \"http:\/\/www.w3.org\/2001\/XMLSchema-datatypes\",\n-                                  NULL, xmlRelaxNGSchemaTypeHave,\n-                                  xmlRelaxNGSchemaTypeCheck,\n-                                  xmlRelaxNGSchemaTypeCompare,\n-                                  xmlRelaxNGSchemaFacetCheck,\n-                                  xmlRelaxNGSchemaFreeValue);\n-    xmlRelaxNGRegisterTypeLibrary(xmlRelaxNGNs, NULL,\n-                                  xmlRelaxNGDefaultTypeHave,\n-                                  xmlRelaxNGDefaultTypeCheck,\n-                                  xmlRelaxNGDefaultTypeCompare, NULL,\n-                                  NULL);\n-    xmlRelaxNGTypeInitialized = 1;\n-    return (0);\n-}\n-\n-\/**\n- * xmlRelaxNGCleanupTypes:\n- *\n- * DEPRECATED: This function will be made private. Call xmlCleanupParser\n- * to free global state but see the warnings there. xmlCleanupParser\n- * should be only called once at program exit. In most cases, you don't\n- * have call cleanup functions at all.\n- *\n- * Cleanup the default Schemas type library associated to RelaxNG\n- *\/\n-void\n-xmlRelaxNGCleanupTypes(void)\n-{\n-    xmlSchemaCleanupTypes();\n-    if (xmlRelaxNGTypeInitialized == 0)\n-        return;\n-    xmlHashFree(xmlRelaxNGRegisteredTypes, xmlRelaxNGFreeTypeLibrary);\n-    xmlRelaxNGTypeInitialized = 0;\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Compiling element content into regexp            *\n- *                                    *\n- * Sometime the element content can be compiled into a pure regexp,    *\n- * This allows a faster execution and streamability at that level    *\n- *                                    *\n- ************************************************************************\/\n-\n-static int xmlRelaxNGTryCompile(xmlRelaxNGParserCtxtPtr ctxt,\n-                                xmlRelaxNGDefinePtr def);\n-\n-\/**\n- * xmlRelaxNGIsCompilable:\n- * @define:  the definition to check\n- *\n- * Check if a definition is nullable.\n- *\n- * Returns 1 if yes, 0 if no and -1 in case of error\n- *\/\n-static int\n-xmlRelaxNGIsCompilable(xmlRelaxNGDefinePtr def)\n-{\n-    int ret = -1;\n-\n-    if (def == NULL) {\n-        return (-1);\n-    }\n-    if ((def->type != XML_RELAXNG_ELEMENT) &&\n-        (def->dflags & IS_COMPILABLE))\n-        return (1);\n-    if ((def->type != XML_RELAXNG_ELEMENT) &&\n-        (def->dflags & IS_NOT_COMPILABLE))\n-        return (0);\n-    switch (def->type) {\n-        case XML_RELAXNG_NOOP:\n-            ret = xmlRelaxNGIsCompilable(def->content);\n-            break;\n-        case XML_RELAXNG_TEXT:\n-        case XML_RELAXNG_EMPTY:\n-            ret = 1;\n-            break;\n-        case XML_RELAXNG_ELEMENT:\n-            \/*\n-             * Check if the element content is compilable\n-             *\/\n-            if (((def->dflags & IS_NOT_COMPILABLE) == 0) &&\n-                ((def->dflags & IS_COMPILABLE) == 0)) {\n-                xmlRelaxNGDefinePtr list;\n-\n-                list = def->content;\n-                while (list != NULL) {\n-                    ret = xmlRelaxNGIsCompilable(list);\n-                    if (ret != 1)\n-                        break;\n-                    list = list->next;\n-                }\n-        \/*\n-         * Because the routine is recursive, we must guard against\n-         * discovering both COMPILABLE and NOT_COMPILABLE\n-         *\/\n-                if (ret == 0) {\n-            def->dflags &= ~IS_COMPILABLE;\n-                    def->dflags |= IS_NOT_COMPILABLE;\n-        }\n-                if ((ret == 1) && !(def->dflags &= IS_NOT_COMPILABLE))\n-                    def->dflags |= IS_COMPILABLE;\n-            }\n-            \/*\n-             * All elements return a compilable status unless they\n-             * are generic like anyName\n-             *\/\n-            if ((def->nameClass != NULL) || (def->name == NULL))\n-                ret = 0;\n-            else\n-                ret = 1;\n-            return (ret);\n-        case XML_RELAXNG_REF:\n-        case XML_RELAXNG_EXTERNALREF:\n-        case XML_RELAXNG_PARENTREF:\n-            if (def->depth == -20) {\n-                return (1);\n-            } else {\n-                xmlRelaxNGDefinePtr list;\n-\n-                def->depth = -20;\n-                list = def->content;\n-                while (list != NULL) {\n-                    ret = xmlRelaxNGIsCompilable(list);\n-                    if (ret != 1)\n-                        break;\n-                    list = list->next;\n-                }\n-            }\n-            break;\n-        case XML_RELAXNG_START:\n-        case XML_RELAXNG_OPTIONAL:\n-        case XML_RELAXNG_ZEROORMORE:\n-        case XML_RELAXNG_ONEORMORE:\n-        case XML_RELAXNG_CHOICE:\n-        case XML_RELAXNG_GROUP:\n-        case XML_RELAXNG_DEF:{\n-                xmlRelaxNGDefinePtr list;\n-\n-                list = def->content;\n-                while (list != NULL) {\n-                    ret = xmlRelaxNGIsCompilable(list);\n-                    if (ret != 1)\n-                        break;\n-                    list = list->next;\n-                }\n-                break;\n-            }\n-        case XML_RELAXNG_EXCEPT:\n-        case XML_RELAXNG_ATTRIBUTE:\n-        case XML_RELAXNG_INTERLEAVE:\n-        case XML_RELAXNG_DATATYPE:\n-        case XML_RELAXNG_LIST:\n-        case XML_RELAXNG_PARAM:\n-        case XML_RELAXNG_VALUE:\n-        case XML_RELAXNG_NOT_ALLOWED:\n-            ret = 0;\n-            break;\n-    }\n-    if (ret == 0)\n-        def->dflags |= IS_NOT_COMPILABLE;\n-    if (ret == 1)\n-        def->dflags |= IS_COMPILABLE;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGCompile:\n- * ctxt:  the RelaxNG parser context\n- * @define:  the definition tree to compile\n- *\n- * Compile the set of definitions, it works recursively, till the\n- * element boundaries, where it tries to compile the content if possible\n- *\n- * Returns 0 if success and -1 in case of error\n- *\/\n-static int\n-xmlRelaxNGCompile(xmlRelaxNGParserCtxtPtr ctxt, xmlRelaxNGDefinePtr def)\n-{\n-    int ret = 0;\n-    xmlRelaxNGDefinePtr list;\n-\n-    if ((ctxt == NULL) || (def == NULL))\n-        return (-1);\n-\n-    switch (def->type) {\n-        case XML_RELAXNG_START:\n-            if ((xmlRelaxNGIsCompilable(def) == 1) && (def->depth != -25)) {\n-                xmlAutomataPtr oldam = ctxt->am;\n-                xmlAutomataStatePtr oldstate = ctxt->state;\n-\n-                def->depth = -25;\n-\n-                list = def->content;\n-                ctxt->am = xmlNewAutomata();\n-                if (ctxt->am == NULL)\n-                    return (-1);\n-\n-                \/*\n-                 * assume identical strings but not same pointer are different\n-                 * atoms, needed for non-determinism detection\n-                 * That way if 2 elements with the same name are in a choice\n-                 * branch the automata is found non-deterministic and\n-                 * we fallback to the normal validation which does the right\n-                 * thing of exploring both choices.\n-                 *\/\n-                xmlAutomataSetFlags(ctxt->am, 1);\n-\n-                ctxt->state = xmlAutomataGetInitState(ctxt->am);\n-                while (list != NULL) {\n-                    xmlRelaxNGCompile(ctxt, list);\n-                    list = list->next;\n-                }\n-                xmlAutomataSetFinalState(ctxt->am, ctxt->state);\n-                if (xmlAutomataIsDeterminist(ctxt->am))\n-                    def->contModel = xmlAutomataCompile(ctxt->am);\n-\n-                xmlFreeAutomata(ctxt->am);\n-                ctxt->state = oldstate;\n-                ctxt->am = oldam;\n-            }\n-            break;\n-        case XML_RELAXNG_ELEMENT:\n-            if ((ctxt->am != NULL) && (def->name != NULL)) {\n-                ctxt->state = xmlAutomataNewTransition2(ctxt->am,\n-                                                        ctxt->state, NULL,\n-                                                        def->name, def->ns,\n-                                                        def);\n-            }\n-            if ((def->dflags & IS_COMPILABLE) && (def->depth != -25)) {\n-                xmlAutomataPtr oldam = ctxt->am;\n-                xmlAutomataStatePtr oldstate = ctxt->state;\n-\n-                def->depth = -25;\n-\n-                list = def->content;\n-                ctxt->am = xmlNewAutomata();\n-                if (ctxt->am == NULL)\n-                    return (-1);\n-                xmlAutomataSetFlags(ctxt->am, 1);\n-                ctxt->state = xmlAutomataGetInitState(ctxt->am);\n-                while (list != NULL) {\n-                    xmlRelaxNGCompile(ctxt, list);\n-                    list = list->next;\n-                }\n-                xmlAutomataSetFinalState(ctxt->am, ctxt->state);\n-                def->contModel = xmlAutomataCompile(ctxt->am);\n-                if (!xmlRegexpIsDeterminist(def->contModel)) {\n-                    \/*\n-                     * we can only use the automata if it is determinist\n-                     *\/\n-                    xmlRegFreeRegexp(def->contModel);\n-                    def->contModel = NULL;\n-                }\n-                xmlFreeAutomata(ctxt->am);\n-                ctxt->state = oldstate;\n-                ctxt->am = oldam;\n-            } else {\n-                xmlAutomataPtr oldam = ctxt->am;\n-\n-                \/*\n-                 * we can't build the content model for this element content\n-                 * but it still might be possible to build it for some of its\n-                 * children, recurse.\n-                 *\/\n-                ret = xmlRelaxNGTryCompile(ctxt, def);\n-                ctxt->am = oldam;\n-            }\n-            break;\n-        case XML_RELAXNG_NOOP:\n-            ret = xmlRelaxNGCompile(ctxt, def->content);\n-            break;\n-        case XML_RELAXNG_OPTIONAL:{\n-                xmlAutomataStatePtr oldstate = ctxt->state;\n-\n-                list = def->content;\n-                while (list != NULL) {\n-                    xmlRelaxNGCompile(ctxt, list);\n-                    list = list->next;\n-                }\n-                xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n-                break;\n-            }\n-        case XML_RELAXNG_ZEROORMORE:{\n-                xmlAutomataStatePtr oldstate;\n-\n-                ctxt->state =\n-                    xmlAutomataNewEpsilon(ctxt->am, ctxt->state, NULL);\n-                oldstate = ctxt->state;\n-                list = def->content;\n-                while (list != NULL) {\n-                    xmlRelaxNGCompile(ctxt, list);\n-                    list = list->next;\n-                }\n-                xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldstate);\n-                ctxt->state =\n-                    xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);\n-                break;\n-            }\n-        case XML_RELAXNG_ONEORMORE:{\n-                xmlAutomataStatePtr oldstate;\n-\n-                list = def->content;\n-                while (list != NULL) {\n-                    xmlRelaxNGCompile(ctxt, list);\n-                    list = list->next;\n-                }\n-                oldstate = ctxt->state;\n-                list = def->content;\n-                while (list != NULL) {\n-                    xmlRelaxNGCompile(ctxt, list);\n-                    list = list->next;\n-                }\n-                xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldstate);\n-                ctxt->state =\n-                    xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);\n-                break;\n-            }\n-        case XML_RELAXNG_CHOICE:{\n-                xmlAutomataStatePtr target = NULL;\n-                xmlAutomataStatePtr oldstate = ctxt->state;\n-\n-                list = def->content;\n-                while (list != NULL) {\n-                    ctxt->state = oldstate;\n-                    ret = xmlRelaxNGCompile(ctxt, list);\n-                    if (ret != 0)\n-                        break;\n-                    if (target == NULL)\n-                        target = ctxt->state;\n-                    else {\n-                        xmlAutomataNewEpsilon(ctxt->am, ctxt->state,\n-                                              target);\n-                    }\n-                    list = list->next;\n-                }\n-                ctxt->state = target;\n-\n-                break;\n-            }\n-        case XML_RELAXNG_REF:\n-        case XML_RELAXNG_EXTERNALREF:\n-        case XML_RELAXNG_PARENTREF:\n-        case XML_RELAXNG_GROUP:\n-        case XML_RELAXNG_DEF:\n-            list = def->content;\n-            while (list != NULL) {\n-                ret = xmlRelaxNGCompile(ctxt, list);\n-                if (ret != 0)\n-                    break;\n-                list = list->next;\n-            }\n-            break;\n-        case XML_RELAXNG_TEXT:{\n-                xmlAutomataStatePtr oldstate;\n-\n-                ctxt->state =\n-                    xmlAutomataNewEpsilon(ctxt->am, ctxt->state, NULL);\n-                oldstate = ctxt->state;\n-                xmlRelaxNGCompile(ctxt, def->content);\n-                xmlAutomataNewTransition(ctxt->am, ctxt->state,\n-                                         ctxt->state, BAD_CAST \"#text\",\n-                                         NULL);\n-                ctxt->state =\n-                    xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);\n-                break;\n-            }\n-        case XML_RELAXNG_EMPTY:\n-            ctxt->state =\n-                xmlAutomataNewEpsilon(ctxt->am, ctxt->state, NULL);\n-            break;\n-        case XML_RELAXNG_EXCEPT:\n-        case XML_RELAXNG_ATTRIBUTE:\n-        case XML_RELAXNG_INTERLEAVE:\n-        case XML_RELAXNG_NOT_ALLOWED:\n-        case XML_RELAXNG_DATATYPE:\n-        case XML_RELAXNG_LIST:\n-        case XML_RELAXNG_PARAM:\n-        case XML_RELAXNG_VALUE:\n-            \/* This should not happen and generate an internal error *\/\n-            fprintf(stderr, \"RNG internal error trying to compile %s\\n\",\n-                    xmlRelaxNGDefName(def));\n-            break;\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGTryCompile:\n- * ctxt:  the RelaxNG parser context\n- * @define:  the definition tree to compile\n- *\n- * Try to compile the set of definitions, it works recursively,\n- * possibly ignoring parts which cannot be compiled.\n- *\n- * Returns 0 if success and -1 in case of error\n- *\/\n-static int\n-xmlRelaxNGTryCompile(xmlRelaxNGParserCtxtPtr ctxt, xmlRelaxNGDefinePtr def)\n-{\n-    int ret = 0;\n-    xmlRelaxNGDefinePtr list;\n-\n-    if ((ctxt == NULL) || (def == NULL))\n-        return (-1);\n-\n-    if ((def->type == XML_RELAXNG_START) ||\n-        (def->type == XML_RELAXNG_ELEMENT)) {\n-        ret = xmlRelaxNGIsCompilable(def);\n-        if ((def->dflags & IS_COMPILABLE) && (def->depth != -25)) {\n-            ctxt->am = NULL;\n-            ret = xmlRelaxNGCompile(ctxt, def);\n-            return (ret);\n-        }\n-    }\n-    switch (def->type) {\n-        case XML_RELAXNG_NOOP:\n-            ret = xmlRelaxNGTryCompile(ctxt, def->content);\n-            break;\n-        case XML_RELAXNG_TEXT:\n-        case XML_RELAXNG_DATATYPE:\n-        case XML_RELAXNG_LIST:\n-        case XML_RELAXNG_PARAM:\n-        case XML_RELAXNG_VALUE:\n-        case XML_RELAXNG_EMPTY:\n-        case XML_RELAXNG_ELEMENT:\n-            ret = 0;\n-            break;\n-        case XML_RELAXNG_OPTIONAL:\n-        case XML_RELAXNG_ZEROORMORE:\n-        case XML_RELAXNG_ONEORMORE:\n-        case XML_RELAXNG_CHOICE:\n-        case XML_RELAXNG_GROUP:\n-        case XML_RELAXNG_DEF:\n-        case XML_RELAXNG_START:\n-        case XML_RELAXNG_REF:\n-        case XML_RELAXNG_EXTERNALREF:\n-        case XML_RELAXNG_PARENTREF:\n-            list = def->content;\n-            while (list != NULL) {\n-                ret = xmlRelaxNGTryCompile(ctxt, list);\n-                if (ret != 0)\n-                    break;\n-                list = list->next;\n-            }\n-            break;\n-        case XML_RELAXNG_EXCEPT:\n-        case XML_RELAXNG_ATTRIBUTE:\n-        case XML_RELAXNG_INTERLEAVE:\n-        case XML_RELAXNG_NOT_ALLOWED:\n-            ret = 0;\n-            break;\n-    }\n-    return (ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Parsing functions                *\n- *                                    *\n- ************************************************************************\/\n-\n-static xmlRelaxNGDefinePtr xmlRelaxNGParseAttribute(xmlRelaxNGParserCtxtPtr\n-                                                    ctxt, xmlNodePtr node);\n-static xmlRelaxNGDefinePtr xmlRelaxNGParseElement(xmlRelaxNGParserCtxtPtr\n-                                                  ctxt, xmlNodePtr node);\n-static xmlRelaxNGDefinePtr xmlRelaxNGParsePatterns(xmlRelaxNGParserCtxtPtr\n-                                                   ctxt, xmlNodePtr nodes,\n-                                                   int group);\n-static xmlRelaxNGDefinePtr xmlRelaxNGParsePattern(xmlRelaxNGParserCtxtPtr\n-                                                  ctxt, xmlNodePtr node);\n-static xmlRelaxNGPtr xmlRelaxNGParseDocument(xmlRelaxNGParserCtxtPtr ctxt,\n-                                             xmlNodePtr node);\n-static int xmlRelaxNGParseGrammarContent(xmlRelaxNGParserCtxtPtr ctxt,\n-                                         xmlNodePtr nodes);\n-static xmlRelaxNGDefinePtr xmlRelaxNGParseNameClass(xmlRelaxNGParserCtxtPtr\n-                                                    ctxt, xmlNodePtr node,\n-                                                    xmlRelaxNGDefinePtr\n-                                                    def);\n-static xmlRelaxNGGrammarPtr xmlRelaxNGParseGrammar(xmlRelaxNGParserCtxtPtr\n-                                                   ctxt, xmlNodePtr nodes);\n-static int xmlRelaxNGElementMatch(xmlRelaxNGValidCtxtPtr ctxt,\n-                                  xmlRelaxNGDefinePtr define,\n-                                  xmlNodePtr elem);\n-\n-\n-#define IS_BLANK_NODE(n) (xmlRelaxNGIsBlank((n)->content))\n-\n-\/**\n- * xmlRelaxNGIsNullable:\n- * @define:  the definition to verify\n- *\n- * Check if a definition is nullable.\n- *\n- * Returns 1 if yes, 0 if no and -1 in case of error\n- *\/\n-static int\n-xmlRelaxNGIsNullable(xmlRelaxNGDefinePtr define)\n-{\n-    int ret;\n-\n-    if (define == NULL)\n-        return (-1);\n-\n-    if (define->dflags & IS_NULLABLE)\n-        return (1);\n-    if (define->dflags & IS_NOT_NULLABLE)\n-        return (0);\n-    switch (define->type) {\n-        case XML_RELAXNG_EMPTY:\n-        case XML_RELAXNG_TEXT:\n-            ret = 1;\n-            break;\n-        case XML_RELAXNG_NOOP:\n-        case XML_RELAXNG_DEF:\n-        case XML_RELAXNG_REF:\n-        case XML_RELAXNG_EXTERNALREF:\n-        case XML_RELAXNG_PARENTREF:\n-        case XML_RELAXNG_ONEORMORE:\n-            ret = xmlRelaxNGIsNullable(define->content);\n-            break;\n-        case XML_RELAXNG_EXCEPT:\n-        case XML_RELAXNG_NOT_ALLOWED:\n-        case XML_RELAXNG_ELEMENT:\n-        case XML_RELAXNG_DATATYPE:\n-        case XML_RELAXNG_PARAM:\n-        case XML_RELAXNG_VALUE:\n-        case XML_RELAXNG_LIST:\n-        case XML_RELAXNG_ATTRIBUTE:\n-            ret = 0;\n-            break;\n-        case XML_RELAXNG_CHOICE:{\n-                xmlRelaxNGDefinePtr list = define->content;\n-\n-                while (list != NULL) {\n-                    ret = xmlRelaxNGIsNullable(list);\n-                    if (ret != 0)\n-                        goto done;\n-                    list = list->next;\n-                }\n-                ret = 0;\n-                break;\n-            }\n-        case XML_RELAXNG_START:\n-        case XML_RELAXNG_INTERLEAVE:\n-        case XML_RELAXNG_GROUP:{\n-                xmlRelaxNGDefinePtr list = define->content;\n-\n-                while (list != NULL) {\n-                    ret = xmlRelaxNGIsNullable(list);\n-                    if (ret != 1)\n-                        goto done;\n-                    list = list->next;\n-                }\n-                return (1);\n-            }\n-        default:\n-            return (-1);\n-    }\n-  done:\n-    if (ret == 0)\n-        define->dflags |= IS_NOT_NULLABLE;\n-    if (ret == 1)\n-        define->dflags |= IS_NULLABLE;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGIsBlank:\n- * @str:  a string\n- *\n- * Check if a string is ignorable c.f. 4.2. Whitespace\n- *\n- * Returns 1 if the string is NULL or made of blanks chars, 0 otherwise\n- *\/\n-static int\n-xmlRelaxNGIsBlank(xmlChar * str)\n-{\n-    if (str == NULL)\n-        return (1);\n-    while (*str != 0) {\n-        if (!(IS_BLANK_CH(*str)))\n-            return (0);\n-        str++;\n-    }\n-    return (1);\n-}\n-\n-\/**\n- * xmlRelaxNGGetDataTypeLibrary:\n- * @ctxt:  a Relax-NG parser context\n- * @node:  the current data or value element\n- *\n- * Applies algorithm from 4.3. datatypeLibrary attribute\n- *\n- * Returns the datatypeLibrary value or NULL if not found\n- *\/\n-static xmlChar *\n-xmlRelaxNGGetDataTypeLibrary(xmlRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-                             xmlNodePtr node)\n-{\n-    xmlChar *ret, *escape;\n-\n-    if (node == NULL)\n-        return(NULL);\n-\n-    if ((IS_RELAXNG(node, \"data\")) || (IS_RELAXNG(node, \"value\"))) {\n-        ret = xmlGetProp(node, BAD_CAST \"datatypeLibrary\");\n-        if (ret != NULL) {\n-            if (ret[0] == 0) {\n-                xmlFree(ret);\n-                return (NULL);\n-            }\n-            escape = xmlURIEscapeStr(ret, BAD_CAST \":\/#?\");\n-            if (escape == NULL) {\n-                return (ret);\n-            }\n-            xmlFree(ret);\n-            return (escape);\n-        }\n-    }\n-    node = node->parent;\n-    while ((node != NULL) && (node->type == XML_ELEMENT_NODE)) {\n-        ret = xmlGetProp(node, BAD_CAST \"datatypeLibrary\");\n-        if (ret != NULL) {\n-            if (ret[0] == 0) {\n-                xmlFree(ret);\n-                return (NULL);\n-            }\n-            escape = xmlURIEscapeStr(ret, BAD_CAST \":\/#?\");\n-            if (escape == NULL) {\n-                return (ret);\n-            }\n-            xmlFree(ret);\n-            return (escape);\n-        }\n-        node = node->parent;\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlRelaxNGParseValue:\n- * @ctxt:  a Relax-NG parser context\n- * @node:  the data node.\n- *\n- * parse the content of a RelaxNG value node.\n- *\n- * Returns the definition pointer or NULL in case of error\n- *\/\n-static xmlRelaxNGDefinePtr\n-xmlRelaxNGParseValue(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlRelaxNGDefinePtr def = NULL;\n-    xmlRelaxNGTypeLibraryPtr lib = NULL;\n-    xmlChar *type;\n-    xmlChar *library;\n-    int success = 0;\n-\n-    def = xmlRelaxNGNewDefine(ctxt, node);\n-    if (def == NULL)\n-        return (NULL);\n-    def->type = XML_RELAXNG_VALUE;\n-\n-    type = xmlGetProp(node, BAD_CAST \"type\");\n-    if (type != NULL) {\n-        xmlRelaxNGNormExtSpace(type);\n-        if (xmlValidateNCName(type, 0)) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_TYPE_VALUE,\n-                       \"value type '%s' is not an NCName\\n\", type, NULL);\n-        }\n-        library = xmlRelaxNGGetDataTypeLibrary(ctxt, node);\n-        if (library == NULL)\n-            library =\n-                xmlStrdup(BAD_CAST \"http:\/\/relaxng.org\/ns\/structure\/1.0\");\n-\n-        def->name = type;\n-        def->ns = library;\n-\n-        lib = (xmlRelaxNGTypeLibraryPtr)\n-            xmlHashLookup(xmlRelaxNGRegisteredTypes, library);\n-        if (lib == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_UNKNOWN_TYPE_LIB,\n-                       \"Use of unregistered type library '%s'\\n\", library,\n-                       NULL);\n-            def->data = NULL;\n-        } else {\n-            def->data = lib;\n-            if (lib->have == NULL) {\n-                xmlRngPErr(ctxt, node, XML_RNGP_ERROR_TYPE_LIB,\n-                           \"Internal error with type library '%s': no 'have'\\n\",\n-                           library, NULL);\n-            } else {\n-                success = lib->have(lib->data, def->name);\n-                if (success != 1) {\n-                    xmlRngPErr(ctxt, node, XML_RNGP_TYPE_NOT_FOUND,\n-                               \"Error type '%s' is not exported by type library '%s'\\n\",\n-                               def->name, library);\n-                }\n-            }\n-        }\n-    }\n-    if (node->children == NULL) {\n-        def->value = xmlStrdup(BAD_CAST \"\");\n-    } else if (((node->children->type != XML_TEXT_NODE) &&\n-                (node->children->type != XML_CDATA_SECTION_NODE)) ||\n-               (node->children->next != NULL)) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_TEXT_EXPECTED,\n-                   \"Expecting a single text value for <value>content\\n\",\n-                   NULL, NULL);\n-    } else if (def != NULL) {\n-        def->value = xmlNodeGetContent(node);\n-        if (def->value == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_VALUE_NO_CONTENT,\n-                       \"Element <value> has no content\\n\", NULL, NULL);\n-        } else if ((lib != NULL) && (lib->check != NULL) && (success == 1)) {\n-            void *val = NULL;\n-\n-            success =\n-                lib->check(lib->data, def->name, def->value, &val, node);\n-            if (success != 1) {\n-                xmlRngPErr(ctxt, node, XML_RNGP_INVALID_VALUE,\n-                           \"Value '%s' is not acceptable for type '%s'\\n\",\n-                           def->value, def->name);\n-            } else {\n-                if (val != NULL)\n-                    def->attrs = val;\n-            }\n-        }\n-    }\n-    return (def);\n-}\n-\n-\/**\n- * xmlRelaxNGParseData:\n- * @ctxt:  a Relax-NG parser context\n- * @node:  the data node.\n- *\n- * parse the content of a RelaxNG data node.\n- *\n- * Returns the definition pointer or NULL in case of error\n- *\/\n-static xmlRelaxNGDefinePtr\n-xmlRelaxNGParseData(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlRelaxNGDefinePtr def = NULL, except;\n-    xmlRelaxNGDefinePtr param, lastparam = NULL;\n-    xmlRelaxNGTypeLibraryPtr lib;\n-    xmlChar *type;\n-    xmlChar *library;\n-    xmlNodePtr content;\n-    int tmp;\n-\n-    type = xmlGetProp(node, BAD_CAST \"type\");\n-    if (type == NULL) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_TYPE_MISSING, \"data has no type\\n\", NULL,\n-                   NULL);\n-        return (NULL);\n-    }\n-    xmlRelaxNGNormExtSpace(type);\n-    if (xmlValidateNCName(type, 0)) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_TYPE_VALUE,\n-                   \"data type '%s' is not an NCName\\n\", type, NULL);\n-    }\n-    library = xmlRelaxNGGetDataTypeLibrary(ctxt, node);\n-    if (library == NULL)\n-        library =\n-            xmlStrdup(BAD_CAST \"http:\/\/relaxng.org\/ns\/structure\/1.0\");\n-\n-    def = xmlRelaxNGNewDefine(ctxt, node);\n-    if (def == NULL) {\n-        xmlFree(library);\n-        xmlFree(type);\n-        return (NULL);\n-    }\n-    def->type = XML_RELAXNG_DATATYPE;\n-    def->name = type;\n-    def->ns = library;\n-\n-    lib = (xmlRelaxNGTypeLibraryPtr)\n-        xmlHashLookup(xmlRelaxNGRegisteredTypes, library);\n-    if (lib == NULL) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_UNKNOWN_TYPE_LIB,\n-                   \"Use of unregistered type library '%s'\\n\", library,\n-                   NULL);\n-        def->data = NULL;\n-    } else {\n-        def->data = lib;\n-        if (lib->have == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_ERROR_TYPE_LIB,\n-                       \"Internal error with type library '%s': no 'have'\\n\",\n-                       library, NULL);\n-        } else {\n-            tmp = lib->have(lib->data, def->name);\n-            if (tmp != 1) {\n-                xmlRngPErr(ctxt, node, XML_RNGP_TYPE_NOT_FOUND,\n-                           \"Error type '%s' is not exported by type library '%s'\\n\",\n-                           def->name, library);\n-            } else\n-                if ((xmlStrEqual\n-                     (library,\n-                      BAD_CAST\n-                      \"http:\/\/www.w3.org\/2001\/XMLSchema-datatypes\"))\n-                    && ((xmlStrEqual(def->name, BAD_CAST \"IDREF\"))\n-                        || (xmlStrEqual(def->name, BAD_CAST \"IDREFS\")))) {\n-                ctxt->idref = 1;\n-            }\n-        }\n-    }\n-    content = node->children;\n-\n-    \/*\n-     * Handle optional params\n-     *\/\n-    while (content != NULL) {\n-        if (!xmlStrEqual(content->name, BAD_CAST \"param\"))\n-            break;\n-        if (xmlStrEqual(library,\n-                        BAD_CAST \"http:\/\/relaxng.org\/ns\/structure\/1.0\")) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_PARAM_FORBIDDEN,\n-                       \"Type library '%s' does not allow type parameters\\n\",\n-                       library, NULL);\n-            content = content->next;\n-            while ((content != NULL) &&\n-                   (xmlStrEqual(content->name, BAD_CAST \"param\")))\n-                content = content->next;\n-        } else {\n-            param = xmlRelaxNGNewDefine(ctxt, node);\n-            if (param != NULL) {\n-                param->type = XML_RELAXNG_PARAM;\n-                param->name = xmlGetProp(content, BAD_CAST \"name\");\n-                if (param->name == NULL) {\n-                    xmlRngPErr(ctxt, node, XML_RNGP_PARAM_NAME_MISSING,\n-                               \"param has no name\\n\", NULL, NULL);\n-                }\n-                param->value = xmlNodeGetContent(content);\n-                if (lastparam == NULL) {\n-                    def->attrs = lastparam = param;\n-                } else {\n-                    lastparam->next = param;\n-                    lastparam = param;\n-                }\n-                if (lib != NULL) {\n-                }\n-            }\n-            content = content->next;\n-        }\n-    }\n-    \/*\n-     * Handle optional except\n-     *\/\n-    if ((content != NULL)\n-        && (xmlStrEqual(content->name, BAD_CAST \"except\"))) {\n-        xmlNodePtr child;\n-        xmlRelaxNGDefinePtr tmp2, last = NULL;\n-\n-        except = xmlRelaxNGNewDefine(ctxt, node);\n-        if (except == NULL) {\n-            return (def);\n-        }\n-        except->type = XML_RELAXNG_EXCEPT;\n-        child = content->children;\n-    def->content = except;\n-        if (child == NULL) {\n-            xmlRngPErr(ctxt, content, XML_RNGP_EXCEPT_NO_CONTENT,\n-                       \"except has no content\\n\", NULL, NULL);\n-        }\n-        while (child != NULL) {\n-            tmp2 = xmlRelaxNGParsePattern(ctxt, child);\n-            if (tmp2 != NULL) {\n-                if (last == NULL) {\n-                    except->content = last = tmp2;\n-                } else {\n-                    last->next = tmp2;\n-                    last = tmp2;\n-                }\n-            }\n-            child = child->next;\n-        }\n-        content = content->next;\n-    }\n-    \/*\n-     * Check there is no unhandled data\n-     *\/\n-    if (content != NULL) {\n-        xmlRngPErr(ctxt, content, XML_RNGP_DATA_CONTENT,\n-                   \"Element data has unexpected content %s\\n\",\n-                   content->name, NULL);\n-    }\n-\n-    return (def);\n-}\n-\n-static const xmlChar *invalidName = BAD_CAST \"\\1\";\n-\n-\/**\n- * xmlRelaxNGCompareNameClasses:\n- * @defs1:  the first element\/attribute defs\n- * @defs2:  the second element\/attribute defs\n- * @name:  the restriction on the name\n- * @ns:  the restriction on the namespace\n- *\n- * Compare the 2 lists of element definitions. The comparison is\n- * that if both lists do not accept the same QNames, it returns 1\n- * If the 2 lists can accept the same QName the comparison returns 0\n- *\n- * Returns 1 distinct, 0 if equal\n- *\/\n-static int\n-xmlRelaxNGCompareNameClasses(xmlRelaxNGDefinePtr def1,\n-                             xmlRelaxNGDefinePtr def2)\n-{\n-    int ret = 1;\n-    xmlNode node;\n-    xmlNs ns;\n-    xmlRelaxNGValidCtxt ctxt;\n-\n-    memset(&ctxt, 0, sizeof(xmlRelaxNGValidCtxt));\n-\n-    ctxt.flags = FLAGS_IGNORABLE | FLAGS_NOERROR;\n-\n-    if ((def1->type == XML_RELAXNG_ELEMENT) ||\n-        (def1->type == XML_RELAXNG_ATTRIBUTE)) {\n-        if (def2->type == XML_RELAXNG_TEXT)\n-            return (1);\n-        if (def1->name != NULL) {\n-            node.name = def1->name;\n-        } else {\n-            node.name = invalidName;\n-        }\n-        if (def1->ns != NULL) {\n-            if (def1->ns[0] == 0) {\n-                node.ns = NULL;\n-            } else {\n-            node.ns = &ns;\n-                ns.href = def1->ns;\n-            }\n-        } else {\n-            node.ns = NULL;\n-        }\n-        if (xmlRelaxNGElementMatch(&ctxt, def2, &node)) {\n-            if (def1->nameClass != NULL) {\n-                ret = xmlRelaxNGCompareNameClasses(def1->nameClass, def2);\n-            } else {\n-                ret = 0;\n-            }\n-        } else {\n-            ret = 1;\n-        }\n-    } else if (def1->type == XML_RELAXNG_TEXT) {\n-        if (def2->type == XML_RELAXNG_TEXT)\n-            return (0);\n-        return (1);\n-    } else if (def1->type == XML_RELAXNG_EXCEPT) {\n-        ret = xmlRelaxNGCompareNameClasses(def1->content, def2);\n-    if (ret == 0)\n-        ret = 1;\n-    else if (ret == 1)\n-        ret = 0;\n-    } else {\n-        \/* TODO *\/\n-        ret = 0;\n-    }\n-    if (ret == 0)\n-        return (ret);\n-    if ((def2->type == XML_RELAXNG_ELEMENT) ||\n-        (def2->type == XML_RELAXNG_ATTRIBUTE)) {\n-        if (def2->name != NULL) {\n-            node.name = def2->name;\n-        } else {\n-            node.name = invalidName;\n-        }\n-        node.ns = &ns;\n-        if (def2->ns != NULL) {\n-            if (def2->ns[0] == 0) {\n-                node.ns = NULL;\n-            } else {\n-                ns.href = def2->ns;\n-            }\n-        } else {\n-            ns.href = invalidName;\n-        }\n-        if (xmlRelaxNGElementMatch(&ctxt, def1, &node)) {\n-            if (def2->nameClass != NULL) {\n-                ret = xmlRelaxNGCompareNameClasses(def2->nameClass, def1);\n-            } else {\n-                ret = 0;\n-            }\n-        } else {\n-            ret = 1;\n-        }\n-    } else {\n-        \/* TODO *\/\n-        ret = 0;\n-    }\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGCompareElemDefLists:\n- * @ctxt:  a Relax-NG parser context\n- * @defs1:  the first list of element\/attribute defs\n- * @defs2:  the second list of element\/attribute defs\n- *\n- * Compare the 2 lists of element or attribute definitions. The comparison\n- * is that if both lists do not accept the same QNames, it returns 1\n- * If the 2 lists can accept the same QName the comparison returns 0\n- *\n- * Returns 1 distinct, 0 if equal\n- *\/\n-static int\n-xmlRelaxNGCompareElemDefLists(xmlRelaxNGParserCtxtPtr ctxt\n-                              ATTRIBUTE_UNUSED, xmlRelaxNGDefinePtr * def1,\n-                              xmlRelaxNGDefinePtr * def2)\n-{\n-    xmlRelaxNGDefinePtr *basedef2 = def2;\n-\n-    if ((def1 == NULL) || (def2 == NULL))\n-        return (1);\n-    if ((*def1 == NULL) || (*def2 == NULL))\n-        return (1);\n-    while (*def1 != NULL) {\n-        while ((*def2) != NULL) {\n-            if (xmlRelaxNGCompareNameClasses(*def1, *def2) == 0)\n-                return (0);\n-            def2++;\n-        }\n-        def2 = basedef2;\n-        def1++;\n-    }\n-    return (1);\n-}\n-\n-\/**\n- * xmlRelaxNGGenerateAttributes:\n- * @ctxt:  a Relax-NG parser context\n- * @def:  the definition definition\n- *\n- * Check if the definition can only generate attributes\n- *\n- * Returns 1 if yes, 0 if no and -1 in case of error.\n- *\/\n-static int\n-xmlRelaxNGGenerateAttributes(xmlRelaxNGParserCtxtPtr ctxt,\n-                             xmlRelaxNGDefinePtr def)\n-{\n-    xmlRelaxNGDefinePtr parent, cur, tmp;\n-\n-    \/*\n-     * Don't run that check in case of error. Infinite recursion\n-     * becomes possible.\n-     *\/\n-    if (ctxt->nbErrors != 0)\n-        return (-1);\n-\n-    parent = NULL;\n-    cur = def;\n-    while (cur != NULL) {\n-        if ((cur->type == XML_RELAXNG_ELEMENT) ||\n-            (cur->type == XML_RELAXNG_TEXT) ||\n-            (cur->type == XML_RELAXNG_DATATYPE) ||\n-            (cur->type == XML_RELAXNG_PARAM) ||\n-            (cur->type == XML_RELAXNG_LIST) ||\n-            (cur->type == XML_RELAXNG_VALUE) ||\n-            (cur->type == XML_RELAXNG_EMPTY))\n-            return (0);\n-        if ((cur->type == XML_RELAXNG_CHOICE) ||\n-            (cur->type == XML_RELAXNG_INTERLEAVE) ||\n-            (cur->type == XML_RELAXNG_GROUP) ||\n-            (cur->type == XML_RELAXNG_ONEORMORE) ||\n-            (cur->type == XML_RELAXNG_ZEROORMORE) ||\n-            (cur->type == XML_RELAXNG_OPTIONAL) ||\n-            (cur->type == XML_RELAXNG_PARENTREF) ||\n-            (cur->type == XML_RELAXNG_EXTERNALREF) ||\n-            (cur->type == XML_RELAXNG_REF) ||\n-            (cur->type == XML_RELAXNG_DEF)) {\n-            if (cur->content != NULL) {\n-                parent = cur;\n-                cur = cur->content;\n-                tmp = cur;\n-                while (tmp != NULL) {\n-                    tmp->parent = parent;\n-                    tmp = tmp->next;\n-                }\n-                continue;\n-            }\n-        }\n-        if (cur == def)\n-            break;\n-        if (cur->next != NULL) {\n-            cur = cur->next;\n-            continue;\n-        }\n-        do {\n-            cur = cur->parent;\n-            if (cur == NULL)\n-                break;\n-            if (cur == def)\n-                return (1);\n-            if (cur->next != NULL) {\n-                cur = cur->next;\n-                break;\n-            }\n-        } while (cur != NULL);\n-    }\n-    return (1);\n-}\n-\n-\/**\n- * xmlRelaxNGGetElements:\n- * @ctxt:  a Relax-NG parser context\n- * @def:  the definition definition\n- * @eora:  gather elements (0), attributes (1) or elements and text (2)\n- *\n- * Compute the list of top elements a definition can generate\n- *\n- * Returns a list of elements or NULL if none was found.\n- *\/\n-static xmlRelaxNGDefinePtr *\n-xmlRelaxNGGetElements(xmlRelaxNGParserCtxtPtr ctxt,\n-                      xmlRelaxNGDefinePtr def, int eora)\n-{\n-    xmlRelaxNGDefinePtr *ret = NULL, parent, cur, tmp;\n-    int len = 0;\n-    int max = 0;\n-\n-    \/*\n-     * Don't run that check in case of error. Infinite recursion\n-     * becomes possible.\n-     *\/\n-    if (ctxt->nbErrors != 0)\n-        return (NULL);\n-\n-    parent = NULL;\n-    cur = def;\n-    while (cur != NULL) {\n-        if (((eora == 0) && ((cur->type == XML_RELAXNG_ELEMENT) ||\n-                             (cur->type == XML_RELAXNG_TEXT))) ||\n-            ((eora == 1) && (cur->type == XML_RELAXNG_ATTRIBUTE)) ||\n-            ((eora == 2) && ((cur->type == XML_RELAXNG_DATATYPE) ||\n-                         (cur->type == XML_RELAXNG_ELEMENT) ||\n-                 (cur->type == XML_RELAXNG_LIST) ||\n-                             (cur->type == XML_RELAXNG_TEXT) ||\n-                 (cur->type == XML_RELAXNG_VALUE)))) {\n-            if (ret == NULL) {\n-                max = 10;\n-                ret = (xmlRelaxNGDefinePtr *)\n-                    xmlMalloc((max + 1) * sizeof(xmlRelaxNGDefinePtr));\n-                if (ret == NULL) {\n-                    xmlRngPErrMemory(ctxt);\n-                    return (NULL);\n-                }\n-            } else if (max <= len) {\n-            xmlRelaxNGDefinePtr *temp;\n-\n-                max *= 2;\n-                temp = xmlRealloc(ret,\n-                               (max + 1) * sizeof(xmlRelaxNGDefinePtr));\n-                if (temp == NULL) {\n-                    xmlRngPErrMemory(ctxt);\n-            xmlFree(ret);\n-                    return (NULL);\n-                }\n-        ret = temp;\n-            }\n-            ret[len++] = cur;\n-            ret[len] = NULL;\n-        } else if ((cur->type == XML_RELAXNG_CHOICE) ||\n-                   (cur->type == XML_RELAXNG_INTERLEAVE) ||\n-                   (cur->type == XML_RELAXNG_GROUP) ||\n-                   (cur->type == XML_RELAXNG_ONEORMORE) ||\n-                   (cur->type == XML_RELAXNG_ZEROORMORE) ||\n-                   (cur->type == XML_RELAXNG_OPTIONAL) ||\n-                   (cur->type == XML_RELAXNG_PARENTREF) ||\n-                   (cur->type == XML_RELAXNG_REF) ||\n-                   (cur->type == XML_RELAXNG_DEF) ||\n-           (cur->type == XML_RELAXNG_EXTERNALREF)) {\n-            \/*\n-             * Don't go within elements or attributes or string values.\n-             * Just gather the element top list\n-             *\/\n-            if (cur->content != NULL) {\n-                parent = cur;\n-                cur = cur->content;\n-                tmp = cur;\n-                while (tmp != NULL) {\n-                    tmp->parent = parent;\n-                    tmp = tmp->next;\n-                }\n-                continue;\n-            }\n-        }\n-        if (cur == def)\n-            break;\n-        if (cur->next != NULL) {\n-            cur = cur->next;\n-            continue;\n-        }\n-        do {\n-            cur = cur->parent;\n-            if (cur == NULL)\n-                break;\n-            if (cur == def)\n-                return (ret);\n-            if (cur->next != NULL) {\n-                cur = cur->next;\n-                break;\n-            }\n-        } while (cur != NULL);\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGCheckChoiceDeterminism:\n- * @ctxt:  a Relax-NG parser context\n- * @def:  the choice definition\n- *\n- * Also used to find indeterministic pattern in choice\n- *\/\n-static void\n-xmlRelaxNGCheckChoiceDeterminism(xmlRelaxNGParserCtxtPtr ctxt,\n-                                 xmlRelaxNGDefinePtr def)\n-{\n-    xmlRelaxNGDefinePtr **list;\n-    xmlRelaxNGDefinePtr cur;\n-    int nbchild = 0, i, j, ret;\n-    int is_nullable = 0;\n-    int is_indeterminist = 0;\n-    xmlHashTablePtr triage = NULL;\n-    int is_triable = 1;\n-\n-    if ((def == NULL) || (def->type != XML_RELAXNG_CHOICE))\n-        return;\n-\n-    if (def->dflags & IS_PROCESSED)\n-        return;\n-\n-    \/*\n-     * Don't run that check in case of error. Infinite recursion\n-     * becomes possible.\n-     *\/\n-    if (ctxt->nbErrors != 0)\n-        return;\n-\n-    is_nullable = xmlRelaxNGIsNullable(def);\n-\n-    cur = def->content;\n-    while (cur != NULL) {\n-        nbchild++;\n-        cur = cur->next;\n-    }\n-\n-    list = (xmlRelaxNGDefinePtr **) xmlMalloc(nbchild *\n-                                              sizeof(xmlRelaxNGDefinePtr\n-                                                     *));\n-    if (list == NULL) {\n-        xmlRngPErrMemory(ctxt);\n-        return;\n-    }\n-    i = 0;\n-    \/*\n-     * a bit strong but safe\n-     *\/\n-    if (is_nullable == 0) {\n-        triage = xmlHashCreate(10);\n-    } else {\n-        is_triable = 0;\n-    }\n-    cur = def->content;\n-    while (cur != NULL) {\n-        list[i] = xmlRelaxNGGetElements(ctxt, cur, 0);\n-        if ((list[i] == NULL) || (list[i][0] == NULL)) {\n-            is_triable = 0;\n-        } else if (is_triable == 1) {\n-            xmlRelaxNGDefinePtr *tmp;\n-            int res;\n-\n-            tmp = list[i];\n-            while ((*tmp != NULL) && (is_triable == 1)) {\n-                if ((*tmp)->type == XML_RELAXNG_TEXT) {\n-                    res = xmlHashAddEntry2(triage,\n-                                           BAD_CAST \"#text\", NULL,\n-                                           (void *) cur);\n-                    if (res != 0)\n-                        is_triable = -1;\n-                } else if (((*tmp)->type == XML_RELAXNG_ELEMENT) &&\n-                           ((*tmp)->name != NULL)) {\n-                    if (((*tmp)->ns == NULL) || ((*tmp)->ns[0] == 0))\n-                        res = xmlHashAddEntry2(triage,\n-                                               (*tmp)->name, NULL,\n-                                               (void *) cur);\n-                    else\n-                        res = xmlHashAddEntry2(triage,\n-                                               (*tmp)->name, (*tmp)->ns,\n-                                               (void *) cur);\n-                    if (res != 0)\n-                        is_triable = -1;\n-                } else if ((*tmp)->type == XML_RELAXNG_ELEMENT) {\n-                    if (((*tmp)->ns == NULL) || ((*tmp)->ns[0] == 0))\n-                        res = xmlHashAddEntry2(triage,\n-                                               BAD_CAST \"#any\", NULL,\n-                                               (void *) cur);\n-                    else\n-                        res = xmlHashAddEntry2(triage,\n-                                               BAD_CAST \"#any\", (*tmp)->ns,\n-                                               (void *) cur);\n-                    if (res != 0)\n-                        is_triable = -1;\n-                } else {\n-                    is_triable = -1;\n-                }\n-                tmp++;\n-            }\n-        }\n-        i++;\n-        cur = cur->next;\n-    }\n-\n-    for (i = 0; i < nbchild; i++) {\n-        if (list[i] == NULL)\n-            continue;\n-        for (j = 0; j < i; j++) {\n-            if (list[j] == NULL)\n-                continue;\n-            ret = xmlRelaxNGCompareElemDefLists(ctxt, list[i], list[j]);\n-            if (ret == 0) {\n-                is_indeterminist = 1;\n-            }\n-        }\n-    }\n-    for (i = 0; i < nbchild; i++) {\n-        if (list[i] != NULL)\n-            xmlFree(list[i]);\n-    }\n-\n-    xmlFree(list);\n-    if (is_indeterminist) {\n-        def->dflags |= IS_INDETERMINIST;\n-    }\n-    if (is_triable == 1) {\n-        def->dflags |= IS_TRIABLE;\n-        def->data = triage;\n-    } else if (triage != NULL) {\n-        xmlHashFree(triage, NULL);\n-    }\n-    def->dflags |= IS_PROCESSED;\n-}\n-\n-\/**\n- * xmlRelaxNGCheckGroupAttrs:\n- * @ctxt:  a Relax-NG parser context\n- * @def:  the group definition\n- *\n- * Detects violations of rule 7.3\n- *\/\n-static void\n-xmlRelaxNGCheckGroupAttrs(xmlRelaxNGParserCtxtPtr ctxt,\n-                          xmlRelaxNGDefinePtr def)\n-{\n-    xmlRelaxNGDefinePtr **list;\n-    xmlRelaxNGDefinePtr cur;\n-    int nbchild = 0, i, j, ret;\n-\n-    if ((def == NULL) ||\n-        ((def->type != XML_RELAXNG_GROUP) &&\n-         (def->type != XML_RELAXNG_ELEMENT)))\n-        return;\n-\n-    if (def->dflags & IS_PROCESSED)\n-        return;\n-\n-    \/*\n-     * Don't run that check in case of error. Infinite recursion\n-     * becomes possible.\n-     *\/\n-    if (ctxt->nbErrors != 0)\n-        return;\n-\n-    cur = def->attrs;\n-    while (cur != NULL) {\n-        nbchild++;\n-        cur = cur->next;\n-    }\n-    cur = def->content;\n-    while (cur != NULL) {\n-        nbchild++;\n-        cur = cur->next;\n-    }\n-\n-    list = (xmlRelaxNGDefinePtr **) xmlMalloc(nbchild *\n-                                              sizeof(xmlRelaxNGDefinePtr\n-                                                     *));\n-    if (list == NULL) {\n-        xmlRngPErrMemory(ctxt);\n-        return;\n-    }\n-    i = 0;\n-    cur = def->attrs;\n-    while (cur != NULL) {\n-        list[i] = xmlRelaxNGGetElements(ctxt, cur, 1);\n-        i++;\n-        cur = cur->next;\n-    }\n-    cur = def->content;\n-    while (cur != NULL) {\n-        list[i] = xmlRelaxNGGetElements(ctxt, cur, 1);\n-        i++;\n-        cur = cur->next;\n-    }\n-\n-    for (i = 0; i < nbchild; i++) {\n-        if (list[i] == NULL)\n-            continue;\n-        for (j = 0; j < i; j++) {\n-            if (list[j] == NULL)\n-                continue;\n-            ret = xmlRelaxNGCompareElemDefLists(ctxt, list[i], list[j]);\n-            if (ret == 0) {\n-                xmlRngPErr(ctxt, def->node, XML_RNGP_GROUP_ATTR_CONFLICT,\n-                           \"Attributes conflicts in group\\n\", NULL, NULL);\n-            }\n-        }\n-    }\n-    for (i = 0; i < nbchild; i++) {\n-        if (list[i] != NULL)\n-            xmlFree(list[i]);\n-    }\n-\n-    xmlFree(list);\n-    def->dflags |= IS_PROCESSED;\n-}\n-\n-\/**\n- * xmlRelaxNGComputeInterleaves:\n- * @def:  the interleave definition\n- * @ctxt:  a Relax-NG parser context\n- * @name:  the definition name\n- *\n- * A lot of work for preprocessing interleave definitions\n- * is potentially needed to get a decent execution speed at runtime\n- *   - trying to get a total order on the element nodes generated\n- *     by the interleaves, order the list of interleave definitions\n- *     following that order.\n- *   - if <text\/> is used to handle mixed content, it is better to\n- *     flag this in the define and simplify the runtime checking\n- *     algorithm\n- *\/\n-static void\n-xmlRelaxNGComputeInterleaves(void *payload, void *data,\n-                             const xmlChar * name ATTRIBUTE_UNUSED)\n-{\n-    xmlRelaxNGDefinePtr def = (xmlRelaxNGDefinePtr) payload;\n-    xmlRelaxNGParserCtxtPtr ctxt = (xmlRelaxNGParserCtxtPtr) data;\n-    xmlRelaxNGDefinePtr cur, *tmp;\n-\n-    xmlRelaxNGPartitionPtr partitions = NULL;\n-    xmlRelaxNGInterleaveGroupPtr *groups = NULL;\n-    xmlRelaxNGInterleaveGroupPtr group;\n-    int i, j, ret, res;\n-    int nbgroups = 0;\n-    int nbchild = 0;\n-    int is_mixed = 0;\n-    int is_determinist = 1;\n-\n-    \/*\n-     * Don't run that check in case of error. Infinite recursion\n-     * becomes possible.\n-     *\/\n-    if (ctxt->nbErrors != 0)\n-        return;\n-\n-    cur = def->content;\n-    while (cur != NULL) {\n-        nbchild++;\n-        cur = cur->next;\n-    }\n-\n-    groups = (xmlRelaxNGInterleaveGroupPtr *)\n-        xmlMalloc(nbchild * sizeof(xmlRelaxNGInterleaveGroupPtr));\n-    if (groups == NULL)\n-        goto error;\n-    cur = def->content;\n-    while (cur != NULL) {\n-        groups[nbgroups] = (xmlRelaxNGInterleaveGroupPtr)\n-            xmlMalloc(sizeof(xmlRelaxNGInterleaveGroup));\n-        if (groups[nbgroups] == NULL)\n-            goto error;\n-        if (cur->type == XML_RELAXNG_TEXT)\n-            is_mixed++;\n-        groups[nbgroups]->rule = cur;\n-        groups[nbgroups]->defs = xmlRelaxNGGetElements(ctxt, cur, 2);\n-        groups[nbgroups]->attrs = xmlRelaxNGGetElements(ctxt, cur, 1);\n-        nbgroups++;\n-        cur = cur->next;\n-    }\n-\n-    \/*\n-     * Let's check that all rules makes a partitions according to 7.4\n-     *\/\n-    partitions = (xmlRelaxNGPartitionPtr)\n-        xmlMalloc(sizeof(xmlRelaxNGPartition));\n-    if (partitions == NULL)\n-        goto error;\n-    memset(partitions, 0, sizeof(xmlRelaxNGPartition));\n-    partitions->nbgroups = nbgroups;\n-    partitions->triage = xmlHashCreate(nbgroups);\n-    for (i = 0; i < nbgroups; i++) {\n-        group = groups[i];\n-        for (j = i + 1; j < nbgroups; j++) {\n-            if (groups[j] == NULL)\n-                continue;\n-\n-            ret = xmlRelaxNGCompareElemDefLists(ctxt, group->defs,\n-                                                groups[j]->defs);\n-            if (ret == 0) {\n-                xmlRngPErr(ctxt, def->node, XML_RNGP_ELEM_TEXT_CONFLICT,\n-                           \"Element or text conflicts in interleave\\n\",\n-                           NULL, NULL);\n-            }\n-            ret = xmlRelaxNGCompareElemDefLists(ctxt, group->attrs,\n-                                                groups[j]->attrs);\n-            if (ret == 0) {\n-                xmlRngPErr(ctxt, def->node, XML_RNGP_ATTR_CONFLICT,\n-                           \"Attributes conflicts in interleave\\n\", NULL,\n-                           NULL);\n-            }\n-        }\n-        tmp = group->defs;\n-        if ((tmp != NULL) && (*tmp != NULL)) {\n-            while (*tmp != NULL) {\n-                if ((*tmp)->type == XML_RELAXNG_TEXT) {\n-                    res = xmlHashAddEntry2(partitions->triage,\n-                                           BAD_CAST \"#text\", NULL,\n-                                           (void *) (ptrdiff_t) (i + 1));\n-                    if (res != 0)\n-                        is_determinist = -1;\n-                } else if (((*tmp)->type == XML_RELAXNG_ELEMENT) &&\n-                           ((*tmp)->name != NULL)) {\n-                    if (((*tmp)->ns == NULL) || ((*tmp)->ns[0] == 0))\n-                        res = xmlHashAddEntry2(partitions->triage,\n-                                               (*tmp)->name, NULL,\n-                                               (void *) (ptrdiff_t) (i + 1));\n-                    else\n-                        res = xmlHashAddEntry2(partitions->triage,\n-                                               (*tmp)->name, (*tmp)->ns,\n-                                               (void *) (ptrdiff_t) (i + 1));\n-                    if (res != 0)\n-                        is_determinist = -1;\n-                } else if ((*tmp)->type == XML_RELAXNG_ELEMENT) {\n-                    if (((*tmp)->ns == NULL) || ((*tmp)->ns[0] == 0))\n-                        res = xmlHashAddEntry2(partitions->triage,\n-                                               BAD_CAST \"#any\", NULL,\n-                                               (void *) (ptrdiff_t) (i + 1));\n-                    else\n-                        res = xmlHashAddEntry2(partitions->triage,\n-                                               BAD_CAST \"#any\", (*tmp)->ns,\n-                                               (void *) (ptrdiff_t) (i + 1));\n-                    if ((*tmp)->nameClass != NULL)\n-                        is_determinist = 2;\n-                    if (res != 0)\n-                        is_determinist = -1;\n-                } else {\n-                    is_determinist = -1;\n-                }\n-                tmp++;\n-            }\n-        } else {\n-            is_determinist = 0;\n-        }\n-    }\n-    partitions->groups = groups;\n-\n-    \/*\n-     * and save the partition list back in the def\n-     *\/\n-    def->data = partitions;\n-    if (is_mixed != 0)\n-        def->dflags |= IS_MIXED;\n-    if (is_determinist == 1)\n-        partitions->flags = IS_DETERMINIST;\n-    if (is_determinist == 2)\n-        partitions->flags = IS_DETERMINIST | IS_NEEDCHECK;\n-    return;\n-\n-  error:\n-    xmlRngPErrMemory(ctxt);\n-    if (groups != NULL) {\n-        for (i = 0; i < nbgroups; i++)\n-            if (groups[i] != NULL) {\n-                if (groups[i]->defs != NULL)\n-                    xmlFree(groups[i]->defs);\n-                xmlFree(groups[i]);\n-            }\n-        xmlFree(groups);\n-    }\n-    xmlRelaxNGFreePartition(partitions);\n-}\n-\n-\/**\n- * xmlRelaxNGParseInterleave:\n- * @ctxt:  a Relax-NG parser context\n- * @node:  the data node.\n- *\n- * parse the content of a RelaxNG interleave node.\n- *\n- * Returns the definition pointer or NULL in case of error\n- *\/\n-static xmlRelaxNGDefinePtr\n-xmlRelaxNGParseInterleave(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlRelaxNGDefinePtr def = NULL;\n-    xmlRelaxNGDefinePtr last = NULL, cur;\n-    xmlNodePtr child;\n-\n-    def = xmlRelaxNGNewDefine(ctxt, node);\n-    if (def == NULL) {\n-        return (NULL);\n-    }\n-    def->type = XML_RELAXNG_INTERLEAVE;\n-\n-    if (ctxt->interleaves == NULL)\n-        ctxt->interleaves = xmlHashCreate(10);\n-    if (ctxt->interleaves == NULL) {\n-        xmlRngPErrMemory(ctxt);\n-    } else {\n-        char name[32];\n-\n-        snprintf(name, 32, \"interleave%d\", ctxt->nbInterleaves++);\n-        if (xmlHashAddEntry(ctxt->interleaves, BAD_CAST name, def) < 0) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_INTERLEAVE_ADD,\n-                       \"Failed to add %s to hash table\\n\",\n-               (const xmlChar *) name, NULL);\n-        }\n-    }\n-    child = node->children;\n-    if (child == NULL) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_INTERLEAVE_NO_CONTENT,\n-                   \"Element interleave is empty\\n\", NULL, NULL);\n-    }\n-    while (child != NULL) {\n-        if (IS_RELAXNG(child, \"element\")) {\n-            cur = xmlRelaxNGParseElement(ctxt, child);\n-        } else {\n-            cur = xmlRelaxNGParsePattern(ctxt, child);\n-        }\n-        if (cur != NULL) {\n-            cur->parent = def;\n-            if (last == NULL) {\n-                def->content = last = cur;\n-            } else {\n-                last->next = cur;\n-                last = cur;\n-            }\n-        }\n-        child = child->next;\n-    }\n-\n-    return (def);\n-}\n-\n-\/**\n- * xmlRelaxNGParseInclude:\n- * @ctxt:  a Relax-NG parser context\n- * @node:  the include node\n- *\n- * Integrate the content of an include node in the current grammar\n- *\n- * Returns 0 in case of success or -1 in case of error\n- *\/\n-static int\n-xmlRelaxNGParseInclude(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlRelaxNGIncludePtr incl;\n-    xmlNodePtr root;\n-    int ret = 0, tmp;\n-\n-    incl = node->psvi;\n-    if (incl == NULL) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_INCLUDE_EMPTY,\n-                   \"Include node has no data\\n\", NULL, NULL);\n-        return (-1);\n-    }\n-    root = xmlDocGetRootElement(incl->doc);\n-    if (root == NULL) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_EMPTY, \"Include document is empty\\n\",\n-                   NULL, NULL);\n-        return (-1);\n-    }\n-    if (!xmlStrEqual(root->name, BAD_CAST \"grammar\")) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_GRAMMAR_MISSING,\n-                   \"Include document root is not a grammar\\n\", NULL, NULL);\n-        return (-1);\n-    }\n-\n-    \/*\n-     * Merge the definition from both the include and the internal list\n-     *\/\n-    if (root->children != NULL) {\n-        tmp = xmlRelaxNGParseGrammarContent(ctxt, root->children);\n-        if (tmp != 0)\n-            ret = -1;\n-    }\n-    if (node->children != NULL) {\n-        tmp = xmlRelaxNGParseGrammarContent(ctxt, node->children);\n-        if (tmp != 0)\n-            ret = -1;\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGParseDefine:\n- * @ctxt:  a Relax-NG parser context\n- * @node:  the define node\n- *\n- * parse the content of a RelaxNG define element node.\n- *\n- * Returns 0 in case of success or -1 in case of error\n- *\/\n-static int\n-xmlRelaxNGParseDefine(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlChar *name;\n-    int ret = 0, tmp;\n-    xmlRelaxNGDefinePtr def;\n-    const xmlChar *olddefine;\n-\n-    name = xmlGetProp(node, BAD_CAST \"name\");\n-    if (name == NULL) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_DEFINE_NAME_MISSING,\n-                   \"define has no name\\n\", NULL, NULL);\n-    } else {\n-        xmlRelaxNGNormExtSpace(name);\n-        if (xmlValidateNCName(name, 0)) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_INVALID_DEFINE_NAME,\n-                       \"define name '%s' is not an NCName\\n\", name, NULL);\n-        }\n-        def = xmlRelaxNGNewDefine(ctxt, node);\n-        if (def == NULL) {\n-            xmlFree(name);\n-            return (-1);\n-        }\n-        def->type = XML_RELAXNG_DEF;\n-        def->name = name;\n-        if (node->children == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_DEFINE_EMPTY,\n-                       \"define has no children\\n\", NULL, NULL);\n-        } else {\n-            olddefine = ctxt->define;\n-            ctxt->define = name;\n-            def->content =\n-                xmlRelaxNGParsePatterns(ctxt, node->children, 0);\n-            ctxt->define = olddefine;\n-        }\n-        if (ctxt->grammar->defs == NULL)\n-            ctxt->grammar->defs = xmlHashCreate(10);\n-        if (ctxt->grammar->defs == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_DEFINE_CREATE_FAILED,\n-                       \"Could not create definition hash\\n\", NULL, NULL);\n-            ret = -1;\n-        } else {\n-            tmp = xmlHashAddEntry(ctxt->grammar->defs, name, def);\n-            if (tmp < 0) {\n-                xmlRelaxNGDefinePtr prev;\n-\n-                prev = xmlHashLookup(ctxt->grammar->defs, name);\n-                if (prev == NULL) {\n-                    xmlRngPErr(ctxt, node, XML_RNGP_DEFINE_CREATE_FAILED,\n-                               \"Internal error on define aggregation of %s\\n\",\n-                               name, NULL);\n-                    ret = -1;\n-                } else {\n-                    while (prev->nextHash != NULL)\n-                        prev = prev->nextHash;\n-                    prev->nextHash = def;\n-                }\n-            }\n-        }\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGParseImportRef:\n- * @payload: the parser context\n- * @data: the current grammar\n- * @name: the reference name\n- *\n- * Import import one references into the current grammar\n- *\/\n-static void\n-xmlRelaxNGParseImportRef(void *payload, void *data, const xmlChar *name) {\n-    xmlRelaxNGParserCtxtPtr ctxt = (xmlRelaxNGParserCtxtPtr) data;\n-    xmlRelaxNGDefinePtr def = (xmlRelaxNGDefinePtr) payload;\n-    int tmp;\n-\n-    def->dflags |= IS_EXTERNAL_REF;\n-\n-    tmp = xmlHashAddEntry(ctxt->grammar->refs, name, def);\n-    if (tmp < 0) {\n-        xmlRelaxNGDefinePtr prev;\n-\n-        prev = (xmlRelaxNGDefinePtr)\n-            xmlHashLookup(ctxt->grammar->refs, def->name);\n-        if (prev == NULL) {\n-            if (def->name != NULL) {\n-                xmlRngPErr(ctxt, NULL, XML_RNGP_REF_CREATE_FAILED,\n-                           \"Error refs definitions '%s'\\n\",\n-                           def->name, NULL);\n-            } else {\n-                xmlRngPErr(ctxt, NULL, XML_RNGP_REF_CREATE_FAILED,\n-                           \"Error refs definitions\\n\",\n-                           NULL, NULL);\n-            }\n-        } else {\n-            def->nextHash = prev->nextHash;\n-            prev->nextHash = def;\n-        }\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGParseImportRefs:\n- * @ctxt: the parser context\n- * @grammar: the sub grammar\n- *\n- * Import references from the subgrammar into the current grammar\n- *\n- * Returns 0 in case of success, -1 in case of failure\n- *\/\n-static int\n-xmlRelaxNGParseImportRefs(xmlRelaxNGParserCtxtPtr ctxt,\n-                          xmlRelaxNGGrammarPtr grammar) {\n-    if ((ctxt == NULL) || (grammar == NULL) || (ctxt->grammar == NULL))\n-        return(-1);\n-    if (grammar->refs == NULL)\n-        return(0);\n-    if (ctxt->grammar->refs == NULL)\n-        ctxt->grammar->refs = xmlHashCreate(10);\n-    if (ctxt->grammar->refs == NULL) {\n-        xmlRngPErr(ctxt, NULL, XML_RNGP_REF_CREATE_FAILED,\n-                   \"Could not create references hash\\n\", NULL, NULL);\n-        return(-1);\n-    }\n-    xmlHashScan(grammar->refs, xmlRelaxNGParseImportRef, ctxt);\n-    return(0);\n-}\n-\n-\/**\n- * xmlRelaxNGProcessExternalRef:\n- * @ctxt: the parser context\n- * @node:  the externalRef node\n- *\n- * Process and compile an externalRef node\n- *\n- * Returns the xmlRelaxNGDefinePtr or NULL in case of error\n- *\/\n-static xmlRelaxNGDefinePtr\n-xmlRelaxNGProcessExternalRef(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlRelaxNGDocumentPtr docu;\n-    xmlNodePtr root, tmp;\n-    xmlChar *ns;\n-    int newNs = 0, oldflags;\n-    xmlRelaxNGDefinePtr def;\n-\n-    docu = node->psvi;\n-    if (docu != NULL) {\n-        def = xmlRelaxNGNewDefine(ctxt, node);\n-        if (def == NULL)\n-            return (NULL);\n-        def->type = XML_RELAXNG_EXTERNALREF;\n-\n-        if (docu->content == NULL) {\n-            \/*\n-             * Then do the parsing for good\n-             *\/\n-            root = xmlDocGetRootElement(docu->doc);\n-            if (root == NULL) {\n-                xmlRngPErr(ctxt, node, XML_RNGP_EXTERNALREF_EMTPY,\n-                           \"xmlRelaxNGParse: %s is empty\\n\", ctxt->URL,\n-                           NULL);\n-                return (NULL);\n-            }\n-            \/*\n-             * ns transmission rules\n-             *\/\n-            ns = xmlGetProp(root, BAD_CAST \"ns\");\n-            if (ns == NULL) {\n-                tmp = node;\n-                while ((tmp != NULL) && (tmp->type == XML_ELEMENT_NODE)) {\n-                    ns = xmlGetProp(tmp, BAD_CAST \"ns\");\n-                    if (ns != NULL) {\n-                        break;\n-                    }\n-                    tmp = tmp->parent;\n-                }\n-                if (ns != NULL) {\n-                    xmlSetProp(root, BAD_CAST \"ns\", ns);\n-                    newNs = 1;\n-                    xmlFree(ns);\n-                }\n-            } else {\n-                xmlFree(ns);\n-            }\n-\n-            \/*\n-             * Parsing to get a precompiled schemas.\n-             *\/\n-            oldflags = ctxt->flags;\n-            ctxt->flags |= XML_RELAXNG_IN_EXTERNALREF;\n-            docu->schema = xmlRelaxNGParseDocument(ctxt, root);\n-            ctxt->flags = oldflags;\n-            if ((docu->schema != NULL) &&\n-                (docu->schema->topgrammar != NULL)) {\n-                docu->content = docu->schema->topgrammar->start;\n-                if (docu->schema->topgrammar->refs)\n-                    xmlRelaxNGParseImportRefs(ctxt, docu->schema->topgrammar);\n-            }\n-\n-            \/*\n-             * the externalRef may be reused in a different ns context\n-             *\/\n-            if (newNs == 1) {\n-                xmlUnsetProp(root, BAD_CAST \"ns\");\n-            }\n-        }\n-        def->content = docu->content;\n-    } else {\n-        def = NULL;\n-    }\n-    return (def);\n-}\n-\n-\/**\n- * xmlRelaxNGParsePattern:\n- * @ctxt:  a Relax-NG parser context\n- * @node:  the pattern node.\n- *\n- * parse the content of a RelaxNG pattern node.\n- *\n- * Returns the definition pointer or NULL in case of error or if no\n- *     pattern is generated.\n- *\/\n-static xmlRelaxNGDefinePtr\n-xmlRelaxNGParsePattern(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlRelaxNGDefinePtr def = NULL;\n-\n-    if (node == NULL) {\n-        return (NULL);\n-    }\n-    if (IS_RELAXNG(node, \"element\")) {\n-        def = xmlRelaxNGParseElement(ctxt, node);\n-    } else if (IS_RELAXNG(node, \"attribute\")) {\n-        def = xmlRelaxNGParseAttribute(ctxt, node);\n-    } else if (IS_RELAXNG(node, \"empty\")) {\n-        def = xmlRelaxNGNewDefine(ctxt, node);\n-        if (def == NULL)\n-            return (NULL);\n-        def->type = XML_RELAXNG_EMPTY;\n-        if (node->children != NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_NOT_EMPTY,\n-                       \"empty: had a child node\\n\", NULL, NULL);\n-        }\n-    } else if (IS_RELAXNG(node, \"text\")) {\n-        def = xmlRelaxNGNewDefine(ctxt, node);\n-        if (def == NULL)\n-            return (NULL);\n-        def->type = XML_RELAXNG_TEXT;\n-        if (node->children != NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_TEXT_HAS_CHILD,\n-                       \"text: had a child node\\n\", NULL, NULL);\n-        }\n-    } else if (IS_RELAXNG(node, \"zeroOrMore\")) {\n-        def = xmlRelaxNGNewDefine(ctxt, node);\n-        if (def == NULL)\n-            return (NULL);\n-        def->type = XML_RELAXNG_ZEROORMORE;\n-        if (node->children == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_CONSTRUCT,\n-                       \"Element %s is empty\\n\", node->name, NULL);\n-        } else {\n-            def->content =\n-                xmlRelaxNGParsePatterns(ctxt, node->children, 1);\n-        }\n-    } else if (IS_RELAXNG(node, \"oneOrMore\")) {\n-        def = xmlRelaxNGNewDefine(ctxt, node);\n-        if (def == NULL)\n-            return (NULL);\n-        def->type = XML_RELAXNG_ONEORMORE;\n-        if (node->children == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_CONSTRUCT,\n-                       \"Element %s is empty\\n\", node->name, NULL);\n-        } else {\n-            def->content =\n-                xmlRelaxNGParsePatterns(ctxt, node->children, 1);\n-        }\n-    } else if (IS_RELAXNG(node, \"optional\")) {\n-        def = xmlRelaxNGNewDefine(ctxt, node);\n-        if (def == NULL)\n-            return (NULL);\n-        def->type = XML_RELAXNG_OPTIONAL;\n-        if (node->children == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_CONSTRUCT,\n-                       \"Element %s is empty\\n\", node->name, NULL);\n-        } else {\n-            def->content =\n-                xmlRelaxNGParsePatterns(ctxt, node->children, 1);\n-        }\n-    } else if (IS_RELAXNG(node, \"choice\")) {\n-        def = xmlRelaxNGNewDefine(ctxt, node);\n-        if (def == NULL)\n-            return (NULL);\n-        def->type = XML_RELAXNG_CHOICE;\n-        if (node->children == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_CONSTRUCT,\n-                       \"Element %s is empty\\n\", node->name, NULL);\n-        } else {\n-            def->content =\n-                xmlRelaxNGParsePatterns(ctxt, node->children, 0);\n-        }\n-    } else if (IS_RELAXNG(node, \"group\")) {\n-        def = xmlRelaxNGNewDefine(ctxt, node);\n-        if (def == NULL)\n-            return (NULL);\n-        def->type = XML_RELAXNG_GROUP;\n-        if (node->children == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_CONSTRUCT,\n-                       \"Element %s is empty\\n\", node->name, NULL);\n-        } else {\n-            def->content =\n-                xmlRelaxNGParsePatterns(ctxt, node->children, 0);\n-        }\n-    } else if (IS_RELAXNG(node, \"ref\")) {\n-        def = xmlRelaxNGNewDefine(ctxt, node);\n-        if (def == NULL)\n-            return (NULL);\n-        def->type = XML_RELAXNG_REF;\n-        def->name = xmlGetProp(node, BAD_CAST \"name\");\n-        if (def->name == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_REF_NO_NAME, \"ref has no name\\n\",\n-                       NULL, NULL);\n-        } else {\n-            xmlRelaxNGNormExtSpace(def->name);\n-            if (xmlValidateNCName(def->name, 0)) {\n-                xmlRngPErr(ctxt, node, XML_RNGP_REF_NAME_INVALID,\n-                           \"ref name '%s' is not an NCName\\n\", def->name,\n-                           NULL);\n-            }\n-        }\n-        if (node->children != NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_REF_NOT_EMPTY, \"ref is not empty\\n\",\n-                       NULL, NULL);\n-        }\n-        if (ctxt->grammar->refs == NULL)\n-            ctxt->grammar->refs = xmlHashCreate(10);\n-        if (ctxt->grammar->refs == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_REF_CREATE_FAILED,\n-                       \"Could not create references hash\\n\", NULL, NULL);\n-            def = NULL;\n-        } else {\n-            int tmp;\n-\n-            tmp = xmlHashAddEntry(ctxt->grammar->refs, def->name, def);\n-            if (tmp < 0) {\n-                xmlRelaxNGDefinePtr prev;\n-\n-                prev = (xmlRelaxNGDefinePtr)\n-                    xmlHashLookup(ctxt->grammar->refs, def->name);\n-                if (prev == NULL) {\n-                    if (def->name != NULL) {\n-                xmlRngPErr(ctxt, node, XML_RNGP_REF_CREATE_FAILED,\n-                   \"Error refs definitions '%s'\\n\",\n-                   def->name, NULL);\n-                    } else {\n-                xmlRngPErr(ctxt, node, XML_RNGP_REF_CREATE_FAILED,\n-                   \"Error refs definitions\\n\",\n-                   NULL, NULL);\n-                    }\n-                    def = NULL;\n-                } else {\n-                    def->nextHash = prev->nextHash;\n-                    prev->nextHash = def;\n-                }\n-            }\n-        }\n-    } else if (IS_RELAXNG(node, \"data\")) {\n-        def = xmlRelaxNGParseData(ctxt, node);\n-    } else if (IS_RELAXNG(node, \"value\")) {\n-        def = xmlRelaxNGParseValue(ctxt, node);\n-    } else if (IS_RELAXNG(node, \"list\")) {\n-        def = xmlRelaxNGNewDefine(ctxt, node);\n-        if (def == NULL)\n-            return (NULL);\n-        def->type = XML_RELAXNG_LIST;\n-        if (node->children == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_CONSTRUCT,\n-                       \"Element %s is empty\\n\", node->name, NULL);\n-        } else {\n-            def->content =\n-                xmlRelaxNGParsePatterns(ctxt, node->children, 0);\n-        }\n-    } else if (IS_RELAXNG(node, \"interleave\")) {\n-        def = xmlRelaxNGParseInterleave(ctxt, node);\n-    } else if (IS_RELAXNG(node, \"externalRef\")) {\n-        def = xmlRelaxNGProcessExternalRef(ctxt, node);\n-    } else if (IS_RELAXNG(node, \"notAllowed\")) {\n-        def = xmlRelaxNGNewDefine(ctxt, node);\n-        if (def == NULL)\n-            return (NULL);\n-        def->type = XML_RELAXNG_NOT_ALLOWED;\n-        if (node->children != NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_NOTALLOWED_NOT_EMPTY,\n-                       \"xmlRelaxNGParse: notAllowed element is not empty\\n\",\n-                       NULL, NULL);\n-        }\n-    } else if (IS_RELAXNG(node, \"grammar\")) {\n-        xmlRelaxNGGrammarPtr grammar, old;\n-        xmlRelaxNGGrammarPtr oldparent;\n-\n-        oldparent = ctxt->parentgrammar;\n-        old = ctxt->grammar;\n-        ctxt->parentgrammar = old;\n-        grammar = xmlRelaxNGParseGrammar(ctxt, node->children);\n-        if (old != NULL) {\n-            ctxt->grammar = old;\n-            ctxt->parentgrammar = oldparent;\n-#if 0\n-            if (grammar != NULL) {\n-                grammar->next = old->next;\n-                old->next = grammar;\n-            }\n-#endif\n-        }\n-        if (grammar != NULL)\n-            def = grammar->start;\n-        else\n-            def = NULL;\n-    } else if (IS_RELAXNG(node, \"parentRef\")) {\n-        if (ctxt->parentgrammar == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_PARENTREF_NO_PARENT,\n-                       \"Use of parentRef without a parent grammar\\n\", NULL,\n-                       NULL);\n-            return (NULL);\n-        }\n-        def = xmlRelaxNGNewDefine(ctxt, node);\n-        if (def == NULL)\n-            return (NULL);\n-        def->type = XML_RELAXNG_PARENTREF;\n-        def->name = xmlGetProp(node, BAD_CAST \"name\");\n-        if (def->name == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_PARENTREF_NO_NAME,\n-                       \"parentRef has no name\\n\", NULL, NULL);\n-        } else {\n-            xmlRelaxNGNormExtSpace(def->name);\n-            if (xmlValidateNCName(def->name, 0)) {\n-                xmlRngPErr(ctxt, node, XML_RNGP_PARENTREF_NAME_INVALID,\n-                           \"parentRef name '%s' is not an NCName\\n\",\n-                           def->name, NULL);\n-            }\n-        }\n-        if (node->children != NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_PARENTREF_NOT_EMPTY,\n-                       \"parentRef is not empty\\n\", NULL, NULL);\n-        }\n-        if (ctxt->parentgrammar->refs == NULL)\n-            ctxt->parentgrammar->refs = xmlHashCreate(10);\n-        if (ctxt->parentgrammar->refs == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_PARENTREF_CREATE_FAILED,\n-                       \"Could not create references hash\\n\", NULL, NULL);\n-            def = NULL;\n-        } else if (def->name != NULL) {\n-            int tmp;\n-\n-            tmp =\n-                xmlHashAddEntry(ctxt->parentgrammar->refs, def->name, def);\n-            if (tmp < 0) {\n-                xmlRelaxNGDefinePtr prev;\n-\n-                prev = (xmlRelaxNGDefinePtr)\n-                    xmlHashLookup(ctxt->parentgrammar->refs, def->name);\n-                if (prev == NULL) {\n-                    xmlRngPErr(ctxt, node, XML_RNGP_PARENTREF_CREATE_FAILED,\n-                               \"Internal error parentRef definitions '%s'\\n\",\n-                               def->name, NULL);\n-                    def = NULL;\n-                } else {\n-                    def->nextHash = prev->nextHash;\n-                    prev->nextHash = def;\n-                }\n-            }\n-        }\n-    } else if (IS_RELAXNG(node, \"mixed\")) {\n-        if (node->children == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_EMPTY_CONSTRUCT, \"Mixed is empty\\n\",\n-                       NULL, NULL);\n-            def = NULL;\n-        } else {\n-            def = xmlRelaxNGParseInterleave(ctxt, node);\n-            if (def != NULL) {\n-                xmlRelaxNGDefinePtr tmp;\n-\n-                if ((def->content != NULL) && (def->content->next != NULL)) {\n-                    tmp = xmlRelaxNGNewDefine(ctxt, node);\n-                    if (tmp != NULL) {\n-                        tmp->type = XML_RELAXNG_GROUP;\n-                        tmp->content = def->content;\n-                        def->content = tmp;\n-                    }\n-                }\n-\n-                tmp = xmlRelaxNGNewDefine(ctxt, node);\n-                if (tmp == NULL)\n-                    return (def);\n-                tmp->type = XML_RELAXNG_TEXT;\n-                tmp->next = def->content;\n-                def->content = tmp;\n-            }\n-        }\n-    } else {\n-        xmlRngPErr(ctxt, node, XML_RNGP_UNKNOWN_CONSTRUCT,\n-                   \"Unexpected node %s is not a pattern\\n\", node->name,\n-                   NULL);\n-        def = NULL;\n-    }\n-    return (def);\n-}\n-\n-\/**\n- * xmlRelaxNGParseAttribute:\n- * @ctxt:  a Relax-NG parser context\n- * @node:  the element node\n- *\n- * parse the content of a RelaxNG attribute node.\n- *\n- * Returns the definition pointer or NULL in case of error.\n- *\/\n-static xmlRelaxNGDefinePtr\n-xmlRelaxNGParseAttribute(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlRelaxNGDefinePtr ret, cur;\n-    xmlNodePtr child;\n-    int old_flags;\n-\n-    ret = xmlRelaxNGNewDefine(ctxt, node);\n-    if (ret == NULL)\n-        return (NULL);\n-    ret->type = XML_RELAXNG_ATTRIBUTE;\n-    ret->parent = ctxt->def;\n-    child = node->children;\n-    if (child == NULL) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_ATTRIBUTE_EMPTY,\n-                   \"xmlRelaxNGParseattribute: attribute has no children\\n\",\n-                   NULL, NULL);\n-        return (ret);\n-    }\n-    old_flags = ctxt->flags;\n-    ctxt->flags |= XML_RELAXNG_IN_ATTRIBUTE;\n-    cur = xmlRelaxNGParseNameClass(ctxt, child, ret);\n-    if (cur != NULL)\n-        child = child->next;\n-\n-    if (child != NULL) {\n-        cur = xmlRelaxNGParsePattern(ctxt, child);\n-        if (cur != NULL) {\n-            switch (cur->type) {\n-                case XML_RELAXNG_EMPTY:\n-                case XML_RELAXNG_NOT_ALLOWED:\n-                case XML_RELAXNG_TEXT:\n-                case XML_RELAXNG_ELEMENT:\n-                case XML_RELAXNG_DATATYPE:\n-                case XML_RELAXNG_VALUE:\n-                case XML_RELAXNG_LIST:\n-                case XML_RELAXNG_REF:\n-                case XML_RELAXNG_PARENTREF:\n-                case XML_RELAXNG_EXTERNALREF:\n-                case XML_RELAXNG_DEF:\n-                case XML_RELAXNG_ONEORMORE:\n-                case XML_RELAXNG_ZEROORMORE:\n-                case XML_RELAXNG_OPTIONAL:\n-                case XML_RELAXNG_CHOICE:\n-                case XML_RELAXNG_GROUP:\n-                case XML_RELAXNG_INTERLEAVE:\n-                case XML_RELAXNG_ATTRIBUTE:\n-                    ret->content = cur;\n-                    cur->parent = ret;\n-                    break;\n-                case XML_RELAXNG_START:\n-                case XML_RELAXNG_PARAM:\n-                case XML_RELAXNG_EXCEPT:\n-                    xmlRngPErr(ctxt, node, XML_RNGP_ATTRIBUTE_CONTENT,\n-                               \"attribute has invalid content\\n\", NULL,\n-                               NULL);\n-                    break;\n-                case XML_RELAXNG_NOOP:\n-                    xmlRngPErr(ctxt, node, XML_RNGP_ATTRIBUTE_NOOP,\n-                               \"RNG Internal error, noop found in attribute\\n\",\n-                               NULL, NULL);\n-                    break;\n-            }\n-        }\n-        child = child->next;\n-    }\n-    if (child != NULL) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_ATTRIBUTE_CHILDREN,\n-                   \"attribute has multiple children\\n\", NULL, NULL);\n-    }\n-    ctxt->flags = old_flags;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGParseExceptNameClass:\n- * @ctxt:  a Relax-NG parser context\n- * @node:  the except node\n- * @attr:  1 if within an attribute, 0 if within an element\n- *\n- * parse the content of a RelaxNG nameClass node.\n- *\n- * Returns the definition pointer or NULL in case of error.\n- *\/\n-static xmlRelaxNGDefinePtr\n-xmlRelaxNGParseExceptNameClass(xmlRelaxNGParserCtxtPtr ctxt,\n-                               xmlNodePtr node, int attr)\n-{\n-    xmlRelaxNGDefinePtr ret, cur, last = NULL;\n-    xmlNodePtr child;\n-\n-    if (!IS_RELAXNG(node, \"except\")) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_EXCEPT_MISSING,\n-                   \"Expecting an except node\\n\", NULL, NULL);\n-        return (NULL);\n-    }\n-    if (node->next != NULL) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_EXCEPT_MULTIPLE,\n-                   \"exceptNameClass allows only a single except node\\n\",\n-                   NULL, NULL);\n-    }\n-    if (node->children == NULL) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_EXCEPT_EMPTY, \"except has no content\\n\",\n-                   NULL, NULL);\n-        return (NULL);\n-    }\n-\n-    ret = xmlRelaxNGNewDefine(ctxt, node);\n-    if (ret == NULL)\n-        return (NULL);\n-    ret->type = XML_RELAXNG_EXCEPT;\n-    child = node->children;\n-    while (child != NULL) {\n-        cur = xmlRelaxNGNewDefine(ctxt, child);\n-        if (cur == NULL)\n-            break;\n-        if (attr)\n-            cur->type = XML_RELAXNG_ATTRIBUTE;\n-        else\n-            cur->type = XML_RELAXNG_ELEMENT;\n-\n-        if (xmlRelaxNGParseNameClass(ctxt, child, cur) != NULL) {\n-            if (last == NULL) {\n-                ret->content = cur;\n-            } else {\n-                last->next = cur;\n-            }\n-            last = cur;\n-        }\n-        child = child->next;\n-    }\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGParseNameClass:\n- * @ctxt:  a Relax-NG parser context\n- * @node:  the nameClass node\n- * @def:  the current definition\n- *\n- * parse the content of a RelaxNG nameClass node.\n- *\n- * Returns the definition pointer or NULL in case of error.\n- *\/\n-static xmlRelaxNGDefinePtr\n-xmlRelaxNGParseNameClass(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node,\n-                         xmlRelaxNGDefinePtr def)\n-{\n-    xmlRelaxNGDefinePtr ret, tmp;\n-    xmlChar *val;\n-\n-    ret = def;\n-    if ((IS_RELAXNG(node, \"name\")) || (IS_RELAXNG(node, \"anyName\")) ||\n-        (IS_RELAXNG(node, \"nsName\"))) {\n-        if ((def->type != XML_RELAXNG_ELEMENT) &&\n-            (def->type != XML_RELAXNG_ATTRIBUTE)) {\n-            ret = xmlRelaxNGNewDefine(ctxt, node);\n-            if (ret == NULL)\n-                return (NULL);\n-            ret->parent = def;\n-            if (ctxt->flags & XML_RELAXNG_IN_ATTRIBUTE)\n-                ret->type = XML_RELAXNG_ATTRIBUTE;\n-            else\n-                ret->type = XML_RELAXNG_ELEMENT;\n-        }\n-    }\n-    if (IS_RELAXNG(node, \"name\")) {\n-        val = xmlNodeGetContent(node);\n-        xmlRelaxNGNormExtSpace(val);\n-        if (xmlValidateNCName(val, 0)) {\n-        if (node->parent != NULL)\n-        xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_NAME,\n-               \"Element %s name '%s' is not an NCName\\n\",\n-               node->parent->name, val);\n-        else\n-        xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_NAME,\n-               \"name '%s' is not an NCName\\n\",\n-               val, NULL);\n-        }\n-        ret->name = val;\n-        val = xmlGetProp(node, BAD_CAST \"ns\");\n-        ret->ns = val;\n-        if ((ctxt->flags & XML_RELAXNG_IN_ATTRIBUTE) &&\n-            (val != NULL) &&\n-            (xmlStrEqual(val, BAD_CAST \"http:\/\/www.w3.org\/2000\/xmlns\"))) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_XML_NS,\n-                        \"Attribute with namespace '%s' is not allowed\\n\",\n-                        val, NULL);\n-        }\n-        if ((ctxt->flags & XML_RELAXNG_IN_ATTRIBUTE) &&\n-            (val != NULL) &&\n-            (val[0] == 0) && (xmlStrEqual(ret->name, BAD_CAST \"xmlns\"))) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_XMLNS_NAME,\n-                       \"Attribute with QName 'xmlns' is not allowed\\n\",\n-                       val, NULL);\n-        }\n-    } else if (IS_RELAXNG(node, \"anyName\")) {\n-        ret->name = NULL;\n-        ret->ns = NULL;\n-        if (node->children != NULL) {\n-            ret->nameClass =\n-                xmlRelaxNGParseExceptNameClass(ctxt, node->children,\n-                                               (def->type ==\n-                                                XML_RELAXNG_ATTRIBUTE));\n-        }\n-    } else if (IS_RELAXNG(node, \"nsName\")) {\n-        ret->name = NULL;\n-        ret->ns = xmlGetProp(node, BAD_CAST \"ns\");\n-        if (ret->ns == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_NSNAME_NO_NS,\n-                       \"nsName has no ns attribute\\n\", NULL, NULL);\n-        }\n-        if ((ctxt->flags & XML_RELAXNG_IN_ATTRIBUTE) &&\n-            (ret->ns != NULL) &&\n-            (xmlStrEqual\n-             (ret->ns, BAD_CAST \"http:\/\/www.w3.org\/2000\/xmlns\"))) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_XML_NS,\n-                       \"Attribute with namespace '%s' is not allowed\\n\",\n-                       ret->ns, NULL);\n-        }\n-        if (node->children != NULL) {\n-            ret->nameClass =\n-                xmlRelaxNGParseExceptNameClass(ctxt, node->children,\n-                                               (def->type ==\n-                                                XML_RELAXNG_ATTRIBUTE));\n-        }\n-    } else if (IS_RELAXNG(node, \"choice\")) {\n-        xmlNodePtr child;\n-        xmlRelaxNGDefinePtr last = NULL;\n-\n-        if (def->type == XML_RELAXNG_CHOICE) {\n-            ret = def;\n-        } else {\n-            ret = xmlRelaxNGNewDefine(ctxt, node);\n-            if (ret == NULL)\n-                return (NULL);\n-            ret->parent = def;\n-            ret->type = XML_RELAXNG_CHOICE;\n-        }\n-\n-        if (node->children == NULL) {\n-            xmlRngPErr(ctxt, node, XML_RNGP_CHOICE_EMPTY,\n-                       \"Element choice is empty\\n\", NULL, NULL);\n-        } else {\n-\n-            child = node->children;\n-            while (child != NULL) {\n-                tmp = xmlRelaxNGParseNameClass(ctxt, child, ret);\n-                if (tmp != NULL) {\n-                    if (last == NULL) {\n-                        last = tmp;\n-                    } else if (tmp != ret) {\n-                        last->next = tmp;\n-                        last = tmp;\n-                    }\n-                }\n-                child = child->next;\n-            }\n-        }\n-    } else {\n-        xmlRngPErr(ctxt, node, XML_RNGP_CHOICE_CONTENT,\n-                   \"expecting name, anyName, nsName or choice : got %s\\n\",\n-                   (node == NULL ? (const xmlChar *) \"nothing\" : node->name),\n-           NULL);\n-        return (NULL);\n-    }\n-    if (ret != def) {\n-        if (def->nameClass == NULL) {\n-            def->nameClass = ret;\n-        } else {\n-            tmp = def->nameClass;\n-            while (tmp->next != NULL) {\n-                tmp = tmp->next;\n-            }\n-            tmp->next = ret;\n-        }\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGParseElement:\n- * @ctxt:  a Relax-NG parser context\n- * @node:  the element node\n- *\n- * parse the content of a RelaxNG element node.\n- *\n- * Returns the definition pointer or NULL in case of error.\n- *\/\n-static xmlRelaxNGDefinePtr\n-xmlRelaxNGParseElement(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlRelaxNGDefinePtr ret, cur, last;\n-    xmlNodePtr child;\n-    const xmlChar *olddefine;\n-\n-    ret = xmlRelaxNGNewDefine(ctxt, node);\n-    if (ret == NULL)\n-        return (NULL);\n-    ret->type = XML_RELAXNG_ELEMENT;\n-    ret->parent = ctxt->def;\n-    child = node->children;\n-    if (child == NULL) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_EMPTY,\n-                   \"xmlRelaxNGParseElement: element has no children\\n\",\n-                   NULL, NULL);\n-        return (ret);\n-    }\n-    cur = xmlRelaxNGParseNameClass(ctxt, child, ret);\n-    if (cur != NULL)\n-        child = child->next;\n-\n-    if (child == NULL) {\n-        xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_NO_CONTENT,\n-                   \"xmlRelaxNGParseElement: element has no content\\n\",\n-                   NULL, NULL);\n-        return (ret);\n-    }\n-    olddefine = ctxt->define;\n-    ctxt->define = NULL;\n-    last = NULL;\n-    while (child != NULL) {\n-        cur = xmlRelaxNGParsePattern(ctxt, child);\n-        if (cur != NULL) {\n-            cur->parent = ret;\n-            switch (cur->type) {\n-                case XML_RELAXNG_EMPTY:\n-                case XML_RELAXNG_NOT_ALLOWED:\n-                case XML_RELAXNG_TEXT:\n-                case XML_RELAXNG_ELEMENT:\n-                case XML_RELAXNG_DATATYPE:\n-                case XML_RELAXNG_VALUE:\n-                case XML_RELAXNG_LIST:\n-                case XML_RELAXNG_REF:\n-                case XML_RELAXNG_PARENTREF:\n-                case XML_RELAXNG_EXTERNALREF:\n-                case XML_RELAXNG_DEF:\n-                case XML_RELAXNG_ZEROORMORE:\n-                case XML_RELAXNG_ONEORMORE:\n-                case XML_RELAXNG_OPTIONAL:\n-                case XML_RELAXNG_CHOICE:\n-                case XML_RELAXNG_GROUP:\n-                case XML_RELAXNG_INTERLEAVE:\n-                    if (last == NULL) {\n-                        ret->content = last = cur;\n-                    } else {\n-                        if ((last->type == XML_RELAXNG_ELEMENT) &&\n-                            (ret->content == last)) {\n-                            ret->content = xmlRelaxNGNewDefine(ctxt, node);\n-                            if (ret->content != NULL) {\n-                                ret->content->type = XML_RELAXNG_GROUP;\n-                                ret->content->content = last;\n-                            } else {\n-                                ret->content = last;\n-                            }\n-                        }\n-                        last->next = cur;\n-                        last = cur;\n-                    }\n-                    break;\n-                case XML_RELAXNG_ATTRIBUTE:\n-                    cur->next = ret->attrs;\n-                    ret->attrs = cur;\n-                    break;\n-                case XML_RELAXNG_START:\n-                    xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_CONTENT,\n-                               \"RNG Internal error, start found in element\\n\",\n-                               NULL, NULL);\n-                    break;\n-                case XML_RELAXNG_PARAM:\n-                    xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_CONTENT,\n-                               \"RNG Internal error, param found in element\\n\",\n-                               NULL, NULL);\n-                    break;\n-                case XML_RELAXNG_EXCEPT:\n-                    xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_CONTENT,\n-                               \"RNG Internal error, except found in element\\n\",\n-                               NULL, NULL);\n-                    break;\n-                case XML_RELAXNG_NOOP:\n-                    xmlRngPErr(ctxt, node, XML_RNGP_ELEMENT_CONTENT,\n-                               \"RNG Internal error, noop found in element\\n\",\n-                               NULL, NULL);\n-                    break;\n-            }\n-        }\n-        child = child->next;\n-    }\n-    ctxt->define = olddefine;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGParsePatterns:\n- * @ctxt:  a Relax-NG parser context\n- * @nodes:  list of nodes\n- * @group:  use an implicit <group> for elements\n- *\n- * parse the content of a RelaxNG start node.\n- *\n- * Returns the definition pointer or NULL in case of error.\n- *\/\n-static xmlRelaxNGDefinePtr\n-xmlRelaxNGParsePatterns(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr nodes,\n-                        int group)\n-{\n-    xmlRelaxNGDefinePtr def = NULL, last = NULL, cur, parent;\n-\n-    parent = ctxt->def;\n-    while (nodes != NULL) {\n-        if (IS_RELAXNG(nodes, \"element\")) {\n-            cur = xmlRelaxNGParseElement(ctxt, nodes);\n-            if (cur == NULL)\n-                return (NULL);\n-            if (def == NULL) {\n-                def = last = cur;\n-            } else {\n-                if ((group == 1) && (def->type == XML_RELAXNG_ELEMENT) &&\n-                    (def == last)) {\n-                    def = xmlRelaxNGNewDefine(ctxt, nodes);\n-                    if (def == NULL)\n-                        return (NULL);\n-                    def->type = XML_RELAXNG_GROUP;\n-                    def->content = last;\n-                }\n-                last->next = cur;\n-                last = cur;\n-            }\n-            cur->parent = parent;\n-        } else {\n-            cur = xmlRelaxNGParsePattern(ctxt, nodes);\n-            if (cur != NULL) {\n-                if (def == NULL) {\n-                    def = last = cur;\n-                } else {\n-                    last->next = cur;\n-                    last = cur;\n-                }\n-            }\n-        }\n-        nodes = nodes->next;\n-    }\n-    return (def);\n-}\n-\n-\/**\n- * xmlRelaxNGParseStart:\n- * @ctxt:  a Relax-NG parser context\n- * @nodes:  start children nodes\n- *\n- * parse the content of a RelaxNG start node.\n- *\n- * Returns 0 in case of success, -1 in case of error\n- *\/\n-static int\n-xmlRelaxNGParseStart(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr nodes)\n-{\n-    int ret = 0;\n-    xmlRelaxNGDefinePtr def = NULL, last;\n-\n-    if (nodes == NULL) {\n-        xmlRngPErr(ctxt, nodes, XML_RNGP_START_EMPTY, \"start has no children\\n\",\n-                   NULL, NULL);\n-        return (-1);\n-    }\n-    if (IS_RELAXNG(nodes, \"empty\")) {\n-        def = xmlRelaxNGNewDefine(ctxt, nodes);\n-        if (def == NULL)\n-            return (-1);\n-        def->type = XML_RELAXNG_EMPTY;\n-        if (nodes->children != NULL) {\n-            xmlRngPErr(ctxt, nodes, XML_RNGP_EMPTY_CONTENT,\n-                       \"element empty is not empty\\n\", NULL, NULL);\n-        }\n-    } else if (IS_RELAXNG(nodes, \"notAllowed\")) {\n-        def = xmlRelaxNGNewDefine(ctxt, nodes);\n-        if (def == NULL)\n-            return (-1);\n-        def->type = XML_RELAXNG_NOT_ALLOWED;\n-        if (nodes->children != NULL) {\n-            xmlRngPErr(ctxt, nodes, XML_RNGP_NOTALLOWED_NOT_EMPTY,\n-                       \"element notAllowed is not empty\\n\", NULL, NULL);\n-        }\n-    } else {\n-        def = xmlRelaxNGParsePatterns(ctxt, nodes, 1);\n-    }\n-    if (ctxt->grammar->start != NULL) {\n-        last = ctxt->grammar->start;\n-        while (last->next != NULL)\n-            last = last->next;\n-        last->next = def;\n-    } else {\n-        ctxt->grammar->start = def;\n-    }\n-    nodes = nodes->next;\n-    if (nodes != NULL) {\n-        xmlRngPErr(ctxt, nodes, XML_RNGP_START_CONTENT,\n-                   \"start more than one children\\n\", NULL, NULL);\n-        return (-1);\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGParseGrammarContent:\n- * @ctxt:  a Relax-NG parser context\n- * @nodes:  grammar children nodes\n- *\n- * parse the content of a RelaxNG grammar node.\n- *\n- * Returns 0 in case of success, -1 in case of error\n- *\/\n-static int\n-xmlRelaxNGParseGrammarContent(xmlRelaxNGParserCtxtPtr ctxt,\n-                              xmlNodePtr nodes)\n-{\n-    int ret = 0, tmp;\n-\n-    if (nodes == NULL) {\n-        xmlRngPErr(ctxt, nodes, XML_RNGP_GRAMMAR_EMPTY,\n-                   \"grammar has no children\\n\", NULL, NULL);\n-        return (-1);\n-    }\n-    while (nodes != NULL) {\n-        if (IS_RELAXNG(nodes, \"start\")) {\n-            if (nodes->children == NULL) {\n-                xmlRngPErr(ctxt, nodes, XML_RNGP_START_EMPTY,\n-                           \"start has no children\\n\", NULL, NULL);\n-            } else {\n-                tmp = xmlRelaxNGParseStart(ctxt, nodes->children);\n-                if (tmp != 0)\n-                    ret = -1;\n-            }\n-        } else if (IS_RELAXNG(nodes, \"define\")) {\n-            tmp = xmlRelaxNGParseDefine(ctxt, nodes);\n-            if (tmp != 0)\n-                ret = -1;\n-        } else if (IS_RELAXNG(nodes, \"include\")) {\n-            tmp = xmlRelaxNGParseInclude(ctxt, nodes);\n-            if (tmp != 0)\n-                ret = -1;\n-        } else {\n-            xmlRngPErr(ctxt, nodes, XML_RNGP_GRAMMAR_CONTENT,\n-                       \"grammar has unexpected child %s\\n\", nodes->name,\n-                       NULL);\n-            ret = -1;\n-        }\n-        nodes = nodes->next;\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGCheckReference:\n- * @ref:  the ref\n- * @ctxt:  a Relax-NG parser context\n- * @name:  the name associated to the defines\n- *\n- * Applies the 4.17. combine attribute rule for all the define\n- * element of a given grammar using the same name.\n- *\/\n-static void\n-xmlRelaxNGCheckReference(void *payload, void *data, const xmlChar * name)\n-{\n-    xmlRelaxNGDefinePtr ref = (xmlRelaxNGDefinePtr) payload;\n-    xmlRelaxNGParserCtxtPtr ctxt = (xmlRelaxNGParserCtxtPtr) data;\n-    xmlRelaxNGGrammarPtr grammar;\n-    xmlRelaxNGDefinePtr def, cur;\n-\n-    \/*\n-     * Those rules don't apply to imported ref from xmlRelaxNGParseImportRef\n-     *\/\n-    if (ref->dflags & IS_EXTERNAL_REF)\n-        return;\n-\n-    grammar = ctxt->grammar;\n-    if (grammar == NULL) {\n-        xmlRngPErr(ctxt, ref->node, XML_ERR_INTERNAL_ERROR,\n-                   \"Internal error: no grammar in CheckReference %s\\n\",\n-                   name, NULL);\n-        return;\n-    }\n-    if (ref->content != NULL) {\n-        xmlRngPErr(ctxt, ref->node, XML_ERR_INTERNAL_ERROR,\n-                   \"Internal error: reference has content in CheckReference %s\\n\",\n-                   name, NULL);\n-        return;\n-    }\n-    if (grammar->defs != NULL) {\n-        def = xmlHashLookup(grammar->defs, name);\n-        if (def != NULL) {\n-            cur = ref;\n-            while (cur != NULL) {\n-                cur->content = def;\n-                cur = cur->nextHash;\n-            }\n-        } else {\n-            xmlRngPErr(ctxt, ref->node, XML_RNGP_REF_NO_DEF,\n-                       \"Reference %s has no matching definition\\n\", name,\n-                       NULL);\n-        }\n-    } else {\n-        xmlRngPErr(ctxt, ref->node, XML_RNGP_REF_NO_DEF,\n-                   \"Reference %s has no matching definition\\n\", name,\n-                   NULL);\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGCheckCombine:\n- * @define:  the define(s) list\n- * @ctxt:  a Relax-NG parser context\n- * @name:  the name associated to the defines\n- *\n- * Applies the 4.17. combine attribute rule for all the define\n- * element of a given grammar using the same name.\n- *\/\n-static void\n-xmlRelaxNGCheckCombine(void *payload, void *data, const xmlChar * name)\n-{\n-    xmlRelaxNGDefinePtr define = (xmlRelaxNGDefinePtr) payload;\n-    xmlRelaxNGParserCtxtPtr ctxt = (xmlRelaxNGParserCtxtPtr) data;\n-    xmlChar *combine;\n-    int choiceOrInterleave = -1;\n-    int missing = 0;\n-    xmlRelaxNGDefinePtr cur, last, tmp, tmp2;\n-\n-    if (define->nextHash == NULL)\n-        return;\n-    cur = define;\n-    while (cur != NULL) {\n-        combine = xmlGetProp(cur->node, BAD_CAST \"combine\");\n-        if (combine != NULL) {\n-            if (xmlStrEqual(combine, BAD_CAST \"choice\")) {\n-                if (choiceOrInterleave == -1)\n-                    choiceOrInterleave = 1;\n-                else if (choiceOrInterleave == 0) {\n-                    xmlRngPErr(ctxt, define->node, XML_RNGP_DEF_CHOICE_AND_INTERLEAVE,\n-                               \"Defines for %s use both 'choice' and 'interleave'\\n\",\n-                               name, NULL);\n-                }\n-            } else if (xmlStrEqual(combine, BAD_CAST \"interleave\")) {\n-                if (choiceOrInterleave == -1)\n-                    choiceOrInterleave = 0;\n-                else if (choiceOrInterleave == 1) {\n-                    xmlRngPErr(ctxt, define->node, XML_RNGP_DEF_CHOICE_AND_INTERLEAVE,\n-                               \"Defines for %s use both 'choice' and 'interleave'\\n\",\n-                               name, NULL);\n-                }\n-            } else {\n-                xmlRngPErr(ctxt, define->node, XML_RNGP_UNKNOWN_COMBINE,\n-                           \"Defines for %s use unknown combine value '%s''\\n\",\n-                           name, combine);\n-            }\n-            xmlFree(combine);\n-        } else {\n-            if (missing == 0)\n-                missing = 1;\n-            else {\n-                xmlRngPErr(ctxt, define->node, XML_RNGP_NEED_COMBINE,\n-                           \"Some defines for %s needs the combine attribute\\n\",\n-                           name, NULL);\n-            }\n-        }\n-\n-        cur = cur->nextHash;\n-    }\n-    if (choiceOrInterleave == -1)\n-        choiceOrInterleave = 0;\n-    cur = xmlRelaxNGNewDefine(ctxt, define->node);\n-    if (cur == NULL)\n-        return;\n-    if (choiceOrInterleave == 0)\n-        cur->type = XML_RELAXNG_INTERLEAVE;\n-    else\n-        cur->type = XML_RELAXNG_CHOICE;\n-    tmp = define;\n-    last = NULL;\n-    while (tmp != NULL) {\n-        if (tmp->content != NULL) {\n-            if (tmp->content->next != NULL) {\n-                \/*\n-                 * we need first to create a wrapper.\n-                 *\/\n-                tmp2 = xmlRelaxNGNewDefine(ctxt, tmp->content->node);\n-                if (tmp2 == NULL)\n-                    break;\n-                tmp2->type = XML_RELAXNG_GROUP;\n-                tmp2->content = tmp->content;\n-            } else {\n-                tmp2 = tmp->content;\n-            }\n-            if (last == NULL) {\n-                cur->content = tmp2;\n-            } else {\n-                last->next = tmp2;\n-            }\n-            last = tmp2;\n-        }\n-        tmp->content = cur;\n-        tmp = tmp->nextHash;\n-    }\n-    define->content = cur;\n-    if (choiceOrInterleave == 0) {\n-        if (ctxt->interleaves == NULL)\n-            ctxt->interleaves = xmlHashCreate(10);\n-        if (ctxt->interleaves == NULL) {\n-            xmlRngPErr(ctxt, define->node, XML_RNGP_INTERLEAVE_CREATE_FAILED,\n-                       \"Failed to create interleaves hash table\\n\", NULL,\n-                       NULL);\n-        } else {\n-            char tmpname[32];\n-\n-            snprintf(tmpname, 32, \"interleave%d\", ctxt->nbInterleaves++);\n-            if (xmlHashAddEntry(ctxt->interleaves, BAD_CAST tmpname, cur) <\n-                0) {\n-                xmlRngPErr(ctxt, define->node, XML_RNGP_INTERLEAVE_CREATE_FAILED,\n-                           \"Failed to add %s to hash table\\n\",\n-               (const xmlChar *) tmpname, NULL);\n-            }\n-        }\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGCombineStart:\n- * @ctxt:  a Relax-NG parser context\n- * @grammar:  the grammar\n- *\n- * Applies the 4.17. combine rule for all the start\n- * element of a given grammar.\n- *\/\n-static void\n-xmlRelaxNGCombineStart(xmlRelaxNGParserCtxtPtr ctxt,\n-                       xmlRelaxNGGrammarPtr grammar)\n-{\n-    xmlRelaxNGDefinePtr starts;\n-    xmlChar *combine;\n-    int choiceOrInterleave = -1;\n-    int missing = 0;\n-    xmlRelaxNGDefinePtr cur;\n-\n-    starts = grammar->start;\n-    if ((starts == NULL) || (starts->next == NULL))\n-        return;\n-    cur = starts;\n-    while (cur != NULL) {\n-        if ((cur->node == NULL) || (cur->node->parent == NULL) ||\n-            (!xmlStrEqual(cur->node->parent->name, BAD_CAST \"start\"))) {\n-            combine = NULL;\n-            xmlRngPErr(ctxt, cur->node, XML_RNGP_START_MISSING,\n-                       \"Internal error: start element not found\\n\", NULL,\n-                       NULL);\n-        } else {\n-            combine = xmlGetProp(cur->node->parent, BAD_CAST \"combine\");\n-        }\n-\n-        if (combine != NULL) {\n-            if (xmlStrEqual(combine, BAD_CAST \"choice\")) {\n-                if (choiceOrInterleave == -1)\n-                    choiceOrInterleave = 1;\n-                else if (choiceOrInterleave == 0) {\n-                    xmlRngPErr(ctxt, cur->node, XML_RNGP_START_CHOICE_AND_INTERLEAVE,\n-                               \"<start> use both 'choice' and 'interleave'\\n\",\n-                               NULL, NULL);\n-                }\n-            } else if (xmlStrEqual(combine, BAD_CAST \"interleave\")) {\n-                if (choiceOrInterleave == -1)\n-                    choiceOrInterleave = 0;\n-                else if (choiceOrInterleave == 1) {\n-                    xmlRngPErr(ctxt, cur->node, XML_RNGP_START_CHOICE_AND_INTERLEAVE,\n-                               \"<start> use both 'choice' and 'interleave'\\n\",\n-                               NULL, NULL);\n-                }\n-            } else {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_UNKNOWN_COMBINE,\n-                           \"<start> uses unknown combine value '%s''\\n\",\n-                           combine, NULL);\n-            }\n-            xmlFree(combine);\n-        } else {\n-            if (missing == 0)\n-                missing = 1;\n-            else {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_NEED_COMBINE,\n-                           \"Some <start> element miss the combine attribute\\n\",\n-                           NULL, NULL);\n-            }\n-        }\n-\n-        cur = cur->next;\n-    }\n-    if (choiceOrInterleave == -1)\n-        choiceOrInterleave = 0;\n-    cur = xmlRelaxNGNewDefine(ctxt, starts->node);\n-    if (cur == NULL)\n-        return;\n-    if (choiceOrInterleave == 0)\n-        cur->type = XML_RELAXNG_INTERLEAVE;\n-    else\n-        cur->type = XML_RELAXNG_CHOICE;\n-    cur->content = grammar->start;\n-    grammar->start = cur;\n-    if (choiceOrInterleave == 0) {\n-        if (ctxt->interleaves == NULL)\n-            ctxt->interleaves = xmlHashCreate(10);\n-        if (ctxt->interleaves == NULL) {\n-            xmlRngPErr(ctxt, cur->node, XML_RNGP_INTERLEAVE_CREATE_FAILED,\n-                       \"Failed to create interleaves hash table\\n\", NULL,\n-                       NULL);\n-        } else {\n-            char tmpname[32];\n-\n-            snprintf(tmpname, 32, \"interleave%d\", ctxt->nbInterleaves++);\n-            if (xmlHashAddEntry(ctxt->interleaves, BAD_CAST tmpname, cur) <\n-                0) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_INTERLEAVE_CREATE_FAILED,\n-                           \"Failed to add %s to hash table\\n\",\n-               (const xmlChar *) tmpname, NULL);\n-            }\n-        }\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGCheckCycles:\n- * @ctxt:  a Relax-NG parser context\n- * @nodes:  grammar children nodes\n- * @depth:  the counter\n- *\n- * Check for cycles.\n- *\n- * Returns 0 if check passed, and -1 in case of error\n- *\/\n-static int\n-xmlRelaxNGCheckCycles(xmlRelaxNGParserCtxtPtr ctxt,\n-                      xmlRelaxNGDefinePtr cur, int depth)\n-{\n-    int ret = 0;\n-\n-    while ((ret == 0) && (cur != NULL)) {\n-        if ((cur->type == XML_RELAXNG_REF) ||\n-            (cur->type == XML_RELAXNG_PARENTREF)) {\n-            if (cur->depth == -1) {\n-                cur->depth = depth;\n-                ret = xmlRelaxNGCheckCycles(ctxt, cur->content, depth);\n-                cur->depth = -2;\n-            } else if (depth == cur->depth) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_REF_CYCLE,\n-                           \"Detected a cycle in %s references\\n\",\n-                           cur->name, NULL);\n-                return (-1);\n-            }\n-        } else if (cur->type == XML_RELAXNG_ELEMENT) {\n-            ret = xmlRelaxNGCheckCycles(ctxt, cur->content, depth + 1);\n-        } else {\n-            ret = xmlRelaxNGCheckCycles(ctxt, cur->content, depth);\n-        }\n-        cur = cur->next;\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGTryUnlink:\n- * @ctxt:  a Relax-NG parser context\n- * @cur:  the definition to unlink\n- * @parent:  the parent definition\n- * @prev:  the previous sibling definition\n- *\n- * Try to unlink a definition. If not possible make it a NOOP\n- *\n- * Returns the new prev definition\n- *\/\n-static xmlRelaxNGDefinePtr\n-xmlRelaxNGTryUnlink(xmlRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-                    xmlRelaxNGDefinePtr cur,\n-                    xmlRelaxNGDefinePtr parent, xmlRelaxNGDefinePtr prev)\n-{\n-    if (prev != NULL) {\n-        prev->next = cur->next;\n-    } else {\n-        if (parent != NULL) {\n-            if (parent->content == cur)\n-                parent->content = cur->next;\n-            else if (parent->attrs == cur)\n-                parent->attrs = cur->next;\n-            else if (parent->nameClass == cur)\n-                parent->nameClass = cur->next;\n-        } else {\n-            cur->type = XML_RELAXNG_NOOP;\n-            prev = cur;\n-        }\n-    }\n-    return (prev);\n-}\n-\n-\/**\n- * xmlRelaxNGSimplify:\n- * @ctxt:  a Relax-NG parser context\n- * @nodes:  grammar children nodes\n- *\n- * Check for simplification of empty and notAllowed\n- *\/\n-static void\n-xmlRelaxNGSimplify(xmlRelaxNGParserCtxtPtr ctxt,\n-                   xmlRelaxNGDefinePtr cur, xmlRelaxNGDefinePtr parent)\n-{\n-    xmlRelaxNGDefinePtr prev = NULL;\n-\n-    while (cur != NULL) {\n-        if ((cur->type == XML_RELAXNG_REF) ||\n-            (cur->type == XML_RELAXNG_PARENTREF)) {\n-            if (cur->depth != -3) {\n-                cur->depth = -3;\n-                xmlRelaxNGSimplify(ctxt, cur->content, cur);\n-            }\n-        } else if (cur->type == XML_RELAXNG_NOT_ALLOWED) {\n-            cur->parent = parent;\n-            if ((parent != NULL) &&\n-                ((parent->type == XML_RELAXNG_ATTRIBUTE) ||\n-                 (parent->type == XML_RELAXNG_LIST) ||\n-                 (parent->type == XML_RELAXNG_GROUP) ||\n-                 (parent->type == XML_RELAXNG_INTERLEAVE) ||\n-                 (parent->type == XML_RELAXNG_ONEORMORE) ||\n-                 (parent->type == XML_RELAXNG_ZEROORMORE))) {\n-                parent->type = XML_RELAXNG_NOT_ALLOWED;\n-                break;\n-            }\n-            if ((parent != NULL) && (parent->type == XML_RELAXNG_CHOICE)) {\n-                prev = xmlRelaxNGTryUnlink(ctxt, cur, parent, prev);\n-            } else\n-                prev = cur;\n-        } else if (cur->type == XML_RELAXNG_EMPTY) {\n-            cur->parent = parent;\n-            if ((parent != NULL) &&\n-                ((parent->type == XML_RELAXNG_ONEORMORE) ||\n-                 (parent->type == XML_RELAXNG_ZEROORMORE))) {\n-                parent->type = XML_RELAXNG_EMPTY;\n-                break;\n-            }\n-            if ((parent != NULL) &&\n-                ((parent->type == XML_RELAXNG_GROUP) ||\n-                 (parent->type == XML_RELAXNG_INTERLEAVE))) {\n-                prev = xmlRelaxNGTryUnlink(ctxt, cur, parent, prev);\n-            } else\n-                prev = cur;\n-        } else {\n-            cur->parent = parent;\n-            if (cur->content != NULL)\n-                xmlRelaxNGSimplify(ctxt, cur->content, cur);\n-            if ((cur->type != XML_RELAXNG_VALUE) && (cur->attrs != NULL))\n-                xmlRelaxNGSimplify(ctxt, cur->attrs, cur);\n-            if (cur->nameClass != NULL)\n-                xmlRelaxNGSimplify(ctxt, cur->nameClass, cur);\n-            \/*\n-             * On Elements, try to move attribute only generating rules on\n-             * the attrs rules.\n-             *\/\n-            if (cur->type == XML_RELAXNG_ELEMENT) {\n-                int attronly;\n-                xmlRelaxNGDefinePtr tmp, pre;\n-\n-                while (cur->content != NULL) {\n-                    attronly =\n-                        xmlRelaxNGGenerateAttributes(ctxt, cur->content);\n-                    if (attronly == 1) {\n-                        \/*\n-                         * migrate cur->content to attrs\n-                         *\/\n-                        tmp = cur->content;\n-                        cur->content = tmp->next;\n-                        tmp->next = cur->attrs;\n-                        cur->attrs = tmp;\n-                    } else {\n-                        \/*\n-                         * cur->content can generate elements or text\n-                         *\/\n-                        break;\n-                    }\n-                }\n-                pre = cur->content;\n-                while ((pre != NULL) && (pre->next != NULL)) {\n-                    tmp = pre->next;\n-                    attronly = xmlRelaxNGGenerateAttributes(ctxt, tmp);\n-                    if (attronly == 1) {\n-                        \/*\n-                         * migrate tmp to attrs\n-                         *\/\n-                        pre->next = tmp->next;\n-                        tmp->next = cur->attrs;\n-                        cur->attrs = tmp;\n-                    } else {\n-                        pre = tmp;\n-                    }\n-                }\n-            }\n-            \/*\n-             * This may result in a simplification\n-             *\/\n-            if ((cur->type == XML_RELAXNG_GROUP) ||\n-                (cur->type == XML_RELAXNG_INTERLEAVE)) {\n-                if (cur->content == NULL)\n-                    cur->type = XML_RELAXNG_EMPTY;\n-                else if (cur->content->next == NULL) {\n-                    if ((parent == NULL) && (prev == NULL)) {\n-                        cur->type = XML_RELAXNG_NOOP;\n-                    } else if (prev == NULL) {\n-                        parent->content = cur->content;\n-                        cur->content->next = cur->next;\n-                        cur = cur->content;\n-                    } else {\n-                        cur->content->next = cur->next;\n-                        prev->next = cur->content;\n-                        cur = cur->content;\n-                    }\n-                }\n-            }\n-            \/*\n-             * the current node may have been transformed back\n-             *\/\n-            if ((cur->type == XML_RELAXNG_EXCEPT) &&\n-                (cur->content != NULL) &&\n-                (cur->content->type == XML_RELAXNG_NOT_ALLOWED)) {\n-                prev = xmlRelaxNGTryUnlink(ctxt, cur, parent, prev);\n-            } else if (cur->type == XML_RELAXNG_NOT_ALLOWED) {\n-                if ((parent != NULL) &&\n-                    ((parent->type == XML_RELAXNG_ATTRIBUTE) ||\n-                     (parent->type == XML_RELAXNG_LIST) ||\n-                     (parent->type == XML_RELAXNG_GROUP) ||\n-                     (parent->type == XML_RELAXNG_INTERLEAVE) ||\n-                     (parent->type == XML_RELAXNG_ONEORMORE) ||\n-                     (parent->type == XML_RELAXNG_ZEROORMORE))) {\n-                    parent->type = XML_RELAXNG_NOT_ALLOWED;\n-                    break;\n-                }\n-                if ((parent != NULL) &&\n-                    (parent->type == XML_RELAXNG_CHOICE)) {\n-                    prev = xmlRelaxNGTryUnlink(ctxt, cur, parent, prev);\n-                } else\n-                    prev = cur;\n-            } else if (cur->type == XML_RELAXNG_EMPTY) {\n-                if ((parent != NULL) &&\n-                    ((parent->type == XML_RELAXNG_ONEORMORE) ||\n-                     (parent->type == XML_RELAXNG_ZEROORMORE))) {\n-                    parent->type = XML_RELAXNG_EMPTY;\n-                    break;\n-                }\n-                if ((parent != NULL) &&\n-                    ((parent->type == XML_RELAXNG_GROUP) ||\n-                     (parent->type == XML_RELAXNG_INTERLEAVE) ||\n-                     (parent->type == XML_RELAXNG_CHOICE))) {\n-                    prev = xmlRelaxNGTryUnlink(ctxt, cur, parent, prev);\n-                } else\n-                    prev = cur;\n-            } else {\n-                prev = cur;\n-            }\n-        }\n-        cur = cur->next;\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGGroupContentType:\n- * @ct1:  the first content type\n- * @ct2:  the second content type\n- *\n- * Try to group 2 content types\n- *\n- * Returns the content type\n- *\/\n-static xmlRelaxNGContentType\n-xmlRelaxNGGroupContentType(xmlRelaxNGContentType ct1,\n-                           xmlRelaxNGContentType ct2)\n-{\n-    if ((ct1 == XML_RELAXNG_CONTENT_ERROR) ||\n-        (ct2 == XML_RELAXNG_CONTENT_ERROR))\n-        return (XML_RELAXNG_CONTENT_ERROR);\n-    if (ct1 == XML_RELAXNG_CONTENT_EMPTY)\n-        return (ct2);\n-    if (ct2 == XML_RELAXNG_CONTENT_EMPTY)\n-        return (ct1);\n-    if ((ct1 == XML_RELAXNG_CONTENT_COMPLEX) &&\n-        (ct2 == XML_RELAXNG_CONTENT_COMPLEX))\n-        return (XML_RELAXNG_CONTENT_COMPLEX);\n-    return (XML_RELAXNG_CONTENT_ERROR);\n-}\n-\n-\/**\n- * xmlRelaxNGMaxContentType:\n- * @ct1:  the first content type\n- * @ct2:  the second content type\n- *\n- * Compute the max content-type\n- *\n- * Returns the content type\n- *\/\n-static xmlRelaxNGContentType\n-xmlRelaxNGMaxContentType(xmlRelaxNGContentType ct1,\n-                         xmlRelaxNGContentType ct2)\n-{\n-    if ((ct1 == XML_RELAXNG_CONTENT_ERROR) ||\n-        (ct2 == XML_RELAXNG_CONTENT_ERROR))\n-        return (XML_RELAXNG_CONTENT_ERROR);\n-    if ((ct1 == XML_RELAXNG_CONTENT_SIMPLE) ||\n-        (ct2 == XML_RELAXNG_CONTENT_SIMPLE))\n-        return (XML_RELAXNG_CONTENT_SIMPLE);\n-    if ((ct1 == XML_RELAXNG_CONTENT_COMPLEX) ||\n-        (ct2 == XML_RELAXNG_CONTENT_COMPLEX))\n-        return (XML_RELAXNG_CONTENT_COMPLEX);\n-    return (XML_RELAXNG_CONTENT_EMPTY);\n-}\n-\n-\/**\n- * xmlRelaxNGCheckRules:\n- * @ctxt:  a Relax-NG parser context\n- * @cur:  the current definition\n- * @flags:  some accumulated flags\n- * @ptype:  the parent type\n- *\n- * Check for rules in section 7.1 and 7.2\n- *\n- * Returns the content type of @cur\n- *\/\n-static xmlRelaxNGContentType\n-xmlRelaxNGCheckRules(xmlRelaxNGParserCtxtPtr ctxt,\n-                     xmlRelaxNGDefinePtr cur, int flags,\n-                     xmlRelaxNGType ptype)\n-{\n-    int nflags;\n-    xmlRelaxNGContentType ret, tmp, val = XML_RELAXNG_CONTENT_EMPTY;\n-\n-    while (cur != NULL) {\n-        ret = XML_RELAXNG_CONTENT_EMPTY;\n-        if ((cur->type == XML_RELAXNG_REF) ||\n-            (cur->type == XML_RELAXNG_PARENTREF)) {\n-           \/*\n-            * This should actually be caught by list\/\/element(ref) at the\n-            * element boundaries, c.f. Bug #159968 local refs are dropped\n-            * in step 4.19.\n-            *\/\n-#if 0\n-            if (flags & XML_RELAXNG_IN_LIST) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_LIST_REF,\n-                           \"Found forbidden pattern list\/\/ref\\n\", NULL,\n-                           NULL);\n-            }\n-#endif\n-            if (flags & XML_RELAXNG_IN_DATAEXCEPT) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_REF,\n-                           \"Found forbidden pattern data\/except\/\/ref\\n\",\n-                           NULL, NULL);\n-            }\n-            if (cur->content == NULL) {\n-                if (cur->type == XML_RELAXNG_PARENTREF)\n-                    xmlRngPErr(ctxt, cur->node, XML_RNGP_REF_NO_DEF,\n-                               \"Internal found no define for parent refs\\n\",\n-                               NULL, NULL);\n-                else\n-                    xmlRngPErr(ctxt, cur->node, XML_RNGP_REF_NO_DEF,\n-                               \"Internal found no define for ref %s\\n\",\n-                               (cur->name ? cur->name: BAD_CAST \"null\"), NULL);\n-            }\n-            if (cur->depth > -4) {\n-                cur->depth = -4;\n-                ret = xmlRelaxNGCheckRules(ctxt, cur->content,\n-                                           flags, cur->type);\n-                cur->depth = ret - 15;\n-            } else if (cur->depth == -4) {\n-                ret = XML_RELAXNG_CONTENT_COMPLEX;\n-            } else {\n-                ret = (xmlRelaxNGContentType) (cur->depth + 15);\n-            }\n-        } else if (cur->type == XML_RELAXNG_ELEMENT) {\n-            \/*\n-             * The 7.3 Attribute derivation rule for groups is plugged there\n-             *\/\n-            xmlRelaxNGCheckGroupAttrs(ctxt, cur);\n-            if (flags & XML_RELAXNG_IN_DATAEXCEPT) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_ELEM,\n-                           \"Found forbidden pattern data\/except\/\/element(ref)\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_LIST) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_LIST_ELEM,\n-                           \"Found forbidden pattern list\/\/element(ref)\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_ATTRIBUTE) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_ATTR_ELEM,\n-                           \"Found forbidden pattern attribute\/\/element(ref)\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_ATTRIBUTE) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_ATTR_ELEM,\n-                           \"Found forbidden pattern attribute\/\/element(ref)\\n\",\n-                           NULL, NULL);\n-            }\n-            \/*\n-             * reset since in the simple form elements are only child\n-             * of grammar\/define\n-             *\/\n-            nflags = 0;\n-            ret =\n-                xmlRelaxNGCheckRules(ctxt, cur->attrs, nflags, cur->type);\n-            if (ret != XML_RELAXNG_CONTENT_EMPTY) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_ELEM_CONTENT_EMPTY,\n-                           \"Element %s attributes have a content type error\\n\",\n-                           cur->name, NULL);\n-            }\n-            ret =\n-                xmlRelaxNGCheckRules(ctxt, cur->content, nflags,\n-                                     cur->type);\n-            if (ret == XML_RELAXNG_CONTENT_ERROR) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_ELEM_CONTENT_ERROR,\n-                           \"Element %s has a content type error\\n\",\n-                           cur->name, NULL);\n-            } else {\n-                ret = XML_RELAXNG_CONTENT_COMPLEX;\n-            }\n-        } else if (cur->type == XML_RELAXNG_ATTRIBUTE) {\n-            if (flags & XML_RELAXNG_IN_ATTRIBUTE) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_ATTR_ATTR,\n-                           \"Found forbidden pattern attribute\/\/attribute\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_LIST) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_LIST_ATTR,\n-                           \"Found forbidden pattern list\/\/attribute\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_OOMGROUP) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_ONEMORE_GROUP_ATTR,\n-                           \"Found forbidden pattern oneOrMore\/\/group\/\/attribute\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_OOMINTERLEAVE) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR,\n-                           \"Found forbidden pattern oneOrMore\/\/interleave\/\/attribute\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_DATAEXCEPT) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_ATTR,\n-                           \"Found forbidden pattern data\/except\/\/attribute\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_START) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_ATTR,\n-                           \"Found forbidden pattern start\/\/attribute\\n\",\n-                           NULL, NULL);\n-            }\n-            if ((!(flags & XML_RELAXNG_IN_ONEORMORE))\n-                && cur->name == NULL\n-                \/* following is checking alternative name class readiness\n-                   in case it went the \"choice\" route *\/\n-                && cur->nameClass == NULL) {\n-                if (cur->ns == NULL) {\n-                    xmlRngPErr(ctxt, cur->node, XML_RNGP_ANYNAME_ATTR_ANCESTOR,\n-                               \"Found anyName attribute without oneOrMore ancestor\\n\",\n-                               NULL, NULL);\n-                } else {\n-                    xmlRngPErr(ctxt, cur->node, XML_RNGP_NSNAME_ATTR_ANCESTOR,\n-                               \"Found nsName attribute without oneOrMore ancestor\\n\",\n-                               NULL, NULL);\n-                }\n-            }\n-            nflags = flags | XML_RELAXNG_IN_ATTRIBUTE;\n-            xmlRelaxNGCheckRules(ctxt, cur->content, nflags, cur->type);\n-            ret = XML_RELAXNG_CONTENT_EMPTY;\n-        } else if ((cur->type == XML_RELAXNG_ONEORMORE) ||\n-                   (cur->type == XML_RELAXNG_ZEROORMORE)) {\n-            if (flags & XML_RELAXNG_IN_DATAEXCEPT) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_ONEMORE,\n-                           \"Found forbidden pattern data\/except\/\/oneOrMore\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_START) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_ONEMORE,\n-                           \"Found forbidden pattern start\/\/oneOrMore\\n\",\n-                           NULL, NULL);\n-            }\n-            nflags = flags | XML_RELAXNG_IN_ONEORMORE;\n-            ret =\n-                xmlRelaxNGCheckRules(ctxt, cur->content, nflags,\n-                                     cur->type);\n-            ret = xmlRelaxNGGroupContentType(ret, ret);\n-        } else if (cur->type == XML_RELAXNG_LIST) {\n-            if (flags & XML_RELAXNG_IN_LIST) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_LIST_LIST,\n-                           \"Found forbidden pattern list\/\/list\\n\", NULL,\n-                           NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_DATAEXCEPT) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_LIST,\n-                           \"Found forbidden pattern data\/except\/\/list\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_START) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_LIST,\n-                           \"Found forbidden pattern start\/\/list\\n\", NULL,\n-                           NULL);\n-            }\n-            nflags = flags | XML_RELAXNG_IN_LIST;\n-            ret =\n-                xmlRelaxNGCheckRules(ctxt, cur->content, nflags,\n-                                     cur->type);\n-        } else if (cur->type == XML_RELAXNG_GROUP) {\n-            if (flags & XML_RELAXNG_IN_DATAEXCEPT) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_GROUP,\n-                           \"Found forbidden pattern data\/except\/\/group\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_START) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_GROUP,\n-                           \"Found forbidden pattern start\/\/group\\n\", NULL,\n-                           NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_ONEORMORE)\n-                nflags = flags | XML_RELAXNG_IN_OOMGROUP;\n-            else\n-                nflags = flags;\n-            ret =\n-                xmlRelaxNGCheckRules(ctxt, cur->content, nflags,\n-                                     cur->type);\n-            \/*\n-             * The 7.3 Attribute derivation rule for groups is plugged there\n-             *\/\n-            xmlRelaxNGCheckGroupAttrs(ctxt, cur);\n-        } else if (cur->type == XML_RELAXNG_INTERLEAVE) {\n-            if (flags & XML_RELAXNG_IN_LIST) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_LIST_INTERLEAVE,\n-                           \"Found forbidden pattern list\/\/interleave\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_DATAEXCEPT) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE,\n-                           \"Found forbidden pattern data\/except\/\/interleave\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_START) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE,\n-                           \"Found forbidden pattern start\/\/interleave\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_ONEORMORE)\n-                nflags = flags | XML_RELAXNG_IN_OOMINTERLEAVE;\n-            else\n-                nflags = flags;\n-            ret =\n-                xmlRelaxNGCheckRules(ctxt, cur->content, nflags,\n-                                     cur->type);\n-        } else if (cur->type == XML_RELAXNG_EXCEPT) {\n-            if ((cur->parent != NULL) &&\n-                (cur->parent->type == XML_RELAXNG_DATATYPE))\n-                nflags = flags | XML_RELAXNG_IN_DATAEXCEPT;\n-            else\n-                nflags = flags;\n-            ret =\n-                xmlRelaxNGCheckRules(ctxt, cur->content, nflags,\n-                                     cur->type);\n-        } else if (cur->type == XML_RELAXNG_DATATYPE) {\n-            if (flags & XML_RELAXNG_IN_START) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_DATA,\n-                           \"Found forbidden pattern start\/\/data\\n\", NULL,\n-                           NULL);\n-            }\n-            xmlRelaxNGCheckRules(ctxt, cur->content, flags, cur->type);\n-            ret = XML_RELAXNG_CONTENT_SIMPLE;\n-        } else if (cur->type == XML_RELAXNG_VALUE) {\n-            if (flags & XML_RELAXNG_IN_START) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_VALUE,\n-                           \"Found forbidden pattern start\/\/value\\n\", NULL,\n-                           NULL);\n-            }\n-            xmlRelaxNGCheckRules(ctxt, cur->content, flags, cur->type);\n-            ret = XML_RELAXNG_CONTENT_SIMPLE;\n-        } else if (cur->type == XML_RELAXNG_TEXT) {\n-            if (flags & XML_RELAXNG_IN_LIST) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_LIST_TEXT,\n-                           \"Found forbidden pattern list\/\/text\\n\", NULL,\n-                           NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_DATAEXCEPT) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_TEXT,\n-                           \"Found forbidden pattern data\/except\/\/text\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_START) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_TEXT,\n-                           \"Found forbidden pattern start\/\/text\\n\", NULL,\n-                           NULL);\n-            }\n-            ret = XML_RELAXNG_CONTENT_COMPLEX;\n-        } else if (cur->type == XML_RELAXNG_EMPTY) {\n-            if (flags & XML_RELAXNG_IN_DATAEXCEPT) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_DATA_EXCEPT_EMPTY,\n-                           \"Found forbidden pattern data\/except\/\/empty\\n\",\n-                           NULL, NULL);\n-            }\n-            if (flags & XML_RELAXNG_IN_START) {\n-                xmlRngPErr(ctxt, cur->node, XML_RNGP_PAT_START_EMPTY,\n-                           \"Found forbidden pattern start\/\/empty\\n\", NULL,\n-                           NULL);\n-            }\n-            ret = XML_RELAXNG_CONTENT_EMPTY;\n-        } else if (cur->type == XML_RELAXNG_CHOICE) {\n-            xmlRelaxNGCheckChoiceDeterminism(ctxt, cur);\n-            ret =\n-                xmlRelaxNGCheckRules(ctxt, cur->content, flags, cur->type);\n-        } else {\n-            ret =\n-                xmlRelaxNGCheckRules(ctxt, cur->content, flags, cur->type);\n-        }\n-        cur = cur->next;\n-        if (ptype == XML_RELAXNG_GROUP) {\n-            val = xmlRelaxNGGroupContentType(val, ret);\n-        } else if (ptype == XML_RELAXNG_INTERLEAVE) {\n-            \/*\n-             * TODO: scan complain that tmp is never used, seems on purpose\n-             *       need double-checking\n-             *\/\n-            tmp = xmlRelaxNGGroupContentType(val, ret);\n-            if (tmp != XML_RELAXNG_CONTENT_ERROR)\n-                tmp = xmlRelaxNGMaxContentType(val, ret);\n-        } else if (ptype == XML_RELAXNG_CHOICE) {\n-            val = xmlRelaxNGMaxContentType(val, ret);\n-        } else if (ptype == XML_RELAXNG_LIST) {\n-            val = XML_RELAXNG_CONTENT_SIMPLE;\n-        } else if (ptype == XML_RELAXNG_EXCEPT) {\n-            if (ret == XML_RELAXNG_CONTENT_ERROR)\n-                val = XML_RELAXNG_CONTENT_ERROR;\n-            else\n-                val = XML_RELAXNG_CONTENT_SIMPLE;\n-        } else {\n-            val = xmlRelaxNGGroupContentType(val, ret);\n-        }\n-\n-    }\n-    return (val);\n-}\n-\n-\/**\n- * xmlRelaxNGParseGrammar:\n- * @ctxt:  a Relax-NG parser context\n- * @nodes:  grammar children nodes\n- *\n- * parse a Relax-NG <grammar> node\n- *\n- * Returns the internal xmlRelaxNGGrammarPtr built or\n- *         NULL in case of error\n- *\/\n-static xmlRelaxNGGrammarPtr\n-xmlRelaxNGParseGrammar(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr nodes)\n-{\n-    xmlRelaxNGGrammarPtr ret, tmp, old;\n-\n-    ret = xmlRelaxNGNewGrammar(ctxt);\n-    if (ret == NULL)\n-        return (NULL);\n-\n-    \/*\n-     * Link the new grammar in the tree\n-     *\/\n-    ret->parent = ctxt->grammar;\n-    if (ctxt->grammar != NULL) {\n-        tmp = ctxt->grammar->children;\n-        if (tmp == NULL) {\n-            ctxt->grammar->children = ret;\n-        } else {\n-            while (tmp->next != NULL)\n-                tmp = tmp->next;\n-            tmp->next = ret;\n-        }\n-    }\n-\n-    old = ctxt->grammar;\n-    ctxt->grammar = ret;\n-    xmlRelaxNGParseGrammarContent(ctxt, nodes);\n-    ctxt->grammar = ret;\n-    if (ctxt->grammar == NULL) {\n-        xmlRngPErr(ctxt, nodes, XML_RNGP_GRAMMAR_CONTENT,\n-                   \"Failed to parse <grammar> content\\n\", NULL, NULL);\n-    } else if (ctxt->grammar->start == NULL) {\n-        xmlRngPErr(ctxt, nodes, XML_RNGP_GRAMMAR_NO_START,\n-                   \"Element <grammar> has no <start>\\n\", NULL, NULL);\n-    }\n-\n-    \/*\n-     * Apply 4.17 merging rules to defines and starts\n-     *\/\n-    xmlRelaxNGCombineStart(ctxt, ret);\n-    if (ret->defs != NULL) {\n-        xmlHashScan(ret->defs, xmlRelaxNGCheckCombine, ctxt);\n-    }\n-\n-    \/*\n-     * link together defines and refs in this grammar\n-     *\/\n-    if (ret->refs != NULL) {\n-        xmlHashScan(ret->refs, xmlRelaxNGCheckReference, ctxt);\n-    }\n-\n-\n-    \/* @@@@ *\/\n-\n-    ctxt->grammar = old;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGParseDocument:\n- * @ctxt:  a Relax-NG parser context\n- * @node:  the root node of the RelaxNG schema\n- *\n- * parse a Relax-NG definition resource and build an internal\n- * xmlRelaxNG structure which can be used to validate instances.\n- *\n- * Returns the internal XML RelaxNG structure built or\n- *         NULL in case of error\n- *\/\n-static xmlRelaxNGPtr\n-xmlRelaxNGParseDocument(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlRelaxNGPtr schema = NULL;\n-    const xmlChar *olddefine;\n-    xmlRelaxNGGrammarPtr old;\n-\n-    if ((ctxt == NULL) || (node == NULL))\n-        return (NULL);\n-\n-    schema = xmlRelaxNGNewRelaxNG(ctxt);\n-    if (schema == NULL)\n-        return (NULL);\n-\n-    olddefine = ctxt->define;\n-    ctxt->define = NULL;\n-    if (IS_RELAXNG(node, \"grammar\")) {\n-        schema->topgrammar = xmlRelaxNGParseGrammar(ctxt, node->children);\n-        if (schema->topgrammar == NULL) {\n-            xmlRelaxNGFree(schema);\n-            return (NULL);\n-        }\n-    } else {\n-        xmlRelaxNGGrammarPtr tmp, ret;\n-\n-        schema->topgrammar = ret = xmlRelaxNGNewGrammar(ctxt);\n-        if (schema->topgrammar == NULL) {\n-            xmlRelaxNGFree(schema);\n-            return (NULL);\n-        }\n-        \/*\n-         * Link the new grammar in the tree\n-         *\/\n-        ret->parent = ctxt->grammar;\n-        if (ctxt->grammar != NULL) {\n-            tmp = ctxt->grammar->children;\n-            if (tmp == NULL) {\n-                ctxt->grammar->children = ret;\n-            } else {\n-                while (tmp->next != NULL)\n-                    tmp = tmp->next;\n-                tmp->next = ret;\n-            }\n-        }\n-        old = ctxt->grammar;\n-        ctxt->grammar = ret;\n-        xmlRelaxNGParseStart(ctxt, node);\n-        if (old != NULL)\n-            ctxt->grammar = old;\n-    }\n-    ctxt->define = olddefine;\n-    if (schema->topgrammar->start != NULL) {\n-        xmlRelaxNGCheckCycles(ctxt, schema->topgrammar->start, 0);\n-        if ((ctxt->flags & XML_RELAXNG_IN_EXTERNALREF) == 0) {\n-            xmlRelaxNGSimplify(ctxt, schema->topgrammar->start, NULL);\n-            while ((schema->topgrammar->start != NULL) &&\n-                   (schema->topgrammar->start->type == XML_RELAXNG_NOOP) &&\n-                   (schema->topgrammar->start->next != NULL))\n-                schema->topgrammar->start =\n-                    schema->topgrammar->start->content;\n-            xmlRelaxNGCheckRules(ctxt, schema->topgrammar->start,\n-                                 XML_RELAXNG_IN_START, XML_RELAXNG_NOOP);\n-        }\n-    }\n-\n-    return (schema);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Reading RelaxNGs                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlRelaxNGNewParserCtxt:\n- * @URL:  the location of the schema\n- *\n- * Create an XML RelaxNGs parse context for that file\/resource expected\n- * to contain an XML RelaxNGs file.\n- *\n- * Returns the parser context or NULL in case of error\n- *\/\n-xmlRelaxNGParserCtxtPtr\n-xmlRelaxNGNewParserCtxt(const char *URL)\n-{\n-    xmlRelaxNGParserCtxtPtr ret;\n-\n-    if (URL == NULL)\n-        return (NULL);\n-\n-    ret =\n-        (xmlRelaxNGParserCtxtPtr) xmlMalloc(sizeof(xmlRelaxNGParserCtxt));\n-    if (ret == NULL) {\n-        xmlRngPErrMemory(NULL);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlRelaxNGParserCtxt));\n-    ret->URL = xmlStrdup((const xmlChar *) URL);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGNewMemParserCtxt:\n- * @buffer:  a pointer to a char array containing the schemas\n- * @size:  the size of the array\n- *\n- * Create an XML RelaxNGs parse context for that memory buffer expected\n- * to contain an XML RelaxNGs file.\n- *\n- * Returns the parser context or NULL in case of error\n- *\/\n-xmlRelaxNGParserCtxtPtr\n-xmlRelaxNGNewMemParserCtxt(const char *buffer, int size)\n-{\n-    xmlRelaxNGParserCtxtPtr ret;\n-\n-    if ((buffer == NULL) || (size <= 0))\n-        return (NULL);\n-\n-    ret =\n-        (xmlRelaxNGParserCtxtPtr) xmlMalloc(sizeof(xmlRelaxNGParserCtxt));\n-    if (ret == NULL) {\n-        xmlRngPErrMemory(NULL);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlRelaxNGParserCtxt));\n-    ret->buffer = buffer;\n-    ret->size = size;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGNewDocParserCtxt:\n- * @doc:  a preparsed document tree\n- *\n- * Create an XML RelaxNGs parser context for that document.\n- * Note: since the process of compiling a RelaxNG schemas modifies the\n- *       document, the @doc parameter is duplicated internally.\n- *\n- * Returns the parser context or NULL in case of error\n- *\/\n-xmlRelaxNGParserCtxtPtr\n-xmlRelaxNGNewDocParserCtxt(xmlDocPtr doc)\n-{\n-    xmlRelaxNGParserCtxtPtr ret;\n-    xmlDocPtr copy;\n-\n-    if (doc == NULL)\n-        return (NULL);\n-    copy = xmlCopyDoc(doc, 1);\n-    if (copy == NULL)\n-        return (NULL);\n-\n-    ret =\n-        (xmlRelaxNGParserCtxtPtr) xmlMalloc(sizeof(xmlRelaxNGParserCtxt));\n-    if (ret == NULL) {\n-        xmlRngPErrMemory(NULL);\n-        xmlFreeDoc(copy);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlRelaxNGParserCtxt));\n-    ret->document = copy;\n-    ret->freedoc = 1;\n-    ret->userData = xmlGenericErrorContext;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGFreeParserCtxt:\n- * @ctxt:  the schema parser context\n- *\n- * Free the resources associated to the schema parser context\n- *\/\n-void\n-xmlRelaxNGFreeParserCtxt(xmlRelaxNGParserCtxtPtr ctxt)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    if (ctxt->URL != NULL)\n-        xmlFree(ctxt->URL);\n-    if (ctxt->doc != NULL)\n-        xmlRelaxNGFreeDocument(ctxt->doc);\n-    if (ctxt->interleaves != NULL)\n-        xmlHashFree(ctxt->interleaves, NULL);\n-    if (ctxt->documents != NULL)\n-        xmlRelaxNGFreeDocumentList(ctxt->documents);\n-    if (ctxt->includes != NULL)\n-        xmlRelaxNGFreeIncludeList(ctxt->includes);\n-    if (ctxt->docTab != NULL)\n-        xmlFree(ctxt->docTab);\n-    if (ctxt->incTab != NULL)\n-        xmlFree(ctxt->incTab);\n-    if (ctxt->defTab != NULL) {\n-        int i;\n-\n-        for (i = 0; i < ctxt->defNr; i++)\n-            xmlRelaxNGFreeDefine(ctxt->defTab[i]);\n-        xmlFree(ctxt->defTab);\n-    }\n-    if ((ctxt->document != NULL) && (ctxt->freedoc))\n-        xmlFreeDoc(ctxt->document);\n-    xmlFree(ctxt);\n-}\n-\n-\/**\n- * xmlRelaxNGNormExtSpace:\n- * @value:  a value\n- *\n- * Removes the leading and ending spaces of the value\n- * The string is modified \"in situ\"\n- *\/\n-static void\n-xmlRelaxNGNormExtSpace(xmlChar * value)\n-{\n-    xmlChar *start = value;\n-    xmlChar *cur = value;\n-\n-    if (value == NULL)\n-        return;\n-\n-    while (IS_BLANK_CH(*cur))\n-        cur++;\n-    if (cur == start) {\n-        do {\n-            while ((*cur != 0) && (!IS_BLANK_CH(*cur)))\n-                cur++;\n-            if (*cur == 0)\n-                return;\n-            start = cur;\n-            while (IS_BLANK_CH(*cur))\n-                cur++;\n-            if (*cur == 0) {\n-                *start = 0;\n-                return;\n-            }\n-        } while (1);\n-    } else {\n-        do {\n-            while ((*cur != 0) && (!IS_BLANK_CH(*cur)))\n-                *start++ = *cur++;\n-            if (*cur == 0) {\n-                *start = 0;\n-                return;\n-            }\n-            \/* don't try to normalize the inner spaces *\/\n-            while (IS_BLANK_CH(*cur))\n-                cur++;\n-            if (*cur == 0) {\n-                *start = 0;\n-                return;\n-            }\n-            *start++ = *cur++;\n-        } while (1);\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGCleanupAttributes:\n- * @ctxt:  a Relax-NG parser context\n- * @node:  a Relax-NG node\n- *\n- * Check all the attributes on the given node\n- *\/\n-static void\n-xmlRelaxNGCleanupAttributes(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlAttrPtr cur, next;\n-\n-    cur = node->properties;\n-    while (cur != NULL) {\n-        next = cur->next;\n-        if ((cur->ns == NULL) ||\n-            (xmlStrEqual(cur->ns->href, xmlRelaxNGNs))) {\n-            if (xmlStrEqual(cur->name, BAD_CAST \"name\")) {\n-                if ((!xmlStrEqual(node->name, BAD_CAST \"element\")) &&\n-                    (!xmlStrEqual(node->name, BAD_CAST \"attribute\")) &&\n-                    (!xmlStrEqual(node->name, BAD_CAST \"ref\")) &&\n-                    (!xmlStrEqual(node->name, BAD_CAST \"parentRef\")) &&\n-                    (!xmlStrEqual(node->name, BAD_CAST \"param\")) &&\n-                    (!xmlStrEqual(node->name, BAD_CAST \"define\"))) {\n-                    xmlRngPErr(ctxt, node, XML_RNGP_FORBIDDEN_ATTRIBUTE,\n-                               \"Attribute %s is not allowed on %s\\n\",\n-                               cur->name, node->name);\n-                }\n-            } else if (xmlStrEqual(cur->name, BAD_CAST \"type\")) {\n-                if ((!xmlStrEqual(node->name, BAD_CAST \"value\")) &&\n-                    (!xmlStrEqual(node->name, BAD_CAST \"data\"))) {\n-                    xmlRngPErr(ctxt, node, XML_RNGP_FORBIDDEN_ATTRIBUTE,\n-                               \"Attribute %s is not allowed on %s\\n\",\n-                               cur->name, node->name);\n-                }\n-            } else if (xmlStrEqual(cur->name, BAD_CAST \"href\")) {\n-                if ((!xmlStrEqual(node->name, BAD_CAST \"externalRef\")) &&\n-                    (!xmlStrEqual(node->name, BAD_CAST \"include\"))) {\n-                    xmlRngPErr(ctxt, node, XML_RNGP_FORBIDDEN_ATTRIBUTE,\n-                               \"Attribute %s is not allowed on %s\\n\",\n-                               cur->name, node->name);\n-                }\n-            } else if (xmlStrEqual(cur->name, BAD_CAST \"combine\")) {\n-                if ((!xmlStrEqual(node->name, BAD_CAST \"start\")) &&\n-                    (!xmlStrEqual(node->name, BAD_CAST \"define\"))) {\n-                    xmlRngPErr(ctxt, node, XML_RNGP_FORBIDDEN_ATTRIBUTE,\n-                               \"Attribute %s is not allowed on %s\\n\",\n-                               cur->name, node->name);\n-                }\n-            } else if (xmlStrEqual(cur->name, BAD_CAST \"datatypeLibrary\")) {\n-                xmlChar *val;\n-                xmlURIPtr uri;\n-\n-                val = xmlNodeListGetString(node->doc, cur->children, 1);\n-                if (val != NULL) {\n-                    if (val[0] != 0) {\n-                        uri = xmlParseURI((const char *) val);\n-                        if (uri == NULL) {\n-                            xmlRngPErr(ctxt, node, XML_RNGP_INVALID_URI,\n-                                       \"Attribute %s contains invalid URI %s\\n\",\n-                                       cur->name, val);\n-                        } else {\n-                            if (uri->scheme == NULL) {\n-                                xmlRngPErr(ctxt, node, XML_RNGP_URI_NOT_ABSOLUTE,\n-                                           \"Attribute %s URI %s is not absolute\\n\",\n-                                           cur->name, val);\n-                            }\n-                            if (uri->fragment != NULL) {\n-                                xmlRngPErr(ctxt, node, XML_RNGP_URI_FRAGMENT,\n-                                           \"Attribute %s URI %s has a fragment ID\\n\",\n-                                           cur->name, val);\n-                            }\n-                            xmlFreeURI(uri);\n-                        }\n-                    }\n-                    xmlFree(val);\n-                }\n-            } else if (!xmlStrEqual(cur->name, BAD_CAST \"ns\")) {\n-                xmlRngPErr(ctxt, node, XML_RNGP_UNKNOWN_ATTRIBUTE,\n-                           \"Unknown attribute %s on %s\\n\", cur->name,\n-                           node->name);\n-            }\n-        }\n-        cur = next;\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGCleanupTree:\n- * @ctxt:  a Relax-NG parser context\n- * @root:  an xmlNodePtr subtree\n- *\n- * Cleanup the subtree from unwanted nodes for parsing, resolve\n- * Include and externalRef lookups.\n- *\/\n-static void\n-xmlRelaxNGCleanupTree(xmlRelaxNGParserCtxtPtr ctxt, xmlNodePtr root)\n-{\n-    xmlNodePtr cur, delete;\n-\n-    delete = NULL;\n-    cur = root;\n-    while (cur != NULL) {\n-        if (delete != NULL) {\n-            xmlUnlinkNode(delete);\n-            xmlFreeNode(delete);\n-            delete = NULL;\n-        }\n-        if (cur->type == XML_ELEMENT_NODE) {\n-            \/*\n-             * Simplification 4.1. Annotations\n-             *\/\n-            if ((cur->ns == NULL) ||\n-                (!xmlStrEqual(cur->ns->href, xmlRelaxNGNs))) {\n-                if ((cur->parent != NULL) &&\n-                    (cur->parent->type == XML_ELEMENT_NODE) &&\n-                    ((xmlStrEqual(cur->parent->name, BAD_CAST \"name\")) ||\n-                     (xmlStrEqual(cur->parent->name, BAD_CAST \"value\")) ||\n-                     (xmlStrEqual(cur->parent->name, BAD_CAST \"param\")))) {\n-                    xmlRngPErr(ctxt, cur, XML_RNGP_FOREIGN_ELEMENT,\n-                               \"element %s doesn't allow foreign elements\\n\",\n-                               cur->parent->name, NULL);\n-                }\n-                delete = cur;\n-                goto skip_children;\n-            } else {\n-                xmlRelaxNGCleanupAttributes(ctxt, cur);\n-                if (xmlStrEqual(cur->name, BAD_CAST \"externalRef\")) {\n-                    xmlChar *href, *ns, *base, *URL;\n-                    xmlRelaxNGDocumentPtr docu;\n-                    xmlNodePtr tmp;\n-            xmlURIPtr uri;\n-\n-                    ns = xmlGetProp(cur, BAD_CAST \"ns\");\n-                    if (ns == NULL) {\n-                        tmp = cur->parent;\n-                        while ((tmp != NULL) &&\n-                               (tmp->type == XML_ELEMENT_NODE)) {\n-                            ns = xmlGetProp(tmp, BAD_CAST \"ns\");\n-                            if (ns != NULL)\n-                                break;\n-                            tmp = tmp->parent;\n-                        }\n-                    }\n-                    href = xmlGetProp(cur, BAD_CAST \"href\");\n-                    if (href == NULL) {\n-                        xmlRngPErr(ctxt, cur, XML_RNGP_MISSING_HREF,\n-                                   \"xmlRelaxNGParse: externalRef has no href attribute\\n\",\n-                                   NULL, NULL);\n-                        if (ns != NULL)\n-                            xmlFree(ns);\n-                        delete = cur;\n-                        goto skip_children;\n-                    }\n-            uri = xmlParseURI((const char *) href);\n-            if (uri == NULL) {\n-                        xmlRngPErr(ctxt, cur, XML_RNGP_HREF_ERROR,\n-                                   \"Incorrect URI for externalRef %s\\n\",\n-                                   href, NULL);\n-                        if (ns != NULL)\n-                            xmlFree(ns);\n-                        if (href != NULL)\n-                            xmlFree(href);\n-                        delete = cur;\n-                        goto skip_children;\n-            }\n-            if (uri->fragment != NULL) {\n-                        xmlRngPErr(ctxt, cur, XML_RNGP_HREF_ERROR,\n-                   \"Fragment forbidden in URI for externalRef %s\\n\",\n-                                   href, NULL);\n-                        if (ns != NULL)\n-                            xmlFree(ns);\n-                xmlFreeURI(uri);\n-                        if (href != NULL)\n-                            xmlFree(href);\n-                        delete = cur;\n-                        goto skip_children;\n-            }\n-            xmlFreeURI(uri);\n-                    base = xmlNodeGetBase(cur->doc, cur);\n-                    URL = xmlBuildURI(href, base);\n-                    if (URL == NULL) {\n-                        xmlRngPErr(ctxt, cur, XML_RNGP_HREF_ERROR,\n-                                   \"Failed to compute URL for externalRef %s\\n\",\n-                                   href, NULL);\n-                        if (ns != NULL)\n-                            xmlFree(ns);\n-                        if (href != NULL)\n-                            xmlFree(href);\n-                        if (base != NULL)\n-                            xmlFree(base);\n-                        delete = cur;\n-                        goto skip_children;\n-                    }\n-                    if (href != NULL)\n-                        xmlFree(href);\n-                    if (base != NULL)\n-                        xmlFree(base);\n-                    docu = xmlRelaxNGLoadExternalRef(ctxt, URL, ns);\n-                    if (docu == NULL) {\n-                        xmlRngPErr(ctxt, cur, XML_RNGP_EXTERNAL_REF_FAILURE,\n-                                   \"Failed to load externalRef %s\\n\", URL,\n-                                   NULL);\n-                        if (ns != NULL)\n-                            xmlFree(ns);\n-                        xmlFree(URL);\n-                        delete = cur;\n-                        goto skip_children;\n-                    }\n-                    if (ns != NULL)\n-                        xmlFree(ns);\n-                    xmlFree(URL);\n-                    cur->psvi = docu;\n-                } else if (xmlStrEqual(cur->name, BAD_CAST \"include\")) {\n-                    xmlChar *href, *ns, *base, *URL;\n-                    xmlRelaxNGIncludePtr incl;\n-                    xmlNodePtr tmp;\n-\n-                    href = xmlGetProp(cur, BAD_CAST \"href\");\n-                    if (href == NULL) {\n-                        xmlRngPErr(ctxt, cur, XML_RNGP_MISSING_HREF,\n-                                   \"xmlRelaxNGParse: include has no href attribute\\n\",\n-                                   NULL, NULL);\n-                        delete = cur;\n-                        goto skip_children;\n-                    }\n-                    base = xmlNodeGetBase(cur->doc, cur);\n-                    URL = xmlBuildURI(href, base);\n-                    if (URL == NULL) {\n-                        xmlRngPErr(ctxt, cur, XML_RNGP_HREF_ERROR,\n-                                   \"Failed to compute URL for include %s\\n\",\n-                                   href, NULL);\n-                        if (href != NULL)\n-                            xmlFree(href);\n-                        if (base != NULL)\n-                            xmlFree(base);\n-                        delete = cur;\n-                        goto skip_children;\n-                    }\n-                    if (href != NULL)\n-                        xmlFree(href);\n-                    if (base != NULL)\n-                        xmlFree(base);\n-                    ns = xmlGetProp(cur, BAD_CAST \"ns\");\n-                    if (ns == NULL) {\n-                        tmp = cur->parent;\n-                        while ((tmp != NULL) &&\n-                               (tmp->type == XML_ELEMENT_NODE)) {\n-                            ns = xmlGetProp(tmp, BAD_CAST \"ns\");\n-                            if (ns != NULL)\n-                                break;\n-                            tmp = tmp->parent;\n-                        }\n-                    }\n-                    incl = xmlRelaxNGLoadInclude(ctxt, URL, cur, ns);\n-                    if (ns != NULL)\n-                        xmlFree(ns);\n-                    if (incl == NULL) {\n-                        xmlRngPErr(ctxt, cur, XML_RNGP_INCLUDE_FAILURE,\n-                                   \"Failed to load include %s\\n\", URL,\n-                                   NULL);\n-                        xmlFree(URL);\n-                        delete = cur;\n-                        goto skip_children;\n-                    }\n-                    xmlFree(URL);\n-                    cur->psvi = incl;\n-                } else if ((xmlStrEqual(cur->name, BAD_CAST \"element\")) ||\n-                           (xmlStrEqual(cur->name, BAD_CAST \"attribute\")))\n-                {\n-                    xmlChar *name, *ns;\n-                    xmlNodePtr text = NULL;\n-\n-                    \/*\n-                     * Simplification 4.8. name attribute of element\n-                     * and attribute elements\n-                     *\/\n-                    name = xmlGetProp(cur, BAD_CAST \"name\");\n-                    if (name != NULL) {\n-                        if (cur->children == NULL) {\n-                            text =\n-                                xmlNewChild(cur, cur->ns, BAD_CAST \"name\",\n-                                            name);\n-                        } else {\n-                            xmlNodePtr node;\n-\n-                            node = xmlNewDocNode(cur->doc, cur->ns,\n-                                     BAD_CAST \"name\", NULL);\n-                            if (node != NULL) {\n-                                xmlAddPrevSibling(cur->children, node);\n-                                text = xmlNewDocText(node->doc, name);\n-                                xmlAddChild(node, text);\n-                                text = node;\n-                            }\n-                        }\n-                        if (text == NULL) {\n-                            xmlRngPErr(ctxt, cur, XML_RNGP_CREATE_FAILURE,\n-                                       \"Failed to create a name %s element\\n\",\n-                                       name, NULL);\n-                        }\n-                        xmlUnsetProp(cur, BAD_CAST \"name\");\n-                        xmlFree(name);\n-                        ns = xmlGetProp(cur, BAD_CAST \"ns\");\n-                        if (ns != NULL) {\n-                            if (text != NULL) {\n-                                xmlSetProp(text, BAD_CAST \"ns\", ns);\n-                                \/* xmlUnsetProp(cur, BAD_CAST \"ns\"); *\/\n-                            }\n-                            xmlFree(ns);\n-                        } else if (xmlStrEqual(cur->name,\n-                                               BAD_CAST \"attribute\")) {\n-                            xmlSetProp(text, BAD_CAST \"ns\", BAD_CAST \"\");\n-                        }\n-                    }\n-                } else if ((xmlStrEqual(cur->name, BAD_CAST \"name\")) ||\n-                           (xmlStrEqual(cur->name, BAD_CAST \"nsName\")) ||\n-                           (xmlStrEqual(cur->name, BAD_CAST \"value\"))) {\n-                    \/*\n-                     * Simplification 4.8. name attribute of element\n-                     * and attribute elements\n-                     *\/\n-                    if (xmlHasProp(cur, BAD_CAST \"ns\") == NULL) {\n-                        xmlNodePtr node;\n-                        xmlChar *ns = NULL;\n-\n-                        node = cur->parent;\n-                        while ((node != NULL) &&\n-                               (node->type == XML_ELEMENT_NODE)) {\n-                            ns = xmlGetProp(node, BAD_CAST \"ns\");\n-                            if (ns != NULL) {\n-                                break;\n-                            }\n-                            node = node->parent;\n-                        }\n-                        if (ns == NULL) {\n-                            xmlSetProp(cur, BAD_CAST \"ns\", BAD_CAST \"\");\n-                        } else {\n-                            xmlSetProp(cur, BAD_CAST \"ns\", ns);\n-                            xmlFree(ns);\n-                        }\n-                    }\n-                    if (xmlStrEqual(cur->name, BAD_CAST \"name\")) {\n-                        xmlChar *name, *local, *prefix;\n-\n-                        \/*\n-                         * Simplification: 4.10. QNames\n-                         *\/\n-                        name = xmlNodeGetContent(cur);\n-                        if (name != NULL) {\n-                            local = xmlSplitQName2(name, &prefix);\n-                            if (local != NULL) {\n-                                xmlNsPtr ns;\n-\n-                                ns = xmlSearchNs(cur->doc, cur, prefix);\n-                                if (ns == NULL) {\n-                                    xmlRngPErr(ctxt, cur,\n-                                               XML_RNGP_PREFIX_UNDEFINED,\n-                                               \"xmlRelaxNGParse: no namespace for prefix %s\\n\",\n-                                               prefix, NULL);\n-                                } else {\n-                                    xmlSetProp(cur, BAD_CAST \"ns\",\n-                                               ns->href);\n-                                    xmlNodeSetContent(cur, local);\n-                                }\n-                                xmlFree(local);\n-                                xmlFree(prefix);\n-                            }\n-                            xmlFree(name);\n-                        }\n-                    }\n-                    \/*\n-                     * 4.16\n-                     *\/\n-                    if (xmlStrEqual(cur->name, BAD_CAST \"nsName\")) {\n-                        if (ctxt->flags & XML_RELAXNG_IN_NSEXCEPT) {\n-                            xmlRngPErr(ctxt, cur,\n-                                       XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME,\n-                                       \"Found nsName\/except\/\/nsName forbidden construct\\n\",\n-                                       NULL, NULL);\n-                        }\n-                    }\n-                } else if ((xmlStrEqual(cur->name, BAD_CAST \"except\")) &&\n-                           (cur != root)) {\n-                    int oldflags = ctxt->flags;\n-\n-                    \/*\n-                     * 4.16\n-                     *\/\n-                    if ((cur->parent != NULL) &&\n-                        (xmlStrEqual\n-                         (cur->parent->name, BAD_CAST \"anyName\"))) {\n-                        ctxt->flags |= XML_RELAXNG_IN_ANYEXCEPT;\n-                        xmlRelaxNGCleanupTree(ctxt, cur);\n-                        ctxt->flags = oldflags;\n-                        goto skip_children;\n-                    } else if ((cur->parent != NULL) &&\n-                               (xmlStrEqual\n-                                (cur->parent->name, BAD_CAST \"nsName\"))) {\n-                        ctxt->flags |= XML_RELAXNG_IN_NSEXCEPT;\n-                        xmlRelaxNGCleanupTree(ctxt, cur);\n-                        ctxt->flags = oldflags;\n-                        goto skip_children;\n-                    }\n-                } else if (xmlStrEqual(cur->name, BAD_CAST \"anyName\")) {\n-                    \/*\n-                     * 4.16\n-                     *\/\n-                    if (ctxt->flags & XML_RELAXNG_IN_ANYEXCEPT) {\n-                        xmlRngPErr(ctxt, cur,\n-                                   XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME,\n-                                   \"Found anyName\/except\/\/anyName forbidden construct\\n\",\n-                                   NULL, NULL);\n-                    } else if (ctxt->flags & XML_RELAXNG_IN_NSEXCEPT) {\n-                        xmlRngPErr(ctxt, cur,\n-                                   XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME,\n-                                   \"Found nsName\/except\/\/anyName forbidden construct\\n\",\n-                                   NULL, NULL);\n-                    }\n-                }\n-                \/*\n-                 * This is not an else since \"include\" is transformed\n-                 * into a div\n-                 *\/\n-                if (xmlStrEqual(cur->name, BAD_CAST \"div\")) {\n-                    xmlChar *ns;\n-                    xmlNodePtr child, ins, tmp;\n-\n-                    \/*\n-                     * implements rule 4.11\n-                     *\/\n-\n-                    ns = xmlGetProp(cur, BAD_CAST \"ns\");\n-\n-                    child = cur->children;\n-                    ins = cur;\n-                    while (child != NULL) {\n-                        if (ns != NULL) {\n-                            if (!xmlHasProp(child, BAD_CAST \"ns\")) {\n-                                xmlSetProp(child, BAD_CAST \"ns\", ns);\n-                            }\n-                        }\n-                        tmp = child->next;\n-                        xmlUnlinkNode(child);\n-                        ins = xmlAddNextSibling(ins, child);\n-                        child = tmp;\n-                    }\n-                    if (ns != NULL)\n-                        xmlFree(ns);\n-            \/*\n-             * Since we are about to delete cur, if its nsDef is non-NULL we\n-             * need to preserve it (it contains the ns definitions for the\n-             * children we just moved).  We'll just stick it on to the end\n-             * of cur->parent's list, since it's never going to be re-serialized\n-             * (bug 143738).\n-             *\/\n-            if ((cur->nsDef != NULL) && (cur->parent != NULL)) {\n-            xmlNsPtr parDef = (xmlNsPtr)&cur->parent->nsDef;\n-            while (parDef->next != NULL)\n-                parDef = parDef->next;\n-            parDef->next = cur->nsDef;\n-            cur->nsDef = NULL;\n-            }\n-                    delete = cur;\n-                    goto skip_children;\n-                }\n-            }\n-        }\n-        \/*\n-         * Simplification 4.2 whitespaces\n-         *\/\n-        else if ((cur->type == XML_TEXT_NODE) ||\n-                 (cur->type == XML_CDATA_SECTION_NODE)) {\n-            if (IS_BLANK_NODE(cur)) {\n-                if ((cur->parent != NULL) &&\n-            (cur->parent->type == XML_ELEMENT_NODE)) {\n-                    if ((!xmlStrEqual(cur->parent->name, BAD_CAST \"value\"))\n-                        &&\n-                        (!xmlStrEqual\n-                         (cur->parent->name, BAD_CAST \"param\")))\n-                        delete = cur;\n-                } else {\n-                    delete = cur;\n-                    goto skip_children;\n-                }\n-            }\n-        } else {\n-            delete = cur;\n-            goto skip_children;\n-        }\n-\n-        \/*\n-         * Skip to next node\n-         *\/\n-        if (cur->children != NULL) {\n-            if ((cur->children->type != XML_ENTITY_DECL) &&\n-                (cur->children->type != XML_ENTITY_REF_NODE) &&\n-                (cur->children->type != XML_ENTITY_NODE)) {\n-                cur = cur->children;\n-                continue;\n-            }\n-        }\n-      skip_children:\n-        if (cur->next != NULL) {\n-            cur = cur->next;\n-            continue;\n-        }\n-\n-        do {\n-            cur = cur->parent;\n-            if (cur == NULL)\n-                break;\n-            if (cur == root) {\n-                cur = NULL;\n-                break;\n-            }\n-            if (cur->next != NULL) {\n-                cur = cur->next;\n-                break;\n-            }\n-        } while (cur != NULL);\n-    }\n-    if (delete != NULL) {\n-        xmlUnlinkNode(delete);\n-        xmlFreeNode(delete);\n-        delete = NULL;\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGCleanupDoc:\n- * @ctxt:  a Relax-NG parser context\n- * @doc:  an xmldocPtr document pointer\n- *\n- * Cleanup the document from unwanted nodes for parsing, resolve\n- * Include and externalRef lookups.\n- *\n- * Returns the cleaned up document or NULL in case of error\n- *\/\n-static xmlDocPtr\n-xmlRelaxNGCleanupDoc(xmlRelaxNGParserCtxtPtr ctxt, xmlDocPtr doc)\n-{\n-    xmlNodePtr root;\n-\n-    \/*\n-     * Extract the root\n-     *\/\n-    root = xmlDocGetRootElement(doc);\n-    if (root == NULL) {\n-        xmlRngPErr(ctxt, (xmlNodePtr) doc, XML_RNGP_EMPTY, \"xmlRelaxNGParse: %s is empty\\n\",\n-                   ctxt->URL, NULL);\n-        return (NULL);\n-    }\n-    xmlRelaxNGCleanupTree(ctxt, root);\n-    return (doc);\n-}\n-\n-\/**\n- * xmlRelaxNGParse:\n- * @ctxt:  a Relax-NG parser context\n- *\n- * parse a schema definition resource and build an internal\n- * XML Schema structure which can be used to validate instances.\n- *\n- * Returns the internal XML RelaxNG structure built from the resource or\n- *         NULL in case of error\n- *\/\n-xmlRelaxNGPtr\n-xmlRelaxNGParse(xmlRelaxNGParserCtxtPtr ctxt)\n-{\n-    xmlRelaxNGPtr ret = NULL;\n-    xmlDocPtr doc;\n-    xmlNodePtr root;\n-\n-    xmlRelaxNGInitTypes();\n-\n-    if (ctxt == NULL)\n-        return (NULL);\n-\n-    \/*\n-     * First step is to parse the input document into an DOM\/Infoset\n-     *\/\n-    if (ctxt->URL != NULL) {\n-        doc = xmlRelaxReadFile(ctxt, (const char *) ctxt->URL);\n-        if (doc == NULL) {\n-            xmlRngPErr(ctxt, NULL, XML_RNGP_PARSE_ERROR,\n-                       \"xmlRelaxNGParse: could not load %s\\n\", ctxt->URL,\n-                       NULL);\n-            return (NULL);\n-        }\n-    } else if (ctxt->buffer != NULL) {\n-        doc = xmlRelaxReadMemory(ctxt, ctxt->buffer, ctxt->size);\n-        if (doc == NULL) {\n-            xmlRngPErr(ctxt, NULL, XML_RNGP_PARSE_ERROR,\n-                       \"xmlRelaxNGParse: could not parse schemas\\n\", NULL,\n-                       NULL);\n-            return (NULL);\n-        }\n-        doc->URL = xmlStrdup(BAD_CAST \"in_memory_buffer\");\n-        ctxt->URL = xmlStrdup(BAD_CAST \"in_memory_buffer\");\n-    } else if (ctxt->document != NULL) {\n-        doc = ctxt->document;\n-    } else {\n-        xmlRngPErr(ctxt, NULL, XML_RNGP_EMPTY,\n-                   \"xmlRelaxNGParse: nothing to parse\\n\", NULL, NULL);\n-        return (NULL);\n-    }\n-    ctxt->document = doc;\n-\n-    \/*\n-     * Some preprocessing of the document content\n-     *\/\n-    doc = xmlRelaxNGCleanupDoc(ctxt, doc);\n-    if (doc == NULL) {\n-        xmlFreeDoc(ctxt->document);\n-        ctxt->document = NULL;\n-        return (NULL);\n-    }\n-\n-    \/*\n-     * Then do the parsing for good\n-     *\/\n-    root = xmlDocGetRootElement(doc);\n-    if (root == NULL) {\n-        xmlRngPErr(ctxt, (xmlNodePtr) doc,\n-               XML_RNGP_EMPTY, \"xmlRelaxNGParse: %s is empty\\n\",\n-                   (ctxt->URL ? ctxt->URL : BAD_CAST \"schemas\"), NULL);\n-\n-        xmlFreeDoc(ctxt->document);\n-        ctxt->document = NULL;\n-        return (NULL);\n-    }\n-    ret = xmlRelaxNGParseDocument(ctxt, root);\n-    if (ret == NULL) {\n-        xmlFreeDoc(ctxt->document);\n-        ctxt->document = NULL;\n-        return (NULL);\n-    }\n-\n-    \/*\n-     * Check the ref\/defines links\n-     *\/\n-    \/*\n-     * try to preprocess interleaves\n-     *\/\n-    if (ctxt->interleaves != NULL) {\n-        xmlHashScan(ctxt->interleaves, xmlRelaxNGComputeInterleaves, ctxt);\n-    }\n-\n-    \/*\n-     * if there was a parsing error return NULL\n-     *\/\n-    if (ctxt->nbErrors > 0) {\n-        xmlRelaxNGFree(ret);\n-        ctxt->document = NULL;\n-        xmlFreeDoc(doc);\n-        return (NULL);\n-    }\n-\n-    \/*\n-     * try to compile (parts of) the schemas\n-     *\/\n-    if ((ret->topgrammar != NULL) && (ret->topgrammar->start != NULL)) {\n-        if (ret->topgrammar->start->type != XML_RELAXNG_START) {\n-            xmlRelaxNGDefinePtr def;\n-\n-            def = xmlRelaxNGNewDefine(ctxt, NULL);\n-            if (def != NULL) {\n-                def->type = XML_RELAXNG_START;\n-                def->content = ret->topgrammar->start;\n-                ret->topgrammar->start = def;\n-            }\n-        }\n-        xmlRelaxNGTryCompile(ctxt, ret->topgrammar->start);\n-    }\n-\n-    \/*\n-     * Transfer the pointer for cleanup at the schema level.\n-     *\/\n-    ret->doc = doc;\n-    ctxt->document = NULL;\n-    ret->documents = ctxt->documents;\n-    ctxt->documents = NULL;\n-\n-    ret->includes = ctxt->includes;\n-    ctxt->includes = NULL;\n-    ret->defNr = ctxt->defNr;\n-    ret->defTab = ctxt->defTab;\n-    ctxt->defTab = NULL;\n-    if (ctxt->idref == 1)\n-        ret->idref = 1;\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGSetParserErrors:\n- * @ctxt:  a Relax-NG validation context\n- * @err:  the error callback\n- * @warn:  the warning callback\n- * @ctx:  contextual data for the callbacks\n- *\n- * DEPRECATED: Use xmlRelaxNGSetParserStructuredErrors.\n- *\n- * Set the callback functions used to handle errors for a validation context\n- *\/\n-void\n-xmlRelaxNGSetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,\n-                          xmlRelaxNGValidityErrorFunc err,\n-                          xmlRelaxNGValidityWarningFunc warn, void *ctx)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    ctxt->error = err;\n-    ctxt->warning = warn;\n-    ctxt->serror = NULL;\n-    ctxt->userData = ctx;\n-}\n-\n-\/**\n- * xmlRelaxNGGetParserErrors:\n- * @ctxt:  a Relax-NG validation context\n- * @err:  the error callback result\n- * @warn:  the warning callback result\n- * @ctx:  contextual data for the callbacks result\n- *\n- * Get the callback information used to handle errors for a validation context\n- *\n- * Returns -1 in case of failure, 0 otherwise.\n- *\/\n-int\n-xmlRelaxNGGetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,\n-                          xmlRelaxNGValidityErrorFunc * err,\n-                          xmlRelaxNGValidityWarningFunc * warn, void **ctx)\n-{\n-    if (ctxt == NULL)\n-        return (-1);\n-    if (err != NULL)\n-        *err = ctxt->error;\n-    if (warn != NULL)\n-        *warn = ctxt->warning;\n-    if (ctx != NULL)\n-        *ctx = ctxt->userData;\n-    return (0);\n-}\n-\n-\/**\n- * xmlRelaxNGSetParserStructuredErrors:\n- * @ctxt:  a Relax-NG parser context\n- * @serror:  the error callback\n- * @ctx:  contextual data for the callbacks\n- *\n- * Set the callback functions used to handle errors for a parsing context\n- *\/\n-void\n-xmlRelaxNGSetParserStructuredErrors(xmlRelaxNGParserCtxtPtr ctxt,\n-                    xmlStructuredErrorFunc serror,\n-                    void *ctx)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    ctxt->serror = serror;\n-    ctxt->error = NULL;\n-    ctxt->warning = NULL;\n-    ctxt->userData = ctx;\n-}\n-\n-#ifdef LIBXML_OUTPUT_ENABLED\n-\n-\/************************************************************************\n- *                                    *\n- *            Dump back a compiled form            *\n- *                                    *\n- ************************************************************************\/\n-static void xmlRelaxNGDumpDefine(FILE * output,\n-                                 xmlRelaxNGDefinePtr define);\n-\n-\/**\n- * xmlRelaxNGDumpDefines:\n- * @output:  the file output\n- * @defines:  a list of define structures\n- *\n- * Dump a RelaxNG structure back\n- *\/\n-static void\n-xmlRelaxNGDumpDefines(FILE * output, xmlRelaxNGDefinePtr defines)\n-{\n-    while (defines != NULL) {\n-        xmlRelaxNGDumpDefine(output, defines);\n-        defines = defines->next;\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGDumpDefine:\n- * @output:  the file output\n- * @define:  a define structure\n- *\n- * Dump a RelaxNG structure back\n- *\/\n-static void\n-xmlRelaxNGDumpDefine(FILE * output, xmlRelaxNGDefinePtr define)\n-{\n-    if (define == NULL)\n-        return;\n-    switch (define->type) {\n-        case XML_RELAXNG_EMPTY:\n-            fprintf(output, \"<empty\/>\\n\");\n-            break;\n-        case XML_RELAXNG_NOT_ALLOWED:\n-            fprintf(output, \"<notAllowed\/>\\n\");\n-            break;\n-        case XML_RELAXNG_TEXT:\n-            fprintf(output, \"<text\/>\\n\");\n-            break;\n-        case XML_RELAXNG_ELEMENT:\n-            fprintf(output, \"<element>\\n\");\n-            if (define->name != NULL) {\n-                fprintf(output, \"<name\");\n-                if (define->ns != NULL)\n-                    fprintf(output, \" ns=\\\"%s\\\"\", define->ns);\n-                fprintf(output, \">%s<\/name>\\n\", define->name);\n-            }\n-            xmlRelaxNGDumpDefines(output, define->attrs);\n-            xmlRelaxNGDumpDefines(output, define->content);\n-            fprintf(output, \"<\/element>\\n\");\n-            break;\n-        case XML_RELAXNG_LIST:\n-            fprintf(output, \"<list>\\n\");\n-            xmlRelaxNGDumpDefines(output, define->content);\n-            fprintf(output, \"<\/list>\\n\");\n-            break;\n-        case XML_RELAXNG_ONEORMORE:\n-            fprintf(output, \"<oneOrMore>\\n\");\n-            xmlRelaxNGDumpDefines(output, define->content);\n-            fprintf(output, \"<\/oneOrMore>\\n\");\n-            break;\n-        case XML_RELAXNG_ZEROORMORE:\n-            fprintf(output, \"<zeroOrMore>\\n\");\n-            xmlRelaxNGDumpDefines(output, define->content);\n-            fprintf(output, \"<\/zeroOrMore>\\n\");\n-            break;\n-        case XML_RELAXNG_CHOICE:\n-            fprintf(output, \"<choice>\\n\");\n-            xmlRelaxNGDumpDefines(output, define->content);\n-            fprintf(output, \"<\/choice>\\n\");\n-            break;\n-        case XML_RELAXNG_GROUP:\n-            fprintf(output, \"<group>\\n\");\n-            xmlRelaxNGDumpDefines(output, define->content);\n-            fprintf(output, \"<\/group>\\n\");\n-            break;\n-        case XML_RELAXNG_INTERLEAVE:\n-            fprintf(output, \"<interleave>\\n\");\n-            xmlRelaxNGDumpDefines(output, define->content);\n-            fprintf(output, \"<\/interleave>\\n\");\n-            break;\n-        case XML_RELAXNG_OPTIONAL:\n-            fprintf(output, \"<optional>\\n\");\n-            xmlRelaxNGDumpDefines(output, define->content);\n-            fprintf(output, \"<\/optional>\\n\");\n-            break;\n-        case XML_RELAXNG_ATTRIBUTE:\n-            fprintf(output, \"<attribute>\\n\");\n-            xmlRelaxNGDumpDefines(output, define->content);\n-            fprintf(output, \"<\/attribute>\\n\");\n-            break;\n-        case XML_RELAXNG_DEF:\n-            fprintf(output, \"<define\");\n-            if (define->name != NULL)\n-                fprintf(output, \" name=\\\"%s\\\"\", define->name);\n-            fprintf(output, \">\\n\");\n-            xmlRelaxNGDumpDefines(output, define->content);\n-            fprintf(output, \"<\/define>\\n\");\n-            break;\n-        case XML_RELAXNG_REF:\n-            fprintf(output, \"<ref\");\n-            if (define->name != NULL)\n-                fprintf(output, \" name=\\\"%s\\\"\", define->name);\n-            fprintf(output, \">\\n\");\n-            xmlRelaxNGDumpDefines(output, define->content);\n-            fprintf(output, \"<\/ref>\\n\");\n-            break;\n-        case XML_RELAXNG_PARENTREF:\n-            fprintf(output, \"<parentRef\");\n-            if (define->name != NULL)\n-                fprintf(output, \" name=\\\"%s\\\"\", define->name);\n-            fprintf(output, \">\\n\");\n-            xmlRelaxNGDumpDefines(output, define->content);\n-            fprintf(output, \"<\/parentRef>\\n\");\n-            break;\n-        case XML_RELAXNG_EXTERNALREF:\n-            fprintf(output, \"<externalRef>\");\n-            xmlRelaxNGDumpDefines(output, define->content);\n-            fprintf(output, \"<\/externalRef>\\n\");\n-            break;\n-        case XML_RELAXNG_DATATYPE:\n-        case XML_RELAXNG_VALUE:\n-            \/* TODO *\/\n-            break;\n-        case XML_RELAXNG_START:\n-        case XML_RELAXNG_EXCEPT:\n-        case XML_RELAXNG_PARAM:\n-            \/* TODO *\/\n-            break;\n-        case XML_RELAXNG_NOOP:\n-            xmlRelaxNGDumpDefines(output, define->content);\n-            break;\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGDumpGrammar:\n- * @output:  the file output\n- * @grammar:  a grammar structure\n- * @top:  is this a top grammar\n- *\n- * Dump a RelaxNG structure back\n- *\/\n-static void\n-xmlRelaxNGDumpGrammar(FILE * output, xmlRelaxNGGrammarPtr grammar, int top)\n-{\n-    if (grammar == NULL)\n-        return;\n-\n-    fprintf(output, \"<grammar\");\n-    if (top)\n-        fprintf(output, \" xmlns=\\\"http:\/\/relaxng.org\/ns\/structure\/1.0\\\"\");\n-    switch (grammar->combine) {\n-        case XML_RELAXNG_COMBINE_UNDEFINED:\n-            break;\n-        case XML_RELAXNG_COMBINE_CHOICE:\n-            fprintf(output, \" combine=\\\"choice\\\"\");\n-            break;\n-        case XML_RELAXNG_COMBINE_INTERLEAVE:\n-            fprintf(output, \" combine=\\\"interleave\\\"\");\n-            break;\n-        default:\n-            fprintf(output, \" <!-- invalid combine value -->\");\n-    }\n-    fprintf(output, \">\\n\");\n-    if (grammar->start == NULL) {\n-        fprintf(output, \" <!-- grammar had no start -->\");\n-    } else {\n-        fprintf(output, \"<start>\\n\");\n-        xmlRelaxNGDumpDefine(output, grammar->start);\n-        fprintf(output, \"<\/start>\\n\");\n-    }\n-    \/* TODO ? Dump the defines ? *\/\n-    fprintf(output, \"<\/grammar>\\n\");\n-}\n-\n-\/**\n- * xmlRelaxNGDump:\n- * @output:  the file output\n- * @schema:  a schema structure\n- *\n- * Dump a RelaxNG structure back\n- *\/\n-void\n-xmlRelaxNGDump(FILE * output, xmlRelaxNGPtr schema)\n-{\n-    if (output == NULL)\n-        return;\n-    if (schema == NULL) {\n-        fprintf(output, \"RelaxNG empty or failed to compile\\n\");\n-        return;\n-    }\n-    fprintf(output, \"RelaxNG: \");\n-    if (schema->doc == NULL) {\n-        fprintf(output, \"no document\\n\");\n-    } else if (schema->doc->URL != NULL) {\n-        fprintf(output, \"%s\\n\", schema->doc->URL);\n-    } else {\n-        fprintf(output, \"\\n\");\n-    }\n-    if (schema->topgrammar == NULL) {\n-        fprintf(output, \"RelaxNG has no top grammar\\n\");\n-        return;\n-    }\n-    xmlRelaxNGDumpGrammar(output, schema->topgrammar, 1);\n-}\n-\n-\/**\n- * xmlRelaxNGDumpTree:\n- * @output:  the file output\n- * @schema:  a schema structure\n- *\n- * Dump the transformed RelaxNG tree.\n- *\/\n-void\n-xmlRelaxNGDumpTree(FILE * output, xmlRelaxNGPtr schema)\n-{\n-    if (output == NULL)\n-        return;\n-    if (schema == NULL) {\n-        fprintf(output, \"RelaxNG empty or failed to compile\\n\");\n-        return;\n-    }\n-    if (schema->doc == NULL) {\n-        fprintf(output, \"no document\\n\");\n-    } else {\n-        xmlDocDump(output, schema->doc);\n-    }\n-}\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-\n-\/************************************************************************\n- *                                    *\n- *        Validation of compiled content                *\n- *                                    *\n- ************************************************************************\/\n-static int xmlRelaxNGValidateDefinition(xmlRelaxNGValidCtxtPtr ctxt,\n-                                        xmlRelaxNGDefinePtr define);\n-\n-\/**\n- * xmlRelaxNGValidateCompiledCallback:\n- * @exec:  the regular expression instance\n- * @token:  the token which matched\n- * @transdata:  callback data, the define for the subelement if available\n- @ @inputdata:  callback data, the Relax NG validation context\n- *\n- * Handle the callback and if needed validate the element children.\n- *\/\n-static void\n-xmlRelaxNGValidateCompiledCallback(xmlRegExecCtxtPtr exec ATTRIBUTE_UNUSED,\n-                                   const xmlChar * token,\n-                                   void *transdata, void *inputdata)\n-{\n-    xmlRelaxNGValidCtxtPtr ctxt = (xmlRelaxNGValidCtxtPtr) inputdata;\n-    xmlRelaxNGDefinePtr define = (xmlRelaxNGDefinePtr) transdata;\n-    int ret;\n-\n-    if (ctxt == NULL) {\n-        fprintf(stderr, \"callback on %s missing context\\n\", token);\n-        return;\n-    }\n-    if (define == NULL) {\n-        if (token[0] == '#')\n-            return;\n-        fprintf(stderr, \"callback on %s missing define\\n\", token);\n-        if ((ctxt != NULL) && (ctxt->errNo == XML_RELAXNG_OK))\n-            ctxt->errNo = XML_RELAXNG_ERR_INTERNAL;\n-        return;\n-    }\n-    if (define->type != XML_RELAXNG_ELEMENT) {\n-        fprintf(stderr, \"callback on %s define is not element\\n\", token);\n-        if (ctxt->errNo == XML_RELAXNG_OK)\n-            ctxt->errNo = XML_RELAXNG_ERR_INTERNAL;\n-        return;\n-    }\n-    ret = xmlRelaxNGValidateDefinition(ctxt, define);\n-    if (ret != 0)\n-        ctxt->perr = ret;\n-}\n-\n-\/**\n- * xmlRelaxNGValidateCompiledContent:\n- * @ctxt:  the RelaxNG validation context\n- * @regexp:  the regular expression as compiled\n- * @content:  list of children to test against the regexp\n- *\n- * Validate the content model of an element or start using the regexp\n- *\n- * Returns 0 in case of success, -1 in case of error.\n- *\/\n-static int\n-xmlRelaxNGValidateCompiledContent(xmlRelaxNGValidCtxtPtr ctxt,\n-                                  xmlRegexpPtr regexp, xmlNodePtr content)\n-{\n-    xmlRegExecCtxtPtr exec;\n-    xmlNodePtr cur;\n-    int ret = 0;\n-    int oldperr;\n-\n-    if ((ctxt == NULL) || (regexp == NULL))\n-        return (-1);\n-    oldperr = ctxt->perr;\n-    exec = xmlRegNewExecCtxt(regexp,\n-                             xmlRelaxNGValidateCompiledCallback, ctxt);\n-    ctxt->perr = 0;\n-    cur = content;\n-    while (cur != NULL) {\n-        ctxt->state->seq = cur;\n-        switch (cur->type) {\n-            case XML_TEXT_NODE:\n-            case XML_CDATA_SECTION_NODE:\n-                if (xmlIsBlankNode(cur))\n-                    break;\n-                ret = xmlRegExecPushString(exec, BAD_CAST \"#text\", ctxt);\n-                if (ret < 0) {\n-                    VALID_ERR2(XML_RELAXNG_ERR_TEXTWRONG,\n-                               cur->parent->name);\n-                }\n-                break;\n-            case XML_ELEMENT_NODE:\n-                if (cur->ns != NULL) {\n-                    ret = xmlRegExecPushString2(exec, cur->name,\n-                                                cur->ns->href, ctxt);\n-                } else {\n-                    ret = xmlRegExecPushString(exec, cur->name, ctxt);\n-                }\n-                if (ret < 0) {\n-                    VALID_ERR2(XML_RELAXNG_ERR_ELEMWRONG, cur->name);\n-                }\n-                break;\n-            default:\n-                break;\n-        }\n-        if (ret < 0)\n-            break;\n-        \/*\n-         * Switch to next element\n-         *\/\n-        cur = cur->next;\n-    }\n-    ret = xmlRegExecPushString(exec, NULL, NULL);\n-    if (ret == 1) {\n-        ret = 0;\n-        ctxt->state->seq = NULL;\n-    } else if (ret == 0) {\n-        \/*\n-         * TODO: get some of the names needed to exit the current state of exec\n-         *\/\n-        VALID_ERR2(XML_RELAXNG_ERR_NOELEM, BAD_CAST \"\");\n-        ret = -1;\n-        if ((ctxt->flags & FLAGS_IGNORABLE) == 0)\n-            xmlRelaxNGDumpValidError(ctxt);\n-    } else {\n-        ret = -1;\n-    }\n-    xmlRegFreeExecCtxt(exec);\n-    \/*\n-     * There might be content model errors outside of the pure\n-     * regexp validation, e.g. for attribute values.\n-     *\/\n-    if ((ret == 0) && (ctxt->perr != 0)) {\n-        ret = ctxt->perr;\n-    }\n-    ctxt->perr = oldperr;\n-    return (ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Progressive validation of when possible            *\n- *                                    *\n- ************************************************************************\/\n-static int xmlRelaxNGValidateAttributeList(xmlRelaxNGValidCtxtPtr ctxt,\n-                                           xmlRelaxNGDefinePtr defines);\n-static int xmlRelaxNGValidateElementEnd(xmlRelaxNGValidCtxtPtr ctxt,\n-                                        int dolog);\n-static void xmlRelaxNGLogBestError(xmlRelaxNGValidCtxtPtr ctxt);\n-\n-\/**\n- * xmlRelaxNGElemPush:\n- * @ctxt:  the validation context\n- * @exec:  the regexp runtime for the new content model\n- *\n- * Push a new regexp for the current node content model on the stack\n- *\n- * Returns 0 in case of success and -1 in case of error.\n- *\/\n-static int\n-xmlRelaxNGElemPush(xmlRelaxNGValidCtxtPtr ctxt, xmlRegExecCtxtPtr exec)\n-{\n-    if (ctxt->elemTab == NULL) {\n-        ctxt->elemMax = 10;\n-        ctxt->elemTab = (xmlRegExecCtxtPtr *) xmlMalloc(ctxt->elemMax *\n-                                                        sizeof\n-                                                        (xmlRegExecCtxtPtr));\n-        if (ctxt->elemTab == NULL) {\n-            xmlRngVErrMemory(ctxt);\n-            return (-1);\n-        }\n-    }\n-    if (ctxt->elemNr >= ctxt->elemMax) {\n-        ctxt->elemMax *= 2;\n-        ctxt->elemTab = (xmlRegExecCtxtPtr *) xmlRealloc(ctxt->elemTab,\n-                                                         ctxt->elemMax *\n-                                                         sizeof\n-                                                         (xmlRegExecCtxtPtr));\n-        if (ctxt->elemTab == NULL) {\n-            xmlRngVErrMemory(ctxt);\n-            return (-1);\n-        }\n-    }\n-    ctxt->elemTab[ctxt->elemNr++] = exec;\n-    ctxt->elem = exec;\n-    return (0);\n-}\n-\n-\/**\n- * xmlRelaxNGElemPop:\n- * @ctxt:  the validation context\n- *\n- * Pop the regexp of the current node content model from the stack\n- *\n- * Returns the exec or NULL if empty\n- *\/\n-static xmlRegExecCtxtPtr\n-xmlRelaxNGElemPop(xmlRelaxNGValidCtxtPtr ctxt)\n-{\n-    xmlRegExecCtxtPtr ret;\n-\n-    if (ctxt->elemNr <= 0)\n-        return (NULL);\n-    ctxt->elemNr--;\n-    ret = ctxt->elemTab[ctxt->elemNr];\n-    ctxt->elemTab[ctxt->elemNr] = NULL;\n-    if (ctxt->elemNr > 0)\n-        ctxt->elem = ctxt->elemTab[ctxt->elemNr - 1];\n-    else\n-        ctxt->elem = NULL;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGValidateProgressiveCallback:\n- * @exec:  the regular expression instance\n- * @token:  the token which matched\n- * @transdata:  callback data, the define for the subelement if available\n- @ @inputdata:  callback data, the Relax NG validation context\n- *\n- * Handle the callback and if needed validate the element children.\n- * some of the in\/out information are passed via the context in @inputdata.\n- *\/\n-static void\n-xmlRelaxNGValidateProgressiveCallback(xmlRegExecCtxtPtr exec\n-                                      ATTRIBUTE_UNUSED,\n-                                      const xmlChar * token,\n-                                      void *transdata, void *inputdata)\n-{\n-    xmlRelaxNGValidCtxtPtr ctxt = (xmlRelaxNGValidCtxtPtr) inputdata;\n-    xmlRelaxNGDefinePtr define = (xmlRelaxNGDefinePtr) transdata;\n-    xmlRelaxNGValidStatePtr state, oldstate;\n-    xmlNodePtr node;\n-    int ret = 0, oldflags;\n-\n-    if (ctxt == NULL) {\n-        fprintf(stderr, \"callback on %s missing context\\n\", token);\n-        return;\n-    }\n-    node = ctxt->pnode;\n-    ctxt->pstate = 1;\n-    if (define == NULL) {\n-        if (token[0] == '#')\n-            return;\n-        fprintf(stderr, \"callback on %s missing define\\n\", token);\n-        if ((ctxt != NULL) && (ctxt->errNo == XML_RELAXNG_OK))\n-            ctxt->errNo = XML_RELAXNG_ERR_INTERNAL;\n-        ctxt->pstate = -1;\n-        return;\n-    }\n-    if (define->type != XML_RELAXNG_ELEMENT) {\n-        fprintf(stderr, \"callback on %s define is not element\\n\", token);\n-        if (ctxt->errNo == XML_RELAXNG_OK)\n-            ctxt->errNo = XML_RELAXNG_ERR_INTERNAL;\n-        ctxt->pstate = -1;\n-        return;\n-    }\n-    if (node->type != XML_ELEMENT_NODE) {\n-        VALID_ERR(XML_RELAXNG_ERR_NOTELEM);\n-        if ((ctxt->flags & FLAGS_IGNORABLE) == 0)\n-            xmlRelaxNGDumpValidError(ctxt);\n-        ctxt->pstate = -1;\n-        return;\n-    }\n-    if (define->contModel == NULL) {\n-        \/*\n-         * this node cannot be validated in a streamable fashion\n-         *\/\n-        ctxt->pstate = 0;\n-        ctxt->pdef = define;\n-        return;\n-    }\n-    exec = xmlRegNewExecCtxt(define->contModel,\n-                             xmlRelaxNGValidateProgressiveCallback, ctxt);\n-    if (exec == NULL) {\n-        ctxt->pstate = -1;\n-        return;\n-    }\n-    xmlRelaxNGElemPush(ctxt, exec);\n-\n-    \/*\n-     * Validate the attributes part of the content.\n-     *\/\n-    state = xmlRelaxNGNewValidState(ctxt, node);\n-    if (state == NULL) {\n-        ctxt->pstate = -1;\n-        return;\n-    }\n-    oldstate = ctxt->state;\n-    ctxt->state = state;\n-    if (define->attrs != NULL) {\n-        ret = xmlRelaxNGValidateAttributeList(ctxt, define->attrs);\n-        if (ret != 0) {\n-            ctxt->pstate = -1;\n-            VALID_ERR2(XML_RELAXNG_ERR_ATTRVALID, node->name);\n-        }\n-    }\n-    if (ctxt->state != NULL) {\n-        ctxt->state->seq = NULL;\n-        ret = xmlRelaxNGValidateElementEnd(ctxt, 1);\n-        if (ret != 0) {\n-            ctxt->pstate = -1;\n-        }\n-        xmlRelaxNGFreeValidState(ctxt, ctxt->state);\n-    } else if (ctxt->states != NULL) {\n-        int tmp = -1, i;\n-\n-        oldflags = ctxt->flags;\n-\n-        for (i = 0; i < ctxt->states->nbState; i++) {\n-            state = ctxt->states->tabState[i];\n-            ctxt->state = state;\n-            ctxt->state->seq = NULL;\n-\n-            if (xmlRelaxNGValidateElementEnd(ctxt, 0) == 0) {\n-                tmp = 0;\n-                break;\n-            }\n-        }\n-        if (tmp != 0) {\n-            \/*\n-             * validation error, log the message for the \"best\" one\n-             *\/\n-            ctxt->flags |= FLAGS_IGNORABLE;\n-            xmlRelaxNGLogBestError(ctxt);\n-        }\n-        for (i = 0; i < ctxt->states->nbState; i++) {\n-            xmlRelaxNGFreeValidState(ctxt, ctxt->states->tabState[i]);\n-        }\n-        xmlRelaxNGFreeStates(ctxt, ctxt->states);\n-        ctxt->states = NULL;\n-        if ((ret == 0) && (tmp == -1))\n-            ctxt->pstate = -1;\n-        ctxt->flags = oldflags;\n-    }\n-    if (ctxt->pstate == -1) {\n-        if ((ctxt->flags & FLAGS_IGNORABLE) == 0) {\n-            xmlRelaxNGDumpValidError(ctxt);\n-        }\n-    }\n-    ctxt->state = oldstate;\n-}\n-\n-\/**\n- * xmlRelaxNGValidatePushElement:\n- * @ctxt:  the validation context\n- * @doc:  a document instance\n- * @elem:  an element instance\n- *\n- * Push a new element start on the RelaxNG validation stack.\n- *\n- * returns 1 if no validation problem was found or 0 if validating the\n- *         element requires a full node, and -1 in case of error.\n- *\/\n-int\n-xmlRelaxNGValidatePushElement(xmlRelaxNGValidCtxtPtr ctxt,\n-                              xmlDocPtr doc ATTRIBUTE_UNUSED,\n-                              xmlNodePtr elem)\n-{\n-    int ret = 1;\n-\n-    if ((ctxt == NULL) || (elem == NULL))\n-        return (-1);\n-\n-    if (ctxt->elem == 0) {\n-        xmlRelaxNGPtr schema;\n-        xmlRelaxNGGrammarPtr grammar;\n-        xmlRegExecCtxtPtr exec;\n-        xmlRelaxNGDefinePtr define;\n-\n-        schema = ctxt->schema;\n-        if (schema == NULL) {\n-            VALID_ERR(XML_RELAXNG_ERR_NOGRAMMAR);\n-            return (-1);\n-        }\n-        grammar = schema->topgrammar;\n-        if ((grammar == NULL) || (grammar->start == NULL)) {\n-            VALID_ERR(XML_RELAXNG_ERR_NOGRAMMAR);\n-            return (-1);\n-        }\n-        define = grammar->start;\n-        if (define->contModel == NULL) {\n-            ctxt->pdef = define;\n-            return (0);\n-        }\n-        exec = xmlRegNewExecCtxt(define->contModel,\n-                                 xmlRelaxNGValidateProgressiveCallback,\n-                                 ctxt);\n-        if (exec == NULL) {\n-            return (-1);\n-        }\n-        xmlRelaxNGElemPush(ctxt, exec);\n-    }\n-    ctxt->pnode = elem;\n-    ctxt->pstate = 0;\n-    if (elem->ns != NULL) {\n-        ret =\n-            xmlRegExecPushString2(ctxt->elem, elem->name, elem->ns->href,\n-                                  ctxt);\n-    } else {\n-        ret = xmlRegExecPushString(ctxt->elem, elem->name, ctxt);\n-    }\n-    if (ret < 0) {\n-        VALID_ERR2(XML_RELAXNG_ERR_ELEMWRONG, elem->name);\n-    } else {\n-        if (ctxt->pstate == 0)\n-            ret = 0;\n-        else if (ctxt->pstate < 0)\n-            ret = -1;\n-        else\n-            ret = 1;\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGValidatePushCData:\n- * @ctxt:  the RelaxNG validation context\n- * @data:  some character data read\n- * @len:  the length of the data\n- *\n- * check the CData parsed for validation in the current stack\n- *\n- * returns 1 if no validation problem was found or -1 otherwise\n- *\/\n-int\n-xmlRelaxNGValidatePushCData(xmlRelaxNGValidCtxtPtr ctxt,\n-                            const xmlChar * data, int len ATTRIBUTE_UNUSED)\n-{\n-    int ret = 1;\n-\n-    if ((ctxt == NULL) || (ctxt->elem == NULL) || (data == NULL))\n-        return (-1);\n-\n-    while (*data != 0) {\n-        if (!IS_BLANK_CH(*data))\n-            break;\n-        data++;\n-    }\n-    if (*data == 0)\n-        return (1);\n-\n-    ret = xmlRegExecPushString(ctxt->elem, BAD_CAST \"#text\", ctxt);\n-    if (ret < 0) {\n-        VALID_ERR2(XML_RELAXNG_ERR_TEXTWRONG, BAD_CAST \" TODO \");\n-\n-        return (-1);\n-    }\n-    return (1);\n-}\n-\n-\/**\n- * xmlRelaxNGValidatePopElement:\n- * @ctxt:  the RelaxNG validation context\n- * @doc:  a document instance\n- * @elem:  an element instance\n- *\n- * Pop the element end from the RelaxNG validation stack.\n- *\n- * returns 1 if no validation problem was found or 0 otherwise\n- *\/\n-int\n-xmlRelaxNGValidatePopElement(xmlRelaxNGValidCtxtPtr ctxt,\n-                             xmlDocPtr doc ATTRIBUTE_UNUSED,\n-                             xmlNodePtr elem)\n-{\n-    int ret;\n-    xmlRegExecCtxtPtr exec;\n-\n-    if ((ctxt == NULL) || (ctxt->elem == NULL) || (elem == NULL))\n-        return (-1);\n-    \/*\n-     * verify that we reached a terminal state of the content model.\n-     *\/\n-    exec = xmlRelaxNGElemPop(ctxt);\n-    ret = xmlRegExecPushString(exec, NULL, NULL);\n-    if (ret == 0) {\n-        \/*\n-         * TODO: get some of the names needed to exit the current state of exec\n-         *\/\n-        VALID_ERR2(XML_RELAXNG_ERR_NOELEM, BAD_CAST \"\");\n-        ret = -1;\n-    } else if (ret < 0) {\n-        ret = -1;\n-    } else {\n-        ret = 1;\n-    }\n-    xmlRegFreeExecCtxt(exec);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGValidateFullElement:\n- * @ctxt:  the validation context\n- * @doc:  a document instance\n- * @elem:  an element instance\n- *\n- * Validate a full subtree when xmlRelaxNGValidatePushElement() returned\n- * 0 and the content of the node has been expanded.\n- *\n- * returns 1 if no validation problem was found or -1 in case of error.\n- *\/\n-int\n-xmlRelaxNGValidateFullElement(xmlRelaxNGValidCtxtPtr ctxt,\n-                              xmlDocPtr doc ATTRIBUTE_UNUSED,\n-                              xmlNodePtr elem)\n-{\n-    int ret;\n-    xmlRelaxNGValidStatePtr state;\n-\n-    if ((ctxt == NULL) || (ctxt->pdef == NULL) || (elem == NULL))\n-        return (-1);\n-    state = xmlRelaxNGNewValidState(ctxt, elem->parent);\n-    if (state == NULL) {\n-        return (-1);\n-    }\n-    state->seq = elem;\n-    ctxt->state = state;\n-    ctxt->errNo = XML_RELAXNG_OK;\n-    ret = xmlRelaxNGValidateDefinition(ctxt, ctxt->pdef);\n-    if ((ret != 0) || (ctxt->errNo != XML_RELAXNG_OK))\n-        ret = -1;\n-    else\n-        ret = 1;\n-    xmlRelaxNGFreeValidState(ctxt, ctxt->state);\n-    ctxt->state = NULL;\n-    return (ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Generic interpreted validation implementation        *\n- *                                    *\n- ************************************************************************\/\n-static int xmlRelaxNGValidateValue(xmlRelaxNGValidCtxtPtr ctxt,\n-                                   xmlRelaxNGDefinePtr define);\n-\n-\/**\n- * xmlRelaxNGSkipIgnored:\n- * @ctxt:  a schema validation context\n- * @node:  the top node.\n- *\n- * Skip ignorable nodes in that context\n- *\n- * Returns the new sibling or NULL in case of error.\n- *\/\n-static xmlNodePtr\n-xmlRelaxNGSkipIgnored(xmlRelaxNGValidCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-                      xmlNodePtr node)\n-{\n-    \/*\n-     * TODO complete and handle entities\n-     *\/\n-    while ((node != NULL) &&\n-           ((node->type == XML_COMMENT_NODE) ||\n-            (node->type == XML_PI_NODE) ||\n-        (node->type == XML_XINCLUDE_START) ||\n-        (node->type == XML_XINCLUDE_END) ||\n-            (((node->type == XML_TEXT_NODE) ||\n-              (node->type == XML_CDATA_SECTION_NODE)) &&\n-             ((ctxt->flags & FLAGS_MIXED_CONTENT) ||\n-              (IS_BLANK_NODE(node)))))) {\n-        node = node->next;\n-    }\n-    return (node);\n-}\n-\n-\/**\n- * xmlRelaxNGNormalize:\n- * @ctxt:  a schema validation context\n- * @str:  the string to normalize\n- *\n- * Implements the  normalizeWhiteSpace( s ) function from\n- * section 6.2.9 of the spec\n- *\n- * Returns the new string or NULL in case of error.\n- *\/\n-static xmlChar *\n-xmlRelaxNGNormalize(xmlRelaxNGValidCtxtPtr ctxt, const xmlChar * str)\n-{\n-    xmlChar *ret, *p;\n-    const xmlChar *tmp;\n-    int len;\n-\n-    if (str == NULL)\n-        return (NULL);\n-    tmp = str;\n-    while (*tmp != 0)\n-        tmp++;\n-    len = tmp - str;\n-\n-    ret = (xmlChar *) xmlMallocAtomic(len + 1);\n-    if (ret == NULL) {\n-        xmlRngVErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    p = ret;\n-    while (IS_BLANK_CH(*str))\n-        str++;\n-    while (*str != 0) {\n-        if (IS_BLANK_CH(*str)) {\n-            while (IS_BLANK_CH(*str))\n-                str++;\n-            if (*str == 0)\n-                break;\n-            *p++ = ' ';\n-        } else\n-            *p++ = *str++;\n-    }\n-    *p = 0;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGValidateDatatype:\n- * @ctxt:  a Relax-NG validation context\n- * @value:  the string value\n- * @type:  the datatype definition\n- * @node:  the node\n- *\n- * Validate the given value against the datatype\n- *\n- * Returns 0 if the validation succeeded or an error code.\n- *\/\n-static int\n-xmlRelaxNGValidateDatatype(xmlRelaxNGValidCtxtPtr ctxt,\n-                           const xmlChar * value,\n-                           xmlRelaxNGDefinePtr define, xmlNodePtr node)\n-{\n-    int ret, tmp;\n-    xmlRelaxNGTypeLibraryPtr lib;\n-    void *result = NULL;\n-    xmlRelaxNGDefinePtr cur;\n-\n-    if ((define == NULL) || (define->data == NULL)) {\n-        return (-1);\n-    }\n-    lib = (xmlRelaxNGTypeLibraryPtr) define->data;\n-    if (lib->check != NULL) {\n-        if ((define->attrs != NULL) &&\n-            (define->attrs->type == XML_RELAXNG_PARAM)) {\n-            ret =\n-                lib->check(lib->data, define->name, value, &result, node);\n-        } else {\n-            ret = lib->check(lib->data, define->name, value, NULL, node);\n-        }\n-    } else\n-        ret = -1;\n-    if (ret < 0) {\n-        VALID_ERR2(XML_RELAXNG_ERR_TYPE, define->name);\n-        if ((result != NULL) && (lib != NULL) && (lib->freef != NULL))\n-            lib->freef(lib->data, result);\n-        return (-1);\n-    } else if (ret == 1) {\n-        ret = 0;\n-    } else if (ret == 2) {\n-        VALID_ERR2P(XML_RELAXNG_ERR_DUPID, value);\n-    } else {\n-        VALID_ERR3P(XML_RELAXNG_ERR_TYPEVAL, define->name, value);\n-        ret = -1;\n-    }\n-    cur = define->attrs;\n-    while ((ret == 0) && (cur != NULL) && (cur->type == XML_RELAXNG_PARAM)) {\n-        if (lib->facet != NULL) {\n-            tmp = lib->facet(lib->data, define->name, cur->name,\n-                             cur->value, value, result);\n-            if (tmp != 0)\n-                ret = -1;\n-        }\n-        cur = cur->next;\n-    }\n-    if ((ret == 0) && (define->content != NULL)) {\n-        const xmlChar *oldvalue, *oldendvalue;\n-\n-        oldvalue = ctxt->state->value;\n-        oldendvalue = ctxt->state->endvalue;\n-        ctxt->state->value = (xmlChar *) value;\n-        ctxt->state->endvalue = NULL;\n-        ret = xmlRelaxNGValidateValue(ctxt, define->content);\n-        ctxt->state->value = (xmlChar *) oldvalue;\n-        ctxt->state->endvalue = (xmlChar *) oldendvalue;\n-    }\n-    if ((result != NULL) && (lib != NULL) && (lib->freef != NULL))\n-        lib->freef(lib->data, result);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGNextValue:\n- * @ctxt:  a Relax-NG validation context\n- *\n- * Skip to the next value when validating within a list\n- *\n- * Returns 0 if the operation succeeded or an error code.\n- *\/\n-static int\n-xmlRelaxNGNextValue(xmlRelaxNGValidCtxtPtr ctxt)\n-{\n-    xmlChar *cur;\n-\n-    cur = ctxt->state->value;\n-    if ((cur == NULL) || (ctxt->state->endvalue == NULL)) {\n-        ctxt->state->value = NULL;\n-        ctxt->state->endvalue = NULL;\n-        return (0);\n-    }\n-    while (*cur != 0)\n-        cur++;\n-    while ((cur != ctxt->state->endvalue) && (*cur == 0))\n-        cur++;\n-    if (cur == ctxt->state->endvalue)\n-        ctxt->state->value = NULL;\n-    else\n-        ctxt->state->value = cur;\n-    return (0);\n-}\n-\n-\/**\n- * xmlRelaxNGValidateValueList:\n- * @ctxt:  a Relax-NG validation context\n- * @defines:  the list of definitions to verify\n- *\n- * Validate the given set of definitions for the current value\n- *\n- * Returns 0 if the validation succeeded or an error code.\n- *\/\n-static int\n-xmlRelaxNGValidateValueList(xmlRelaxNGValidCtxtPtr ctxt,\n-                            xmlRelaxNGDefinePtr defines)\n-{\n-    int ret = 0;\n-\n-    while (defines != NULL) {\n-        ret = xmlRelaxNGValidateValue(ctxt, defines);\n-        if (ret != 0)\n-            break;\n-        defines = defines->next;\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGValidateValue:\n- * @ctxt:  a Relax-NG validation context\n- * @define:  the definition to verify\n- *\n- * Validate the given definition for the current value\n- *\n- * Returns 0 if the validation succeeded or an error code.\n- *\/\n-static int\n-xmlRelaxNGValidateValue(xmlRelaxNGValidCtxtPtr ctxt,\n-                        xmlRelaxNGDefinePtr define)\n-{\n-    int ret = 0, oldflags;\n-    xmlChar *value;\n-\n-    value = ctxt->state->value;\n-    switch (define->type) {\n-        case XML_RELAXNG_EMPTY:{\n-                if ((value != NULL) && (value[0] != 0)) {\n-                    int idx = 0;\n-\n-                    while (IS_BLANK_CH(value[idx]))\n-                        idx++;\n-                    if (value[idx] != 0)\n-                        ret = -1;\n-                }\n-                break;\n-            }\n-        case XML_RELAXNG_TEXT:\n-            break;\n-        case XML_RELAXNG_VALUE:{\n-                if (!xmlStrEqual(value, define->value)) {\n-                    if (define->name != NULL) {\n-                        xmlRelaxNGTypeLibraryPtr lib;\n-\n-                        lib = (xmlRelaxNGTypeLibraryPtr) define->data;\n-                        if ((lib != NULL) && (lib->comp != NULL)) {\n-                            ret = lib->comp(lib->data, define->name,\n-                                            define->value, define->node,\n-                                            (void *) define->attrs,\n-                                            value, ctxt->state->node);\n-                        } else\n-                            ret = -1;\n-                        if (ret < 0) {\n-                            VALID_ERR2(XML_RELAXNG_ERR_TYPECMP,\n-                                       define->name);\n-                            return (-1);\n-                        } else if (ret == 1) {\n-                            ret = 0;\n-                        } else {\n-                            ret = -1;\n-                        }\n-                    } else {\n-                        xmlChar *nval, *nvalue;\n-\n-                        \/*\n-                         * TODO: trivial optimizations are possible by\n-                         * computing at compile-time\n-                         *\/\n-                        nval = xmlRelaxNGNormalize(ctxt, define->value);\n-                        nvalue = xmlRelaxNGNormalize(ctxt, value);\n-\n-                        if ((nval == NULL) || (nvalue == NULL) ||\n-                            (!xmlStrEqual(nval, nvalue)))\n-                            ret = -1;\n-                        if (nval != NULL)\n-                            xmlFree(nval);\n-                        if (nvalue != NULL)\n-                            xmlFree(nvalue);\n-                    }\n-                }\n-                if (ret == 0)\n-                    xmlRelaxNGNextValue(ctxt);\n-                break;\n-            }\n-        case XML_RELAXNG_DATATYPE:{\n-                ret = xmlRelaxNGValidateDatatype(ctxt, value, define,\n-                                                 ctxt->state->seq);\n-                if (ret == 0)\n-                    xmlRelaxNGNextValue(ctxt);\n-\n-                break;\n-            }\n-        case XML_RELAXNG_CHOICE:{\n-                xmlRelaxNGDefinePtr list = define->content;\n-                xmlChar *oldvalue;\n-\n-                oldflags = ctxt->flags;\n-                ctxt->flags |= FLAGS_IGNORABLE;\n-\n-                oldvalue = ctxt->state->value;\n-                while (list != NULL) {\n-                    ret = xmlRelaxNGValidateValue(ctxt, list);\n-                    if (ret == 0) {\n-                        break;\n-                    }\n-                    ctxt->state->value = oldvalue;\n-                    list = list->next;\n-                }\n-                ctxt->flags = oldflags;\n-                if (ret != 0) {\n-                    if ((ctxt->flags & FLAGS_IGNORABLE) == 0)\n-                        xmlRelaxNGDumpValidError(ctxt);\n-                } else {\n-                    if (ctxt->errNr > 0)\n-                        xmlRelaxNGPopErrors(ctxt, 0);\n-                }\n-                break;\n-            }\n-        case XML_RELAXNG_LIST:{\n-                xmlRelaxNGDefinePtr list = define->content;\n-                xmlChar *oldvalue, *oldend, *val, *cur;\n-\n-                oldvalue = ctxt->state->value;\n-                oldend = ctxt->state->endvalue;\n-\n-                val = xmlStrdup(oldvalue);\n-                if (val == NULL) {\n-                    val = xmlStrdup(BAD_CAST \"\");\n-                }\n-                if (val == NULL) {\n-                    VALID_ERR(XML_RELAXNG_ERR_NOSTATE);\n-                    return (-1);\n-                }\n-                cur = val;\n-                while (*cur != 0) {\n-                    if (IS_BLANK_CH(*cur)) {\n-                        *cur = 0;\n-                        cur++;\n-                        while (IS_BLANK_CH(*cur))\n-                            *cur++ = 0;\n-                    } else\n-                        cur++;\n-                }\n-                ctxt->state->endvalue = cur;\n-                cur = val;\n-                while ((*cur == 0) && (cur != ctxt->state->endvalue))\n-                    cur++;\n-\n-                ctxt->state->value = cur;\n-\n-                while (list != NULL) {\n-                    if (ctxt->state->value == ctxt->state->endvalue)\n-                        ctxt->state->value = NULL;\n-                    ret = xmlRelaxNGValidateValue(ctxt, list);\n-                    if (ret != 0) {\n-                        break;\n-                    }\n-                    list = list->next;\n-                }\n-\n-                if ((ret == 0) && (ctxt->state->value != NULL) &&\n-                    (ctxt->state->value != ctxt->state->endvalue)) {\n-                    VALID_ERR2(XML_RELAXNG_ERR_LISTEXTRA,\n-                               ctxt->state->value);\n-                    ret = -1;\n-                }\n-                xmlFree(val);\n-                ctxt->state->value = oldvalue;\n-                ctxt->state->endvalue = oldend;\n-                break;\n-            }\n-        case XML_RELAXNG_ONEORMORE:\n-            ret = xmlRelaxNGValidateValueList(ctxt, define->content);\n-            if (ret != 0) {\n-                break;\n-            }\n-            \/* Falls through. *\/\n-        case XML_RELAXNG_ZEROORMORE:{\n-                xmlChar *cur, *temp;\n-\n-                if ((ctxt->state->value == NULL) ||\n-                    (*ctxt->state->value == 0)) {\n-                    ret = 0;\n-                    break;\n-                }\n-                oldflags = ctxt->flags;\n-                ctxt->flags |= FLAGS_IGNORABLE;\n-                cur = ctxt->state->value;\n-                temp = NULL;\n-                while ((cur != NULL) && (cur != ctxt->state->endvalue) &&\n-                       (temp != cur)) {\n-                    temp = cur;\n-                    ret =\n-                        xmlRelaxNGValidateValueList(ctxt, define->content);\n-                    if (ret != 0) {\n-                        ctxt->state->value = temp;\n-                        ret = 0;\n-                        break;\n-                    }\n-                    cur = ctxt->state->value;\n-                }\n-                ctxt->flags = oldflags;\n-        if (ctxt->errNr > 0)\n-            xmlRelaxNGPopErrors(ctxt, 0);\n-                break;\n-            }\n-        case XML_RELAXNG_OPTIONAL:{\n-                xmlChar *temp;\n-\n-                if ((ctxt->state->value == NULL) ||\n-                    (*ctxt->state->value == 0)) {\n-                    ret = 0;\n-                    break;\n-                }\n-                oldflags = ctxt->flags;\n-                ctxt->flags |= FLAGS_IGNORABLE;\n-                temp = ctxt->state->value;\n-                ret = xmlRelaxNGValidateValue(ctxt, define->content);\n-                ctxt->flags = oldflags;\n-                if (ret != 0) {\n-                    ctxt->state->value = temp;\n-                    if (ctxt->errNr > 0)\n-                        xmlRelaxNGPopErrors(ctxt, 0);\n-                    ret = 0;\n-                    break;\n-                }\n-        if (ctxt->errNr > 0)\n-            xmlRelaxNGPopErrors(ctxt, 0);\n-                break;\n-            }\n-        case XML_RELAXNG_EXCEPT:{\n-                xmlRelaxNGDefinePtr list;\n-\n-                list = define->content;\n-                while (list != NULL) {\n-                    ret = xmlRelaxNGValidateValue(ctxt, list);\n-                    if (ret == 0) {\n-                        ret = -1;\n-                        break;\n-                    } else\n-                        ret = 0;\n-                    list = list->next;\n-                }\n-                break;\n-            }\n-        case XML_RELAXNG_DEF:\n-        case XML_RELAXNG_GROUP:{\n-                xmlRelaxNGDefinePtr list;\n-\n-                list = define->content;\n-                while (list != NULL) {\n-                    ret = xmlRelaxNGValidateValue(ctxt, list);\n-                    if (ret != 0) {\n-                        ret = -1;\n-                        break;\n-                    } else\n-                        ret = 0;\n-                    list = list->next;\n-                }\n-                break;\n-            }\n-        case XML_RELAXNG_REF:\n-        case XML_RELAXNG_PARENTREF:\n-        if (define->content == NULL) {\n-                VALID_ERR(XML_RELAXNG_ERR_NODEFINE);\n-                ret = -1;\n-        } else {\n-                ret = xmlRelaxNGValidateValue(ctxt, define->content);\n-            }\n-            break;\n-        default:\n-            \/* TODO *\/\n-            ret = -1;\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGValidateValueContent:\n- * @ctxt:  a Relax-NG validation context\n- * @defines:  the list of definitions to verify\n- *\n- * Validate the given definitions for the current value\n- *\n- * Returns 0 if the validation succeeded or an error code.\n- *\/\n-static int\n-xmlRelaxNGValidateValueContent(xmlRelaxNGValidCtxtPtr ctxt,\n-                               xmlRelaxNGDefinePtr defines)\n-{\n-    int ret = 0;\n-\n-    while (defines != NULL) {\n-        ret = xmlRelaxNGValidateValue(ctxt, defines);\n-        if (ret != 0)\n-            break;\n-        defines = defines->next;\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGAttributeMatch:\n- * @ctxt:  a Relax-NG validation context\n- * @define:  the definition to check\n- * @prop:  the attribute\n- *\n- * Check if the attribute matches the definition nameClass\n- *\n- * Returns 1 if the attribute matches, 0 if no, or -1 in case of error\n- *\/\n-static int\n-xmlRelaxNGAttributeMatch(xmlRelaxNGValidCtxtPtr ctxt,\n-                         xmlRelaxNGDefinePtr define, xmlAttrPtr prop)\n-{\n-    int ret;\n-\n-    if (define->name != NULL) {\n-        if (!xmlStrEqual(define->name, prop->name))\n-            return (0);\n-    }\n-    if (define->ns != NULL) {\n-        if (define->ns[0] == 0) {\n-            if (prop->ns != NULL)\n-                return (0);\n-        } else {\n-            if ((prop->ns == NULL) ||\n-                (!xmlStrEqual(define->ns, prop->ns->href)))\n-                return (0);\n-        }\n-    }\n-    if (define->nameClass == NULL)\n-        return (1);\n-    define = define->nameClass;\n-    if (define->type == XML_RELAXNG_EXCEPT) {\n-        xmlRelaxNGDefinePtr list;\n-\n-        list = define->content;\n-        while (list != NULL) {\n-            ret = xmlRelaxNGAttributeMatch(ctxt, list, prop);\n-            if (ret == 1)\n-                return (0);\n-            if (ret < 0)\n-                return (ret);\n-            list = list->next;\n-        }\n-    } else if (define->type == XML_RELAXNG_CHOICE) {\n-        xmlRelaxNGDefinePtr list;\n-\n-        list = define->nameClass;\n-        while (list != NULL) {\n-            ret = xmlRelaxNGAttributeMatch(ctxt, list, prop);\n-            if (ret == 1)\n-                return (1);\n-            if (ret < 0)\n-                return (ret);\n-            list = list->next;\n-        }\n-        return (0);\n-    } else {\n-        \/* TODO *\/\n-        return (0);\n-    }\n-    return (1);\n-}\n-\n-\/**\n- * xmlRelaxNGValidateAttribute:\n- * @ctxt:  a Relax-NG validation context\n- * @define:  the definition to verify\n- *\n- * Validate the given attribute definition for that node\n- *\n- * Returns 0 if the validation succeeded or an error code.\n- *\/\n-static int\n-xmlRelaxNGValidateAttribute(xmlRelaxNGValidCtxtPtr ctxt,\n-                            xmlRelaxNGDefinePtr define)\n-{\n-    int ret = 0, i;\n-    xmlChar *value, *oldvalue;\n-    xmlAttrPtr prop = NULL, tmp;\n-    xmlNodePtr oldseq;\n-\n-    if (ctxt->state->nbAttrLeft <= 0)\n-        return (-1);\n-    if (define->name != NULL) {\n-        for (i = 0; i < ctxt->state->nbAttrs; i++) {\n-            tmp = ctxt->state->attrs[i];\n-            if ((tmp != NULL) && (xmlStrEqual(define->name, tmp->name))) {\n-                if ((((define->ns == NULL) || (define->ns[0] == 0)) &&\n-                     (tmp->ns == NULL)) ||\n-                    ((tmp->ns != NULL) &&\n-                     (xmlStrEqual(define->ns, tmp->ns->href)))) {\n-                    prop = tmp;\n-                    break;\n-                }\n-            }\n-        }\n-        if (prop != NULL) {\n-            value = xmlNodeListGetString(prop->doc, prop->children, 1);\n-            oldvalue = ctxt->state->value;\n-            oldseq = ctxt->state->seq;\n-            ctxt->state->seq = (xmlNodePtr) prop;\n-            ctxt->state->value = value;\n-            ctxt->state->endvalue = NULL;\n-            ret = xmlRelaxNGValidateValueContent(ctxt, define->content);\n-            if (ctxt->state->value != NULL)\n-                value = ctxt->state->value;\n-            if (value != NULL)\n-                xmlFree(value);\n-            ctxt->state->value = oldvalue;\n-            ctxt->state->seq = oldseq;\n-            if (ret == 0) {\n-                \/*\n-                 * flag the attribute as processed\n-                 *\/\n-                ctxt->state->attrs[i] = NULL;\n-                ctxt->state->nbAttrLeft--;\n-            }\n-        } else {\n-            ret = -1;\n-        }\n-    } else {\n-        for (i = 0; i < ctxt->state->nbAttrs; i++) {\n-            tmp = ctxt->state->attrs[i];\n-            if ((tmp != NULL) &&\n-                (xmlRelaxNGAttributeMatch(ctxt, define, tmp) == 1)) {\n-                prop = tmp;\n-                break;\n-            }\n-        }\n-        if (prop != NULL) {\n-            value = xmlNodeListGetString(prop->doc, prop->children, 1);\n-            oldvalue = ctxt->state->value;\n-            oldseq = ctxt->state->seq;\n-            ctxt->state->seq = (xmlNodePtr) prop;\n-            ctxt->state->value = value;\n-            ret = xmlRelaxNGValidateValueContent(ctxt, define->content);\n-            if (ctxt->state->value != NULL)\n-                value = ctxt->state->value;\n-            if (value != NULL)\n-                xmlFree(value);\n-            ctxt->state->value = oldvalue;\n-            ctxt->state->seq = oldseq;\n-            if (ret == 0) {\n-                \/*\n-                 * flag the attribute as processed\n-                 *\/\n-                ctxt->state->attrs[i] = NULL;\n-                ctxt->state->nbAttrLeft--;\n-            }\n-        } else {\n-            ret = -1;\n-        }\n-    }\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGValidateAttributeList:\n- * @ctxt:  a Relax-NG validation context\n- * @define:  the list of definition to verify\n- *\n- * Validate the given node against the list of attribute definitions\n- *\n- * Returns 0 if the validation succeeded or an error code.\n- *\/\n-static int\n-xmlRelaxNGValidateAttributeList(xmlRelaxNGValidCtxtPtr ctxt,\n-                                xmlRelaxNGDefinePtr defines)\n-{\n-    int ret = 0, res;\n-    int needmore = 0;\n-    xmlRelaxNGDefinePtr cur;\n-\n-    cur = defines;\n-    while (cur != NULL) {\n-        if (cur->type == XML_RELAXNG_ATTRIBUTE) {\n-            if (xmlRelaxNGValidateAttribute(ctxt, cur) != 0)\n-                ret = -1;\n-        } else\n-            needmore = 1;\n-        cur = cur->next;\n-    }\n-    if (!needmore)\n-        return (ret);\n-    cur = defines;\n-    while (cur != NULL) {\n-        if (cur->type != XML_RELAXNG_ATTRIBUTE) {\n-            if ((ctxt->state != NULL) || (ctxt->states != NULL)) {\n-                res = xmlRelaxNGValidateDefinition(ctxt, cur);\n-                if (res < 0)\n-                    ret = -1;\n-            } else {\n-                VALID_ERR(XML_RELAXNG_ERR_NOSTATE);\n-                return (-1);\n-            }\n-            if (res == -1)      \/* continues on -2 *\/\n-                break;\n-        }\n-        cur = cur->next;\n-    }\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGNodeMatchesList:\n- * @node:  the node\n- * @list:  a NULL terminated array of definitions\n- *\n- * Check if a node can be matched by one of the definitions\n- *\n- * Returns 1 if matches 0 otherwise\n- *\/\n-static int\n-xmlRelaxNGNodeMatchesList(xmlNodePtr node, xmlRelaxNGDefinePtr * list)\n-{\n-    xmlRelaxNGDefinePtr cur;\n-    int i = 0, tmp;\n-\n-    if ((node == NULL) || (list == NULL))\n-        return (0);\n-\n-    cur = list[i++];\n-    while (cur != NULL) {\n-        if ((node->type == XML_ELEMENT_NODE) &&\n-            (cur->type == XML_RELAXNG_ELEMENT)) {\n-            tmp = xmlRelaxNGElementMatch(NULL, cur, node);\n-            if (tmp == 1)\n-                return (1);\n-        } else if (((node->type == XML_TEXT_NODE) ||\n-                    (node->type == XML_CDATA_SECTION_NODE)) &&\n-                   ((cur->type == XML_RELAXNG_DATATYPE) ||\n-            (cur->type == XML_RELAXNG_LIST) ||\n-                    (cur->type == XML_RELAXNG_TEXT) ||\n-                    (cur->type == XML_RELAXNG_VALUE))) {\n-            return (1);\n-        }\n-        cur = list[i++];\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlRelaxNGValidateInterleave:\n- * @ctxt:  a Relax-NG validation context\n- * @define:  the definition to verify\n- *\n- * Validate an interleave definition for a node.\n- *\n- * Returns 0 if the validation succeeded or an error code.\n- *\/\n-static int\n-xmlRelaxNGValidateInterleave(xmlRelaxNGValidCtxtPtr ctxt,\n-                             xmlRelaxNGDefinePtr define)\n-{\n-    int ret = 0, i, nbgroups;\n-    int errNr = ctxt->errNr;\n-    int oldflags;\n-\n-    xmlRelaxNGValidStatePtr oldstate;\n-    xmlRelaxNGPartitionPtr partitions;\n-    xmlRelaxNGInterleaveGroupPtr group = NULL;\n-    xmlNodePtr cur, start, last = NULL, lastchg = NULL, lastelem;\n-    xmlNodePtr *list = NULL, *lasts = NULL;\n-\n-    if (define->data != NULL) {\n-        partitions = (xmlRelaxNGPartitionPtr) define->data;\n-        nbgroups = partitions->nbgroups;\n-    } else {\n-        VALID_ERR(XML_RELAXNG_ERR_INTERNODATA);\n-        return (-1);\n-    }\n-    \/*\n-     * Optimizations for MIXED\n-     *\/\n-    oldflags = ctxt->flags;\n-    if (define->dflags & IS_MIXED) {\n-        ctxt->flags |= FLAGS_MIXED_CONTENT;\n-        if (nbgroups == 2) {\n-            \/*\n-             * this is a pure <mixed> case\n-             *\/\n-            if (ctxt->state != NULL)\n-                ctxt->state->seq = xmlRelaxNGSkipIgnored(ctxt,\n-                                                         ctxt->state->seq);\n-            if (partitions->groups[0]->rule->type == XML_RELAXNG_TEXT)\n-                ret = xmlRelaxNGValidateDefinition(ctxt,\n-                                                   partitions->groups[1]->\n-                                                   rule);\n-            else\n-                ret = xmlRelaxNGValidateDefinition(ctxt,\n-                                                   partitions->groups[0]->\n-                                                   rule);\n-            if (ret == 0) {\n-                if (ctxt->state != NULL)\n-                    ctxt->state->seq = xmlRelaxNGSkipIgnored(ctxt,\n-                                                             ctxt->state->\n-                                                             seq);\n-            }\n-            ctxt->flags = oldflags;\n-            return (ret);\n-        }\n-    }\n-\n-    \/*\n-     * Build arrays to store the first and last node of the chain\n-     * pertaining to each group\n-     *\/\n-    list = (xmlNodePtr *) xmlMalloc(nbgroups * sizeof(xmlNodePtr));\n-    if (list == NULL) {\n-        xmlRngVErrMemory(ctxt);\n-        return (-1);\n-    }\n-    memset(list, 0, nbgroups * sizeof(xmlNodePtr));\n-    lasts = (xmlNodePtr *) xmlMalloc(nbgroups * sizeof(xmlNodePtr));\n-    if (lasts == NULL) {\n-        xmlRngVErrMemory(ctxt);\n-        return (-1);\n-    }\n-    memset(lasts, 0, nbgroups * sizeof(xmlNodePtr));\n-\n-    \/*\n-     * Walk the sequence of children finding the right group and\n-     * sorting them in sequences.\n-     *\/\n-    cur = ctxt->state->seq;\n-    cur = xmlRelaxNGSkipIgnored(ctxt, cur);\n-    start = cur;\n-    while (cur != NULL) {\n-        ctxt->state->seq = cur;\n-        if ((partitions->triage != NULL) &&\n-            (partitions->flags & IS_DETERMINIST)) {\n-            void *tmp = NULL;\n-\n-            if ((cur->type == XML_TEXT_NODE) ||\n-                (cur->type == XML_CDATA_SECTION_NODE)) {\n-                tmp = xmlHashLookup2(partitions->triage, BAD_CAST \"#text\",\n-                                     NULL);\n-            } else if (cur->type == XML_ELEMENT_NODE) {\n-                if (cur->ns != NULL) {\n-                    tmp = xmlHashLookup2(partitions->triage, cur->name,\n-                                         cur->ns->href);\n-                    if (tmp == NULL)\n-                        tmp = xmlHashLookup2(partitions->triage,\n-                                             BAD_CAST \"#any\",\n-                                             cur->ns->href);\n-                } else\n-                    tmp =\n-                        xmlHashLookup2(partitions->triage, cur->name,\n-                                       NULL);\n-                if (tmp == NULL)\n-                    tmp =\n-                        xmlHashLookup2(partitions->triage, BAD_CAST \"#any\",\n-                                       NULL);\n-            }\n-\n-            if (tmp == NULL) {\n-                i = nbgroups;\n-            } else {\n-                i = ((ptrdiff_t) tmp) - 1;\n-                if (partitions->flags & IS_NEEDCHECK) {\n-                    group = partitions->groups[i];\n-                    if (!xmlRelaxNGNodeMatchesList(cur, group->defs))\n-                        i = nbgroups;\n-                }\n-            }\n-        } else {\n-            for (i = 0; i < nbgroups; i++) {\n-                group = partitions->groups[i];\n-                if (group == NULL)\n-                    continue;\n-                if (xmlRelaxNGNodeMatchesList(cur, group->defs))\n-                    break;\n-            }\n-        }\n-        \/*\n-         * We break as soon as an element not matched is found\n-         *\/\n-        if (i >= nbgroups) {\n-            break;\n-        }\n-        if (lasts[i] != NULL) {\n-            lasts[i]->next = cur;\n-            lasts[i] = cur;\n-        } else {\n-            list[i] = cur;\n-            lasts[i] = cur;\n-        }\n-        if (cur->next != NULL)\n-            lastchg = cur->next;\n-        else\n-            lastchg = cur;\n-        cur = xmlRelaxNGSkipIgnored(ctxt, cur->next);\n-    }\n-    if (ret != 0) {\n-        VALID_ERR(XML_RELAXNG_ERR_INTERSEQ);\n-        ret = -1;\n-        goto done;\n-    }\n-    lastelem = cur;\n-    oldstate = ctxt->state;\n-    for (i = 0; i < nbgroups; i++) {\n-        ctxt->state = xmlRelaxNGCopyValidState(ctxt, oldstate);\n-    if (ctxt->state == NULL) {\n-        ret = -1;\n-        break;\n-    }\n-        group = partitions->groups[i];\n-        if (lasts[i] != NULL) {\n-            last = lasts[i]->next;\n-            lasts[i]->next = NULL;\n-        }\n-        ctxt->state->seq = list[i];\n-        ret = xmlRelaxNGValidateDefinition(ctxt, group->rule);\n-        if (ret != 0)\n-            break;\n-        if (ctxt->state != NULL) {\n-            cur = ctxt->state->seq;\n-            cur = xmlRelaxNGSkipIgnored(ctxt, cur);\n-            xmlRelaxNGFreeValidState(ctxt, oldstate);\n-            oldstate = ctxt->state;\n-            ctxt->state = NULL;\n-            if (cur != NULL\n-                    \/* there's a nasty violation of context-free unambiguities,\n-                       since in open-name-class context, interleave in the\n-                       production shall finish without caring about anything\n-                       else that is OK to follow in that case -- it would\n-                       otherwise get marked as \"extra content\" and would\n-                       hence fail the validation, hence this perhaps\n-                       dirty attempt to rectify such a situation *\/\n-                    && (define->parent->type != XML_RELAXNG_DEF\n-                        || !xmlStrEqual(define->parent->name,\n-                                        (const xmlChar *) \"open-name-class\"))) {\n-                VALID_ERR2(XML_RELAXNG_ERR_INTEREXTRA, cur->name);\n-                ret = -1;\n-                ctxt->state = oldstate;\n-                goto done;\n-            }\n-        } else if (ctxt->states != NULL) {\n-            int j;\n-            int found = 0;\n-        int best = -1;\n-        int lowattr = -1;\n-\n-        \/*\n-         * PBM: what happen if there is attributes checks in the interleaves\n-         *\/\n-\n-            for (j = 0; j < ctxt->states->nbState; j++) {\n-                cur = ctxt->states->tabState[j]->seq;\n-                cur = xmlRelaxNGSkipIgnored(ctxt, cur);\n-                if (cur == NULL) {\n-            if (found == 0) {\n-                lowattr = ctxt->states->tabState[j]->nbAttrLeft;\n-            best = j;\n-            }\n-                    found = 1;\n-            if (ctxt->states->tabState[j]->nbAttrLeft <= lowattr) {\n-                \/* try  to keep the latest one to mach old heuristic *\/\n-                lowattr = ctxt->states->tabState[j]->nbAttrLeft;\n-            best = j;\n-            }\n-                    if (lowattr == 0)\n-                break;\n-                } else if (found == 0) {\n-                    if (lowattr == -1) {\n-                lowattr = ctxt->states->tabState[j]->nbAttrLeft;\n-            best = j;\n-            } else\n-            if (ctxt->states->tabState[j]->nbAttrLeft <= lowattr)  {\n-                \/* try  to keep the latest one to mach old heuristic *\/\n-                lowattr = ctxt->states->tabState[j]->nbAttrLeft;\n-            best = j;\n-            }\n-        }\n-            }\n-        \/*\n-         * BIG PBM: here we pick only one restarting point :-(\n-         *\/\n-            if (ctxt->states->nbState > 0) {\n-                xmlRelaxNGFreeValidState(ctxt, oldstate);\n-        if (best != -1) {\n-            oldstate = ctxt->states->tabState[best];\n-            ctxt->states->tabState[best] = NULL;\n-        } else {\n-            oldstate =\n-            ctxt->states->tabState[ctxt->states->nbState - 1];\n-                    ctxt->states->tabState[ctxt->states->nbState - 1] = NULL;\n-                    ctxt->states->nbState--;\n-        }\n-            }\n-            for (j = 0; j < ctxt->states->nbState ; j++) {\n-                xmlRelaxNGFreeValidState(ctxt, ctxt->states->tabState[j]);\n-            }\n-            xmlRelaxNGFreeStates(ctxt, ctxt->states);\n-            ctxt->states = NULL;\n-            if (found == 0) {\n-                if (cur == NULL) {\n-            VALID_ERR2(XML_RELAXNG_ERR_INTEREXTRA,\n-                   (const xmlChar *) \"noname\");\n-                } else {\n-                    VALID_ERR2(XML_RELAXNG_ERR_INTEREXTRA, cur->name);\n-                }\n-                ret = -1;\n-                ctxt->state = oldstate;\n-                goto done;\n-            }\n-        } else {\n-            ret = -1;\n-            break;\n-        }\n-        if (lasts[i] != NULL) {\n-            lasts[i]->next = last;\n-        }\n-    }\n-    if (ctxt->state != NULL)\n-        xmlRelaxNGFreeValidState(ctxt, ctxt->state);\n-    ctxt->state = oldstate;\n-    ctxt->state->seq = lastelem;\n-    if (ret != 0) {\n-        VALID_ERR(XML_RELAXNG_ERR_INTERSEQ);\n-        ret = -1;\n-        goto done;\n-    }\n-\n-  done:\n-    ctxt->flags = oldflags;\n-    \/*\n-     * builds the next links chain from the prev one\n-     *\/\n-    cur = lastchg;\n-    while (cur != NULL) {\n-        if ((cur == start) || (cur->prev == NULL))\n-            break;\n-        cur->prev->next = cur;\n-        cur = cur->prev;\n-    }\n-    if (ret == 0) {\n-        if (ctxt->errNr > errNr)\n-            xmlRelaxNGPopErrors(ctxt, errNr);\n-    }\n-\n-    xmlFree(list);\n-    xmlFree(lasts);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGValidateDefinitionList:\n- * @ctxt:  a Relax-NG validation context\n- * @define:  the list of definition to verify\n- *\n- * Validate the given node content against the (list) of definitions\n- *\n- * Returns 0 if the validation succeeded or an error code.\n- *\/\n-static int\n-xmlRelaxNGValidateDefinitionList(xmlRelaxNGValidCtxtPtr ctxt,\n-                                 xmlRelaxNGDefinePtr defines)\n-{\n-    int ret = 0, res;\n-\n-\n-    if (defines == NULL) {\n-        VALID_ERR2(XML_RELAXNG_ERR_INTERNAL,\n-                   BAD_CAST \"NULL definition list\");\n-        return (-1);\n-    }\n-    while (defines != NULL) {\n-        if ((ctxt->state != NULL) || (ctxt->states != NULL)) {\n-            res = xmlRelaxNGValidateDefinition(ctxt, defines);\n-            if (res < 0)\n-                ret = -1;\n-        } else {\n-            VALID_ERR(XML_RELAXNG_ERR_NOSTATE);\n-            return (-1);\n-        }\n-        if (res == -1)          \/* continues on -2 *\/\n-            break;\n-        defines = defines->next;\n-    }\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGElementMatch:\n- * @ctxt:  a Relax-NG validation context\n- * @define:  the definition to check\n- * @elem:  the element\n- *\n- * Check if the element matches the definition nameClass\n- *\n- * Returns 1 if the element matches, 0 if no, or -1 in case of error\n- *\/\n-static int\n-xmlRelaxNGElementMatch(xmlRelaxNGValidCtxtPtr ctxt,\n-                       xmlRelaxNGDefinePtr define, xmlNodePtr elem)\n-{\n-    int ret = 0, oldflags = 0;\n-\n-    if (define->name != NULL) {\n-        if (!xmlStrEqual(elem->name, define->name)) {\n-            VALID_ERR3(XML_RELAXNG_ERR_ELEMNAME, define->name, elem->name);\n-            return (0);\n-        }\n-    }\n-    if ((define->ns != NULL) && (define->ns[0] != 0)) {\n-        if (elem->ns == NULL) {\n-            VALID_ERR2(XML_RELAXNG_ERR_ELEMNONS, elem->name);\n-            return (0);\n-        } else if (!xmlStrEqual(elem->ns->href, define->ns)) {\n-            VALID_ERR3(XML_RELAXNG_ERR_ELEMWRONGNS,\n-                       elem->name, define->ns);\n-            return (0);\n-        }\n-    } else if ((elem->ns != NULL) && (define->ns != NULL) &&\n-               (define->name == NULL)) {\n-        VALID_ERR2(XML_RELAXNG_ERR_ELEMEXTRANS, elem->name);\n-        return (0);\n-    } else if ((elem->ns != NULL) && (define->name != NULL)) {\n-        VALID_ERR2(XML_RELAXNG_ERR_ELEMEXTRANS, define->name);\n-        return (0);\n-    }\n-\n-    if (define->nameClass == NULL)\n-        return (1);\n-\n-    define = define->nameClass;\n-    if (define->type == XML_RELAXNG_EXCEPT) {\n-        xmlRelaxNGDefinePtr list;\n-\n-        if (ctxt != NULL) {\n-            oldflags = ctxt->flags;\n-            ctxt->flags |= FLAGS_IGNORABLE;\n-        }\n-\n-        list = define->content;\n-        while (list != NULL) {\n-            ret = xmlRelaxNGElementMatch(ctxt, list, elem);\n-            if (ret == 1) {\n-                if (ctxt != NULL)\n-                    ctxt->flags = oldflags;\n-                return (0);\n-            }\n-            if (ret < 0) {\n-                if (ctxt != NULL)\n-                    ctxt->flags = oldflags;\n-                return (ret);\n-            }\n-            list = list->next;\n-        }\n-        ret = 1;\n-        if (ctxt != NULL) {\n-            ctxt->flags = oldflags;\n-        }\n-    } else if (define->type == XML_RELAXNG_CHOICE) {\n-        xmlRelaxNGDefinePtr list;\n-\n-        if (ctxt != NULL) {\n-            oldflags = ctxt->flags;\n-            ctxt->flags |= FLAGS_IGNORABLE;\n-        }\n-\n-        list = define->nameClass;\n-        while (list != NULL) {\n-            ret = xmlRelaxNGElementMatch(ctxt, list, elem);\n-            if (ret == 1) {\n-                if (ctxt != NULL)\n-                    ctxt->flags = oldflags;\n-                return (1);\n-            }\n-            if (ret < 0) {\n-                if (ctxt != NULL)\n-                    ctxt->flags = oldflags;\n-                return (ret);\n-            }\n-            list = list->next;\n-        }\n-        if (ctxt != NULL) {\n-            if (ret != 0) {\n-                if ((ctxt->flags & FLAGS_IGNORABLE) == 0)\n-                    xmlRelaxNGDumpValidError(ctxt);\n-            } else {\n-                if (ctxt->errNr > 0)\n-                    xmlRelaxNGPopErrors(ctxt, 0);\n-            }\n-        }\n-        ret = 0;\n-        if (ctxt != NULL) {\n-            ctxt->flags = oldflags;\n-        }\n-    } else {\n-        \/* TODO *\/\n-        ret = -1;\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGBestState:\n- * @ctxt:  a Relax-NG validation context\n- *\n- * Find the \"best\" state in the ctxt->states list of states to report\n- * errors about. I.e. a state with no element left in the child list\n- * or the one with the less attributes left.\n- * This is called only if a validation error was detected\n- *\n- * Returns the index of the \"best\" state or -1 in case of error\n- *\/\n-static int\n-xmlRelaxNGBestState(xmlRelaxNGValidCtxtPtr ctxt)\n-{\n-    xmlRelaxNGValidStatePtr state;\n-    int i, tmp;\n-    int best = -1;\n-    int value = 1000000;\n-\n-    if ((ctxt == NULL) || (ctxt->states == NULL) ||\n-        (ctxt->states->nbState <= 0))\n-        return (-1);\n-\n-    for (i = 0; i < ctxt->states->nbState; i++) {\n-        state = ctxt->states->tabState[i];\n-        if (state == NULL)\n-            continue;\n-        if (state->seq != NULL) {\n-            if ((best == -1) || (value > 100000)) {\n-                value = 100000;\n-                best = i;\n-            }\n-        } else {\n-            tmp = state->nbAttrLeft;\n-            if ((best == -1) || (value > tmp)) {\n-                value = tmp;\n-                best = i;\n-            }\n-        }\n-    }\n-    return (best);\n-}\n-\n-\/**\n- * xmlRelaxNGLogBestError:\n- * @ctxt:  a Relax-NG validation context\n- *\n- * Find the \"best\" state in the ctxt->states list of states to report\n- * errors about and log it.\n- *\/\n-static void\n-xmlRelaxNGLogBestError(xmlRelaxNGValidCtxtPtr ctxt)\n-{\n-    int best;\n-\n-    if ((ctxt == NULL) || (ctxt->states == NULL) ||\n-        (ctxt->states->nbState <= 0))\n-        return;\n-\n-    best = xmlRelaxNGBestState(ctxt);\n-    if ((best >= 0) && (best < ctxt->states->nbState)) {\n-        ctxt->state = ctxt->states->tabState[best];\n-\n-        xmlRelaxNGValidateElementEnd(ctxt, 1);\n-    }\n-}\n-\n-\/**\n- * xmlRelaxNGValidateElementEnd:\n- * @ctxt:  a Relax-NG validation context\n- * @dolog:  indicate that error logging should be done\n- *\n- * Validate the end of the element, implements check that\n- * there is nothing left not consumed in the element content\n- * or in the attribute list.\n- *\n- * Returns 0 if the validation succeeded or an error code.\n- *\/\n-static int\n-xmlRelaxNGValidateElementEnd(xmlRelaxNGValidCtxtPtr ctxt, int dolog)\n-{\n-    int i;\n-    xmlRelaxNGValidStatePtr state;\n-\n-    state = ctxt->state;\n-    if (state->seq != NULL) {\n-        state->seq = xmlRelaxNGSkipIgnored(ctxt, state->seq);\n-        if (state->seq != NULL) {\n-            if (dolog) {\n-                VALID_ERR3(XML_RELAXNG_ERR_EXTRACONTENT,\n-                           state->node->name, state->seq->name);\n-            }\n-            return (-1);\n-        }\n-    }\n-    for (i = 0; i < state->nbAttrs; i++) {\n-        if (state->attrs[i] != NULL) {\n-            if (dolog) {\n-                VALID_ERR3(XML_RELAXNG_ERR_INVALIDATTR,\n-                           state->attrs[i]->name, state->node->name);\n-            }\n-            return (-1 - i);\n-        }\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlRelaxNGValidateState:\n- * @ctxt:  a Relax-NG validation context\n- * @define:  the definition to verify\n- *\n- * Validate the current state against the definition\n- *\n- * Returns 0 if the validation succeeded or an error code.\n- *\/\n-static int\n-xmlRelaxNGValidateState(xmlRelaxNGValidCtxtPtr ctxt,\n-                        xmlRelaxNGDefinePtr define)\n-{\n-    xmlNodePtr node;\n-    int ret = 0, i, tmp, oldflags, errNr;\n-    xmlRelaxNGValidStatePtr oldstate = NULL, state;\n-\n-    if (define == NULL) {\n-        VALID_ERR(XML_RELAXNG_ERR_NODEFINE);\n-        return (-1);\n-    }\n-\n-    if (ctxt->state != NULL) {\n-        node = ctxt->state->seq;\n-    } else {\n-        node = NULL;\n-    }\n-    ctxt->depth++;\n-    switch (define->type) {\n-        case XML_RELAXNG_EMPTY:\n-            ret = 0;\n-            break;\n-        case XML_RELAXNG_NOT_ALLOWED:\n-            ret = -1;\n-            break;\n-        case XML_RELAXNG_TEXT:\n-            while ((node != NULL) &&\n-                   ((node->type == XML_TEXT_NODE) ||\n-                    (node->type == XML_COMMENT_NODE) ||\n-                    (node->type == XML_PI_NODE) ||\n-                    (node->type == XML_CDATA_SECTION_NODE)))\n-                node = node->next;\n-            ctxt->state->seq = node;\n-            break;\n-        case XML_RELAXNG_ELEMENT:\n-            errNr = ctxt->errNr;\n-            node = xmlRelaxNGSkipIgnored(ctxt, node);\n-            if (node == NULL) {\n-                VALID_ERR2(XML_RELAXNG_ERR_NOELEM, define->name);\n-                ret = -1;\n-                if ((ctxt->flags & FLAGS_IGNORABLE) == 0)\n-                    xmlRelaxNGDumpValidError(ctxt);\n-                break;\n-            }\n-            if (node->type != XML_ELEMENT_NODE) {\n-                VALID_ERR(XML_RELAXNG_ERR_NOTELEM);\n-                ret = -1;\n-                if ((ctxt->flags & FLAGS_IGNORABLE) == 0)\n-                    xmlRelaxNGDumpValidError(ctxt);\n-                break;\n-            }\n-            \/*\n-             * This node was already validated successfully against\n-             * this definition.\n-             *\/\n-            if (node->psvi == define) {\n-                ctxt->state->seq = xmlRelaxNGSkipIgnored(ctxt, node->next);\n-                if (ctxt->errNr > errNr)\n-                    xmlRelaxNGPopErrors(ctxt, errNr);\n-                if (ctxt->errNr != 0) {\n-                    while ((ctxt->err != NULL) &&\n-                           (((ctxt->err->err == XML_RELAXNG_ERR_ELEMNAME)\n-                             && (xmlStrEqual(ctxt->err->arg2, node->name)))\n-                            ||\n-                            ((ctxt->err->err ==\n-                              XML_RELAXNG_ERR_ELEMEXTRANS)\n-                             && (xmlStrEqual(ctxt->err->arg1, node->name)))\n-                            || (ctxt->err->err == XML_RELAXNG_ERR_NOELEM)\n-                            || (ctxt->err->err ==\n-                                XML_RELAXNG_ERR_NOTELEM)))\n-                        xmlRelaxNGValidErrorPop(ctxt);\n-                }\n-                break;\n-            }\n-\n-            ret = xmlRelaxNGElementMatch(ctxt, define, node);\n-            if (ret <= 0) {\n-                ret = -1;\n-                if ((ctxt->flags & FLAGS_IGNORABLE) == 0)\n-                    xmlRelaxNGDumpValidError(ctxt);\n-                break;\n-            }\n-            ret = 0;\n-            if (ctxt->errNr != 0) {\n-                if (ctxt->errNr > errNr)\n-                    xmlRelaxNGPopErrors(ctxt, errNr);\n-                while ((ctxt->err != NULL) &&\n-                       (((ctxt->err->err == XML_RELAXNG_ERR_ELEMNAME) &&\n-                         (xmlStrEqual(ctxt->err->arg2, node->name))) ||\n-                        ((ctxt->err->err == XML_RELAXNG_ERR_ELEMEXTRANS) &&\n-                         (xmlStrEqual(ctxt->err->arg1, node->name))) ||\n-                        (ctxt->err->err == XML_RELAXNG_ERR_NOELEM) ||\n-                        (ctxt->err->err == XML_RELAXNG_ERR_NOTELEM)))\n-                    xmlRelaxNGValidErrorPop(ctxt);\n-            }\n-            errNr = ctxt->errNr;\n-\n-            oldflags = ctxt->flags;\n-            if (ctxt->flags & FLAGS_MIXED_CONTENT) {\n-                ctxt->flags -= FLAGS_MIXED_CONTENT;\n-            }\n-            state = xmlRelaxNGNewValidState(ctxt, node);\n-            if (state == NULL) {\n-                ret = -1;\n-                if ((ctxt->flags & FLAGS_IGNORABLE) == 0)\n-                    xmlRelaxNGDumpValidError(ctxt);\n-                break;\n-            }\n-\n-            oldstate = ctxt->state;\n-            ctxt->state = state;\n-            if (define->attrs != NULL) {\n-                tmp = xmlRelaxNGValidateAttributeList(ctxt, define->attrs);\n-                if (tmp != 0) {\n-                    ret = -1;\n-                    VALID_ERR2(XML_RELAXNG_ERR_ATTRVALID, node->name);\n-                }\n-            }\n-            if (define->contModel != NULL) {\n-                xmlRelaxNGValidStatePtr nstate, tmpstate = ctxt->state;\n-                xmlRelaxNGStatesPtr tmpstates = ctxt->states;\n-                xmlNodePtr nseq;\n-\n-                nstate = xmlRelaxNGNewValidState(ctxt, node);\n-                ctxt->state = nstate;\n-                ctxt->states = NULL;\n-\n-                tmp = xmlRelaxNGValidateCompiledContent(ctxt,\n-                                                        define->contModel,\n-                                                        ctxt->state->seq);\n-                nseq = ctxt->state->seq;\n-                ctxt->state = tmpstate;\n-                ctxt->states = tmpstates;\n-                xmlRelaxNGFreeValidState(ctxt, nstate);\n-\n-                if (tmp != 0)\n-                    ret = -1;\n-\n-                if (ctxt->states != NULL) {\n-                    tmp = -1;\n-\n-                    for (i = 0; i < ctxt->states->nbState; i++) {\n-                        state = ctxt->states->tabState[i];\n-                        ctxt->state = state;\n-                        ctxt->state->seq = nseq;\n-\n-                        if (xmlRelaxNGValidateElementEnd(ctxt, 0) == 0) {\n-                            tmp = 0;\n-                            break;\n-                        }\n-                    }\n-                    if (tmp != 0) {\n-                        \/*\n-                         * validation error, log the message for the \"best\" one\n-                         *\/\n-                        ctxt->flags |= FLAGS_IGNORABLE;\n-                        xmlRelaxNGLogBestError(ctxt);\n-                    }\n-                    for (i = 0; i < ctxt->states->nbState; i++) {\n-                        xmlRelaxNGFreeValidState(ctxt,\n-                                                 ctxt->states->\n-                                                 tabState[i]);\n-                    }\n-                    xmlRelaxNGFreeStates(ctxt, ctxt->states);\n-                    ctxt->flags = oldflags;\n-                    ctxt->states = NULL;\n-                    if ((ret == 0) && (tmp == -1))\n-                        ret = -1;\n-                } else {\n-                    state = ctxt->state;\n-            if (ctxt->state != NULL)\n-            ctxt->state->seq = nseq;\n-                    if (ret == 0)\n-                        ret = xmlRelaxNGValidateElementEnd(ctxt, 1);\n-                    xmlRelaxNGFreeValidState(ctxt, state);\n-                }\n-            } else {\n-                if (define->content != NULL) {\n-                    tmp = xmlRelaxNGValidateDefinitionList(ctxt,\n-                                                           define->\n-                                                           content);\n-                    if (tmp != 0) {\n-                        ret = -1;\n-                        if (ctxt->state == NULL) {\n-                            ctxt->state = oldstate;\n-                            VALID_ERR2(XML_RELAXNG_ERR_CONTENTVALID,\n-                                       node->name);\n-                            ctxt->state = NULL;\n-                        } else {\n-                            VALID_ERR2(XML_RELAXNG_ERR_CONTENTVALID,\n-                                       node->name);\n-                        }\n-\n-                    }\n-                }\n-                if (ctxt->states != NULL) {\n-                    tmp = -1;\n-\n-                    for (i = 0; i < ctxt->states->nbState; i++) {\n-                        state = ctxt->states->tabState[i];\n-                        ctxt->state = state;\n-\n-                        if (xmlRelaxNGValidateElementEnd(ctxt, 0) == 0) {\n-                            tmp = 0;\n-                            break;\n-                        }\n-                    }\n-                    if (tmp != 0) {\n-                        \/*\n-                         * validation error, log the message for the \"best\" one\n-                         *\/\n-                        ctxt->flags |= FLAGS_IGNORABLE;\n-                        xmlRelaxNGLogBestError(ctxt);\n-                    }\n-                    for (i = 0; i < ctxt->states->nbState; i++) {\n-                        xmlRelaxNGFreeValidState(ctxt,\n-                                                 ctxt->states->tabState[i]);\n-                        ctxt->states->tabState[i] = NULL;\n-                    }\n-                    xmlRelaxNGFreeStates(ctxt, ctxt->states);\n-                    ctxt->flags = oldflags;\n-                    ctxt->states = NULL;\n-                    if ((ret == 0) && (tmp == -1))\n-                        ret = -1;\n-                } else {\n-                    state = ctxt->state;\n-                    if (ret == 0)\n-                        ret = xmlRelaxNGValidateElementEnd(ctxt, 1);\n-                    xmlRelaxNGFreeValidState(ctxt, state);\n-                }\n-            }\n-            if (ret == 0) {\n-                node->psvi = define;\n-            }\n-            ctxt->flags = oldflags;\n-            ctxt->state = oldstate;\n-            if (oldstate != NULL)\n-                oldstate->seq = xmlRelaxNGSkipIgnored(ctxt, node->next);\n-            if (ret != 0) {\n-                if ((ctxt->flags & FLAGS_IGNORABLE) == 0) {\n-                    xmlRelaxNGDumpValidError(ctxt);\n-                    ret = 0;\n-#if 0\n-                } else {\n-                    ret = -2;\n-#endif\n-                }\n-            } else {\n-                if (ctxt->errNr > errNr)\n-                    xmlRelaxNGPopErrors(ctxt, errNr);\n-            }\n-\n-            break;\n-        case XML_RELAXNG_OPTIONAL:{\n-                errNr = ctxt->errNr;\n-                oldflags = ctxt->flags;\n-                ctxt->flags |= FLAGS_IGNORABLE;\n-                oldstate = xmlRelaxNGCopyValidState(ctxt, ctxt->state);\n-                ret =\n-                    xmlRelaxNGValidateDefinitionList(ctxt,\n-                                                     define->content);\n-                if (ret != 0) {\n-                    if (ctxt->state != NULL)\n-                        xmlRelaxNGFreeValidState(ctxt, ctxt->state);\n-                    ctxt->state = oldstate;\n-                    ctxt->flags = oldflags;\n-                    ret = 0;\n-                    if (ctxt->errNr > errNr)\n-                        xmlRelaxNGPopErrors(ctxt, errNr);\n-                    break;\n-                }\n-                if (ctxt->states != NULL) {\n-                    xmlRelaxNGAddStates(ctxt, ctxt->states, oldstate);\n-                } else {\n-                    ctxt->states = xmlRelaxNGNewStates(ctxt, 1);\n-                    if (ctxt->states == NULL) {\n-                        xmlRelaxNGFreeValidState(ctxt, oldstate);\n-                        ctxt->flags = oldflags;\n-                        ret = -1;\n-                        if (ctxt->errNr > errNr)\n-                            xmlRelaxNGPopErrors(ctxt, errNr);\n-                        break;\n-                    }\n-                    xmlRelaxNGAddStates(ctxt, ctxt->states, oldstate);\n-                    xmlRelaxNGAddStates(ctxt, ctxt->states, ctxt->state);\n-                    ctxt->state = NULL;\n-                }\n-                ctxt->flags = oldflags;\n-                ret = 0;\n-                if (ctxt->errNr > errNr)\n-                    xmlRelaxNGPopErrors(ctxt, errNr);\n-                break;\n-            }\n-        case XML_RELAXNG_ONEORMORE:\n-            errNr = ctxt->errNr;\n-            ret = xmlRelaxNGValidateDefinitionList(ctxt, define->content);\n-            if (ret != 0) {\n-                break;\n-            }\n-            if (ctxt->errNr > errNr)\n-                xmlRelaxNGPopErrors(ctxt, errNr);\n-            \/* Falls through. *\/\n-        case XML_RELAXNG_ZEROORMORE:{\n-                int progress;\n-                xmlRelaxNGStatesPtr states = NULL, res = NULL;\n-                int base, j;\n-\n-                errNr = ctxt->errNr;\n-                res = xmlRelaxNGNewStates(ctxt, 1);\n-                if (res == NULL) {\n-                    ret = -1;\n-                    break;\n-                }\n-                \/*\n-                 * All the input states are also exit states\n-                 *\/\n-                if (ctxt->state != NULL) {\n-                    xmlRelaxNGAddStates(ctxt, res,\n-                                        xmlRelaxNGCopyValidState(ctxt,\n-                                                                 ctxt->\n-                                                                 state));\n-                } else {\n-                    for (j = 0; j < ctxt->states->nbState; j++) {\n-                        xmlRelaxNGAddStates(ctxt, res,\n-                            xmlRelaxNGCopyValidState(ctxt,\n-                                            ctxt->states->tabState[j]));\n-                    }\n-                }\n-                oldflags = ctxt->flags;\n-                ctxt->flags |= FLAGS_IGNORABLE;\n-                do {\n-                    progress = 0;\n-                    base = res->nbState;\n-\n-                    if (ctxt->states != NULL) {\n-                        states = ctxt->states;\n-                        for (i = 0; i < states->nbState; i++) {\n-                            ctxt->state = states->tabState[i];\n-                            ctxt->states = NULL;\n-                            ret = xmlRelaxNGValidateDefinitionList(ctxt,\n-                                                                   define->\n-                                                                   content);\n-                            if (ret == 0) {\n-                                if (ctxt->state != NULL) {\n-                                    tmp = xmlRelaxNGAddStates(ctxt, res,\n-                                                              ctxt->state);\n-                                    ctxt->state = NULL;\n-                                    if (tmp == 1)\n-                                        progress = 1;\n-                                } else if (ctxt->states != NULL) {\n-                                    for (j = 0; j < ctxt->states->nbState;\n-                                         j++) {\n-                                        tmp =\n-                                            xmlRelaxNGAddStates(ctxt, res,\n-                                                   ctxt->states->tabState[j]);\n-                                        if (tmp == 1)\n-                                            progress = 1;\n-                                    }\n-                                    xmlRelaxNGFreeStates(ctxt,\n-                                                         ctxt->states);\n-                                    ctxt->states = NULL;\n-                                }\n-                            } else {\n-                                if (ctxt->state != NULL) {\n-                                    xmlRelaxNGFreeValidState(ctxt,\n-                                                             ctxt->state);\n-                                    ctxt->state = NULL;\n-                                }\n-                            }\n-                        }\n-                    } else {\n-                        ret = xmlRelaxNGValidateDefinitionList(ctxt,\n-                                                               define->\n-                                                               content);\n-                        if (ret != 0) {\n-                            xmlRelaxNGFreeValidState(ctxt, ctxt->state);\n-                            ctxt->state = NULL;\n-                        } else {\n-                            base = res->nbState;\n-                            if (ctxt->state != NULL) {\n-                                tmp = xmlRelaxNGAddStates(ctxt, res,\n-                                                          ctxt->state);\n-                                ctxt->state = NULL;\n-                                if (tmp == 1)\n-                                    progress = 1;\n-                            } else if (ctxt->states != NULL) {\n-                                for (j = 0; j < ctxt->states->nbState; j++) {\n-                                    tmp = xmlRelaxNGAddStates(ctxt, res,\n-                                               ctxt->states->tabState[j]);\n-                                    if (tmp == 1)\n-                                        progress = 1;\n-                                }\n-                                if (states == NULL) {\n-                                    states = ctxt->states;\n-                                } else {\n-                                    xmlRelaxNGFreeStates(ctxt,\n-                                                         ctxt->states);\n-                                }\n-                                ctxt->states = NULL;\n-                            }\n-                        }\n-                    }\n-                    if (progress) {\n-                        \/*\n-                         * Collect all the new nodes added at that step\n-                         * and make them the new node set\n-                         *\/\n-                        if (res->nbState - base == 1) {\n-                            ctxt->state = xmlRelaxNGCopyValidState(ctxt,\n-                                                                   res->\n-                                                                   tabState\n-                                                                   [base]);\n-                        } else {\n-                            if (states == NULL) {\n-                                xmlRelaxNGNewStates(ctxt,\n-                                                    res->nbState - base);\n-                    states = ctxt->states;\n-                if (states == NULL) {\n-                    progress = 0;\n-                    break;\n-                }\n-                            }\n-                            states->nbState = 0;\n-                            for (i = base; i < res->nbState; i++)\n-                                xmlRelaxNGAddStates(ctxt, states,\n-                                                    xmlRelaxNGCopyValidState\n-                                                    (ctxt, res->tabState[i]));\n-                            ctxt->states = states;\n-                        }\n-                    }\n-                } while (progress == 1);\n-                if (states != NULL) {\n-                    xmlRelaxNGFreeStates(ctxt, states);\n-                }\n-                ctxt->states = res;\n-                ctxt->flags = oldflags;\n-#if 0\n-                \/*\n-                 * errors may have to be propagated back...\n-                 *\/\n-                if (ctxt->errNr > errNr)\n-                    xmlRelaxNGPopErrors(ctxt, errNr);\n-#endif\n-                ret = 0;\n-                break;\n-            }\n-        case XML_RELAXNG_CHOICE:{\n-                xmlRelaxNGDefinePtr list = NULL;\n-                xmlRelaxNGStatesPtr states = NULL;\n-\n-                node = xmlRelaxNGSkipIgnored(ctxt, node);\n-\n-                errNr = ctxt->errNr;\n-                if ((define->dflags & IS_TRIABLE) && (define->data != NULL) &&\n-            (node != NULL)) {\n-            \/*\n-             * node == NULL can't be optimized since IS_TRIABLE\n-             * doesn't account for choice which may lead to\n-             * only attributes.\n-             *\/\n-                    xmlHashTablePtr triage =\n-                        (xmlHashTablePtr) define->data;\n-\n-                    \/*\n-                     * Something we can optimize cleanly there is only one\n-                     * possible branch out !\n-                     *\/\n-                    if ((node->type == XML_TEXT_NODE) ||\n-                        (node->type == XML_CDATA_SECTION_NODE)) {\n-                        list =\n-                            xmlHashLookup2(triage, BAD_CAST \"#text\", NULL);\n-                    } else if (node->type == XML_ELEMENT_NODE) {\n-                        if (node->ns != NULL) {\n-                            list = xmlHashLookup2(triage, node->name,\n-                                                  node->ns->href);\n-                            if (list == NULL)\n-                                list =\n-                                    xmlHashLookup2(triage, BAD_CAST \"#any\",\n-                                                   node->ns->href);\n-                        } else\n-                            list =\n-                                xmlHashLookup2(triage, node->name, NULL);\n-                        if (list == NULL)\n-                            list =\n-                                xmlHashLookup2(triage, BAD_CAST \"#any\",\n-                                               NULL);\n-                    }\n-                    if (list == NULL) {\n-                        ret = -1;\n-            VALID_ERR2(XML_RELAXNG_ERR_ELEMWRONG, node->name);\n-                        break;\n-                    }\n-                    ret = xmlRelaxNGValidateDefinition(ctxt, list);\n-                    if (ret == 0) {\n-                    }\n-                    break;\n-                }\n-\n-                list = define->content;\n-                oldflags = ctxt->flags;\n-                ctxt->flags |= FLAGS_IGNORABLE;\n-\n-                while (list != NULL) {\n-                    oldstate = xmlRelaxNGCopyValidState(ctxt, ctxt->state);\n-                    ret = xmlRelaxNGValidateDefinition(ctxt, list);\n-                    if (ret == 0) {\n-                        if (states == NULL) {\n-                            states = xmlRelaxNGNewStates(ctxt, 1);\n-                        }\n-                        if (ctxt->state != NULL) {\n-                            xmlRelaxNGAddStates(ctxt, states, ctxt->state);\n-                        } else if (ctxt->states != NULL) {\n-                            for (i = 0; i < ctxt->states->nbState; i++) {\n-                                xmlRelaxNGAddStates(ctxt, states,\n-                                                    ctxt->states->\n-                                                    tabState[i]);\n-                            }\n-                            xmlRelaxNGFreeStates(ctxt, ctxt->states);\n-                            ctxt->states = NULL;\n-                        }\n-                    } else {\n-                        xmlRelaxNGFreeValidState(ctxt, ctxt->state);\n-                    }\n-                    ctxt->state = oldstate;\n-                    list = list->next;\n-                }\n-                if (states != NULL) {\n-                    xmlRelaxNGFreeValidState(ctxt, oldstate);\n-                    ctxt->states = states;\n-                    ctxt->state = NULL;\n-                    ret = 0;\n-                } else {\n-                    ctxt->states = NULL;\n-                }\n-                ctxt->flags = oldflags;\n-                if (ret != 0) {\n-                    if ((ctxt->flags & FLAGS_IGNORABLE) == 0) {\n-                        xmlRelaxNGDumpValidError(ctxt);\n-                    }\n-                } else {\n-                    if (ctxt->errNr > errNr)\n-                        xmlRelaxNGPopErrors(ctxt, errNr);\n-                }\n-                break;\n-            }\n-        case XML_RELAXNG_DEF:\n-        case XML_RELAXNG_GROUP:\n-            ret = xmlRelaxNGValidateDefinitionList(ctxt, define->content);\n-            break;\n-        case XML_RELAXNG_INTERLEAVE:\n-            ret = xmlRelaxNGValidateInterleave(ctxt, define);\n-            break;\n-        case XML_RELAXNG_ATTRIBUTE:\n-            ret = xmlRelaxNGValidateAttribute(ctxt, define);\n-            break;\n-        case XML_RELAXNG_START:\n-        case XML_RELAXNG_NOOP:\n-        case XML_RELAXNG_REF:\n-        case XML_RELAXNG_EXTERNALREF:\n-        case XML_RELAXNG_PARENTREF:\n-            ret = xmlRelaxNGValidateDefinition(ctxt, define->content);\n-            break;\n-        case XML_RELAXNG_DATATYPE:{\n-                xmlNodePtr child;\n-                xmlChar *content = NULL;\n-\n-                child = node;\n-                while (child != NULL) {\n-                    if (child->type == XML_ELEMENT_NODE) {\n-                        VALID_ERR2(XML_RELAXNG_ERR_DATAELEM,\n-                                   node->parent->name);\n-                        ret = -1;\n-                        break;\n-                    } else if ((child->type == XML_TEXT_NODE) ||\n-                               (child->type == XML_CDATA_SECTION_NODE)) {\n-                        content = xmlStrcat(content, child->content);\n-                    }\n-                    \/* TODO: handle entities ... *\/\n-                    child = child->next;\n-                }\n-                if (ret == -1) {\n-                    if (content != NULL)\n-                        xmlFree(content);\n-                    break;\n-                }\n-                if (content == NULL) {\n-                    content = xmlStrdup(BAD_CAST \"\");\n-                    if (content == NULL) {\n-                        xmlRngVErrMemory(ctxt);\n-                        ret = -1;\n-                        break;\n-                    }\n-                }\n-                ret = xmlRelaxNGValidateDatatype(ctxt, content, define,\n-                                                 ctxt->state->seq);\n-                if (ret == -1) {\n-                    VALID_ERR2(XML_RELAXNG_ERR_DATATYPE, define->name);\n-                } else if (ret == 0) {\n-                    ctxt->state->seq = NULL;\n-                }\n-                if (content != NULL)\n-                    xmlFree(content);\n-                break;\n-            }\n-        case XML_RELAXNG_VALUE:{\n-                xmlChar *content = NULL;\n-                xmlChar *oldvalue;\n-                xmlNodePtr child;\n-\n-                child = node;\n-                while (child != NULL) {\n-                    if (child->type == XML_ELEMENT_NODE) {\n-                        VALID_ERR2(XML_RELAXNG_ERR_VALELEM,\n-                                   node->parent->name);\n-                        ret = -1;\n-                        break;\n-                    } else if ((child->type == XML_TEXT_NODE) ||\n-                               (child->type == XML_CDATA_SECTION_NODE)) {\n-                        content = xmlStrcat(content, child->content);\n-                    }\n-                    \/* TODO: handle entities ... *\/\n-                    child = child->next;\n-                }\n-                if (ret == -1) {\n-                    if (content != NULL)\n-                        xmlFree(content);\n-                    break;\n-                }\n-                if (content == NULL) {\n-                    content = xmlStrdup(BAD_CAST \"\");\n-                    if (content == NULL) {\n-                        xmlRngVErrMemory(ctxt);\n-                        ret = -1;\n-                        break;\n-                    }\n-                }\n-                oldvalue = ctxt->state->value;\n-                ctxt->state->value = content;\n-                ret = xmlRelaxNGValidateValue(ctxt, define);\n-                ctxt->state->value = oldvalue;\n-                if (ret == -1) {\n-                    VALID_ERR2(XML_RELAXNG_ERR_VALUE, define->name);\n-                } else if (ret == 0) {\n-                    ctxt->state->seq = NULL;\n-                }\n-                if (content != NULL)\n-                    xmlFree(content);\n-                break;\n-            }\n-        case XML_RELAXNG_LIST:{\n-                xmlChar *content;\n-                xmlNodePtr child;\n-                xmlChar *oldvalue, *oldendvalue;\n-                int len;\n-\n-                \/*\n-                 * Make sure it's only text nodes\n-                 *\/\n-\n-                content = NULL;\n-                child = node;\n-                while (child != NULL) {\n-                    if (child->type == XML_ELEMENT_NODE) {\n-                        VALID_ERR2(XML_RELAXNG_ERR_LISTELEM,\n-                                   node->parent->name);\n-                        ret = -1;\n-                        break;\n-                    } else if ((child->type == XML_TEXT_NODE) ||\n-                               (child->type == XML_CDATA_SECTION_NODE)) {\n-                        content = xmlStrcat(content, child->content);\n-                    }\n-                    \/* TODO: handle entities ... *\/\n-                    child = child->next;\n-                }\n-                if (ret == -1) {\n-                    if (content != NULL)\n-                        xmlFree(content);\n-                    break;\n-                }\n-                if (content == NULL) {\n-                    content = xmlStrdup(BAD_CAST \"\");\n-                    if (content == NULL) {\n-                        xmlRngVErrMemory(ctxt);\n-                        ret = -1;\n-                        break;\n-                    }\n-                }\n-                len = xmlStrlen(content);\n-                oldvalue = ctxt->state->value;\n-                oldendvalue = ctxt->state->endvalue;\n-                ctxt->state->value = content;\n-                ctxt->state->endvalue = content + len;\n-                ret = xmlRelaxNGValidateValue(ctxt, define);\n-                ctxt->state->value = oldvalue;\n-                ctxt->state->endvalue = oldendvalue;\n-                if (ret == -1) {\n-                    VALID_ERR(XML_RELAXNG_ERR_LIST);\n-                } else if ((ret == 0) && (node != NULL)) {\n-                    ctxt->state->seq = node->next;\n-                }\n-                if (content != NULL)\n-                    xmlFree(content);\n-                break;\n-            }\n-        case XML_RELAXNG_EXCEPT:\n-        case XML_RELAXNG_PARAM:\n-            \/* TODO *\/\n-            ret = -1;\n-            break;\n-    }\n-    ctxt->depth--;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGValidateDefinition:\n- * @ctxt:  a Relax-NG validation context\n- * @define:  the definition to verify\n- *\n- * Validate the current node lists against the definition\n- *\n- * Returns 0 if the validation succeeded or an error code.\n- *\/\n-static int\n-xmlRelaxNGValidateDefinition(xmlRelaxNGValidCtxtPtr ctxt,\n-                             xmlRelaxNGDefinePtr define)\n-{\n-    xmlRelaxNGStatesPtr states, res;\n-    int i, j, k, ret, oldflags;\n-\n-    \/*\n-     * We should NOT have both ctxt->state and ctxt->states\n-     *\/\n-    if ((ctxt->state != NULL) && (ctxt->states != NULL)) {\n-        \/* TODO *\/\n-        xmlRelaxNGFreeValidState(ctxt, ctxt->state);\n-        ctxt->state = NULL;\n-    }\n-\n-    if ((ctxt->states == NULL) || (ctxt->states->nbState == 1)) {\n-        if (ctxt->states != NULL) {\n-            ctxt->state = ctxt->states->tabState[0];\n-            xmlRelaxNGFreeStates(ctxt, ctxt->states);\n-            ctxt->states = NULL;\n-        }\n-        ret = xmlRelaxNGValidateState(ctxt, define);\n-        if ((ctxt->state != NULL) && (ctxt->states != NULL)) {\n-            \/* TODO *\/\n-            xmlRelaxNGFreeValidState(ctxt, ctxt->state);\n-            ctxt->state = NULL;\n-        }\n-        if ((ctxt->states != NULL) && (ctxt->states->nbState == 1)) {\n-            ctxt->state = ctxt->states->tabState[0];\n-            xmlRelaxNGFreeStates(ctxt, ctxt->states);\n-            ctxt->states = NULL;\n-        }\n-        return (ret);\n-    }\n-\n-    states = ctxt->states;\n-    ctxt->states = NULL;\n-    res = NULL;\n-    j = 0;\n-    oldflags = ctxt->flags;\n-    ctxt->flags |= FLAGS_IGNORABLE;\n-    for (i = 0; i < states->nbState; i++) {\n-        ctxt->state = states->tabState[i];\n-        ctxt->states = NULL;\n-        ret = xmlRelaxNGValidateState(ctxt, define);\n-        \/*\n-         * We should NOT have both ctxt->state and ctxt->states\n-         *\/\n-        if ((ctxt->state != NULL) && (ctxt->states != NULL)) {\n-            \/* TODO *\/\n-            xmlRelaxNGFreeValidState(ctxt, ctxt->state);\n-            ctxt->state = NULL;\n-        }\n-        if (ret == 0) {\n-            if (ctxt->states == NULL) {\n-                if (res != NULL) {\n-                    \/* add the state to the container *\/\n-                    xmlRelaxNGAddStates(ctxt, res, ctxt->state);\n-                    ctxt->state = NULL;\n-                } else {\n-                    \/* add the state directly in states *\/\n-                    states->tabState[j++] = ctxt->state;\n-                    ctxt->state = NULL;\n-                }\n-            } else {\n-                if (res == NULL) {\n-                    \/* make it the new container and copy other results *\/\n-                    res = ctxt->states;\n-                    ctxt->states = NULL;\n-                    for (k = 0; k < j; k++)\n-                        xmlRelaxNGAddStates(ctxt, res,\n-                                            states->tabState[k]);\n-                } else {\n-                    \/* add all the new results to res and reff the container *\/\n-                    for (k = 0; k < ctxt->states->nbState; k++)\n-                        xmlRelaxNGAddStates(ctxt, res,\n-                                            ctxt->states->tabState[k]);\n-                    xmlRelaxNGFreeStates(ctxt, ctxt->states);\n-                    ctxt->states = NULL;\n-                }\n-            }\n-        } else {\n-            if (ctxt->state != NULL) {\n-                xmlRelaxNGFreeValidState(ctxt, ctxt->state);\n-                ctxt->state = NULL;\n-            } else if (ctxt->states != NULL) {\n-                for (k = 0; k < ctxt->states->nbState; k++)\n-                    xmlRelaxNGFreeValidState(ctxt,\n-                                             ctxt->states->tabState[k]);\n-                xmlRelaxNGFreeStates(ctxt, ctxt->states);\n-                ctxt->states = NULL;\n-            }\n-        }\n-    }\n-    ctxt->flags = oldflags;\n-    if (res != NULL) {\n-        xmlRelaxNGFreeStates(ctxt, states);\n-        ctxt->states = res;\n-        ret = 0;\n-    } else if (j > 1) {\n-        states->nbState = j;\n-        ctxt->states = states;\n-        ret = 0;\n-    } else if (j == 1) {\n-        ctxt->state = states->tabState[0];\n-        xmlRelaxNGFreeStates(ctxt, states);\n-        ret = 0;\n-    } else {\n-        ret = -1;\n-        xmlRelaxNGFreeStates(ctxt, states);\n-        if (ctxt->states != NULL) {\n-            xmlRelaxNGFreeStates(ctxt, ctxt->states);\n-            ctxt->states = NULL;\n-        }\n-    }\n-    if ((ctxt->state != NULL) && (ctxt->states != NULL)) {\n-        \/* TODO *\/\n-        xmlRelaxNGFreeValidState(ctxt, ctxt->state);\n-        ctxt->state = NULL;\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGValidateDocument:\n- * @ctxt:  a Relax-NG validation context\n- * @doc:  the document\n- *\n- * Validate the given document\n- *\n- * Returns 0 if the validation succeeded or an error code.\n- *\/\n-static int\n-xmlRelaxNGValidateDocument(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)\n-{\n-    int ret;\n-    xmlRelaxNGPtr schema;\n-    xmlRelaxNGGrammarPtr grammar;\n-    xmlRelaxNGValidStatePtr state;\n-    xmlNodePtr node;\n-\n-    if ((ctxt == NULL) || (ctxt->schema == NULL) || (doc == NULL))\n-        return (-1);\n-\n-    ctxt->errNo = XML_RELAXNG_OK;\n-    schema = ctxt->schema;\n-    grammar = schema->topgrammar;\n-    if (grammar == NULL) {\n-        VALID_ERR(XML_RELAXNG_ERR_NOGRAMMAR);\n-        return (-1);\n-    }\n-    state = xmlRelaxNGNewValidState(ctxt, NULL);\n-    ctxt->state = state;\n-    ret = xmlRelaxNGValidateDefinition(ctxt, grammar->start);\n-    if ((ctxt->state != NULL) && (state->seq != NULL)) {\n-        state = ctxt->state;\n-        node = state->seq;\n-        node = xmlRelaxNGSkipIgnored(ctxt, node);\n-        if (node != NULL) {\n-            if (ret != -1) {\n-                VALID_ERR(XML_RELAXNG_ERR_EXTRADATA);\n-                ret = -1;\n-            }\n-        }\n-    } else if (ctxt->states != NULL) {\n-        int i;\n-        int tmp = -1;\n-\n-        for (i = 0; i < ctxt->states->nbState; i++) {\n-            state = ctxt->states->tabState[i];\n-            node = state->seq;\n-            node = xmlRelaxNGSkipIgnored(ctxt, node);\n-            if (node == NULL)\n-                tmp = 0;\n-            xmlRelaxNGFreeValidState(ctxt, state);\n-        }\n-        if (tmp == -1) {\n-            if (ret != -1) {\n-                VALID_ERR(XML_RELAXNG_ERR_EXTRADATA);\n-                ret = -1;\n-            }\n-        }\n-    }\n-    if (ctxt->state != NULL) {\n-        xmlRelaxNGFreeValidState(ctxt, ctxt->state);\n-        ctxt->state = NULL;\n-    }\n-    if (ret != 0)\n-        xmlRelaxNGDumpValidError(ctxt);\n-#ifdef LIBXML_VALID_ENABLED\n-    if (ctxt->idref == 1) {\n-        xmlValidCtxt vctxt;\n-\n-        memset(&vctxt, 0, sizeof(xmlValidCtxt));\n-        vctxt.valid = 1;\n-\n-        if (ctxt->error == NULL) {\n-            vctxt.error = xmlGenericError;\n-            vctxt.warning = xmlGenericError;\n-            vctxt.userData = xmlGenericErrorContext;\n-        } else {\n-            vctxt.error = ctxt->error;\n-            vctxt.warning = ctxt->warning;\n-            vctxt.userData = ctxt->userData;\n-        }\n-\n-        if (xmlValidateDocumentFinal(&vctxt, doc) != 1)\n-            ret = -1;\n-    }\n-#endif \/* LIBXML_VALID_ENABLED *\/\n-    if ((ret == 0) && (ctxt->errNo != XML_RELAXNG_OK))\n-        ret = -1;\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGCleanPSVI:\n- * @node:  an input element or document\n- *\n- * Call this routine to speed up XPath computation on static documents.\n- * This stamps all the element nodes with the document order\n- * Like for line information, the order is kept in the element->content\n- * field, the value stored is actually - the node number (starting at -1)\n- * to be able to differentiate from line numbers.\n- *\n- * Returns the number of elements found in the document or -1 in case\n- *    of error.\n- *\/\n-static void\n-xmlRelaxNGCleanPSVI(xmlNodePtr node) {\n-    xmlNodePtr cur;\n-\n-    if ((node == NULL) ||\n-        ((node->type != XML_ELEMENT_NODE) &&\n-         (node->type != XML_DOCUMENT_NODE) &&\n-         (node->type != XML_HTML_DOCUMENT_NODE)))\n-    return;\n-    if (node->type == XML_ELEMENT_NODE)\n-        node->psvi = NULL;\n-\n-    cur = node->children;\n-    while (cur != NULL) {\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        cur->psvi = NULL;\n-        if (cur->children != NULL) {\n-        cur = cur->children;\n-        continue;\n-        }\n-    }\n-    if (cur->next != NULL) {\n-        cur = cur->next;\n-        continue;\n-    }\n-    do {\n-        cur = cur->parent;\n-        if (cur == NULL)\n-        break;\n-        if (cur == node) {\n-        cur = NULL;\n-        break;\n-        }\n-        if (cur->next != NULL) {\n-        cur = cur->next;\n-        break;\n-        }\n-    } while (cur != NULL);\n-    }\n-    return;\n-}\n-\/************************************************************************\n- *                                    *\n- *            Validation interfaces                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlRelaxNGNewValidCtxt:\n- * @schema:  a precompiled XML RelaxNGs\n- *\n- * Create an XML RelaxNGs validation context based on the given schema\n- *\n- * Returns the validation context or NULL in case of error\n- *\/\n-xmlRelaxNGValidCtxtPtr\n-xmlRelaxNGNewValidCtxt(xmlRelaxNGPtr schema)\n-{\n-    xmlRelaxNGValidCtxtPtr ret;\n-\n-    ret = (xmlRelaxNGValidCtxtPtr) xmlMalloc(sizeof(xmlRelaxNGValidCtxt));\n-    if (ret == NULL) {\n-        xmlRngVErrMemory(NULL);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlRelaxNGValidCtxt));\n-    ret->schema = schema;\n-    ret->errNr = 0;\n-    ret->errMax = 0;\n-    ret->err = NULL;\n-    ret->errTab = NULL;\n-    if (schema != NULL)\n-    ret->idref = schema->idref;\n-    ret->states = NULL;\n-    ret->freeState = NULL;\n-    ret->freeStates = NULL;\n-    ret->errNo = XML_RELAXNG_OK;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRelaxNGFreeValidCtxt:\n- * @ctxt:  the schema validation context\n- *\n- * Free the resources associated to the schema validation context\n- *\/\n-void\n-xmlRelaxNGFreeValidCtxt(xmlRelaxNGValidCtxtPtr ctxt)\n-{\n-    int k;\n-\n-    if (ctxt == NULL)\n-        return;\n-    if (ctxt->states != NULL)\n-        xmlRelaxNGFreeStates(NULL, ctxt->states);\n-    if (ctxt->freeState != NULL) {\n-        for (k = 0; k < ctxt->freeState->nbState; k++) {\n-            xmlRelaxNGFreeValidState(NULL, ctxt->freeState->tabState[k]);\n-        }\n-        xmlRelaxNGFreeStates(NULL, ctxt->freeState);\n-    }\n-    if (ctxt->freeStates != NULL) {\n-        for (k = 0; k < ctxt->freeStatesNr; k++) {\n-            xmlRelaxNGFreeStates(NULL, ctxt->freeStates[k]);\n-        }\n-        xmlFree(ctxt->freeStates);\n-    }\n-    if (ctxt->errTab != NULL)\n-        xmlFree(ctxt->errTab);\n-    if (ctxt->elemTab != NULL) {\n-        xmlRegExecCtxtPtr exec;\n-\n-        exec = xmlRelaxNGElemPop(ctxt);\n-        while (exec != NULL) {\n-            xmlRegFreeExecCtxt(exec);\n-            exec = xmlRelaxNGElemPop(ctxt);\n-        }\n-        xmlFree(ctxt->elemTab);\n-    }\n-    xmlFree(ctxt);\n-}\n-\n-\/**\n- * xmlRelaxNGSetValidErrors:\n- * @ctxt:  a Relax-NG validation context\n- * @err:  the error function\n- * @warn: the warning function\n- * @ctx: the functions context\n- *\n- * DEPRECATED: Use xmlRelaxNGSetValidStructuredErrors.\n- *\n- * Set the error and warning callback information\n- *\/\n-void\n-xmlRelaxNGSetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,\n-                         xmlRelaxNGValidityErrorFunc err,\n-                         xmlRelaxNGValidityWarningFunc warn, void *ctx)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    ctxt->error = err;\n-    ctxt->warning = warn;\n-    ctxt->userData = ctx;\n-    ctxt->serror = NULL;\n-}\n-\n-\/**\n- * xmlRelaxNGSetValidStructuredErrors:\n- * @ctxt:  a Relax-NG validation context\n- * @serror:  the structured error function\n- * @ctx: the functions context\n- *\n- * Set the structured error callback\n- *\/\n-void\n-xmlRelaxNGSetValidStructuredErrors(xmlRelaxNGValidCtxtPtr ctxt,\n-                                   xmlStructuredErrorFunc serror, void *ctx)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    ctxt->serror = serror;\n-    ctxt->error = NULL;\n-    ctxt->warning = NULL;\n-    ctxt->userData = ctx;\n-}\n-\n-\/**\n- * xmlRelaxNGGetValidErrors:\n- * @ctxt:  a Relax-NG validation context\n- * @err:  the error function result\n- * @warn: the warning function result\n- * @ctx: the functions context result\n- *\n- * Get the error and warning callback information\n- *\n- * Returns -1 in case of error and 0 otherwise\n- *\/\n-int\n-xmlRelaxNGGetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,\n-                         xmlRelaxNGValidityErrorFunc * err,\n-                         xmlRelaxNGValidityWarningFunc * warn, void **ctx)\n-{\n-    if (ctxt == NULL)\n-        return (-1);\n-    if (err != NULL)\n-        *err = ctxt->error;\n-    if (warn != NULL)\n-        *warn = ctxt->warning;\n-    if (ctx != NULL)\n-        *ctx = ctxt->userData;\n-    return (0);\n-}\n-\n-\/**\n- * xmlRelaxNGValidateDoc:\n- * @ctxt:  a Relax-NG validation context\n- * @doc:  a parsed document tree\n- *\n- * Validate a document tree in memory.\n- *\n- * Returns 0 if the document is valid, a positive error code\n- *     number otherwise and -1 in case of internal or API error.\n- *\/\n-int\n-xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)\n-{\n-    int ret;\n-\n-    if ((ctxt == NULL) || (doc == NULL))\n-        return (-1);\n-\n-    ctxt->doc = doc;\n-\n-    ret = xmlRelaxNGValidateDocument(ctxt, doc);\n-    \/*\n-     * Remove all left PSVI\n-     *\/\n-    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);\n-\n-    \/*\n-     * TODO: build error codes\n-     *\/\n-    if (ret == -1)\n-        return (1);\n-    return (ret);\n-}\n-\n-#endif \/* LIBXML_SCHEMAS_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/relaxng.c","additions":0,"deletions":10839,"binary":false,"changes":10839,"status":"deleted"},{"patch":"@@ -1,1588 +0,0 @@\n-\/**\n- * rngparser.c: parser for the Relax-NG compact syntax.\n- *\n- * Based on:\n- *   RELAX NG Compact Syntax\n- *   Committee Specification 21 November 2002\n- *   http:\/\/www.oasis-open.org\/committees\/relax-ng\/compact-20021121.html\n- *\n- * See Copyright for the status of this software.\n- *\n- * Daniel Veillard <veillard@redhat.com>\n- *\/\n-\n-#include <string.h>\n-\n-#include <libxml\/parser.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/relaxng.h>\n-#include <libxml\/dict.h>\n-\n-#define MAX_TOKEN 10\n-\n-typedef enum {\n-    CRNG_NONE = 0,\n-    CRNG_OP = 1,\n-    CRNG_KEYWORD,\n-    CRNG_IDENTIFIER,\n-    CRNG_LITERAL_SEGMENT,\n-    CRNG_CNAME,\n-    CRNG_QNAME,\n-    CRNG_NSNAME,\n-    CRNG_DOCUMENTATION\n-} xmlCRNGTokType;\n-\n-typedef enum {\n-    CRNG_OKAY = 0,\n-    CRNG_MEMORY_ERROR,\n-    CRNG_INVALID_CHAR_ERROR,\n-    CRNG_END_ERROR,\n-    CRNG_ENCODING_ERROR\n-} xmlCRNGError;\n-\n-typedef enum {\n-    XML_CRNG_ERROR = -1,\n-    XML_CRNG_OK = 0,\n-    XML_CRNG_EOF = 1\n-} xmlCRelaxNGParserState;\n-\n-typedef struct _token _token;\n-typedef _token *tokenPtr;\n-struct _token {\n-    xmlCRNGTokType toktype;\n-    int toklen;\n-    const xmlChar *token;\n-    const xmlChar *prefix;\n-};\n-\n-typedef struct _xmlCRelaxNGParserCtxt xmlCRelaxNGParserCtxt;\n-typedef xmlCRelaxNGParserCtxt *xmlCRelaxNGParserCtxtPtr;\n-struct _xmlCRelaxNGParserCtxt {\n-    void *userData;            \/* user specific data block *\/\n-    xmlRelaxNGValidityErrorFunc error;    \/* the callback in case of errors *\/\n-    xmlRelaxNGValidityWarningFunc warning;\/* the callback in case of warning *\/\n-    xmlRelaxNGValidErr err;\n-\n-    const xmlChar *compact;\n-    const xmlChar *end;\n-    const xmlChar *cur;\n-    int isElem;\n-    int lineno;\n-    const xmlChar *linestart;\n-    const char *filename;\n-\n-    int  nbTokens;\n-    int  firstToken;\n-    _token tokens[MAX_TOKEN];\n-    int  totalToken;\n-\n-    xmlCRelaxNGParserState state;\n-\n-    int            nbErrors;\n-\n-    xmlDocPtr      res;            \/* the result *\/\n-    xmlNodePtr     ins;            \/* the current insertion node *\/\n-\n-    xmlNsPtr       nsDef;\n-    tokenPtr token;\n-\n-    xmlHashTablePtr namespaces;\n-    xmlHashTablePtr datatypes;\n-\n-    \/*\n-     * dictionary and keywords\n-     *\/\n-    xmlDictPtr     dict;\n-    const xmlChar *key_attribute;\n-    const xmlChar *key_default;\n-    const xmlChar *key_datatypes;\n-    const xmlChar *key_div;\n-    const xmlChar *key_element;\n-    const xmlChar *key_empty;\n-    const xmlChar *key_external;\n-    const xmlChar *key_grammar;\n-    const xmlChar *key_include;\n-    const xmlChar *key_inherit;\n-    const xmlChar *key_list;\n-    const xmlChar *key_mixed;\n-    const xmlChar *key_namespace;\n-    const xmlChar *key_notAllowed;\n-    const xmlChar *key_parent;\n-    const xmlChar *key_start;\n-    const xmlChar *key_string;\n-    const xmlChar *key_text;\n-    const xmlChar *key_token;\n-    const xmlChar *key_equal;\n-    const xmlChar *key_orequal;\n-    const xmlChar *key_andequal;\n-    const xmlChar *key_combine;\n-    const xmlChar *key_or;\n-    const xmlChar *key_comma;\n-    const xmlChar *key_and;\n-    const xmlChar *key_choice;\n-    const xmlChar *key_group;\n-    const xmlChar *key_interleave;\n-    const xmlChar *key_ref;\n-    const xmlChar *key_define;\n-\n-    \/* results *\/\n-    xmlDocPtr doc;    \/* the resulting doc *\/\n-    xmlNodePtr insert;    \/* the insertion point *\/\n-    xmlAttrPtr attrs;   \/* pending attributes *\/\n-};\n-\n-static const xmlChar *xmlCRelaxNGInherit = BAD_CAST \"Inherit string\";\n-static const xmlChar *xmlCRelaxNGDefault = BAD_CAST \"Default string\";\n-\n-#define CUR_CHAR(l) xmlXPathCurrentChar(ctxt, &l)\n-\/**\n- * IS_BLANK:\n- * @c:  an UNICODE value (int)\n- *\n- * Macro to check the following production in the XML spec:\n- *\n- * [3] S ::= (#x20 | #x9 | #xD | #xA)+\n- *\/\n-#ifndef IS_BLANK\n-#define IS_BLANK(c) (((c) == 0x20) || ((c) == 0x09) || ((c) == 0xA) ||    \\\n-                     ((c) == 0x0D))\n-#endif\n-#define IS_SEPARATOR(c) (((c) == 0x20) || ((c) == 0x09) || ((c) == 0xA) || \\\n-                     ((c) == 0x0D) || (c == '#'))\n-\n-#define CRNG_ERROR0(X)                            \\\n-    { xmlCRNGErr(ctxt, X, NULL); return(0); }\n-#define CRNG_ERROR(X)                            \\\n-    { xmlCRNGErr(ctxt, X, NULL); }\n-\n-#define CRNG_MEM_ERROR0()                        \\\n-    { xmlCRNGErr(ctxt, CRNG_MEMORY_ERROR, NULL); return(0); }\n-#define CRNG_MEM_ERROR()                        \\\n-    { xmlCRNGErr(ctxt, CRNG_MEMORY_ERROR, NULL); }\n-\n-#define ERROR(str) xmlCRNGErr(ctxt, 0, str);\n-\n-static void\n-xmlCRNGErr(xmlCRelaxNGParserCtxtPtr ctxt, int err_no, const char *err_msg) {\n-    const xmlChar *cur;\n-    xmlChar buffer[150];\n-    int i, l;\n-\n-    if (ctxt != NULL) {\n-        if (ctxt->filename != NULL)\n-        fprintf(stderr, \"%s:%d \", ctxt->filename, ctxt->lineno);\n-    }\n-    if (err_msg != NULL) {\n-    fprintf(stderr, \"error: %s\\n\", err_msg);\n-    } else if (err_no != 0)\n-    fprintf(stderr, \"error %d\\n\", err_no);\n-    cur = ctxt->cur;\n-    while ((*cur != '\\n') && (*cur != '\\r') && (ctxt->cur - cur < 80)) cur--;\n-    l = ctxt->cur - cur;\n-    cur++;\n-    for (i = 0; i < 100;i++) {\n-        if ((*cur == '\\n') || (*cur == '\\r')) break;\n-        buffer[i] = *cur++;\n-    }\n-    buffer[i] = 0;\n-    fprintf(stderr, \"%s\\n\", buffer);\n-    for (i = 0; i < l;i++) buffer[i] = ' ';\n-    buffer[i++] = '^';\n-    buffer[i++] = 0;\n-    fprintf(stderr, \"%s\\n\", buffer);\n-}\n-\n-\/**\n- * IS_OP\n- * @c:  an UNICODE value (int)\n- *\n- * Macro to check for operator value\n- *\/\n-#ifndef IS_OP\n-#define IS_OP(c) (((c) == ',') || ((c) == '&') || ((c) == '|') ||    \\\n-          ((c) == '?') || ((c) == '-') || ((c) == '*') ||    \\\n-          ((c) == '{') || ((c) == '}') || ((c) == '(') ||    \\\n-          ((c) == ')') || ((c) == '+') || ((c) == '=') ||    \\\n-          ((c) == ':'))\n-#endif\n-\n-static int\n-xmlCRNGIsKeyword(xmlCRelaxNGParserCtxtPtr ctxt, const xmlChar *str) {\n-    if ((str == ctxt->key_attribute) ||\n-        (str == ctxt->key_default) ||\n-        (str == ctxt->key_datatypes) ||\n-        (str == ctxt->key_div) ||\n-        (str == ctxt->key_element) ||\n-        (str == ctxt->key_empty) ||\n-        (str == ctxt->key_external) ||\n-        (str == ctxt->key_grammar) ||\n-        (str == ctxt->key_include) ||\n-        (str == ctxt->key_inherit) ||\n-        (str == ctxt->key_list) ||\n-        (str == ctxt->key_mixed) ||\n-        (str == ctxt->key_namespace) ||\n-        (str == ctxt->key_notAllowed) ||\n-        (str == ctxt->key_parent) ||\n-        (str == ctxt->key_start) ||\n-        (str == ctxt->key_string) ||\n-        (str == ctxt->key_text) ||\n-        (str == ctxt->key_token))\n-    return(1);\n-    return(0);\n-\n-}\n-\n-\/*\n- * xmlCRNGNextToken:\n- * ctxt:  a compact RNG parser context\n- *\n- * Scan the schema to get the next token\n- *\n- * Return 0 if success and -1 in case of error\n- *\/\n-\n-static int\n-xmlCRNGNextToken(xmlCRelaxNGParserCtxtPtr ctxt) {\n-    const xmlChar *cur;\n-    tokenPtr token;\n-\n-    if (ctxt == NULL) return(-1);\n-    if (ctxt->nbTokens >= MAX_TOKEN) return(-1);\n-    token = &(ctxt->tokens[(ctxt->firstToken + ctxt->nbTokens) % MAX_TOKEN]);\n-    token->toktype = CRNG_NONE;\n-\n-    if (ctxt->cur == NULL) {\n-        ctxt->cur = ctxt->compact;\n-    }\n-retry:\n-    if (ctxt->cur >= ctxt->end) {\n-    ctxt->state = XML_CRNG_EOF;\n-    return(-1);\n-    }\n-    while ((ctxt->cur < ctxt->end) &&\n-           (IS_BLANK(*ctxt->cur))) ctxt->cur++;\n-    if (ctxt->cur >= ctxt->end) {\n-    ctxt->state = XML_CRNG_EOF;\n-    return(-1);\n-    }\n-    if (*ctxt->cur == '#') {\n-        cur = ctxt->cur;\n-    cur++;\n-    while ((cur < ctxt->end) && (*cur != '\\n') && (*cur != '\\r'))\n-        cur++;\n-        ctxt->cur = cur;\n-    goto retry;\n-    } else if (*ctxt->cur == '\"') {\n-        \/* string, check for '\"\"\"' *\/\n-    ctxt->cur++;\n-    if (ctxt->cur >= ctxt->end) goto eof;\n-    cur = ctxt->cur;\n-        if ((ctxt->end - ctxt->end > 2) &&\n-        (*cur == '\"') && (cur[1] == '\"')) {\n-        \/* TODO *\/\n-    } else {\n-        while ((cur < ctxt->end) && (*cur != '\"')) cur++;\n-        if (cur >= ctxt->end) goto eof;\n-        token->toklen = cur - ctxt->cur;\n-        token->token = xmlDictLookup(ctxt->dict, ctxt->cur, token->toklen);\n-        token->toktype = CRNG_LITERAL_SEGMENT;\n-        token->prefix = NULL;\n-        cur++;\n-        ctxt->cur = cur;\n-    }\n-    } else if (*ctxt->cur == '\\'') {\n-        \/* string, check for \"'''\" *\/\n-    \/* TODO *\/\n-    } else if ((IS_OP(*ctxt->cur)) || (*ctxt->cur == ':')) {\n-        cur = ctxt->cur;\n-    cur++;\n-    if ((cur < ctxt->end) &&\n-        (((*cur == '=') &&\n-          ((*ctxt->cur == '|') || (*ctxt->cur == '&'))) ||\n-         ((*cur == '*') && (*ctxt->cur == ':')))) {\n-        token->toklen = 2;\n-    } else {\n-        token->toklen = 1;\n-    }\n-    token->token = xmlDictLookup(ctxt->dict, ctxt->cur, token->toklen);\n-    token->toktype = CRNG_OP;\n-    token->prefix = NULL;\n-    ctxt->cur += token->toklen;\n-    } else {\n-        int escape = 0;\n-\n-        cur = ctxt->cur;\n-        if (*cur == '\\\\') {\n-        escape = 1;\n-        cur++;\n-        ctxt->cur++;\n-    }\n-    while ((cur < ctxt->end) &&\n-           (!(IS_SEPARATOR(*cur))) && (!(IS_OP(*cur)))) cur++;\n-\n-    token->toklen = cur - ctxt->cur;\n-    token->token = xmlDictLookup(ctxt->dict, ctxt->cur, token->toklen);\n-    token->prefix = NULL;\n-    ctxt->cur = cur;\n-    if ((escape == 0) && (xmlCRNGIsKeyword(ctxt, token->token)))\n-        token->toktype = CRNG_KEYWORD;\n-    else {\n-        token->toktype = CRNG_IDENTIFIER;\n-    }\n-    if (*ctxt->cur == ':') {\n-        ctxt->cur++;\n-        if (*ctxt->cur == '*') {\n-        ctxt->cur++;\n-        token->toktype = CRNG_NSNAME;\n-        } else {\n-            cur = ctxt->cur;\n-        while ((cur < ctxt->end) &&\n-               (!(IS_SEPARATOR(*cur))) && (!(IS_OP(*cur)))) cur++;\n-        token->prefix = token->token;\n-        token->toklen = cur - ctxt->cur;\n-        token->token = xmlDictLookup(ctxt->dict, ctxt->cur,\n-                                     token->toklen);\n-        ctxt->cur = cur;\n-        if (xmlValidateNCName(token->token, 0) == 0)\n-            token->toktype = CRNG_QNAME;\n-        else {\n-            \/* TODO: sounds like an error ! *\/\n-            token->toktype = CRNG_IDENTIFIER;\n-        }\n-        }\n-    }\n-    }\n-    ctxt->nbTokens++;\n-    return(0);\n-eof:\n-    ctxt->state = XML_CRNG_EOF;\n-    CRNG_ERROR(CRNG_END_ERROR);\n-    return(-1);\n-}\n-\n-\/**\n- * xmlParseCRNGGetToken:\n- * @ctxt: a compact RNG parser context\n- * @no: the number of the token from 1 for the first one\n- *      and 2, 3 ... for read-ahead\n- *\n- * Token reading interface\n- *\n- * returns a pointer to the new token, or NULL in case of error or EOF\n- *\/\n-static tokenPtr\n-xmlParseCRNGGetToken(xmlCRelaxNGParserCtxtPtr ctxt, int no) {\n-    tokenPtr ret;\n-    int res;\n-\n-    if ((no <= 0) || (no >= MAX_TOKEN)) return(NULL);\n-    no--;\n-    while (ctxt->nbTokens <= no) {\n-        res = xmlCRNGNextToken(ctxt);\n-    if (res < 0)\n-        return(NULL);\n-    }\n-    ret = &(ctxt->tokens[(ctxt->firstToken + no) % MAX_TOKEN]);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlParseCRNGDropTokens:\n- * @ctxt: a compact RNG parser context\n- * @nr: the number of token marked as read\n- *\n- * mark a number of token as read and consumed.\n- *\n- * Returns -1 in case of error and 0 otherwise\n- *\/\n-static int\n-xmlParseCRNGDropTokens(xmlCRelaxNGParserCtxtPtr ctxt, int nr) {\n-    if ((nr <= 0) || (nr >= MAX_TOKEN)) return(-1);\n-    while ((ctxt->nbTokens >0) && (nr > 0)) {\n-        ctxt->firstToken++;\n-    nr--;\n-    ctxt->nbTokens--;\n-    ctxt->totalToken++;\n-    if (ctxt->totalToken == 384)\n-        fprintf(stderr, \"found\\n\");\n-    }\n-    ctxt->firstToken = ctxt->firstToken % MAX_TOKEN;\n-    return(0);\n-}\n-\n-static void\n-xmlParseCRNGTokenize(xmlCRelaxNGParserCtxtPtr ctxt) {\n-    tokenPtr token;\n-\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    while (token != NULL) {\n-        switch (token->toktype) {\n-            case CRNG_NONE: printf(\"none\"); break;\n-            case CRNG_OP: printf(\"op\"); break;\n-            case CRNG_KEYWORD: printf(\"keyword\"); break;\n-            case CRNG_IDENTIFIER: printf(\"identifier\"); break;\n-            case CRNG_LITERAL_SEGMENT: printf(\"literal\"); break;\n-            case CRNG_CNAME: printf(\"cname\"); break;\n-            case CRNG_QNAME: printf(\"qname\"); break;\n-            case CRNG_NSNAME: printf(\"nsname\"); break;\n-            case CRNG_DOCUMENTATION: printf(\"doc\"); break;\n-    }\n-        printf(\":%s\\n\", token->token);\n-    xmlParseCRNGDropTokens(ctxt, 1);\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    }\n-}\n-\n-\/**\n- * xmlParseCRNG_attribute:\n- * @ctxt: a compact RNG parser context\n- * @name: the attribute name\n- * @ns: the attribute namespace\n- * @value: the attribute value\n- *\n- * implements attribute of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_attribute(xmlCRelaxNGParserCtxtPtr ctxt,\n-                       const xmlChar *name,\n-                       xmlNsPtr ns,\n-               const xmlChar *value)\n-{\n-    xmlAttrPtr attr;\n-\n-    attr = xmlNewNsPropEatName(NULL, ns, (xmlChar *) name, value);\n-    if (attr == NULL) CRNG_MEM_ERROR0();\n-    attr->next = ctxt->attrs;\n-    if (ctxt->attrs != NULL)\n-        ctxt->attrs->prev = attr;\n-    ctxt->attrs = attr;\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_bindPrefix:\n- * @ctxt: a compact RNG parser context\n- * @prefix: the namespace prefix or NULL\n- * @namespace: the namespace name\n- *\n- * implements bindPrefix of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_bindPrefix(xmlCRelaxNGParserCtxtPtr ctxt,\n-                        const xmlChar *prefix,\n-            const xmlChar *namespace)\n-{\n-    int ret;\n-\n-    if ((prefix != NULL) && (xmlStrEqual(prefix, BAD_CAST \"xml\"))  &&\n-        (!xmlStrEqual(namespace, XML_XML_NAMESPACE))) {\n-    ERROR(\"The \\\"xml\\\" prefix must be bound to \\\"http:\/\/www.w3.org\/XML\/1998\/namespace\\\"\");\n-    return(-1);\n-    } else if ((xmlStrEqual(namespace, XML_XML_NAMESPACE)) &&\n-               (!xmlStrEqual(prefix, BAD_CAST \"xml\"))) {\n-    ERROR(\"The \\\"http:\/\/www.w3.org\/XML\/1998\/namespace\\\" name must be bound to \\\"xml\\\" prefix\");\n-    return(-1);\n-    }\n-    if (ctxt->namespaces == NULL)\n-        ctxt->namespaces = xmlHashCreate(10);\n-    if (ctxt->namespaces == NULL) {\n-        ERROR(\"Failed to create namespace hash table\");\n-    return(-1);\n-    }\n-    if (prefix == NULL)\n-        ret = xmlHashAddEntry(ctxt->namespaces, xmlCRelaxNGDefault,\n-                          (void *) namespace);\n-    else\n-        ret = xmlHashAddEntry(ctxt->namespaces, prefix,\n-                          (void *) namespace);\n-    if (ret < 0) {\n-        if (prefix == NULL) {\n-        ERROR(\"Redefinition of default namespace\");\n-    } else {\n-        ERROR(\"Redefinition of namespace\");\n-    }\n-    return(-1);\n-    }\n-\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_bindDatatypePrefix:\n- * @ctxt: a compact RNG parser context\n- * @prefix: the datatype prefix\n- * @namespace: the datatype identifier\n- *\n- * implements bindDatatypePrefix of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_bindDatatypePrefix(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-                                const xmlChar *prefix,\n-                    const xmlChar *namespace)\n-{\n-    int ret;\n-\n-    if ((prefix != NULL) && (xmlStrEqual(prefix, BAD_CAST \"xsd\"))  &&\n-        (!xmlStrEqual(namespace,\n-          BAD_CAST \"http:\/\/www.w3.org\/2001\/XMLSchema-datatypes\"))) {\n-    ERROR(\"The \\\"xsd\\\" prefix must be bound to \\\"http:\/\/www.w3.org\/2001\/XMLSchema-datatypes\\\"\");\n-    return(-1);\n-    }\n-    if (ctxt->datatypes == NULL)\n-        ctxt->datatypes = xmlHashCreate(10);\n-    if (ctxt->datatypes == NULL) {\n-        ERROR(\"Failed to create namespace hash table\");\n-    return(-1);\n-    }\n-    ret = xmlHashAddEntry(ctxt->datatypes, prefix,\n-                          (void *) namespace);\n-    if (ret < 0) {\n-    ERROR(\"Redefinition of datatype\");\n-    return(-1);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_lookupPrefix:\n- * @ctxt: a compact RNG parser context\n- * @prefix: the namespace prefix or NULL\n- *\n- * implements lookupPrefix of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns the prefix in case of success or NULL in case of error\n- *\/\n-static const xmlChar *\n-xmlParseCRNG_lookupPrefix(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-                        const xmlChar *prefix)\n-{\n-    const xmlChar *ret;\n-\n-    if (prefix == NULL)\n-        ret = xmlHashLookup(ctxt->namespaces, xmlCRelaxNGDefault);\n-    else\n-        ret = xmlHashLookup(ctxt->namespaces, prefix);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlParseCRNG_lookupDatatypePrefix:\n- * @ctxt: a compact RNG parser context\n- * @prefix: the namespace prefix or NULL\n- *\n- * implements lookupDatatypePrefix of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns the prefix in case of success or NULL in case of error\n- *\/\n-static const xmlChar *\n-xmlParseCRNG_lookupDatatypePrefix(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-                        const xmlChar *prefix)\n-{\n-    const xmlChar *ret;\n-    ret = xmlHashLookup(ctxt->datatypes, prefix);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlParseCRNG_datatypeAttributes:\n- * @ctxt: a compact RNG parser context\n- * @prefix: the namespace prefix or NULL\n- *\n- * implements lookupPrefix of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns the prefix in case of success or NULL in case of error\n- *\/\n-static xmlAttrPtr\n-xmlParseCRNG_datatypeAttributes(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-                        const xmlChar *library, const xmlChar *type)\n-{\n-    xmlAttrPtr lib, typ;\n-\n-    lib = xmlNewNsProp(NULL, NULL, BAD_CAST \"datatypeLibrary\", library);\n-    if (lib == NULL) {\n-        CRNG_MEM_ERROR();\n-    return(NULL);\n-    }\n-    typ = xmlNewNsProp(NULL, NULL, BAD_CAST \"type\", type);\n-    if (typ == NULL) {\n-        CRNG_MEM_ERROR();\n-    return(lib);\n-    }\n-    lib->next = typ;\n-\n-    return(lib);\n-}\n-\n-\/**\n- * xmlParseCRNG_XXX:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse XXX of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_XXX(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED)\n-{\n-    return(0);\n-}\n-\n-static int xmlParseCRNG_pattern(xmlCRelaxNGParserCtxtPtr ctxt);\n-static int xmlParseCRNG_nameClass(xmlCRelaxNGParserCtxtPtr ctxt);\n-\n-\/**\n- * xmlParseCRNG_params:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse params of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_params(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED)\n-{\n-    \/* TODO *\/\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_exceptNameClass:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse exceptNameClass of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_exceptNameClass(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED)\n-{\n-    tokenPtr token;\n-    xmlNodePtr insert = ctxt->insert, cur;\n-\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    if ((token->toktype == CRNG_OP) &&\n-        (token->token[0] == '-') && (token->token[1] == 0)) {\n-    xmlParseCRNGDropTokens(ctxt, 1);\n-    cur = xmlNewNode(NULL, BAD_CAST \"except\");\n-    if (cur == NULL) CRNG_MEM_ERROR0();\n-    if (ctxt->insert != NULL)\n-        xmlAddChild(ctxt->insert, cur);\n-    ctxt->insert = cur;\n-    xmlParseCRNG_nameClass(ctxt);\n-    }\n-    ctxt->insert = insert;\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_innerNameClass:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse innerNameClass of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_innerNameClass(xmlCRelaxNGParserCtxtPtr ctxt)\n-{\n-    tokenPtr token;\n-    xmlNodePtr cur;\n-\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    if (token->toktype == CRNG_OP) {\n-        if ((token->token[0] == '(') && (token->token[1] == 0)) {\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        xmlParseCRNG_nameClass(ctxt);\n-        token = xmlParseCRNGGetToken(ctxt, 1);\n-        if ((token->toktype != CRNG_OP) ||\n-            (token->token[0] != ')') || (token->token[1] != 0)) {\n-        ERROR(\"Expecting \\\")\\\" here\");\n-        }\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-    } else if ((token->token[0] == '*') && (token->token[1] == 0)) {\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        cur = xmlNewNode(NULL, BAD_CAST \"anyName\");\n-        if (cur == NULL) CRNG_MEM_ERROR0();\n-        if (ctxt->insert != NULL)\n-        xmlAddChild(ctxt->insert, cur);\n-        ctxt->insert = cur;\n-        xmlParseCRNG_exceptNameClass(ctxt);\n-    } else {\n-        \/* TODO *\/\n-    }\n-    } else if ((token->toktype == CRNG_IDENTIFIER) ||\n-               (token->toktype == CRNG_KEYWORD)) {\n-    cur = xmlNewNode(NULL, BAD_CAST \"name\");\n-    if (cur == NULL) CRNG_MEM_ERROR0();\n-    if (ctxt->isElem) {\n-        xmlSetProp(cur, BAD_CAST \"ns\",\n-                   xmlParseCRNG_lookupPrefix(ctxt, NULL));\n-    } else {\n-        xmlSetProp(cur, BAD_CAST \"ns\", BAD_CAST \"\");\n-    }\n-    xmlNodeAddContent(cur, token->token);\n-    if (ctxt->insert != NULL)\n-        xmlAddChild(ctxt->insert, cur);\n-    ctxt->insert = cur;\n-    xmlParseCRNGDropTokens(ctxt, 1);\n-    } else if (token->toktype == CRNG_CNAME) {\n-        \/* TODO *\/\n-    } else if (token->toktype == CRNG_NSNAME) {\n-    cur = xmlNewNode(NULL, BAD_CAST \"nsName\");\n-    if (cur == NULL) CRNG_MEM_ERROR0();\n-        xmlSetProp(cur, BAD_CAST \"ns\",\n-               xmlParseCRNG_lookupPrefix(ctxt, token->token));\n-    if (ctxt->insert != NULL)\n-        xmlAddChild(ctxt->insert, cur);\n-    ctxt->insert = cur;\n-    xmlParseCRNGDropTokens(ctxt, 1);\n-    xmlParseCRNG_exceptNameClass(ctxt);\n-    } else {\n-        \/* TODO: probably an error *\/\n-    }\n-\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_nameClass:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse nameClass of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_nameClass(xmlCRelaxNGParserCtxtPtr ctxt)\n-{\n-    tokenPtr token;\n-    xmlNodePtr insert = ctxt->insert, last, choice;\n-\n-    ctxt->insert = NULL;\n-    xmlParseCRNG_innerNameClass(ctxt);\n-    last = ctxt->insert;\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    while ((token->toktype == CRNG_OP) &&\n-        (token->token[0] == '|') && (token->token[1] == 0)) {\n-    choice = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_choice);\n-    xmlParseCRNGDropTokens(ctxt, 1);\n-    if (choice == NULL) CRNG_MEM_ERROR0();\n-    ctxt->insert = NULL;\n-    xmlParseCRNG_innerNameClass(ctxt);\n-    xmlAddChild(choice, last);\n-    xmlAddChild(choice, ctxt->insert);\n-    last = choice;\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    }\n-    xmlAddChild(insert, last);\n-\n-    ctxt->insert = insert;\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_patternBlock:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse a pattern block of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_patternBlock(xmlCRelaxNGParserCtxtPtr ctxt)\n-{\n-    tokenPtr token;\n-\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    if ((token->toktype != CRNG_OP) ||\n-    (token->token[0] != '{') || (token->token[1] != 0)) {\n-    ERROR(\"Expecting \\\"{\\\" here\");\n-    }\n-    xmlParseCRNGDropTokens(ctxt, 1);\n-    xmlParseCRNG_pattern(ctxt);\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    if ((token->toktype != CRNG_OP) ||\n-    (token->token[0] != '}') || (token->token[1] != 0)) {\n-    ERROR(\"Expecting \\\"}\\\" here\");\n-    }\n-    xmlParseCRNGDropTokens(ctxt, 1);\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_datatype:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse datatype of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_datatype(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED)\n-{\n-    tokenPtr token;\n-    xmlAttrPtr attrs = NULL;\n-\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    if (token->toktype == CRNG_KEYWORD) {\n-    if (token->token == ctxt->key_string) {\n-        attrs = xmlParseCRNG_datatypeAttributes(ctxt, BAD_CAST \"\",\n-                                                token->token);\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-    } else if (token->token == ctxt->key_token) {\n-        attrs = xmlParseCRNG_datatypeAttributes(ctxt, BAD_CAST \"\",\n-                                                token->token);\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-    } else {\n-        \/* TODO: probably an error *\/\n-    }\n-    } else if (token->toktype == CRNG_LITERAL_SEGMENT) {\n-    ctxt->insert = xmlNewNode(NULL, BAD_CAST \"value\");\n-    xmlParseCRNGDropTokens(ctxt, 1);\n-    if (ctxt->insert == NULL) CRNG_MEM_ERROR0();\n-    xmlNodeAddContent(ctxt->insert, token->token);\n-    } else if (token->toktype == CRNG_QNAME) {\n-    attrs = xmlParseCRNG_datatypeAttributes(ctxt,\n-                xmlParseCRNG_lookupDatatypePrefix(ctxt, token->prefix),\n-            token->token);\n-    } else {\n-        \/* TODO *\/\n-    }\n-    if (attrs != NULL) {\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    if (token->toktype == CRNG_LITERAL_SEGMENT) {\n-        ctxt->insert = xmlNewNode(NULL, BAD_CAST \"value\");\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (ctxt->insert == NULL) {\n-            xmlFreePropList(attrs);\n-        CRNG_MEM_ERROR0();\n-        }\n-        ctxt->insert->properties = attrs;\n-        xmlNodeAddContent(ctxt->insert, token->token);\n-    } else if ((token->toktype == CRNG_OP) &&\n-               (token->token[0] == '{') && (token->token[0] == 0)) {\n-        ctxt->insert = xmlNewNode(NULL, BAD_CAST \"data\");\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (ctxt->insert == NULL) {\n-            xmlFreePropList(attrs);\n-        CRNG_MEM_ERROR0();\n-        }\n-        ctxt->insert->properties = attrs;\n-        xmlParseCRNG_params(ctxt);\n-        } else {\n-        ctxt->insert = xmlNewNode(NULL, BAD_CAST \"data\");\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (ctxt->insert == NULL) {\n-            xmlFreePropList(attrs);\n-        CRNG_MEM_ERROR0();\n-        }\n-        ctxt->insert->properties = attrs;\n-        xmlNodeAddContent(ctxt->insert, token->token);\n-    }\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_primary:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse primary of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_primary(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED)\n-{\n-    tokenPtr token;\n-\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    if (token == NULL)\n-        return(0);\n-    if (token->toktype == CRNG_KEYWORD) {\n-        if (token->token == ctxt->key_element) {\n-        ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (ctxt->insert == NULL) CRNG_MEM_ERROR0();\n-        ctxt->isElem = 1;\n-        xmlParseCRNG_nameClass(ctxt);\n-        xmlParseCRNG_patternBlock(ctxt);\n-    } else if (token->token == ctxt->key_attribute) {\n-        ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (ctxt->insert == NULL) CRNG_MEM_ERROR0();\n-        ctxt->isElem = 0;\n-        xmlParseCRNG_nameClass(ctxt);\n-        xmlParseCRNG_patternBlock(ctxt);\n-    } else if (token->token == ctxt->key_mixed) {\n-        ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (ctxt->insert == NULL) CRNG_MEM_ERROR0();\n-        xmlParseCRNG_patternBlock(ctxt);\n-    } else if (token->token == ctxt->key_list) {\n-        ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (ctxt->insert == NULL) CRNG_MEM_ERROR0();\n-        xmlParseCRNG_patternBlock(ctxt);\n-    } else if (token->token == ctxt->key_empty) {\n-        ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (ctxt->insert == NULL) CRNG_MEM_ERROR0();\n-    } else if (token->token == ctxt->key_notAllowed) {\n-        ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (ctxt->insert == NULL) CRNG_MEM_ERROR0();\n-    } else if (token->token == ctxt->key_text) {\n-        ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (ctxt->insert == NULL) CRNG_MEM_ERROR0();\n-    } else if (token->token == ctxt->key_parent) {\n-        ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (ctxt->insert == NULL) CRNG_MEM_ERROR0();\n-        \/* TODO *\/\n-    } else if (token->token == ctxt->key_grammar) {\n-        ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) token->token);\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (ctxt->insert == NULL) CRNG_MEM_ERROR0();\n-        \/* TODO *\/\n-    } else if (token->token == ctxt->key_external) {\n-        ctxt->insert = xmlNewNode(NULL, BAD_CAST \"externalRef\");\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (ctxt->insert == NULL) CRNG_MEM_ERROR0();\n-        \/* TODO *\/\n-    } else {\n-       \/* TODO *\/\n-    }\n-    } else if (token->toktype == CRNG_IDENTIFIER) {\n-    ctxt->insert = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_ref);\n-    if (ctxt->insert == NULL) CRNG_MEM_ERROR0();\n-    xmlSetProp(ctxt->insert, BAD_CAST \"name\", token->token);\n-    xmlParseCRNGDropTokens(ctxt, 1);\n-    } else if (token->toktype == CRNG_QNAME) {\n-        xmlParseCRNG_datatype(ctxt);\n-    } else if (token->toktype == CRNG_LITERAL_SEGMENT) {\n-        xmlParseCRNG_datatype(ctxt);\n-    } else if ((token->toktype == CRNG_OP) &&\n-               (token->token[0] == '(') && (token->token[1] == 0)) {\n-    xmlParseCRNGDropTokens(ctxt, 1);\n-    xmlParseCRNG_pattern(ctxt);\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    if ((token->toktype != CRNG_OP) ||\n-        (token->token[0] != ')') || (token->token[1] != 0)) {\n-        ERROR(\"Expecting \\\")\\\" here\");\n-    }\n-    xmlParseCRNGDropTokens(ctxt, 1);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_particle:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse particle of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_particle(xmlCRelaxNGParserCtxtPtr ctxt)\n-{\n-    tokenPtr token;\n-    xmlNodePtr insert = ctxt->insert, res, tmp = NULL;\n-\n-    ctxt->insert = NULL;\n-    xmlParseCRNG_primary(ctxt);\n-    res = ctxt->insert;\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    if ((token != NULL) && (token->toktype == CRNG_OP)) {\n-        if ((token->token[0] == '*') && (token->token[1] == 0)) {\n-        tmp = xmlNewNode(NULL, BAD_CAST \"zeroOrMore\");\n-        if (tmp == NULL) CRNG_MEM_ERROR0();\n-    } else if ((token->token[0] == '+') && (token->token[1] == 0)) {\n-        tmp = xmlNewNode(NULL, BAD_CAST \"oneOrMore\");\n-        if (tmp == NULL) CRNG_MEM_ERROR0();\n-    } else if ((token->token[0] == '?') && (token->token[1] == 0)) {\n-        tmp = xmlNewNode(NULL, BAD_CAST \"optional\");\n-        if (tmp == NULL) CRNG_MEM_ERROR0();\n-    }\n-    if (tmp != NULL) {\n-        xmlAddChild(tmp, res);\n-        res = tmp;\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-    }\n-    }\n-    if (insert != NULL) {\n-        xmlAddChild(insert, res);\n-    ctxt->insert = insert;\n-    } else\n-        ctxt->insert = res;\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_pattern:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse pattern of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_pattern(xmlCRelaxNGParserCtxtPtr ctxt)\n-{\n-    tokenPtr token;\n-    xmlNodePtr insert = ctxt->insert, prev, grp;\n-\n-    ctxt->insert = NULL;\n-    xmlParseCRNG_particle(ctxt);\n-    prev = ctxt->insert;\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    while ((prev != NULL) && (token != NULL) && (token->toktype == CRNG_OP)) {\n-        if (token->token == ctxt->key_or) {\n-        grp = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_choice);\n-        if (grp == NULL) CRNG_MEM_ERROR0();\n-    } else if (token->token == ctxt->key_and) {\n-        grp = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_interleave);\n-        if (grp == NULL) CRNG_MEM_ERROR0();\n-    } else if (token->token == ctxt->key_comma) {\n-        grp = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_group);\n-        if (grp == NULL) CRNG_MEM_ERROR0();\n-    } else\n-       break;\n-    xmlParseCRNGDropTokens(ctxt, 1);\n-        ctxt->insert = NULL;\n-    xmlParseCRNG_particle(ctxt);\n-    xmlAddChild(grp, prev);\n-    xmlAddChild(grp, ctxt->insert);\n-    prev = grp;\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    }\n-    if (insert != NULL) {\n-    xmlAddChild(insert, prev);\n-    ctxt->insert = insert;\n-    } else {\n-    ctxt->insert = prev;\n-    }\n-\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_component:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse component of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_component(xmlCRelaxNGParserCtxtPtr ctxt)\n-{\n-    tokenPtr token, tok2;\n-    xmlNodePtr insert = ctxt->insert;\n-\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    if (token == NULL)\n-        return(0);\n-    if (token->toktype == CRNG_KEYWORD) {\n-        if (token->token == ctxt->key_start) {\n-        xmlNodePtr start;\n-\n-        start = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_start);\n-        if (start == NULL) CRNG_MEM_ERROR0();\n-        if (ctxt->insert != NULL)\n-            xmlAddChild(ctxt->insert, start);\n-        ctxt->insert = start;\n-            xmlParseCRNGDropTokens(ctxt, 1);\n-        token = xmlParseCRNGGetToken(ctxt, 1);\n-\n-            if ((token->toktype == CRNG_OP) &&\n-            (token->token == ctxt->key_equal)) {\n-        } else if ((token->toktype == CRNG_OP) &&\n-                   (token->token == ctxt->key_orequal)) {\n-        xmlParseCRNG_attribute(ctxt, ctxt->key_combine, NULL,\n-                               BAD_CAST \"choice\");\n-        } else if ((token->toktype == CRNG_OP) &&\n-                   (token->token == ctxt->key_andequal)) {\n-        xmlParseCRNG_attribute(ctxt, ctxt->key_combine, NULL,\n-                               BAD_CAST \"interleave\");\n-        } else {\n-            ERROR(\"expecting \\\"=\\\" or \\\"&=\\\" or \\\"|=\\\" here\")\n-        return(-1);\n-        }\n-        start->properties = ctxt->attrs;\n-        ctxt->attrs = NULL;\n-            xmlParseCRNGDropTokens(ctxt, 1);\n-        xmlParseCRNG_pattern(ctxt);\n-\n-    } else if (token->token == ctxt->key_include) {\n-        \/* TODO *\/\n-    } else if (token->token == ctxt->key_div) {\n-        \/* TODO *\/\n-    } else {\n-        return(-1);\n-    }\n-    } else if (token->toktype == CRNG_IDENTIFIER) {\n-        xmlNodePtr define;\n-    const xmlChar *identifier;\n-\n-        identifier = token->token;\n-    tok2 = xmlParseCRNGGetToken(ctxt, 2);\n-    if ((tok2->toktype == CRNG_OP) &&\n-        (tok2->token == ctxt->key_equal)) {\n-    } else if ((tok2->toktype == CRNG_OP) &&\n-           (tok2->token == ctxt->key_orequal)) {\n-        xmlParseCRNG_attribute(ctxt, ctxt->key_combine, NULL,\n-                   BAD_CAST \"choice\");\n-    } else if ((tok2->toktype == CRNG_OP) &&\n-           (tok2->token == ctxt->key_andequal)) {\n-        xmlParseCRNG_attribute(ctxt, ctxt->key_combine, NULL,\n-                   BAD_CAST \"interleave\");\n-    } else {\n-        ERROR(\"expecting \\\"=\\\" or \\\"&=\\\" or \\\"|=\\\" here\")\n-        return(-1);\n-    }\n-    xmlParseCRNGDropTokens(ctxt, 2);\n-\n-    define = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_define);\n-    if (define == NULL) CRNG_MEM_ERROR0();\n-    define->properties = ctxt->attrs;\n-    ctxt->attrs = NULL;\n-    xmlSetProp(define, BAD_CAST \"name\", identifier);\n-    if (ctxt->insert != NULL)\n-        xmlAddChild(ctxt->insert, define);\n-    ctxt->insert = define;\n-    xmlParseCRNG_pattern(ctxt);\n-    } else {\n-    return(-1);\n-    }\n-    ctxt->insert = insert;\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_grammar:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse grammar of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_grammar(xmlCRelaxNGParserCtxtPtr ctxt ATTRIBUTE_UNUSED)\n-{\n-    tokenPtr token;\n-    int ret;\n-\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    while (token != NULL) {\n-        ret = xmlParseCRNG_component(ctxt);\n-    if (ret != 0)\n-        break;\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_topLevelBody:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse topLevelBody of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_topLevelBody(xmlCRelaxNGParserCtxtPtr ctxt)\n-{\n-    tokenPtr token, tok2;\n-\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    if (token->toktype == CRNG_KEYWORD) {\n-        if ((token->token == ctxt->key_start) ||\n-        (token->token == ctxt->key_include) ||\n-        (token->token == ctxt->key_div)) {\n-        xmlNodePtr grammar;\n-\n-        grammar = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_grammar);\n-        if (grammar == NULL) CRNG_MEM_ERROR0();\n-        xmlDocSetRootElement(ctxt->doc, grammar);\n-        ctxt->insert = grammar;\n-\n-        xmlParseCRNG_grammar(ctxt);\n-    } else {\n-        xmlParseCRNG_pattern(ctxt);\n-    }\n-    } else {\n-        tok2 = xmlParseCRNGGetToken(ctxt, 2);\n-    if ((tok2->toktype == CRNG_OP) &&\n-        ((tok2->token == ctxt->key_equal) ||\n-         (tok2->token == ctxt->key_orequal) ||\n-         (tok2->token == ctxt->key_andequal))) {\n-        xmlNodePtr grammar;\n-\n-        grammar = xmlNewNodeEatName(NULL, (xmlChar *) ctxt->key_grammar);\n-        if (grammar == NULL) CRNG_MEM_ERROR0();\n-        xmlDocSetRootElement(ctxt->doc, grammar);\n-        ctxt->insert = grammar;\n-\n-        xmlParseCRNG_grammar(ctxt);\n-    } else {\n-        xmlParseCRNG_pattern(ctxt);\n-    }\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_namespacePrefix:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse namespacePrefix of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns the prefix or NULL in case of error\n- *\/\n-static const xmlChar *\n-xmlParseCRNG_namespacePrefix(xmlCRelaxNGParserCtxtPtr ctxt)\n-{\n-    tokenPtr token;\n-    const xmlChar *prefix = NULL;\n-\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    if (token->toktype == CRNG_IDENTIFIER) {\n-        prefix = token->token;\n-    } else if (token->toktype == CRNG_OP) {\n-    if ((token->token[0] == '=') && (token->token[1] == 0))\n-        return(NULL);\n-        prefix = token->token;\n-    } else {\n-    ERROR(\"Expecting a namespace prefix\");\n-    return(NULL);\n-    }\n-    xmlParseCRNGDropTokens(ctxt, 1);\n-\n-    if (xmlStrEqual(prefix, BAD_CAST \"xmlns\")) {\n-    ERROR(\"Namespace prefix \\\"xmlns\\\" is forbidden\");\n-    }\n-    return(prefix);\n-}\n-\n-\/**\n- * xmlParseCRNG_decl:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse decl of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_decl(xmlCRelaxNGParserCtxtPtr ctxt)\n-{\n-    const xmlChar *prefix = NULL;\n-    const xmlChar *namespace = NULL;\n-    tokenPtr token;\n-\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    if (token->toktype != CRNG_KEYWORD) return(-1);\n-    if (token->token == ctxt->key_default) {\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        token = xmlParseCRNGGetToken(ctxt, 1);\n-        if ((token->toktype != CRNG_KEYWORD) ||\n-        (token->token != ctxt->key_namespace)) {\n-        ERROR(\"Expecting keyword \\\"namespace\\\" after \\\"default\\\"\");\n-    }\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-    prefix = xmlParseCRNG_namespacePrefix(ctxt);\n-        token = xmlParseCRNGGetToken(ctxt, 1);\n-        if ((token->toktype != CRNG_OP) ||\n-        (token->token[0] != '=') || (token->token[1] != 0)) {\n-        ERROR(\"Expecting keyword \\\"=\\\" here\");\n-    }\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        token = xmlParseCRNGGetToken(ctxt, 1);\n-        if ((token->toktype == CRNG_KEYWORD) &&\n-        (token->token == ctxt->key_inherit)) {\n-        namespace = xmlCRelaxNGInherit;\n-    } else if (token->toktype == CRNG_LITERAL_SEGMENT) {\n-        namespace = token->token;\n-    } else {\n-        ERROR(\"Expecting an URI or \\\"inherit\\\" value\");\n-    }\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (namespace != NULL) {\n-        if (prefix != NULL)\n-        xmlParseCRNG_bindPrefix(ctxt, prefix, namespace);\n-            xmlParseCRNG_bindPrefix(ctxt, NULL, namespace);\n-    }\n-    } else if (token->token == ctxt->key_namespace) {\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-    prefix = xmlParseCRNG_namespacePrefix(ctxt);\n-        token = xmlParseCRNGGetToken(ctxt, 1);\n-        if ((token->toktype != CRNG_OP) ||\n-        (token->token[0] != '=') || (token->token[1] != 0)) {\n-        ERROR(\"Expecting keyword \\\"=\\\" here\");\n-    }\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        token = xmlParseCRNGGetToken(ctxt, 1);\n-        if ((token->toktype == CRNG_KEYWORD) &&\n-        (token->token == ctxt->key_inherit)) {\n-        namespace = xmlCRelaxNGInherit;\n-    } else if (token->toktype == CRNG_LITERAL_SEGMENT) {\n-        namespace = token->token;\n-    } else {\n-        ERROR(\"Expecting an URI or \\\"inherit\\\" value\");\n-    }\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if (namespace != NULL)\n-        xmlParseCRNG_bindPrefix(ctxt, prefix, namespace);\n-    } else if (token->token == ctxt->key_datatypes) {\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-\n-        token = xmlParseCRNGGetToken(ctxt, 1);\n-    if ((token->toktype != CRNG_KEYWORD) &&\n-        (token->toktype != CRNG_IDENTIFIER)) {\n-        ERROR(\"Expecting a datatype prefix identifier here\");\n-    } else\n-        prefix = token->token;\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        token = xmlParseCRNGGetToken(ctxt, 1);\n-        if ((token->toktype != CRNG_OP) ||\n-        (token->token[0] != '=') || (token->token[1] != 0)) {\n-        ERROR(\"Expecting keyword \\\"=\\\" here\");\n-    }\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        token = xmlParseCRNGGetToken(ctxt, 1);\n-    if (token->toktype == CRNG_LITERAL_SEGMENT) {\n-        namespace = token->token;\n-    } else {\n-        ERROR(\"Expecting a literal value for the datatype identifier\");\n-    }\n-        xmlParseCRNGDropTokens(ctxt, 1);\n-        if ((namespace != NULL) && (prefix != NULL))\n-        xmlParseCRNG_bindDatatypePrefix(ctxt, prefix, namespace);\n-    }\n-\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_preamble:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse preamble of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_preamble(xmlCRelaxNGParserCtxtPtr ctxt)\n-{\n-    tokenPtr token;\n-\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    while (token != NULL) {\n-    if (token == NULL) return(-1);\n-    if ((token->toktype == CRNG_KEYWORD) &&\n-        ((token->token == ctxt->key_default) ||\n-         (token->token == ctxt->key_namespace) ||\n-         (token->token == ctxt->key_datatypes))) {\n-        xmlParseCRNG_decl(ctxt);\n-    } else\n-        break;\n-    token = xmlParseCRNGGetToken(ctxt, 1);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlParseCRNG_topLevel:\n- * @ctxt: a compact RNG parser context\n- *\n- * Parse topLevel of the RELAX NG Compact Syntax Appendix A\n- *\n- * Returns 0 in case of success and -1 in case of error\n- *\/\n-static int\n-xmlParseCRNG_topLevel(xmlCRelaxNGParserCtxtPtr ctxt)\n-{\n-    xmlParseCRNG_preamble(ctxt);\n-    xmlParseCRNG_topLevelBody(ctxt);\n-    return(0);\n-}\n-\n-\/**\n- * xmlConvertCRNG:\n- * @schemas:  pointer to the text of the compact schemas\n- * @len:  length of the schemas in bytes (or 0)\n- * @encoding:  encoding indicated by the context or NULL\n- *\n- * Compiles the schemas into the equivalent Relax-NG XML structure\n- *\n- * Returns the xmlDocPtr resulting from the compilation or\n- *         NULL in case of error\n- *\/\n-xmlDocPtr\n-xmlConvertCRNG(const char *schemas, int len, const char *encoding) {\n-    struct _xmlCRelaxNGParserCtxt ctxt;\n-    xmlDocPtr ret = NULL;\n-\n-    if (schemas == NULL) return(NULL);\n-    if (len <= 5) len = xmlStrlen((const unsigned char *) schemas);\n-    if (len <= 0) return(NULL);\n-\n-    memset(&ctxt, 0, sizeof(ctxt));\n-    ctxt.compact = (const unsigned char *) schemas;\n-    ctxt.cur = (const unsigned char *) schemas;\n-    ctxt.end = (const unsigned char *) &schemas[len];\n-    ctxt.dict = xmlDictCreate();\n-    if (ctxt.dict == NULL)\n-        return(NULL);\n-    ctxt.doc = xmlNewDoc(NULL);\n-    if (ctxt.doc == NULL) {\n-    xmlDictFree(ctxt.dict);\n-    return(NULL);\n-    }\n-    ctxt.doc->dict = ctxt.dict;\n-    xmlDictReference(ctxt.dict);\n-\n-    ctxt.nbTokens = 0;\n-    ctxt.firstToken = 0;\n-    ctxt.key_attribute = xmlDictLookup(ctxt.dict, BAD_CAST \"attribute\", -1);\n-    ctxt.key_default = xmlDictLookup(ctxt.dict, BAD_CAST \"default\", -1);\n-    ctxt.key_datatypes = xmlDictLookup(ctxt.dict, BAD_CAST \"datatypes\", -1);\n-    ctxt.key_div = xmlDictLookup(ctxt.dict, BAD_CAST \"div\", -1);\n-    ctxt.key_element = xmlDictLookup(ctxt.dict, BAD_CAST \"element\", -1);\n-    ctxt.key_empty = xmlDictLookup(ctxt.dict, BAD_CAST \"empty\", -1);\n-    ctxt.key_external = xmlDictLookup(ctxt.dict, BAD_CAST \"external\", -1);\n-    ctxt.key_grammar = xmlDictLookup(ctxt.dict, BAD_CAST \"grammar\", -1);\n-    ctxt.key_include = xmlDictLookup(ctxt.dict, BAD_CAST \"include\", -1);\n-    ctxt.key_inherit = xmlDictLookup(ctxt.dict, BAD_CAST \"inherit\", -1);\n-    ctxt.key_list = xmlDictLookup(ctxt.dict, BAD_CAST \"list\", -1);\n-    ctxt.key_mixed = xmlDictLookup(ctxt.dict, BAD_CAST \"mixed\", -1);\n-    ctxt.key_namespace = xmlDictLookup(ctxt.dict, BAD_CAST \"namespace\", -1);\n-    ctxt.key_notAllowed = xmlDictLookup(ctxt.dict, BAD_CAST \"notAllowed\", -1);\n-    ctxt.key_parent = xmlDictLookup(ctxt.dict, BAD_CAST \"parent\", -1);\n-    ctxt.key_start = xmlDictLookup(ctxt.dict, BAD_CAST \"start\", -1);\n-    ctxt.key_string = xmlDictLookup(ctxt.dict, BAD_CAST \"string\", -1);\n-    ctxt.key_text = xmlDictLookup(ctxt.dict, BAD_CAST \"text\", -1);\n-    ctxt.key_token = xmlDictLookup(ctxt.dict, BAD_CAST \"token\", -1);\n-    ctxt.key_equal = xmlDictLookup(ctxt.dict, BAD_CAST \"=\", 1);\n-    ctxt.key_orequal = xmlDictLookup(ctxt.dict, BAD_CAST \"|=\", 2);\n-    ctxt.key_andequal = xmlDictLookup(ctxt.dict, BAD_CAST \"&=\", 2);\n-    ctxt.key_combine = xmlDictLookup(ctxt.dict, BAD_CAST \"&=\", 2);\n-    ctxt.key_or = xmlDictLookup(ctxt.dict, BAD_CAST \"|\", 1);\n-    ctxt.key_comma = xmlDictLookup(ctxt.dict, BAD_CAST \",\", 1);\n-    ctxt.key_and = xmlDictLookup(ctxt.dict, BAD_CAST \"&\", 1);\n-    ctxt.key_choice = xmlDictLookup(ctxt.dict, BAD_CAST \"choice\", -1);\n-    ctxt.key_group = xmlDictLookup(ctxt.dict, BAD_CAST \"group\", -1);\n-    ctxt.key_interleave = xmlDictLookup(ctxt.dict, BAD_CAST \"interleave\", -1);\n-    ctxt.key_ref = xmlDictLookup(ctxt.dict, BAD_CAST \"ref\", 3);\n-    ctxt.key_define = xmlDictLookup(ctxt.dict, BAD_CAST \"define\", 6);\n-\n-    \/* xmlConvertCRNGTokenize(&ctxt); *\/\n-    xmlConvertCRNG_topLevel(&ctxt);\n-\n-    xmlDictFree(ctxt.dict);\n-\n-    ret = ctxt.doc;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlConvertCRNGFile:\n- * @URL: URL or filename for the resource\n- * @encoding:  encoding indicated by the context or NULL\n- *\n- * Compiles the schemas into the equivalent Relax-NG XML structure\n- *\n- * Returns the xmlDocPtr resulting from the compilation or\n- *         NULL in case of error\n- *\/\n-xmlDocPtr\n-xmlConvertCRNGFile(const char *URL, const char *encoding) {\n-}\n-\n-#ifdef STANDALONE\n-const xmlChar *schemas =\n-\"# RELAX NG XML syntax specified in compact syntax.\\n\\\n-\\n\\\n-default namespace rng = \\\"http:\/\/relaxng.org\/ns\/structure\/1.0\\\"\\n\\\n-namespace local = \\\"\\\"\\n\\\n-datatypes xsd = \\\"http:\/\/www.w3.org\/2001\/XMLSchema-datatypes\\\"\\n\\\n-\\n\\\n-start = pattern\\n\\\n-\\n\\\n-pattern =\\n\\\n-  element element { (nameQName | nameClass), (common & pattern+) }\\n\\\n-  | element attribute { (nameQName | nameClass), (common & pattern?) }\\n\\\n-  | element group|interleave|choice|optional\\n\\\n-            |zeroOrMore|oneOrMore|list|mixed { common & pattern+ }\\n\\\n-  | element ref|parentRef { nameNCName, common }\\n\\\n-  | element empty|notAllowed|text { common }\\n\\\n-  | element data { type, param*, (common & exceptPattern?) }\\n\\\n-  | element value { commonAttributes, type?, xsd:string }\\n\\\n-  | element externalRef { href, common }\\n\\\n-  | element grammar { common & grammarContent* }\\n\\\n-\\n\\\n-param = element param { commonAttributes, nameNCName, xsd:string }\\n\\\n-\\n\\\n-exceptPattern = element except { common & pattern+ }\\n\\\n-\\n\\\n-grammarContent =\\n\\\n-  definition\\n\\\n-  | element div { common & grammarContent* }\\n\\\n-  | element include { href, (common & includeContent*) }\\n\\\n-\\n\\\n-includeContent =\\n\\\n-  definition\\n\\\n-  | element div { common & includeContent* }\\n\\\n-\\n\\\n-definition =\\n\\\n-  element start { combine?, (common & pattern+) }\\n\\\n-  | element define { nameNCName, combine?, (common & pattern+) }\\n\\\n-\\n\\\n-combine = attribute combine { \\\"choice\\\" | \\\"interleave\\\" }\\n\\\n-\\n\\\n-nameClass =\\n\\\n-  element name { commonAttributes, xsd:QName }\\n\\\n-  | element anyName { common & exceptNameClass? }\\n\\\n-  | element nsName { common & exceptNameClass? }\\n\\\n-  | element choice { common & nameClass+ }\\n\\\n-\\n\\\n-exceptNameClass = element except { common & nameClass+ }\\n\\\n-\\n\\\n-nameQName = attribute name { xsd:QName }\\n\\\n-nameNCName = attribute name { xsd:NCName }\\n\\\n-href = attribute href { xsd:anyURI }\\n\\\n-type = attribute type { xsd:NCName }\\n\\\n-\\n\\\n-common = commonAttributes, foreignElement*\\n\\\n-\\n\\\n-commonAttributes =\\n\\\n-  attribute ns { xsd:string }?,\\n\\\n-  attribute datatypeLibrary { xsd:anyURI }?,\\n\\\n-  foreignAttribute*\\n\\\n-\\n\\\n-foreignElement = element * - rng:* { (anyAttribute | text | anyElement)* }\\n\\\n-foreignAttribute = attribute * - (rng:*|local:*) { text }\\n\\\n-anyElement = element * { (anyAttribute | text | anyElement)* }\\n\\\n-anyAttribute = attribute * { text }\\n\\\n-\";\n-\n-int main(int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED) {\n-    xmlDocPtr res;\n-\n-    res = xmlConvertCRNG(schemas, -1);\n-    if (res != NULL) {\n-        xmlDocFormatDump(stdout, res, 1);\n-    xmlFreeDoc(res);\n-    }\n-    return(0);\n-}\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/rngparser.c","additions":0,"deletions":1588,"binary":false,"changes":1588,"status":"deleted"},{"patch":"@@ -1,1166 +0,0 @@\n-\/*\n- * runsuite.c: C program to run libxml2 against published testsuites\n- *\n- * See Copyright for the status of this software.\n- *\n- * daniel@veillard.com\n- *\/\n-\n-#include \"config.h\"\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <sys\/stat.h>\n-\n-#include <libxml\/parser.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/tree.h>\n-#include <libxml\/uri.h>\n-#if defined(LIBXML_SCHEMAS_ENABLED) && defined(LIBXML_XPATH_ENABLED)\n-#include <libxml\/xmlreader.h>\n-\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-\n-#include <libxml\/relaxng.h>\n-#include <libxml\/xmlschemas.h>\n-#include <libxml\/xmlschemastypes.h>\n-\n-#define LOGFILE \"runsuite.log\"\n-static FILE *logfile = NULL;\n-static int verbose = 0;\n-\n-\n-\/************************************************************************\n- *                                    *\n- *        File name and path utilities                *\n- *                                    *\n- ************************************************************************\/\n-\n-static int checkTestFile(const char *filename) {\n-    struct stat buf;\n-\n-    if (stat(filename, &buf) == -1)\n-        return(0);\n-\n-#if defined(_WIN32)\n-    if (!(buf.st_mode & _S_IFREG))\n-        return(0);\n-#else\n-    if (!S_ISREG(buf.st_mode))\n-        return(0);\n-#endif\n-\n-    return(1);\n-}\n-\n-static xmlChar *composeDir(const xmlChar *dir, const xmlChar *path) {\n-    char buf[500];\n-\n-    if (dir == NULL) return(xmlStrdup(path));\n-    if (path == NULL) return(NULL);\n-\n-    snprintf(buf, 500, \"%s\/%s\", (const char *) dir, (const char *) path);\n-    return(xmlStrdup((const xmlChar *) buf));\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Libxml2 specific routines                *\n- *                                    *\n- ************************************************************************\/\n-\n-static int nb_tests = 0;\n-static int nb_errors = 0;\n-static int nb_internals = 0;\n-static int nb_schematas = 0;\n-static int nb_unimplemented = 0;\n-static int nb_leaks = 0;\n-static int extraMemoryFromResolver = 0;\n-\n-static int\n-fatalError(void) {\n-    fprintf(stderr, \"Exitting tests on fatal error\\n\");\n-    exit(1);\n-}\n-\n-\/*\n- * that's needed to implement <resource>\n- *\/\n-#define MAX_ENTITIES 20\n-static char *testEntitiesName[MAX_ENTITIES];\n-static char *testEntitiesValue[MAX_ENTITIES];\n-static int nb_entities = 0;\n-static void resetEntities(void) {\n-    int i;\n-\n-    for (i = 0;i < nb_entities;i++) {\n-        if (testEntitiesName[i] != NULL)\n-        xmlFree(testEntitiesName[i]);\n-        if (testEntitiesValue[i] != NULL)\n-        xmlFree(testEntitiesValue[i]);\n-    }\n-    nb_entities = 0;\n-}\n-static int addEntity(char *name, char *content) {\n-    if (nb_entities >= MAX_ENTITIES) {\n-    fprintf(stderr, \"Too many entities defined\\n\");\n-    return(-1);\n-    }\n-    testEntitiesName[nb_entities] = name;\n-    testEntitiesValue[nb_entities] = content;\n-    nb_entities++;\n-    return(0);\n-}\n-\n-\/*\n- * We need to trap calls to the resolver to not account memory for the catalog\n- * which is shared to the current running test. We also don't want to have\n- * network downloads modifying tests.\n- *\/\n-static xmlParserInputPtr\n-testExternalEntityLoader(const char *URL, const char *ID,\n-             xmlParserCtxtPtr ctxt) {\n-    xmlParserInputPtr ret;\n-    int i;\n-\n-    for (i = 0;i < nb_entities;i++) {\n-        if (!strcmp(testEntitiesName[i], URL)) {\n-        ret = xmlNewStringInputStream(ctxt,\n-                    (const xmlChar *) testEntitiesValue[i]);\n-        if (ret != NULL) {\n-            ret->filename = (const char *)\n-                        xmlStrdup((xmlChar *)testEntitiesName[i]);\n-        }\n-        return(ret);\n-    }\n-    }\n-    if (checkTestFile(URL)) {\n-    ret = xmlNoNetExternalEntityLoader(URL, ID, ctxt);\n-    } else {\n-    int memused = xmlMemUsed();\n-    ret = xmlNoNetExternalEntityLoader(URL, ID, ctxt);\n-    extraMemoryFromResolver += xmlMemUsed() - memused;\n-    }\n-#if 0\n-    if (ret == NULL) {\n-        fprintf(stderr, \"Failed to find resource %s\\n\", URL);\n-    }\n-#endif\n-\n-    return(ret);\n-}\n-\n-\/*\n- * Trapping the error messages at the generic level to grab the equivalent of\n- * stderr messages on CLI tools.\n- *\/\n-static char testErrors[32769];\n-static int testErrorsSize = 0;\n-\n-static void test_log(const char *msg, ...) {\n-    va_list args;\n-    if (logfile != NULL) {\n-        fprintf(logfile, \"\\n------------\\n\");\n-    va_start(args, msg);\n-    vfprintf(logfile, msg, args);\n-    va_end(args);\n-    fprintf(logfile, \"%s\", testErrors);\n-    testErrorsSize = 0; testErrors[0] = 0;\n-    }\n-    if (verbose) {\n-    va_start(args, msg);\n-    vfprintf(stderr, msg, args);\n-    va_end(args);\n-    }\n-}\n-\n-static void\n-testErrorHandler(void *ctx  ATTRIBUTE_UNUSED, const char *msg, ...) {\n-    va_list args;\n-    int res;\n-\n-    if (testErrorsSize >= 32768)\n-        return;\n-    va_start(args, msg);\n-    res = vsnprintf(&testErrors[testErrorsSize],\n-                    32768 - testErrorsSize,\n-            msg, args);\n-    va_end(args);\n-    if (testErrorsSize + res >= 32768) {\n-        \/* buffer is full *\/\n-    testErrorsSize = 32768;\n-    testErrors[testErrorsSize] = 0;\n-    } else {\n-        testErrorsSize += res;\n-    }\n-    testErrors[testErrorsSize] = 0;\n-}\n-\n-static xmlXPathContextPtr ctxtXPath;\n-\n-static void\n-initializeLibxml2(void) {\n-    xmlMemSetup(xmlMemFree, xmlMemMalloc, xmlMemRealloc, xmlMemoryStrdup);\n-    xmlInitParser();\n-    xmlSetExternalEntityLoader(testExternalEntityLoader);\n-    ctxtXPath = xmlXPathNewContext(NULL);\n-    \/*\n-    * Deactivate the cache if created; otherwise we have to create\/free it\n-    * for every test, since it will confuse the memory leak detection.\n-    * Note that normally this need not be done, since the cache is not\n-    * created until set explicitly with xmlXPathContextSetCache();\n-    * but for test purposes it is sometimes useful to activate the\n-    * cache by default for the whole library.\n-    *\/\n-    if (ctxtXPath->cache != NULL)\n-    xmlXPathContextSetCache(ctxtXPath, 0, -1, 0);\n-    \/* used as default namespace in xstc tests *\/\n-    xmlXPathRegisterNs(ctxtXPath, BAD_CAST \"ts\", BAD_CAST \"TestSuite\");\n-    xmlXPathRegisterNs(ctxtXPath, BAD_CAST \"xlink\",\n-                       BAD_CAST \"http:\/\/www.w3.org\/1999\/xlink\");\n-    xmlSetGenericErrorFunc(NULL, testErrorHandler);\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-    xmlSchemaInitTypes();\n-    xmlRelaxNGInitTypes();\n-#endif\n-}\n-\n-static xmlNodePtr\n-getNext(xmlNodePtr cur, const char *xpath) {\n-    xmlNodePtr ret = NULL;\n-    xmlXPathObjectPtr res;\n-    xmlXPathCompExprPtr comp;\n-\n-    if ((cur == NULL)  || (cur->doc == NULL) || (xpath == NULL))\n-        return(NULL);\n-    ctxtXPath->doc = cur->doc;\n-    ctxtXPath->node = cur;\n-    comp = xmlXPathCompile(BAD_CAST xpath);\n-    if (comp == NULL) {\n-        fprintf(stderr, \"Failed to compile %s\\n\", xpath);\n-    return(NULL);\n-    }\n-    res = xmlXPathCompiledEval(comp, ctxtXPath);\n-    xmlXPathFreeCompExpr(comp);\n-    if (res == NULL)\n-        return(NULL);\n-    if ((res->type == XPATH_NODESET) &&\n-        (res->nodesetval != NULL) &&\n-    (res->nodesetval->nodeNr > 0) &&\n-    (res->nodesetval->nodeTab != NULL))\n-    ret = res->nodesetval->nodeTab[0];\n-    xmlXPathFreeObject(res);\n-    return(ret);\n-}\n-\n-static xmlChar *\n-getString(xmlNodePtr cur, const char *xpath) {\n-    xmlChar *ret = NULL;\n-    xmlXPathObjectPtr res;\n-    xmlXPathCompExprPtr comp;\n-\n-    if ((cur == NULL)  || (cur->doc == NULL) || (xpath == NULL))\n-        return(NULL);\n-    ctxtXPath->doc = cur->doc;\n-    ctxtXPath->node = cur;\n-    comp = xmlXPathCompile(BAD_CAST xpath);\n-    if (comp == NULL) {\n-        fprintf(stderr, \"Failed to compile %s\\n\", xpath);\n-    return(NULL);\n-    }\n-    res = xmlXPathCompiledEval(comp, ctxtXPath);\n-    xmlXPathFreeCompExpr(comp);\n-    if (res == NULL)\n-        return(NULL);\n-    if (res->type == XPATH_STRING) {\n-        ret = res->stringval;\n-    res->stringval = NULL;\n-    }\n-    xmlXPathFreeObject(res);\n-    return(ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Test test\/xsdtest\/xsdtestsuite.xml            *\n- *                                    *\n- ************************************************************************\/\n-\n-static int\n-xsdIncorrectTestCase(xmlNodePtr cur) {\n-    xmlNodePtr test;\n-    xmlBufferPtr buf;\n-    xmlRelaxNGParserCtxtPtr pctxt;\n-    xmlRelaxNGPtr rng = NULL;\n-    int ret = 0, memt;\n-\n-    cur = getNext(cur, \".\/incorrect[1]\");\n-    if (cur == NULL) {\n-        return(0);\n-    }\n-\n-    test = getNext(cur, \".\/*\");\n-    if (test == NULL) {\n-        test_log(\"Failed to find test in correct line %ld\\n\",\n-            xmlGetLineNo(cur));\n-        return(1);\n-    }\n-\n-    memt = xmlMemUsed();\n-    extraMemoryFromResolver = 0;\n-    \/*\n-     * dump the schemas to a buffer, then reparse it and compile the schemas\n-     *\/\n-    buf = xmlBufferCreate();\n-    if (buf == NULL) {\n-        fprintf(stderr, \"out of memory !\\n\");\n-    fatalError();\n-    }\n-    xmlBufferSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);\n-    xmlNodeDump(buf, test->doc, test, 0, 0);\n-    pctxt = xmlRelaxNGNewMemParserCtxt((const char *)buf->content, buf->use);\n-    xmlRelaxNGSetParserErrors(pctxt, testErrorHandler, testErrorHandler,\n-            pctxt);\n-    rng = xmlRelaxNGParse(pctxt);\n-    xmlRelaxNGFreeParserCtxt(pctxt);\n-    if (rng != NULL) {\n-    test_log(\"Failed to detect incorrect RNG line %ld\\n\",\n-            xmlGetLineNo(test));\n-        ret = 1;\n-    goto done;\n-    }\n-\n-done:\n-    if (buf != NULL)\n-    xmlBufferFree(buf);\n-    if (rng != NULL)\n-        xmlRelaxNGFree(rng);\n-    xmlResetLastError();\n-    if ((memt < xmlMemUsed()) && (extraMemoryFromResolver == 0)) {\n-    test_log(\"Validation of tests starting line %ld leaked %d\\n\",\n-        xmlGetLineNo(cur), xmlMemUsed() - memt);\n-    nb_leaks++;\n-    }\n-    return(ret);\n-}\n-\n-static void\n-installResources(xmlNodePtr tst, const xmlChar *base) {\n-    xmlNodePtr test;\n-    xmlBufferPtr buf;\n-    xmlChar *name, *content, *res;\n-\n-    buf = xmlBufferCreate();\n-    if (buf == NULL) {\n-        fprintf(stderr, \"out of memory !\\n\");\n-    fatalError();\n-    }\n-    xmlBufferSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);\n-    xmlNodeDump(buf, tst->doc, tst, 0, 0);\n-\n-    while (tst != NULL) {\n-    test = getNext(tst, \".\/*\");\n-    if (test != NULL) {\n-        xmlBufferEmpty(buf);\n-        xmlNodeDump(buf, test->doc, test, 0, 0);\n-        name = getString(tst, \"string(@name)\");\n-        content = xmlStrdup(buf->content);\n-        if ((name != NULL) && (content != NULL)) {\n-            res = composeDir(base, name);\n-        xmlFree(name);\n-            addEntity((char *) res, (char *) content);\n-        } else {\n-            if (name != NULL) xmlFree(name);\n-            if (content != NULL) xmlFree(content);\n-        }\n-    }\n-    tst = getNext(tst, \"following-sibling::resource[1]\");\n-    }\n-    if (buf != NULL)\n-    xmlBufferFree(buf);\n-}\n-\n-static void\n-installDirs(xmlNodePtr tst, const xmlChar *base) {\n-    xmlNodePtr test;\n-    xmlChar *name, *res;\n-\n-    name = getString(tst, \"string(@name)\");\n-    if (name == NULL)\n-        return;\n-    res = composeDir(base, name);\n-    xmlFree(name);\n-    if (res == NULL) {\n-    return;\n-    }\n-    \/* Now process resources and subdir recursively *\/\n-    test = getNext(tst, \".\/resource[1]\");\n-    if (test != NULL) {\n-        installResources(test, res);\n-    }\n-    test = getNext(tst, \".\/dir[1]\");\n-    while (test != NULL) {\n-        installDirs(test, res);\n-    test = getNext(test, \"following-sibling::dir[1]\");\n-    }\n-    xmlFree(res);\n-}\n-\n-static int\n-xsdTestCase(xmlNodePtr tst) {\n-    xmlNodePtr test, tmp, cur;\n-    xmlBufferPtr buf;\n-    xmlDocPtr doc = NULL;\n-    xmlRelaxNGParserCtxtPtr pctxt;\n-    xmlRelaxNGValidCtxtPtr ctxt;\n-    xmlRelaxNGPtr rng = NULL;\n-    int ret = 0, mem, memt;\n-    xmlChar *dtd;\n-\n-    resetEntities();\n-    testErrorsSize = 0; testErrors[0] = 0;\n-\n-    tmp = getNext(tst, \".\/dir[1]\");\n-    if (tmp != NULL) {\n-        installDirs(tmp, NULL);\n-    }\n-    tmp = getNext(tst, \".\/resource[1]\");\n-    if (tmp != NULL) {\n-        installResources(tmp, NULL);\n-    }\n-\n-    cur = getNext(tst, \".\/correct[1]\");\n-    if (cur == NULL) {\n-        return(xsdIncorrectTestCase(tst));\n-    }\n-\n-    test = getNext(cur, \".\/*\");\n-    if (test == NULL) {\n-        fprintf(stderr, \"Failed to find test in correct line %ld\\n\",\n-            xmlGetLineNo(cur));\n-        return(1);\n-    }\n-\n-    memt = xmlMemUsed();\n-    extraMemoryFromResolver = 0;\n-    \/*\n-     * dump the schemas to a buffer, then reparse it and compile the schemas\n-     *\/\n-    buf = xmlBufferCreate();\n-    if (buf == NULL) {\n-        fprintf(stderr, \"out of memory !\\n\");\n-    fatalError();\n-    }\n-    xmlBufferSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);\n-    xmlNodeDump(buf, test->doc, test, 0, 0);\n-    pctxt = xmlRelaxNGNewMemParserCtxt((const char *)buf->content, buf->use);\n-    xmlRelaxNGSetParserErrors(pctxt, testErrorHandler, testErrorHandler,\n-            pctxt);\n-    rng = xmlRelaxNGParse(pctxt);\n-    xmlRelaxNGFreeParserCtxt(pctxt);\n-    if (extraMemoryFromResolver)\n-        memt = 0;\n-\n-    if (rng == NULL) {\n-        test_log(\"Failed to parse RNGtest line %ld\\n\",\n-            xmlGetLineNo(test));\n-    nb_errors++;\n-        ret = 1;\n-    goto done;\n-    }\n-    \/*\n-     * now scan all the siblings of correct to process the <valid> tests\n-     *\/\n-    tmp = getNext(cur, \"following-sibling::valid[1]\");\n-    while (tmp != NULL) {\n-    dtd = xmlGetProp(tmp, BAD_CAST \"dtd\");\n-    test = getNext(tmp, \".\/*\");\n-    if (test == NULL) {\n-        fprintf(stderr, \"Failed to find test in <valid> line %ld\\n\",\n-            xmlGetLineNo(tmp));\n-\n-    } else {\n-        xmlBufferEmpty(buf);\n-        if (dtd != NULL)\n-        xmlBufferAdd(buf, dtd, -1);\n-        xmlNodeDump(buf, test->doc, test, 0, 0);\n-\n-        \/*\n-         * We are ready to run the test\n-         *\/\n-        mem = xmlMemUsed();\n-        extraMemoryFromResolver = 0;\n-            doc = xmlReadMemory((const char *)buf->content, buf->use,\n-                            \"test\", NULL, 0);\n-        if (doc == NULL) {\n-        test_log(\"Failed to parse valid instance line %ld\\n\",\n-            xmlGetLineNo(tmp));\n-        nb_errors++;\n-        } else {\n-        nb_tests++;\n-            ctxt = xmlRelaxNGNewValidCtxt(rng);\n-        xmlRelaxNGSetValidErrors(ctxt,\n-                        testErrorHandler, testErrorHandler, ctxt);\n-        ret = xmlRelaxNGValidateDoc(ctxt, doc);\n-        xmlRelaxNGFreeValidCtxt(ctxt);\n-        if (ret > 0) {\n-            test_log(\"Failed to validate valid instance line %ld\\n\",\n-                xmlGetLineNo(tmp));\n-            nb_errors++;\n-        } else if (ret < 0) {\n-            test_log(\"Internal error validating instance line %ld\\n\",\n-                xmlGetLineNo(tmp));\n-            nb_errors++;\n-        }\n-        xmlFreeDoc(doc);\n-        }\n-        xmlResetLastError();\n-        if ((mem != xmlMemUsed()) && (extraMemoryFromResolver == 0)) {\n-            test_log(\"Validation of instance line %ld leaked %d\\n\",\n-                xmlGetLineNo(tmp), xmlMemUsed() - mem);\n-            nb_leaks++;\n-        }\n-    }\n-    if (dtd != NULL)\n-        xmlFree(dtd);\n-    tmp = getNext(tmp, \"following-sibling::valid[1]\");\n-    }\n-    \/*\n-     * now scan all the siblings of correct to process the <invalid> tests\n-     *\/\n-    tmp = getNext(cur, \"following-sibling::invalid[1]\");\n-    while (tmp != NULL) {\n-    test = getNext(tmp, \".\/*\");\n-    if (test == NULL) {\n-        fprintf(stderr, \"Failed to find test in <invalid> line %ld\\n\",\n-            xmlGetLineNo(tmp));\n-\n-    } else {\n-        xmlBufferEmpty(buf);\n-        xmlNodeDump(buf, test->doc, test, 0, 0);\n-\n-        \/*\n-         * We are ready to run the test\n-         *\/\n-        mem = xmlMemUsed();\n-        extraMemoryFromResolver = 0;\n-            doc = xmlReadMemory((const char *)buf->content, buf->use,\n-                            \"test\", NULL, 0);\n-        if (doc == NULL) {\n-        test_log(\"Failed to parse valid instance line %ld\\n\",\n-            xmlGetLineNo(tmp));\n-        nb_errors++;\n-        } else {\n-        nb_tests++;\n-            ctxt = xmlRelaxNGNewValidCtxt(rng);\n-        xmlRelaxNGSetValidErrors(ctxt,\n-                        testErrorHandler, testErrorHandler, ctxt);\n-        ret = xmlRelaxNGValidateDoc(ctxt, doc);\n-        xmlRelaxNGFreeValidCtxt(ctxt);\n-        if (ret == 0) {\n-            test_log(\"Failed to detect invalid instance line %ld\\n\",\n-                xmlGetLineNo(tmp));\n-            nb_errors++;\n-        } else if (ret < 0) {\n-            test_log(\"Internal error validating instance line %ld\\n\",\n-                xmlGetLineNo(tmp));\n-            nb_errors++;\n-        }\n-        xmlFreeDoc(doc);\n-        }\n-        xmlResetLastError();\n-        if ((mem != xmlMemUsed()) && (extraMemoryFromResolver == 0)) {\n-            test_log(\"Validation of instance line %ld leaked %d\\n\",\n-                xmlGetLineNo(tmp), xmlMemUsed() - mem);\n-            nb_leaks++;\n-        }\n-    }\n-    tmp = getNext(tmp, \"following-sibling::invalid[1]\");\n-    }\n-\n-done:\n-    if (buf != NULL)\n-    xmlBufferFree(buf);\n-    if (rng != NULL)\n-        xmlRelaxNGFree(rng);\n-    xmlResetLastError();\n-    if ((memt != xmlMemUsed()) && (memt != 0)) {\n-    test_log(\"Validation of tests starting line %ld leaked %d\\n\",\n-        xmlGetLineNo(cur), xmlMemUsed() - memt);\n-    nb_leaks++;\n-    }\n-    return(ret);\n-}\n-\n-static int\n-xsdTestSuite(xmlNodePtr cur) {\n-    if (verbose) {\n-    xmlChar *doc = getString(cur, \"string(documentation)\");\n-\n-    if (doc != NULL) {\n-        printf(\"Suite %s\\n\", doc);\n-        xmlFree(doc);\n-    }\n-    }\n-    cur = getNext(cur, \".\/testCase[1]\");\n-    while (cur != NULL) {\n-        xsdTestCase(cur);\n-    cur = getNext(cur, \"following-sibling::testCase[1]\");\n-    }\n-\n-    return(0);\n-}\n-\n-static int\n-xsdTest(void) {\n-    xmlDocPtr doc;\n-    xmlNodePtr cur;\n-    const char *filename = \"test\/xsdtest\/xsdtestsuite.xml\";\n-    int ret = 0;\n-\n-    doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);\n-    if (doc == NULL) {\n-        fprintf(stderr, \"Failed to parse %s\\n\", filename);\n-    return(-1);\n-    }\n-    printf(\"## XML Schemas datatypes test suite from James Clark\\n\");\n-\n-    cur = xmlDocGetRootElement(doc);\n-    if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST \"testSuite\"))) {\n-        fprintf(stderr, \"Unexpected format %s\\n\", filename);\n-    ret = -1;\n-    goto done;\n-    }\n-\n-    cur = getNext(cur, \".\/testSuite[1]\");\n-    if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST \"testSuite\"))) {\n-        fprintf(stderr, \"Unexpected format %s\\n\", filename);\n-    ret = -1;\n-    goto done;\n-    }\n-    while (cur != NULL) {\n-        xsdTestSuite(cur);\n-    cur = getNext(cur, \"following-sibling::testSuite[1]\");\n-    }\n-\n-done:\n-    if (doc != NULL)\n-    xmlFreeDoc(doc);\n-    return(ret);\n-}\n-\n-static int\n-rngTestSuite(xmlNodePtr cur) {\n-    if (verbose) {\n-    xmlChar *doc = getString(cur, \"string(documentation)\");\n-\n-    if (doc != NULL) {\n-        printf(\"Suite %s\\n\", doc);\n-        xmlFree(doc);\n-    } else {\n-        doc = getString(cur, \"string(section)\");\n-        if (doc != NULL) {\n-        printf(\"Section %s\\n\", doc);\n-        xmlFree(doc);\n-        }\n-    }\n-    }\n-    cur = getNext(cur, \".\/testSuite[1]\");\n-    while (cur != NULL) {\n-        xsdTestSuite(cur);\n-    cur = getNext(cur, \"following-sibling::testSuite[1]\");\n-    }\n-\n-    return(0);\n-}\n-\n-static int\n-rngTest1(void) {\n-    xmlDocPtr doc;\n-    xmlNodePtr cur;\n-    const char *filename = \"test\/relaxng\/OASIS\/spectest.xml\";\n-    int ret = 0;\n-\n-    doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);\n-    if (doc == NULL) {\n-        fprintf(stderr, \"Failed to parse %s\\n\", filename);\n-    return(-1);\n-    }\n-    printf(\"## Relax NG test suite from James Clark\\n\");\n-\n-    cur = xmlDocGetRootElement(doc);\n-    if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST \"testSuite\"))) {\n-        fprintf(stderr, \"Unexpected format %s\\n\", filename);\n-    ret = -1;\n-    goto done;\n-    }\n-\n-    cur = getNext(cur, \".\/testSuite[1]\");\n-    if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST \"testSuite\"))) {\n-        fprintf(stderr, \"Unexpected format %s\\n\", filename);\n-    ret = -1;\n-    goto done;\n-    }\n-    while (cur != NULL) {\n-        rngTestSuite(cur);\n-    cur = getNext(cur, \"following-sibling::testSuite[1]\");\n-    }\n-\n-done:\n-    if (doc != NULL)\n-    xmlFreeDoc(doc);\n-    return(ret);\n-}\n-\n-static int\n-rngTest2(void) {\n-    xmlDocPtr doc;\n-    xmlNodePtr cur;\n-    const char *filename = \"test\/relaxng\/testsuite.xml\";\n-    int ret = 0;\n-\n-    doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);\n-    if (doc == NULL) {\n-        fprintf(stderr, \"Failed to parse %s\\n\", filename);\n-    return(-1);\n-    }\n-    printf(\"## Relax NG test suite for libxml2\\n\");\n-\n-    cur = xmlDocGetRootElement(doc);\n-    if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST \"testSuite\"))) {\n-        fprintf(stderr, \"Unexpected format %s\\n\", filename);\n-    ret = -1;\n-    goto done;\n-    }\n-\n-    cur = getNext(cur, \".\/testSuite[1]\");\n-    if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST \"testSuite\"))) {\n-        fprintf(stderr, \"Unexpected format %s\\n\", filename);\n-    ret = -1;\n-    goto done;\n-    }\n-    while (cur != NULL) {\n-        xsdTestSuite(cur);\n-    cur = getNext(cur, \"following-sibling::testSuite[1]\");\n-    }\n-\n-done:\n-    if (doc != NULL)\n-    xmlFreeDoc(doc);\n-    return(ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Schemas test suites from W3C\/NIST\/MS\/Sun        *\n- *                                    *\n- ************************************************************************\/\n-\n-static int\n-xstcTestInstance(xmlNodePtr cur, xmlSchemaPtr schemas,\n-                 const xmlChar *spath, const char *base) {\n-    xmlChar *href = NULL;\n-    xmlChar *path = NULL;\n-    xmlChar *validity = NULL;\n-    xmlSchemaValidCtxtPtr ctxt = NULL;\n-    xmlDocPtr doc = NULL;\n-    int ret = 0, mem;\n-\n-    xmlResetLastError();\n-    testErrorsSize = 0; testErrors[0] = 0;\n-    mem = xmlMemUsed();\n-    href = getString(cur,\n-                     \"string(ts:instanceDocument\/@xlink:href)\");\n-    if ((href == NULL) || (href[0] == 0)) {\n-    test_log(\"testGroup line %ld misses href for schemaDocument\\n\",\n-            xmlGetLineNo(cur));\n-    ret = -1;\n-    goto done;\n-    }\n-    path = xmlBuildURI(href, BAD_CAST base);\n-    if (path == NULL) {\n-    fprintf(stderr,\n-            \"Failed to build path to schemas testGroup line %ld : %s\\n\",\n-        xmlGetLineNo(cur), href);\n-    ret = -1;\n-    goto done;\n-    }\n-    if (checkTestFile((const char *) path) <= 0) {\n-    test_log(\"schemas for testGroup line %ld is missing: %s\\n\",\n-        xmlGetLineNo(cur), path);\n-    ret = -1;\n-    goto done;\n-    }\n-    validity = getString(cur,\n-                         \"string(ts:expected\/@validity)\");\n-    if (validity == NULL) {\n-        fprintf(stderr, \"instanceDocument line %ld misses expected validity\\n\",\n-            xmlGetLineNo(cur));\n-    ret = -1;\n-    goto done;\n-    }\n-    nb_tests++;\n-    doc = xmlReadFile((const char *) path, NULL, XML_PARSE_NOENT);\n-    if (doc == NULL) {\n-        fprintf(stderr, \"instance %s fails to parse\\n\", path);\n-    ret = -1;\n-    nb_errors++;\n-    goto done;\n-    }\n-\n-    ctxt = xmlSchemaNewValidCtxt(schemas);\n-    xmlSchemaSetValidErrors(ctxt, testErrorHandler, testErrorHandler, ctxt);\n-    ret = xmlSchemaValidateDoc(ctxt, doc);\n-\n-    if (xmlStrEqual(validity, BAD_CAST \"valid\")) {\n-    if (ret > 0) {\n-        test_log(\"valid instance %s failed to validate against %s\\n\",\n-            path, spath);\n-        nb_errors++;\n-    } else if (ret < 0) {\n-        test_log(\"valid instance %s got internal error validating %s\\n\",\n-            path, spath);\n-        nb_internals++;\n-        nb_errors++;\n-    }\n-    } else if (xmlStrEqual(validity, BAD_CAST \"invalid\")) {\n-    if (ret == 0) {\n-        test_log(\"Failed to detect invalid instance %s against %s\\n\",\n-            path, spath);\n-        nb_errors++;\n-    }\n-    } else {\n-        test_log(\"instanceDocument line %ld has unexpected validity value%s\\n\",\n-            xmlGetLineNo(cur), validity);\n-    ret = -1;\n-    goto done;\n-    }\n-\n-done:\n-    if (href != NULL) xmlFree(href);\n-    if (path != NULL) xmlFree(path);\n-    if (validity != NULL) xmlFree(validity);\n-    if (ctxt != NULL) xmlSchemaFreeValidCtxt(ctxt);\n-    if (doc != NULL) xmlFreeDoc(doc);\n-    xmlResetLastError();\n-    if (mem != xmlMemUsed()) {\n-    test_log(\"Validation of tests starting line %ld leaked %d\\n\",\n-        xmlGetLineNo(cur), xmlMemUsed() - mem);\n-    nb_leaks++;\n-    }\n-    return(ret);\n-}\n-\n-static int\n-xstcTestGroup(xmlNodePtr cur, const char *base) {\n-    xmlChar *href = NULL;\n-    xmlChar *path = NULL;\n-    xmlChar *validity = NULL;\n-    xmlSchemaPtr schemas = NULL;\n-    xmlSchemaParserCtxtPtr ctxt;\n-    xmlNodePtr instance;\n-    int ret = 0, mem;\n-\n-    xmlResetLastError();\n-    testErrorsSize = 0; testErrors[0] = 0;\n-    mem = xmlMemUsed();\n-    href = getString(cur,\n-                     \"string(ts:schemaTest\/ts:schemaDocument\/@xlink:href)\");\n-    if ((href == NULL) || (href[0] == 0)) {\n-        test_log(\"testGroup line %ld misses href for schemaDocument\\n\",\n-            xmlGetLineNo(cur));\n-    ret = -1;\n-    goto done;\n-    }\n-    path = xmlBuildURI(href, BAD_CAST base);\n-    if (path == NULL) {\n-    test_log(\"Failed to build path to schemas testGroup line %ld : %s\\n\",\n-        xmlGetLineNo(cur), href);\n-    ret = -1;\n-    goto done;\n-    }\n-    if (checkTestFile((const char *) path) <= 0) {\n-    test_log(\"schemas for testGroup line %ld is missing: %s\\n\",\n-        xmlGetLineNo(cur), path);\n-    ret = -1;\n-    goto done;\n-    }\n-    validity = getString(cur,\n-                         \"string(ts:schemaTest\/ts:expected\/@validity)\");\n-    if (validity == NULL) {\n-        test_log(\"testGroup line %ld misses expected validity\\n\",\n-            xmlGetLineNo(cur));\n-    ret = -1;\n-    goto done;\n-    }\n-    nb_tests++;\n-    if (xmlStrEqual(validity, BAD_CAST \"valid\")) {\n-        nb_schematas++;\n-    ctxt = xmlSchemaNewParserCtxt((const char *) path);\n-    xmlSchemaSetParserErrors(ctxt, testErrorHandler, testErrorHandler,\n-                ctxt);\n-    schemas = xmlSchemaParse(ctxt);\n-    xmlSchemaFreeParserCtxt(ctxt);\n-    if (schemas == NULL) {\n-        test_log(\"valid schemas %s failed to parse\\n\",\n-            path);\n-        ret = 1;\n-        nb_errors++;\n-    }\n-    if ((ret == 0) && (strstr(testErrors, \"nimplemented\") != NULL)) {\n-        test_log(\"valid schemas %s hit an unimplemented block\\n\",\n-            path);\n-        ret = 1;\n-        nb_unimplemented++;\n-        nb_errors++;\n-    }\n-    instance = getNext(cur, \".\/ts:instanceTest[1]\");\n-    while (instance != NULL) {\n-        if (schemas != NULL) {\n-        xstcTestInstance(instance, schemas, path, base);\n-        } else {\n-        \/*\n-        * We'll automatically mark the instances as failed\n-        * if the schema was broken.\n-        *\/\n-        nb_errors++;\n-        }\n-        instance = getNext(instance,\n-        \"following-sibling::ts:instanceTest[1]\");\n-    }\n-    } else if (xmlStrEqual(validity, BAD_CAST \"invalid\")) {\n-        nb_schematas++;\n-    ctxt = xmlSchemaNewParserCtxt((const char *) path);\n-    xmlSchemaSetParserErrors(ctxt, testErrorHandler, testErrorHandler,\n-                ctxt);\n-    schemas = xmlSchemaParse(ctxt);\n-    xmlSchemaFreeParserCtxt(ctxt);\n-    if (schemas != NULL) {\n-        test_log(\"Failed to detect error in schemas %s\\n\",\n-            path);\n-        nb_errors++;\n-        ret = 1;\n-    }\n-    if ((ret == 0) && (strstr(testErrors, \"nimplemented\") != NULL)) {\n-        nb_unimplemented++;\n-        test_log(\"invalid schemas %s hit an unimplemented block\\n\",\n-            path);\n-        ret = 1;\n-        nb_errors++;\n-    }\n-    } else {\n-        test_log(\"testGroup line %ld misses unexpected validity value%s\\n\",\n-            xmlGetLineNo(cur), validity);\n-    ret = -1;\n-    goto done;\n-    }\n-\n-done:\n-    if (href != NULL) xmlFree(href);\n-    if (path != NULL) xmlFree(path);\n-    if (validity != NULL) xmlFree(validity);\n-    if (schemas != NULL) xmlSchemaFree(schemas);\n-    xmlResetLastError();\n-    if ((mem != xmlMemUsed()) && (extraMemoryFromResolver == 0)) {\n-    test_log(\"Processing test line %ld %s leaked %d\\n\",\n-        xmlGetLineNo(cur), path, xmlMemUsed() - mem);\n-    nb_leaks++;\n-    }\n-    return(ret);\n-}\n-\n-static int\n-xstcMetadata(const char *metadata, const char *base) {\n-    xmlDocPtr doc;\n-    xmlNodePtr cur;\n-    xmlChar *contributor;\n-    xmlChar *name;\n-    int ret = 0;\n-\n-    doc = xmlReadFile(metadata, NULL, XML_PARSE_NOENT);\n-    if (doc == NULL) {\n-        fprintf(stderr, \"Failed to parse %s\\n\", metadata);\n-    return(-1);\n-    }\n-\n-    cur = xmlDocGetRootElement(doc);\n-    if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST \"testSet\"))) {\n-        fprintf(stderr, \"Unexpected format %s\\n\", metadata);\n-    return(-1);\n-    }\n-    contributor = xmlGetProp(cur, BAD_CAST \"contributor\");\n-    if (contributor == NULL) {\n-        contributor = xmlStrdup(BAD_CAST \"Unknown\");\n-    }\n-    name = xmlGetProp(cur, BAD_CAST \"name\");\n-    if (name == NULL) {\n-        name = xmlStrdup(BAD_CAST \"Unknown\");\n-    }\n-    printf(\"## %s test suite for Schemas version %s\\n\", contributor, name);\n-    xmlFree(contributor);\n-    xmlFree(name);\n-\n-    cur = getNext(cur, \".\/ts:testGroup[1]\");\n-    if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST \"testGroup\"))) {\n-        fprintf(stderr, \"Unexpected format %s\\n\", metadata);\n-    ret = -1;\n-    goto done;\n-    }\n-    while (cur != NULL) {\n-        xstcTestGroup(cur, base);\n-    cur = getNext(cur, \"following-sibling::ts:testGroup[1]\");\n-    }\n-\n-done:\n-    xmlFreeDoc(doc);\n-    return(ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        The driver for the tests                *\n- *                                    *\n- ************************************************************************\/\n-\n-int\n-main(int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED) {\n-    int ret = 0;\n-    int old_errors, old_tests, old_leaks, expected_errors;\n-\n-    logfile = fopen(LOGFILE, \"w\");\n-    if (logfile == NULL) {\n-        fprintf(stderr,\n-            \"Could not open the log file, running in verbose mode\\n\");\n-    verbose = 1;\n-    }\n-    initializeLibxml2();\n-\n-    if ((argc >= 2) && (!strcmp(argv[1], \"-v\")))\n-        verbose = 1;\n-\n-\n-    old_errors = nb_errors;\n-    old_tests = nb_tests;\n-    old_leaks = nb_leaks;\n-    xsdTest();\n-    expected_errors = 3;\n-    printf(\"Ran %d tests, %d errors, %d leaks\\n\",\n-           nb_tests - old_tests,\n-           nb_errors - old_errors,\n-           nb_leaks - old_leaks);\n-    if (nb_errors - old_errors == expected_errors) {\n-        printf(\"%d errors were expected\\n\", expected_errors);\n-        nb_errors = old_errors;\n-    } else {\n-        printf(\"%d errors were expected, got %d errors\\n\",\n-               expected_errors, nb_errors - old_errors);\n-        nb_errors = old_errors + 1;\n-    }\n-\n-    old_errors = nb_errors;\n-    old_tests = nb_tests;\n-    old_leaks = nb_leaks;\n-    rngTest1();\n-    if ((nb_errors == old_errors) && (nb_leaks == old_leaks))\n-    printf(\"Ran %d tests, no errors\\n\", nb_tests - old_tests);\n-    else\n-    printf(\"Ran %d tests, %d errors, %d leaks\\n\",\n-           nb_tests - old_tests,\n-           nb_errors - old_errors,\n-           nb_leaks - old_leaks);\n-\n-    old_errors = nb_errors;\n-    old_tests = nb_tests;\n-    old_leaks = nb_leaks;\n-    rngTest2();\n-    if ((nb_errors == old_errors) && (nb_leaks == old_leaks))\n-    printf(\"Ran %d tests, no errors\\n\", nb_tests - old_tests);\n-    else\n-    printf(\"Ran %d tests, %d errors, %d leaks\\n\",\n-           nb_tests - old_tests,\n-           nb_errors - old_errors,\n-           nb_leaks - old_leaks);\n-\n-    old_errors = nb_errors;\n-    old_tests = nb_tests;\n-    old_leaks = nb_leaks;\n-    nb_internals = 0;\n-    nb_schematas = 0;\n-    xstcMetadata(\"xstc\/Tests\/Metadata\/NISTXMLSchemaDatatypes.testSet\",\n-         \"xstc\/Tests\/Metadata\/\");\n-    if ((nb_errors == old_errors) && (nb_leaks == old_leaks))\n-    printf(\"Ran %d tests (%d schemata), no errors\\n\",\n-           nb_tests - old_tests, nb_schematas);\n-    else\n-    printf(\"Ran %d tests (%d schemata), %d errors (%d internals), %d leaks\\n\",\n-           nb_tests - old_tests,\n-           nb_schematas,\n-           nb_errors - old_errors,\n-           nb_internals,\n-           nb_leaks - old_leaks);\n-\n-    old_errors = nb_errors;\n-    old_tests = nb_tests;\n-    old_leaks = nb_leaks;\n-    nb_internals = 0;\n-    nb_schematas = 0;\n-    xstcMetadata(\"xstc\/Tests\/Metadata\/SunXMLSchema1-0-20020116.testSet\",\n-         \"xstc\/Tests\/\");\n-    if ((nb_errors == old_errors) && (nb_leaks == old_leaks)) {\n-    printf(\"Ran %d tests (%d schemata), no errors\\n\",\n-           nb_tests - old_tests, nb_schematas);\n-    } else {\n-    printf(\"Ran %d tests (%d schemata), %d errors (%d internals), %d leaks\\n\",\n-           nb_tests - old_tests,\n-           nb_schematas,\n-           nb_errors - old_errors,\n-           nb_internals,\n-           nb_leaks - old_leaks);\n-        printf(\"Some errors were expected.\\n\");\n-        nb_errors = old_errors;\n-    }\n-\n-    old_errors = nb_errors;\n-    old_tests = nb_tests;\n-    old_leaks = nb_leaks;\n-    nb_internals = 0;\n-    nb_schematas = 0;\n-    xstcMetadata(\"xstc\/Tests\/Metadata\/MSXMLSchema1-0-20020116.testSet\",\n-         \"xstc\/Tests\/\");\n-    if ((nb_errors == old_errors) && (nb_leaks == old_leaks)) {\n-    printf(\"Ran %d tests (%d schemata), no errors\\n\",\n-           nb_tests - old_tests, nb_schematas);\n-    } else {\n-    printf(\"Ran %d tests (%d schemata), %d errors (%d internals), %d leaks\\n\",\n-           nb_tests - old_tests,\n-           nb_schematas,\n-           nb_errors - old_errors,\n-           nb_internals,\n-           nb_leaks - old_leaks);\n-        printf(\"Some errors were expected.\\n\");\n-        nb_errors = old_errors;\n-    }\n-\n-    if ((nb_errors == 0) && (nb_leaks == 0)) {\n-        ret = 0;\n-    printf(\"Total %d tests, no errors\\n\",\n-           nb_tests);\n-    } else {\n-        ret = 1;\n-    printf(\"Total %d tests, %d errors, %d leaks\\n\",\n-           nb_tests, nb_errors, nb_leaks);\n-    }\n-    xmlXPathFreeContext(ctxtXPath);\n-    xmlCleanupParser();\n-\n-    if (logfile != NULL)\n-        fclose(logfile);\n-    return(ret);\n-}\n-#else \/* !SCHEMAS *\/\n-int\n-main(int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED) {\n-    fprintf(stderr, \"runsuite requires support for schemas and xpath in libxml2\\n\");\n-}\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/runsuite.c","additions":0,"deletions":1166,"binary":false,"changes":1166,"status":"deleted"},{"patch":"@@ -1,5129 +0,0 @@\n-\/*\n- * runtest.c: C program to run libxml2 regression tests without\n- *            requiring make or Python, and reducing platform dependencies\n- *            to a strict minimum.\n- *\n- * To compile on Unixes:\n- * cc -o runtest `xml2-config --cflags` runtest.c `xml2-config --libs` -lpthread\n- *\n- * See Copyright for the status of this software.\n- *\n- * daniel@veillard.com\n- *\/\n-\n-#define XML_DEPRECATED\n-\n-#include \"libxml.h\"\n-#include <stdio.h>\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#elif defined (_WIN32)\n-#include <io.h>\n-#endif\n-#include <stdlib.h>\n-#include <string.h>\n-#include <sys\/stat.h>\n-#include <fcntl.h>\n-\n-#include <libxml\/parser.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/tree.h>\n-#include <libxml\/uri.h>\n-#include <libxml\/encoding.h>\n-\n-#ifdef LIBXML_OUTPUT_ENABLED\n-#ifdef LIBXML_READER_ENABLED\n-#include <libxml\/xmlreader.h>\n-#endif\n-\n-#ifdef LIBXML_XINCLUDE_ENABLED\n-#include <libxml\/xinclude.h>\n-#endif\n-\n-#ifdef LIBXML_XPATH_ENABLED\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-#ifdef LIBXML_XPTR_ENABLED\n-#include <libxml\/xpointer.h>\n-#endif\n-#endif\n-\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-#include <libxml\/relaxng.h>\n-#include <libxml\/xmlschemas.h>\n-#include <libxml\/xmlschemastypes.h>\n-#endif\n-\n-#ifdef LIBXML_PATTERN_ENABLED\n-#include <libxml\/pattern.h>\n-#endif\n-\n-#ifdef LIBXML_C14N_ENABLED\n-#include <libxml\/c14n.h>\n-#endif\n-\n-#ifdef LIBXML_HTML_ENABLED\n-#include <libxml\/HTMLparser.h>\n-#include <libxml\/HTMLtree.h>\n-#endif\n-\n-#if defined(LIBXML_THREAD_ENABLED) && defined(LIBXML_CATALOG_ENABLED)\n-#include <libxml\/threads.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/catalog.h>\n-#endif\n-\n-\/*\n- * pseudo flag for the unification of HTML and XML tests\n- *\/\n-#define XML_PARSE_HTML 1 << 24\n-\n-\/*\n- * O_BINARY is just for Windows compatibility - if it isn't defined\n- * on this system, avoid any compilation error\n- *\/\n-#ifdef    O_BINARY\n-#define RD_FLAGS    O_RDONLY | O_BINARY\n-#define WR_FLAGS    O_WRONLY | O_CREAT | O_TRUNC | O_BINARY\n-#else\n-#define RD_FLAGS    O_RDONLY\n-#define WR_FLAGS    O_WRONLY | O_CREAT | O_TRUNC\n-#endif\n-\n-typedef int (*functest) (const char *filename, const char *result,\n-                         const char *error, int options);\n-\n-typedef struct testDesc testDesc;\n-typedef testDesc *testDescPtr;\n-struct testDesc {\n-    const char *desc; \/* description of the test *\/\n-    functest    func; \/* function implementing the test *\/\n-    const char *in;   \/* glob to path for input files *\/\n-    const char *out;  \/* output directory *\/\n-    const char *suffix;\/* suffix for output files *\/\n-    const char *err;  \/* suffix for error output files *\/\n-    int     options;  \/* parser options for the test *\/\n-};\n-\n-static int update_results = 0;\n-static char* temp_directory = NULL;\n-static int checkTestFile(const char *filename);\n-\n-#if defined(_WIN32)\n-\n-#include <windows.h>\n-\n-typedef struct\n-{\n-      size_t gl_pathc;    \/* Count of paths matched so far  *\/\n-      char **gl_pathv;    \/* List of matched pathnames.  *\/\n-      size_t gl_offs;     \/* Slots to reserve in 'gl_pathv'.  *\/\n-} glob_t;\n-\n-#define GLOB_DOOFFS 0\n-static int glob(const char *pattern, ATTRIBUTE_UNUSED int flags,\n-                ATTRIBUTE_UNUSED int errfunc(const char *epath, int eerrno),\n-                glob_t *pglob) {\n-    glob_t *ret;\n-    WIN32_FIND_DATA FindFileData;\n-    HANDLE hFind;\n-    unsigned int nb_paths = 0;\n-    char directory[500];\n-    int len;\n-\n-    if ((pattern == NULL) || (pglob == NULL)) return(-1);\n-\n-    strncpy(directory, pattern, 499);\n-    for (len = strlen(directory);len >= 0;len--) {\n-        if (directory[len] == '\/') {\n-        len++;\n-        directory[len] = 0;\n-        break;\n-    }\n-    }\n-    if (len <= 0)\n-        len = 0;\n-\n-\n-    ret = pglob;\n-    memset(ret, 0, sizeof(glob_t));\n-\n-    hFind = FindFirstFileA(pattern, &FindFileData);\n-    if (hFind == INVALID_HANDLE_VALUE)\n-        return(0);\n-    nb_paths = 20;\n-    ret->gl_pathv = (char **) malloc(nb_paths * sizeof(char *));\n-    if (ret->gl_pathv == NULL) {\n-    FindClose(hFind);\n-        return(-1);\n-    }\n-    strncpy(directory + len, FindFileData.cFileName, 499 - len);\n-    ret->gl_pathv[ret->gl_pathc] = strdup(directory);\n-    if (ret->gl_pathv[ret->gl_pathc] == NULL)\n-        goto done;\n-    ret->gl_pathc++;\n-    while(FindNextFileA(hFind, &FindFileData)) {\n-        if (FindFileData.cFileName[0] == '.')\n-        continue;\n-        if (ret->gl_pathc + 2 > nb_paths) {\n-            char **tmp = realloc(ret->gl_pathv, nb_paths * 2 * sizeof(char *));\n-            if (tmp == NULL)\n-                break;\n-            ret->gl_pathv = tmp;\n-            nb_paths *= 2;\n-    }\n-    strncpy(directory + len, FindFileData.cFileName, 499 - len);\n-    ret->gl_pathv[ret->gl_pathc] = strdup(directory);\n-        if (ret->gl_pathv[ret->gl_pathc] == NULL)\n-            break;\n-        ret->gl_pathc++;\n-    }\n-    ret->gl_pathv[ret->gl_pathc] = NULL;\n-\n-done:\n-    FindClose(hFind);\n-    return(0);\n-}\n-\n-\n-\n-static void globfree(glob_t *pglob) {\n-    unsigned int i;\n-    if (pglob == NULL)\n-        return;\n-\n-    for (i = 0;i < pglob->gl_pathc;i++) {\n-         if (pglob->gl_pathv[i] != NULL)\n-             free(pglob->gl_pathv[i]);\n-    }\n-}\n-\n-#else\n-#include <glob.h>\n-#endif\n-\n-\/************************************************************************\n- *                                    *\n- *        Libxml2 specific routines                *\n- *                                    *\n- ************************************************************************\/\n-\n-static int nb_tests = 0;\n-static int nb_errors = 0;\n-static int nb_leaks = 0;\n-static int extraMemoryFromResolver = 0;\n-\n-static int\n-fatalError(void) {\n-    fprintf(stderr, \"Exitting tests on fatal error\\n\");\n-    exit(1);\n-}\n-\n-\/*\n- * We need to trap calls to the resolver to not account memory for the catalog\n- * which is shared to the current running test. We also don't want to have\n- * network downloads modifying tests.\n- *\/\n-static xmlParserInputPtr\n-testExternalEntityLoader(const char *URL, const char *ID,\n-             xmlParserCtxtPtr ctxt) {\n-    xmlParserInputPtr ret;\n-\n-    if (checkTestFile(URL)) {\n-    ret = xmlNoNetExternalEntityLoader(URL, ID, ctxt);\n-    } else {\n-    int memused = xmlMemUsed();\n-    ret = xmlNoNetExternalEntityLoader(URL, ID, ctxt);\n-    extraMemoryFromResolver += xmlMemUsed() - memused;\n-    }\n-\n-    return(ret);\n-}\n-\n-\/*\n- * Trapping the error messages at the generic level to grab the equivalent of\n- * stderr messages on CLI tools.\n- *\/\n-static char testErrors[32769];\n-static int testErrorsSize = 0;\n-\n-static void\n-testErrorHandler(void *ctx  ATTRIBUTE_UNUSED, const char *msg, ...) {\n-    va_list args;\n-    int res;\n-\n-    if (testErrorsSize >= 32768)\n-        return;\n-    va_start(args, msg);\n-    res = vsnprintf(&testErrors[testErrorsSize],\n-                    32768 - testErrorsSize,\n-            msg, args);\n-    va_end(args);\n-    if (testErrorsSize + res >= 32768) {\n-        \/* buffer is full *\/\n-    testErrorsSize = 32768;\n-    testErrors[testErrorsSize] = 0;\n-    } else {\n-        testErrorsSize += res;\n-    }\n-    testErrors[testErrorsSize] = 0;\n-}\n-\n-static void\n-testStructuredErrorHandler(void *ctx ATTRIBUTE_UNUSED, const xmlError *err) {\n-    xmlFormatError(err, testErrorHandler, NULL);\n-}\n-\n-static void\n-initializeLibxml2(void) {\n-    \/*\n-     * This verifies that xmlInitParser doesn't allocate memory with\n-     * xmlMalloc\n-     *\/\n-    xmlFree = NULL;\n-    xmlMalloc = NULL;\n-    xmlRealloc = NULL;\n-    xmlMemStrdup = NULL;\n-    xmlInitParser();\n-    xmlMemSetup(xmlMemFree, xmlMemMalloc, xmlMemRealloc, xmlMemoryStrdup);\n-    xmlSetExternalEntityLoader(testExternalEntityLoader);\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-    xmlSchemaInitTypes();\n-    xmlRelaxNGInitTypes();\n-#endif\n-}\n-\n-\n-\/************************************************************************\n- *                                    *\n- *        File name and path utilities                *\n- *                                    *\n- ************************************************************************\/\n-\n-static const char *baseFilename(const char *filename) {\n-    const char *cur;\n-    if (filename == NULL)\n-        return(NULL);\n-    cur = &filename[strlen(filename)];\n-    while ((cur > filename) && (*cur != '\/'))\n-        cur--;\n-    if (*cur == '\/')\n-        return(cur + 1);\n-    return(cur);\n-}\n-\n-static char *resultFilename(const char *filename, const char *out,\n-                            const char *suffix) {\n-    const char *base;\n-    char res[500];\n-    char suffixbuff[500];\n-\n-\/*************\n-    if ((filename[0] == 't') && (filename[1] == 'e') &&\n-        (filename[2] == 's') && (filename[3] == 't') &&\n-    (filename[4] == '\/'))\n-    filename = &filename[5];\n- *************\/\n-\n-    base = baseFilename(filename);\n-    if (suffix == NULL)\n-        suffix = \".tmp\";\n-    if (out == NULL)\n-        out = \"\";\n-\n-    strncpy(suffixbuff,suffix,499);\n-\n-    if (snprintf(res, 499, \"%s%s%s\", out, base, suffixbuff) >= 499)\n-        res[499] = 0;\n-    return(strdup(res));\n-}\n-\n-static int checkTestFile(const char *filename) {\n-    struct stat buf;\n-\n-    if (stat(filename, &buf) == -1)\n-        return(0);\n-\n-#if defined(_WIN32)\n-    if (!(buf.st_mode & _S_IFREG))\n-        return(0);\n-#else\n-    if (!S_ISREG(buf.st_mode))\n-        return(0);\n-#endif\n-\n-    return(1);\n-}\n-\n-static int compareFiles(const char *r1 \/* temp *\/, const char *r2 \/* result *\/) {\n-    int res1, res2, total;\n-    int fd1, fd2;\n-    char bytes1[4096];\n-    char bytes2[4096];\n-\n-    if (update_results) {\n-        fd1 = open(r1, RD_FLAGS);\n-        if (fd1 < 0)\n-            return(-1);\n-        fd2 = open(r2, WR_FLAGS, 0644);\n-        if (fd2 < 0) {\n-            close(fd1);\n-            return(-1);\n-        }\n-        total = 0;\n-        do {\n-            res1 = read(fd1, bytes1, 4096);\n-            if (res1 <= 0)\n-                break;\n-            total += res1;\n-            res2 = write(fd2, bytes1, res1);\n-            if (res2 <= 0 || res2 != res1)\n-                break;\n-        } while (1);\n-        close(fd2);\n-        close(fd1);\n-        if (total == 0)\n-            unlink(r2);\n-        return(res1 != 0);\n-    }\n-\n-    fd1 = open(r1, RD_FLAGS);\n-    if (fd1 < 0)\n-        return(-1);\n-    fd2 = open(r2, RD_FLAGS);\n-    while (1) {\n-        res1 = read(fd1, bytes1, 4096);\n-        res2 = fd2 >= 0 ? read(fd2, bytes2, 4096) : 0;\n-    if ((res1 != res2) || (res1 < 0)) {\n-        close(fd1);\n-            if (fd2 >= 0)\n-                close(fd2);\n-        return(1);\n-    }\n-    if (res1 == 0)\n-        break;\n-    if (memcmp(bytes1, bytes2, res1) != 0) {\n-        close(fd1);\n-            if (fd2 >= 0)\n-                close(fd2);\n-        return(1);\n-    }\n-    }\n-    close(fd1);\n-    if (fd2 >= 0)\n-        close(fd2);\n-    return(0);\n-}\n-\n-static int compareFileMem(const char *filename, const char *mem, int size) {\n-    int res;\n-    int fd;\n-    char bytes[4096];\n-    int idx = 0;\n-    struct stat info;\n-\n-    if (update_results) {\n-        if (size == 0) {\n-            unlink(filename);\n-            return(0);\n-        }\n-        fd = open(filename, WR_FLAGS, 0644);\n-        if (fd < 0) {\n-        fprintf(stderr, \"failed to open %s for writing\", filename);\n-            return(-1);\n-    }\n-        res = write(fd, mem, size);\n-        close(fd);\n-        return(res != size);\n-    }\n-\n-    if (stat(filename, &info) < 0) {\n-        if (size == 0)\n-            return(0);\n-        fprintf(stderr, \"failed to stat %s\\n\", filename);\n-    return(-1);\n-    }\n-    if (info.st_size != size) {\n-        fprintf(stderr, \"file %s is %ld bytes, result is %d bytes\\n\",\n-            filename, (long) info.st_size, size);\n-        return(-1);\n-    }\n-    fd = open(filename, RD_FLAGS);\n-    if (fd < 0) {\n-    fprintf(stderr, \"failed to open %s for reading\", filename);\n-        return(-1);\n-    }\n-    while (idx < size) {\n-        res = read(fd, bytes, 4096);\n-    if (res <= 0)\n-        break;\n-    if (res + idx > size)\n-        break;\n-    if (memcmp(bytes, &mem[idx], res) != 0) {\n-        int ix;\n-        for (ix=0; ix<res; ix++)\n-        if (bytes[ix] != mem[idx+ix])\n-            break;\n-        fprintf(stderr,\"Compare error at position %d\\n\", idx+ix);\n-        close(fd);\n-        return(1);\n-    }\n-    idx += res;\n-    }\n-    close(fd);\n-    if (idx != size) {\n-    fprintf(stderr,\"Compare error index %d, size %d\\n\", idx, size);\n-    }\n-    return(idx != size);\n-}\n-\n-static int loadMem(const char *filename, const char **mem, int *size) {\n-    int fd, res;\n-    struct stat info;\n-    char *base;\n-    int siz = 0;\n-    if (stat(filename, &info) < 0)\n-    return(-1);\n-    base = malloc(info.st_size + 1);\n-    if (base == NULL)\n-    return(-1);\n-    if ((fd = open(filename, RD_FLAGS)) < 0) {\n-        free(base);\n-    return(-1);\n-    }\n-    while ((res = read(fd, &base[siz], info.st_size - siz)) > 0) {\n-        siz += res;\n-    }\n-    close(fd);\n-#if !defined(_WIN32)\n-    if (siz != info.st_size) {\n-        free(base);\n-    return(-1);\n-    }\n-#endif\n-    base[siz] = 0;\n-    *mem = base;\n-    *size = siz;\n-    return(0);\n-}\n-\n-static int unloadMem(const char *mem) {\n-    free((char *)mem);\n-    return(0);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Tests implementations                    *\n- *                                    *\n- ************************************************************************\/\n-\n-\/************************************************************************\n- *                                    *\n- *        Parse to SAX based tests                *\n- *                                    *\n- ************************************************************************\/\n-\n-static FILE *SAXdebug = NULL;\n-\n-\/*\n- * empty SAX block\n- *\/\n-static xmlSAXHandler emptySAXHandlerStruct = {\n-    NULL, \/* internalSubset *\/\n-    NULL, \/* isStandalone *\/\n-    NULL, \/* hasInternalSubset *\/\n-    NULL, \/* hasExternalSubset *\/\n-    NULL, \/* resolveEntity *\/\n-    NULL, \/* getEntity *\/\n-    NULL, \/* entityDecl *\/\n-    NULL, \/* notationDecl *\/\n-    NULL, \/* attributeDecl *\/\n-    NULL, \/* elementDecl *\/\n-    NULL, \/* unparsedEntityDecl *\/\n-    NULL, \/* setDocumentLocator *\/\n-    NULL, \/* startDocument *\/\n-    NULL, \/* endDocument *\/\n-    NULL, \/* startElement *\/\n-    NULL, \/* endElement *\/\n-    NULL, \/* reference *\/\n-    NULL, \/* characters *\/\n-    NULL, \/* ignorableWhitespace *\/\n-    NULL, \/* processingInstruction *\/\n-    NULL, \/* comment *\/\n-    NULL, \/* xmlParserWarning *\/\n-    NULL, \/* xmlParserError *\/\n-    NULL, \/* xmlParserError *\/\n-    NULL, \/* getParameterEntity *\/\n-    NULL, \/* cdataBlock; *\/\n-    NULL, \/* externalSubset; *\/\n-    1,\n-    NULL,\n-    NULL, \/* startElementNs *\/\n-    NULL, \/* endElementNs *\/\n-    NULL  \/* xmlStructuredErrorFunc *\/\n-};\n-\n-typedef struct {\n-    const char *filename;\n-    xmlHashTablePtr generalEntities;\n-    xmlHashTablePtr parameterEntities;\n-} debugContext;\n-\n-static xmlSAXHandlerPtr emptySAXHandler = &emptySAXHandlerStruct;\n-static int callbacks = 0;\n-static int quiet = 0;\n-\n-\/**\n- * isStandaloneDebug:\n- * @ctxt:  An XML parser context\n- *\n- * Is this document tagged standalone ?\n- *\n- * Returns 1 if true\n- *\/\n-static int\n-isStandaloneDebug(void *ctx ATTRIBUTE_UNUSED)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return(0);\n-    fprintf(SAXdebug, \"SAX.isStandalone()\\n\");\n-    return(0);\n-}\n-\n-\/**\n- * hasInternalSubsetDebug:\n- * @ctxt:  An XML parser context\n- *\n- * Does this document has an internal subset\n- *\n- * Returns 1 if true\n- *\/\n-static int\n-hasInternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return(0);\n-    fprintf(SAXdebug, \"SAX.hasInternalSubset()\\n\");\n-    return(0);\n-}\n-\n-\/**\n- * hasExternalSubsetDebug:\n- * @ctxt:  An XML parser context\n- *\n- * Does this document has an external subset\n- *\n- * Returns 1 if true\n- *\/\n-static int\n-hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return(0);\n-    fprintf(SAXdebug, \"SAX.hasExternalSubset()\\n\");\n-    return(0);\n-}\n-\n-\/**\n- * internalSubsetDebug:\n- * @ctxt:  An XML parser context\n- *\n- * Does this document has an internal subset\n- *\/\n-static void\n-internalSubsetDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name,\n-           const xmlChar *ExternalID, const xmlChar *SystemID)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    if (name == NULL)\n-        name = BAD_CAST \"(null)\";\n-    fprintf(SAXdebug, \"SAX.internalSubset(%s,\", name);\n-    if (ExternalID == NULL)\n-    fprintf(SAXdebug, \" ,\");\n-    else\n-    fprintf(SAXdebug, \" %s,\", ExternalID);\n-    if (SystemID == NULL)\n-    fprintf(SAXdebug, \" )\\n\");\n-    else\n-    fprintf(SAXdebug, \" %s)\\n\", SystemID);\n-}\n-\n-\/**\n- * externalSubsetDebug:\n- * @ctxt:  An XML parser context\n- *\n- * Does this document has an external subset\n- *\/\n-static void\n-externalSubsetDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name,\n-           const xmlChar *ExternalID, const xmlChar *SystemID)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.externalSubset(%s,\", name);\n-    if (ExternalID == NULL)\n-    fprintf(SAXdebug, \" ,\");\n-    else\n-    fprintf(SAXdebug, \" %s,\", ExternalID);\n-    if (SystemID == NULL)\n-    fprintf(SAXdebug, \" )\\n\");\n-    else\n-    fprintf(SAXdebug, \" %s)\\n\", SystemID);\n-}\n-\n-\/**\n- * resolveEntityDebug:\n- * @ctxt:  An XML parser context\n- * @publicId: The public ID of the entity\n- * @systemId: The system ID of the entity\n- *\n- * Special entity resolver, better left to the parser, it has\n- * more context than the application layer.\n- * The default behaviour is to NOT resolve the entities, in that case\n- * the ENTITY_REF nodes are built in the structure (and the parameter\n- * values).\n- *\n- * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.\n- *\/\n-static xmlParserInputPtr\n-resolveEntityDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *publicId, const xmlChar *systemId)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return(NULL);\n-    \/* xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; *\/\n-\n-\n-    fprintf(SAXdebug, \"SAX.resolveEntity(\");\n-    if (publicId != NULL)\n-    fprintf(SAXdebug, \"%s\", (char *)publicId);\n-    else\n-    fprintf(SAXdebug, \" \");\n-    if (systemId != NULL)\n-    fprintf(SAXdebug, \", %s)\\n\", (char *)systemId);\n-    else\n-    fprintf(SAXdebug, \", )\\n\");\n-\/*********\n-    if (systemId != NULL) {\n-        return(xmlNewInputFromFile(ctxt, (char *) systemId));\n-    }\n- *********\/\n-    return(NULL);\n-}\n-\n-\/**\n- * getEntityDebug:\n- * @ctxt:  An XML parser context\n- * @name: The entity name\n- *\n- * Get an entity by name\n- *\n- * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.\n- *\/\n-static xmlEntityPtr\n-getEntityDebug(void *ctx, const xmlChar *name)\n-{\n-    debugContext *ctxt = ctx;\n-\n-    callbacks++;\n-    if (quiet)\n-    return(NULL);\n-    fprintf(SAXdebug, \"SAX.getEntity(%s)\\n\", name);\n-\n-    return(xmlHashLookup(ctxt->generalEntities, name));\n-}\n-\n-\/**\n- * getParameterEntityDebug:\n- * @ctxt:  An XML parser context\n- * @name: The entity name\n- *\n- * Get a parameter entity by name\n- *\n- * Returns the xmlParserInputPtr\n- *\/\n-static xmlEntityPtr\n-getParameterEntityDebug(void *ctx, const xmlChar *name)\n-{\n-    debugContext *ctxt = ctx;\n-\n-    callbacks++;\n-    if (quiet)\n-    return(NULL);\n-    fprintf(SAXdebug, \"SAX.getParameterEntity(%s)\\n\", name);\n-\n-    return(xmlHashLookup(ctxt->parameterEntities, name));\n-}\n-\n-\n-\/**\n- * entityDeclDebug:\n- * @ctxt:  An XML parser context\n- * @name:  the entity name\n- * @type:  the entity type\n- * @publicId: The public ID of the entity\n- * @systemId: The system ID of the entity\n- * @content: the entity value (without processing).\n- *\n- * An entity definition has been parsed\n- *\/\n-static void\n-entityDeclDebug(void *ctx, const xmlChar *name, int type,\n-          const xmlChar *publicId, const xmlChar *systemId, xmlChar *content)\n-{\n-    debugContext *ctxt = ctx;\n-    xmlEntityPtr ent;\n-    const xmlChar *nullstr = BAD_CAST \"(null)\";\n-\n-    ent = xmlNewEntity(NULL, name, type, publicId, systemId, content);\n-    if (systemId != NULL)\n-        ent->URI = xmlBuildURI(systemId, (const xmlChar *) ctxt->filename);\n-\n-    if ((type == XML_INTERNAL_PARAMETER_ENTITY) ||\n-        (type == XML_EXTERNAL_PARAMETER_ENTITY))\n-        xmlHashAddEntry(ctxt->parameterEntities, name, ent);\n-    else\n-        xmlHashAddEntry(ctxt->generalEntities, name, ent);\n-\n-    \/* not all libraries handle printing null pointers nicely *\/\n-    if (publicId == NULL)\n-        publicId = nullstr;\n-    if (systemId == NULL)\n-        systemId = nullstr;\n-    if (content == NULL)\n-        content = (xmlChar *)nullstr;\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.entityDecl(%s, %d, %s, %s, %s)\\n\",\n-            name, type, publicId, systemId, content);\n-}\n-\n-\/**\n- * attributeDeclDebug:\n- * @ctxt:  An XML parser context\n- * @name:  the attribute name\n- * @type:  the attribute type\n- *\n- * An attribute definition has been parsed\n- *\/\n-static void\n-attributeDeclDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar * elem,\n-                   const xmlChar * name, int type, int def,\n-                   const xmlChar * defaultValue, xmlEnumerationPtr tree)\n-{\n-    callbacks++;\n-    if (quiet)\n-        return;\n-    if (defaultValue == NULL)\n-        fprintf(SAXdebug, \"SAX.attributeDecl(%s, %s, %d, %d, NULL, ...)\\n\",\n-                elem, name, type, def);\n-    else\n-        fprintf(SAXdebug, \"SAX.attributeDecl(%s, %s, %d, %d, %s, ...)\\n\",\n-                elem, name, type, def, defaultValue);\n-    xmlFreeEnumeration(tree);\n-}\n-\n-\/**\n- * elementDeclDebug:\n- * @ctxt:  An XML parser context\n- * @name:  the element name\n- * @type:  the element type\n- * @content: the element value (without processing).\n- *\n- * An element definition has been parsed\n- *\/\n-static void\n-elementDeclDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, int type,\n-        xmlElementContentPtr content ATTRIBUTE_UNUSED)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.elementDecl(%s, %d, ...)\\n\",\n-            name, type);\n-}\n-\n-\/**\n- * notationDeclDebug:\n- * @ctxt:  An XML parser context\n- * @name: The name of the notation\n- * @publicId: The public ID of the entity\n- * @systemId: The system ID of the entity\n- *\n- * What to do when a notation declaration has been parsed.\n- *\/\n-static void\n-notationDeclDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name,\n-         const xmlChar *publicId, const xmlChar *systemId)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.notationDecl(%s, %s, %s)\\n\",\n-            (char *) name, (char *) publicId, (char *) systemId);\n-}\n-\n-\/**\n- * unparsedEntityDeclDebug:\n- * @ctxt:  An XML parser context\n- * @name: The name of the entity\n- * @publicId: The public ID of the entity\n- * @systemId: The system ID of the entity\n- * @notationName: the name of the notation\n- *\n- * What to do when an unparsed entity declaration is parsed\n- *\/\n-static void\n-unparsedEntityDeclDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name,\n-           const xmlChar *publicId, const xmlChar *systemId,\n-           const xmlChar *notationName)\n-{\n-const xmlChar *nullstr = BAD_CAST \"(null)\";\n-\n-    if (publicId == NULL)\n-        publicId = nullstr;\n-    if (systemId == NULL)\n-        systemId = nullstr;\n-    if (notationName == NULL)\n-        notationName = nullstr;\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.unparsedEntityDecl(%s, %s, %s, %s)\\n\",\n-            (char *) name, (char *) publicId, (char *) systemId,\n-        (char *) notationName);\n-}\n-\n-\/**\n- * setDocumentLocatorDebug:\n- * @ctxt:  An XML parser context\n- * @loc: A SAX Locator\n- *\n- * Receive the document locator at startup, actually xmlDefaultSAXLocator\n- * Everything is available on the context, so this is useless in our case.\n- *\/\n-static void\n-setDocumentLocatorDebug(void *ctx ATTRIBUTE_UNUSED, xmlSAXLocatorPtr loc ATTRIBUTE_UNUSED)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.setDocumentLocator()\\n\");\n-}\n-\n-\/**\n- * startDocumentDebug:\n- * @ctxt:  An XML parser context\n- *\n- * called when the document start being processed.\n- *\/\n-static void\n-startDocumentDebug(void *ctx ATTRIBUTE_UNUSED)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.startDocument()\\n\");\n-}\n-\n-\/**\n- * endDocumentDebug:\n- * @ctxt:  An XML parser context\n- *\n- * called when the document end has been detected.\n- *\/\n-static void\n-endDocumentDebug(void *ctx ATTRIBUTE_UNUSED)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.endDocument()\\n\");\n-}\n-\n-\/**\n- * startElementDebug:\n- * @ctxt:  An XML parser context\n- * @name:  The element name\n- *\n- * called when an opening tag has been processed.\n- *\/\n-static void\n-startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)\n-{\n-    int i;\n-\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.startElement(%s\", (char *) name);\n-    if (atts != NULL) {\n-        for (i = 0;(atts[i] != NULL);i++) {\n-        fprintf(SAXdebug, \", %s='\", atts[i++]);\n-        if (atts[i] != NULL)\n-            fprintf(SAXdebug, \"%s'\", atts[i]);\n-    }\n-    }\n-    fprintf(SAXdebug, \")\\n\");\n-}\n-\n-\/**\n- * endElementDebug:\n- * @ctxt:  An XML parser context\n- * @name:  The element name\n- *\n- * called when the end of an element has been detected.\n- *\/\n-static void\n-endElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.endElement(%s)\\n\", (char *) name);\n-}\n-\n-\/**\n- * charactersDebug:\n- * @ctxt:  An XML parser context\n- * @ch:  a xmlChar string\n- * @len: the number of xmlChar\n- *\n- * receiving some chars from the parser.\n- * Question: how much at a time ???\n- *\/\n-static void\n-charactersDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *ch, int len)\n-{\n-    char output[40];\n-    int i;\n-\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    for (i = 0;(i<len) && (i < 30);i++)\n-    output[i] = (char) ch[i];\n-    output[i] = 0;\n-\n-    fprintf(SAXdebug, \"SAX.characters(%s, %d)\\n\", output, len);\n-}\n-\n-\/**\n- * referenceDebug:\n- * @ctxt:  An XML parser context\n- * @name:  The entity name\n- *\n- * called when an entity reference is detected.\n- *\/\n-static void\n-referenceDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.reference(%s)\\n\", name);\n-}\n-\n-\/**\n- * ignorableWhitespaceDebug:\n- * @ctxt:  An XML parser context\n- * @ch:  a xmlChar string\n- * @start: the first char in the string\n- * @len: the number of xmlChar\n- *\n- * receiving some ignorable whitespaces from the parser.\n- * Question: how much at a time ???\n- *\/\n-static void\n-ignorableWhitespaceDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *ch, int len)\n-{\n-    char output[40];\n-    int i;\n-\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    for (i = 0;(i<len) && (i < 30);i++)\n-    output[i] = (char) ch[i];\n-    output[i] = 0;\n-    fprintf(SAXdebug, \"SAX.ignorableWhitespace(%s, %d)\\n\", output, len);\n-}\n-\n-\/**\n- * processingInstructionDebug:\n- * @ctxt:  An XML parser context\n- * @target:  the target name\n- * @data: the PI data's\n- * @len: the number of xmlChar\n- *\n- * A processing instruction has been parsed.\n- *\/\n-static void\n-processingInstructionDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *target,\n-                      const xmlChar *data)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    if (data != NULL)\n-    fprintf(SAXdebug, \"SAX.processingInstruction(%s, %s)\\n\",\n-        (char *) target, (char *) data);\n-    else\n-    fprintf(SAXdebug, \"SAX.processingInstruction(%s, NULL)\\n\",\n-        (char *) target);\n-}\n-\n-\/**\n- * cdataBlockDebug:\n- * @ctx: the user data (XML parser context)\n- * @value:  The pcdata content\n- * @len:  the block length\n- *\n- * called when a pcdata block has been parsed\n- *\/\n-static void\n-cdataBlockDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *value, int len)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.pcdata(%.20s, %d)\\n\",\n-        (char *) value, len);\n-}\n-\n-\/**\n- * commentDebug:\n- * @ctxt:  An XML parser context\n- * @value:  the comment content\n- *\n- * A comment has been parsed.\n- *\/\n-static void\n-commentDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *value)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.comment(%s)\\n\", value);\n-}\n-\n-\/**\n- * warningDebug:\n- * @ctxt:  An XML parser context\n- * @msg:  the message to display\/transmit\n- * @...:  extra parameters for the message display\n- *\n- * Display and format a warning messages, gives file, line, position and\n- * extra parameters.\n- *\/\n-static void\n-warningDebug(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...)\n-{\n-    va_list args;\n-\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    va_start(args, msg);\n-    fprintf(SAXdebug, \"SAX.warning: \");\n-    vfprintf(SAXdebug, msg, args);\n-    va_end(args);\n-}\n-\n-\/**\n- * errorDebug:\n- * @ctxt:  An XML parser context\n- * @msg:  the message to display\/transmit\n- * @...:  extra parameters for the message display\n- *\n- * Display and format a error messages, gives file, line, position and\n- * extra parameters.\n- *\/\n-static void\n-errorDebug(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...)\n-{\n-    va_list args;\n-\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    va_start(args, msg);\n-    fprintf(SAXdebug, \"SAX.error: \");\n-    vfprintf(SAXdebug, msg, args);\n-    va_end(args);\n-}\n-\n-\/**\n- * fatalErrorDebug:\n- * @ctxt:  An XML parser context\n- * @msg:  the message to display\/transmit\n- * @...:  extra parameters for the message display\n- *\n- * Display and format a fatalError messages, gives file, line, position and\n- * extra parameters.\n- *\/\n-static void\n-fatalErrorDebug(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...)\n-{\n-    va_list args;\n-\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    va_start(args, msg);\n-    fprintf(SAXdebug, \"SAX.fatalError: \");\n-    vfprintf(SAXdebug, msg, args);\n-    va_end(args);\n-}\n-\n-static xmlSAXHandler debugSAXHandlerStruct = {\n-    internalSubsetDebug,\n-    isStandaloneDebug,\n-    hasInternalSubsetDebug,\n-    hasExternalSubsetDebug,\n-    resolveEntityDebug,\n-    getEntityDebug,\n-    entityDeclDebug,\n-    notationDeclDebug,\n-    attributeDeclDebug,\n-    elementDeclDebug,\n-    unparsedEntityDeclDebug,\n-    setDocumentLocatorDebug,\n-    startDocumentDebug,\n-    endDocumentDebug,\n-    startElementDebug,\n-    endElementDebug,\n-    referenceDebug,\n-    charactersDebug,\n-    ignorableWhitespaceDebug,\n-    processingInstructionDebug,\n-    commentDebug,\n-    warningDebug,\n-    errorDebug,\n-    fatalErrorDebug,\n-    getParameterEntityDebug,\n-    cdataBlockDebug,\n-    externalSubsetDebug,\n-    1,\n-    NULL,\n-    NULL,\n-    NULL,\n-    NULL\n-};\n-\n-static xmlSAXHandlerPtr debugSAXHandler = &debugSAXHandlerStruct;\n-\n-\/*\n- * SAX2 specific callbacks\n- *\/\n-\/**\n- * startElementNsDebug:\n- * @ctxt:  An XML parser context\n- * @name:  The element name\n- *\n- * called when an opening tag has been processed.\n- *\/\n-static void\n-startElementNsDebug(void *ctx ATTRIBUTE_UNUSED,\n-                    const xmlChar *localname,\n-                    const xmlChar *prefix,\n-                    const xmlChar *URI,\n-            int nb_namespaces,\n-            const xmlChar **namespaces,\n-            int nb_attributes,\n-            int nb_defaulted,\n-            const xmlChar **attributes)\n-{\n-    int i;\n-\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.startElementNs(%s\", (char *) localname);\n-    if (prefix == NULL)\n-    fprintf(SAXdebug, \", NULL\");\n-    else\n-    fprintf(SAXdebug, \", %s\", (char *) prefix);\n-    if (URI == NULL)\n-    fprintf(SAXdebug, \", NULL\");\n-    else\n-    fprintf(SAXdebug, \", '%s'\", (char *) URI);\n-    fprintf(SAXdebug, \", %d\", nb_namespaces);\n-\n-    if (namespaces != NULL) {\n-        for (i = 0;i < nb_namespaces * 2;i++) {\n-        fprintf(SAXdebug, \", xmlns\");\n-        if (namespaces[i] != NULL)\n-            fprintf(SAXdebug, \":%s\", namespaces[i]);\n-        i++;\n-        fprintf(SAXdebug, \"='%s'\", namespaces[i]);\n-    }\n-    }\n-    fprintf(SAXdebug, \", %d, %d\", nb_attributes, nb_defaulted);\n-    if (attributes != NULL) {\n-        for (i = 0;i < nb_attributes * 5;i += 5) {\n-        if (attributes[i + 1] != NULL)\n-        fprintf(SAXdebug, \", %s:%s='\", attributes[i + 1], attributes[i]);\n-        else\n-        fprintf(SAXdebug, \", %s='\", attributes[i]);\n-        fprintf(SAXdebug, \"%.4s...', %d\", attributes[i + 3],\n-            (int)(attributes[i + 4] - attributes[i + 3]));\n-    }\n-    }\n-    fprintf(SAXdebug, \")\\n\");\n-}\n-\n-\/**\n- * endElementDebug:\n- * @ctxt:  An XML parser context\n- * @name:  The element name\n- *\n- * called when the end of an element has been detected.\n- *\/\n-static void\n-endElementNsDebug(void *ctx ATTRIBUTE_UNUSED,\n-                  const xmlChar *localname,\n-                  const xmlChar *prefix,\n-                  const xmlChar *URI)\n-{\n-    callbacks++;\n-    if (quiet)\n-    return;\n-    fprintf(SAXdebug, \"SAX.endElementNs(%s\", (char *) localname);\n-    if (prefix == NULL)\n-    fprintf(SAXdebug, \", NULL\");\n-    else\n-    fprintf(SAXdebug, \", %s\", (char *) prefix);\n-    if (URI == NULL)\n-    fprintf(SAXdebug, \", NULL)\\n\");\n-    else\n-    fprintf(SAXdebug, \", '%s')\\n\", (char *) URI);\n-}\n-\n-static xmlSAXHandler debugSAX2HandlerStruct = {\n-    internalSubsetDebug,\n-    isStandaloneDebug,\n-    hasInternalSubsetDebug,\n-    hasExternalSubsetDebug,\n-    resolveEntityDebug,\n-    getEntityDebug,\n-    entityDeclDebug,\n-    notationDeclDebug,\n-    attributeDeclDebug,\n-    elementDeclDebug,\n-    unparsedEntityDeclDebug,\n-    setDocumentLocatorDebug,\n-    startDocumentDebug,\n-    endDocumentDebug,\n-    NULL,\n-    NULL,\n-    referenceDebug,\n-    charactersDebug,\n-    ignorableWhitespaceDebug,\n-    processingInstructionDebug,\n-    commentDebug,\n-    warningDebug,\n-    errorDebug,\n-    fatalErrorDebug,\n-    getParameterEntityDebug,\n-    cdataBlockDebug,\n-    externalSubsetDebug,\n-    XML_SAX2_MAGIC,\n-    NULL,\n-    startElementNsDebug,\n-    endElementNsDebug,\n-    NULL\n-};\n-\n-static xmlSAXHandlerPtr debugSAX2Handler = &debugSAX2HandlerStruct;\n-\n-#ifdef LIBXML_HTML_ENABLED\n-\/**\n- * htmlstartElementDebug:\n- * @ctxt:  An XML parser context\n- * @name:  The element name\n- *\n- * called when an opening tag has been processed.\n- *\/\n-static void\n-htmlstartElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)\n-{\n-    int i;\n-\n-    fprintf(SAXdebug, \"SAX.startElement(%s\", (char *) name);\n-    if (atts != NULL) {\n-        for (i = 0;(atts[i] != NULL);i++) {\n-        fprintf(SAXdebug, \", %s\", atts[i++]);\n-        if (atts[i] != NULL) {\n-        unsigned char output[40];\n-        const unsigned char *att = atts[i];\n-        int outlen, attlen;\n-            fprintf(SAXdebug, \"='\");\n-        while ((attlen = strlen((char*)att)) > 0) {\n-            outlen = sizeof output - 1;\n-            htmlEncodeEntities(output, &outlen, att, &attlen, '\\'');\n-            output[outlen] = 0;\n-            fprintf(SAXdebug, \"%s\", (char *) output);\n-            att += attlen;\n-        }\n-        fprintf(SAXdebug, \"'\");\n-        }\n-    }\n-    }\n-    fprintf(SAXdebug, \")\\n\");\n-}\n-\n-\/**\n- * htmlcharactersDebug:\n- * @ctxt:  An XML parser context\n- * @ch:  a xmlChar string\n- * @len: the number of xmlChar\n- *\n- * receiving some chars from the parser.\n- * Question: how much at a time ???\n- *\/\n-static void\n-htmlcharactersDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *ch, int len)\n-{\n-    unsigned char output[40];\n-    int inlen = len, outlen = 30;\n-\n-    htmlEncodeEntities(output, &outlen, ch, &inlen, 0);\n-    output[outlen] = 0;\n-\n-    fprintf(SAXdebug, \"SAX.characters(%s, %d)\\n\", output, len);\n-}\n-\n-\/**\n- * htmlcdataDebug:\n- * @ctxt:  An XML parser context\n- * @ch:  a xmlChar string\n- * @len: the number of xmlChar\n- *\n- * receiving some cdata chars from the parser.\n- * Question: how much at a time ???\n- *\/\n-static void\n-htmlcdataDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *ch, int len)\n-{\n-    unsigned char output[40];\n-    int inlen = len, outlen = 30;\n-\n-    htmlEncodeEntities(output, &outlen, ch, &inlen, 0);\n-    output[outlen] = 0;\n-\n-    fprintf(SAXdebug, \"SAX.cdata(%s, %d)\\n\", output, len);\n-}\n-\n-static xmlSAXHandler debugHTMLSAXHandlerStruct = {\n-    internalSubsetDebug,\n-    isStandaloneDebug,\n-    hasInternalSubsetDebug,\n-    hasExternalSubsetDebug,\n-    resolveEntityDebug,\n-    getEntityDebug,\n-    entityDeclDebug,\n-    notationDeclDebug,\n-    attributeDeclDebug,\n-    elementDeclDebug,\n-    unparsedEntityDeclDebug,\n-    setDocumentLocatorDebug,\n-    startDocumentDebug,\n-    endDocumentDebug,\n-    htmlstartElementDebug,\n-    endElementDebug,\n-    referenceDebug,\n-    htmlcharactersDebug,\n-    ignorableWhitespaceDebug,\n-    processingInstructionDebug,\n-    commentDebug,\n-    warningDebug,\n-    errorDebug,\n-    fatalErrorDebug,\n-    getParameterEntityDebug,\n-    htmlcdataDebug,\n-    externalSubsetDebug,\n-    1,\n-    NULL,\n-    NULL,\n-    NULL,\n-    NULL\n-};\n-\n-static xmlSAXHandlerPtr debugHTMLSAXHandler = &debugHTMLSAXHandlerStruct;\n-#endif \/* LIBXML_HTML_ENABLED *\/\n-\n-static void\n-hashFreeEntity(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {\n-    xmlEntityPtr ent = payload;\n-\n-    xmlFreeEntity(ent);\n-}\n-\n-\/**\n- * saxParseTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file using the SAX API and check for errors.\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-saxParseTest(const char *filename, const char *result,\n-             const char *err ATTRIBUTE_UNUSED,\n-             int options) {\n-    int ret;\n-    char *temp;\n-\n-    nb_tests++;\n-    temp = resultFilename(filename, temp_directory, \".res\");\n-    if (temp == NULL) {\n-        fprintf(stderr, \"out of memory\\n\");\n-        fatalError();\n-    }\n-    SAXdebug = fopen(temp, \"wb\");\n-    if (SAXdebug == NULL) {\n-        fprintf(stderr, \"Failed to write to %s\\n\", temp);\n-    free(temp);\n-    return(-1);\n-    }\n-\n-#ifdef LIBXML_HTML_ENABLED\n-    if (options & XML_PARSE_HTML) {\n-        htmlParserCtxtPtr ctxt;\n-\n-        ctxt = htmlNewSAXParserCtxt(emptySAXHandler, NULL);\n-        htmlCtxtReadFile(ctxt, filename, NULL, options);\n-        htmlFreeParserCtxt(ctxt);\n-    ret = 0;\n-    } else\n-#endif\n-    {\n-        xmlParserCtxtPtr ctxt = xmlCreateFileParserCtxt(filename);\n-        memcpy(ctxt->sax, emptySAXHandler, sizeof(xmlSAXHandler));\n-        xmlCtxtUseOptions(ctxt, options);\n-        xmlParseDocument(ctxt);\n-        ret = ctxt->wellFormed ? 0 : ctxt->errNo;\n-        xmlFreeDoc(ctxt->myDoc);\n-        xmlFreeParserCtxt(ctxt);\n-    }\n-    if (ret == XML_ERR_UNDECLARED_ENTITY) {\n-        fprintf(SAXdebug, \"xmlParseDocument returned error %d\\n\", ret);\n-        ret = 0;\n-    }\n-    if (ret != 0) {\n-        fprintf(stderr, \"Failed to parse %s\\n\", filename);\n-    ret = 1;\n-    goto done;\n-    }\n-#ifdef LIBXML_HTML_ENABLED\n-    if (options & XML_PARSE_HTML) {\n-        htmlParserCtxtPtr ctxt;\n-\n-        ctxt = htmlNewSAXParserCtxt(debugHTMLSAXHandler, NULL);\n-        htmlCtxtReadFile(ctxt, filename, NULL, options);\n-        htmlFreeParserCtxt(ctxt);\n-    ret = 0;\n-    } else\n-#endif\n-    {\n-        debugContext userData;\n-        xmlParserCtxtPtr ctxt = xmlCreateFileParserCtxt(filename);\n-\n-        if (options & XML_PARSE_SAX1) {\n-            memcpy(ctxt->sax, debugSAXHandler, sizeof(xmlSAXHandler));\n-            options -= XML_PARSE_SAX1;\n-        } else {\n-            memcpy(ctxt->sax, debugSAX2Handler, sizeof(xmlSAXHandler));\n-        }\n-        userData.filename = filename;\n-        userData.generalEntities = xmlHashCreate(0);\n-        userData.parameterEntities = xmlHashCreate(0);\n-        ctxt->userData = &userData;\n-        xmlCtxtUseOptions(ctxt, options);\n-        xmlParseDocument(ctxt);\n-        ret = ctxt->wellFormed ? 0 : ctxt->errNo;\n-        xmlHashFree(userData.generalEntities, hashFreeEntity);\n-        xmlHashFree(userData.parameterEntities, hashFreeEntity);\n-        xmlFreeDoc(ctxt->myDoc);\n-        xmlFreeParserCtxt(ctxt);\n-    }\n-    fclose(SAXdebug);\n-    if (compareFiles(temp, result)) {\n-        fprintf(stderr, \"Got a difference for %s\\n\", filename);\n-        ret = 1;\n-    }\n-\n-done:\n-    if (temp != NULL) {\n-        unlink(temp);\n-        free(temp);\n-    }\n-\n-    return(ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Parse to tree based tests                *\n- *                                    *\n- ************************************************************************\/\n-\/**\n- * oldParseTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages: unused\n- *\n- * Parse a file using the old xmlParseFile API, then serialize back\n- * reparse the result and serialize again, then check for deviation\n- * in serialization.\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-oldParseTest(const char *filename, const char *result,\n-             const char *err ATTRIBUTE_UNUSED,\n-         int options ATTRIBUTE_UNUSED) {\n-    xmlDocPtr doc;\n-    char *temp;\n-    int res = 0;\n-\n-    nb_tests++;\n-    \/*\n-     * base of the test, parse with the old API\n-     *\/\n-#ifdef LIBXML_SAX1_ENABLED\n-    xmlGetWarningsDefaultValue = 0;\n-    doc = xmlParseFile(filename);\n-    xmlGetWarningsDefaultValue = 1;\n-#else\n-    doc = xmlReadFile(filename, NULL, XML_PARSE_NOWARNING);\n-#endif\n-    if (doc == NULL)\n-        return(1);\n-    temp = resultFilename(filename, temp_directory, \".res\");\n-    if (temp == NULL) {\n-        fprintf(stderr, \"out of memory\\n\");\n-        fatalError();\n-    }\n-    xmlSaveFile(temp, doc);\n-    if (compareFiles(temp, result)) {\n-        res = 1;\n-    }\n-    xmlFreeDoc(doc);\n-\n-    \/*\n-     * Parse the saved result to make sure the round trip is okay\n-     *\/\n-#ifdef LIBXML_SAX1_ENABLED\n-    xmlGetWarningsDefaultValue = 0;\n-    doc = xmlParseFile(temp);\n-    xmlGetWarningsDefaultValue = 1;\n-#else\n-    doc = xmlReadFile(temp, NULL, XML_PARSE_NOWARNING);\n-#endif\n-    if (doc == NULL)\n-        return(1);\n-    xmlSaveFile(temp, doc);\n-    if (compareFiles(temp, result)) {\n-        res = 1;\n-    }\n-    xmlFreeDoc(doc);\n-\n-    if (temp != NULL) {\n-        unlink(temp);\n-        free(temp);\n-    }\n-\n-    return(res);\n-}\n-\n-#ifdef LIBXML_PUSH_ENABLED\n-\/**\n- * pushParseTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages: unused\n- *\n- * Parse a file using the Push API, then serialize back\n- * to check for content.\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-pushParseTest(const char *filename, const char *result,\n-             const char *err ATTRIBUTE_UNUSED,\n-         int options) {\n-    xmlParserCtxtPtr ctxt;\n-    xmlDocPtr doc;\n-    const char *base;\n-    int size, res;\n-    int cur = 0;\n-    int chunkSize = 4;\n-\n-    nb_tests++;\n-    \/*\n-     * load the document in memory and work from there.\n-     *\/\n-    if (loadMem(filename, &base, &size) != 0) {\n-        fprintf(stderr, \"Failed to load %s\\n\", filename);\n-    return(-1);\n-    }\n-\n-    if (chunkSize > size)\n-        chunkSize = size;\n-\n-#ifdef LIBXML_HTML_ENABLED\n-    if (options & XML_PARSE_HTML)\n-    ctxt = htmlCreatePushParserCtxt(NULL, NULL, base + cur, chunkSize, filename,\n-                                    XML_CHAR_ENCODING_NONE);\n-    else\n-#endif\n-    ctxt = xmlCreatePushParserCtxt(NULL, NULL, base + cur, chunkSize, filename);\n-    xmlCtxtSetErrorHandler(ctxt, testStructuredErrorHandler, NULL);\n-    xmlCtxtUseOptions(ctxt, options);\n-    cur += chunkSize;\n-    chunkSize = 1024;\n-    do {\n-        if (cur + chunkSize >= size) {\n-#ifdef LIBXML_HTML_ENABLED\n-        if (options & XML_PARSE_HTML)\n-        htmlParseChunk(ctxt, base + cur, size - cur, 1);\n-        else\n-#endif\n-        xmlParseChunk(ctxt, base + cur, size - cur, 1);\n-        break;\n-    } else {\n-#ifdef LIBXML_HTML_ENABLED\n-        if (options & XML_PARSE_HTML)\n-        htmlParseChunk(ctxt, base + cur, chunkSize, 0);\n-        else\n-#endif\n-        xmlParseChunk(ctxt, base + cur, chunkSize, 0);\n-        cur += chunkSize;\n-    }\n-    } while (cur < size);\n-    doc = ctxt->myDoc;\n-#ifdef LIBXML_HTML_ENABLED\n-    if (options & XML_PARSE_HTML)\n-        res = 1;\n-    else\n-#endif\n-    res = ctxt->wellFormed;\n-    xmlFreeParserCtxt(ctxt);\n-    free((char *)base);\n-    if (!res) {\n-    xmlFreeDoc(doc);\n-    fprintf(stderr, \"Failed to parse %s\\n\", filename);\n-    return(-1);\n-    }\n-#ifdef LIBXML_HTML_ENABLED\n-    if (options & XML_PARSE_HTML)\n-    htmlDocDumpMemory(doc, (xmlChar **) &base, &size);\n-    else\n-#endif\n-    xmlDocDumpMemory(doc, (xmlChar **) &base, &size);\n-    xmlFreeDoc(doc);\n-    res = compareFileMem(result, base, size);\n-    if ((base == NULL) || (res != 0)) {\n-    if (base != NULL)\n-        xmlFree((char *)base);\n-        fprintf(stderr, \"Result for %s failed in %s\\n\", filename, result);\n-    return(-1);\n-    }\n-    xmlFree((char *)base);\n-    if (err != NULL) {\n-    res = compareFileMem(err, testErrors, testErrorsSize);\n-    if (res != 0) {\n-        fprintf(stderr, \"Error for %s failed\\n\", filename);\n-        return(-1);\n-    }\n-    }\n-    return(0);\n-}\n-\n-static int pushBoundaryCount;\n-static int pushBoundaryRefCount;\n-static int pushBoundaryCharsCount;\n-static int pushBoundaryCDataCount;\n-\n-static void\n-internalSubsetBnd(void *ctx, const xmlChar *name, const xmlChar *externalID,\n-                  const xmlChar *systemID) {\n-    pushBoundaryCount++;\n-    xmlSAX2InternalSubset(ctx, name, externalID, systemID);\n-}\n-\n-static void\n-referenceBnd(void *ctx, const xmlChar *name) {\n-    pushBoundaryRefCount++;\n-    xmlSAX2Reference(ctx, name);\n-}\n-\n-static void\n-charactersBnd(void *ctx, const xmlChar *ch, int len) {\n-    pushBoundaryCount++;\n-    pushBoundaryCharsCount++;\n-    xmlSAX2Characters(ctx, ch, len);\n-}\n-\n-static void\n-cdataBlockBnd(void *ctx, const xmlChar *ch, int len) {\n-    pushBoundaryCount++;\n-    pushBoundaryCDataCount++;\n-    xmlSAX2CDataBlock(ctx, ch, len);\n-}\n-\n-static void\n-processingInstructionBnd(void *ctx, const xmlChar *target,\n-                         const xmlChar *data) {\n-    pushBoundaryCount++;\n-    xmlSAX2ProcessingInstruction(ctx, target, data);\n-}\n-\n-static void\n-commentBnd(void *ctx, const xmlChar *value) {\n-    xmlParserCtxtPtr ctxt = ctx;\n-    if (ctxt->inSubset == 0)\n-        pushBoundaryCount++;\n-    xmlSAX2Comment(ctx, value);\n-}\n-\n-static void\n-startElementBnd(void *ctx, const xmlChar *xname, const xmlChar **atts) {\n-    const char *name = (const char *)xname;\n-\n-    \/* Some elements might be created automatically. *\/\n-    if ((strcmp(name, \"html\") != 0) &&\n-        (strcmp(name, \"body\") != 0) &&\n-        (strcmp(name, \"head\") != 0) &&\n-        (strcmp(name, \"p\") != 0)) {\n-        pushBoundaryCount++;\n-    }\n-    xmlSAX2StartElement(ctx, xname, atts);\n-}\n-\n-static void\n-endElementBnd(void *ctx, const xmlChar *name) {\n-    \/*pushBoundaryCount++;*\/\n-    xmlSAX2EndElement(ctx, name);\n-}\n-\n-static void\n-startElementNsBnd(void *ctx, const xmlChar *localname, const xmlChar *prefix,\n-                  const xmlChar *URI, int nb_namespaces,\n-                  const xmlChar **namespaces, int nb_attributes,\n-                  int nb_defaulted, const xmlChar **attributes) {\n-    pushBoundaryCount++;\n-    xmlSAX2StartElementNs(ctx, localname, prefix, URI, nb_namespaces,\n-                          namespaces, nb_attributes, nb_defaulted, attributes);\n-}\n-\n-static void\n-endElementNsBnd(void *ctx, const xmlChar *localname, const xmlChar *prefix,\n-                const xmlChar *URI) {\n-    \/*pushBoundaryCount++;*\/\n-    xmlSAX2EndElementNs(ctx, localname, prefix, URI);\n-}\n-\n-\/**\n- * pushBoundaryTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages: unused\n- *\n- * Test whether the push parser detects boundaries between syntactical\n- * elements correctly.\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-pushBoundaryTest(const char *filename, const char *result,\n-                 const char *err ATTRIBUTE_UNUSED,\n-                 int options) {\n-    xmlParserCtxtPtr ctxt;\n-    xmlDocPtr doc;\n-    xmlSAXHandler bndSAX;\n-    const char *base;\n-    int size, res, numCallbacks;\n-    int cur = 0;\n-    unsigned long avail, oldConsumed, consumed;\n-\n-    \/*\n-     * HTML encoding detection doesn't work when data is fed bytewise.\n-     *\/\n-    if (strcmp(filename, \".\/test\/HTML\/xml-declaration-1.html\") == 0)\n-        return(0);\n-\n-    \/*\n-     * If the parser made progress, check that exactly one construct was\n-     * processed and that the input buffer is (almost) empty.\n-     * Since we use a chunk size of 1, this tests whether content is\n-     * processed as early as possible.\n-     *\/\n-\n-    nb_tests++;\n-\n-    memset(&bndSAX, 0, sizeof(bndSAX));\n-#ifdef LIBXML_HTML_ENABLED\n-    if (options & XML_PARSE_HTML) {\n-        xmlSAX2InitHtmlDefaultSAXHandler(&bndSAX);\n-        bndSAX.startElement = startElementBnd;\n-        bndSAX.endElement = endElementBnd;\n-    } else\n-#endif\n-    {\n-        xmlSAXVersion(&bndSAX, 2);\n-        bndSAX.startElementNs = startElementNsBnd;\n-        bndSAX.endElementNs = endElementNsBnd;\n-    }\n-\n-    bndSAX.internalSubset = internalSubsetBnd;\n-    bndSAX.reference = referenceBnd;\n-    bndSAX.characters = charactersBnd;\n-    bndSAX.cdataBlock = cdataBlockBnd;\n-    bndSAX.processingInstruction = processingInstructionBnd;\n-    bndSAX.comment = commentBnd;\n-\n-    \/*\n-     * load the document in memory and work from there.\n-     *\/\n-    if (loadMem(filename, &base, &size) != 0) {\n-        fprintf(stderr, \"Failed to load %s\\n\", filename);\n-    return(-1);\n-    }\n-\n-#ifdef LIBXML_HTML_ENABLED\n-    if (options & XML_PARSE_HTML)\n-    ctxt = htmlCreatePushParserCtxt(&bndSAX, NULL, base, 1, filename,\n-                                    XML_CHAR_ENCODING_NONE);\n-    else\n-#endif\n-    ctxt = xmlCreatePushParserCtxt(&bndSAX, NULL, base, 1, filename);\n-    xmlCtxtSetErrorHandler(ctxt, testStructuredErrorHandler, NULL);\n-    xmlCtxtUseOptions(ctxt, options);\n-    cur = 1;\n-    consumed = 0;\n-    numCallbacks = 0;\n-    avail = 0;\n-    while ((cur < size) && (numCallbacks <= 1) && (avail <= 0)) {\n-        int terminate = (cur + 1 >= size);\n-        int isText = 0;\n-\n-        if (ctxt->instate == XML_PARSER_CONTENT) {\n-            int firstChar = (ctxt->input->end > ctxt->input->cur) ?\n-                            *ctxt->input->cur :\n-                            base[cur];\n-\n-            if ((firstChar != '<') &&\n-                ((options & XML_PARSE_HTML) || (firstChar != '&')))\n-                isText = 1;\n-        }\n-\n-        oldConsumed = ctxt->input->consumed +\n-                      (unsigned long) (ctxt->input->cur - ctxt->input->base);\n-\n-        pushBoundaryCount = 0;\n-        pushBoundaryRefCount = 0;\n-        pushBoundaryCharsCount = 0;\n-        pushBoundaryCDataCount = 0;\n-\n-#ifdef LIBXML_HTML_ENABLED\n-        if (options & XML_PARSE_HTML)\n-            htmlParseChunk(ctxt, base + cur, 1, terminate);\n-        else\n-#endif\n-        xmlParseChunk(ctxt, base + cur, 1, terminate);\n-    cur += 1;\n-\n-        \/*\n-         * Callback check: Check that only a single construct was parsed.\n-         *\/\n-        if (pushBoundaryRefCount > 0) {\n-            numCallbacks = 1;\n-        } else {\n-            numCallbacks = pushBoundaryCount;\n-            if (pushBoundaryCharsCount > 1) {\n-                if (options & XML_PARSE_HTML) {\n-                    \/*\n-                     * The HTML parser can generate a mix of chars and\n-                     * references.\n-                     *\/\n-                    numCallbacks -= pushBoundaryCharsCount - 1;\n-                } else {\n-                    \/*\n-                     * Allow two chars callbacks. This can happen when\n-                     * multi-byte chars are split across buffer boundaries.\n-                     *\/\n-                    numCallbacks -= 1;\n-                }\n-            }\n-            if (options & XML_PARSE_HTML) {\n-                \/*\n-                 * Allow multiple cdata callbacks in HTML mode.\n-                 *\/\n-                if (pushBoundaryCDataCount > 1)\n-                    numCallbacks -= pushBoundaryCDataCount - 1;\n-            }\n-        }\n-\n-        \/*\n-         * Buffer check: If input was consumed, check that the input\n-         * buffer is (almost) empty.\n-         *\/\n-        consumed = ctxt->input->consumed +\n-                   (unsigned long) (ctxt->input->cur - ctxt->input->base);\n-        if ((ctxt->instate != XML_PARSER_DTD) &&\n-            (consumed >= 4) &&\n-            (consumed != oldConsumed)) {\n-            size_t max = 0;\n-\n-            avail = ctxt->input->end - ctxt->input->cur;\n-\n-            if ((options & XML_PARSE_HTML) &&\n-                (ctxt->instate == XML_PARSER_END_TAG)) {\n-                \/* Something related to script parsing. *\/\n-                max = 3;\n-            } else if (isText) {\n-                int c = *ctxt->input->cur;\n-\n-                \/* 3 bytes for partial UTF-8 *\/\n-                max = ((c == '<') || (c == '&')) ? 1 : 3;\n-            } else if (ctxt->instate == XML_PARSER_CDATA_SECTION) {\n-                \/* 2 bytes for terminator, 3 bytes for UTF-8 *\/\n-                max = 5;\n-            }\n-\n-            if (avail <= max)\n-                avail = 0;\n-        }\n-    }\n-    doc = ctxt->myDoc;\n-#ifdef LIBXML_HTML_ENABLED\n-    if (options & XML_PARSE_HTML)\n-        res = 1;\n-    else\n-#endif\n-    res = ctxt->wellFormed;\n-    xmlFreeParserCtxt(ctxt);\n-    free((char *)base);\n-    if (numCallbacks > 1) {\n-    xmlFreeDoc(doc);\n-    fprintf(stderr, \"Failed push boundary callback test (%d@%lu-%lu): %s\\n\",\n-                numCallbacks, oldConsumed, consumed, filename);\n-    return(-1);\n-    }\n-    if (avail > 0) {\n-    xmlFreeDoc(doc);\n-    fprintf(stderr, \"Failed push boundary buffer test (%lu@%lu): %s\\n\",\n-                avail, consumed, filename);\n-    return(-1);\n-    }\n-    if (!res) {\n-    xmlFreeDoc(doc);\n-    fprintf(stderr, \"Failed to parse %s\\n\", filename);\n-    return(-1);\n-    }\n-#ifdef LIBXML_HTML_ENABLED\n-    if (options & XML_PARSE_HTML)\n-    htmlDocDumpMemory(doc, (xmlChar **) &base, &size);\n-    else\n-#endif\n-    xmlDocDumpMemory(doc, (xmlChar **) &base, &size);\n-    xmlFreeDoc(doc);\n-    res = compareFileMem(result, base, size);\n-    if ((base == NULL) || (res != 0)) {\n-    if (base != NULL)\n-        xmlFree((char *)base);\n-        fprintf(stderr, \"Result for %s failed in %s\\n\", filename, result);\n-    return(-1);\n-    }\n-    xmlFree((char *)base);\n-    if (err != NULL) {\n-    res = compareFileMem(err, testErrors, testErrorsSize);\n-    if (res != 0) {\n-        fprintf(stderr, \"Error for %s failed\\n\", filename);\n-        return(-1);\n-    }\n-    }\n-    return(0);\n-}\n-#endif\n-\n-\/**\n- * memParseTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages: unused\n- *\n- * Parse a file using the old xmlReadMemory API, then serialize back\n- * reparse the result and serialize again, then check for deviation\n- * in serialization.\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-memParseTest(const char *filename, const char *result,\n-             const char *err ATTRIBUTE_UNUSED,\n-         int options ATTRIBUTE_UNUSED) {\n-    xmlDocPtr doc;\n-    const char *base;\n-    int size, res;\n-\n-    nb_tests++;\n-    \/*\n-     * load and parse the memory\n-     *\/\n-    if (loadMem(filename, &base, &size) != 0) {\n-        fprintf(stderr, \"Failed to load %s\\n\", filename);\n-    return(-1);\n-    }\n-\n-    doc = xmlReadMemory(base, size, filename, NULL, XML_PARSE_NOWARNING);\n-    unloadMem(base);\n-    if (doc == NULL) {\n-        return(1);\n-    }\n-    xmlDocDumpMemory(doc, (xmlChar **) &base, &size);\n-    xmlFreeDoc(doc);\n-    res = compareFileMem(result, base, size);\n-    if ((base == NULL) || (res != 0)) {\n-    if (base != NULL)\n-        xmlFree((char *)base);\n-        fprintf(stderr, \"Result for %s failed in %s\\n\", filename, result);\n-    return(-1);\n-    }\n-    xmlFree((char *)base);\n-    return(0);\n-}\n-\n-\/**\n- * noentParseTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages: unused\n- *\n- * Parse a file with entity resolution, then serialize back\n- * reparse the result and serialize again, then check for deviation\n- * in serialization.\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-noentParseTest(const char *filename, const char *result,\n-               const char *err  ATTRIBUTE_UNUSED,\n-           int options) {\n-    xmlDocPtr doc;\n-    char *temp;\n-    int res = 0;\n-\n-    nb_tests++;\n-    \/*\n-     * base of the test, parse with the old API\n-     *\/\n-    doc = xmlReadFile(filename, NULL,\n-                      options | XML_PARSE_NOWARNING | XML_PARSE_NOERROR);\n-    if (doc == NULL)\n-        return(1);\n-    temp = resultFilename(filename, temp_directory, \".res\");\n-    if (temp == NULL) {\n-        fprintf(stderr, \"Out of memory\\n\");\n-        fatalError();\n-    }\n-    xmlSaveFile(temp, doc);\n-    if (compareFiles(temp, result)) {\n-        res = 1;\n-    }\n-    xmlFreeDoc(doc);\n-\n-    \/*\n-     * Parse the saved result to make sure the round trip is okay\n-     *\/\n-    doc = xmlReadFile(filename, NULL,\n-                      options | XML_PARSE_NOWARNING | XML_PARSE_NOERROR);\n-    if (doc == NULL)\n-        return(1);\n-    xmlSaveFile(temp, doc);\n-    if (compareFiles(temp, result)) {\n-        res = 1;\n-    }\n-    xmlFreeDoc(doc);\n-\n-    if (temp != NULL) {\n-        unlink(temp);\n-        free(temp);\n-    }\n-    return(res);\n-}\n-\n-\/**\n- * errParseTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file using the xmlReadFile API and check for errors.\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-errParseTest(const char *filename, const char *result, const char *err,\n-             int options) {\n-    xmlParserCtxtPtr ctxt;\n-    xmlDocPtr doc;\n-    const char *base = NULL;\n-    int size, res = 0;\n-\n-    nb_tests++;\n-#ifdef LIBXML_HTML_ENABLED\n-    if (options & XML_PARSE_HTML) {\n-        ctxt = htmlNewParserCtxt();\n-        xmlCtxtSetErrorHandler(ctxt, testStructuredErrorHandler, NULL);\n-        doc = htmlCtxtReadFile(ctxt, filename, NULL, options);\n-        htmlFreeParserCtxt(ctxt);\n-    } else\n-#endif\n-    {\n-        ctxt = xmlNewParserCtxt();\n-        xmlCtxtSetErrorHandler(ctxt, testStructuredErrorHandler, NULL);\n-    doc = xmlCtxtReadFile(ctxt, filename, NULL, options);\n-        xmlFreeParserCtxt(ctxt);\n-#ifdef LIBXML_XINCLUDE_ENABLED\n-        if (options & XML_PARSE_XINCLUDE) {\n-            xmlXIncludeCtxtPtr xinc = NULL;\n-\n-            xinc = xmlXIncludeNewContext(doc);\n-            xmlXIncludeSetErrorHandler(xinc, testStructuredErrorHandler, NULL);\n-            xmlXIncludeSetFlags(xinc, options);\n-            if (xmlXIncludeProcessNode(xinc, (xmlNodePtr) doc) < 0) {\n-                testErrorHandler(NULL, \"%s : failed to parse\\n\", filename);\n-                xmlFreeDoc(doc);\n-                doc = NULL;\n-            }\n-            xmlXIncludeFreeContext(xinc);\n-        }\n-#endif\n-    }\n-    if (result) {\n-    if (doc == NULL) {\n-        base = \"\";\n-        size = 0;\n-    } else {\n-#ifdef LIBXML_HTML_ENABLED\n-        if (options & XML_PARSE_HTML) {\n-        htmlDocDumpMemory(doc, (xmlChar **) &base, &size);\n-        } else\n-#endif\n-        xmlDocDumpMemory(doc, (xmlChar **) &base, &size);\n-    }\n-    res = compareFileMem(result, base, size);\n-    }\n-    if (doc != NULL) {\n-    if (base != NULL)\n-        xmlFree((char *)base);\n-    xmlFreeDoc(doc);\n-    }\n-    if (res != 0) {\n-        fprintf(stderr, \"Result for %s failed in %s\\n\", filename, result);\n-        return(-1);\n-    }\n-    if (err != NULL) {\n-    res = compareFileMem(err, testErrors, testErrorsSize);\n-    if (res != 0) {\n-        fprintf(stderr, \"Error for %s failed\\n\", filename);\n-        return(-1);\n-    }\n-    } else if (options & XML_PARSE_DTDVALID) {\n-        if (testErrorsSize != 0)\n-        fprintf(stderr, \"Validation for %s failed\\n\", filename);\n-    }\n-\n-    return(0);\n-}\n-\n-#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_HTML_ENABLED)\n-\/**\n- * fdParseTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file using the xmlReadFd API and check for errors.\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-fdParseTest(const char *filename, const char *result, const char *err,\n-             int options) {\n-    xmlParserCtxtPtr ctxt;\n-    xmlDocPtr doc;\n-    const char *base = NULL;\n-    int size, res = 0, fd;\n-\n-    nb_tests++;\n-    fd = open(filename, RD_FLAGS);\n-#ifdef LIBXML_HTML_ENABLED\n-    if (options & XML_PARSE_HTML) {\n-        ctxt = htmlNewParserCtxt();\n-        xmlCtxtSetErrorHandler(ctxt, testStructuredErrorHandler, NULL);\n-        doc = htmlCtxtReadFd(ctxt, fd, filename, NULL, options);\n-        htmlFreeParserCtxt(ctxt);\n-    } else\n-#endif\n-    {\n-        ctxt = xmlNewParserCtxt();\n-        xmlCtxtSetErrorHandler(ctxt, testStructuredErrorHandler, NULL);\n-    doc = xmlCtxtReadFd(ctxt, fd, filename, NULL, options);\n-        xmlFreeParserCtxt(ctxt);\n-    }\n-    close(fd);\n-    if (result) {\n-    if (doc == NULL) {\n-        base = \"\";\n-        size = 0;\n-    } else {\n-#ifdef LIBXML_HTML_ENABLED\n-        if (options & XML_PARSE_HTML) {\n-        htmlDocDumpMemory(doc, (xmlChar **) &base, &size);\n-        } else\n-#endif\n-        xmlDocDumpMemory(doc, (xmlChar **) &base, &size);\n-    }\n-    res = compareFileMem(result, base, size);\n-    }\n-    if (doc != NULL) {\n-    if (base != NULL)\n-        xmlFree((char *)base);\n-    xmlFreeDoc(doc);\n-    }\n-    if (res != 0) {\n-        fprintf(stderr, \"Result for %s failed in %s\\n\", filename, result);\n-        return(-1);\n-    }\n-    if (err != NULL) {\n-    res = compareFileMem(err, testErrors, testErrorsSize);\n-    if (res != 0) {\n-        fprintf(stderr, \"Error for %s failed\\n\", filename);\n-        return(-1);\n-    }\n-    } else if (options & XML_PARSE_DTDVALID) {\n-        if (testErrorsSize != 0)\n-        fprintf(stderr, \"Validation for %s failed\\n\", filename);\n-    }\n-\n-    return(0);\n-}\n-#endif\n-\n-\n-#ifdef LIBXML_READER_ENABLED\n-\/************************************************************************\n- *                                    *\n- *        Reader based tests                    *\n- *                                    *\n- ************************************************************************\/\n-\n-static void processNode(FILE *out, xmlTextReaderPtr reader) {\n-    const xmlChar *name, *value;\n-    int type, empty;\n-\n-    type = xmlTextReaderNodeType(reader);\n-    empty = xmlTextReaderIsEmptyElement(reader);\n-\n-    name = xmlTextReaderConstName(reader);\n-    if (name == NULL)\n-    name = BAD_CAST \"--\";\n-\n-    value = xmlTextReaderConstValue(reader);\n-\n-\n-    fprintf(out, \"%d %d %s %d %d\",\n-        xmlTextReaderDepth(reader),\n-        type,\n-        name,\n-        empty,\n-        xmlTextReaderHasValue(reader));\n-    if (value == NULL)\n-    fprintf(out, \"\\n\");\n-    else {\n-    fprintf(out, \" %s\\n\", value);\n-    }\n-}\n-static int\n-streamProcessTest(const char *filename, const char *result, const char *err,\n-                  xmlTextReaderPtr reader, const char *rng,\n-                  int options ATTRIBUTE_UNUSED) {\n-    int ret;\n-    char *temp = NULL;\n-    FILE *t = NULL;\n-\n-    if (reader == NULL)\n-        return(-1);\n-\n-    nb_tests++;\n-    if (result != NULL) {\n-    temp = resultFilename(filename, temp_directory, \".res\");\n-    if (temp == NULL) {\n-        fprintf(stderr, \"Out of memory\\n\");\n-        fatalError();\n-    }\n-    t = fopen(temp, \"wb\");\n-    if (t == NULL) {\n-        fprintf(stderr, \"Can't open temp file %s\\n\", temp);\n-        free(temp);\n-        return(-1);\n-    }\n-    }\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-    if (rng != NULL) {\n-    ret = xmlTextReaderRelaxNGValidate(reader, rng);\n-    if (ret < 0) {\n-        testErrorHandler(NULL, \"Relax-NG schema %s failed to compile\\n\",\n-                         rng);\n-        fclose(t);\n-            if (temp != NULL) {\n-                unlink(temp);\n-                free(temp);\n-            }\n-        return(0);\n-    }\n-    }\n-#endif\n-    ret = xmlTextReaderRead(reader);\n-    while (ret == 1) {\n-    if ((t != NULL) && (rng == NULL))\n-        processNode(t, reader);\n-        ret = xmlTextReaderRead(reader);\n-    }\n-    if (ret != 0) {\n-        testErrorHandler(NULL, \"%s : failed to parse\\n\", filename);\n-    }\n-    if (rng != NULL) {\n-        if (xmlTextReaderIsValid(reader) != 1) {\n-        testErrorHandler(NULL, \"%s fails to validate\\n\", filename);\n-    } else {\n-        testErrorHandler(NULL, \"%s validates\\n\", filename);\n-    }\n-    }\n-    if (t != NULL) {\n-        fclose(t);\n-    ret = compareFiles(temp, result);\n-        if (temp != NULL) {\n-            unlink(temp);\n-            free(temp);\n-        }\n-    if (ret) {\n-        fprintf(stderr, \"Result for %s failed in %s\\n\", filename, result);\n-        return(-1);\n-    }\n-    }\n-    if (err != NULL) {\n-    ret = compareFileMem(err, testErrors, testErrorsSize);\n-    if (ret != 0) {\n-        fprintf(stderr, \"Error for %s failed\\n\", filename);\n-        printf(\"%s\", testErrors);\n-        return(-1);\n-    }\n-    }\n-\n-    return(0);\n-}\n-\n-\/**\n- * streamParseTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file using the reader API and check for errors.\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-streamParseTest(const char *filename, const char *result, const char *err,\n-                int options) {\n-    xmlTextReaderPtr reader;\n-    int ret;\n-\n-    reader = xmlReaderForFile(filename, NULL, options);\n-    xmlTextReaderSetStructuredErrorHandler(reader, testStructuredErrorHandler,\n-                                           NULL);\n-    ret = streamProcessTest(filename, result, err, reader, NULL, options);\n-    xmlFreeTextReader(reader);\n-    return(ret);\n-}\n-\n-\/**\n- * walkerParseTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file using the walker, i.e. a reader built from a atree.\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-walkerParseTest(const char *filename, const char *result, const char *err,\n-                int options) {\n-    xmlDocPtr doc;\n-    xmlTextReaderPtr reader;\n-    int ret;\n-\n-    doc = xmlReadFile(filename, NULL, options | XML_PARSE_NOWARNING);\n-    if (doc == NULL) {\n-        fprintf(stderr, \"Failed to parse %s\\n\", filename);\n-    return(-1);\n-    }\n-    reader = xmlReaderWalker(doc);\n-    ret = streamProcessTest(filename, result, err, reader, NULL, options);\n-    xmlFreeTextReader(reader);\n-    xmlFreeDoc(doc);\n-    return(ret);\n-}\n-\n-\/**\n- * streamMemParseTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file using the reader API from memory and check for errors.\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-streamMemParseTest(const char *filename, const char *result, const char *err,\n-                   int options) {\n-    xmlTextReaderPtr reader;\n-    int ret;\n-    const char *base;\n-    int size;\n-\n-    \/*\n-     * load and parse the memory\n-     *\/\n-    if (loadMem(filename, &base, &size) != 0) {\n-        fprintf(stderr, \"Failed to load %s\\n\", filename);\n-    return(-1);\n-    }\n-    reader = xmlReaderForMemory(base, size, filename, NULL, options);\n-    xmlTextReaderSetStructuredErrorHandler(reader, testStructuredErrorHandler,\n-                                           NULL);\n-    ret = streamProcessTest(filename, result, err, reader, NULL, options);\n-    free((char *)base);\n-    xmlFreeTextReader(reader);\n-    return(ret);\n-}\n-#endif\n-\n-#ifdef LIBXML_XPATH_ENABLED\n-#ifdef LIBXML_DEBUG_ENABLED\n-\/************************************************************************\n- *                                    *\n- *        XPath and XPointer based tests                *\n- *                                    *\n- ************************************************************************\/\n-\n-static FILE *xpathOutput;\n-static xmlDocPtr xpathDocument;\n-\n-static void\n-testXPath(const char *str, int xptr, int expr) {\n-    xmlXPathObjectPtr res;\n-    xmlXPathContextPtr ctxt;\n-\n-    nb_tests++;\n-#if defined(LIBXML_XPTR_ENABLED)\n-    if (xptr) {\n-    ctxt = xmlXPtrNewContext(xpathDocument, NULL, NULL);\n-        xmlXPathSetErrorHandler(ctxt, testStructuredErrorHandler, NULL);\n-    res = xmlXPtrEval(BAD_CAST str, ctxt);\n-    } else {\n-#endif\n-    ctxt = xmlXPathNewContext(xpathDocument);\n-        xmlXPathSetErrorHandler(ctxt, testStructuredErrorHandler, NULL);\n-    ctxt->node = xmlDocGetRootElement(xpathDocument);\n-    if (expr)\n-        res = xmlXPathEvalExpression(BAD_CAST str, ctxt);\n-    else {\n-        \/* res = xmlXPathEval(BAD_CAST str, ctxt); *\/\n-        xmlXPathCompExprPtr comp;\n-\n-        comp = xmlXPathCompile(BAD_CAST str);\n-        if (comp != NULL) {\n-        res = xmlXPathCompiledEval(comp, ctxt);\n-        xmlXPathFreeCompExpr(comp);\n-        } else\n-        res = NULL;\n-    }\n-#if defined(LIBXML_XPTR_ENABLED)\n-    }\n-#endif\n-    xmlXPathDebugDumpObject(xpathOutput, res, 0);\n-    xmlXPathFreeObject(res);\n-    xmlXPathFreeContext(ctxt);\n-}\n-\n-\/**\n- * xpathExprTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file containing XPath standalone expressions and evaluate them\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-xpathCommonTest(const char *filename, const char *result,\n-                int xptr, int expr) {\n-    FILE *input;\n-    char expression[5000];\n-    int len, ret = 0;\n-    char *temp;\n-\n-    temp = resultFilename(filename, temp_directory, \".res\");\n-    if (temp == NULL) {\n-        fprintf(stderr, \"Out of memory\\n\");\n-        fatalError();\n-    }\n-    xpathOutput = fopen(temp, \"wb\");\n-    if (xpathOutput == NULL) {\n-    fprintf(stderr, \"failed to open output file %s\\n\", temp);\n-        free(temp);\n-    return(-1);\n-    }\n-\n-    input = fopen(filename, \"rb\");\n-    if (input == NULL) {\n-        fprintf(stderr,\n-        \"Cannot open %s for reading\\n\", filename);\n-        free(temp);\n-    return(-1);\n-    }\n-    while (fgets(expression, 4500, input) != NULL) {\n-    len = strlen(expression);\n-    len--;\n-    while ((len >= 0) &&\n-           ((expression[len] == '\\n') || (expression[len] == '\\t') ||\n-        (expression[len] == '\\r') || (expression[len] == ' '))) len--;\n-    expression[len + 1] = 0;\n-    if (len >= 0) {\n-        fprintf(xpathOutput,\n-                \"\\n========================\\nExpression: %s\\n\",\n-            expression) ;\n-        testXPath(expression, xptr, expr);\n-    }\n-    }\n-\n-    fclose(input);\n-    fclose(xpathOutput);\n-    if (result != NULL) {\n-    ret = compareFiles(temp, result);\n-    if (ret) {\n-        fprintf(stderr, \"Result for %s failed in %s\\n\", filename, result);\n-    }\n-    }\n-\n-    if (temp != NULL) {\n-        unlink(temp);\n-        free(temp);\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xpathExprTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file containing XPath standalone expressions and evaluate them\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-xpathExprTest(const char *filename, const char *result,\n-              const char *err ATTRIBUTE_UNUSED,\n-              int options ATTRIBUTE_UNUSED) {\n-    return(xpathCommonTest(filename, result, 0, 1));\n-}\n-\n-\/**\n- * xpathDocTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file containing XPath expressions and evaluate them against\n- * a set of corresponding documents.\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-xpathDocTest(const char *filename,\n-             const char *resul ATTRIBUTE_UNUSED,\n-             const char *err ATTRIBUTE_UNUSED,\n-             int options) {\n-\n-    char pattern[500];\n-    char result[500];\n-    glob_t globbuf;\n-    size_t i;\n-    int ret = 0, res;\n-\n-    xpathDocument = xmlReadFile(filename, NULL,\n-                                options | XML_PARSE_DTDATTR | XML_PARSE_NOENT);\n-    if (xpathDocument == NULL) {\n-        fprintf(stderr, \"Failed to load %s\\n\", filename);\n-    return(-1);\n-    }\n-\n-    res = snprintf(pattern, 499, \".\/test\/XPath\/tests\/%s*\",\n-            baseFilename(filename));\n-    if (res >= 499)\n-        pattern[499] = 0;\n-    globbuf.gl_offs = 0;\n-    glob(pattern, GLOB_DOOFFS, NULL, &globbuf);\n-    for (i = 0;i < globbuf.gl_pathc;i++) {\n-        res = snprintf(result, 499, \"result\/XPath\/tests\/%s\",\n-             baseFilename(globbuf.gl_pathv[i]));\n-        if (res >= 499)\n-            result[499] = 0;\n-    res = xpathCommonTest(globbuf.gl_pathv[i], &result[0], 0, 0);\n-    if (res != 0)\n-        ret = res;\n-    }\n-    globfree(&globbuf);\n-\n-    xmlFreeDoc(xpathDocument);\n-    return(ret);\n-}\n-\n-#ifdef LIBXML_XPTR_ENABLED\n-\/**\n- * xptrDocTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file containing XPath expressions and evaluate them against\n- * a set of corresponding documents.\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-xptrDocTest(const char *filename,\n-            const char *resul ATTRIBUTE_UNUSED,\n-            const char *err ATTRIBUTE_UNUSED,\n-            int options) {\n-\n-    char pattern[500];\n-    char result[500];\n-    glob_t globbuf;\n-    size_t i;\n-    int ret = 0, res;\n-    const char *subdir = options == -1 ? \"xptr-xp1\" : \"xptr\";\n-\n-    xpathDocument = xmlReadFile(filename, NULL,\n-                                XML_PARSE_DTDATTR | XML_PARSE_NOENT);\n-    if (xpathDocument == NULL) {\n-        fprintf(stderr, \"Failed to load %s\\n\", filename);\n-    return(-1);\n-    }\n-\n-    res = snprintf(pattern, 499, \".\/test\/XPath\/%s\/%s*\",\n-            subdir, baseFilename(filename));\n-    if (res >= 499)\n-        pattern[499] = 0;\n-    globbuf.gl_offs = 0;\n-    glob(pattern, GLOB_DOOFFS, NULL, &globbuf);\n-    for (i = 0;i < globbuf.gl_pathc;i++) {\n-        res = snprintf(result, 499, \"result\/XPath\/%s\/%s\",\n-             subdir, baseFilename(globbuf.gl_pathv[i]));\n-        if (res >= 499)\n-            result[499] = 0;\n-    res = xpathCommonTest(globbuf.gl_pathv[i], &result[0], 1, 0);\n-    if (res != 0)\n-        ret = res;\n-    }\n-    globfree(&globbuf);\n-\n-    xmlFreeDoc(xpathDocument);\n-    return(ret);\n-}\n-#endif \/* LIBXML_XPTR_ENABLED *\/\n-\n-#ifdef LIBXML_VALID_ENABLED\n-\/**\n- * xmlidDocTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file containing xml:id and check for errors and verify\n- * that XPath queries will work on them as expected.\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-xmlidDocTest(const char *filename,\n-             const char *result,\n-             const char *err,\n-             int options) {\n-    xmlParserCtxtPtr ctxt;\n-    int res = 0;\n-    int ret = 0;\n-    char *temp;\n-\n-    ctxt = xmlNewParserCtxt();\n-    xmlCtxtSetErrorHandler(ctxt, testStructuredErrorHandler, NULL);\n-    xpathDocument = xmlCtxtReadFile(ctxt, filename, NULL,\n-            options | XML_PARSE_DTDATTR | XML_PARSE_NOENT);\n-    xmlFreeParserCtxt(ctxt);\n-    if (xpathDocument == NULL) {\n-        fprintf(stderr, \"Failed to load %s\\n\", filename);\n-    return(-1);\n-    }\n-\n-    temp = resultFilename(filename, temp_directory, \".res\");\n-    if (temp == NULL) {\n-        fprintf(stderr, \"Out of memory\\n\");\n-        fatalError();\n-    }\n-    xpathOutput = fopen(temp, \"wb\");\n-    if (xpathOutput == NULL) {\n-    fprintf(stderr, \"failed to open output file %s\\n\", temp);\n-        xmlFreeDoc(xpathDocument);\n-        free(temp);\n-    return(-1);\n-    }\n-\n-    testXPath(\"id('bar')\", 0, 0);\n-\n-    fclose(xpathOutput);\n-    if (result != NULL) {\n-    ret = compareFiles(temp, result);\n-    if (ret) {\n-        fprintf(stderr, \"Result for %s failed in %s\\n\", filename, result);\n-        res = 1;\n-    }\n-    }\n-\n-    if (temp != NULL) {\n-        unlink(temp);\n-        free(temp);\n-    }\n-    xmlFreeDoc(xpathDocument);\n-\n-    if (err != NULL) {\n-    ret = compareFileMem(err, testErrors, testErrorsSize);\n-    if (ret != 0) {\n-        fprintf(stderr, \"Error for %s failed\\n\", filename);\n-        res = 1;\n-    }\n-    }\n-    return(res);\n-}\n-#endif \/* LIBXML_VALID_ENABLED *\/\n-\n-#endif \/* LIBXML_DEBUG_ENABLED *\/\n-#endif \/* XPATH *\/\n-\/************************************************************************\n- *                                    *\n- *            URI based tests                    *\n- *                                    *\n- ************************************************************************\/\n-\n-static void\n-handleURI(const char *str, const char *base, FILE *o) {\n-    int ret;\n-    xmlURIPtr uri;\n-    xmlChar *res = NULL;\n-\n-    uri = xmlCreateURI();\n-\n-    if (base == NULL) {\n-    ret = xmlParseURIReference(uri, str);\n-    if (ret != 0)\n-        fprintf(o, \"%s : error %d\\n\", str, ret);\n-    else {\n-        xmlNormalizeURIPath(uri->path);\n-        xmlPrintURI(o, uri);\n-        fprintf(o, \"\\n\");\n-    }\n-    } else {\n-    res = xmlBuildURI((xmlChar *)str, (xmlChar *) base);\n-    if (res != NULL) {\n-        fprintf(o, \"%s\\n\", (char *) res);\n-    }\n-    else\n-        fprintf(o, \"::ERROR::\\n\");\n-    }\n-    if (res != NULL)\n-    xmlFree(res);\n-    xmlFreeURI(uri);\n-}\n-\n-\/**\n- * uriCommonTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file containing URI and check for errors\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-uriCommonTest(const char *filename,\n-             const char *result,\n-             const char *err,\n-             const char *base) {\n-    char *temp;\n-    FILE *o, *f;\n-    char str[1024];\n-    int res = 0, i, ret;\n-\n-    temp = resultFilename(filename, temp_directory, \".res\");\n-    if (temp == NULL) {\n-        fprintf(stderr, \"Out of memory\\n\");\n-        fatalError();\n-    }\n-    o = fopen(temp, \"wb\");\n-    if (o == NULL) {\n-    fprintf(stderr, \"failed to open output file %s\\n\", temp);\n-        free(temp);\n-    return(-1);\n-    }\n-    f = fopen(filename, \"rb\");\n-    if (f == NULL) {\n-    fprintf(stderr, \"failed to open input file %s\\n\", filename);\n-    fclose(o);\n-        if (temp != NULL) {\n-            unlink(temp);\n-            free(temp);\n-        }\n-    return(-1);\n-    }\n-\n-    while (1) {\n-    \/*\n-     * read one line in string buffer.\n-     *\/\n-    if (fgets (&str[0], sizeof (str) - 1, f) == NULL)\n-       break;\n-\n-    \/*\n-     * remove the ending spaces\n-     *\/\n-    i = strlen(str);\n-    while ((i > 0) &&\n-           ((str[i - 1] == '\\n') || (str[i - 1] == '\\r') ||\n-        (str[i - 1] == ' ') || (str[i - 1] == '\\t'))) {\n-        i--;\n-        str[i] = 0;\n-    }\n-    nb_tests++;\n-    handleURI(str, base, o);\n-    }\n-\n-    fclose(f);\n-    fclose(o);\n-\n-    if (result != NULL) {\n-    ret = compareFiles(temp, result);\n-    if (ret) {\n-        fprintf(stderr, \"Result for %s failed in %s\\n\", filename, result);\n-        res = 1;\n-    }\n-    }\n-    if (err != NULL) {\n-    ret = compareFileMem(err, testErrors, testErrorsSize);\n-    if (ret != 0) {\n-        fprintf(stderr, \"Error for %s failed\\n\", filename);\n-        res = 1;\n-    }\n-    }\n-\n-    if (temp != NULL) {\n-        unlink(temp);\n-        free(temp);\n-    }\n-    return(res);\n-}\n-\n-\/**\n- * uriParseTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file containing URI and check for errors\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-uriParseTest(const char *filename,\n-             const char *result,\n-             const char *err,\n-             int options ATTRIBUTE_UNUSED) {\n-    return(uriCommonTest(filename, result, err, NULL));\n-}\n-\n-\/**\n- * uriBaseTest:\n- * @filename: the file to parse\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file containing URI, compose them against a fixed base and\n- * check for errors\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-uriBaseTest(const char *filename,\n-             const char *result,\n-             const char *err,\n-             int options ATTRIBUTE_UNUSED) {\n-    return(uriCommonTest(filename, result, err,\n-                         \"http:\/\/foo.com\/path\/to\/index.html?orig#help\"));\n-}\n-\n-static int urip_success = 1;\n-static int urip_current = 0;\n-static const char *urip_testURLs[] = {\n-    \"urip:\/\/example.com\/a b.html\",\n-    \"urip:\/\/example.com\/a%20b.html\",\n-    \"file:\/\/\/path\/to\/a b.html\",\n-    \"file:\/\/\/path\/to\/a%20b.html\",\n-    \"\/path\/to\/a b.html\",\n-    \"\/path\/to\/a%20b.html\",\n-    \"urip:\/\/example.com\/r\" \"\\xe9\" \"sum\" \"\\xe9\" \".html\",\n-    \"urip:\/\/example.com\/test?a=1&b=2%263&c=4#foo\",\n-    NULL\n-};\n-static const char *urip_rcvsURLs[] = {\n-    \/* it is an URI the strings must be escaped *\/\n-    \"urip:\/\/example.com\/a%20b.html\",\n-    \/* check that % escaping is not broken *\/\n-    \"urip:\/\/example.com\/a%20b.html\",\n-    \/* it's an URI path the strings must be escaped *\/\n-    \"file:\/\/\/path\/to\/a%20b.html\",\n-    \/* check that % escaping is not broken *\/\n-    \"file:\/\/\/path\/to\/a%20b.html\",\n-    \/* this is not an URI, this is a path, so this should not be escaped *\/\n-    \"\/path\/to\/a b.html\",\n-    \/* check that paths with % are not broken *\/\n-    \"\/path\/to\/a%20b.html\",\n-    \/* out of context the encoding can't be guessed byte by byte conversion *\/\n-    \"urip:\/\/example.com\/r%E9sum%E9.html\",\n-    \/* verify we don't destroy URIs especially the query part *\/\n-    \"urip:\/\/example.com\/test?a=1&b=2%263&c=4#foo\",\n-    NULL\n-};\n-static const char *urip_res = \"<list\/>\";\n-static const char *urip_cur = NULL;\n-static int urip_rlen;\n-\n-\/**\n- * uripMatch:\n- * @URI: an URI to test\n- *\n- * Check for an urip: query\n- *\n- * Returns 1 if yes and 0 if another Input module should be used\n- *\/\n-static int\n-uripMatch(const char * URI) {\n-    if ((URI == NULL) || (!strcmp(URI, \"file:\/\/\" SYSCONFDIR \"\/xml\/catalog\")))\n-        return(0);\n-    \/* Verify we received the escaped URL *\/\n-    if (strcmp(urip_rcvsURLs[urip_current], URI))\n-    urip_success = 0;\n-    return(1);\n-}\n-\n-\/**\n- * uripOpen:\n- * @URI: an URI to test\n- *\n- * Return a pointer to the urip: query handler, in this example simply\n- * the urip_current pointer...\n- *\n- * Returns an Input context or NULL in case or error\n- *\/\n-static void *\n-uripOpen(const char * URI) {\n-    if ((URI == NULL) || (!strcmp(URI, \"file:\/\/\" SYSCONFDIR \"\/xml\/catalog\")))\n-        return(NULL);\n-    \/* Verify we received the escaped URL *\/\n-    if (strcmp(urip_rcvsURLs[urip_current], URI))\n-    urip_success = 0;\n-    urip_cur = urip_res;\n-    urip_rlen = strlen(urip_res);\n-    return((void *) urip_cur);\n-}\n-\n-\/**\n- * uripClose:\n- * @context: the read context\n- *\n- * Close the urip: query handler\n- *\n- * Returns 0 or -1 in case of error\n- *\/\n-static int\n-uripClose(void * context) {\n-    if (context == NULL) return(-1);\n-    urip_cur = NULL;\n-    urip_rlen = 0;\n-    return(0);\n-}\n-\n-\/**\n- * uripRead:\n- * @context: the read context\n- * @buffer: where to store data\n- * @len: number of bytes to read\n- *\n- * Implement an urip: query read.\n- *\n- * Returns the number of bytes read or -1 in case of error\n- *\/\n-static int\n-uripRead(void * context, char * buffer, int len) {\n-   const char *ptr = (const char *) context;\n-\n-   if ((context == NULL) || (buffer == NULL) || (len < 0))\n-       return(-1);\n-\n-   if (len > urip_rlen) len = urip_rlen;\n-   memcpy(buffer, ptr, len);\n-   urip_rlen -= len;\n-   return(len);\n-}\n-\n-static int\n-urip_checkURL(const char *URL) {\n-    xmlDocPtr doc;\n-\n-    doc = xmlReadFile(URL, NULL, 0);\n-    if (doc == NULL)\n-        return(-1);\n-    xmlFreeDoc(doc);\n-    return(1);\n-}\n-\n-\/**\n- * uriPathTest:\n- * @filename: ignored\n- * @result: ignored\n- * @err: ignored\n- *\n- * Run a set of tests to check how Path and URI are handled before\n- * being passed to the I\/O layer\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-uriPathTest(const char *filename ATTRIBUTE_UNUSED,\n-             const char *result ATTRIBUTE_UNUSED,\n-             const char *err ATTRIBUTE_UNUSED,\n-             int options ATTRIBUTE_UNUSED) {\n-    int parsed;\n-    int failures = 0;\n-\n-    \/*\n-     * register the new I\/O handlers\n-     *\/\n-    if (xmlRegisterInputCallbacks(uripMatch, uripOpen, uripRead, uripClose) < 0)\n-    {\n-        fprintf(stderr, \"failed to register HTTP handler\\n\");\n-    return(-1);\n-    }\n-\n-    for (urip_current = 0;urip_testURLs[urip_current] != NULL;urip_current++) {\n-        urip_success = 1;\n-        parsed = urip_checkURL(urip_testURLs[urip_current]);\n-    if (urip_success != 1) {\n-        fprintf(stderr, \"failed the URL passing test for %s\",\n-                urip_testURLs[urip_current]);\n-        failures++;\n-    } else if (parsed != 1) {\n-        fprintf(stderr, \"failed the parsing test for %s\",\n-                urip_testURLs[urip_current]);\n-        failures++;\n-    }\n-    nb_tests++;\n-    }\n-\n-    xmlPopInputCallbacks();\n-    return(failures);\n-}\n-\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-\/************************************************************************\n- *                                    *\n- *            Schemas tests                    *\n- *                                    *\n- ************************************************************************\/\n-static int\n-schemasOneTest(const char *sch,\n-               const char *filename,\n-               const char *result,\n-               const char *err,\n-           int options,\n-           xmlSchemaPtr schemas) {\n-    int ret = 0;\n-    int i;\n-    char *temp;\n-    int parseErrorsSize = testErrorsSize;\n-\n-    temp = resultFilename(result, temp_directory, \".res\");\n-    if (temp == NULL) {\n-        fprintf(stderr, \"Out of memory\\n\");\n-        fatalError();\n-        return(-1);\n-    }\n-\n-    \/*\n-     * Test both memory and streaming validation.\n-     *\/\n-    for (i = 0; i < 2; i++) {\n-        xmlSchemaValidCtxtPtr ctxt;\n-        int validResult = 0;\n-        FILE *schemasOutput;\n-\n-        testErrorsSize = parseErrorsSize;\n-        testErrors[parseErrorsSize] = 0;\n-\n-        if (schemas == NULL)\n-            goto done;\n-\n-        ctxt = xmlSchemaNewValidCtxt(schemas);\n-        xmlSchemaSetValidStructuredErrors(ctxt, testStructuredErrorHandler,\n-                                          NULL);\n-\n-        schemasOutput = fopen(temp, \"wb\");\n-        if (schemasOutput == NULL) {\n-            fprintf(stderr, \"failed to open output file %s\\n\", temp);\n-            free(temp);\n-            return(-1);\n-        }\n-\n-        if (i == 0) {\n-            xmlDocPtr doc;\n-\n-            doc = xmlReadFile(filename, NULL, options);\n-            if (doc == NULL) {\n-                fprintf(stderr, \"failed to parse instance %s for %s\\n\", filename, sch);\n-                return(-1);\n-            }\n-            validResult = xmlSchemaValidateDoc(ctxt, doc);\n-            xmlFreeDoc(doc);\n-        } else {\n-            validResult = xmlSchemaValidateFile(ctxt, filename, options);\n-        }\n-\n-        if (validResult == 0) {\n-            fprintf(schemasOutput, \"%s validates\\n\", filename);\n-        } else if (validResult > 0) {\n-            fprintf(schemasOutput, \"%s fails to validate\\n\", filename);\n-        } else {\n-            fprintf(schemasOutput, \"%s validation generated an internal error\\n\",\n-                   filename);\n-        }\n-        fclose(schemasOutput);\n-\n-        if (result) {\n-            if (compareFiles(temp, result)) {\n-                fprintf(stderr, \"Result for %s on %s failed\\n\", filename, sch);\n-                ret = 1;\n-            }\n-        }\n-\n-        xmlSchemaFreeValidCtxt(ctxt);\n-\n-done:\n-        if (compareFileMem(err, testErrors, testErrorsSize)) {\n-            fprintf(stderr, \"Error for %s on %s failed\\n\", filename, sch);\n-            ret = 1;\n-        }\n-\n-        unlink(temp);\n-    }\n-\n-    free(temp);\n-    return(ret);\n-}\n-\/**\n- * schemasTest:\n- * @filename: the schemas file\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a file containing URI, compose them against a fixed base and\n- * check for errors\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-schemasTest(const char *filename,\n-            const char *resul ATTRIBUTE_UNUSED,\n-            const char *errr ATTRIBUTE_UNUSED,\n-            int options) {\n-    const char *base = baseFilename(filename);\n-    const char *base2;\n-    const char *instance;\n-    xmlSchemaParserCtxtPtr ctxt;\n-    xmlSchemaPtr schemas;\n-    int res = 0, len, ret;\n-    int parseErrorsSize;\n-    char pattern[500];\n-    char prefix[500];\n-    char result[500];\n-    char err[500];\n-    glob_t globbuf;\n-    size_t i;\n-    char count = 0;\n-\n-    \/* first compile the schemas if possible *\/\n-    ctxt = xmlSchemaNewParserCtxt(filename);\n-    xmlSchemaSetParserStructuredErrors(ctxt, testStructuredErrorHandler, NULL);\n-    schemas = xmlSchemaParse(ctxt);\n-    xmlSchemaFreeParserCtxt(ctxt);\n-    parseErrorsSize = testErrorsSize;\n-\n-    \/*\n-     * most of the mess is about the output filenames generated by the Makefile\n-     *\/\n-    len = strlen(base);\n-    if ((len > 499) || (len < 5)) {\n-        xmlSchemaFree(schemas);\n-    return(-1);\n-    }\n-    len -= 4; \/* remove trailing .xsd *\/\n-    if (base[len - 2] == '_') {\n-        len -= 2; \/* remove subtest number *\/\n-    }\n-    if (base[len - 2] == '_') {\n-        len -= 2; \/* remove subtest number *\/\n-    }\n-    memcpy(prefix, base, len);\n-    prefix[len] = 0;\n-\n-    if (snprintf(pattern, 499, \".\/test\/schemas\/%s_*.xml\", prefix) >= 499)\n-        pattern[499] = 0;\n-\n-    if (base[len] == '_') {\n-        len += 2;\n-    memcpy(prefix, base, len);\n-    prefix[len] = 0;\n-    }\n-\n-    globbuf.gl_offs = 0;\n-    glob(pattern, GLOB_DOOFFS, NULL, &globbuf);\n-    for (i = 0;i < globbuf.gl_pathc;i++) {\n-        testErrorsSize = parseErrorsSize;\n-        testErrors[parseErrorsSize] = 0;\n-        instance = globbuf.gl_pathv[i];\n-    base2 = baseFilename(instance);\n-    len = strlen(base2);\n-    if ((len > 6) && (base2[len - 6] == '_')) {\n-        count = base2[len - 5];\n-        ret = snprintf(result, 499, \"result\/schemas\/%s_%c\",\n-             prefix, count);\n-            if (ret >= 499)\n-            result[499] = 0;\n-        ret = snprintf(err, 499, \"result\/schemas\/%s_%c.err\",\n-             prefix, count);\n-            if (ret >= 499)\n-            err[499] = 0;\n-    } else {\n-        fprintf(stderr, \"don't know how to process %s\\n\", instance);\n-        continue;\n-    }\n-\n-        nb_tests++;\n-        ret = schemasOneTest(filename, instance, result, err,\n-                             options, schemas);\n-        if (ret != 0)\n-            res = ret;\n-    }\n-    globfree(&globbuf);\n-    xmlSchemaFree(schemas);\n-\n-    return(res);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Schemas tests                    *\n- *                                    *\n- ************************************************************************\/\n-static int\n-rngOneTest(const char *sch,\n-               const char *filename,\n-               const char *result,\n-           int options,\n-           xmlRelaxNGPtr schemas) {\n-    xmlDocPtr doc;\n-    xmlRelaxNGValidCtxtPtr ctxt;\n-    int ret = 0;\n-    char *temp;\n-    FILE *schemasOutput;\n-\n-    doc = xmlReadFile(filename, NULL, options);\n-    if (doc == NULL) {\n-        fprintf(stderr, \"failed to parse instance %s for %s\\n\", filename, sch);\n-    return(-1);\n-    }\n-\n-    temp = resultFilename(result, temp_directory, \".res\");\n-    if (temp == NULL) {\n-        fprintf(stderr, \"Out of memory\\n\");\n-        fatalError();\n-    }\n-    schemasOutput = fopen(temp, \"wb\");\n-    if (schemasOutput == NULL) {\n-    fprintf(stderr, \"failed to open output file %s\\n\", temp);\n-    xmlFreeDoc(doc);\n-        free(temp);\n-    return(-1);\n-    }\n-\n-    ctxt = xmlRelaxNGNewValidCtxt(schemas);\n-    xmlRelaxNGSetValidStructuredErrors(ctxt, testStructuredErrorHandler, NULL);\n-    ret = xmlRelaxNGValidateDoc(ctxt, doc);\n-    if (ret == 0) {\n-    testErrorHandler(NULL, \"%s validates\\n\", filename);\n-    } else if (ret > 0) {\n-    testErrorHandler(NULL, \"%s fails to validate\\n\", filename);\n-    } else {\n-    testErrorHandler(NULL, \"%s validation generated an internal error\\n\",\n-           filename);\n-    }\n-    fclose(schemasOutput);\n-    ret = 0;\n-    if (result) {\n-    if (compareFiles(temp, result)) {\n-        fprintf(stderr, \"Result for %s on %s failed\\n\", filename, sch);\n-        ret = 1;\n-    }\n-    }\n-    if (temp != NULL) {\n-        unlink(temp);\n-        free(temp);\n-    }\n-\n-    xmlRelaxNGFreeValidCtxt(ctxt);\n-    xmlFreeDoc(doc);\n-    return(ret);\n-}\n-\/**\n- * rngTest:\n- * @filename: the schemas file\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse an RNG schemas and then apply it to the related .xml\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-rngTest(const char *filename,\n-            const char *resul ATTRIBUTE_UNUSED,\n-            const char *errr ATTRIBUTE_UNUSED,\n-            int options) {\n-    const char *base = baseFilename(filename);\n-    const char *base2;\n-    const char *instance;\n-    xmlRelaxNGParserCtxtPtr ctxt;\n-    xmlRelaxNGPtr schemas;\n-    int res = 0, len, ret = 0;\n-    int parseErrorsSize;\n-    char pattern[500];\n-    char prefix[500];\n-    char result[500];\n-    char err[500];\n-    glob_t globbuf;\n-    size_t i;\n-    char count = 0;\n-\n-    \/* first compile the schemas if possible *\/\n-    ctxt = xmlRelaxNGNewParserCtxt(filename);\n-    xmlRelaxNGSetParserStructuredErrors(ctxt, testStructuredErrorHandler,\n-                                        NULL);\n-    schemas = xmlRelaxNGParse(ctxt);\n-    xmlRelaxNGFreeParserCtxt(ctxt);\n-    if (schemas == NULL)\n-        testErrorHandler(NULL, \"Relax-NG schema %s failed to compile\\n\",\n-                         filename);\n-    parseErrorsSize = testErrorsSize;\n-\n-    \/*\n-     * most of the mess is about the output filenames generated by the Makefile\n-     *\/\n-    len = strlen(base);\n-    if ((len > 499) || (len < 5)) {\n-        xmlRelaxNGFree(schemas);\n-    return(-1);\n-    }\n-    len -= 4; \/* remove trailing .rng *\/\n-    memcpy(prefix, base, len);\n-    prefix[len] = 0;\n-\n-    if (snprintf(pattern, 499, \".\/test\/relaxng\/%s_?.xml\", prefix) >= 499)\n-        pattern[499] = 0;\n-\n-    globbuf.gl_offs = 0;\n-    glob(pattern, GLOB_DOOFFS, NULL, &globbuf);\n-    for (i = 0;i < globbuf.gl_pathc;i++) {\n-        testErrorsSize = parseErrorsSize;\n-        testErrors[parseErrorsSize] = 0;\n-        instance = globbuf.gl_pathv[i];\n-    base2 = baseFilename(instance);\n-    len = strlen(base2);\n-    if ((len > 6) && (base2[len - 6] == '_')) {\n-        count = base2[len - 5];\n-        res = snprintf(result, 499, \"result\/relaxng\/%s_%c\",\n-             prefix, count);\n-            if (res >= 499)\n-            result[499] = 0;\n-        res = snprintf(err, 499, \"result\/relaxng\/%s_%c.err\",\n-             prefix, count);\n-            if (res >= 499)\n-            err[499] = 0;\n-    } else {\n-        fprintf(stderr, \"don't know how to process %s\\n\", instance);\n-        continue;\n-    }\n-    if (schemas != NULL) {\n-        nb_tests++;\n-        res = rngOneTest(filename, instance, result, options, schemas);\n-        if (res != 0)\n-        ret = res;\n-    }\n-        if (compareFileMem(err, testErrors, testErrorsSize)) {\n-            fprintf(stderr, \"Error for %s on %s failed\\n\", instance,\n-                    filename);\n-            ret = 1;\n-        }\n-    }\n-    globfree(&globbuf);\n-    xmlRelaxNGFree(schemas);\n-\n-    return(ret);\n-}\n-\n-#ifdef LIBXML_READER_ENABLED\n-\/**\n- * rngStreamTest:\n- * @filename: the schemas file\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a set of files with streaming, applying an RNG schemas\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-rngStreamTest(const char *filename,\n-            const char *resul ATTRIBUTE_UNUSED,\n-            const char *errr ATTRIBUTE_UNUSED,\n-            int options) {\n-    const char *base = baseFilename(filename);\n-    const char *base2;\n-    const char *instance;\n-    int res = 0, len, ret;\n-    char pattern[500];\n-    char prefix[500];\n-    char result[500];\n-    char err[500];\n-    glob_t globbuf;\n-    size_t i;\n-    char count = 0;\n-    xmlTextReaderPtr reader;\n-    int disable_err = 0;\n-\n-    \/*\n-     * most of the mess is about the output filenames generated by the Makefile\n-     *\/\n-    len = strlen(base);\n-    if ((len > 499) || (len < 5)) {\n-    fprintf(stderr, \"len(base) == %d !\\n\", len);\n-    return(-1);\n-    }\n-    len -= 4; \/* remove trailing .rng *\/\n-    memcpy(prefix, base, len);\n-    prefix[len] = 0;\n-\n-    \/*\n-     * strictly unifying the error messages is nearly impossible this\n-     * hack is also done in the Makefile\n-     *\/\n-    if ((!strcmp(prefix, \"tutor10_1\")) || (!strcmp(prefix, \"tutor10_2\")) ||\n-        (!strcmp(prefix, \"tutor3_2\")) || (!strcmp(prefix, \"307377\")) ||\n-        (!strcmp(prefix, \"tutor8_2\")))\n-    disable_err = 1;\n-\n-    if (snprintf(pattern, 499, \".\/test\/relaxng\/%s_?.xml\", prefix) >= 499)\n-        pattern[499] = 0;\n-\n-    globbuf.gl_offs = 0;\n-    glob(pattern, GLOB_DOOFFS, NULL, &globbuf);\n-    for (i = 0;i < globbuf.gl_pathc;i++) {\n-        testErrorsSize = 0;\n-    testErrors[0] = 0;\n-        instance = globbuf.gl_pathv[i];\n-    base2 = baseFilename(instance);\n-    len = strlen(base2);\n-    if ((len > 6) && (base2[len - 6] == '_')) {\n-        count = base2[len - 5];\n-        ret = snprintf(result, 499, \"result\/relaxng\/%s_%c\",\n-             prefix, count);\n-            if (ret >= 499)\n-            result[499] = 0;\n-        ret = snprintf(err, 499, \"result\/relaxng\/%s_%c.err\",\n-             prefix, count);\n-            if (ret >= 499)\n-            err[499] = 0;\n-    } else {\n-        fprintf(stderr, \"don't know how to process %s\\n\", instance);\n-        continue;\n-    }\n-    reader = xmlReaderForFile(instance, NULL, options);\n-        xmlTextReaderSetStructuredErrorHandler(reader,\n-                testStructuredErrorHandler, NULL);\n-    if (reader == NULL) {\n-        fprintf(stderr, \"Failed to build reader for %s\\n\", instance);\n-    }\n-    if (disable_err == 1)\n-        ret = streamProcessTest(instance, result, NULL, reader, filename,\n-                                options);\n-    else\n-        ret = streamProcessTest(instance, result, err, reader, filename,\n-                                options);\n-    xmlFreeTextReader(reader);\n-    if (ret != 0) {\n-        fprintf(stderr, \"instance %s failed\\n\", instance);\n-        res = ret;\n-    }\n-    }\n-    globfree(&globbuf);\n-\n-    return(res);\n-}\n-#endif \/* READER *\/\n-\n-#endif\n-\n-#ifdef LIBXML_PATTERN_ENABLED\n-#ifdef LIBXML_READER_ENABLED\n-\/************************************************************************\n- *                                    *\n- *            Patterns tests                    *\n- *                                    *\n- ************************************************************************\/\n-static void patternNode(FILE *out, xmlTextReaderPtr reader,\n-                        const char *pattern, xmlPatternPtr patternc,\n-            xmlStreamCtxtPtr patstream) {\n-    xmlChar *path = NULL;\n-    int match = -1;\n-    int type, empty;\n-\n-    type = xmlTextReaderNodeType(reader);\n-    empty = xmlTextReaderIsEmptyElement(reader);\n-\n-    if (type == XML_READER_TYPE_ELEMENT) {\n-    \/* do the check only on element start *\/\n-    match = xmlPatternMatch(patternc, xmlTextReaderCurrentNode(reader));\n-\n-    if (match) {\n-        path = xmlGetNodePath(xmlTextReaderCurrentNode(reader));\n-        fprintf(out, \"Node %s matches pattern %s\\n\", path, pattern);\n-    }\n-    }\n-    if (patstream != NULL) {\n-    int ret;\n-\n-    if (type == XML_READER_TYPE_ELEMENT) {\n-        ret = xmlStreamPush(patstream,\n-                xmlTextReaderConstLocalName(reader),\n-                xmlTextReaderConstNamespaceUri(reader));\n-        if (ret < 0) {\n-        fprintf(out, \"xmlStreamPush() failure\\n\");\n-        xmlFreeStreamCtxt(patstream);\n-        patstream = NULL;\n-        } else if (ret != match) {\n-        if (path == NULL) {\n-            path = xmlGetNodePath(\n-                   xmlTextReaderCurrentNode(reader));\n-        }\n-        fprintf(out,\n-            \"xmlPatternMatch and xmlStreamPush disagree\\n\");\n-        fprintf(out,\n-            \"  pattern %s node %s\\n\",\n-            pattern, path);\n-        }\n-\n-\n-    }\n-    if ((type == XML_READER_TYPE_END_ELEMENT) ||\n-        ((type == XML_READER_TYPE_ELEMENT) && (empty))) {\n-        ret = xmlStreamPop(patstream);\n-        if (ret < 0) {\n-        fprintf(out, \"xmlStreamPop() failure\\n\");\n-        xmlFreeStreamCtxt(patstream);\n-        patstream = NULL;\n-        }\n-    }\n-    }\n-    if (path != NULL)\n-    xmlFree(path);\n-}\n-\n-\/**\n- * patternTest:\n- * @filename: the schemas file\n- * @result: the file with expected result\n- * @err: the file with error messages\n- *\n- * Parse a set of files with streaming, applying an RNG schemas\n- *\n- * Returns 0 in case of success, an error code otherwise\n- *\/\n-static int\n-patternTest(const char *filename,\n-            const char *resul ATTRIBUTE_UNUSED,\n-            const char *err ATTRIBUTE_UNUSED,\n-            int options) {\n-    xmlPatternPtr patternc = NULL;\n-    xmlStreamCtxtPtr patstream = NULL;\n-    FILE *o, *f;\n-    char str[1024];\n-    char xml[500];\n-    char result[500];\n-    int len, i;\n-    int ret = 0, res;\n-    char *temp;\n-    xmlTextReaderPtr reader;\n-    xmlDocPtr doc;\n-\n-    len = strlen(filename);\n-    len -= 4;\n-    memcpy(xml, filename, len);\n-    xml[len] = 0;\n-    if (snprintf(result, 499, \"result\/pattern\/%s\", baseFilename(xml)) >= 499)\n-        result[499] = 0;\n-    memcpy(xml + len, \".xml\", 5);\n-\n-    if (!checkTestFile(xml) && !update_results) {\n-    fprintf(stderr, \"Missing xml file %s\\n\", xml);\n-    return(-1);\n-    }\n-    f = fopen(filename, \"rb\");\n-    if (f == NULL) {\n-        fprintf(stderr, \"Failed to open %s\\n\", filename);\n-    return(-1);\n-    }\n-    temp = resultFilename(filename, temp_directory, \".res\");\n-    if (temp == NULL) {\n-        fprintf(stderr, \"Out of memory\\n\");\n-        fatalError();\n-    }\n-    o = fopen(temp, \"wb\");\n-    if (o == NULL) {\n-    fprintf(stderr, \"failed to open output file %s\\n\", temp);\n-    fclose(f);\n-        free(temp);\n-    return(-1);\n-    }\n-    while (1) {\n-    \/*\n-     * read one line in string buffer.\n-     *\/\n-    if (fgets (&str[0], sizeof (str) - 1, f) == NULL)\n-       break;\n-\n-    \/*\n-     * remove the ending spaces\n-     *\/\n-    i = strlen(str);\n-    while ((i > 0) &&\n-           ((str[i - 1] == '\\n') || (str[i - 1] == '\\r') ||\n-        (str[i - 1] == ' ') || (str[i - 1] == '\\t'))) {\n-        i--;\n-        str[i] = 0;\n-    }\n-    doc = xmlReadFile(xml, NULL, options);\n-    if (doc == NULL) {\n-        fprintf(stderr, \"Failed to parse %s\\n\", xml);\n-        ret = 1;\n-    } else {\n-        xmlNodePtr root;\n-        const xmlChar *namespaces[22];\n-        int j;\n-        xmlNsPtr ns;\n-\n-        root = xmlDocGetRootElement(doc);\n-        for (ns = root->nsDef, j = 0;ns != NULL && j < 20;ns=ns->next) {\n-        namespaces[j++] = ns->href;\n-        namespaces[j++] = ns->prefix;\n-        }\n-        namespaces[j++] = NULL;\n-        namespaces[j] = NULL;\n-\n-        patternc = xmlPatterncompile((const xmlChar *) str, doc->dict,\n-                     0, &namespaces[0]);\n-        if (patternc == NULL) {\n-        testErrorHandler(NULL,\n-            \"Pattern %s failed to compile\\n\", str);\n-        xmlFreeDoc(doc);\n-        ret = 1;\n-        continue;\n-        }\n-        patstream = xmlPatternGetStreamCtxt(patternc);\n-        if (patstream != NULL) {\n-        ret = xmlStreamPush(patstream, NULL, NULL);\n-        if (ret < 0) {\n-            fprintf(stderr, \"xmlStreamPush() failure\\n\");\n-            xmlFreeStreamCtxt(patstream);\n-            patstream = NULL;\n-        }\n-        }\n-        nb_tests++;\n-\n-        reader = xmlReaderWalker(doc);\n-        res = xmlTextReaderRead(reader);\n-        while (res == 1) {\n-        patternNode(o, reader, str, patternc, patstream);\n-        res = xmlTextReaderRead(reader);\n-        }\n-        if (res != 0) {\n-        fprintf(o, \"%s : failed to parse\\n\", filename);\n-        }\n-        xmlFreeTextReader(reader);\n-        xmlFreeDoc(doc);\n-        xmlFreeStreamCtxt(patstream);\n-        patstream = NULL;\n-        xmlFreePattern(patternc);\n-\n-    }\n-    }\n-\n-    fclose(f);\n-    fclose(o);\n-\n-    ret = compareFiles(temp, result);\n-    if (ret) {\n-    fprintf(stderr, \"Result for %s failed in %s\\n\", filename, result);\n-    ret = 1;\n-    }\n-    if (temp != NULL) {\n-        unlink(temp);\n-        free(temp);\n-    }\n-    return(ret);\n-}\n-#endif \/* READER *\/\n-#endif \/* PATTERN *\/\n-#ifdef LIBXML_C14N_ENABLED\n-\/************************************************************************\n- *                                    *\n- *            Canonicalization tests                *\n- *                                    *\n- ************************************************************************\/\n-static xmlXPathObjectPtr\n-load_xpath_expr (xmlDocPtr parent_doc, const char* filename) {\n-    xmlXPathObjectPtr xpath;\n-    xmlDocPtr doc;\n-    xmlChar *expr;\n-    xmlXPathContextPtr ctx;\n-    xmlNodePtr node;\n-    xmlNsPtr ns;\n-\n-    \/*\n-     * load XPath expr as a file\n-     *\/\n-    doc = xmlReadFile(filename, NULL, XML_PARSE_DTDATTR | XML_PARSE_NOENT);\n-    if (doc == NULL) {\n-    fprintf(stderr, \"Error: unable to parse file \\\"%s\\\"\\n\", filename);\n-    return(NULL);\n-    }\n-\n-    \/*\n-     * Check the document is of the right kind\n-     *\/\n-    if(xmlDocGetRootElement(doc) == NULL) {\n-        fprintf(stderr,\"Error: empty document for file \\\"%s\\\"\\n\", filename);\n-    xmlFreeDoc(doc);\n-    return(NULL);\n-    }\n-\n-    node = doc->children;\n-    while(node != NULL && !xmlStrEqual(node->name, (const xmlChar *)\"XPath\")) {\n-    node = node->next;\n-    }\n-\n-    if(node == NULL) {\n-        fprintf(stderr,\"Error: XPath element expected in the file  \\\"%s\\\"\\n\", filename);\n-    xmlFreeDoc(doc);\n-    return(NULL);\n-    }\n-\n-    expr = xmlNodeGetContent(node);\n-    if(expr == NULL) {\n-        fprintf(stderr,\"Error: XPath content element is NULL \\\"%s\\\"\\n\", filename);\n-    xmlFreeDoc(doc);\n-    return(NULL);\n-    }\n-\n-    ctx = xmlXPathNewContext(parent_doc);\n-    if(ctx == NULL) {\n-        fprintf(stderr,\"Error: unable to create new context\\n\");\n-        xmlFree(expr);\n-        xmlFreeDoc(doc);\n-        return(NULL);\n-    }\n-\n-    \/*\n-     * Register namespaces\n-     *\/\n-    ns = node->nsDef;\n-    while(ns != NULL) {\n-    if(xmlXPathRegisterNs(ctx, ns->prefix, ns->href) != 0) {\n-        fprintf(stderr,\"Error: unable to register NS with prefix=\\\"%s\\\" and href=\\\"%s\\\"\\n\", ns->prefix, ns->href);\n-    xmlFree(expr);\n-        xmlXPathFreeContext(ctx);\n-        xmlFreeDoc(doc);\n-        return(NULL);\n-    }\n-    ns = ns->next;\n-    }\n-\n-    \/*\n-     * Evaluate xpath\n-     *\/\n-    xpath = xmlXPathEvalExpression(expr, ctx);\n-    if(xpath == NULL) {\n-        fprintf(stderr,\"Error: unable to evaluate xpath expression\\n\");\n-xmlFree(expr);\n-        xmlXPathFreeContext(ctx);\n-        xmlFreeDoc(doc);\n-        return(NULL);\n-    }\n-\n-    \/* print_xpath_nodes(xpath->nodesetval); *\/\n-\n-    xmlFree(expr);\n-    xmlXPathFreeContext(ctx);\n-    xmlFreeDoc(doc);\n-    return(xpath);\n-}\n-\n-\/*\n- * Macro used to grow the current buffer.\n- *\/\n-#define xxx_growBufferReentrant() {                        \\\n-    buffer_size *= 2;                            \\\n-    buffer = (xmlChar **)                        \\\n-    xmlRealloc(buffer, buffer_size * sizeof(xmlChar*));    \\\n-    if (buffer == NULL) {                        \\\n-    perror(\"realloc failed\");                    \\\n-    return(NULL);                            \\\n-    }                                    \\\n-}\n-\n-static xmlChar **\n-parse_list(xmlChar *str) {\n-    xmlChar **buffer;\n-    xmlChar **out = NULL;\n-    int buffer_size = 0;\n-    int len;\n-\n-    if(str == NULL) {\n-    return(NULL);\n-    }\n-\n-    len = xmlStrlen(str);\n-    if((str[0] == '\\'') && (str[len - 1] == '\\'')) {\n-    str[len - 1] = '\\0';\n-    str++;\n-    }\n-    \/*\n-     * allocate an translation buffer.\n-     *\/\n-    buffer_size = 1000;\n-    buffer = (xmlChar **) xmlMalloc(buffer_size * sizeof(xmlChar*));\n-    if (buffer == NULL) {\n-    perror(\"malloc failed\");\n-    return(NULL);\n-    }\n-    out = buffer;\n-\n-    while(*str != '\\0') {\n-    if (out - buffer > buffer_size - 10) {\n-        int indx = out - buffer;\n-\n-        xxx_growBufferReentrant();\n-        out = &buffer[indx];\n-    }\n-    (*out++) = str;\n-    while(*str != ',' && *str != '\\0') ++str;\n-    if(*str == ',') *(str++) = '\\0';\n-    }\n-    (*out) = NULL;\n-    return buffer;\n-}\n-\n-static int\n-c14nRunTest(const char* xml_filename, int with_comments, int mode,\n-        const char* xpath_filename, const char *ns_filename,\n-        const char* result_file) {\n-    xmlDocPtr doc;\n-    xmlXPathObjectPtr xpath = NULL;\n-    xmlChar *result = NULL;\n-    int ret;\n-    xmlChar **inclusive_namespaces = NULL;\n-    const char *nslist = NULL;\n-    int nssize;\n-\n-\n-    \/*\n-     * build an XML tree from a the file; we need to add default\n-     * attributes and resolve all character and entities references\n-     *\/\n-    doc = xmlReadFile(xml_filename, NULL,\n-            XML_PARSE_DTDATTR | XML_PARSE_NOENT | XML_PARSE_NOWARNING);\n-    if (doc == NULL) {\n-    fprintf(stderr, \"Error: unable to parse file \\\"%s\\\"\\n\", xml_filename);\n-    return(-1);\n-    }\n-\n-    \/*\n-     * Check the document is of the right kind\n-     *\/\n-    if(xmlDocGetRootElement(doc) == NULL) {\n-        fprintf(stderr,\"Error: empty document for file \\\"%s\\\"\\n\", xml_filename);\n-    xmlFreeDoc(doc);\n-    return(-1);\n-    }\n-\n-    \/*\n-     * load xpath file if specified\n-     *\/\n-    if(xpath_filename) {\n-    xpath = load_xpath_expr(doc, xpath_filename);\n-    if(xpath == NULL) {\n-        fprintf(stderr,\"Error: unable to evaluate xpath expression\\n\");\n-        xmlFreeDoc(doc);\n-        return(-1);\n-    }\n-    }\n-\n-    if (ns_filename != NULL) {\n-        if (loadMem(ns_filename, &nslist, &nssize)) {\n-        fprintf(stderr,\"Error: unable to evaluate xpath expression\\n\");\n-        if(xpath != NULL) xmlXPathFreeObject(xpath);\n-        xmlFreeDoc(doc);\n-        return(-1);\n-    }\n-        inclusive_namespaces = parse_list((xmlChar *) nslist);\n-    }\n-\n-    \/*\n-     * Canonical form\n-     *\/\n-    \/* fprintf(stderr,\"File \\\"%s\\\" loaded: start canonization\\n\", xml_filename); *\/\n-    ret = xmlC14NDocDumpMemory(doc,\n-        (xpath) ? xpath->nodesetval : NULL,\n-        mode, inclusive_namespaces,\n-        with_comments, &result);\n-    if (ret >= 0) {\n-    if(result != NULL) {\n-        if (compareFileMem(result_file, (const char *) result, ret)) {\n-        fprintf(stderr, \"Result mismatch for %s\\n\", xml_filename);\n-        fprintf(stderr, \"RESULT:\\n%s\\n\", (const char*)result);\n-            ret = -1;\n-        }\n-    }\n-    } else {\n-    fprintf(stderr,\"Error: failed to canonicalize XML file \\\"%s\\\" (ret=%d)\\n\", xml_filename, ret);\n-    ret = -1;\n-    }\n-\n-    \/*\n-     * Cleanup\n-     *\/\n-    if (result != NULL) xmlFree(result);\n-    if(xpath != NULL) xmlXPathFreeObject(xpath);\n-    if (inclusive_namespaces != NULL) xmlFree(inclusive_namespaces);\n-    if (nslist != NULL) free((char *) nslist);\n-    xmlFreeDoc(doc);\n-\n-    return(ret);\n-}\n-\n-static int\n-c14nCommonTest(const char *filename, int with_comments, int mode,\n-               const char *subdir) {\n-    char buf[500];\n-    char prefix[500];\n-    const char *base;\n-    int len;\n-    char *result = NULL;\n-    char *xpath = NULL;\n-    char *ns = NULL;\n-    int ret = 0;\n-\n-    base = baseFilename(filename);\n-    len = strlen(base);\n-    len -= 4;\n-    memcpy(prefix, base, len);\n-    prefix[len] = 0;\n-\n-    if (snprintf(buf, 499, \"result\/c14n\/%s\/%s\", subdir, prefix) >= 499)\n-        buf[499] = 0;\n-    result = strdup(buf);\n-    if (snprintf(buf, 499, \"test\/c14n\/%s\/%s.xpath\", subdir, prefix) >= 499)\n-        buf[499] = 0;\n-    if (checkTestFile(buf)) {\n-    xpath = strdup(buf);\n-    }\n-    if (snprintf(buf, 499, \"test\/c14n\/%s\/%s.ns\", subdir, prefix) >= 499)\n-        buf[499] = 0;\n-    if (checkTestFile(buf)) {\n-    ns = strdup(buf);\n-    }\n-\n-    nb_tests++;\n-    if (c14nRunTest(filename, with_comments, mode,\n-                    xpath, ns, result) < 0)\n-        ret = 1;\n-\n-    if (result != NULL) free(result);\n-    if (xpath != NULL) free(xpath);\n-    if (ns != NULL) free(ns);\n-    return(ret);\n-}\n-\n-static int\n-c14nWithCommentTest(const char *filename,\n-                    const char *resul ATTRIBUTE_UNUSED,\n-            const char *err ATTRIBUTE_UNUSED,\n-            int options ATTRIBUTE_UNUSED) {\n-    return(c14nCommonTest(filename, 1, XML_C14N_1_0, \"with-comments\"));\n-}\n-static int\n-c14nWithoutCommentTest(const char *filename,\n-                    const char *resul ATTRIBUTE_UNUSED,\n-            const char *err ATTRIBUTE_UNUSED,\n-            int options ATTRIBUTE_UNUSED) {\n-    return(c14nCommonTest(filename, 0, XML_C14N_1_0, \"without-comments\"));\n-}\n-static int\n-c14nExcWithoutCommentTest(const char *filename,\n-                    const char *resul ATTRIBUTE_UNUSED,\n-            const char *err ATTRIBUTE_UNUSED,\n-            int options ATTRIBUTE_UNUSED) {\n-    return(c14nCommonTest(filename, 0, XML_C14N_EXCLUSIVE_1_0, \"exc-without-comments\"));\n-}\n-static int\n-c14n11WithoutCommentTest(const char *filename,\n-                    const char *resul ATTRIBUTE_UNUSED,\n-            const char *err ATTRIBUTE_UNUSED,\n-            int options ATTRIBUTE_UNUSED) {\n-    return(c14nCommonTest(filename, 0, XML_C14N_1_1, \"1-1-without-comments\"));\n-}\n-#endif\n-#if defined(LIBXML_THREAD_ENABLED) && defined(LIBXML_CATALOG_ENABLED)\n-\/************************************************************************\n- *                                    *\n- *            Catalog and threads test            *\n- *                                    *\n- ************************************************************************\/\n-\n-\/*\n- * mostly a cut and paste from testThreads.c\n- *\/\n-#define    MAX_ARGC    20\n-\n-typedef struct {\n-    const char *filename;\n-    int okay;\n-} xmlThreadParams;\n-\n-static const char *catalog = \"test\/threads\/complex.xml\";\n-static xmlThreadParams threadParams[] = {\n-    { \"test\/threads\/abc.xml\", 0 },\n-    { \"test\/threads\/acb.xml\", 0 },\n-    { \"test\/threads\/bac.xml\", 0 },\n-    { \"test\/threads\/bca.xml\", 0 },\n-    { \"test\/threads\/cab.xml\", 0 },\n-    { \"test\/threads\/cba.xml\", 0 },\n-    { \"test\/threads\/invalid.xml\", 0 }\n-};\n-static const unsigned int num_threads = sizeof(threadParams) \/\n-                                        sizeof(threadParams[0]);\n-\n-static void *\n-thread_specific_data(void *private_data)\n-{\n-    xmlDocPtr myDoc;\n-    xmlThreadParams *params = (xmlThreadParams *) private_data;\n-    const char *filename = params->filename;\n-    int okay = 1;\n-\n-#ifdef LIBXML_THREAD_ALLOC_ENABLED\n-    xmlMemSetup(xmlMemFree, xmlMemMalloc, xmlMemRealloc, xmlMemoryStrdup);\n-#endif\n-\n-    myDoc = xmlReadFile(filename, NULL, XML_PARSE_NOENT | XML_PARSE_DTDLOAD);\n-    if (myDoc) {\n-        xmlFreeDoc(myDoc);\n-    } else {\n-        printf(\"parse failed\\n\");\n-        okay = 0;\n-    }\n-    params->okay = okay;\n-    return(NULL);\n-}\n-\n-#if defined(_WIN32)\n-#include <windows.h>\n-#include <string.h>\n-\n-#define TEST_REPEAT_COUNT 500\n-\n-static HANDLE tid[MAX_ARGC];\n-\n-static DWORD WINAPI\n-win32_thread_specific_data(void *private_data)\n-{\n-    thread_specific_data(private_data);\n-    return(0);\n-}\n-\n-static int\n-testThread(void)\n-{\n-    unsigned int i, repeat;\n-    BOOL ret;\n-    int res = 0;\n-\n-    xmlInitParser();\n-    for (repeat = 0; repeat < TEST_REPEAT_COUNT; repeat++) {\n-        xmlLoadCatalog(catalog);\n-        nb_tests++;\n-\n-        for (i = 0; i < num_threads; i++) {\n-            tid[i] = (HANDLE) - 1;\n-        }\n-\n-        for (i = 0; i < num_threads; i++) {\n-            DWORD useless;\n-\n-            tid[i] = CreateThread(NULL, 0,\n-                                  win32_thread_specific_data,\n-                  (void *) &threadParams[i], 0,\n-                                  &useless);\n-            if (tid[i] == NULL) {\n-                fprintf(stderr, \"CreateThread failed\\n\");\n-                return(1);\n-            }\n-        }\n-\n-        if (WaitForMultipleObjects(num_threads, tid, TRUE, INFINITE) ==\n-            WAIT_FAILED) {\n-            fprintf(stderr, \"WaitForMultipleObjects failed\\n\");\n-        return(1);\n-    }\n-\n-        for (i = 0; i < num_threads; i++) {\n-            DWORD exitCode;\n-            ret = GetExitCodeThread(tid[i], &exitCode);\n-            if (ret == 0) {\n-                fprintf(stderr, \"GetExitCodeThread failed\\n\");\n-                return(1);\n-            }\n-            CloseHandle(tid[i]);\n-        }\n-\n-        xmlCatalogCleanup();\n-        for (i = 0; i < num_threads; i++) {\n-            if (threadParams[i].okay == 0) {\n-                fprintf(stderr, \"Thread %d handling %s failed\\n\",\n-                i, threadParams[i].filename);\n-            res = 1;\n-        }\n-        }\n-    }\n-\n-    return (res);\n-}\n-\n-#elif defined HAVE_PTHREAD_H\n-#include <pthread.h>\n-\n-static pthread_t tid[MAX_ARGC];\n-\n-static int\n-testThread(void)\n-{\n-    unsigned int i, repeat;\n-    int ret;\n-    int res = 0;\n-\n-    xmlInitParser();\n-\n-    for (repeat = 0; repeat < 500; repeat++) {\n-        xmlLoadCatalog(catalog);\n-        nb_tests++;\n-\n-        for (i = 0; i < num_threads; i++) {\n-            tid[i] = (pthread_t) - 1;\n-        }\n-\n-        for (i = 0; i < num_threads; i++) {\n-            ret = pthread_create(&tid[i], 0, thread_specific_data,\n-                                 (void *) &threadParams[i]);\n-            if (ret != 0) {\n-                fprintf(stderr, \"pthread_create failed\\n\");\n-                return (1);\n-            }\n-        }\n-        for (i = 0; i < num_threads; i++) {\n-            void *result;\n-            ret = pthread_join(tid[i], &result);\n-            if (ret != 0) {\n-                fprintf(stderr, \"pthread_join failed\\n\");\n-                return (1);\n-            }\n-        }\n-\n-        xmlCatalogCleanup();\n-        for (i = 0; i < num_threads; i++)\n-            if (threadParams[i].okay == 0) {\n-                fprintf(stderr, \"Thread %d handling %s failed\\n\",\n-                        i, threadParams[i].filename);\n-                res = 1;\n-            }\n-    }\n-    return (res);\n-}\n-\n-#else\n-static int\n-testThread(void)\n-{\n-    fprintf(stderr,\n-            \"Specific platform thread support not detected\\n\");\n-    return (-1);\n-}\n-#endif\n-static int\n-threadsTest(const char *filename ATTRIBUTE_UNUSED,\n-        const char *resul ATTRIBUTE_UNUSED,\n-        const char *err ATTRIBUTE_UNUSED,\n-        int options ATTRIBUTE_UNUSED) {\n-    return(testThread());\n-}\n-#endif\n-\n-#if defined(LIBXML_REGEXP_ENABLED)\n-\/************************************************************************\n- *                                    *\n- *            Regexp tests                    *\n- *                                    *\n- ************************************************************************\/\n-\n-static void testRegexp(FILE *output, xmlRegexpPtr comp, const char *value) {\n-    int ret;\n-\n-    ret = xmlRegexpExec(comp, (const xmlChar *) value);\n-    if (ret == 1)\n-    fprintf(output, \"%s: Ok\\n\", value);\n-    else if (ret == 0)\n-    fprintf(output, \"%s: Fail\\n\", value);\n-    else\n-    fprintf(output, \"%s: Error: %d\\n\", value, ret);\n-}\n-\n-static int\n-regexpTest(const char *filename, const char *result, const char *err,\n-       int options ATTRIBUTE_UNUSED) {\n-    xmlRegexpPtr comp = NULL;\n-    FILE *input, *output;\n-    char *temp;\n-    char expression[5000];\n-    int len, ret, res = 0;\n-\n-    \/*\n-     * TODO: Custom error handler for regexp\n-     *\/\n-    xmlSetStructuredErrorFunc(NULL, testStructuredErrorHandler);\n-\n-    nb_tests++;\n-\n-    input = fopen(filename, \"rb\");\n-    if (input == NULL) {\n-        fprintf(stderr,\n-        \"Cannot open %s for reading\\n\", filename);\n-    ret = -1;\n-        goto done;\n-    }\n-    temp = resultFilename(filename, \"\", \".res\");\n-    if (temp == NULL) {\n-        fprintf(stderr, \"Out of memory\\n\");\n-        fatalError();\n-    }\n-    output = fopen(temp, \"wb\");\n-    if (output == NULL) {\n-    fprintf(stderr, \"failed to open output file %s\\n\", temp);\n-        free(temp);\n-    ret = -1;\n-        goto done;\n-    }\n-    while (fgets(expression, 4500, input) != NULL) {\n-    len = strlen(expression);\n-    len--;\n-    while ((len >= 0) &&\n-           ((expression[len] == '\\n') || (expression[len] == '\\t') ||\n-        (expression[len] == '\\r') || (expression[len] == ' '))) len--;\n-    expression[len + 1] = 0;\n-    if (len >= 0) {\n-        if (expression[0] == '#')\n-        continue;\n-        if ((expression[0] == '=') && (expression[1] == '>')) {\n-        char *pattern = &expression[2];\n-\n-        if (comp != NULL) {\n-            xmlRegFreeRegexp(comp);\n-            comp = NULL;\n-        }\n-        fprintf(output, \"Regexp: %s\\n\", pattern) ;\n-        comp = xmlRegexpCompile((const xmlChar *) pattern);\n-        if (comp == NULL) {\n-            fprintf(output, \"   failed to compile\\n\");\n-            break;\n-        }\n-        } else if (comp == NULL) {\n-        fprintf(output, \"Regexp: %s\\n\", expression) ;\n-        comp = xmlRegexpCompile((const xmlChar *) expression);\n-        if (comp == NULL) {\n-            fprintf(output, \"   failed to compile\\n\");\n-            break;\n-        }\n-        } else if (comp != NULL) {\n-        testRegexp(output, comp, expression);\n-        }\n-    }\n-    }\n-    fclose(output);\n-    fclose(input);\n-    if (comp != NULL)\n-    xmlRegFreeRegexp(comp);\n-\n-    ret = compareFiles(temp, result);\n-    if (ret) {\n-        fprintf(stderr, \"Result for %s failed in %s\\n\", filename, result);\n-        res = 1;\n-    }\n-    if (temp != NULL) {\n-        unlink(temp);\n-        free(temp);\n-    }\n-\n-    ret = compareFileMem(err, testErrors, testErrorsSize);\n-    if (ret != 0) {\n-        fprintf(stderr, \"Error for %s failed\\n\", filename);\n-        res = 1;\n-    }\n-\n-done:\n-    xmlSetStructuredErrorFunc(NULL, NULL);\n-\n-    return(res);\n-}\n-\n-#endif \/* LIBXML_REGEXPS_ENABLED *\/\n-\n-#ifdef LIBXML_AUTOMATA_ENABLED\n-\/************************************************************************\n- *                                    *\n- *            Automata tests                    *\n- *                                    *\n- ************************************************************************\/\n-\n-static int scanNumber(char **ptr) {\n-    int ret = 0;\n-    char *cur;\n-\n-    cur = *ptr;\n-    while ((*cur >= '0') && (*cur <= '9')) {\n-    ret = ret * 10 + (*cur - '0');\n-    cur++;\n-    }\n-    *ptr = cur;\n-    return(ret);\n-}\n-\n-static int\n-automataTest(const char *filename, const char *result,\n-             const char *err ATTRIBUTE_UNUSED, int options ATTRIBUTE_UNUSED) {\n-    FILE *input, *output;\n-    char *temp;\n-    char expr[5000];\n-    int len;\n-    int ret;\n-    int i;\n-    int res = 0;\n-    xmlAutomataPtr am;\n-    xmlAutomataStatePtr states[1000];\n-    xmlRegexpPtr regexp = NULL;\n-    xmlRegExecCtxtPtr exec = NULL;\n-\n-    nb_tests++;\n-\n-    for (i = 0;i<1000;i++)\n-    states[i] = NULL;\n-\n-    input = fopen(filename, \"rb\");\n-    if (input == NULL) {\n-        fprintf(stderr,\n-        \"Cannot open %s for reading\\n\", filename);\n-    return(-1);\n-    }\n-    temp = resultFilename(filename, \"\", \".res\");\n-    if (temp == NULL) {\n-        fprintf(stderr, \"Out of memory\\n\");\n-        fatalError();\n-    }\n-    output = fopen(temp, \"wb\");\n-    if (output == NULL) {\n-    fprintf(stderr, \"failed to open output file %s\\n\", temp);\n-        free(temp);\n-    return(-1);\n-    }\n-\n-    am = xmlNewAutomata();\n-    if (am == NULL) {\n-        fprintf(stderr,\n-        \"Cannot create automata\\n\");\n-    fclose(input);\n-    return(-1);\n-    }\n-    states[0] = xmlAutomataGetInitState(am);\n-    if (states[0] == NULL) {\n-        fprintf(stderr,\n-        \"Cannot get start state\\n\");\n-    xmlFreeAutomata(am);\n-    fclose(input);\n-    return(-1);\n-    }\n-    ret = 0;\n-\n-    while (fgets(expr, 4500, input) != NULL) {\n-    if (expr[0] == '#')\n-        continue;\n-    len = strlen(expr);\n-    len--;\n-    while ((len >= 0) &&\n-           ((expr[len] == '\\n') || (expr[len] == '\\t') ||\n-        (expr[len] == '\\r') || (expr[len] == ' '))) len--;\n-    expr[len + 1] = 0;\n-    if (len >= 0) {\n-        if ((am != NULL) && (expr[0] == 't') && (expr[1] == ' ')) {\n-        char *ptr = &expr[2];\n-        int from, to;\n-\n-        from = scanNumber(&ptr);\n-        if (*ptr != ' ') {\n-            fprintf(stderr,\n-                \"Bad line %s\\n\", expr);\n-            break;\n-        }\n-        if (states[from] == NULL)\n-            states[from] = xmlAutomataNewState(am);\n-        ptr++;\n-        to = scanNumber(&ptr);\n-        if (*ptr != ' ') {\n-            fprintf(stderr,\n-                \"Bad line %s\\n\", expr);\n-            break;\n-        }\n-        if (states[to] == NULL)\n-            states[to] = xmlAutomataNewState(am);\n-        ptr++;\n-        xmlAutomataNewTransition(am, states[from], states[to],\n-                             BAD_CAST ptr, NULL);\n-        } else if ((am != NULL) && (expr[0] == 'e') && (expr[1] == ' ')) {\n-        char *ptr = &expr[2];\n-        int from, to;\n-\n-        from = scanNumber(&ptr);\n-        if (*ptr != ' ') {\n-            fprintf(stderr,\n-                \"Bad line %s\\n\", expr);\n-            break;\n-        }\n-        if (states[from] == NULL)\n-            states[from] = xmlAutomataNewState(am);\n-        ptr++;\n-        to = scanNumber(&ptr);\n-        if (states[to] == NULL)\n-            states[to] = xmlAutomataNewState(am);\n-        xmlAutomataNewEpsilon(am, states[from], states[to]);\n-        } else if ((am != NULL) && (expr[0] == 'f') && (expr[1] == ' ')) {\n-        char *ptr = &expr[2];\n-        int state;\n-\n-        state = scanNumber(&ptr);\n-        if (states[state] == NULL) {\n-            fprintf(stderr,\n-                \"Bad state %d : %s\\n\", state, expr);\n-            break;\n-        }\n-        xmlAutomataSetFinalState(am, states[state]);\n-        } else if ((am != NULL) && (expr[0] == 'c') && (expr[1] == ' ')) {\n-        char *ptr = &expr[2];\n-        int from, to;\n-        int min, max;\n-\n-        from = scanNumber(&ptr);\n-        if (*ptr != ' ') {\n-            fprintf(stderr,\n-                \"Bad line %s\\n\", expr);\n-            break;\n-        }\n-        if (states[from] == NULL)\n-            states[from] = xmlAutomataNewState(am);\n-        ptr++;\n-        to = scanNumber(&ptr);\n-        if (*ptr != ' ') {\n-            fprintf(stderr,\n-                \"Bad line %s\\n\", expr);\n-            break;\n-        }\n-        if (states[to] == NULL)\n-            states[to] = xmlAutomataNewState(am);\n-        ptr++;\n-        min = scanNumber(&ptr);\n-        if (*ptr != ' ') {\n-            fprintf(stderr,\n-                \"Bad line %s\\n\", expr);\n-            break;\n-        }\n-        ptr++;\n-        max = scanNumber(&ptr);\n-        if (*ptr != ' ') {\n-            fprintf(stderr,\n-                \"Bad line %s\\n\", expr);\n-            break;\n-        }\n-        ptr++;\n-        xmlAutomataNewCountTrans(am, states[from], states[to],\n-                             BAD_CAST ptr, min, max, NULL);\n-        } else if ((am != NULL) && (expr[0] == '-') && (expr[1] == '-')) {\n-        \/* end of the automata *\/\n-        regexp = xmlAutomataCompile(am);\n-        xmlFreeAutomata(am);\n-        am = NULL;\n-        if (regexp == NULL) {\n-            fprintf(stderr,\n-                \"Failed to compile the automata\");\n-            break;\n-        }\n-        } else if ((expr[0] == '=') && (expr[1] == '>')) {\n-        if (regexp == NULL) {\n-            fprintf(output, \"=> failed not compiled\\n\");\n-        } else {\n-            if (exec == NULL)\n-            exec = xmlRegNewExecCtxt(regexp, NULL, NULL);\n-            if (ret == 0) {\n-            ret = xmlRegExecPushString(exec, NULL, NULL);\n-            }\n-            if (ret == 1)\n-            fprintf(output, \"=> Passed\\n\");\n-            else if ((ret == 0) || (ret == -1))\n-            fprintf(output, \"=> Failed\\n\");\n-            else if (ret < 0)\n-            fprintf(output, \"=> Error\\n\");\n-            xmlRegFreeExecCtxt(exec);\n-            exec = NULL;\n-        }\n-        ret = 0;\n-        } else if (regexp != NULL) {\n-        if (exec == NULL)\n-            exec = xmlRegNewExecCtxt(regexp, NULL, NULL);\n-        ret = xmlRegExecPushString(exec, BAD_CAST expr, NULL);\n-        } else {\n-        fprintf(stderr,\n-            \"Unexpected line %s\\n\", expr);\n-        }\n-    }\n-    }\n-    fclose(output);\n-    fclose(input);\n-    if (regexp != NULL)\n-    xmlRegFreeRegexp(regexp);\n-    if (exec != NULL)\n-    xmlRegFreeExecCtxt(exec);\n-    if (am != NULL)\n-    xmlFreeAutomata(am);\n-\n-    ret = compareFiles(temp, result);\n-    if (ret) {\n-        fprintf(stderr, \"Result for %s failed in %s\\n\", filename, result);\n-        res = 1;\n-    }\n-    if (temp != NULL) {\n-        unlink(temp);\n-        free(temp);\n-    }\n-\n-    return(res);\n-}\n-\n-#endif \/* LIBXML_AUTOMATA_ENABLED *\/\n-\n-\/************************************************************************\n- *                                    *\n- *            Tests Descriptions                *\n- *                                    *\n- ************************************************************************\/\n-\n-static\n-testDesc testDescriptions[] = {\n-    { \"XML regression tests\" ,\n-      oldParseTest, \".\/test\/*\", \"result\/\", \"\", NULL,\n-      0 },\n-    { \"XML regression tests on memory\" ,\n-      memParseTest, \".\/test\/*\", \"result\/\", \"\", NULL,\n-      0 },\n-    { \"XML entity subst regression tests\" ,\n-      noentParseTest, \".\/test\/*\", \"result\/noent\/\", \"\", NULL,\n-      XML_PARSE_NOENT },\n-    { \"XML Namespaces regression tests\",\n-      errParseTest, \".\/test\/namespaces\/*\", \"result\/namespaces\/\", \"\", \".err\",\n-      0 },\n-#ifdef LIBXML_VALID_ENABLED\n-    { \"Error cases regression tests\",\n-      errParseTest, \".\/test\/errors\/*.xml\", \"result\/errors\/\", \"\", \".err\",\n-      0 },\n-    { \"Error cases regression tests from file descriptor\",\n-      fdParseTest, \".\/test\/errors\/*.xml\", \"result\/errors\/\", \"\", \".err\",\n-      0 },\n-    { \"Error cases regression tests with entity substitution\",\n-      errParseTest, \".\/test\/errors\/*.xml\", \"result\/errors\/\", NULL, \".ent\",\n-      XML_PARSE_NOENT },\n-    { \"Error cases regression tests (old 1.0)\",\n-      errParseTest, \".\/test\/errors10\/*.xml\", \"result\/errors10\/\", \"\", \".err\",\n-      XML_PARSE_OLD10 },\n-#endif\n-#ifdef LIBXML_READER_ENABLED\n-#ifdef LIBXML_VALID_ENABLED\n-    { \"Error cases stream regression tests\",\n-      streamParseTest, \".\/test\/errors\/*.xml\", \"result\/errors\/\", NULL, \".str\",\n-      0 },\n-#endif\n-    { \"Reader regression tests\",\n-      streamParseTest, \".\/test\/*\", \"result\/\", \".rdr\", NULL,\n-      0 },\n-    { \"Reader entities substitution regression tests\",\n-      streamParseTest, \".\/test\/*\", \"result\/\", \".rde\", NULL,\n-      XML_PARSE_NOENT },\n-    { \"Reader on memory regression tests\",\n-      streamMemParseTest, \".\/test\/*\", \"result\/\", \".rdr\", NULL,\n-      0 },\n-    { \"Walker regression tests\",\n-      walkerParseTest, \".\/test\/*\", \"result\/\", \".rdr\", NULL,\n-      0 },\n-#endif\n-#ifdef LIBXML_SAX1_ENABLED\n-    { \"SAX1 callbacks regression tests\" ,\n-      saxParseTest, \".\/test\/*\", \"result\/\", \".sax\", NULL,\n-      XML_PARSE_SAX1 },\n-#endif\n-    { \"SAX2 callbacks regression tests\" ,\n-      saxParseTest, \".\/test\/*\", \"result\/\", \".sax2\", NULL,\n-      0 },\n-    { \"SAX2 callbacks regression tests with entity substitution\" ,\n-      saxParseTest, \".\/test\/*\", \"result\/noent\/\", \".sax2\", NULL,\n-      XML_PARSE_NOENT },\n-#ifdef LIBXML_PUSH_ENABLED\n-    { \"XML push regression tests\" ,\n-      pushParseTest, \".\/test\/*\", \"result\/\", \"\", NULL,\n-      0 },\n-    { \"XML push boundary tests\" ,\n-      pushBoundaryTest, \".\/test\/*\", \"result\/\", \"\", NULL,\n-      0 },\n-#endif\n-#ifdef LIBXML_HTML_ENABLED\n-    { \"HTML regression tests\" ,\n-      errParseTest, \".\/test\/HTML\/*\", \"result\/HTML\/\", \"\", \".err\",\n-      XML_PARSE_HTML },\n-    { \"HTML regression tests from file descriptor\",\n-      fdParseTest, \".\/test\/HTML\/*\", \"result\/HTML\/\", \"\", \".err\",\n-      XML_PARSE_HTML },\n-#ifdef LIBXML_PUSH_ENABLED\n-    { \"Push HTML regression tests\" ,\n-      pushParseTest, \".\/test\/HTML\/*\", \"result\/HTML\/\", \"\", \".err\",\n-      XML_PARSE_HTML },\n-    { \"Push HTML boundary tests\" ,\n-      pushBoundaryTest, \".\/test\/HTML\/*\", \"result\/HTML\/\", \"\", NULL,\n-      XML_PARSE_HTML },\n-#endif\n-    { \"HTML SAX regression tests\" ,\n-      saxParseTest, \".\/test\/HTML\/*\", \"result\/HTML\/\", \".sax\", NULL,\n-      XML_PARSE_HTML },\n-#endif\n-#ifdef LIBXML_VALID_ENABLED\n-    { \"Valid documents regression tests\" ,\n-      errParseTest, \".\/test\/VCM\/*\", NULL, NULL, NULL,\n-      XML_PARSE_DTDVALID },\n-    { \"Validity checking regression tests\" ,\n-      errParseTest, \".\/test\/VC\/*\", \"result\/VC\/\", NULL, \"\",\n-      XML_PARSE_DTDVALID },\n-#ifdef LIBXML_READER_ENABLED\n-    { \"Streaming validity checking regression tests\" ,\n-      streamParseTest, \".\/test\/valid\/*.xml\", \"result\/valid\/\", NULL, \".err.rdr\",\n-      XML_PARSE_DTDVALID },\n-    { \"Streaming validity error checking regression tests\" ,\n-      streamParseTest, \".\/test\/VC\/*\", \"result\/VC\/\", NULL, \".rdr\",\n-      XML_PARSE_DTDVALID },\n-#endif\n-    { \"General documents valid regression tests\" ,\n-      errParseTest, \".\/test\/valid\/*\", \"result\/valid\/\", \"\", \".err\",\n-      XML_PARSE_DTDVALID },\n-#endif\n-#ifdef LIBXML_XINCLUDE_ENABLED\n-    { \"XInclude regression tests\" ,\n-      errParseTest, \".\/test\/XInclude\/docs\/*\", \"result\/XInclude\/\", \"\", \".err\",\n-      XML_PARSE_XINCLUDE },\n-#ifdef LIBXML_READER_ENABLED\n-    { \"XInclude xmlReader regression tests\",\n-      streamParseTest, \".\/test\/XInclude\/docs\/*\", \"result\/XInclude\/\", \".rdr\",\n-      \".err\", XML_PARSE_XINCLUDE },\n-#endif\n-    { \"XInclude regression tests stripping include nodes\" ,\n-      errParseTest, \".\/test\/XInclude\/docs\/*\", \"result\/XInclude\/\", \"\", \".err\",\n-      XML_PARSE_XINCLUDE | XML_PARSE_NOXINCNODE },\n-#ifdef LIBXML_READER_ENABLED\n-    { \"XInclude xmlReader regression tests stripping include nodes\",\n-      streamParseTest, \".\/test\/XInclude\/docs\/*\", \"result\/XInclude\/\", \".rdr\",\n-      \".err\", XML_PARSE_XINCLUDE | XML_PARSE_NOXINCNODE },\n-#endif\n-    { \"XInclude regression tests without reader\",\n-      errParseTest, \".\/test\/XInclude\/without-reader\/*\", \"result\/XInclude\/\", \"\",\n-      \".err\", XML_PARSE_XINCLUDE },\n-#endif\n-#ifdef LIBXML_XPATH_ENABLED\n-#ifdef LIBXML_DEBUG_ENABLED\n-    { \"XPath expressions regression tests\" ,\n-      xpathExprTest, \".\/test\/XPath\/expr\/*\", \"result\/XPath\/expr\/\", \"\", NULL,\n-      0 },\n-    { \"XPath document queries regression tests\" ,\n-      xpathDocTest, \".\/test\/XPath\/docs\/*\", NULL, NULL, NULL,\n-      0 },\n-#ifdef LIBXML_XPTR_ENABLED\n-    { \"XPointer document queries regression tests\" ,\n-      xptrDocTest, \".\/test\/XPath\/docs\/*\", NULL, NULL, NULL,\n-      -1 },\n-#endif\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    { \"XPointer xpointer() queries regression tests\" ,\n-      xptrDocTest, \".\/test\/XPath\/docs\/*\", NULL, NULL, NULL,\n-      0 },\n-#endif\n-#ifdef LIBXML_VALID_ENABLED\n-    { \"xml:id regression tests\" ,\n-      xmlidDocTest, \".\/test\/xmlid\/*\", \"result\/xmlid\/\", \"\", \".err\",\n-      0 },\n-#endif\n-#endif\n-#endif\n-    { \"URI parsing tests\" ,\n-      uriParseTest, \".\/test\/URI\/*.uri\", \"result\/URI\/\", \"\", NULL,\n-      0 },\n-    { \"URI base composition tests\" ,\n-      uriBaseTest, \".\/test\/URI\/*.data\", \"result\/URI\/\", \"\", NULL,\n-      0 },\n-    { \"Path URI conversion tests\" ,\n-      uriPathTest, NULL, NULL, NULL, NULL,\n-      0 },\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-    { \"Schemas regression tests\" ,\n-      schemasTest, \".\/test\/schemas\/*_*.xsd\", NULL, NULL, NULL,\n-      0 },\n-    { \"Relax-NG regression tests\" ,\n-      rngTest, \".\/test\/relaxng\/*.rng\", NULL, NULL, NULL,\n-      XML_PARSE_DTDATTR | XML_PARSE_NOENT },\n-#ifdef LIBXML_READER_ENABLED\n-    { \"Relax-NG streaming regression tests\" ,\n-      rngStreamTest, \".\/test\/relaxng\/*.rng\", NULL, NULL, NULL,\n-      XML_PARSE_DTDATTR | XML_PARSE_NOENT },\n-#endif\n-#endif\n-#ifdef LIBXML_PATTERN_ENABLED\n-#ifdef LIBXML_READER_ENABLED\n-    { \"Pattern regression tests\" ,\n-      patternTest, \".\/test\/pattern\/*.pat\", \"result\/pattern\/\", NULL, NULL,\n-      0 },\n-#endif\n-#endif\n-#ifdef LIBXML_C14N_ENABLED\n-    { \"C14N with comments regression tests\" ,\n-      c14nWithCommentTest, \".\/test\/c14n\/with-comments\/*.xml\", NULL, NULL, NULL,\n-      0 },\n-    { \"C14N without comments regression tests\" ,\n-      c14nWithoutCommentTest, \".\/test\/c14n\/without-comments\/*.xml\", NULL, NULL, NULL,\n-      0 },\n-    { \"C14N exclusive without comments regression tests\" ,\n-      c14nExcWithoutCommentTest, \".\/test\/c14n\/exc-without-comments\/*.xml\", NULL, NULL, NULL,\n-      0 },\n-    { \"C14N 1.1 without comments regression tests\" ,\n-      c14n11WithoutCommentTest, \".\/test\/c14n\/1-1-without-comments\/*.xml\", NULL, NULL, NULL,\n-      0 },\n-#endif\n-#if defined(LIBXML_THREAD_ENABLED) && defined(LIBXML_CATALOG_ENABLED)\n-    { \"Catalog and Threads regression tests\" ,\n-      threadsTest, NULL, NULL, NULL, NULL,\n-      0 },\n-#endif\n-    { \"SVG parsing regression tests\" ,\n-      oldParseTest, \".\/test\/SVG\/*.xml\", \"result\/SVG\/\", \"\", NULL,\n-      0 },\n-#if defined(LIBXML_REGEXP_ENABLED)\n-    { \"Regexp regression tests\" ,\n-      regexpTest, \".\/test\/regexp\/*\", \"result\/regexp\/\", \"\", \".err\",\n-      0 },\n-#endif\n-#if defined(LIBXML_AUTOMATA_ENABLED)\n-    { \"Automata regression tests\" ,\n-      automataTest, \".\/test\/automata\/*\", \"result\/automata\/\", \"\", NULL,\n-      0 },\n-#endif\n-    {NULL, NULL, NULL, NULL, NULL, NULL, 0}\n-};\n-\n-\/************************************************************************\n- *                                    *\n- *        The main code driving the tests                *\n- *                                    *\n- ************************************************************************\/\n-\n-static int\n-launchTests(testDescPtr tst) {\n-    int res = 0, err = 0;\n-    size_t i;\n-    char *result;\n-    char *error;\n-    int mem;\n-    xmlCharEncodingHandlerPtr ebcdicHandler, ibm1141Handler, eucJpHandler;\n-\n-    ebcdicHandler = xmlGetCharEncodingHandler(XML_CHAR_ENCODING_EBCDIC);\n-    ibm1141Handler = xmlFindCharEncodingHandler(\"IBM-1141\");\n-\n-    \/*\n-     * When decoding EUC-JP, musl doesn't seem to support 0x8F control\n-     * codes.\n-     *\/\n-    eucJpHandler = xmlGetCharEncodingHandler(XML_CHAR_ENCODING_EUC_JP);\n-    if (eucJpHandler != NULL) {\n-        xmlBufferPtr in, out;\n-\n-        in = xmlBufferCreateSize(10);\n-        xmlBufferCCat(in, \"\\x8f\\xe9\\xae\");\n-        out = xmlBufferCreateSize(10);\n-        if (xmlCharEncInFunc(eucJpHandler, out, in) != 3) {\n-            xmlCharEncCloseFunc(eucJpHandler);\n-            eucJpHandler = NULL;\n-        }\n-        xmlBufferFree(out);\n-        xmlBufferFree(in);\n-    }\n-\n-    if (tst == NULL) return(-1);\n-    if (tst->in != NULL) {\n-    glob_t globbuf;\n-\n-    globbuf.gl_offs = 0;\n-    glob(tst->in, GLOB_DOOFFS, NULL, &globbuf);\n-    for (i = 0;i < globbuf.gl_pathc;i++) {\n-        if (!checkTestFile(globbuf.gl_pathv[i]))\n-            continue;\n-            if ((((ebcdicHandler == NULL) || (ibm1141Handler == NULL)) &&\n-                 (strstr(globbuf.gl_pathv[i], \"ebcdic\") != NULL)) ||\n-                ((eucJpHandler == NULL) &&\n-                 (strstr(globbuf.gl_pathv[i], \"icu_parse_test\") != NULL)))\n-                continue;\n-        if (tst->suffix != NULL) {\n-        result = resultFilename(globbuf.gl_pathv[i], tst->out,\n-                    tst->suffix);\n-        if (result == NULL) {\n-            fprintf(stderr, \"Out of memory !\\n\");\n-            fatalError();\n-        }\n-        } else {\n-            result = NULL;\n-        }\n-        if (tst->err != NULL) {\n-        error = resultFilename(globbuf.gl_pathv[i], tst->out,\n-                                tst->err);\n-        if (error == NULL) {\n-            fprintf(stderr, \"Out of memory !\\n\");\n-            fatalError();\n-        }\n-        } else {\n-            error = NULL;\n-        }\n-            mem = xmlMemUsed();\n-            extraMemoryFromResolver = 0;\n-            testErrorsSize = 0;\n-            testErrors[0] = 0;\n-            res = tst->func(globbuf.gl_pathv[i], result, error,\n-                            tst->options | XML_PARSE_COMPACT);\n-            xmlResetLastError();\n-            if (res != 0) {\n-                fprintf(stderr, \"File %s generated an error\\n\",\n-                        globbuf.gl_pathv[i]);\n-                nb_errors++;\n-                err++;\n-            }\n-            else if (xmlMemUsed() != mem) {\n-                if ((xmlMemUsed() != mem) &&\n-                    (extraMemoryFromResolver == 0)) {\n-                    fprintf(stderr, \"File %s leaked %d bytes\\n\",\n-                            globbuf.gl_pathv[i], xmlMemUsed() - mem);\n-                    nb_leaks++;\n-                    err++;\n-                }\n-            }\n-            testErrorsSize = 0;\n-        if (result)\n-        free(result);\n-        if (error)\n-        free(error);\n-    }\n-    globfree(&globbuf);\n-    } else {\n-        testErrorsSize = 0;\n-    testErrors[0] = 0;\n-    extraMemoryFromResolver = 0;\n-        res = tst->func(NULL, NULL, NULL, tst->options);\n-    if (res != 0) {\n-        nb_errors++;\n-        err++;\n-    }\n-    }\n-\n-    xmlCharEncCloseFunc(ebcdicHandler);\n-    xmlCharEncCloseFunc(ibm1141Handler);\n-    xmlCharEncCloseFunc(eucJpHandler);\n-\n-    return(err);\n-}\n-\n-static int verbose = 0;\n-static int tests_quiet = 0;\n-\n-static int\n-runtest(int i) {\n-    int ret = 0, res;\n-    int old_errors, old_tests, old_leaks;\n-\n-    old_errors = nb_errors;\n-    old_tests = nb_tests;\n-    old_leaks = nb_leaks;\n-    if ((tests_quiet == 0) && (testDescriptions[i].desc != NULL))\n-    printf(\"## %s\\n\", testDescriptions[i].desc);\n-    res = launchTests(&testDescriptions[i]);\n-    if (res != 0)\n-    ret++;\n-    if (verbose) {\n-    if ((nb_errors == old_errors) && (nb_leaks == old_leaks))\n-        printf(\"Ran %d tests, no errors\\n\", nb_tests - old_tests);\n-    else\n-        printf(\"Ran %d tests, %d errors, %d leaks\\n\",\n-           nb_tests - old_tests,\n-           nb_errors - old_errors,\n-           nb_leaks - old_leaks);\n-    }\n-    return(ret);\n-}\n-\n-int\n-main(int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED) {\n-    int i, a, ret = 0;\n-    int subset = 0;\n-\n-#if defined(_WIN32)\n-    setvbuf(stdout, NULL, _IONBF, 0);\n-    setvbuf(stderr, NULL, _IONBF, 0);\n-#endif\n-\n-#if defined(_MSC_VER) && _MSC_VER >= 1400 && _MSC_VER < 1900\n-    _set_output_format(_TWO_DIGIT_EXPONENT);\n-#endif\n-\n-    initializeLibxml2();\n-\n-    for (a = 1; a < argc;a++) {\n-        if (!strcmp(argv[a], \"-v\"))\n-        verbose = 1;\n-        else if (!strcmp(argv[a], \"-u\"))\n-        update_results = 1;\n-        else if (!strcmp(argv[a], \"-quiet\"))\n-        tests_quiet = 1;\n-        else if (!strcmp(argv[a], \"--out\"))\n-        temp_directory = argv[++a];\n-    else {\n-        for (i = 0; testDescriptions[i].func != NULL; i++) {\n-            if (strstr(testDescriptions[i].desc, argv[a])) {\n-            ret += runtest(i);\n-            subset++;\n-        }\n-        }\n-    }\n-    }\n-    if (subset == 0) {\n-    for (i = 0; testDescriptions[i].func != NULL; i++) {\n-        ret += runtest(i);\n-    }\n-    }\n-    if ((nb_errors == 0) && (nb_leaks == 0)) {\n-        ret = 0;\n-    printf(\"Total %d tests, no errors\\n\",\n-           nb_tests);\n-    } else {\n-        ret = 1;\n-    printf(\"Total %d tests, %d errors, %d leaks\\n\",\n-           nb_tests, nb_errors, nb_leaks);\n-    }\n-    xmlCleanupParser();\n-\n-    return(ret);\n-}\n-\n-#else \/* ! LIBXML_OUTPUT_ENABLED *\/\n-int\n-main(int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED) {\n-    fprintf(stderr, \"runtest requires output to be enabled in libxml2\\n\");\n-    return(0);\n-}\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/runtest.c","additions":0,"deletions":5129,"binary":false,"changes":5129,"status":"deleted"},{"patch":"@@ -1,609 +0,0 @@\n-\/*\n- * runxmlconf.c: C program to run XML W3C conformance testsuites\n- *\n- * See Copyright for the status of this software.\n- *\n- * daniel@veillard.com\n- *\/\n-\n-#include \"config.h\"\n-#include <stdio.h>\n-#include <libxml\/xmlversion.h>\n-\n-#if defined(LIBXML_XPATH_ENABLED) && defined(LIBXML_VALID_ENABLED)\n-\n-#include <string.h>\n-#include <sys\/stat.h>\n-\n-#include <libxml\/parser.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/tree.h>\n-#include <libxml\/uri.h>\n-#include <libxml\/xmlreader.h>\n-\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-\n-#define LOGFILE \"runxmlconf.log\"\n-static FILE *logfile = NULL;\n-static int verbose = 0;\n-\n-#define NB_EXPECTED_ERRORS 15\n-\n-\n-const char *skipped_tests[] = {\n-\/* http:\/\/lists.w3.org\/Archives\/Public\/public-xml-testsuite\/2008Jul\/0000.html *\/\n-    \"rmt-ns10-035\",\n-    NULL\n-};\n-\n-\/************************************************************************\n- *                                    *\n- *        File name and path utilities                *\n- *                                    *\n- ************************************************************************\/\n-\n-static int checkTestFile(const char *filename) {\n-    struct stat buf;\n-\n-    if (stat(filename, &buf) == -1)\n-        return(0);\n-\n-#if defined(_WIN32)\n-    if (!(buf.st_mode & _S_IFREG))\n-        return(0);\n-#else\n-    if (!S_ISREG(buf.st_mode))\n-        return(0);\n-#endif\n-\n-    return(1);\n-}\n-\n-static xmlChar *composeDir(const xmlChar *dir, const xmlChar *path) {\n-    char buf[500];\n-\n-    if (dir == NULL) return(xmlStrdup(path));\n-    if (path == NULL) return(NULL);\n-\n-    snprintf(buf, 500, \"%s\/%s\", (const char *) dir, (const char *) path);\n-    return(xmlStrdup((const xmlChar *) buf));\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Libxml2 specific routines                *\n- *                                    *\n- ************************************************************************\/\n-\n-static int nb_skipped = 0;\n-static int nb_tests = 0;\n-static int nb_errors = 0;\n-static int nb_leaks = 0;\n-\n-\/*\n- * We need to trap calls to the resolver to not account memory for the catalog\n- * and not rely on any external resources.\n- *\/\n-static xmlParserInputPtr\n-testExternalEntityLoader(const char *URL, const char *ID ATTRIBUTE_UNUSED,\n-             xmlParserCtxtPtr ctxt) {\n-    xmlParserInputPtr ret;\n-\n-    ret = xmlNewInputFromFile(ctxt, (const char *) URL);\n-\n-    return(ret);\n-}\n-\n-\/*\n- * Trapping the error messages at the generic level to grab the equivalent of\n- * stderr messages on CLI tools.\n- *\/\n-static char testErrors[32769];\n-static int testErrorsSize = 0;\n-static int nbError = 0;\n-static int nbFatal = 0;\n-\n-static void test_log(const char *msg, ...) {\n-    va_list args;\n-    if (logfile != NULL) {\n-        fprintf(logfile, \"\\n------------\\n\");\n-    va_start(args, msg);\n-    vfprintf(logfile, msg, args);\n-    va_end(args);\n-    fprintf(logfile, \"%s\", testErrors);\n-    testErrorsSize = 0; testErrors[0] = 0;\n-    }\n-    if (verbose) {\n-    va_start(args, msg);\n-    vfprintf(stderr, msg, args);\n-    va_end(args);\n-    }\n-}\n-\n-static void\n-testErrorHandler(void *userData ATTRIBUTE_UNUSED, const xmlError *error) {\n-    int res;\n-\n-    if (testErrorsSize >= 32768)\n-        return;\n-    res = snprintf(&testErrors[testErrorsSize],\n-                    32768 - testErrorsSize,\n-           \"%s:%d: %s\\n\", (error->file ? error->file : \"entity\"),\n-           error->line, error->message);\n-    if (error->level == XML_ERR_FATAL)\n-        nbFatal++;\n-    else if (error->level == XML_ERR_ERROR)\n-        nbError++;\n-    if (testErrorsSize + res >= 32768) {\n-        \/* buffer is full *\/\n-    testErrorsSize = 32768;\n-    testErrors[testErrorsSize] = 0;\n-    } else {\n-        testErrorsSize += res;\n-    }\n-    testErrors[testErrorsSize] = 0;\n-}\n-\n-static xmlXPathContextPtr ctxtXPath;\n-\n-static void\n-initializeLibxml2(void) {\n-    xmlMemSetup(xmlMemFree, xmlMemMalloc, xmlMemRealloc, xmlMemoryStrdup);\n-    xmlInitParser();\n-    xmlSetExternalEntityLoader(testExternalEntityLoader);\n-    ctxtXPath = xmlXPathNewContext(NULL);\n-    \/*\n-    * Deactivate the cache if created; otherwise we have to create\/free it\n-    * for every test, since it will confuse the memory leak detection.\n-    * Note that normally this need not be done, since the cache is not\n-    * created until set explicitly with xmlXPathContextSetCache();\n-    * but for test purposes it is sometimes useful to activate the\n-    * cache by default for the whole library.\n-    *\/\n-    if (ctxtXPath->cache != NULL)\n-    xmlXPathContextSetCache(ctxtXPath, 0, -1, 0);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Run the xmlconf test if found                *\n- *                                    *\n- ************************************************************************\/\n-\n-static int\n-xmlconfTestInvalid(const char *id, const char *filename, int options) {\n-    xmlDocPtr doc;\n-    xmlParserCtxtPtr ctxt;\n-    int ret = 1;\n-\n-    ctxt = xmlNewParserCtxt();\n-    if (ctxt == NULL) {\n-        test_log(\"test %s : %s out of memory\\n\",\n-             id, filename);\n-        return(0);\n-    }\n-    xmlCtxtSetErrorHandler(ctxt, testErrorHandler, NULL);\n-    doc = xmlCtxtReadFile(ctxt, filename, NULL, options);\n-    if (doc == NULL) {\n-        test_log(\"test %s : %s invalid document turned not well-formed too\\n\",\n-             id, filename);\n-    } else {\n-    \/* invalidity should be reported both in the context and in the document *\/\n-        if ((ctxt->valid != 0) || (doc->properties & XML_DOC_DTDVALID)) {\n-        test_log(\"test %s : %s failed to detect invalid document\\n\",\n-             id, filename);\n-        nb_errors++;\n-        ret = 0;\n-    }\n-    xmlFreeDoc(doc);\n-    }\n-    xmlFreeParserCtxt(ctxt);\n-    return(ret);\n-}\n-\n-static int\n-xmlconfTestValid(const char *id, const char *filename, int options) {\n-    xmlDocPtr doc;\n-    xmlParserCtxtPtr ctxt;\n-    int ret = 1;\n-\n-    ctxt = xmlNewParserCtxt();\n-    if (ctxt == NULL) {\n-        test_log(\"test %s : %s out of memory\\n\",\n-             id, filename);\n-        return(0);\n-    }\n-    xmlCtxtSetErrorHandler(ctxt, testErrorHandler, NULL);\n-    doc = xmlCtxtReadFile(ctxt, filename, NULL, options);\n-    if (doc == NULL) {\n-        test_log(\"test %s : %s failed to parse a valid document\\n\",\n-             id, filename);\n-        nb_errors++;\n-    ret = 0;\n-    } else {\n-    \/* validity should be reported both in the context and in the document *\/\n-        if ((ctxt->valid == 0) || ((doc->properties & XML_DOC_DTDVALID) == 0)) {\n-        test_log(\"test %s : %s failed to validate a valid document\\n\",\n-             id, filename);\n-        nb_errors++;\n-        ret = 0;\n-    }\n-    xmlFreeDoc(doc);\n-    }\n-    xmlFreeParserCtxt(ctxt);\n-    return(ret);\n-}\n-\n-static int\n-xmlconfTestNotNSWF(const char *id, const char *filename, int options) {\n-    xmlParserCtxtPtr ctxt;\n-    xmlDocPtr doc;\n-    int ret = 1;\n-\n-    ctxt = xmlNewParserCtxt();\n-    xmlCtxtSetErrorHandler(ctxt, testErrorHandler, NULL);\n-    \/*\n-     * In case of Namespace errors, libxml2 will still parse the document\n-     * but log a Namespace error.\n-     *\/\n-    doc = xmlCtxtReadFile(ctxt, filename, NULL, options);\n-    if (doc == NULL) {\n-        test_log(\"test %s : %s failed to parse the XML\\n\",\n-             id, filename);\n-        nb_errors++;\n-    ret = 0;\n-    } else {\n-        const xmlError *error = xmlGetLastError();\n-\n-    if ((error->code == XML_ERR_OK) ||\n-        (error->domain != XML_FROM_NAMESPACE)) {\n-        test_log(\"test %s : %s failed to detect namespace error\\n\",\n-             id, filename);\n-        nb_errors++;\n-        ret = 0;\n-    }\n-    xmlFreeDoc(doc);\n-    }\n-    xmlFreeParserCtxt(ctxt);\n-    return(ret);\n-}\n-\n-static int\n-xmlconfTestNotWF(const char *id, const char *filename, int options) {\n-    xmlParserCtxtPtr ctxt;\n-    xmlDocPtr doc;\n-    int ret = 1;\n-\n-    ctxt = xmlNewParserCtxt();\n-    xmlCtxtSetErrorHandler(ctxt, testErrorHandler, NULL);\n-    doc = xmlCtxtReadFile(ctxt, filename, NULL, options);\n-    if (doc != NULL) {\n-        test_log(\"test %s : %s failed to detect not well formedness\\n\",\n-             id, filename);\n-        nb_errors++;\n-    xmlFreeDoc(doc);\n-    ret = 0;\n-    }\n-    xmlFreeParserCtxt(ctxt);\n-    return(ret);\n-}\n-\n-static int\n-xmlconfTestItem(xmlDocPtr doc, xmlNodePtr cur) {\n-    int ret = -1;\n-    xmlChar *type = NULL;\n-    xmlChar *filename = NULL;\n-    xmlChar *uri = NULL;\n-    xmlChar *base = NULL;\n-    xmlChar *id = NULL;\n-    xmlChar *rec = NULL;\n-    xmlChar *version = NULL;\n-    xmlChar *entities = NULL;\n-    xmlChar *edition = NULL;\n-    int options = 0;\n-    int nstest = 0;\n-    int mem, final;\n-    int i;\n-\n-    testErrorsSize = 0; testErrors[0] = 0;\n-    nbError = 0;\n-    nbFatal = 0;\n-    id = xmlGetProp(cur, BAD_CAST \"ID\");\n-    if (id == NULL) {\n-        test_log(\"test missing ID, line %ld\\n\", xmlGetLineNo(cur));\n-    goto error;\n-    }\n-    for (i = 0;skipped_tests[i] != NULL;i++) {\n-        if (!strcmp(skipped_tests[i], (char *) id)) {\n-        test_log(\"Skipping test %s from skipped list\\n\", (char *) id);\n-        ret = 0;\n-        nb_skipped++;\n-        goto error;\n-    }\n-    }\n-    type = xmlGetProp(cur, BAD_CAST \"TYPE\");\n-    if (type == NULL) {\n-        test_log(\"test %s missing TYPE\\n\", (char *) id);\n-    goto error;\n-    }\n-    uri = xmlGetProp(cur, BAD_CAST \"URI\");\n-    if (uri == NULL) {\n-        test_log(\"test %s missing URI\\n\", (char *) id);\n-    goto error;\n-    }\n-    base = xmlNodeGetBase(doc, cur);\n-    filename = composeDir(base, uri);\n-    if (!checkTestFile((char *) filename)) {\n-        test_log(\"test %s missing file %s \\n\", id,\n-             (filename ? (char *)filename : \"NULL\"));\n-    goto error;\n-    }\n-\n-    version = xmlGetProp(cur, BAD_CAST \"VERSION\");\n-\n-    entities = xmlGetProp(cur, BAD_CAST \"ENTITIES\");\n-    if (!xmlStrEqual(entities, BAD_CAST \"none\")) {\n-        options |= XML_PARSE_DTDLOAD;\n-        options |= XML_PARSE_NOENT;\n-    }\n-    rec = xmlGetProp(cur, BAD_CAST \"RECOMMENDATION\");\n-    if ((rec == NULL) ||\n-        (xmlStrEqual(rec, BAD_CAST \"XML1.0\")) ||\n-    (xmlStrEqual(rec, BAD_CAST \"XML1.0-errata2e\")) ||\n-    (xmlStrEqual(rec, BAD_CAST \"XML1.0-errata3e\")) ||\n-    (xmlStrEqual(rec, BAD_CAST \"XML1.0-errata4e\"))) {\n-    if ((version != NULL) && (!xmlStrEqual(version, BAD_CAST \"1.0\"))) {\n-        test_log(\"Skipping test %s for %s\\n\", (char *) id,\n-                 (char *) version);\n-        ret = 0;\n-        nb_skipped++;\n-        goto error;\n-    }\n-    ret = 1;\n-    } else if ((xmlStrEqual(rec, BAD_CAST \"NS1.0\")) ||\n-           (xmlStrEqual(rec, BAD_CAST \"NS1.0-errata1e\"))) {\n-    ret = 1;\n-    nstest = 1;\n-    } else {\n-        test_log(\"Skipping test %s for REC %s\\n\", (char *) id, (char *) rec);\n-    ret = 0;\n-    nb_skipped++;\n-    goto error;\n-    }\n-    edition = xmlGetProp(cur, BAD_CAST \"EDITION\");\n-    if ((edition != NULL) && (xmlStrchr(edition, '5') == NULL)) {\n-        \/* test limited to all versions before 5th *\/\n-    options |= XML_PARSE_OLD10;\n-    }\n-\n-    \/*\n-     * Reset errors and check memory usage before the test\n-     *\/\n-    xmlResetLastError();\n-    testErrorsSize = 0; testErrors[0] = 0;\n-    mem = xmlMemUsed();\n-\n-    if (xmlStrEqual(type, BAD_CAST \"not-wf\")) {\n-        if (nstest == 0)\n-        xmlconfTestNotWF((char *) id, (char *) filename, options);\n-        else\n-        xmlconfTestNotNSWF((char *) id, (char *) filename, options);\n-    } else if (xmlStrEqual(type, BAD_CAST \"valid\")) {\n-        options |= XML_PARSE_DTDVALID;\n-    xmlconfTestValid((char *) id, (char *) filename, options);\n-    } else if (xmlStrEqual(type, BAD_CAST \"invalid\")) {\n-        options |= XML_PARSE_DTDVALID;\n-    xmlconfTestInvalid((char *) id, (char *) filename, options);\n-    } else if (xmlStrEqual(type, BAD_CAST \"error\")) {\n-        test_log(\"Skipping error test %s \\n\", (char *) id);\n-    ret = 0;\n-    nb_skipped++;\n-    goto error;\n-    } else {\n-        test_log(\"test %s unknown TYPE value %s\\n\", (char *) id, (char *)type);\n-    ret = -1;\n-    goto error;\n-    }\n-\n-    \/*\n-     * Reset errors and check memory usage after the test\n-     *\/\n-    xmlResetLastError();\n-    final = xmlMemUsed();\n-    if (final > mem) {\n-        test_log(\"test %s : %s leaked %d bytes\\n\",\n-             id, filename, final - mem);\n-        nb_leaks++;\n-    }\n-    nb_tests++;\n-\n-error:\n-    if (type != NULL)\n-        xmlFree(type);\n-    if (entities != NULL)\n-        xmlFree(entities);\n-    if (edition != NULL)\n-        xmlFree(edition);\n-    if (version != NULL)\n-        xmlFree(version);\n-    if (filename != NULL)\n-        xmlFree(filename);\n-    if (uri != NULL)\n-        xmlFree(uri);\n-    if (base != NULL)\n-        xmlFree(base);\n-    if (id != NULL)\n-        xmlFree(id);\n-    if (rec != NULL)\n-        xmlFree(rec);\n-    return(ret);\n-}\n-\n-static int\n-xmlconfTestCases(xmlDocPtr doc, xmlNodePtr cur, int level) {\n-    xmlChar *profile;\n-    int ret = 0;\n-    int tests = 0;\n-    int output = 0;\n-\n-    if (level == 1) {\n-    profile = xmlGetProp(cur, BAD_CAST \"PROFILE\");\n-    if (profile != NULL) {\n-        output = 1;\n-        level++;\n-        printf(\"Test cases: %s\\n\", (char *) profile);\n-        xmlFree(profile);\n-    }\n-    }\n-    cur = cur->children;\n-    while (cur != NULL) {\n-        \/* look only at elements we ignore everything else *\/\n-        if (cur->type == XML_ELEMENT_NODE) {\n-        if (xmlStrEqual(cur->name, BAD_CAST \"TESTCASES\")) {\n-            ret += xmlconfTestCases(doc, cur, level);\n-        } else if (xmlStrEqual(cur->name, BAD_CAST \"TEST\")) {\n-            if (xmlconfTestItem(doc, cur) >= 0)\n-            ret++;\n-        tests++;\n-        } else {\n-            fprintf(stderr, \"Unhandled element %s\\n\", (char *)cur->name);\n-        }\n-    }\n-        cur = cur->next;\n-    }\n-    if (output == 1) {\n-    if (tests > 0)\n-        printf(\"Test cases: %d tests\\n\", tests);\n-    }\n-    return(ret);\n-}\n-\n-static int\n-xmlconfTestSuite(xmlDocPtr doc, xmlNodePtr cur) {\n-    xmlChar *profile;\n-    int ret = 0;\n-\n-    profile = xmlGetProp(cur, BAD_CAST \"PROFILE\");\n-    if (profile != NULL) {\n-        printf(\"Test suite: %s\\n\", (char *) profile);\n-    xmlFree(profile);\n-    } else\n-        printf(\"Test suite\\n\");\n-    cur = cur->children;\n-    while (cur != NULL) {\n-        \/* look only at elements we ignore everything else *\/\n-        if (cur->type == XML_ELEMENT_NODE) {\n-        if (xmlStrEqual(cur->name, BAD_CAST \"TESTCASES\")) {\n-            ret += xmlconfTestCases(doc, cur, 1);\n-        } else {\n-            fprintf(stderr, \"Unhandled element %s\\n\", (char *)cur->name);\n-        }\n-    }\n-        cur = cur->next;\n-    }\n-    return(ret);\n-}\n-\n-static void\n-xmlconfInfo(void) {\n-    fprintf(stderr, \"  you need to fetch and extract the\\n\");\n-    fprintf(stderr, \"  latest XML Conformance Test Suites\\n\");\n-    fprintf(stderr, \"  http:\/\/www.w3.org\/XML\/Test\/xmlts20080827.tar.gz\\n\");\n-    fprintf(stderr, \"  see http:\/\/www.w3.org\/XML\/Test\/ for information\\n\");\n-}\n-\n-static int\n-xmlconfTest(void) {\n-    const char *confxml = \"xmlconf\/xmlconf.xml\";\n-    xmlDocPtr doc;\n-    xmlNodePtr cur;\n-    int ret = 0;\n-\n-    if (!checkTestFile(confxml)) {\n-        fprintf(stderr, \"%s is missing \\n\", confxml);\n-    xmlconfInfo();\n-    return(-1);\n-    }\n-    doc = xmlReadFile(confxml, NULL, XML_PARSE_NOENT);\n-    if (doc == NULL) {\n-        fprintf(stderr, \"%s is corrupted \\n\", confxml);\n-    xmlconfInfo();\n-    return(-1);\n-    }\n-\n-    cur = xmlDocGetRootElement(doc);\n-    if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST \"TESTSUITE\"))) {\n-        fprintf(stderr, \"Unexpected format %s\\n\", confxml);\n-    xmlconfInfo();\n-    ret = -1;\n-    } else {\n-        ret = xmlconfTestSuite(doc, cur);\n-    }\n-    xmlFreeDoc(doc);\n-    return(ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        The driver for the tests                *\n- *                                    *\n- ************************************************************************\/\n-\n-int\n-main(int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED) {\n-    int ret = 0;\n-    int old_errors, old_tests, old_leaks;\n-\n-    logfile = fopen(LOGFILE, \"w\");\n-    if (logfile == NULL) {\n-        fprintf(stderr,\n-            \"Could not open the log file, running in verbose mode\\n\");\n-    verbose = 1;\n-    }\n-    initializeLibxml2();\n-\n-    if ((argc >= 2) && (!strcmp(argv[1], \"-v\")))\n-        verbose = 1;\n-\n-\n-    old_errors = nb_errors;\n-    old_tests = nb_tests;\n-    old_leaks = nb_leaks;\n-    xmlconfTest();\n-    if ((nb_errors == old_errors) && (nb_leaks == old_leaks))\n-    printf(\"Ran %d tests, no errors\\n\", nb_tests - old_tests);\n-    else\n-    printf(\"Ran %d tests, %d errors, %d leaks\\n\",\n-           nb_tests - old_tests,\n-           nb_errors - old_errors,\n-           nb_leaks - old_leaks);\n-    if ((nb_errors == 0) && (nb_leaks == 0)) {\n-        ret = 0;\n-    printf(\"Total %d tests, no errors\\n\",\n-           nb_tests);\n-    } else {\n-    ret = 1;\n-    printf(\"Total %d tests, %d errors, %d leaks\\n\",\n-           nb_tests, nb_errors, nb_leaks);\n-    printf(\"See %s for detailed output\\n\", LOGFILE);\n-    if ((nb_leaks == 0) && (nb_errors == NB_EXPECTED_ERRORS)) {\n-        printf(\"%d errors were expected\\n\", nb_errors);\n-        ret = 0;\n-    }\n-    }\n-    xmlXPathFreeContext(ctxtXPath);\n-    xmlCleanupParser();\n-\n-    if (logfile != NULL)\n-        fclose(logfile);\n-    return(ret);\n-}\n-\n-#else \/* ! LIBXML_XPATH_ENABLED *\/\n-int\n-main(int argc ATTRIBUTE_UNUSED, char **argv) {\n-    fprintf(stderr, \"%s need XPath and validation support\\n\", argv[0]);\n-    return(0);\n-}\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/runxmlconf.c","additions":0,"deletions":609,"binary":false,"changes":609,"status":"deleted"},{"patch":"@@ -5861,2 +5861,3 @@\n- * Merge the second text node into the first. The second node is\n- * unlinked and freed.\n+ * Merge the second text node into the first. If @first is NULL,\n+ * @second is returned. Otherwise, the second node is unlinked and\n+ * freed.\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/tree.c","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,2451 +0,0 @@\n-\/*\n- * xinclude.c : Code to implement XInclude processing\n- *\n- * World Wide Web Consortium W3C Last Call Working Draft 10 November 2003\n- * http:\/\/www.w3.org\/TR\/2003\/WD-xinclude-20031110\n- *\n- * See Copyright for the status of this software.\n- *\n- * daniel@veillard.com\n- *\/\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-\n-#include <string.h>\n-#include <libxml\/xmlmemory.h>\n-#include <libxml\/tree.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/uri.h>\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpointer.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/xmlerror.h>\n-#include <libxml\/encoding.h>\n-\n-#ifdef LIBXML_XINCLUDE_ENABLED\n-#include <libxml\/xinclude.h>\n-\n-#include \"private\/buf.h\"\n-#include \"private\/error.h\"\n-#include \"private\/tree.h\"\n-#include \"private\/xinclude.h\"\n-\n-#define XINCLUDE_MAX_DEPTH 40\n-\n-\/************************************************************************\n- *                                    *\n- *            XInclude context handling            *\n- *                                    *\n- ************************************************************************\/\n-\n-\/*\n- * An XInclude context\n- *\/\n-typedef xmlChar *xmlURL;\n-\n-typedef struct _xmlXIncludeRef xmlXIncludeRef;\n-typedef xmlXIncludeRef *xmlXIncludeRefPtr;\n-struct _xmlXIncludeRef {\n-    xmlChar              *URI; \/* the fully resolved resource URL *\/\n-    xmlChar         *fragment; \/* the fragment in the URI *\/\n-    xmlChar             *base; \/* base URI of xi:include element *\/\n-    xmlNodePtr           elem; \/* the xi:include element *\/\n-    xmlNodePtr            inc; \/* the included copy *\/\n-    int                   xml; \/* xml or txt *\/\n-    int                 fallback; \/* fallback was loaded *\/\n-    int            expanding; \/* flag to detect inclusion loops *\/\n-    int              replace; \/* should the node be replaced? *\/\n-};\n-\n-typedef struct _xmlXIncludeDoc xmlXIncludeDoc;\n-typedef xmlXIncludeDoc *xmlXIncludeDocPtr;\n-struct _xmlXIncludeDoc {\n-    xmlDocPtr             doc; \/* the parsed document *\/\n-    xmlChar              *url; \/* the URL *\/\n-    int             expanding; \/* flag to detect inclusion loops *\/\n-};\n-\n-typedef struct _xmlXIncludeTxt xmlXIncludeTxt;\n-typedef xmlXIncludeTxt *xmlXIncludeTxtPtr;\n-struct _xmlXIncludeTxt {\n-    xmlChar        *text; \/* text string *\/\n-    xmlChar              *url; \/* the URL *\/\n-};\n-\n-struct _xmlXIncludeCtxt {\n-    xmlDocPtr             doc; \/* the source document *\/\n-    int                 incNr; \/* number of includes *\/\n-    int                incMax; \/* size of includes tab *\/\n-    xmlXIncludeRefPtr *incTab; \/* array of included references *\/\n-\n-    int                 txtNr; \/* number of unparsed documents *\/\n-    int                txtMax; \/* size of unparsed documents tab *\/\n-    xmlXIncludeTxt    *txtTab; \/* array of unparsed documents *\/\n-\n-    int                 urlNr; \/* number of documents stacked *\/\n-    int                urlMax; \/* size of document stack *\/\n-    xmlXIncludeDoc    *urlTab; \/* document stack *\/\n-\n-    int              nbErrors; \/* the number of errors detected *\/\n-    int              fatalErr; \/* abort processing *\/\n-    int                 errNo; \/* error code *\/\n-    int                legacy; \/* using XINCLUDE_OLD_NS *\/\n-    int            parseFlags; \/* the flags used for parsing XML documents *\/\n-\n-    void            *_private; \/* application data *\/\n-\n-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n-    unsigned long    incTotal; \/* total number of processed inclusions *\/\n-#endif\n-    int            depth; \/* recursion depth *\/\n-    int             isStream; \/* streaming mode *\/\n-\n-    xmlXPathContextPtr xpctxt;\n-\n-    xmlStructuredErrorFunc errorHandler;\n-    void *errorCtxt;\n-};\n-\n-static xmlXIncludeRefPtr\n-xmlXIncludeExpandNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node);\n-\n-static int\n-xmlXIncludeLoadNode(xmlXIncludeCtxtPtr ctxt, xmlXIncludeRefPtr ref);\n-\n-static int\n-xmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlNodePtr tree);\n-\n-\n-\/************************************************************************\n- *                                    *\n- *            XInclude error handler                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlXIncludeErrMemory:\n- * @extra:  extra information\n- *\n- * Handle an out of memory condition\n- *\/\n-static void\n-xmlXIncludeErrMemory(xmlXIncludeCtxtPtr ctxt)\n-{\n-    ctxt->errNo = XML_ERR_NO_MEMORY;\n-    ctxt->fatalErr = 1;\n-    ctxt->nbErrors++;\n-\n-    xmlRaiseMemoryError(ctxt->errorHandler, NULL, ctxt->errorCtxt,\n-                        XML_FROM_XINCLUDE, NULL);\n-}\n-\n-\/**\n- * xmlXIncludeErr:\n- * @ctxt: the XInclude context\n- * @node: the context node\n- * @msg:  the error message\n- * @extra:  extra information\n- *\n- * Handle an XInclude error\n- *\/\n-static void LIBXML_ATTR_FORMAT(4,0)\n-xmlXIncludeErr(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node, int error,\n-               const char *msg, const xmlChar *extra)\n-{\n-    xmlStructuredErrorFunc schannel = NULL;\n-    xmlGenericErrorFunc channel = NULL;\n-    void *data = NULL;\n-    int res;\n-\n-    if (ctxt->fatalErr != 0)\n-        return;\n-    ctxt->nbErrors++;\n-\n-    schannel = ctxt->errorHandler;\n-    data = ctxt->errorCtxt;\n-\n-    if (schannel == NULL) {\n-        channel = xmlGenericError;\n-        data = xmlGenericErrorContext;\n-    }\n-\n-    res = __xmlRaiseError(schannel, channel, data, ctxt, node,\n-                          XML_FROM_XINCLUDE, error, XML_ERR_ERROR,\n-                          NULL, 0, (const char *) extra, NULL, NULL, 0, 0,\n-                  msg, (const char *) extra);\n-    if (res < 0) {\n-        ctxt->errNo = XML_ERR_NO_MEMORY;\n-        ctxt->fatalErr = 1;\n-    } else {\n-        ctxt->errNo = error;\n-    }\n-}\n-\n-\/**\n- * xmlXIncludeGetProp:\n- * @ctxt:  the XInclude context\n- * @cur:  the node\n- * @name:  the attribute name\n- *\n- * Get an XInclude attribute\n- *\n- * Returns the value (to be freed) or NULL if not found\n- *\/\n-static xmlChar *\n-xmlXIncludeGetProp(xmlXIncludeCtxtPtr ctxt, xmlNodePtr cur,\n-                   const xmlChar *name) {\n-    xmlChar *ret;\n-\n-    if (xmlNodeGetAttrValue(cur, name, XINCLUDE_NS, &ret) < 0)\n-        xmlXIncludeErrMemory(ctxt);\n-    if (ret != NULL)\n-        return(ret);\n-\n-    if (ctxt->legacy != 0) {\n-        if (xmlNodeGetAttrValue(cur, name, XINCLUDE_OLD_NS, &ret) < 0)\n-            xmlXIncludeErrMemory(ctxt);\n-        if (ret != NULL)\n-            return(ret);\n-    }\n-\n-    if (xmlNodeGetAttrValue(cur, name, NULL, &ret) < 0)\n-        xmlXIncludeErrMemory(ctxt);\n-    return(ret);\n-}\n-\/**\n- * xmlXIncludeFreeRef:\n- * @ref: the XInclude reference\n- *\n- * Free an XInclude reference\n- *\/\n-static void\n-xmlXIncludeFreeRef(xmlXIncludeRefPtr ref) {\n-    if (ref == NULL)\n-    return;\n-    if (ref->URI != NULL)\n-    xmlFree(ref->URI);\n-    if (ref->fragment != NULL)\n-    xmlFree(ref->fragment);\n-    if (ref->base != NULL)\n-    xmlFree(ref->base);\n-    xmlFree(ref);\n-}\n-\n-\/**\n- * xmlXIncludeNewContext:\n- * @doc:  an XML Document\n- *\n- * Creates a new XInclude context\n- *\n- * Returns the new set\n- *\/\n-xmlXIncludeCtxtPtr\n-xmlXIncludeNewContext(xmlDocPtr doc) {\n-    xmlXIncludeCtxtPtr ret;\n-\n-    if (doc == NULL)\n-    return(NULL);\n-    ret = (xmlXIncludeCtxtPtr) xmlMalloc(sizeof(xmlXIncludeCtxt));\n-    if (ret == NULL)\n-    return(NULL);\n-    memset(ret, 0, sizeof(xmlXIncludeCtxt));\n-    ret->doc = doc;\n-    ret->incNr = 0;\n-    ret->incMax = 0;\n-    ret->incTab = NULL;\n-    ret->nbErrors = 0;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXIncludeFreeContext:\n- * @ctxt: the XInclude context\n- *\n- * Free an XInclude context\n- *\/\n-void\n-xmlXIncludeFreeContext(xmlXIncludeCtxtPtr ctxt) {\n-    int i;\n-\n-    if (ctxt == NULL)\n-    return;\n-    if (ctxt->urlTab != NULL) {\n-    for (i = 0; i < ctxt->urlNr; i++) {\n-        xmlFreeDoc(ctxt->urlTab[i].doc);\n-        xmlFree(ctxt->urlTab[i].url);\n-    }\n-    xmlFree(ctxt->urlTab);\n-    }\n-    for (i = 0;i < ctxt->incNr;i++) {\n-    if (ctxt->incTab[i] != NULL)\n-        xmlXIncludeFreeRef(ctxt->incTab[i]);\n-    }\n-    if (ctxt->incTab != NULL)\n-    xmlFree(ctxt->incTab);\n-    if (ctxt->txtTab != NULL) {\n-    for (i = 0;i < ctxt->txtNr;i++) {\n-        xmlFree(ctxt->txtTab[i].text);\n-        xmlFree(ctxt->txtTab[i].url);\n-    }\n-    xmlFree(ctxt->txtTab);\n-    }\n-    if (ctxt->xpctxt != NULL)\n-    xmlXPathFreeContext(ctxt->xpctxt);\n-    xmlFree(ctxt);\n-}\n-\n-\/**\n- * xmlXIncludeParseFile:\n- * @ctxt:  the XInclude context\n- * @URL:  the URL or file path\n- *\n- * parse a document for XInclude\n- *\/\n-static xmlDocPtr\n-xmlXIncludeParseFile(xmlXIncludeCtxtPtr ctxt, const char *URL) {\n-    xmlDocPtr ret = NULL;\n-    xmlParserCtxtPtr pctxt;\n-    xmlParserInputPtr inputStream;\n-\n-    xmlInitParser();\n-\n-    pctxt = xmlNewParserCtxt();\n-    if (pctxt == NULL) {\n-    xmlXIncludeErrMemory(ctxt);\n-    return(NULL);\n-    }\n-    if (ctxt->errorHandler != NULL)\n-        xmlCtxtSetErrorHandler(pctxt, ctxt->errorHandler, ctxt->errorCtxt);\n-\n-    \/*\n-     * pass in the application data to the parser context.\n-     *\/\n-    pctxt->_private = ctxt->_private;\n-\n-    \/*\n-     * try to ensure that new documents included are actually\n-     * built with the same dictionary as the including document.\n-     *\/\n-    if ((ctxt->doc != NULL) && (ctxt->doc->dict != NULL)) {\n-       if (pctxt->dict != NULL)\n-            xmlDictFree(pctxt->dict);\n-    pctxt->dict = ctxt->doc->dict;\n-    xmlDictReference(pctxt->dict);\n-    }\n-\n-    \/*\n-     * We set DTDLOAD to make sure that ID attributes declared in\n-     * external DTDs are detected.\n-     *\/\n-    xmlCtxtUseOptions(pctxt, ctxt->parseFlags | XML_PARSE_DTDLOAD);\n-\n-    inputStream = xmlLoadExternalEntity(URL, NULL, pctxt);\n-    if (inputStream == NULL)\n-        goto error;\n-\n-    inputPush(pctxt, inputStream);\n-\n-    xmlParseDocument(pctxt);\n-\n-    if (pctxt->wellFormed) {\n-        ret = pctxt->myDoc;\n-    }\n-    else {\n-        ret = NULL;\n-    if (pctxt->myDoc != NULL)\n-        xmlFreeDoc(pctxt->myDoc);\n-        pctxt->myDoc = NULL;\n-    }\n-\n-error:\n-    if (pctxt->errNo == XML_ERR_NO_MEMORY)\n-        xmlXIncludeErrMemory(ctxt);\n-    xmlFreeParserCtxt(pctxt);\n-\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXIncludeAddNode:\n- * @ctxt:  the XInclude context\n- * @cur:  the new node\n- *\n- * Add a new node to process to an XInclude context\n- *\/\n-static xmlXIncludeRefPtr\n-xmlXIncludeAddNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr cur) {\n-    xmlXIncludeRefPtr ref = NULL;\n-    xmlXIncludeRefPtr ret = NULL;\n-    xmlURIPtr uri = NULL;\n-    xmlChar *href = NULL;\n-    xmlChar *parse = NULL;\n-    xmlChar *fragment = NULL;\n-    xmlChar *base = NULL;\n-    xmlChar *tmp;\n-    int xml = 1;\n-    int local = 0;\n-    int res;\n-\n-    if (ctxt == NULL)\n-    return(NULL);\n-    if (cur == NULL)\n-    return(NULL);\n-\n-    \/*\n-     * read the attributes\n-     *\/\n-\n-    fragment = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_PARSE_XPOINTER);\n-\n-    href = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_HREF);\n-    if (href == NULL) {\n-        if (fragment == NULL) {\n-        xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_NO_HREF,\n-                       \"href or xpointer must be present\\n\", parse);\n-        goto error;\n-        }\n-\n-    href = xmlStrdup(BAD_CAST \"\"); \/* @@@@ href is now optional *\/\n-    if (href == NULL) {\n-            xmlXIncludeErrMemory(ctxt);\n-        goto error;\n-        }\n-    }\n-\n-    parse = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_PARSE);\n-    if (parse != NULL) {\n-    if (xmlStrEqual(parse, XINCLUDE_PARSE_XML))\n-        xml = 1;\n-    else if (xmlStrEqual(parse, XINCLUDE_PARSE_TEXT))\n-        xml = 0;\n-    else {\n-        xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_PARSE_VALUE,\n-                       \"invalid value %s for 'parse'\\n\", parse);\n-        goto error;\n-    }\n-    }\n-\n-    \/*\n-     * Check the URL and remove any fragment identifier\n-     *\/\n-    res = xmlParseURISafe((const char *)href, &uri);\n-    if (uri == NULL) {\n-        if (res < 0)\n-            xmlXIncludeErrMemory(ctxt);\n-        else\n-            xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_HREF_URI,\n-                           \"invalid value href %s\\n\", href);\n-        goto error;\n-    }\n-\n-    if (uri->fragment != NULL) {\n-        if (ctxt->legacy != 0) {\n-        if (fragment == NULL) {\n-        fragment = (xmlChar *) uri->fragment;\n-        } else {\n-        xmlFree(uri->fragment);\n-        }\n-    } else {\n-        xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_FRAGMENT_ID,\n-       \"Invalid fragment identifier in URI %s use the xpointer attribute\\n\",\n-                           href);\n-        goto error;\n-    }\n-    uri->fragment = NULL;\n-    }\n-    tmp = xmlSaveUri(uri);\n-    if (tmp == NULL) {\n-    xmlXIncludeErrMemory(ctxt);\n-    goto error;\n-    }\n-    xmlFree(href);\n-    href = tmp;\n-\n-    \/*\n-     * Resolve URI\n-     *\/\n-\n-    if (xmlNodeGetBaseSafe(ctxt->doc, cur, &base) < 0) {\n-        xmlXIncludeErrMemory(ctxt);\n-        goto error;\n-    }\n-\n-    if (href[0] != 0) {\n-        if (xmlBuildURISafe(href, base, &tmp) < 0) {\n-            xmlXIncludeErrMemory(ctxt);\n-            goto error;\n-        }\n-        if (tmp == NULL) {\n-            xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_HREF_URI,\n-                           \"failed build URL\\n\", NULL);\n-            goto error;\n-        }\n-        xmlFree(href);\n-        href = tmp;\n-\n-        if (xmlStrEqual(href, ctxt->doc->URL))\n-            local = 1;\n-    } else {\n-        local = 1;\n-    }\n-\n-    \/*\n-     * If local and xml then we need a fragment\n-     *\/\n-    if ((local == 1) && (xml == 1) &&\n-        ((fragment == NULL) || (fragment[0] == 0))) {\n-    xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_RECURSION,\n-                   \"detected a local recursion with no xpointer in %s\\n\",\n-               href);\n-    goto error;\n-    }\n-\n-    ref = (xmlXIncludeRefPtr) xmlMalloc(sizeof(xmlXIncludeRef));\n-    if (ref == NULL) {\n-        xmlXIncludeErrMemory(ctxt);\n-        goto error;\n-    }\n-    memset(ref, 0, sizeof(xmlXIncludeRef));\n-\n-    ref->elem = cur;\n-    ref->xml = xml;\n-    ref->URI = href;\n-    href = NULL;\n-    ref->fragment = fragment;\n-    fragment = NULL;\n-\n-    \/*\n-     * xml:base fixup\n-     *\/\n-    if (((ctxt->parseFlags & XML_PARSE_NOBASEFIX) == 0) &&\n-        (cur->doc != NULL) &&\n-        ((cur->doc->parseFlags & XML_PARSE_NOBASEFIX) == 0)) {\n-        if (base != NULL) {\n-            ref->base = base;\n-            base = NULL;\n-        } else {\n-            ref->base = xmlStrdup(BAD_CAST \"\");\n-            if (ref->base == NULL) {\n-            xmlXIncludeErrMemory(ctxt);\n-                goto error;\n-            }\n-        }\n-    }\n-\n-    if (ctxt->incNr >= ctxt->incMax) {\n-        xmlXIncludeRefPtr *table;\n-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n-        size_t newSize = ctxt->incMax ? ctxt->incMax * 2 : 1;\n-#else\n-        size_t newSize = ctxt->incMax ? ctxt->incMax * 2 : 4;\n-#endif\n-\n-        table = (xmlXIncludeRefPtr *) xmlRealloc(ctxt->incTab,\n-                 newSize * sizeof(ctxt->incTab[0]));\n-        if (table == NULL) {\n-        xmlXIncludeErrMemory(ctxt);\n-        goto error;\n-    }\n-        ctxt->incTab = table;\n-        ctxt->incMax = newSize;\n-    }\n-    ctxt->incTab[ctxt->incNr++] = ref;\n-\n-    ret = ref;\n-    ref = NULL;\n-\n-error:\n-    xmlXIncludeFreeRef(ref);\n-    xmlFreeURI(uri);\n-    xmlFree(href);\n-    xmlFree(parse);\n-    xmlFree(fragment);\n-    xmlFree(base);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXIncludeRecurseDoc:\n- * @ctxt:  the XInclude context\n- * @doc:  the new document\n- * @url:  the associated URL\n- *\n- * The XInclude recursive nature is handled at this point.\n- *\/\n-static void\n-xmlXIncludeRecurseDoc(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc) {\n-    xmlDocPtr oldDoc;\n-    xmlXIncludeRefPtr *oldIncTab;\n-    int oldIncMax, oldIncNr, oldIsStream;\n-    int i;\n-\n-    oldDoc = ctxt->doc;\n-    oldIncMax = ctxt->incMax;\n-    oldIncNr = ctxt->incNr;\n-    oldIncTab = ctxt->incTab;\n-    oldIsStream = ctxt->isStream;\n-    ctxt->doc = doc;\n-    ctxt->incMax = 0;\n-    ctxt->incNr = 0;\n-    ctxt->incTab = NULL;\n-    ctxt->isStream = 0;\n-\n-    xmlXIncludeDoProcess(ctxt, xmlDocGetRootElement(doc));\n-\n-    if (ctxt->incTab != NULL) {\n-        for (i = 0; i < ctxt->incNr; i++)\n-            xmlXIncludeFreeRef(ctxt->incTab[i]);\n-        xmlFree(ctxt->incTab);\n-    }\n-\n-    ctxt->doc = oldDoc;\n-    ctxt->incMax = oldIncMax;\n-    ctxt->incNr = oldIncNr;\n-    ctxt->incTab = oldIncTab;\n-    ctxt->isStream = oldIsStream;\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Node copy with specific semantic        *\n- *                                    *\n- ************************************************************************\/\n-\n-static void\n-xmlXIncludeBaseFixup(xmlXIncludeCtxtPtr ctxt, xmlNodePtr cur, xmlNodePtr copy,\n-                     const xmlChar *targetBase) {\n-    xmlChar *base = NULL;\n-    xmlChar *relBase = NULL;\n-    xmlNs ns;\n-    int res;\n-\n-    if (cur->type != XML_ELEMENT_NODE)\n-        return;\n-\n-    if (xmlNodeGetBaseSafe(cur->doc, cur, &base) < 0)\n-        xmlXIncludeErrMemory(ctxt);\n-\n-    if ((base != NULL) && !xmlStrEqual(base, targetBase)) {\n-        if (xmlBuildRelativeURISafe(base, targetBase, &relBase) < 0) {\n-            xmlXIncludeErrMemory(ctxt);\n-            goto done;\n-        }\n-        if (relBase == NULL) {\n-            xmlXIncludeErr(ctxt, cur,\n-                    XML_XINCLUDE_HREF_URI,\n-                    \"Building relative URI failed: %s\\n\",\n-                    base);\n-            goto done;\n-        }\n-\n-        \/*\n-         * If the new base doesn't contain a slash, it can be omitted.\n-         *\/\n-        if (xmlStrchr(relBase, '\/') != NULL) {\n-            res = xmlNodeSetBase(copy, relBase);\n-            if (res < 0)\n-                xmlXIncludeErrMemory(ctxt);\n-            goto done;\n-        }\n-    }\n-\n-    \/*\n-     * Delete existing xml:base if bases are equal\n-     *\/\n-    memset(&ns, 0, sizeof(ns));\n-    ns.href = XML_XML_NAMESPACE;\n-    xmlUnsetNsProp(copy, &ns, BAD_CAST \"base\");\n-\n-done:\n-    xmlFree(base);\n-    xmlFree(relBase);\n-}\n-\n-\/**\n- * xmlXIncludeCopyNode:\n- * @ctxt:  the XInclude context\n- * @elem:  the element\n- * @copyChildren:  copy children instead of node if true\n- *\n- * Make a copy of the node while expanding nested XIncludes.\n- *\n- * Returns a node list, not a single node.\n- *\/\n-static xmlNodePtr\n-xmlXIncludeCopyNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr elem,\n-                    int copyChildren, const xmlChar *targetBase) {\n-    xmlNodePtr result = NULL;\n-    xmlNodePtr insertParent = NULL;\n-    xmlNodePtr insertLast = NULL;\n-    xmlNodePtr cur;\n-    xmlNodePtr item;\n-    int depth = 0;\n-\n-    if (copyChildren) {\n-        cur = elem->children;\n-        if (cur == NULL)\n-            return(NULL);\n-    } else {\n-        cur = elem;\n-    }\n-\n-    while (1) {\n-        xmlNodePtr copy = NULL;\n-        int recurse = 0;\n-\n-        if ((cur->type == XML_DOCUMENT_NODE) ||\n-            (cur->type == XML_DTD_NODE)) {\n-            ;\n-        } else if ((cur->type == XML_ELEMENT_NODE) &&\n-                   (cur->ns != NULL) &&\n-                   (xmlStrEqual(cur->name, XINCLUDE_NODE)) &&\n-                   ((xmlStrEqual(cur->ns->href, XINCLUDE_NS)) ||\n-                    (xmlStrEqual(cur->ns->href, XINCLUDE_OLD_NS)))) {\n-            xmlXIncludeRefPtr ref = xmlXIncludeExpandNode(ctxt, cur);\n-\n-            if (ref == NULL)\n-                goto error;\n-            \/*\n-             * TODO: Insert XML_XINCLUDE_START and XML_XINCLUDE_END nodes\n-             *\/\n-            for (item = ref->inc; item != NULL; item = item->next) {\n-                copy = xmlStaticCopyNode(item, ctxt->doc, insertParent, 1);\n-                if (copy == NULL) {\n-                    xmlXIncludeErrMemory(ctxt);\n-                    goto error;\n-                }\n-\n-                if (result == NULL)\n-                    result = copy;\n-                if (insertLast != NULL) {\n-                    insertLast->next = copy;\n-                    copy->prev = insertLast;\n-                } else if (insertParent != NULL) {\n-                    insertParent->children = copy;\n-                }\n-                insertLast = copy;\n-\n-                if ((depth == 0) && (targetBase != NULL))\n-                    xmlXIncludeBaseFixup(ctxt, item, copy, targetBase);\n-            }\n-        } else {\n-            copy = xmlStaticCopyNode(cur, ctxt->doc, insertParent, 2);\n-            if (copy == NULL) {\n-                xmlXIncludeErrMemory(ctxt);\n-                goto error;\n-            }\n-\n-            if (result == NULL)\n-                result = copy;\n-            if (insertLast != NULL) {\n-                insertLast->next = copy;\n-                copy->prev = insertLast;\n-            } else if (insertParent != NULL) {\n-                insertParent->children = copy;\n-            }\n-            insertLast = copy;\n-\n-            if ((depth == 0) && (targetBase != NULL))\n-                xmlXIncludeBaseFixup(ctxt, cur, copy, targetBase);\n-\n-            recurse = (cur->type != XML_ENTITY_REF_NODE) &&\n-                      (cur->children != NULL);\n-        }\n-\n-        if (recurse) {\n-            cur = cur->children;\n-            insertParent = insertLast;\n-            insertLast = NULL;\n-            depth += 1;\n-            continue;\n-        }\n-\n-        if (cur == elem)\n-            return(result);\n-\n-        while (cur->next == NULL) {\n-            if (insertParent != NULL)\n-                insertParent->last = insertLast;\n-            cur = cur->parent;\n-            if (cur == elem)\n-                return(result);\n-            insertLast = insertParent;\n-            insertParent = insertParent->parent;\n-            depth -= 1;\n-        }\n-\n-        cur = cur->next;\n-    }\n-\n-error:\n-    xmlFreeNodeList(result);\n-    return(NULL);\n-}\n-\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-\/**\n- * xmlXIncludeGetNthChild:\n- * @cur:  the node\n- * @no:  the child number\n- *\n- * Returns the @n'th element child of @cur or NULL\n- *\/\n-static xmlNodePtr\n-xmlXIncludeGetNthChild(xmlNodePtr cur, int no) {\n-    int i;\n-    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n-        return(NULL);\n-    cur = cur->children;\n-    for (i = 0;i <= no;cur = cur->next) {\n-    if (cur == NULL)\n-        return(cur);\n-    if ((cur->type == XML_ELEMENT_NODE) ||\n-        (cur->type == XML_DOCUMENT_NODE) ||\n-        (cur->type == XML_HTML_DOCUMENT_NODE)) {\n-        i++;\n-        if (i == no)\n-        break;\n-    }\n-    }\n-    return(cur);\n-}\n-\n-xmlNodePtr xmlXPtrAdvanceNode(xmlNodePtr cur, int *level); \/* in xpointer.c *\/\n-\/**\n- * xmlXIncludeCopyRange:\n- * @ctxt:  the XInclude context\n- * @obj:  the XPointer result from the evaluation.\n- *\n- * Build a node list tree copy of the XPointer result.\n- *\n- * Returns an xmlNodePtr list or NULL.\n- *         The caller has to free the node tree.\n- *\/\n-static xmlNodePtr\n-xmlXIncludeCopyRange(xmlXIncludeCtxtPtr ctxt, xmlXPathObjectPtr range) {\n-    \/* pointers to generated nodes *\/\n-    xmlNodePtr list = NULL, last = NULL, listParent = NULL;\n-    xmlNodePtr tmp, tmp2;\n-    \/* pointers to traversal nodes *\/\n-    xmlNodePtr start, cur, end;\n-    int index1, index2;\n-    int level = 0, lastLevel = 0, endLevel = 0, endFlag = 0;\n-\n-    if ((ctxt == NULL) || (range == NULL))\n-    return(NULL);\n-    if (range->type != XPATH_RANGE)\n-    return(NULL);\n-    start = (xmlNodePtr) range->user;\n-\n-    if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))\n-    return(NULL);\n-    end = range->user2;\n-    if (end == NULL)\n-    return(xmlDocCopyNode(start, ctxt->doc, 1));\n-    if (end->type == XML_NAMESPACE_DECL)\n-        return(NULL);\n-\n-    cur = start;\n-    index1 = range->index;\n-    index2 = range->index2;\n-    \/*\n-     * level is depth of the current node under consideration\n-     * list is the pointer to the root of the output tree\n-     * listParent is a pointer to the parent of output tree (within\n-       the included file) in case we need to add another level\n-     * last is a pointer to the last node added to the output tree\n-     * lastLevel is the depth of last (relative to the root)\n-     *\/\n-    while (cur != NULL) {\n-    \/*\n-     * Check if our output tree needs a parent\n-     *\/\n-    if (level < 0) {\n-        while (level < 0) {\n-            \/* copy must include namespaces and properties *\/\n-            tmp2 = xmlDocCopyNode(listParent, ctxt->doc, 2);\n-            xmlAddChild(tmp2, list);\n-            list = tmp2;\n-            listParent = listParent->parent;\n-            level++;\n-        }\n-        last = list;\n-        lastLevel = 0;\n-    }\n-    \/*\n-     * Check whether we need to change our insertion point\n-     *\/\n-    while (level < lastLevel) {\n-        last = last->parent;\n-        lastLevel --;\n-    }\n-    if (cur == end) {    \/* Are we at the end of the range? *\/\n-        if (cur->type == XML_TEXT_NODE) {\n-        const xmlChar *content = cur->content;\n-        int len;\n-\n-        if (content == NULL) {\n-            tmp = xmlNewDocTextLen(ctxt->doc, NULL, 0);\n-        } else {\n-            len = index2;\n-            if ((cur == start) && (index1 > 1)) {\n-            content += (index1 - 1);\n-            len -= (index1 - 1);\n-            } else {\n-            len = index2;\n-            }\n-            tmp = xmlNewDocTextLen(ctxt->doc, content, len);\n-        }\n-        \/* single sub text node selection *\/\n-        if (list == NULL)\n-            return(tmp);\n-        \/* prune and return full set *\/\n-        if (level == lastLevel)\n-            xmlAddNextSibling(last, tmp);\n-        else\n-            xmlAddChild(last, tmp);\n-        return(list);\n-        } else {    \/* ending node not a text node *\/\n-            endLevel = level;    \/* remember the level of the end node *\/\n-        endFlag = 1;\n-        \/* last node - need to take care of properties + namespaces *\/\n-        tmp = xmlDocCopyNode(cur, ctxt->doc, 2);\n-        if (list == NULL) {\n-            list = tmp;\n-            listParent = cur->parent;\n-            last = tmp;\n-        } else {\n-            if (level == lastLevel)\n-            last = xmlAddNextSibling(last, tmp);\n-            else {\n-            last = xmlAddChild(last, tmp);\n-            lastLevel = level;\n-            }\n-        }\n-\n-        if (index2 > 1) {\n-            end = xmlXIncludeGetNthChild(cur, index2 - 1);\n-            index2 = 0;\n-        }\n-        if ((cur == start) && (index1 > 1)) {\n-            cur = xmlXIncludeGetNthChild(cur, index1 - 1);\n-            index1 = 0;\n-        }  else {\n-            cur = cur->children;\n-        }\n-        level++;    \/* increment level to show change *\/\n-        \/*\n-         * Now gather the remaining nodes from cur to end\n-         *\/\n-        continue;    \/* while *\/\n-        }\n-    } else if (cur == start) {    \/* Not at the end, are we at start? *\/\n-        if ((cur->type == XML_TEXT_NODE) ||\n-        (cur->type == XML_CDATA_SECTION_NODE)) {\n-        const xmlChar *content = cur->content;\n-\n-        if (content == NULL) {\n-            tmp = xmlNewDocTextLen(ctxt->doc, NULL, 0);\n-        } else {\n-            if (index1 > 1) {\n-            content += (index1 - 1);\n-            index1 = 0;\n-            }\n-            tmp = xmlNewDocText(ctxt->doc, content);\n-        }\n-        last = list = tmp;\n-        listParent = cur->parent;\n-        } else {        \/* Not text node *\/\n-            \/*\n-         * start of the range - need to take care of\n-         * properties and namespaces\n-         *\/\n-        tmp = xmlDocCopyNode(cur, ctxt->doc, 2);\n-        list = last = tmp;\n-        listParent = cur->parent;\n-        if (index1 > 1) {    \/* Do we need to position? *\/\n-            cur = xmlXIncludeGetNthChild(cur, index1 - 1);\n-            level = lastLevel = 1;\n-            index1 = 0;\n-            \/*\n-             * Now gather the remaining nodes from cur to end\n-             *\/\n-            continue; \/* while *\/\n-        }\n-        }\n-    } else {\n-        tmp = NULL;\n-        switch (cur->type) {\n-        case XML_DTD_NODE:\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_ENTITY_NODE:\n-            \/* Do not copy DTD information *\/\n-            break;\n-        case XML_ENTITY_DECL:\n-            \/* handle crossing entities -> stack needed *\/\n-            break;\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-            \/* don't consider it part of the tree content *\/\n-            break;\n-        case XML_ATTRIBUTE_NODE:\n-            \/* Humm, should not happen ! *\/\n-            break;\n-        default:\n-            \/*\n-             * Middle of the range - need to take care of\n-             * properties and namespaces\n-             *\/\n-            tmp = xmlDocCopyNode(cur, ctxt->doc, 2);\n-            break;\n-        }\n-        if (tmp != NULL) {\n-        if (level == lastLevel)\n-            last = xmlAddNextSibling(last, tmp);\n-        else {\n-            last = xmlAddChild(last, tmp);\n-            lastLevel = level;\n-        }\n-        }\n-    }\n-    \/*\n-     * Skip to next node in document order\n-     *\/\n-    cur = xmlXPtrAdvanceNode(cur, &level);\n-    if (endFlag && (level >= endLevel))\n-        break;\n-    }\n-    return(list);\n-}\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-\n-#ifdef LIBXML_XPTR_ENABLED\n-\/**\n- * xmlXIncludeCopyXPointer:\n- * @ctxt:  the XInclude context\n- * @obj:  the XPointer result from the evaluation.\n- *\n- * Build a node list tree copy of the XPointer result.\n- * This will drop Attributes and Namespace declarations.\n- *\n- * Returns an xmlNodePtr list or NULL.\n- *         the caller has to free the node tree.\n- *\/\n-static xmlNodePtr\n-xmlXIncludeCopyXPointer(xmlXIncludeCtxtPtr ctxt, xmlXPathObjectPtr obj,\n-                        const xmlChar *targetBase) {\n-    xmlNodePtr list = NULL, last = NULL, copy;\n-    int i;\n-\n-    if ((ctxt == NULL) || (obj == NULL))\n-    return(NULL);\n-    switch (obj->type) {\n-        case XPATH_NODESET: {\n-        xmlNodeSetPtr set = obj->nodesetval;\n-        if (set == NULL)\n-        break;\n-        for (i = 0;i < set->nodeNr;i++) {\n-                xmlNodePtr node;\n-\n-        if (set->nodeTab[i] == NULL)\n-            continue;\n-        switch (set->nodeTab[i]->type) {\n-            case XML_DOCUMENT_NODE:\n-            case XML_HTML_DOCUMENT_NODE:\n-                        node = xmlDocGetRootElement(\n-                                (xmlDocPtr) set->nodeTab[i]);\n-                        if (node == NULL) {\n-                            xmlXIncludeErr(ctxt, set->nodeTab[i],\n-                                           XML_ERR_INTERNAL_ERROR,\n-                                          \"document without root\\n\", NULL);\n-                            continue;\n-                        }\n-                        break;\n-                    case XML_TEXT_NODE:\n-            case XML_CDATA_SECTION_NODE:\n-            case XML_ELEMENT_NODE:\n-            case XML_PI_NODE:\n-            case XML_COMMENT_NODE:\n-                        node = set->nodeTab[i];\n-            break;\n-                    default:\n-                        xmlXIncludeErr(ctxt, set->nodeTab[i],\n-                                       XML_XINCLUDE_XPTR_RESULT,\n-                                       \"invalid node type in XPtr result\\n\",\n-                                       NULL);\n-            continue; \/* for *\/\n-        }\n-                \/*\n-                 * OPTIMIZE TODO: External documents should already be\n-                 * expanded, so xmlDocCopyNode should work as well.\n-                 * xmlXIncludeCopyNode is only required for the initial\n-                 * document.\n-                 *\/\n-        copy = xmlXIncludeCopyNode(ctxt, node, 0, targetBase);\n-                if (copy == NULL) {\n-                    xmlFreeNodeList(list);\n-                    return(NULL);\n-                }\n-        if (last == NULL) {\n-                    list = copy;\n-                } else {\n-                    while (last->next != NULL)\n-                        last = last->next;\n-                    copy->prev = last;\n-                    last->next = copy;\n-        }\n-                last = copy;\n-        }\n-        break;\n-    }\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    case XPATH_LOCATIONSET: {\n-        xmlLocationSetPtr set = (xmlLocationSetPtr) obj->user;\n-        if (set == NULL)\n-        return(NULL);\n-        for (i = 0;i < set->locNr;i++) {\n-        if (last == NULL)\n-            list = last = xmlXIncludeCopyXPointer(ctxt,\n-                                              set->locTab[i],\n-                                                          targetBase);\n-        else\n-            xmlAddNextSibling(last,\n-                xmlXIncludeCopyXPointer(ctxt, set->locTab[i],\n-                                                    targetBase));\n-        if (last != NULL) {\n-            while (last->next != NULL)\n-            last = last->next;\n-        }\n-        }\n-        break;\n-    }\n-    case XPATH_RANGE:\n-        return(xmlXIncludeCopyRange(ctxt, obj));\n-    case XPATH_POINT:\n-        \/* points are ignored in XInclude *\/\n-        break;\n-#endif\n-    default:\n-        break;\n-    }\n-    return(list);\n-}\n-#endif\n-\n-\/************************************************************************\n- *                                    *\n- *            XInclude I\/O handling                *\n- *                                    *\n- ************************************************************************\/\n-\n-typedef struct _xmlXIncludeMergeData xmlXIncludeMergeData;\n-typedef xmlXIncludeMergeData *xmlXIncludeMergeDataPtr;\n-struct _xmlXIncludeMergeData {\n-    xmlDocPtr doc;\n-    xmlXIncludeCtxtPtr ctxt;\n-};\n-\n-\/**\n- * xmlXIncludeMergeOneEntity:\n- * @ent: the entity\n- * @doc:  the including doc\n- * @name: the entity name\n- *\n- * Implements the merge of one entity\n- *\/\n-static void\n-xmlXIncludeMergeEntity(void *payload, void *vdata,\n-                   const xmlChar *name ATTRIBUTE_UNUSED) {\n-    xmlEntityPtr ent = (xmlEntityPtr) payload;\n-    xmlXIncludeMergeDataPtr data = (xmlXIncludeMergeDataPtr) vdata;\n-    xmlEntityPtr ret, prev;\n-    xmlDocPtr doc;\n-    xmlXIncludeCtxtPtr ctxt;\n-\n-    if ((ent == NULL) || (data == NULL))\n-    return;\n-    ctxt = data->ctxt;\n-    doc = data->doc;\n-    if ((ctxt == NULL) || (doc == NULL))\n-    return;\n-    switch (ent->etype) {\n-        case XML_INTERNAL_PARAMETER_ENTITY:\n-        case XML_EXTERNAL_PARAMETER_ENTITY:\n-        case XML_INTERNAL_PREDEFINED_ENTITY:\n-        return;\n-        case XML_INTERNAL_GENERAL_ENTITY:\n-        case XML_EXTERNAL_GENERAL_PARSED_ENTITY:\n-        case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:\n-        break;\n-    }\n-    prev = xmlGetDocEntity(doc, ent->name);\n-    if (prev == NULL) {\n-        ret = xmlAddDocEntity(doc, ent->name, ent->etype, ent->ExternalID,\n-                              ent->SystemID, ent->content);\n-        if (ret == NULL) {\n-            xmlXIncludeErrMemory(ctxt);\n-            return;\n-        }\n-    if (ent->URI != NULL) {\n-        ret->URI = xmlStrdup(ent->URI);\n-            if (ret->URI == 0)\n-                xmlXIncludeErrMemory(ctxt);\n-        }\n-    } else {\n-        if (ent->etype != prev->etype)\n-            goto error;\n-\n-        if ((ent->SystemID != NULL) && (prev->SystemID != NULL)) {\n-            if (!xmlStrEqual(ent->SystemID, prev->SystemID))\n-                goto error;\n-        } else if ((ent->ExternalID != NULL) &&\n-                   (prev->ExternalID != NULL)) {\n-            if (!xmlStrEqual(ent->ExternalID, prev->ExternalID))\n-                goto error;\n-        } else if ((ent->content != NULL) && (prev->content != NULL)) {\n-            if (!xmlStrEqual(ent->content, prev->content))\n-                goto error;\n-        } else {\n-            goto error;\n-        }\n-    }\n-    return;\n-error:\n-    switch (ent->etype) {\n-        case XML_INTERNAL_PARAMETER_ENTITY:\n-        case XML_EXTERNAL_PARAMETER_ENTITY:\n-        case XML_INTERNAL_PREDEFINED_ENTITY:\n-        case XML_INTERNAL_GENERAL_ENTITY:\n-        case XML_EXTERNAL_GENERAL_PARSED_ENTITY:\n-        return;\n-        case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:\n-        break;\n-    }\n-    xmlXIncludeErr(ctxt, (xmlNodePtr) ent, XML_XINCLUDE_ENTITY_DEF_MISMATCH,\n-                   \"mismatch in redefinition of entity %s\\n\",\n-           ent->name);\n-}\n-\n-\/**\n- * xmlXIncludeMergeEntities:\n- * @ctxt: an XInclude context\n- * @doc:  the including doc\n- * @from:  the included doc\n- *\n- * Implements the entity merge\n- *\n- * Returns 0 if merge succeeded, -1 if some processing failed\n- *\/\n-static int\n-xmlXIncludeMergeEntities(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc,\n-                     xmlDocPtr from) {\n-    xmlNodePtr cur;\n-    xmlDtdPtr target, source;\n-\n-    if (ctxt == NULL)\n-    return(-1);\n-\n-    if ((from == NULL) || (from->intSubset == NULL))\n-    return(0);\n-\n-    target = doc->intSubset;\n-    if (target == NULL) {\n-    cur = xmlDocGetRootElement(doc);\n-    if (cur == NULL)\n-        return(-1);\n-        target = xmlCreateIntSubset(doc, cur->name, NULL, NULL);\n-    if (target == NULL) {\n-            xmlXIncludeErrMemory(ctxt);\n-        return(-1);\n-        }\n-    }\n-\n-    source = from->intSubset;\n-    if ((source != NULL) && (source->entities != NULL)) {\n-    xmlXIncludeMergeData data;\n-\n-    data.ctxt = ctxt;\n-    data.doc = doc;\n-\n-    xmlHashScan((xmlHashTablePtr) source->entities,\n-            xmlXIncludeMergeEntity, &data);\n-    }\n-    source = from->extSubset;\n-    if ((source != NULL) && (source->entities != NULL)) {\n-    xmlXIncludeMergeData data;\n-\n-    data.ctxt = ctxt;\n-    data.doc = doc;\n-\n-    \/*\n-     * don't duplicate existing stuff when external subsets are the same\n-     *\/\n-    if ((!xmlStrEqual(target->ExternalID, source->ExternalID)) &&\n-        (!xmlStrEqual(target->SystemID, source->SystemID))) {\n-        xmlHashScan((xmlHashTablePtr) source->entities,\n-            xmlXIncludeMergeEntity, &data);\n-    }\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlXIncludeLoadDoc:\n- * @ctxt:  the XInclude context\n- * @url:  the associated URL\n- * @ref:  an XMLXincludeRefPtr\n- *\n- * Load the document, and store the result in the XInclude context\n- *\n- * Returns 0 in case of success, -1 in case of failure\n- *\/\n-static int\n-xmlXIncludeLoadDoc(xmlXIncludeCtxtPtr ctxt, xmlXIncludeRefPtr ref) {\n-    xmlXIncludeDocPtr cache;\n-    xmlDocPtr doc;\n-    const xmlChar *url = ref->URI;\n-    const xmlChar *fragment = ref->fragment;\n-    int i = 0;\n-    int ret = -1;\n-    int cacheNr;\n-#ifdef LIBXML_XPTR_ENABLED\n-    int saveFlags;\n-#endif\n-\n-    \/*\n-     * Handling of references to the local document are done\n-     * directly through ctxt->doc.\n-     *\/\n-    if ((url[0] == 0) || (url[0] == '#') ||\n-    ((ctxt->doc != NULL) && (xmlStrEqual(url, ctxt->doc->URL)))) {\n-    doc = ctxt->doc;\n-        goto loaded;\n-    }\n-\n-    \/*\n-     * Prevent reloading the document twice.\n-     *\/\n-    for (i = 0; i < ctxt->urlNr; i++) {\n-    if (xmlStrEqual(url, ctxt->urlTab[i].url)) {\n-            if (ctxt->urlTab[i].expanding) {\n-                xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_RECURSION,\n-                               \"inclusion loop detected\\n\", NULL);\n-                goto error;\n-            }\n-        doc = ctxt->urlTab[i].doc;\n-            if (doc == NULL)\n-                goto error;\n-        goto loaded;\n-    }\n-    }\n-\n-    \/*\n-     * Load it.\n-     *\/\n-#ifdef LIBXML_XPTR_ENABLED\n-    \/*\n-     * If this is an XPointer evaluation, we want to assure that\n-     * all entities have been resolved prior to processing the\n-     * referenced document\n-     *\/\n-    saveFlags = ctxt->parseFlags;\n-    if (fragment != NULL) {    \/* if this is an XPointer eval *\/\n-    ctxt->parseFlags |= XML_PARSE_NOENT;\n-    }\n-#endif\n-\n-    doc = xmlXIncludeParseFile(ctxt, (const char *)url);\n-#ifdef LIBXML_XPTR_ENABLED\n-    ctxt->parseFlags = saveFlags;\n-#endif\n-\n-    \/* Also cache NULL docs *\/\n-    if (ctxt->urlNr >= ctxt->urlMax) {\n-        xmlXIncludeDoc *tmp;\n-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n-        size_t newSize = ctxt->urlMax ? ctxt->urlMax * 2 : 1;\n-#else\n-        size_t newSize = ctxt->urlMax ? ctxt->urlMax * 2 : 8;\n-#endif\n-\n-        tmp = xmlRealloc(ctxt->urlTab, sizeof(xmlXIncludeDoc) * newSize);\n-        if (tmp == NULL) {\n-            xmlXIncludeErrMemory(ctxt);\n-            xmlFreeDoc(doc);\n-            goto error;\n-        }\n-        ctxt->urlMax = newSize;\n-        ctxt->urlTab = tmp;\n-    }\n-    cache = &ctxt->urlTab[ctxt->urlNr];\n-    cache->doc = doc;\n-    cache->url = xmlStrdup(url);\n-    if (cache->url == NULL) {\n-        xmlXIncludeErrMemory(ctxt);\n-        xmlFreeDoc(doc);\n-        goto error;\n-    }\n-    cache->expanding = 0;\n-    cacheNr = ctxt->urlNr++;\n-\n-    if (doc == NULL)\n-        goto error;\n-    \/*\n-     * It's possible that the requested URL has been mapped to a\n-     * completely different location (e.g. through a catalog entry).\n-     * To check for this, we compare the URL with that of the doc\n-     * and change it if they disagree (bug 146988).\n-     *\/\n-    if ((doc->URL != NULL) && (!xmlStrEqual(url, doc->URL)))\n-        url = doc->URL;\n-\n-    \/*\n-     * Make sure we have all entities fixed up\n-     *\/\n-    xmlXIncludeMergeEntities(ctxt, ctxt->doc, doc);\n-\n-    \/*\n-     * We don't need the DTD anymore, free up space\n-    if (doc->intSubset != NULL) {\n-    xmlUnlinkNode((xmlNodePtr) doc->intSubset);\n-    xmlFreeNode((xmlNodePtr) doc->intSubset);\n-    doc->intSubset = NULL;\n-    }\n-    if (doc->extSubset != NULL) {\n-    xmlUnlinkNode((xmlNodePtr) doc->extSubset);\n-    xmlFreeNode((xmlNodePtr) doc->extSubset);\n-    doc->extSubset = NULL;\n-    }\n-     *\/\n-    cache->expanding = 1;\n-    xmlXIncludeRecurseDoc(ctxt, doc);\n-    \/* urlTab might be reallocated. *\/\n-    cache = &ctxt->urlTab[cacheNr];\n-    cache->expanding = 0;\n-\n-loaded:\n-    if (fragment == NULL) {\n-        xmlNodePtr root;\n-\n-        root = xmlDocGetRootElement(doc);\n-        if (root == NULL) {\n-            xmlXIncludeErr(ctxt, ref->elem, XML_ERR_INTERNAL_ERROR,\n-                           \"document without root\\n\", NULL);\n-            goto error;\n-        }\n-\n-        ref->inc = xmlDocCopyNode(root, ctxt->doc, 1);\n-        if (ref->inc == NULL) {\n-            xmlXIncludeErrMemory(ctxt);\n-            goto error;\n-        }\n-\n-        if (ref->base != NULL)\n-            xmlXIncludeBaseFixup(ctxt, root, ref->inc, ref->base);\n-    }\n-#ifdef LIBXML_XPTR_ENABLED\n-    else {\n-    \/*\n-     * Computes the XPointer expression and make a copy used\n-     * as the replacement copy.\n-     *\/\n-    xmlXPathObjectPtr xptr;\n-    xmlNodeSetPtr set;\n-\n-        if (ctxt->isStream && doc == ctxt->doc) {\n-        xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_XPTR_FAILED,\n-               \"XPointer expressions not allowed in streaming\"\n-                           \" mode\\n\", NULL);\n-            goto error;\n-        }\n-\n-        if (ctxt->xpctxt == NULL) {\n-            ctxt->xpctxt = xmlXPtrNewContext(doc, NULL, NULL);\n-            if (ctxt->xpctxt == NULL) {\n-                xmlXIncludeErrMemory(ctxt);\n-                goto error;\n-            }\n-            if (ctxt->errorHandler != NULL)\n-                xmlXPathSetErrorHandler(ctxt->xpctxt, ctxt->errorHandler,\n-                                        ctxt->errorCtxt);\n-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n-            ctxt->xpctxt->opLimit = 100000;\n-#endif\n-        } else {\n-            ctxt->xpctxt->doc = doc;\n-        }\n-    xptr = xmlXPtrEval(fragment, ctxt->xpctxt);\n-    if (ctxt->xpctxt->lastError.code != XML_ERR_OK) {\n-            if (ctxt->xpctxt->lastError.code == XML_ERR_NO_MEMORY)\n-                xmlXIncludeErrMemory(ctxt);\n-            else\n-                xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_XPTR_FAILED,\n-                               \"XPointer evaluation failed: #%s\\n\",\n-                               fragment);\n-            goto error;\n-    }\n-        if (xptr == NULL)\n-            goto done;\n-    switch (xptr->type) {\n-        case XPATH_UNDEFINED:\n-        case XPATH_BOOLEAN:\n-        case XPATH_NUMBER:\n-        case XPATH_STRING:\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        case XPATH_POINT:\n-#endif\n-        case XPATH_USERS:\n-        case XPATH_XSLT_TREE:\n-        xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_XPTR_RESULT,\n-                   \"XPointer is not a range: #%s\\n\",\n-                   fragment);\n-                xmlXPathFreeObject(xptr);\n-                goto error;\n-        case XPATH_NODESET:\n-                break;\n-\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        case XPATH_RANGE:\n-        case XPATH_LOCATIONSET:\n-        break;\n-#endif\n-    }\n-    set = xptr->nodesetval;\n-    if (set != NULL) {\n-        for (i = 0;i < set->nodeNr;i++) {\n-        if (set->nodeTab[i] == NULL)\n-            continue;\n-        switch (set->nodeTab[i]->type) {\n-            case XML_ELEMENT_NODE:\n-            case XML_TEXT_NODE:\n-            case XML_CDATA_SECTION_NODE:\n-            case XML_ENTITY_REF_NODE:\n-            case XML_ENTITY_NODE:\n-            case XML_PI_NODE:\n-            case XML_COMMENT_NODE:\n-            case XML_DOCUMENT_NODE:\n-            case XML_HTML_DOCUMENT_NODE:\n-            continue;\n-\n-            case XML_ATTRIBUTE_NODE:\n-            xmlXIncludeErr(ctxt, ref->elem,\n-                           XML_XINCLUDE_XPTR_RESULT,\n-                       \"XPointer selects an attribute: #%s\\n\",\n-                       fragment);\n-            set->nodeTab[i] = NULL;\n-            continue;\n-            case XML_NAMESPACE_DECL:\n-            xmlXIncludeErr(ctxt, ref->elem,\n-                           XML_XINCLUDE_XPTR_RESULT,\n-                       \"XPointer selects a namespace: #%s\\n\",\n-                       fragment);\n-            set->nodeTab[i] = NULL;\n-            continue;\n-            case XML_DOCUMENT_TYPE_NODE:\n-            case XML_DOCUMENT_FRAG_NODE:\n-            case XML_NOTATION_NODE:\n-            case XML_DTD_NODE:\n-            case XML_ELEMENT_DECL:\n-            case XML_ATTRIBUTE_DECL:\n-            case XML_ENTITY_DECL:\n-            case XML_XINCLUDE_START:\n-            case XML_XINCLUDE_END:\n-            xmlXIncludeErr(ctxt, ref->elem,\n-                           XML_XINCLUDE_XPTR_RESULT,\n-                   \"XPointer selects unexpected nodes: #%s\\n\",\n-                       fragment);\n-            set->nodeTab[i] = NULL;\n-            set->nodeTab[i] = NULL;\n-            continue; \/* for *\/\n-        }\n-        }\n-    }\n-        ref->inc = xmlXIncludeCopyXPointer(ctxt, xptr, ref->base);\n-        xmlXPathFreeObject(xptr);\n-    }\n-#endif\n-\n-done:\n-    ret = 0;\n-\n-error:\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXIncludeLoadTxt:\n- * @ctxt:  the XInclude context\n- * @ref:  an XMLXincludeRefPtr\n- *\n- * Load the content, and store the result in the XInclude context\n- *\n- * Returns 0 in case of success, -1 in case of failure\n- *\/\n-static int\n-xmlXIncludeLoadTxt(xmlXIncludeCtxtPtr ctxt, xmlXIncludeRefPtr ref) {\n-    xmlParserInputBufferPtr buf;\n-    xmlNodePtr node = NULL;\n-    const xmlChar *url = ref->URI;\n-    int i;\n-    int ret = -1;\n-    xmlChar *encoding = NULL;\n-    xmlCharEncodingHandlerPtr handler = NULL;\n-    xmlParserCtxtPtr pctxt = NULL;\n-    xmlParserInputPtr inputStream = NULL;\n-    int len;\n-    int res;\n-    const xmlChar *content;\n-\n-    \/*\n-     * Handling of references to the local document are done\n-     * directly through ctxt->doc.\n-     *\/\n-    if (url[0] == 0) {\n-    xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_TEXT_DOCUMENT,\n-               \"text serialization of document not available\\n\", NULL);\n-    goto error;\n-    }\n-\n-    \/*\n-     * Prevent reloading the document twice.\n-     *\/\n-    for (i = 0; i < ctxt->txtNr; i++) {\n-    if (xmlStrEqual(url, ctxt->txtTab[i].url)) {\n-            node = xmlNewDocText(ctxt->doc, ctxt->txtTab[i].text);\n-            if (node == NULL)\n-                xmlXIncludeErrMemory(ctxt);\n-        goto loaded;\n-    }\n-    }\n-\n-    \/*\n-     * Try to get the encoding if available\n-     *\/\n-    if (ref->elem != NULL) {\n-    encoding = xmlXIncludeGetProp(ctxt, ref->elem, XINCLUDE_PARSE_ENCODING);\n-    }\n-    if (encoding != NULL) {\n-        res = xmlOpenCharEncodingHandler((const char *) encoding,\n-                                         \/* output *\/ 0, &handler);\n-\n-        if (res != 0) {\n-            if (res == XML_ERR_NO_MEMORY) {\n-                xmlXIncludeErrMemory(ctxt);\n-            } else if (res == XML_ERR_UNSUPPORTED_ENCODING) {\n-                xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_UNKNOWN_ENCODING,\n-                               \"encoding %s not supported\\n\", encoding);\n-                goto error;\n-            } else {\n-                xmlXIncludeErr(ctxt, ref->elem, res,\n-                               \"unexpected error from iconv or ICU\\n\", NULL);\n-                goto error;\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * Load it.\n-     *\/\n-    pctxt = xmlNewParserCtxt();\n-    if (pctxt == NULL) {\n-        xmlXIncludeErrMemory(ctxt);\n-        goto error;\n-    }\n-    if (ctxt->errorHandler != NULL)\n-        xmlCtxtSetErrorHandler(pctxt, ctxt->errorHandler, ctxt->errorCtxt);\n-    inputStream = xmlLoadExternalEntity((const char*)url, NULL, pctxt);\n-    if (inputStream == NULL) {\n-        \/*\n-         * ENOENT only produces a warning which isn't reflected in errNo.\n-         *\/\n-        if (pctxt->errNo == XML_ERR_NO_MEMORY)\n-            xmlXIncludeErrMemory(ctxt);\n-        else if ((pctxt->errNo != XML_ERR_OK) &&\n-                 (pctxt->errNo != XML_IO_ENOENT) &&\n-                 (pctxt->errNo != XML_IO_UNKNOWN))\n-            xmlXIncludeErr(ctxt, NULL, pctxt->errNo, \"load error\", NULL);\n-    goto error;\n-    }\n-    buf = inputStream->buf;\n-    if (buf == NULL)\n-    goto error;\n-    if (buf->encoder)\n-    xmlCharEncCloseFunc(buf->encoder);\n-    buf->encoder = handler;\n-    handler = NULL;\n-\n-    node = xmlNewDocText(ctxt->doc, NULL);\n-    if (node == NULL) {\n-        xmlXIncludeErrMemory(ctxt);\n-    goto error;\n-    }\n-\n-    \/*\n-     * Scan all chars from the resource and add the to the node\n-     *\/\n-    do {\n-        res = xmlParserInputBufferRead(buf, 4096);\n-    } while (res > 0);\n-    if (res < 0) {\n-        if (buf->error == XML_ERR_NO_MEMORY)\n-            xmlXIncludeErrMemory(ctxt);\n-        else\n-            xmlXIncludeErr(ctxt, NULL, buf->error, \"read error\", NULL);\n-        goto error;\n-    }\n-\n-    content = xmlBufContent(buf->buffer);\n-    len = xmlBufLength(buf->buffer);\n-    for (i = 0; i < len;) {\n-        int cur;\n-        int l;\n-\n-        l = len - i;\n-        cur = xmlGetUTF8Char(&content[i], &l);\n-        if ((cur < 0) || (!IS_CHAR(cur))) {\n-            xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_INVALID_CHAR,\n-                           \"%s contains invalid char\\n\", url);\n-            goto error;\n-        }\n-\n-        i += l;\n-    }\n-\n-    if (xmlNodeAddContentLen(node, content, len) < 0)\n-        xmlXIncludeErrMemory(ctxt);\n-\n-    if (ctxt->txtNr >= ctxt->txtMax) {\n-        xmlXIncludeTxt *tmp;\n-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n-        size_t newSize = ctxt->txtMax ? ctxt->txtMax * 2 : 1;\n-#else\n-        size_t newSize = ctxt->txtMax ? ctxt->txtMax * 2 : 8;\n-#endif\n-\n-        tmp = xmlRealloc(ctxt->txtTab, sizeof(xmlXIncludeTxt) * newSize);\n-        if (tmp == NULL) {\n-            xmlXIncludeErrMemory(ctxt);\n-        goto error;\n-        }\n-        ctxt->txtMax = newSize;\n-        ctxt->txtTab = tmp;\n-    }\n-    ctxt->txtTab[ctxt->txtNr].text = xmlStrdup(node->content);\n-    if ((node->content != NULL) &&\n-        (ctxt->txtTab[ctxt->txtNr].text == NULL)) {\n-        xmlXIncludeErrMemory(ctxt);\n-        goto error;\n-    }\n-    ctxt->txtTab[ctxt->txtNr].url = xmlStrdup(url);\n-    if (ctxt->txtTab[ctxt->txtNr].url == NULL) {\n-        xmlXIncludeErrMemory(ctxt);\n-        xmlFree(ctxt->txtTab[ctxt->txtNr].text);\n-        goto error;\n-    }\n-    ctxt->txtNr++;\n-\n-loaded:\n-    \/*\n-     * Add the element as the replacement copy.\n-     *\/\n-    ref->inc = node;\n-    node = NULL;\n-    ret = 0;\n-\n-error:\n-    xmlFreeNode(node);\n-    xmlFreeInputStream(inputStream);\n-    xmlFreeParserCtxt(pctxt);\n-    xmlCharEncCloseFunc(handler);\n-    xmlFree(encoding);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXIncludeLoadFallback:\n- * @ctxt:  the XInclude context\n- * @fallback:  the fallback node\n- * @ref:  an XMLXincludeRefPtr\n- *\n- * Load the content of the fallback node, and store the result\n- * in the XInclude context\n- *\n- * Returns 0 in case of success, -1 in case of failure\n- *\/\n-static int\n-xmlXIncludeLoadFallback(xmlXIncludeCtxtPtr ctxt, xmlNodePtr fallback,\n-                        xmlXIncludeRefPtr ref) {\n-    int ret = 0;\n-    int oldNbErrors;\n-\n-    if ((fallback == NULL) || (fallback->type == XML_NAMESPACE_DECL) ||\n-        (ctxt == NULL))\n-    return(-1);\n-    if (fallback->children != NULL) {\n-    \/*\n-     * It's possible that the fallback also has 'includes'\n-     * (Bug 129969), so we re-process the fallback just in case\n-     *\/\n-        oldNbErrors = ctxt->nbErrors;\n-    ref->inc = xmlXIncludeCopyNode(ctxt, fallback, 1, ref->base);\n-    if (ctxt->nbErrors > oldNbErrors)\n-        ret = -1;\n-    } else {\n-        ref->inc = NULL;\n-    }\n-    ref->fallback = 1;\n-    return(ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            XInclude Processing                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlXIncludeExpandNode:\n- * @ctxt: an XInclude context\n- * @node: an XInclude node\n- *\n- * If the XInclude node wasn't processed yet, create a new RefPtr,\n- * add it to ctxt->incTab and load the included items.\n- *\n- * Returns the new or existing xmlXIncludeRefPtr, or NULL in case of error.\n- *\/\n-static xmlXIncludeRefPtr\n-xmlXIncludeExpandNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {\n-    xmlXIncludeRefPtr ref;\n-    int i;\n-\n-    if (ctxt->fatalErr)\n-        return(NULL);\n-    if (ctxt->depth >= XINCLUDE_MAX_DEPTH) {\n-        xmlXIncludeErr(ctxt, node, XML_XINCLUDE_RECURSION,\n-                       \"maximum recursion depth exceeded\\n\", NULL);\n-        ctxt->fatalErr = 1;\n-        return(NULL);\n-    }\n-\n-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n-    \/*\n-     * The XInclude engine offers no protection against exponential\n-     * expansion attacks similar to \"billion laughs\". Avoid timeouts by\n-     * limiting the total number of replacements when fuzzing.\n-     *\n-     * Unfortuately, a single XInclude can already result in quadratic\n-     * behavior:\n-     *\n-     *     <doc xmlns:xi=\"http:\/\/www.w3.org\/2001\/XInclude\">\n-     *       <xi:include xpointer=\"xpointer(\/\/e)\"\/>\n-     *       <e>\n-     *         <e>\n-     *           <e>\n-     *             <!-- more nested elements -->\n-     *           <\/e>\n-     *         <\/e>\n-     *       <\/e>\n-     *     <\/doc>\n-     *\/\n-    if (ctxt->incTotal >= 20)\n-        return(NULL);\n-    ctxt->incTotal++;\n-#endif\n-\n-    for (i = 0; i < ctxt->incNr; i++) {\n-        if (ctxt->incTab[i]->elem == node) {\n-            if (ctxt->incTab[i]->expanding) {\n-                xmlXIncludeErr(ctxt, node, XML_XINCLUDE_RECURSION,\n-                               \"inclusion loop detected\\n\", NULL);\n-                return(NULL);\n-            }\n-            return(ctxt->incTab[i]);\n-        }\n-    }\n-\n-    ref = xmlXIncludeAddNode(ctxt, node);\n-    if (ref == NULL)\n-        return(NULL);\n-    ref->expanding = 1;\n-    ctxt->depth++;\n-    xmlXIncludeLoadNode(ctxt, ref);\n-    ctxt->depth--;\n-    ref->expanding = 0;\n-\n-    return(ref);\n-}\n-\n-\/**\n- * xmlXIncludeLoadNode:\n- * @ctxt: an XInclude context\n- * @ref: an xmlXIncludeRefPtr\n- *\n- * Find and load the infoset replacement for the given node.\n- *\n- * Returns 0 if substitution succeeded, -1 if some processing failed\n- *\/\n-static int\n-xmlXIncludeLoadNode(xmlXIncludeCtxtPtr ctxt, xmlXIncludeRefPtr ref) {\n-    xmlNodePtr cur;\n-    int ret;\n-\n-    if ((ctxt == NULL) || (ref == NULL))\n-    return(-1);\n-    cur = ref->elem;\n-    if (cur == NULL)\n-    return(-1);\n-\n-    if (ref->xml) {\n-    ret = xmlXIncludeLoadDoc(ctxt, ref);\n-    \/* xmlXIncludeGetFragment(ctxt, cur, URI); *\/\n-    } else {\n-    ret = xmlXIncludeLoadTxt(ctxt, ref);\n-    }\n-\n-    if (ret < 0) {\n-    xmlNodePtr children;\n-\n-    \/*\n-     * Time to try a fallback if available\n-     *\/\n-    children = cur->children;\n-    while (children != NULL) {\n-        if ((children->type == XML_ELEMENT_NODE) &&\n-        (children->ns != NULL) &&\n-        (xmlStrEqual(children->name, XINCLUDE_FALLBACK)) &&\n-        ((xmlStrEqual(children->ns->href, XINCLUDE_NS)) ||\n-         (xmlStrEqual(children->ns->href, XINCLUDE_OLD_NS)))) {\n-        ret = xmlXIncludeLoadFallback(ctxt, children, ref);\n-        break;\n-        }\n-        children = children->next;\n-    }\n-    }\n-    if (ret < 0) {\n-    xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_NO_FALLBACK,\n-               \"could not load %s, and no fallback was found\\n\",\n-               ref->URI);\n-    }\n-\n-    return(0);\n-}\n-\n-\/**\n- * xmlXIncludeIncludeNode:\n- * @ctxt: an XInclude context\n- * @ref: an xmlXIncludeRefPtr\n- *\n- * Implement the infoset replacement for the given node\n- *\n- * Returns 0 if substitution succeeded, -1 if some processing failed\n- *\/\n-static int\n-xmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, xmlXIncludeRefPtr ref) {\n-    xmlNodePtr cur, end, list, tmp;\n-\n-    if ((ctxt == NULL) || (ref == NULL))\n-    return(-1);\n-    cur = ref->elem;\n-    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n-    return(-1);\n-\n-    list = ref->inc;\n-    ref->inc = NULL;\n-\n-    \/*\n-     * Check against the risk of generating a multi-rooted document\n-     *\/\n-    if ((cur->parent != NULL) &&\n-    (cur->parent->type != XML_ELEMENT_NODE)) {\n-    int nb_elem = 0;\n-\n-    tmp = list;\n-    while (tmp != NULL) {\n-        if (tmp->type == XML_ELEMENT_NODE)\n-        nb_elem++;\n-        tmp = tmp->next;\n-    }\n-    if (nb_elem > 1) {\n-        xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_MULTIPLE_ROOT,\n-               \"XInclude error: would result in multiple root nodes\\n\",\n-               NULL);\n-            xmlFreeNodeList(list);\n-        return(-1);\n-    }\n-    }\n-\n-    if (ctxt->parseFlags & XML_PARSE_NOXINCNODE) {\n-    \/*\n-     * Add the list of nodes\n-         *\n-         * TODO: Coalesce text nodes unless we are streaming mode.\n-     *\/\n-    while (list != NULL) {\n-        end = list;\n-        list = list->next;\n-\n-        if (xmlAddPrevSibling(cur, end) == NULL) {\n-                xmlUnlinkNode(end);\n-                xmlFreeNode(end);\n-                goto err_memory;\n-            }\n-    }\n-    xmlUnlinkNode(cur);\n-    xmlFreeNode(cur);\n-    } else {\n-        xmlNodePtr child, next;\n-\n-    \/*\n-     * Change the current node as an XInclude start one, and add an\n-     * XInclude end one\n-     *\/\n-        if (ref->fallback)\n-            xmlUnsetProp(cur, BAD_CAST \"href\");\n-    cur->type = XML_XINCLUDE_START;\n-        \/* Remove fallback children *\/\n-        for (child = cur->children; child != NULL; child = next) {\n-            next = child->next;\n-            xmlUnlinkNode(child);\n-            xmlFreeNode(child);\n-        }\n-    end = xmlNewDocNode(cur->doc, cur->ns, cur->name, NULL);\n-    if (end == NULL)\n-            goto err_memory;\n-    end->type = XML_XINCLUDE_END;\n-    if (xmlAddNextSibling(cur, end) == NULL) {\n-            xmlFreeNode(end);\n-            goto err_memory;\n-        }\n-\n-    \/*\n-     * Add the list of nodes\n-     *\/\n-    while (list != NULL) {\n-        cur = list;\n-        list = list->next;\n-\n-        if (xmlAddPrevSibling(end, cur) == NULL) {\n-                xmlUnlinkNode(cur);\n-                xmlFreeNode(cur);\n-                goto err_memory;\n-            }\n-    }\n-    }\n-\n-\n-    return(0);\n-\n-err_memory:\n-    xmlXIncludeErrMemory(ctxt);\n-    xmlFreeNodeList(list);\n-    return(-1);\n-}\n-\n-\/**\n- * xmlXIncludeTestNode:\n- * @ctxt: the XInclude processing context\n- * @node: an XInclude node\n- *\n- * test if the node is an XInclude node\n- *\n- * Returns 1 true, 0 otherwise\n- *\/\n-static int\n-xmlXIncludeTestNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {\n-    if (node == NULL)\n-    return(0);\n-    if (node->type != XML_ELEMENT_NODE)\n-    return(0);\n-    if (node->ns == NULL)\n-    return(0);\n-    if ((xmlStrEqual(node->ns->href, XINCLUDE_NS)) ||\n-        (xmlStrEqual(node->ns->href, XINCLUDE_OLD_NS))) {\n-    if (xmlStrEqual(node->ns->href, XINCLUDE_OLD_NS)) {\n-        if (ctxt->legacy == 0) {\n-#if 0 \/* wait for the XML Core Working Group to get something stable ! *\/\n-        xmlXIncludeWarn(ctxt, node, XML_XINCLUDE_DEPRECATED_NS,\n-                   \"Deprecated XInclude namespace found, use %s\",\n-                        XINCLUDE_NS);\n-#endif\n-            ctxt->legacy = 1;\n-        }\n-    }\n-    if (xmlStrEqual(node->name, XINCLUDE_NODE)) {\n-        xmlNodePtr child = node->children;\n-        int nb_fallback = 0;\n-\n-        while (child != NULL) {\n-        if ((child->type == XML_ELEMENT_NODE) &&\n-            (child->ns != NULL) &&\n-            ((xmlStrEqual(child->ns->href, XINCLUDE_NS)) ||\n-             (xmlStrEqual(child->ns->href, XINCLUDE_OLD_NS)))) {\n-            if (xmlStrEqual(child->name, XINCLUDE_NODE)) {\n-            xmlXIncludeErr(ctxt, node,\n-                           XML_XINCLUDE_INCLUDE_IN_INCLUDE,\n-                       \"%s has an 'include' child\\n\",\n-                       XINCLUDE_NODE);\n-            return(0);\n-            }\n-            if (xmlStrEqual(child->name, XINCLUDE_FALLBACK)) {\n-            nb_fallback++;\n-            }\n-        }\n-        child = child->next;\n-        }\n-        if (nb_fallback > 1) {\n-        xmlXIncludeErr(ctxt, node, XML_XINCLUDE_FALLBACKS_IN_INCLUDE,\n-                   \"%s has multiple fallback children\\n\",\n-                       XINCLUDE_NODE);\n-        return(0);\n-        }\n-        return(1);\n-    }\n-    if (xmlStrEqual(node->name, XINCLUDE_FALLBACK)) {\n-        if ((node->parent == NULL) ||\n-        (node->parent->type != XML_ELEMENT_NODE) ||\n-        (node->parent->ns == NULL) ||\n-        ((!xmlStrEqual(node->parent->ns->href, XINCLUDE_NS)) &&\n-         (!xmlStrEqual(node->parent->ns->href, XINCLUDE_OLD_NS))) ||\n-        (!xmlStrEqual(node->parent->name, XINCLUDE_NODE))) {\n-        xmlXIncludeErr(ctxt, node,\n-                       XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE,\n-                   \"%s is not the child of an 'include'\\n\",\n-                   XINCLUDE_FALLBACK);\n-        }\n-    }\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlXIncludeDoProcess:\n- * @ctxt: the XInclude processing context\n- * @tree: the top of the tree to process\n- *\n- * Implement the XInclude substitution on the XML document @doc\n- *\n- * Returns 0 if no substitution were done, -1 if some processing failed\n- *    or the number of substitutions done.\n- *\/\n-static int\n-xmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlNodePtr tree) {\n-    xmlXIncludeRefPtr ref;\n-    xmlNodePtr cur;\n-    int ret = 0;\n-    int i, start;\n-\n-    \/*\n-     * First phase: lookup the elements in the document\n-     *\/\n-    start = ctxt->incNr;\n-    cur = tree;\n-    do {\n-    \/* TODO: need to work on entities -> stack *\/\n-        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n-            ref = xmlXIncludeExpandNode(ctxt, cur);\n-            \/*\n-             * Mark direct includes.\n-             *\/\n-            if (ref != NULL)\n-                ref->replace = 1;\n-        } else if ((cur->children != NULL) &&\n-                   ((cur->type == XML_DOCUMENT_NODE) ||\n-                    (cur->type == XML_ELEMENT_NODE))) {\n-            cur = cur->children;\n-            continue;\n-        }\n-        do {\n-            if (cur == tree)\n-                break;\n-            if (cur->next != NULL) {\n-                cur = cur->next;\n-                break;\n-            }\n-            cur = cur->parent;\n-        } while (cur != NULL);\n-    } while ((cur != NULL) && (cur != tree));\n-\n-    \/*\n-     * Second phase: extend the original document infoset.\n-     *\/\n-    for (i = start; i < ctxt->incNr; i++) {\n-    if (ctxt->incTab[i]->replace != 0) {\n-            xmlXIncludeIncludeNode(ctxt, ctxt->incTab[i]);\n-            ctxt->incTab[i]->replace = 0;\n-        } else {\n-            \/*\n-             * Ignore includes which were added indirectly, for example\n-             * inside xi:fallback elements.\n-             *\/\n-            if (ctxt->incTab[i]->inc != NULL) {\n-                xmlFreeNodeList(ctxt->incTab[i]->inc);\n-                ctxt->incTab[i]->inc = NULL;\n-            }\n-        }\n-    ret++;\n-    }\n-\n-    if (ctxt->isStream) {\n-        \/*\n-         * incTab references nodes which will eventually be deleted in\n-         * streaming mode. The table is only required for XPointer\n-         * expressions which aren't allowed in streaming mode.\n-         *\/\n-        for (i = 0;i < ctxt->incNr;i++) {\n-            xmlXIncludeFreeRef(ctxt->incTab[i]);\n-        }\n-        ctxt->incNr = 0;\n-    }\n-\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXIncludeDoProcessRoot:\n- * @ctxt: the XInclude processing context\n- * @tree: the top of the tree to process\n- *\n- * Implement the XInclude substitution on the XML document @doc\n- *\n- * Returns 0 if no substitution were done, -1 if some processing failed\n- *    or the number of substitutions done.\n- *\/\n-static int\n-xmlXIncludeDoProcessRoot(xmlXIncludeCtxtPtr ctxt, xmlNodePtr tree) {\n-    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n-    return(-1);\n-    if (ctxt == NULL)\n-    return(-1);\n-\n-    return(xmlXIncludeDoProcess(ctxt, tree));\n-}\n-\n-\/**\n- * xmlXIncludeGetLastError:\n- * @ctxt:  an XInclude processing context\n- *\n- * Available since 2.13.0.\n- *\n- * Returns the last error code.\n- *\/\n-int\n-xmlXIncludeGetLastError(xmlXIncludeCtxtPtr ctxt) {\n-    if (ctxt == NULL)\n-        return(XML_ERR_ARGUMENT);\n-    return(ctxt->errNo);\n-}\n-\n-\/**\n- * xmlXIncludeSetErrorHandler:\n- * @ctxt:  an XInclude processing context\n- * @handler:  error handler\n- * @data:  user data which will be passed to the handler\n- *\n- * Register a callback function that will be called on errors and\n- * warnings. If handler is NULL, the error handler will be deactivated.\n- *\n- * Available since 2.13.0.\n- *\/\n-void\n-xmlXIncludeSetErrorHandler(xmlXIncludeCtxtPtr ctxt,\n-                           xmlStructuredErrorFunc handler, void *data) {\n-    if (ctxt == NULL)\n-        return;\n-    ctxt->errorHandler = handler;\n-    ctxt->errorCtxt = data;\n-}\n-\n-\/**\n- * xmlXIncludeSetFlags:\n- * @ctxt:  an XInclude processing context\n- * @flags: a set of xmlParserOption used for parsing XML includes\n- *\n- * Set the flags used for further processing of XML resources.\n- *\n- * Returns 0 in case of success and -1 in case of error.\n- *\/\n-int\n-xmlXIncludeSetFlags(xmlXIncludeCtxtPtr ctxt, int flags) {\n-    if (ctxt == NULL)\n-        return(-1);\n-    ctxt->parseFlags = flags;\n-    return(0);\n-}\n-\n-\/**\n- * xmlXIncludeSetStreamingMode:\n- * @ctxt:  an XInclude processing context\n- * @mode:  whether streaming mode should be enabled\n- *\n- * In streaming mode, XPointer expressions aren't allowed.\n- *\n- * Returns 0 in case of success and -1 in case of error.\n- *\/\n-int\n-xmlXIncludeSetStreamingMode(xmlXIncludeCtxtPtr ctxt, int mode) {\n-    if (ctxt == NULL)\n-        return(-1);\n-    ctxt->isStream = !!mode;\n-    return(0);\n-}\n-\n-\/**\n- * xmlXIncludeProcessTreeFlagsData:\n- * @tree: an XML node\n- * @flags: a set of xmlParserOption used for parsing XML includes\n- * @data: application data that will be passed to the parser context\n- *        in the _private field of the parser context(s)\n- *\n- * Implement the XInclude substitution on the XML node @tree\n- *\n- * Returns 0 if no substitution were done, -1 if some processing failed\n- *    or the number of substitutions done.\n- *\/\n-\n-int\n-xmlXIncludeProcessTreeFlagsData(xmlNodePtr tree, int flags, void *data) {\n-    xmlXIncludeCtxtPtr ctxt;\n-    int ret = 0;\n-\n-    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL) ||\n-        (tree->doc == NULL))\n-        return(-1);\n-\n-    ctxt = xmlXIncludeNewContext(tree->doc);\n-    if (ctxt == NULL)\n-        return(-1);\n-    ctxt->_private = data;\n-    xmlXIncludeSetFlags(ctxt, flags);\n-    ret = xmlXIncludeDoProcessRoot(ctxt, tree);\n-    if ((ret >= 0) && (ctxt->nbErrors > 0))\n-        ret = -1;\n-\n-    xmlXIncludeFreeContext(ctxt);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXIncludeProcessFlagsData:\n- * @doc: an XML document\n- * @flags: a set of xmlParserOption used for parsing XML includes\n- * @data: application data that will be passed to the parser context\n- *        in the _private field of the parser context(s)\n- *\n- * Implement the XInclude substitution on the XML document @doc\n- *\n- * Returns 0 if no substitution were done, -1 if some processing failed\n- *    or the number of substitutions done.\n- *\/\n-int\n-xmlXIncludeProcessFlagsData(xmlDocPtr doc, int flags, void *data) {\n-    xmlNodePtr tree;\n-\n-    if (doc == NULL)\n-    return(-1);\n-    tree = xmlDocGetRootElement(doc);\n-    if (tree == NULL)\n-    return(-1);\n-    return(xmlXIncludeProcessTreeFlagsData(tree, flags, data));\n-}\n-\n-\/**\n- * xmlXIncludeProcessFlags:\n- * @doc: an XML document\n- * @flags: a set of xmlParserOption used for parsing XML includes\n- *\n- * Implement the XInclude substitution on the XML document @doc\n- *\n- * Returns 0 if no substitution were done, -1 if some processing failed\n- *    or the number of substitutions done.\n- *\/\n-int\n-xmlXIncludeProcessFlags(xmlDocPtr doc, int flags) {\n-    return xmlXIncludeProcessFlagsData(doc, flags, NULL);\n-}\n-\n-\/**\n- * xmlXIncludeProcess:\n- * @doc: an XML document\n- *\n- * Implement the XInclude substitution on the XML document @doc\n- *\n- * Returns 0 if no substitution were done, -1 if some processing failed\n- *    or the number of substitutions done.\n- *\/\n-int\n-xmlXIncludeProcess(xmlDocPtr doc) {\n-    return(xmlXIncludeProcessFlags(doc, 0));\n-}\n-\n-\/**\n- * xmlXIncludeProcessTreeFlags:\n- * @tree: a node in an XML document\n- * @flags: a set of xmlParserOption used for parsing XML includes\n- *\n- * Implement the XInclude substitution for the given subtree\n- *\n- * Returns 0 if no substitution were done, -1 if some processing failed\n- *    or the number of substitutions done.\n- *\/\n-int\n-xmlXIncludeProcessTreeFlags(xmlNodePtr tree, int flags) {\n-    xmlXIncludeCtxtPtr ctxt;\n-    int ret = 0;\n-\n-    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL) ||\n-        (tree->doc == NULL))\n-    return(-1);\n-    ctxt = xmlXIncludeNewContext(tree->doc);\n-    if (ctxt == NULL)\n-    return(-1);\n-    xmlXIncludeSetFlags(ctxt, flags);\n-    ret = xmlXIncludeDoProcessRoot(ctxt, tree);\n-    if ((ret >= 0) && (ctxt->nbErrors > 0))\n-    ret = -1;\n-\n-    xmlXIncludeFreeContext(ctxt);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXIncludeProcessTree:\n- * @tree: a node in an XML document\n- *\n- * Implement the XInclude substitution for the given subtree\n- *\n- * Returns 0 if no substitution were done, -1 if some processing failed\n- *    or the number of substitutions done.\n- *\/\n-int\n-xmlXIncludeProcessTree(xmlNodePtr tree) {\n-    return(xmlXIncludeProcessTreeFlags(tree, 0));\n-}\n-\n-\/**\n- * xmlXIncludeProcessNode:\n- * @ctxt: an existing XInclude context\n- * @node: a node in an XML document\n- *\n- * Implement the XInclude substitution for the given subtree reusing\n- * the information and data coming from the given context.\n- *\n- * Returns 0 if no substitution were done, -1 if some processing failed\n- *    or the number of substitutions done.\n- *\/\n-int\n-xmlXIncludeProcessNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {\n-    int ret = 0;\n-\n-    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL) ||\n-        (node->doc == NULL) || (ctxt == NULL))\n-    return(-1);\n-    ret = xmlXIncludeDoProcessRoot(ctxt, node);\n-    if ((ret >= 0) && (ctxt->nbErrors > 0))\n-    ret = -1;\n-    return(ret);\n-}\n-\n-#else \/* !LIBXML_XINCLUDE_ENABLED *\/\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xinclude.c","additions":0,"deletions":2451,"binary":false,"changes":2451,"status":"deleted"},{"patch":"@@ -1,163 +0,0 @@\n-\/*\n- * xlink.c : implementation of the hyperlinks detection module\n- *           This version supports both XML XLinks and HTML simple links\n- *\n- * See Copyright for the status of this software.\n- *\n- * daniel@veillard.com\n- *\/\n-\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-\n-#ifdef LIBXML_XPTR_ENABLED\n-#include <string.h> \/* for memset() only *\/\n-#include <ctype.h>\n-#include <stdlib.h>\n-\n-#include <libxml\/xmlmemory.h>\n-#include <libxml\/tree.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/xlink.h>\n-\n-#define XLINK_NAMESPACE (BAD_CAST \"http:\/\/www.w3.org\/1999\/xlink\/namespace\/\")\n-#define XHTML_NAMESPACE (BAD_CAST \"http:\/\/www.w3.org\/1999\/xhtml\/\")\n-\n-\/****************************************************************\n- *                                *\n- *           Default setting and related functions        *\n- *                                *\n- ****************************************************************\/\n-\n-static xlinkHandlerPtr xlinkDefaultHandler = NULL;\n-static xlinkNodeDetectFunc    xlinkDefaultDetect = NULL;\n-\n-\/**\n- * xlinkGetDefaultHandler:\n- *\n- * Get the default xlink handler.\n- *\n- * Returns the current xlinkHandlerPtr value.\n- *\/\n-xlinkHandlerPtr\n-xlinkGetDefaultHandler(void) {\n-    return(xlinkDefaultHandler);\n-}\n-\n-\n-\/**\n- * xlinkSetDefaultHandler:\n- * @handler:  the new value for the xlink handler block\n- *\n- * Set the default xlink handlers\n- *\/\n-void\n-xlinkSetDefaultHandler(xlinkHandlerPtr handler) {\n-    xlinkDefaultHandler = handler;\n-}\n-\n-\/**\n- * xlinkGetDefaultDetect:\n- *\n- * Get the default xlink detection routine\n- *\n- * Returns the current function or NULL;\n- *\/\n-xlinkNodeDetectFunc\n-xlinkGetDefaultDetect    (void) {\n-    return(xlinkDefaultDetect);\n-}\n-\n-\/**\n- * xlinkSetDefaultDetect:\n- * @func: pointer to the new detection routine.\n- *\n- * Set the default xlink detection routine\n- *\/\n-void\n-xlinkSetDefaultDetect    (xlinkNodeDetectFunc func) {\n-    xlinkDefaultDetect = func;\n-}\n-\n-\/****************************************************************\n- *                                *\n- *                  The detection routines            *\n- *                                *\n- ****************************************************************\/\n-\n-\n-\/**\n- * xlinkIsLink:\n- * @doc:  the document containing the node\n- * @node:  the node pointer itself\n- *\n- * Check whether the given node carries the attributes needed\n- * to be a link element (or is one of the linking elements issued\n- * from the (X)HTML DtDs).\n- * This routine don't try to do full checking of the link validity\n- * but tries to detect and return the appropriate link type.\n- *\n- * Returns the xlinkType of the node (XLINK_TYPE_NONE if there is no\n- *         link detected.\n- *\/\n-xlinkType\n-xlinkIsLink    (xmlDocPtr doc, xmlNodePtr node) {\n-    xmlChar *type = NULL, *role = NULL;\n-    xlinkType ret = XLINK_TYPE_NONE;\n-\n-    if (node == NULL) return(XLINK_TYPE_NONE);\n-    if (doc == NULL) doc = node->doc;\n-    if ((doc != NULL) && (doc->type == XML_HTML_DOCUMENT_NODE)) {\n-        \/*\n-     * This is an HTML document.\n-     *\/\n-    } else if ((node->ns != NULL) &&\n-               (xmlStrEqual(node->ns->href, XHTML_NAMESPACE))) {\n-    \/*\n-     * !!!! We really need an IS_XHTML_ELEMENT function from HTMLtree.h @@@\n-     *\/\n-        \/*\n-     * This is an XHTML element within an XML document\n-     * Check whether it's one of the element able to carry links\n-     * and in that case if it holds the attributes.\n-     *\/\n-    }\n-\n-    \/*\n-     * We don't prevent a-priori having XML Linking constructs on\n-     * XHTML elements\n-     *\/\n-    type = xmlGetNsProp(node, BAD_CAST\"type\", XLINK_NAMESPACE);\n-    if (type != NULL) {\n-    if (xmlStrEqual(type, BAD_CAST \"simple\")) {\n-            ret = XLINK_TYPE_SIMPLE;\n-    } else if (xmlStrEqual(type, BAD_CAST \"extended\")) {\n-        role = xmlGetNsProp(node, BAD_CAST \"role\", XLINK_NAMESPACE);\n-        if (role != NULL) {\n-        xmlNsPtr xlink;\n-        xlink = xmlSearchNs(doc, node, XLINK_NAMESPACE);\n-        if (xlink == NULL) {\n-            \/* Humm, fallback method *\/\n-            if (xmlStrEqual(role, BAD_CAST\"xlink:external-linkset\"))\n-            ret = XLINK_TYPE_EXTENDED_SET;\n-        } else {\n-            xmlChar buf[200];\n-            snprintf((char *) buf, sizeof(buf), \"%s:external-linkset\",\n-                 (char *) xlink->prefix);\n-                    buf[sizeof(buf) - 1] = 0;\n-            if (xmlStrEqual(role, buf))\n-            ret = XLINK_TYPE_EXTENDED_SET;\n-\n-        }\n-\n-        }\n-        ret = XLINK_TYPE_EXTENDED;\n-    }\n-    }\n-\n-    if (type != NULL) xmlFree(type);\n-    if (role != NULL) xmlFree(role);\n-    return(ret);\n-}\n-#endif \/* LIBXML_XPTR_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xlink.c","additions":0,"deletions":163,"binary":false,"changes":163,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-#! \/bin\/sh\n-\n-prefix=@prefix@\n-exec_prefix=@exec_prefix@\n-includedir=@includedir@\n-libdir=@libdir@\n-cflags=\n-libs=\n-\n-usage()\n-{\n-    cat <<EOF\n-Usage: xml2-config [OPTION]\n-\n-Known values for OPTION are:\n-\n-  --prefix=DIR\t\tchange libxml prefix [default $prefix]\n-  --exec-prefix=DIR\tchange libxml exec prefix [default $exec_prefix]\n-  --libs\t\tprint library linking information\n-                        add --dynamic to print only shared libraries\n-  --cflags\t\tprint pre-processor and compiler flags\n-  --modules\t\tmodule support enabled\n-  --help\t\tdisplay this help and exit\n-  --version\t\toutput version information\n-EOF\n-\n-    exit $1\n-}\n-\n-if test $# -eq 0; then\n-    usage 1\n-fi\n-\n-while test $# -gt 0; do\n-    case \"$1\" in\n-    -*=*) optarg=`echo \"$1\" | sed 's\/[-_a-zA-Z0-9]*=\/\/'` ;;\n-    *) optarg= ;;\n-    esac\n-\n-    case \"$1\" in\n-    --prefix=*)\n-\tprefix=$optarg\n-\tincludedir=$prefix\/include\n-\tlibdir=$prefix\/lib\n-\t;;\n-\n-    --prefix)\n-\techo $prefix\n-\t;;\n-\n-    --exec-prefix=*)\n-      exec_prefix=$optarg\n-      libdir=$exec_prefix\/lib\n-      ;;\n-\n-    --exec-prefix)\n-      echo $exec_prefix\n-      ;;\n-\n-    --version)\n-\techo @VERSION@\n-\texit 0\n-\t;;\n-\n-    --help)\n-\tusage 0\n-\t;;\n-\n-    --cflags)\n-        cflags=\"@XML_INCLUDEDIR@ @XML_CFLAGS@\"\n-       \t;;\n-\n-    --libtool-libs)\n-\tif [ -r ${libdir}\/@XML_LIBTOOLLIBS@ ]\n-\tthen\n-\t    echo ${libdir}\/@XML_LIBTOOLLIBS@\n-\tfi\n-        ;;\n-\n-    --modules)\n-       \techo @WITH_MODULES@\n-       \t;;\n-\n-    --libs)\n-        if [ \"$2\" = \"--dynamic\" ]; then\n-            shift\n-            libs=\"@XML_LIBS@ @XML_PRIVATE_LIBS_NO_SHARED@\"\n-        else\n-            libs=\"@XML_LIBS@ @XML_PRIVATE_LIBS@ @MODULE_PLATFORM_LIBS@ @LIBS@\"\n-        fi\n-\n-        if [ \"@XML_LIBDIR@\" != \"-L\/usr\/lib\" -a \"@XML_LIBDIR@\" != \"-L\/usr\/lib64\" ]; then\n-            libs=\"@XML_LIBDIR@ $libs\"\n-        fi\n-        ;;\n-\n-    *)\n-\tusage 1\n-\t;;\n-    esac\n-    shift\n-done\n-\n-if test -n \"$cflags$libs\"; then\n-    echo $cflags $libs\n-fi\n-\n-exit 0\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xml2-config.in","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,614 +0,0 @@\n-\/*\n- * xmlcatalog.c : a small utility program to handle XML catalogs\n- *\n- * See Copyright for the status of this software.\n- *\n- * daniel@veillard.com\n- *\/\n-\n-#include \"libxml.h\"\n-\n-#include <string.h>\n-#include <stdio.h>\n-#include <stdarg.h>\n-#include <stdlib.h>\n-\n-#ifdef HAVE_LIBREADLINE\n-#include <readline\/readline.h>\n-#ifdef HAVE_LIBHISTORY\n-#include <readline\/history.h>\n-#endif\n-#endif\n-\n-#include <libxml\/xmlmemory.h>\n-#include <libxml\/uri.h>\n-#include <libxml\/catalog.h>\n-#include <libxml\/parser.h>\n-\n-#if defined(LIBXML_CATALOG_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)\n-static int shell = 0;\n-static int sgml = 0;\n-static int noout = 0;\n-static int create = 0;\n-static int add = 0;\n-static int del = 0;\n-static int convert = 0;\n-static int no_super_update = 0;\n-static int verbose = 0;\n-static char *filename = NULL;\n-\n-\n-#ifndef XML_SGML_DEFAULT_CATALOG\n-#define XML_SGML_DEFAULT_CATALOG SYSCONFDIR \"\/sgml\/catalog\"\n-#endif\n-\n-\/************************************************************************\n- *                                    *\n- *            Shell Interface                    *\n- *                                    *\n- ************************************************************************\/\n-\/**\n- * xmlShellReadline:\n- * @prompt:  the prompt value\n- *\n- * Read a string\n- *\n- * Returns a pointer to it or NULL on EOF the caller is expected to\n- *     free the returned string.\n- *\/\n-static char *\n-xmlShellReadline(const char *prompt) {\n-#ifdef HAVE_LIBREADLINE\n-    char *line_read;\n-\n-    \/* Get a line from the user. *\/\n-    line_read = readline (prompt);\n-\n-    \/* If the line has any text in it, save it on the history. *\/\n-    if (line_read && *line_read)\n-    add_history (line_read);\n-\n-    return (line_read);\n-#else\n-    char line_read[501];\n-    char *ret;\n-    int len;\n-\n-    if (prompt != NULL)\n-    fprintf(stdout, \"%s\", prompt);\n-    fflush(stdout);\n-    if (!fgets(line_read, 500, stdin))\n-        return(NULL);\n-    line_read[500] = 0;\n-    len = strlen(line_read);\n-    ret = (char *) malloc(len + 1);\n-    if (ret != NULL) {\n-    memcpy (ret, line_read, len + 1);\n-    }\n-    return(ret);\n-#endif\n-}\n-\n-static void usershell(void) {\n-    char *cmdline = NULL, *cur;\n-    int nbargs;\n-    char command[100];\n-    char arg[400];\n-    char *argv[20];\n-    int i, ret;\n-    xmlChar *ans;\n-\n-    while (1) {\n-    cmdline = xmlShellReadline(\"> \");\n-    if (cmdline == NULL)\n-        return;\n-\n-    \/*\n-     * Parse the command itself\n-     *\/\n-    cur = cmdline;\n-    nbargs = 0;\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    i = 0;\n-    while ((*cur != ' ') && (*cur != '\\t') &&\n-           (*cur != '\\n') && (*cur != '\\r')) {\n-        if (*cur == 0)\n-        break;\n-        command[i++] = *cur++;\n-    }\n-    command[i] = 0;\n-    if (i == 0) {\n-        free(cmdline);\n-        continue;\n-    }\n-\n-    \/*\n-     * Parse the argument string\n-     *\/\n-    memset(arg, 0, sizeof(arg));\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    i = 0;\n-    while ((*cur != '\\n') && (*cur != '\\r') && (*cur != 0)) {\n-        if (*cur == 0)\n-        break;\n-        arg[i++] = *cur++;\n-    }\n-    arg[i] = 0;\n-\n-    \/*\n-     * Parse the arguments\n-     *\/\n-    i = 0;\n-    nbargs = 0;\n-    cur = arg;\n-    memset(argv, 0, sizeof(argv));\n-    while (*cur != 0) {\n-        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-        if (*cur == '\\'') {\n-        cur++;\n-        argv[i] = cur;\n-        while ((*cur != 0) && (*cur != '\\'')) cur++;\n-        if (*cur == '\\'') {\n-            *cur = 0;\n-            nbargs++;\n-            i++;\n-            cur++;\n-        }\n-        } else if (*cur == '\"') {\n-        cur++;\n-        argv[i] = cur;\n-        while ((*cur != 0) && (*cur != '\"')) cur++;\n-        if (*cur == '\"') {\n-            *cur = 0;\n-            nbargs++;\n-            i++;\n-            cur++;\n-        }\n-        } else {\n-        argv[i] = cur;\n-        while ((*cur != 0) && (*cur != ' ') && (*cur != '\\t'))\n-            cur++;\n-        *cur = 0;\n-        nbargs++;\n-        i++;\n-        cur++;\n-        }\n-    }\n-\n-    \/*\n-     * start interpreting the command\n-     *\/\n-    if (!strcmp(command, \"exit\") ||\n-        !strcmp(command, \"quit\") ||\n-        !strcmp(command, \"bye\")) {\n-        free(cmdline);\n-        break;\n-    }\n-\n-    if (!strcmp(command, \"public\")) {\n-        if (nbargs != 1) {\n-        printf(\"public requires 1 arguments\\n\");\n-        } else {\n-        ans = xmlCatalogResolvePublic((const xmlChar *) argv[0]);\n-        if (ans == NULL) {\n-            printf(\"No entry for PUBLIC %s\\n\", argv[0]);\n-        } else {\n-            printf(\"%s\\n\", (char *) ans);\n-            xmlFree(ans);\n-        }\n-        }\n-    } else if (!strcmp(command, \"system\")) {\n-        if (nbargs != 1) {\n-        printf(\"system requires 1 arguments\\n\");\n-        } else {\n-        ans = xmlCatalogResolveSystem((const xmlChar *) argv[0]);\n-        if (ans == NULL) {\n-            printf(\"No entry for SYSTEM %s\\n\", argv[0]);\n-        } else {\n-            printf(\"%s\\n\", (char *) ans);\n-            xmlFree(ans);\n-        }\n-        }\n-    } else if (!strcmp(command, \"add\")) {\n-        if ((nbargs != 3) && (nbargs != 2)) {\n-        printf(\"add requires 2 or 3 arguments\\n\");\n-        } else {\n-        if (argv[2] == NULL)\n-        ret = xmlCatalogAdd(BAD_CAST argv[0], NULL,\n-                    BAD_CAST argv[1]);\n-        else\n-            ret = xmlCatalogAdd(BAD_CAST argv[0], BAD_CAST argv[1],\n-                    BAD_CAST argv[2]);\n-        if (ret != 0)\n-            printf(\"add command failed\\n\");\n-        }\n-    } else if (!strcmp(command, \"del\")) {\n-        if (nbargs != 1) {\n-        printf(\"del requires 1\\n\");\n-        } else {\n-        ret = xmlCatalogRemove(BAD_CAST argv[0]);\n-        if (ret <= 0)\n-            printf(\"del command failed\\n\");\n-\n-        }\n-    } else if (!strcmp(command, \"resolve\")) {\n-        if (nbargs != 2) {\n-        printf(\"resolve requires 2 arguments\\n\");\n-        } else {\n-        ans = xmlCatalogResolve(BAD_CAST argv[0],\n-                            BAD_CAST argv[1]);\n-        if (ans == NULL) {\n-            printf(\"Resolver failed to find an answer\\n\");\n-        } else {\n-            printf(\"%s\\n\", (char *) ans);\n-            xmlFree(ans);\n-        }\n-        }\n-    } else if (!strcmp(command, \"dump\")) {\n-        if (nbargs != 0) {\n-        printf(\"dump has no arguments\\n\");\n-        } else {\n-        xmlCatalogDump(stdout);\n-        }\n-    } else if (!strcmp(command, \"debug\")) {\n-        if (nbargs != 0) {\n-        printf(\"debug has no arguments\\n\");\n-        } else {\n-        verbose++;\n-        xmlCatalogSetDebug(verbose);\n-        }\n-    } else if (!strcmp(command, \"quiet\")) {\n-        if (nbargs != 0) {\n-        printf(\"quiet has no arguments\\n\");\n-        } else {\n-        if (verbose > 0)\n-            verbose--;\n-        xmlCatalogSetDebug(verbose);\n-        }\n-    } else {\n-        if (strcmp(command, \"help\")) {\n-        printf(\"Unrecognized command %s\\n\", command);\n-        }\n-        printf(\"Commands available:\\n\");\n-        printf(\"\\tpublic PublicID: make a PUBLIC identifier lookup\\n\");\n-        printf(\"\\tsystem SystemID: make a SYSTEM identifier lookup\\n\");\n-        printf(\"\\tresolve PublicID SystemID: do a full resolver lookup\\n\");\n-        printf(\"\\tadd 'type' 'orig' 'replace' : add an entry\\n\");\n-        printf(\"\\tdel 'values' : remove values\\n\");\n-        printf(\"\\tdump: print the current catalog state\\n\");\n-        printf(\"\\tdebug: increase the verbosity level\\n\");\n-        printf(\"\\tquiet: decrease the verbosity level\\n\");\n-        printf(\"\\texit:  quit the shell\\n\");\n-    }\n-    free(cmdline); \/* not xmlFree here ! *\/\n-    }\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Main                        *\n- *                                    *\n- ************************************************************************\/\n-static void usage(const char *name) {\n-    \/* split into 2 printf's to avoid overly long string (gcc warning) *\/\n-    printf(\"\\\n-Usage : %s [options] catalogfile entities...\\n\\\n-\\tParse the catalog file (void specification possibly expressed as \\\"\\\"\\n\\\n-\\tappoints the default system one) and query it for the entities\\n\\\n-\\t--sgml : handle SGML Super catalogs for --add and --del\\n\\\n-\\t--shell : run a shell allowing interactive queries\\n\\\n-\\t--create : create a new catalog\\n\\\n-\\t--add 'type' 'orig' 'replace' : add an XML entry\\n\\\n-\\t--add 'entry' : add an SGML entry\\n\", name);\n-    printf(\"\\\n-\\t--del 'values' : remove values\\n\\\n-\\t--noout: avoid dumping the result on stdout\\n\\\n-\\t         used with --add or --del, it saves the catalog changes\\n\\\n-\\t         and with --sgml it automatically updates the super catalog\\n\\\n-\\t--no-super-update: do not update the SGML super catalog\\n\\\n-\\t-v --verbose : provide debug information\\n\");\n-}\n-int main(int argc, char **argv) {\n-    int i;\n-    int ret;\n-    int exit_value = 0;\n-\n-\n-    if (argc <= 1) {\n-    usage(argv[0]);\n-    return(1);\n-    }\n-\n-    LIBXML_TEST_VERSION\n-    for (i = 1; i < argc ; i++) {\n-    if (!strcmp(argv[i], \"-\"))\n-        break;\n-\n-    if (argv[i][0] != '-')\n-        break;\n-    if ((!strcmp(argv[i], \"-verbose\")) ||\n-        (!strcmp(argv[i], \"-v\")) ||\n-        (!strcmp(argv[i], \"--verbose\"))) {\n-        verbose++;\n-        xmlCatalogSetDebug(verbose);\n-    } else if ((!strcmp(argv[i], \"-noout\")) ||\n-        (!strcmp(argv[i], \"--noout\"))) {\n-            noout = 1;\n-    } else if ((!strcmp(argv[i], \"-shell\")) ||\n-        (!strcmp(argv[i], \"--shell\"))) {\n-        shell++;\n-            noout = 1;\n-    } else if ((!strcmp(argv[i], \"-sgml\")) ||\n-        (!strcmp(argv[i], \"--sgml\"))) {\n-        sgml++;\n-    } else if ((!strcmp(argv[i], \"-create\")) ||\n-        (!strcmp(argv[i], \"--create\"))) {\n-        create++;\n-    } else if ((!strcmp(argv[i], \"-convert\")) ||\n-        (!strcmp(argv[i], \"--convert\"))) {\n-        convert++;\n-    } else if ((!strcmp(argv[i], \"-no-super-update\")) ||\n-        (!strcmp(argv[i], \"--no-super-update\"))) {\n-        no_super_update++;\n-    } else if ((!strcmp(argv[i], \"-add\")) ||\n-        (!strcmp(argv[i], \"--add\"))) {\n-        if (sgml)\n-        i += 2;\n-        else\n-        i += 3;\n-        add++;\n-    } else if ((!strcmp(argv[i], \"-del\")) ||\n-        (!strcmp(argv[i], \"--del\"))) {\n-        i += 1;\n-        del++;\n-    } else {\n-        fprintf(stderr, \"Unknown option %s\\n\", argv[i]);\n-        usage(argv[0]);\n-        return(1);\n-    }\n-    }\n-\n-    for (i = 1; i < argc; i++) {\n-    if ((!strcmp(argv[i], \"-add\")) ||\n-        (!strcmp(argv[i], \"--add\"))) {\n-        if (sgml)\n-        i += 2;\n-        else\n-        i += 3;\n-        continue;\n-    } else if ((!strcmp(argv[i], \"-del\")) ||\n-        (!strcmp(argv[i], \"--del\"))) {\n-        i += 1;\n-\n-        \/* No catalog entry specified *\/\n-        if (i == argc || (sgml && i + 1 == argc)) {\n-        fprintf(stderr, \"No catalog entry specified to remove from\\n\");\n-        usage (argv[0]);\n-        return(1);\n-        }\n-\n-        continue;\n-    } else if (argv[i][0] == '-')\n-        continue;\n-\n-    if (filename == NULL && argv[i][0] == '\\0') {\n-        \/* Interpret empty-string catalog specification as\n-           a shortcut for a default system catalog. *\/\n-        xmlInitializeCatalog();\n-    } else {\n-        filename = argv[i];\n-        ret = xmlLoadCatalog(argv[i]);\n-        if ((ret < 0) && (create)) {\n-        xmlCatalogAdd(BAD_CAST \"catalog\", BAD_CAST argv[i], NULL);\n-        }\n-\n-            \/*\n-             * Catalogs are loaded lazily. Make sure that dumping works\n-             * by the issuing a dummy request that forces the catalog to\n-             * be loaded.\n-             *\/\n-            xmlCatalogResolvePublic(BAD_CAST \"\");\n-    }\n-    break;\n-    }\n-\n-    if (convert)\n-        ret = xmlCatalogConvert();\n-\n-    if ((add) || (del)) {\n-    for (i = 1; i < argc ; i++) {\n-        if (!strcmp(argv[i], \"-\"))\n-        break;\n-\n-        if (argv[i][0] != '-')\n-        continue;\n-        if (strcmp(argv[i], \"-add\") && strcmp(argv[i], \"--add\") &&\n-        strcmp(argv[i], \"-del\") && strcmp(argv[i], \"--del\"))\n-        continue;\n-\n-        if (sgml) {\n-        \/*\n-         * Maintenance of SGML catalogs.\n-         *\/\n-        xmlCatalogPtr catal = NULL;\n-        xmlCatalogPtr super = NULL;\n-\n-        catal = xmlLoadSGMLSuperCatalog(argv[i + 1]);\n-\n-        if ((!strcmp(argv[i], \"-add\")) ||\n-            (!strcmp(argv[i], \"--add\"))) {\n-            if (catal == NULL)\n-            catal = xmlNewCatalog(1);\n-            xmlACatalogAdd(catal, BAD_CAST \"CATALOG\",\n-                     BAD_CAST argv[i + 2], NULL);\n-\n-            if (!no_super_update) {\n-            super = xmlLoadSGMLSuperCatalog(XML_SGML_DEFAULT_CATALOG);\n-            if (super == NULL)\n-                super = xmlNewCatalog(1);\n-\n-            xmlACatalogAdd(super, BAD_CAST \"CATALOG\",\n-                         BAD_CAST argv[i + 1], NULL);\n-            }\n-        } else {\n-            if (catal != NULL)\n-            ret = xmlACatalogRemove(catal, BAD_CAST argv[i + 2]);\n-            else\n-            ret = -1;\n-            if (ret < 0) {\n-            fprintf(stderr, \"Failed to remove entry from %s\\n\",\n-                argv[i + 1]);\n-            exit_value = 1;\n-            }\n-            if ((!no_super_update) && (noout) && (catal != NULL) &&\n-            (xmlCatalogIsEmpty(catal))) {\n-            super = xmlLoadSGMLSuperCatalog(\n-                   XML_SGML_DEFAULT_CATALOG);\n-            if (super != NULL) {\n-                ret = xmlACatalogRemove(super,\n-                    BAD_CAST argv[i + 1]);\n-                if (ret < 0) {\n-                fprintf(stderr,\n-                    \"Failed to remove entry from %s\\n\",\n-                    XML_SGML_DEFAULT_CATALOG);\n-                exit_value = 1;\n-                }\n-            }\n-            }\n-        }\n-        if (noout) {\n-            FILE *out;\n-\n-            if (xmlCatalogIsEmpty(catal)) {\n-            remove(argv[i + 1]);\n-            } else {\n-            out = fopen(argv[i + 1], \"w\");\n-            if (out == NULL) {\n-                fprintf(stderr, \"could not open %s for saving\\n\",\n-                    argv[i + 1]);\n-                exit_value = 2;\n-                noout = 0;\n-            } else {\n-                xmlACatalogDump(catal, out);\n-                fclose(out);\n-            }\n-            }\n-            if (!no_super_update && super != NULL) {\n-            if (xmlCatalogIsEmpty(super)) {\n-                remove(XML_SGML_DEFAULT_CATALOG);\n-            } else {\n-                out = fopen(XML_SGML_DEFAULT_CATALOG, \"w\");\n-                if (out == NULL) {\n-                fprintf(stderr,\n-                    \"could not open %s for saving\\n\",\n-                    XML_SGML_DEFAULT_CATALOG);\n-                exit_value = 2;\n-                noout = 0;\n-                } else {\n-\n-                xmlACatalogDump(super, out);\n-                fclose(out);\n-                }\n-            }\n-            }\n-        } else {\n-            xmlACatalogDump(catal, stdout);\n-        }\n-        i += 2;\n-\n-                xmlFreeCatalog(catal);\n-                xmlFreeCatalog(super);\n-        } else {\n-        if ((!strcmp(argv[i], \"-add\")) ||\n-            (!strcmp(argv[i], \"--add\"))) {\n-            if ((argv[i + 3] == NULL) || (argv[i + 3][0] == 0))\n-                ret = xmlCatalogAdd(BAD_CAST argv[i + 1], NULL,\n-                        BAD_CAST argv[i + 2]);\n-            else\n-                ret = xmlCatalogAdd(BAD_CAST argv[i + 1],\n-                        BAD_CAST argv[i + 2],\n-                        BAD_CAST argv[i + 3]);\n-            if (ret != 0) {\n-                printf(\"add command failed\\n\");\n-                exit_value = 3;\n-            }\n-            i += 3;\n-        } else if ((!strcmp(argv[i], \"-del\")) ||\n-            (!strcmp(argv[i], \"--del\"))) {\n-            ret = xmlCatalogRemove(BAD_CAST argv[i + 1]);\n-            if (ret < 0) {\n-            fprintf(stderr, \"Failed to remove entry %s\\n\",\n-                argv[i + 1]);\n-            exit_value = 1;\n-            }\n-            i += 1;\n-        }\n-        }\n-    }\n-\n-    } else if (shell) {\n-    usershell();\n-    } else {\n-    for (i++; i < argc; i++) {\n-        xmlURIPtr uri;\n-        xmlChar *ans;\n-\n-        uri = xmlParseURI(argv[i]);\n-        if (uri == NULL) {\n-        ans = xmlCatalogResolvePublic((const xmlChar *) argv[i]);\n-        if (ans == NULL) {\n-            printf(\"No entry for PUBLIC %s\\n\", argv[i]);\n-            exit_value = 4;\n-        } else {\n-            printf(\"%s\\n\", (char *) ans);\n-            xmlFree(ans);\n-        }\n-        } else {\n-                xmlFreeURI(uri);\n-        ans = xmlCatalogResolveSystem((const xmlChar *) argv[i]);\n-        if (ans == NULL) {\n-            printf(\"No entry for SYSTEM %s\\n\", argv[i]);\n-            ans = xmlCatalogResolveURI ((const xmlChar *) argv[i]);\n-            if (ans == NULL) {\n-            printf (\"No entry for URI %s\\n\", argv[i]);\n-                exit_value = 4;\n-            } else {\n-                printf(\"%s\\n\", (char *) ans);\n-            xmlFree (ans);\n-            }\n-        } else {\n-            printf(\"%s\\n\", (char *) ans);\n-            xmlFree(ans);\n-        }\n-        }\n-    }\n-    }\n-    if ((!sgml) && ((add) || (del) || (create) || (convert))) {\n-    if (noout && filename && *filename) {\n-        FILE *out;\n-\n-        out = fopen(filename, \"w\");\n-        if (out == NULL) {\n-        fprintf(stderr, \"could not open %s for saving\\n\", filename);\n-        exit_value = 2;\n-        noout = 0;\n-        } else {\n-        xmlCatalogDump(out);\n-        }\n-    } else {\n-        xmlCatalogDump(stdout);\n-    }\n-    }\n-\n-    \/*\n-     * Cleanup and check for memory leaks\n-     *\/\n-    xmlCleanupParser();\n-    return(exit_value);\n-}\n-#else\n-int main(int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED) {\n-    fprintf(stderr, \"libxml was not compiled with catalog and output support\\n\");\n-    return(1);\n-}\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlcatalog.c","additions":0,"deletions":614,"binary":false,"changes":614,"status":"deleted"},{"patch":"@@ -1,3792 +0,0 @@\n-\/*\n- * xmllint.c : a small tester program for XML input.\n- *\n- * See Copyright for the status of this software.\n- *\n- * daniel@veillard.com\n- *\/\n-\n-#include \"libxml.h\"\n-\n-#include <string.h>\n-#include <stdarg.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <assert.h>\n-#include <time.h>\n-#include <errno.h>\n-#include <limits.h>\n-\n-#ifdef HAVE_SYS_TIME_H\n-#include <sys\/time.h>\n-#endif\n-#ifdef HAVE_SYS_TIMEB_H\n-#include <sys\/timeb.h>\n-#endif\n-#ifdef HAVE_SYS_STAT_H\n-#include <sys\/stat.h>\n-#endif\n-#ifdef HAVE_FCNTL_H\n-#include <fcntl.h>\n-#endif\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#elif defined (_WIN32)\n-#include <io.h>\n-#endif\n-#ifdef HAVE_SYS_MMAN_H\n-#include <sys\/mman.h>\n-\/* seems needed for Solaris *\/\n-#ifndef MAP_FAILED\n-#define MAP_FAILED ((void *) -1)\n-#endif\n-#endif\n-#ifdef HAVE_LIBREADLINE\n-#include <readline\/readline.h>\n-#ifdef HAVE_LIBHISTORY\n-#include <readline\/history.h>\n-#endif\n-#endif\n-\n-#include <libxml\/xmlmemory.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/HTMLparser.h>\n-#include <libxml\/HTMLtree.h>\n-#include <libxml\/tree.h>\n-#include <libxml\/xpath.h>\n-#include <libxml\/debugXML.h>\n-#include <libxml\/xmlerror.h>\n-#ifdef LIBXML_XINCLUDE_ENABLED\n-#include <libxml\/xinclude.h>\n-#endif\n-#ifdef LIBXML_CATALOG_ENABLED\n-#include <libxml\/catalog.h>\n-#endif\n-#include <libxml\/xmlreader.h>\n-#ifdef LIBXML_SCHEMATRON_ENABLED\n-#include <libxml\/schematron.h>\n-#endif\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-#include <libxml\/relaxng.h>\n-#include <libxml\/xmlschemas.h>\n-#endif\n-#ifdef LIBXML_PATTERN_ENABLED\n-#include <libxml\/pattern.h>\n-#endif\n-#ifdef LIBXML_C14N_ENABLED\n-#include <libxml\/c14n.h>\n-#endif\n-#ifdef LIBXML_OUTPUT_ENABLED\n-#include <libxml\/xmlsave.h>\n-#endif\n-\n-#ifdef XMLLINT_FUZZ\n-  #define ERR_STREAM stdout\n-#else\n-  #define ERR_STREAM stderr\n-#endif\n-\n-#ifndef XML_XML_DEFAULT_CATALOG\n-#define XML_XML_DEFAULT_CATALOG \"file:\/\/\" SYSCONFDIR \"\/xml\/catalog\"\n-#endif\n-\n-#ifndef STDIN_FILENO\n-  #define STDIN_FILENO 0\n-#endif\n-\n-\/* Internal parser option *\/\n-#define XML_PARSE_UNZIP     (1 << 24)\n-\n-typedef enum {\n-    XMLLINT_RETURN_OK = 0,        \/* No error *\/\n-    XMLLINT_ERR_UNCLASS = 1,        \/* Unclassified *\/\n-    XMLLINT_ERR_DTD = 2,        \/* Error in DTD *\/\n-    XMLLINT_ERR_VALID = 3,        \/* Validation error *\/\n-    XMLLINT_ERR_RDFILE = 4,        \/* CtxtReadFile error *\/\n-    XMLLINT_ERR_SCHEMACOMP = 5,        \/* Schema compilation *\/\n-    XMLLINT_ERR_OUT = 6,        \/* Error writing output *\/\n-    XMLLINT_ERR_SCHEMAPAT = 7,        \/* Error in schema pattern *\/\n-    \/*XMLLINT_ERR_RDREGIS = 8,*\/\n-    XMLLINT_ERR_MEM = 9,        \/* Out of memory error *\/\n-    XMLLINT_ERR_XPATH = 10,        \/* XPath evaluation error *\/\n-    XMLLINT_ERR_XPATH_EMPTY = 11    \/* XPath result is empty *\/\n-} xmllintReturnCode;\n-\n-#ifdef LIBXML_DEBUG_ENABLED\n-static int shell = 0;\n-static int debugent = 0;\n-#endif\n-static int debug = 0;\n-static int maxmem = 0;\n-#ifdef LIBXML_TREE_ENABLED\n-static int copy = 0;\n-#endif \/* LIBXML_TREE_ENABLED *\/\n-static int noout = 0;\n-#ifdef LIBXML_OUTPUT_ENABLED\n-static const char *output = NULL;\n-static int format = 0;\n-static const char *encoding = NULL;\n-static int compress = 0;\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-#ifdef LIBXML_VALID_ENABLED\n-static int postvalid = 0;\n-static const char *dtdvalid = NULL;\n-static const char *dtdvalidfpi = NULL;\n-static int insert = 0;\n-#endif\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-static const char *relaxng = NULL;\n-static xmlRelaxNGPtr relaxngschemas = NULL;\n-static const char *schema = NULL;\n-static xmlSchemaPtr wxschemas = NULL;\n-#endif\n-#ifdef LIBXML_SCHEMATRON_ENABLED\n-static const char *schematron = NULL;\n-static xmlSchematronPtr wxschematron = NULL;\n-#endif\n-static int repeat = 0;\n-#if defined(LIBXML_HTML_ENABLED)\n-static int html = 0;\n-static int xmlout = 0;\n-#endif\n-static int htmlout = 0;\n-#ifdef LIBXML_PUSH_ENABLED\n-static int push = 0;\n-static int pushsize = 4096;\n-#endif \/* LIBXML_PUSH_ENABLED *\/\n-#ifdef HAVE_MMAP\n-static int memory = 0;\n-#endif\n-static int testIO = 0;\n-#ifdef LIBXML_XINCLUDE_ENABLED\n-static int xinclude = 0;\n-#endif\n-static xmllintReturnCode progresult = XMLLINT_RETURN_OK;\n-static int quiet = 0;\n-static int timing = 0;\n-static int generate = 0;\n-static int dropdtd = 0;\n-#ifdef LIBXML_C14N_ENABLED\n-static int canonical = 0;\n-static int canonical_11 = 0;\n-static int exc_canonical = 0;\n-#endif\n-#ifdef LIBXML_READER_ENABLED\n-static int walker = 0;\n-#ifdef LIBXML_PATTERN_ENABLED\n-static const char *pattern = NULL;\n-static xmlPatternPtr patternc = NULL;\n-static xmlStreamCtxtPtr patstream = NULL;\n-#endif\n-#endif \/* LIBXML_READER_ENABLED *\/\n-#ifdef LIBXML_XPATH_ENABLED\n-static const char *xpathquery = NULL;\n-#endif\n-static int options = XML_PARSE_COMPACT | XML_PARSE_BIG_LINES;\n-static unsigned maxAmpl = 0;\n-\n-\/************************************************************************\n- *                                    *\n- *         Entity loading control and customization.        *\n- *                                    *\n- ************************************************************************\/\n-#define MAX_PATHS 64\n-#ifdef _WIN32\n-# define PATH_SEPARATOR ';'\n-#else\n-# define PATH_SEPARATOR ':'\n-#endif\n-static xmlChar *paths[MAX_PATHS + 1];\n-static int nbpaths = 0;\n-static int load_trace = 0;\n-\n-static\n-void parsePath(const xmlChar *path) {\n-    const xmlChar *cur;\n-\n-    if (path == NULL)\n-    return;\n-    while (*path != 0) {\n-    if (nbpaths >= MAX_PATHS) {\n-        fprintf(ERR_STREAM, \"MAX_PATHS reached: too many paths\\n\");\n-        return;\n-    }\n-    cur = path;\n-    while ((*cur == ' ') || (*cur == PATH_SEPARATOR))\n-        cur++;\n-    path = cur;\n-    while ((*cur != 0) && (*cur != ' ') && (*cur != PATH_SEPARATOR))\n-        cur++;\n-    if (cur != path) {\n-        paths[nbpaths] = xmlStrndup(path, cur - path);\n-        if (paths[nbpaths] != NULL)\n-        nbpaths++;\n-        path = cur;\n-    }\n-    }\n-}\n-\n-static xmlExternalEntityLoader defaultEntityLoader = NULL;\n-\n-static xmlParserInputPtr\n-xmllintExternalEntityLoader(const char *URL, const char *ID,\n-                 xmlParserCtxtPtr ctxt) {\n-    xmlParserInputPtr ret;\n-    warningSAXFunc warning = NULL;\n-    errorSAXFunc err = NULL;\n-\n-    int i;\n-    const char *lastsegment = URL;\n-    const char *iter = URL;\n-\n-    if ((nbpaths > 0) && (iter != NULL)) {\n-    while (*iter != 0) {\n-        if (*iter == '\/')\n-        lastsegment = iter + 1;\n-        iter++;\n-    }\n-    }\n-\n-    if ((ctxt != NULL) && (ctxt->sax != NULL)) {\n-    warning = ctxt->sax->warning;\n-    err = ctxt->sax->error;\n-    ctxt->sax->warning = NULL;\n-    ctxt->sax->error = NULL;\n-    }\n-\n-    if (defaultEntityLoader != NULL) {\n-    ret = defaultEntityLoader(URL, ID, ctxt);\n-    if (ret != NULL) {\n-        if (warning != NULL)\n-        ctxt->sax->warning = warning;\n-        if (err != NULL)\n-        ctxt->sax->error = err;\n-        if (load_trace) {\n-        fprintf \\\n-            (ERR_STREAM,\n-             \"Loaded URL=\\\"%s\\\" ID=\\\"%s\\\"\\n\",\n-             URL ? URL : \"(null)\",\n-             ID ? ID : \"(null)\");\n-        }\n-        return(ret);\n-    }\n-    }\n-    for (i = 0;i < nbpaths;i++) {\n-    xmlChar *newURL;\n-\n-    newURL = xmlStrdup((const xmlChar *) paths[i]);\n-    newURL = xmlStrcat(newURL, (const xmlChar *) \"\/\");\n-    newURL = xmlStrcat(newURL, (const xmlChar *) lastsegment);\n-    if (newURL != NULL) {\n-        ret = defaultEntityLoader((const char *)newURL, ID, ctxt);\n-        if (ret != NULL) {\n-        if (warning != NULL)\n-            ctxt->sax->warning = warning;\n-        if (err != NULL)\n-            ctxt->sax->error = err;\n-        if (load_trace) {\n-            fprintf \\\n-            (ERR_STREAM,\n-             \"Loaded URL=\\\"%s\\\" ID=\\\"%s\\\"\\n\",\n-             newURL,\n-             ID ? ID : \"(null)\");\n-        }\n-        xmlFree(newURL);\n-        return(ret);\n-        }\n-        xmlFree(newURL);\n-    }\n-    }\n-    if (err != NULL)\n-        ctxt->sax->error = err;\n-    if (warning != NULL) {\n-    ctxt->sax->warning = warning;\n-    if (URL != NULL)\n-        warning(ctxt, \"failed to load external entity \\\"%s\\\"\\n\", URL);\n-    else if (ID != NULL)\n-        warning(ctxt, \"failed to load external entity \\\"%s\\\"\\n\", ID);\n-    }\n-    return(NULL);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- * Memory allocation consumption debugging                *\n- *                                    *\n- ************************************************************************\/\n-\n-static void\n-OOM(void)\n-{\n-    fprintf(ERR_STREAM, \"Ran out of memory needs > %d bytes\\n\", maxmem);\n-    progresult = XMLLINT_ERR_MEM;\n-}\n-\n-static void\n-myFreeFunc(void *mem)\n-{\n-    xmlMemFree(mem);\n-}\n-static void *\n-myMallocFunc(size_t size)\n-{\n-    void *ret;\n-\n-    ret = xmlMemMalloc(size);\n-    if (ret != NULL) {\n-        if (xmlMemUsed() > maxmem) {\n-            OOM();\n-            xmlMemFree(ret);\n-            return (NULL);\n-        }\n-    }\n-    return (ret);\n-}\n-static void *\n-myReallocFunc(void *mem, size_t size)\n-{\n-    size_t oldsize = xmlMemSize(mem);\n-\n-    if (xmlMemUsed() + size - oldsize > (size_t) maxmem) {\n-        OOM();\n-        return (NULL);\n-    }\n-\n-    return (xmlMemRealloc(mem, size));\n-}\n-static char *\n-myStrdupFunc(const char *str)\n-{\n-    char *ret;\n-\n-    ret = xmlMemoryStrdup(str);\n-    if (ret != NULL) {\n-        if (xmlMemUsed() > maxmem) {\n-            OOM();\n-            xmlMemFree(ret);\n-            return (NULL);\n-        }\n-    }\n-    return (ret);\n-}\n-\/************************************************************************\n- *                                    *\n- * Internal timing routines to remove the necessity to have        *\n- * unix-specific function calls.                    *\n- *                                    *\n- ************************************************************************\/\n-\n-#ifndef HAVE_GETTIMEOFDAY\n-#ifdef HAVE_SYS_TIMEB_H\n-#ifdef HAVE_SYS_TIME_H\n-#ifdef HAVE_FTIME\n-\n-static int\n-my_gettimeofday(struct timeval *tvp, void *tzp)\n-{\n-    struct timeb timebuffer;\n-\n-    ftime(&timebuffer);\n-    if (tvp) {\n-        tvp->tv_sec = timebuffer.time;\n-        tvp->tv_usec = timebuffer.millitm * 1000L;\n-    }\n-    return (0);\n-}\n-#define HAVE_GETTIMEOFDAY 1\n-#define gettimeofday my_gettimeofday\n-\n-#endif \/* HAVE_FTIME *\/\n-#endif \/* HAVE_SYS_TIME_H *\/\n-#endif \/* HAVE_SYS_TIMEB_H *\/\n-#endif \/* !HAVE_GETTIMEOFDAY *\/\n-\n-#if defined(HAVE_GETTIMEOFDAY)\n-static struct timeval begin, end;\n-\n-\/*\n- * startTimer: call where you want to start timing\n- *\/\n-static void\n-startTimer(void)\n-{\n-    gettimeofday(&begin, NULL);\n-}\n-\n-\/*\n- * endTimer: call where you want to stop timing and to print out a\n- *           message about the timing performed; format is a printf\n- *           type argument\n- *\/\n-static void LIBXML_ATTR_FORMAT(1,2)\n-endTimer(const char *fmt, ...)\n-{\n-    long msec;\n-    va_list ap;\n-\n-    gettimeofday(&end, NULL);\n-    msec = end.tv_sec - begin.tv_sec;\n-    msec *= 1000;\n-    msec += (end.tv_usec - begin.tv_usec) \/ 1000;\n-\n-    va_start(ap, fmt);\n-    vfprintf(ERR_STREAM, fmt, ap);\n-    va_end(ap);\n-\n-    fprintf(ERR_STREAM, \" took %ld ms\\n\", msec);\n-}\n-#else\n-\/*\n- * No gettimeofday function, so we have to make do with calling clock.\n- * This is obviously less accurate, but there's little we can do about\n- * that.\n- *\/\n-#ifndef CLOCKS_PER_SEC\n-#define CLOCKS_PER_SEC 100\n-#endif\n-\n-static clock_t begin, end;\n-static void\n-startTimer(void)\n-{\n-    begin = clock();\n-}\n-static void LIBXML_ATTR_FORMAT(1,2)\n-endTimer(const char *fmt, ...)\n-{\n-    long msec;\n-    va_list ap;\n-\n-    end = clock();\n-    msec = ((end - begin) * 1000) \/ CLOCKS_PER_SEC;\n-\n-    va_start(ap, fmt);\n-    vfprintf(ERR_STREAM, fmt, ap);\n-    va_end(ap);\n-    fprintf(ERR_STREAM, \" took %ld ms\\n\", msec);\n-}\n-#endif\n-\/************************************************************************\n- *                                    *\n- *            HTML output                    *\n- *                                    *\n- ************************************************************************\/\n-static char buffer[50000];\n-\n-static void\n-xmlHTMLEncodeSend(void) {\n-    char *result;\n-\n-    \/*\n-     * xmlEncodeEntitiesReentrant assumes valid UTF-8, but the buffer might\n-     * end with a truncated UTF-8 sequence. This is a hack to at least avoid\n-     * an out-of-bounds read.\n-     *\/\n-    memset(&buffer[sizeof(buffer)-4], 0, 4);\n-    result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer);\n-    if (result) {\n-    fprintf(ERR_STREAM, \"%s\", result);\n-    xmlFree(result);\n-    }\n-    buffer[0] = 0;\n-}\n-\n-\/**\n- * xmlHTMLPrintFileInfo:\n- * @input:  an xmlParserInputPtr input\n- *\n- * Displays the associated file and line information for the current input\n- *\/\n-\n-static void\n-xmlHTMLPrintFileInfo(xmlParserInputPtr input) {\n-    int len;\n-    fprintf(ERR_STREAM, \"<p>\");\n-\n-    len = strlen(buffer);\n-    if (input != NULL) {\n-    if (input->filename) {\n-        snprintf(&buffer[len], sizeof(buffer) - len, \"%s:%d: \", input->filename,\n-            input->line);\n-    } else {\n-        snprintf(&buffer[len], sizeof(buffer) - len, \"Entity: line %d: \", input->line);\n-    }\n-    }\n-    xmlHTMLEncodeSend();\n-}\n-\n-\/**\n- * xmlHTMLPrintFileContext:\n- * @input:  an xmlParserInputPtr input\n- *\n- * Displays current context within the input content for error tracking\n- *\/\n-\n-static void\n-xmlHTMLPrintFileContext(xmlParserInputPtr input) {\n-    const xmlChar *cur, *base;\n-    int len;\n-    int n;\n-\n-    if (input == NULL) return;\n-    fprintf(ERR_STREAM, \"<pre>\\n\");\n-    cur = input->cur;\n-    base = input->base;\n-    while ((cur > base) && ((*cur == '\\n') || (*cur == '\\r'))) {\n-    cur--;\n-    }\n-    n = 0;\n-    while ((n++ < 80) && (cur > base) && (*cur != '\\n') && (*cur != '\\r'))\n-        cur--;\n-    if ((*cur == '\\n') || (*cur == '\\r')) cur++;\n-    base = cur;\n-    n = 0;\n-    while ((*cur != 0) && (*cur != '\\n') && (*cur != '\\r') && (n < 79)) {\n-    len = strlen(buffer);\n-        snprintf(&buffer[len], sizeof(buffer) - len, \"%c\",\n-            (unsigned char) *cur++);\n-    n++;\n-    }\n-    len = strlen(buffer);\n-    snprintf(&buffer[len], sizeof(buffer) - len, \"\\n\");\n-    cur = input->cur;\n-    while ((cur > base) && ((*cur == '\\n') || (*cur == '\\r')))\n-    cur--;\n-    n = 0;\n-    while ((cur != base) && (n++ < 80)) {\n-    len = strlen(buffer);\n-        snprintf(&buffer[len], sizeof(buffer) - len, \" \");\n-        base++;\n-    }\n-    len = strlen(buffer);\n-    snprintf(&buffer[len], sizeof(buffer) - len, \"^\\n\");\n-    xmlHTMLEncodeSend();\n-    fprintf(ERR_STREAM, \"<\/pre>\");\n-}\n-\n-\/**\n- * xmlHTMLError:\n- * @ctx:  an XML parser context\n- * @msg:  the message to display\/transmit\n- * @...:  extra parameters for the message display\n- *\n- * Display and format an error messages, gives file, line, position and\n- * extra parameters.\n- *\/\n-static void LIBXML_ATTR_FORMAT(2,3)\n-xmlHTMLError(void *ctx, const char *msg, ...)\n-{\n-    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;\n-    xmlParserInputPtr input;\n-    va_list args;\n-    int len;\n-\n-    buffer[0] = 0;\n-    input = ctxt->input;\n-    if ((input != NULL) && (input->filename == NULL) && (ctxt->inputNr > 1)) {\n-        input = ctxt->inputTab[ctxt->inputNr - 2];\n-    }\n-\n-    xmlHTMLPrintFileInfo(input);\n-\n-    fprintf(ERR_STREAM, \"<b>error<\/b>: \");\n-    va_start(args, msg);\n-    len = strlen(buffer);\n-    vsnprintf(&buffer[len],  sizeof(buffer) - len, msg, args);\n-    va_end(args);\n-    xmlHTMLEncodeSend();\n-    fprintf(ERR_STREAM, \"<\/p>\\n\");\n-\n-    xmlHTMLPrintFileContext(input);\n-    xmlHTMLEncodeSend();\n-}\n-\n-\/**\n- * xmlHTMLWarning:\n- * @ctx:  an XML parser context\n- * @msg:  the message to display\/transmit\n- * @...:  extra parameters for the message display\n- *\n- * Display and format a warning messages, gives file, line, position and\n- * extra parameters.\n- *\/\n-static void LIBXML_ATTR_FORMAT(2,3)\n-xmlHTMLWarning(void *ctx, const char *msg, ...)\n-{\n-    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;\n-    xmlParserInputPtr input;\n-    va_list args;\n-    int len;\n-\n-    buffer[0] = 0;\n-    input = ctxt->input;\n-    if ((input != NULL) && (input->filename == NULL) && (ctxt->inputNr > 1)) {\n-        input = ctxt->inputTab[ctxt->inputNr - 2];\n-    }\n-\n-\n-    xmlHTMLPrintFileInfo(input);\n-\n-    fprintf(ERR_STREAM, \"<b>warning<\/b>: \");\n-    va_start(args, msg);\n-    len = strlen(buffer);\n-    vsnprintf(&buffer[len],  sizeof(buffer) - len, msg, args);\n-    va_end(args);\n-    xmlHTMLEncodeSend();\n-    fprintf(ERR_STREAM, \"<\/p>\\n\");\n-\n-    xmlHTMLPrintFileContext(input);\n-    xmlHTMLEncodeSend();\n-}\n-\n-\/**\n- * xmlHTMLValidityError:\n- * @ctx:  an XML parser context\n- * @msg:  the message to display\/transmit\n- * @...:  extra parameters for the message display\n- *\n- * Display and format an validity error messages, gives file,\n- * line, position and extra parameters.\n- *\/\n-static void LIBXML_ATTR_FORMAT(2,3)\n-xmlHTMLValidityError(void *ctx, const char *msg, ...)\n-{\n-    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;\n-    xmlParserInputPtr input;\n-    va_list args;\n-    int len;\n-\n-    buffer[0] = 0;\n-    input = ctxt->input;\n-\n-    if (input != NULL) {\n-        if ((input->filename == NULL) && (ctxt->inputNr > 1))\n-            input = ctxt->inputTab[ctxt->inputNr - 2];\n-\n-        xmlHTMLPrintFileInfo(input);\n-    }\n-\n-    fprintf(ERR_STREAM, \"<b>validity error<\/b>: \");\n-    len = strlen(buffer);\n-    va_start(args, msg);\n-    vsnprintf(&buffer[len],  sizeof(buffer) - len, msg, args);\n-    va_end(args);\n-    xmlHTMLEncodeSend();\n-    fprintf(ERR_STREAM, \"<\/p>\\n\");\n-\n-    if (input != NULL)\n-        xmlHTMLPrintFileContext(input);\n-    xmlHTMLEncodeSend();\n-    progresult = XMLLINT_ERR_VALID;\n-}\n-\n-\/**\n- * xmlHTMLValidityWarning:\n- * @ctx:  an XML parser context\n- * @msg:  the message to display\/transmit\n- * @...:  extra parameters for the message display\n- *\n- * Display and format a validity warning messages, gives file, line,\n- * position and extra parameters.\n- *\/\n-static void LIBXML_ATTR_FORMAT(2,3)\n-xmlHTMLValidityWarning(void *ctx, const char *msg, ...)\n-{\n-    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;\n-    xmlParserInputPtr input;\n-    va_list args;\n-    int len;\n-\n-    buffer[0] = 0;\n-    input = ctxt->input;\n-    if ((input->filename == NULL) && (ctxt->inputNr > 1))\n-        input = ctxt->inputTab[ctxt->inputNr - 2];\n-\n-    xmlHTMLPrintFileInfo(input);\n-\n-    fprintf(ERR_STREAM, \"<b>validity warning<\/b>: \");\n-    va_start(args, msg);\n-    len = strlen(buffer);\n-    vsnprintf(&buffer[len],  sizeof(buffer) - len, msg, args);\n-    va_end(args);\n-    xmlHTMLEncodeSend();\n-    fprintf(ERR_STREAM, \"<\/p>\\n\");\n-\n-    xmlHTMLPrintFileContext(input);\n-    xmlHTMLEncodeSend();\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Shell Interface                    *\n- *                                    *\n- ************************************************************************\/\n-#ifdef LIBXML_DEBUG_ENABLED\n-#ifdef LIBXML_XPATH_ENABLED\n-\/**\n- * xmlShellReadline:\n- * @prompt:  the prompt value\n- *\n- * Read a string\n- *\n- * Returns a pointer to it or NULL on EOF the caller is expected to\n- *     free the returned string.\n- *\/\n-static char *\n-xmlShellReadline(char *prompt) {\n-#ifdef HAVE_LIBREADLINE\n-    char *line_read;\n-\n-    \/* Get a line from the user. *\/\n-    line_read = readline (prompt);\n-\n-    \/* If the line has any text in it, save it on the history. *\/\n-    if (line_read && *line_read)\n-    add_history (line_read);\n-\n-    return (line_read);\n-#else\n-    char line_read[501];\n-    char *ret;\n-    int len;\n-\n-    if (prompt != NULL)\n-    fprintf(stdout, \"%s\", prompt);\n-    fflush(stdout);\n-    if (!fgets(line_read, 500, stdin))\n-        return(NULL);\n-    line_read[500] = 0;\n-    len = strlen(line_read);\n-    ret = (char *) malloc(len + 1);\n-    if (ret != NULL) {\n-    memcpy (ret, line_read, len + 1);\n-    }\n-    return(ret);\n-#endif\n-}\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-#endif \/* LIBXML_DEBUG_ENABLED *\/\n-\n-\/************************************************************************\n- *                                    *\n- *            I\/O Interfaces                    *\n- *                                    *\n- ************************************************************************\/\n-\n-static int myRead(void *f, char *buf, int len) {\n-    return(fread(buf, 1, len, (FILE *) f));\n-}\n-static int myClose(void *context) {\n-    FILE *f = (FILE *) context;\n-    if (f == stdin)\n-        return(0);\n-    return(fclose(f));\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            SAX based tests                    *\n- *                                    *\n- ************************************************************************\/\n-\n-\/*\n- * empty SAX block\n- *\/\n-static xmlSAXHandler emptySAXHandlerStruct = {\n-    NULL, \/* internalSubset *\/\n-    NULL, \/* isStandalone *\/\n-    NULL, \/* hasInternalSubset *\/\n-    NULL, \/* hasExternalSubset *\/\n-    NULL, \/* resolveEntity *\/\n-    NULL, \/* getEntity *\/\n-    NULL, \/* entityDecl *\/\n-    NULL, \/* notationDecl *\/\n-    NULL, \/* attributeDecl *\/\n-    NULL, \/* elementDecl *\/\n-    NULL, \/* unparsedEntityDecl *\/\n-    NULL, \/* setDocumentLocator *\/\n-    NULL, \/* startDocument *\/\n-    NULL, \/* endDocument *\/\n-    NULL, \/* startElement *\/\n-    NULL, \/* endElement *\/\n-    NULL, \/* reference *\/\n-    NULL, \/* characters *\/\n-    NULL, \/* ignorableWhitespace *\/\n-    NULL, \/* processingInstruction *\/\n-    NULL, \/* comment *\/\n-    NULL, \/* xmlParserWarning *\/\n-    NULL, \/* xmlParserError *\/\n-    NULL, \/* xmlParserError *\/\n-    NULL, \/* getParameterEntity *\/\n-    NULL, \/* cdataBlock; *\/\n-    NULL, \/* externalSubset; *\/\n-    XML_SAX2_MAGIC,\n-    NULL,\n-    NULL, \/* startElementNs *\/\n-    NULL, \/* endElementNs *\/\n-    NULL  \/* xmlStructuredErrorFunc *\/\n-};\n-\n-static xmlSAXHandlerPtr emptySAXHandler = &emptySAXHandlerStruct;\n-extern xmlSAXHandlerPtr debugSAXHandler;\n-static int callbacks;\n-\n-\/**\n- * isStandaloneDebug:\n- * @ctxt:  An XML parser context\n- *\n- * Is this document tagged standalone ?\n- *\n- * Returns 1 if true\n- *\/\n-static int\n-isStandaloneDebug(void *ctx ATTRIBUTE_UNUSED)\n-{\n-    callbacks++;\n-    if (noout)\n-    return(0);\n-    fprintf(stdout, \"SAX.isStandalone()\\n\");\n-    return(0);\n-}\n-\n-\/**\n- * hasInternalSubsetDebug:\n- * @ctxt:  An XML parser context\n- *\n- * Does this document has an internal subset\n- *\n- * Returns 1 if true\n- *\/\n-static int\n-hasInternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)\n-{\n-    callbacks++;\n-    if (noout)\n-    return(0);\n-    fprintf(stdout, \"SAX.hasInternalSubset()\\n\");\n-    return(0);\n-}\n-\n-\/**\n- * hasExternalSubsetDebug:\n- * @ctxt:  An XML parser context\n- *\n- * Does this document has an external subset\n- *\n- * Returns 1 if true\n- *\/\n-static int\n-hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)\n-{\n-    callbacks++;\n-    if (noout)\n-    return(0);\n-    fprintf(stdout, \"SAX.hasExternalSubset()\\n\");\n-    return(0);\n-}\n-\n-\/**\n- * internalSubsetDebug:\n- * @ctxt:  An XML parser context\n- *\n- * Does this document has an internal subset\n- *\/\n-static void\n-internalSubsetDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name,\n-           const xmlChar *ExternalID, const xmlChar *SystemID)\n-{\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.internalSubset(%s,\", name);\n-    if (ExternalID == NULL)\n-    fprintf(stdout, \" ,\");\n-    else\n-    fprintf(stdout, \" %s,\", ExternalID);\n-    if (SystemID == NULL)\n-    fprintf(stdout, \" )\\n\");\n-    else\n-    fprintf(stdout, \" %s)\\n\", SystemID);\n-}\n-\n-\/**\n- * externalSubsetDebug:\n- * @ctxt:  An XML parser context\n- *\n- * Does this document has an external subset\n- *\/\n-static void\n-externalSubsetDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name,\n-           const xmlChar *ExternalID, const xmlChar *SystemID)\n-{\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.externalSubset(%s,\", name);\n-    if (ExternalID == NULL)\n-    fprintf(stdout, \" ,\");\n-    else\n-    fprintf(stdout, \" %s,\", ExternalID);\n-    if (SystemID == NULL)\n-    fprintf(stdout, \" )\\n\");\n-    else\n-    fprintf(stdout, \" %s)\\n\", SystemID);\n-}\n-\n-\/**\n- * resolveEntityDebug:\n- * @ctxt:  An XML parser context\n- * @publicId: The public ID of the entity\n- * @systemId: The system ID of the entity\n- *\n- * Special entity resolver, better left to the parser, it has\n- * more context than the application layer.\n- * The default behaviour is to NOT resolve the entities, in that case\n- * the ENTITY_REF nodes are built in the structure (and the parameter\n- * values).\n- *\n- * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.\n- *\/\n-static xmlParserInputPtr\n-resolveEntityDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *publicId, const xmlChar *systemId)\n-{\n-    callbacks++;\n-    if (noout)\n-    return(NULL);\n-    \/* xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; *\/\n-\n-\n-    fprintf(stdout, \"SAX.resolveEntity(\");\n-    if (publicId != NULL)\n-    fprintf(stdout, \"%s\", (char *)publicId);\n-    else\n-    fprintf(stdout, \" \");\n-    if (systemId != NULL)\n-    fprintf(stdout, \", %s)\\n\", (char *)systemId);\n-    else\n-    fprintf(stdout, \", )\\n\");\n-    return(NULL);\n-}\n-\n-\/**\n- * getEntityDebug:\n- * @ctxt:  An XML parser context\n- * @name: The entity name\n- *\n- * Get an entity by name\n- *\n- * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.\n- *\/\n-static xmlEntityPtr\n-getEntityDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name)\n-{\n-    callbacks++;\n-    if (noout)\n-    return(NULL);\n-    fprintf(stdout, \"SAX.getEntity(%s)\\n\", name);\n-    return(NULL);\n-}\n-\n-\/**\n- * getParameterEntityDebug:\n- * @ctxt:  An XML parser context\n- * @name: The entity name\n- *\n- * Get a parameter entity by name\n- *\n- * Returns the xmlParserInputPtr\n- *\/\n-static xmlEntityPtr\n-getParameterEntityDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name)\n-{\n-    callbacks++;\n-    if (noout)\n-    return(NULL);\n-    fprintf(stdout, \"SAX.getParameterEntity(%s)\\n\", name);\n-    return(NULL);\n-}\n-\n-\n-\/**\n- * entityDeclDebug:\n- * @ctxt:  An XML parser context\n- * @name:  the entity name\n- * @type:  the entity type\n- * @publicId: The public ID of the entity\n- * @systemId: The system ID of the entity\n- * @content: the entity value (without processing).\n- *\n- * An entity definition has been parsed\n- *\/\n-static void\n-entityDeclDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, int type,\n-          const xmlChar *publicId, const xmlChar *systemId, xmlChar *content)\n-{\n-const xmlChar *nullstr = BAD_CAST \"(null)\";\n-    \/* not all libraries handle printing null pointers nicely *\/\n-    if (publicId == NULL)\n-        publicId = nullstr;\n-    if (systemId == NULL)\n-        systemId = nullstr;\n-    if (content == NULL)\n-        content = (xmlChar *)nullstr;\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.entityDecl(%s, %d, %s, %s, %s)\\n\",\n-            name, type, publicId, systemId, content);\n-}\n-\n-\/**\n- * attributeDeclDebug:\n- * @ctxt:  An XML parser context\n- * @name:  the attribute name\n- * @type:  the attribute type\n- *\n- * An attribute definition has been parsed\n- *\/\n-static void\n-attributeDeclDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar * elem,\n-                   const xmlChar * name, int type, int def,\n-                   const xmlChar * defaultValue, xmlEnumerationPtr tree)\n-{\n-    callbacks++;\n-    if (noout)\n-        return;\n-    if (defaultValue == NULL)\n-        fprintf(stdout, \"SAX.attributeDecl(%s, %s, %d, %d, NULL, ...)\\n\",\n-                elem, name, type, def);\n-    else\n-        fprintf(stdout, \"SAX.attributeDecl(%s, %s, %d, %d, %s, ...)\\n\",\n-                elem, name, type, def, defaultValue);\n-    xmlFreeEnumeration(tree);\n-}\n-\n-\/**\n- * elementDeclDebug:\n- * @ctxt:  An XML parser context\n- * @name:  the element name\n- * @type:  the element type\n- * @content: the element value (without processing).\n- *\n- * An element definition has been parsed\n- *\/\n-static void\n-elementDeclDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, int type,\n-        xmlElementContentPtr content ATTRIBUTE_UNUSED)\n-{\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.elementDecl(%s, %d, ...)\\n\",\n-            name, type);\n-}\n-\n-\/**\n- * notationDeclDebug:\n- * @ctxt:  An XML parser context\n- * @name: The name of the notation\n- * @publicId: The public ID of the entity\n- * @systemId: The system ID of the entity\n- *\n- * What to do when a notation declaration has been parsed.\n- *\/\n-static void\n-notationDeclDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name,\n-         const xmlChar *publicId, const xmlChar *systemId)\n-{\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.notationDecl(%s, %s, %s)\\n\",\n-            (char *) name, (char *) publicId, (char *) systemId);\n-}\n-\n-\/**\n- * unparsedEntityDeclDebug:\n- * @ctxt:  An XML parser context\n- * @name: The name of the entity\n- * @publicId: The public ID of the entity\n- * @systemId: The system ID of the entity\n- * @notationName: the name of the notation\n- *\n- * What to do when an unparsed entity declaration is parsed\n- *\/\n-static void\n-unparsedEntityDeclDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name,\n-           const xmlChar *publicId, const xmlChar *systemId,\n-           const xmlChar *notationName)\n-{\n-const xmlChar *nullstr = BAD_CAST \"(null)\";\n-\n-    if (publicId == NULL)\n-        publicId = nullstr;\n-    if (systemId == NULL)\n-        systemId = nullstr;\n-    if (notationName == NULL)\n-        notationName = nullstr;\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.unparsedEntityDecl(%s, %s, %s, %s)\\n\",\n-            (char *) name, (char *) publicId, (char *) systemId,\n-        (char *) notationName);\n-}\n-\n-\/**\n- * setDocumentLocatorDebug:\n- * @ctxt:  An XML parser context\n- * @loc: A SAX Locator\n- *\n- * Receive the document locator at startup, actually xmlDefaultSAXLocator\n- * Everything is available on the context, so this is useless in our case.\n- *\/\n-static void\n-setDocumentLocatorDebug(void *ctx ATTRIBUTE_UNUSED, xmlSAXLocatorPtr loc ATTRIBUTE_UNUSED)\n-{\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.setDocumentLocator()\\n\");\n-}\n-\n-\/**\n- * startDocumentDebug:\n- * @ctxt:  An XML parser context\n- *\n- * called when the document start being processed.\n- *\/\n-static void\n-startDocumentDebug(void *ctx ATTRIBUTE_UNUSED)\n-{\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.startDocument()\\n\");\n-}\n-\n-\/**\n- * endDocumentDebug:\n- * @ctxt:  An XML parser context\n- *\n- * called when the document end has been detected.\n- *\/\n-static void\n-endDocumentDebug(void *ctx ATTRIBUTE_UNUSED)\n-{\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.endDocument()\\n\");\n-}\n-\n-\/**\n- * startElementDebug:\n- * @ctxt:  An XML parser context\n- * @name:  The element name\n- *\n- * called when an opening tag has been processed.\n- *\/\n-static void\n-startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)\n-{\n-    int i;\n-\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.startElement(%s\", (char *) name);\n-    if (atts != NULL) {\n-        for (i = 0;(atts[i] != NULL);i++) {\n-        fprintf(stdout, \", %s='\", atts[i++]);\n-        if (atts[i] != NULL)\n-            fprintf(stdout, \"%s'\", atts[i]);\n-    }\n-    }\n-    fprintf(stdout, \")\\n\");\n-}\n-\n-\/**\n- * endElementDebug:\n- * @ctxt:  An XML parser context\n- * @name:  The element name\n- *\n- * called when the end of an element has been detected.\n- *\/\n-static void\n-endElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name)\n-{\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.endElement(%s)\\n\", (char *) name);\n-}\n-\n-\/**\n- * charactersDebug:\n- * @ctxt:  An XML parser context\n- * @ch:  a xmlChar string\n- * @len: the number of xmlChar\n- *\n- * receiving some chars from the parser.\n- * Question: how much at a time ???\n- *\/\n-static void\n-charactersDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *ch, int len)\n-{\n-    char out[40];\n-    int i;\n-\n-    callbacks++;\n-    if (noout)\n-    return;\n-    for (i = 0;(i<len) && (i < 30);i++)\n-    out[i] = (char) ch[i];\n-    out[i] = 0;\n-\n-    fprintf(stdout, \"SAX.characters(%s, %d)\\n\", out, len);\n-}\n-\n-\/**\n- * referenceDebug:\n- * @ctxt:  An XML parser context\n- * @name:  The entity name\n- *\n- * called when an entity reference is detected.\n- *\/\n-static void\n-referenceDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name)\n-{\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.reference(%s)\\n\", name);\n-}\n-\n-\/**\n- * ignorableWhitespaceDebug:\n- * @ctxt:  An XML parser context\n- * @ch:  a xmlChar string\n- * @start: the first char in the string\n- * @len: the number of xmlChar\n- *\n- * receiving some ignorable whitespaces from the parser.\n- * Question: how much at a time ???\n- *\/\n-static void\n-ignorableWhitespaceDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *ch, int len)\n-{\n-    char out[40];\n-    int i;\n-\n-    callbacks++;\n-    if (noout)\n-    return;\n-    for (i = 0;(i<len) && (i < 30);i++)\n-    out[i] = ch[i];\n-    out[i] = 0;\n-    fprintf(stdout, \"SAX.ignorableWhitespace(%s, %d)\\n\", out, len);\n-}\n-\n-\/**\n- * processingInstructionDebug:\n- * @ctxt:  An XML parser context\n- * @target:  the target name\n- * @data: the PI data's\n- * @len: the number of xmlChar\n- *\n- * A processing instruction has been parsed.\n- *\/\n-static void\n-processingInstructionDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *target,\n-                      const xmlChar *data)\n-{\n-    callbacks++;\n-    if (noout)\n-    return;\n-    if (data != NULL)\n-    fprintf(stdout, \"SAX.processingInstruction(%s, %s)\\n\",\n-        (char *) target, (char *) data);\n-    else\n-    fprintf(stdout, \"SAX.processingInstruction(%s, NULL)\\n\",\n-        (char *) target);\n-}\n-\n-\/**\n- * cdataBlockDebug:\n- * @ctx: the user data (XML parser context)\n- * @value:  The pcdata content\n- * @len:  the block length\n- *\n- * called when a pcdata block has been parsed\n- *\/\n-static void\n-cdataBlockDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *value, int len)\n-{\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.pcdata(%.20s, %d)\\n\",\n-        (char *) value, len);\n-}\n-\n-\/**\n- * commentDebug:\n- * @ctxt:  An XML parser context\n- * @value:  the comment content\n- *\n- * A comment has been parsed.\n- *\/\n-static void\n-commentDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *value)\n-{\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.comment(%s)\\n\", value);\n-}\n-\n-\/**\n- * warningDebug:\n- * @ctxt:  An XML parser context\n- * @msg:  the message to display\/transmit\n- * @...:  extra parameters for the message display\n- *\n- * Display and format a warning messages, gives file, line, position and\n- * extra parameters.\n- *\/\n-static void LIBXML_ATTR_FORMAT(2,3)\n-warningDebug(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...)\n-{\n-    va_list args;\n-\n-    callbacks++;\n-    if (noout)\n-    return;\n-    va_start(args, msg);\n-    fprintf(stdout, \"SAX.warning: \");\n-    vfprintf(stdout, msg, args);\n-    va_end(args);\n-}\n-\n-\/**\n- * errorDebug:\n- * @ctxt:  An XML parser context\n- * @msg:  the message to display\/transmit\n- * @...:  extra parameters for the message display\n- *\n- * Display and format a error messages, gives file, line, position and\n- * extra parameters.\n- *\/\n-static void LIBXML_ATTR_FORMAT(2,3)\n-errorDebug(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...)\n-{\n-    va_list args;\n-\n-    callbacks++;\n-    if (noout)\n-    return;\n-    va_start(args, msg);\n-    fprintf(stdout, \"SAX.error: \");\n-    vfprintf(stdout, msg, args);\n-    va_end(args);\n-}\n-\n-\/**\n- * fatalErrorDebug:\n- * @ctxt:  An XML parser context\n- * @msg:  the message to display\/transmit\n- * @...:  extra parameters for the message display\n- *\n- * Display and format a fatalError messages, gives file, line, position and\n- * extra parameters.\n- *\/\n-static void LIBXML_ATTR_FORMAT(2,3)\n-fatalErrorDebug(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...)\n-{\n-    va_list args;\n-\n-    callbacks++;\n-    if (noout)\n-    return;\n-    va_start(args, msg);\n-    fprintf(stdout, \"SAX.fatalError: \");\n-    vfprintf(stdout, msg, args);\n-    va_end(args);\n-}\n-\n-static xmlSAXHandler debugSAXHandlerStruct = {\n-    internalSubsetDebug,\n-    isStandaloneDebug,\n-    hasInternalSubsetDebug,\n-    hasExternalSubsetDebug,\n-    resolveEntityDebug,\n-    getEntityDebug,\n-    entityDeclDebug,\n-    notationDeclDebug,\n-    attributeDeclDebug,\n-    elementDeclDebug,\n-    unparsedEntityDeclDebug,\n-    setDocumentLocatorDebug,\n-    startDocumentDebug,\n-    endDocumentDebug,\n-    startElementDebug,\n-    endElementDebug,\n-    referenceDebug,\n-    charactersDebug,\n-    ignorableWhitespaceDebug,\n-    processingInstructionDebug,\n-    commentDebug,\n-    warningDebug,\n-    errorDebug,\n-    fatalErrorDebug,\n-    getParameterEntityDebug,\n-    cdataBlockDebug,\n-    externalSubsetDebug,\n-    1,\n-    NULL,\n-    NULL,\n-    NULL,\n-    NULL\n-};\n-\n-xmlSAXHandlerPtr debugSAXHandler = &debugSAXHandlerStruct;\n-\n-\/*\n- * SAX2 specific callbacks\n- *\/\n-\/**\n- * startElementNsDebug:\n- * @ctxt:  An XML parser context\n- * @name:  The element name\n- *\n- * called when an opening tag has been processed.\n- *\/\n-static void\n-startElementNsDebug(void *ctx ATTRIBUTE_UNUSED,\n-                    const xmlChar *localname,\n-                    const xmlChar *prefix,\n-                    const xmlChar *URI,\n-            int nb_namespaces,\n-            const xmlChar **namespaces,\n-            int nb_attributes,\n-            int nb_defaulted,\n-            const xmlChar **attributes)\n-{\n-    int i;\n-\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.startElementNs(%s\", (char *) localname);\n-    if (prefix == NULL)\n-    fprintf(stdout, \", NULL\");\n-    else\n-    fprintf(stdout, \", %s\", (char *) prefix);\n-    if (URI == NULL)\n-    fprintf(stdout, \", NULL\");\n-    else\n-    fprintf(stdout, \", '%s'\", (char *) URI);\n-    fprintf(stdout, \", %d\", nb_namespaces);\n-\n-    if (namespaces != NULL) {\n-        for (i = 0;i < nb_namespaces * 2;i++) {\n-        fprintf(stdout, \", xmlns\");\n-        if (namespaces[i] != NULL)\n-            fprintf(stdout, \":%s\", namespaces[i]);\n-        i++;\n-        fprintf(stdout, \"='%s'\", namespaces[i]);\n-    }\n-    }\n-    fprintf(stdout, \", %d, %d\", nb_attributes, nb_defaulted);\n-    if (attributes != NULL) {\n-        for (i = 0;i < nb_attributes * 5;i += 5) {\n-        if (attributes[i + 1] != NULL)\n-        fprintf(stdout, \", %s:%s='\", attributes[i + 1], attributes[i]);\n-        else\n-        fprintf(stdout, \", %s='\", attributes[i]);\n-        fprintf(stdout, \"%.4s...', %d\", attributes[i + 3],\n-            (int)(attributes[i + 4] - attributes[i + 3]));\n-    }\n-    }\n-    fprintf(stdout, \")\\n\");\n-}\n-\n-\/**\n- * endElementDebug:\n- * @ctxt:  An XML parser context\n- * @name:  The element name\n- *\n- * called when the end of an element has been detected.\n- *\/\n-static void\n-endElementNsDebug(void *ctx ATTRIBUTE_UNUSED,\n-                  const xmlChar *localname,\n-                  const xmlChar *prefix,\n-                  const xmlChar *URI)\n-{\n-    callbacks++;\n-    if (noout)\n-    return;\n-    fprintf(stdout, \"SAX.endElementNs(%s\", (char *) localname);\n-    if (prefix == NULL)\n-    fprintf(stdout, \", NULL\");\n-    else\n-    fprintf(stdout, \", %s\", (char *) prefix);\n-    if (URI == NULL)\n-    fprintf(stdout, \", NULL)\\n\");\n-    else\n-    fprintf(stdout, \", '%s')\\n\", (char *) URI);\n-}\n-\n-static xmlSAXHandler debugSAX2HandlerStruct = {\n-    internalSubsetDebug,\n-    isStandaloneDebug,\n-    hasInternalSubsetDebug,\n-    hasExternalSubsetDebug,\n-    resolveEntityDebug,\n-    getEntityDebug,\n-    entityDeclDebug,\n-    notationDeclDebug,\n-    attributeDeclDebug,\n-    elementDeclDebug,\n-    unparsedEntityDeclDebug,\n-    setDocumentLocatorDebug,\n-    startDocumentDebug,\n-    endDocumentDebug,\n-    NULL,\n-    NULL,\n-    referenceDebug,\n-    charactersDebug,\n-    ignorableWhitespaceDebug,\n-    processingInstructionDebug,\n-    commentDebug,\n-    warningDebug,\n-    errorDebug,\n-    fatalErrorDebug,\n-    getParameterEntityDebug,\n-    cdataBlockDebug,\n-    externalSubsetDebug,\n-    XML_SAX2_MAGIC,\n-    NULL,\n-    startElementNsDebug,\n-    endElementNsDebug,\n-    NULL\n-};\n-\n-static xmlSAXHandlerPtr debugSAX2Handler = &debugSAX2HandlerStruct;\n-\n-static void\n-testSAX(const char *filename) {\n-    xmlSAXHandlerPtr handler;\n-    const char *user_data = \"user_data\"; \/* mostly for debugging *\/\n-\n-    callbacks = 0;\n-\n-    if (noout) {\n-        handler = emptySAXHandler;\n-#ifdef LIBXML_SAX1_ENABLED\n-    } else if (options & XML_PARSE_SAX1) {\n-        handler = debugSAXHandler;\n-#endif\n-    } else {\n-        handler = debugSAX2Handler;\n-    }\n-\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-    if (wxschemas != NULL) {\n-        int ret;\n-    xmlSchemaValidCtxtPtr vctxt;\n-        xmlParserInputBufferPtr buf;\n-\n-        if (strcmp(filename, \"-\") == 0)\n-            buf = xmlParserInputBufferCreateFd(STDIN_FILENO,\n-                    XML_CHAR_ENCODING_NONE);\n-        else\n-            buf = xmlParserInputBufferCreateFilename(filename,\n-                    XML_CHAR_ENCODING_NONE);\n-        if (buf == NULL)\n-            return;\n-\n-    vctxt = xmlSchemaNewValidCtxt(wxschemas);\n-        if (vctxt == NULL) {\n-            progresult = XMLLINT_ERR_MEM;\n-            xmlFreeParserInputBuffer(buf);\n-            return;\n-        }\n-    xmlSchemaValidateSetFilename(vctxt, filename);\n-\n-    ret = xmlSchemaValidateStream(vctxt, buf, 0, handler,\n-                                  (void *)user_data);\n-    if (repeat == 0) {\n-        if (ret == 0) {\n-            if (!quiet) {\n-                fprintf(ERR_STREAM, \"%s validates\\n\", filename);\n-            }\n-        } else if (ret > 0) {\n-        fprintf(ERR_STREAM, \"%s fails to validate\\n\", filename);\n-        progresult = XMLLINT_ERR_VALID;\n-        } else {\n-        fprintf(ERR_STREAM, \"%s validation generated an internal error\\n\",\n-               filename);\n-        progresult = XMLLINT_ERR_VALID;\n-        }\n-    }\n-    xmlSchemaFreeValidCtxt(vctxt);\n-    } else\n-#endif\n-    {\n-        xmlParserCtxtPtr ctxt = NULL;\n-\n-    \/*\n-     * Create the parser context amd hook the input\n-     *\/\n-    ctxt = xmlNewSAXParserCtxt(handler, (void *) user_data);\n-    if (ctxt == NULL) {\n-            progresult = XMLLINT_ERR_MEM;\n-        return;\n-    }\n-        if (maxAmpl > 0)\n-            xmlCtxtSetMaxAmplification(ctxt, maxAmpl);\n-\n-        if (strcmp(filename, \"-\") == 0)\n-            xmlCtxtReadFd(ctxt, STDIN_FILENO, \"-\", NULL,\n-                          options | XML_PARSE_UNZIP);\n-        else\n-            xmlCtxtReadFile(ctxt, filename, NULL, options);\n-\n-    if (ctxt->myDoc != NULL) {\n-        fprintf(ERR_STREAM, \"SAX generated a doc !\\n\");\n-        xmlFreeDoc(ctxt->myDoc);\n-        ctxt->myDoc = NULL;\n-    }\n-        xmlFreeParserCtxt(ctxt);\n-    }\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Stream Test processing                *\n- *                                    *\n- ************************************************************************\/\n-#ifdef LIBXML_READER_ENABLED\n-static void processNode(xmlTextReaderPtr reader) {\n-    const xmlChar *name, *value;\n-    int type, empty;\n-\n-    type = xmlTextReaderNodeType(reader);\n-    empty = xmlTextReaderIsEmptyElement(reader);\n-\n-    if (debug) {\n-    name = xmlTextReaderConstName(reader);\n-    if (name == NULL)\n-        name = BAD_CAST \"--\";\n-\n-    value = xmlTextReaderConstValue(reader);\n-\n-\n-    printf(\"%d %d %s %d %d\",\n-        xmlTextReaderDepth(reader),\n-        type,\n-        name,\n-        empty,\n-        xmlTextReaderHasValue(reader));\n-    if (value == NULL)\n-        printf(\"\\n\");\n-    else {\n-        printf(\" %s\\n\", value);\n-    }\n-    }\n-#ifdef LIBXML_PATTERN_ENABLED\n-    if (patternc) {\n-        xmlChar *path = NULL;\n-        int match = -1;\n-\n-    if (type == XML_READER_TYPE_ELEMENT) {\n-        \/* do the check only on element start *\/\n-        match = xmlPatternMatch(patternc, xmlTextReaderCurrentNode(reader));\n-\n-        if (match) {\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)\n-        path = xmlGetNodePath(xmlTextReaderCurrentNode(reader));\n-        printf(\"Node %s matches pattern %s\\n\", path, pattern);\n-#else\n-                printf(\"Node %s matches pattern %s\\n\",\n-                       xmlTextReaderConstName(reader), pattern);\n-#endif\n-        }\n-    }\n-    if (patstream != NULL) {\n-        int ret;\n-\n-        if (type == XML_READER_TYPE_ELEMENT) {\n-        ret = xmlStreamPush(patstream,\n-                            xmlTextReaderConstLocalName(reader),\n-                    xmlTextReaderConstNamespaceUri(reader));\n-        if (ret < 0) {\n-            fprintf(ERR_STREAM, \"xmlStreamPush() failure\\n\");\n-                    xmlFreeStreamCtxt(patstream);\n-            patstream = NULL;\n-        } else if (ret != match) {\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)\n-            if (path == NULL) {\n-                path = xmlGetNodePath(\n-                               xmlTextReaderCurrentNode(reader));\n-            }\n-#endif\n-            fprintf(ERR_STREAM,\n-                    \"xmlPatternMatch and xmlStreamPush disagree\\n\");\n-                    if (path != NULL)\n-                        fprintf(ERR_STREAM, \"  pattern %s node %s\\n\",\n-                                pattern, path);\n-                    else\n-                fprintf(ERR_STREAM, \"  pattern %s node %s\\n\",\n-                pattern, xmlTextReaderConstName(reader));\n-        }\n-\n-        }\n-        if ((type == XML_READER_TYPE_END_ELEMENT) ||\n-            ((type == XML_READER_TYPE_ELEMENT) && (empty))) {\n-            ret = xmlStreamPop(patstream);\n-        if (ret < 0) {\n-            fprintf(ERR_STREAM, \"xmlStreamPop() failure\\n\");\n-                    xmlFreeStreamCtxt(patstream);\n-            patstream = NULL;\n-        }\n-        }\n-    }\n-    if (path != NULL)\n-        xmlFree(path);\n-    }\n-#endif\n-}\n-\n-static void streamFile(const char *filename) {\n-    xmlTextReaderPtr reader;\n-    int ret;\n-#ifdef HAVE_MMAP\n-    int fd = -1;\n-    struct stat info;\n-    const char *base = NULL;\n-\n-    if (memory) {\n-    if (stat(filename, &info) < 0)\n-        return;\n-    if ((fd = open(filename, O_RDONLY)) < 0)\n-        return;\n-    base = mmap(NULL, info.st_size, PROT_READ, MAP_SHARED, fd, 0) ;\n-    if (base == (void *) MAP_FAILED) {\n-        close(fd);\n-        fprintf(ERR_STREAM, \"mmap failure for file %s\\n\", filename);\n-        progresult = XMLLINT_ERR_RDFILE;\n-        return;\n-    }\n-\n-    reader = xmlReaderForMemory(base, info.st_size, filename,\n-                                NULL, options);\n-    } else\n-#endif\n-    if (strcmp(filename, \"-\") == 0)\n-    reader = xmlReaderForFd(STDIN_FILENO, \"-\", NULL, options);\n-    else\n-    reader = xmlReaderForFile(filename, NULL, options);\n-#ifdef LIBXML_PATTERN_ENABLED\n-    if (patternc != NULL) {\n-        patstream = xmlPatternGetStreamCtxt(patternc);\n-    if (patstream != NULL) {\n-        ret = xmlStreamPush(patstream, NULL, NULL);\n-        if (ret < 0) {\n-        fprintf(ERR_STREAM, \"xmlStreamPush() failure\\n\");\n-        xmlFreeStreamCtxt(patstream);\n-        patstream = NULL;\n-            }\n-    }\n-    }\n-#endif\n-\n-\n-    if (reader != NULL) {\n-        if (maxAmpl > 0)\n-            xmlTextReaderSetMaxAmplification(reader, maxAmpl);\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-    if (relaxng != NULL) {\n-        if ((timing) && (!repeat)) {\n-        startTimer();\n-        }\n-        ret = xmlTextReaderRelaxNGValidate(reader, relaxng);\n-        if (ret < 0) {\n-        fprintf(ERR_STREAM,\n-            \"Relax-NG schema %s failed to compile\\n\", relaxng);\n-        progresult = XMLLINT_ERR_SCHEMACOMP;\n-        relaxng = NULL;\n-        }\n-        if ((timing) && (!repeat)) {\n-        endTimer(\"Compiling the schemas\");\n-        }\n-    }\n-    if (schema != NULL) {\n-        if ((timing) && (!repeat)) {\n-        startTimer();\n-        }\n-        ret = xmlTextReaderSchemaValidate(reader, schema);\n-        if (ret < 0) {\n-        fprintf(ERR_STREAM,\n-            \"XSD schema %s failed to compile\\n\", schema);\n-        progresult = XMLLINT_ERR_SCHEMACOMP;\n-        schema = NULL;\n-        }\n-        if ((timing) && (!repeat)) {\n-        endTimer(\"Compiling the schemas\");\n-        }\n-    }\n-#endif\n-\n-    \/*\n-     * Process all nodes in sequence\n-     *\/\n-    if ((timing) && (!repeat)) {\n-        startTimer();\n-    }\n-    ret = xmlTextReaderRead(reader);\n-    while (ret == 1) {\n-        if ((debug)\n-#ifdef LIBXML_PATTERN_ENABLED\n-            || (patternc)\n-#endif\n-           )\n-        processNode(reader);\n-        ret = xmlTextReaderRead(reader);\n-    }\n-    if ((timing) && (!repeat)) {\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-        if (relaxng != NULL)\n-        endTimer(\"Parsing and validating\");\n-        else\n-#endif\n-#ifdef LIBXML_VALID_ENABLED\n-        if (options & XML_PARSE_DTDVALID)\n-        endTimer(\"Parsing and validating\");\n-        else\n-#endif\n-        endTimer(\"Parsing\");\n-    }\n-\n-#ifdef LIBXML_VALID_ENABLED\n-    if (options & XML_PARSE_DTDVALID) {\n-        if (xmlTextReaderIsValid(reader) != 1) {\n-        fprintf(ERR_STREAM,\n-            \"Document %s does not validate\\n\", filename);\n-        progresult = XMLLINT_ERR_VALID;\n-        }\n-    }\n-#endif \/* LIBXML_VALID_ENABLED *\/\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-    if ((relaxng != NULL) || (schema != NULL)) {\n-        if (xmlTextReaderIsValid(reader) != 1) {\n-        fprintf(ERR_STREAM, \"%s fails to validate\\n\", filename);\n-        progresult = XMLLINT_ERR_VALID;\n-        } else {\n-            if (!quiet) {\n-                fprintf(ERR_STREAM, \"%s validates\\n\", filename);\n-            }\n-        }\n-    }\n-#endif\n-    \/*\n-     * Done, cleanup and status\n-     *\/\n-    xmlFreeTextReader(reader);\n-    if (ret != 0) {\n-        fprintf(ERR_STREAM, \"%s : failed to parse\\n\", filename);\n-        progresult = XMLLINT_ERR_UNCLASS;\n-    }\n-    } else {\n-    fprintf(ERR_STREAM, \"Unable to open %s\\n\", filename);\n-    progresult = XMLLINT_ERR_UNCLASS;\n-    }\n-#ifdef LIBXML_PATTERN_ENABLED\n-    if (patstream != NULL) {\n-    xmlFreeStreamCtxt(patstream);\n-    patstream = NULL;\n-    }\n-#endif\n-#ifdef HAVE_MMAP\n-    if (memory) {\n-    munmap((char *) base, info.st_size);\n-    close(fd);\n-    }\n-#endif\n-}\n-\n-static void walkDoc(xmlDocPtr doc) {\n-    xmlTextReaderPtr reader;\n-    int ret;\n-\n-#ifdef LIBXML_PATTERN_ENABLED\n-    if (pattern != NULL) {\n-        xmlNodePtr root;\n-        const xmlChar *namespaces[22];\n-        int i;\n-        xmlNsPtr ns;\n-\n-        root = xmlDocGetRootElement(doc);\n-        if (root == NULL ) {\n-            fprintf(ERR_STREAM,\n-                    \"Document does not have a root element\");\n-            progresult = XMLLINT_ERR_UNCLASS;\n-            return;\n-        }\n-        for (ns = root->nsDef, i = 0;ns != NULL && i < 20;ns=ns->next) {\n-            namespaces[i++] = ns->href;\n-            namespaces[i++] = ns->prefix;\n-        }\n-        namespaces[i++] = NULL;\n-        namespaces[i] = NULL;\n-\n-        ret = xmlPatternCompileSafe((const xmlChar *) pattern, doc->dict,\n-                                    0, &namespaces[0], &patternc);\n-    if (patternc == NULL) {\n-            if (ret < 0) {\n-                progresult = XMLLINT_ERR_MEM;\n-            } else {\n-                fprintf(ERR_STREAM,\n-                        \"Pattern %s failed to compile\\n\", pattern);\n-                progresult = XMLLINT_ERR_SCHEMAPAT;\n-            }\n-            goto error;\n-    }\n-\n-        patstream = xmlPatternGetStreamCtxt(patternc);\n-        if (patstream == NULL) {\n-            progresult = XMLLINT_ERR_MEM;\n-            goto error;\n-        }\n-\n-        ret = xmlStreamPush(patstream, NULL, NULL);\n-        if (ret < 0) {\n-            fprintf(ERR_STREAM, \"xmlStreamPush() failure\\n\");\n-            progresult = XMLLINT_ERR_MEM;\n-            goto error;\n-        }\n-    }\n-#endif \/* LIBXML_PATTERN_ENABLED *\/\n-    reader = xmlReaderWalker(doc);\n-    if (reader != NULL) {\n-    if ((timing) && (!repeat)) {\n-        startTimer();\n-    }\n-    ret = xmlTextReaderRead(reader);\n-    while (ret == 1) {\n-        if ((debug)\n-#ifdef LIBXML_PATTERN_ENABLED\n-            || (patternc)\n-#endif\n-           )\n-        processNode(reader);\n-        ret = xmlTextReaderRead(reader);\n-    }\n-    if ((timing) && (!repeat)) {\n-        endTimer(\"walking through the doc\");\n-    }\n-    xmlFreeTextReader(reader);\n-    if (ret != 0) {\n-        fprintf(ERR_STREAM, \"failed to walk through the doc\\n\");\n-        progresult = XMLLINT_ERR_UNCLASS;\n-    }\n-    } else {\n-    fprintf(ERR_STREAM, \"Failed to crate a reader from the document\\n\");\n-    progresult = XMLLINT_ERR_UNCLASS;\n-    }\n-\n-#ifdef LIBXML_PATTERN_ENABLED\n-error:\n-    if (patternc != NULL) {\n-        xmlFreePattern(patternc);\n-        patternc = NULL;\n-    }\n-    if (patstream != NULL) {\n-    xmlFreeStreamCtxt(patstream);\n-    patstream = NULL;\n-    }\n-#endif\n-}\n-#endif \/* LIBXML_READER_ENABLED *\/\n-\n-#ifdef LIBXML_XPATH_ENABLED\n-\/************************************************************************\n- *                                    *\n- *            XPath Query                                     *\n- *                                    *\n- ************************************************************************\/\n-\n-static void doXPathDump(xmlXPathObjectPtr cur) {\n-    switch(cur->type) {\n-        case XPATH_NODESET: {\n-#ifdef LIBXML_OUTPUT_ENABLED\n-            xmlOutputBufferPtr buf;\n-            xmlNodePtr node;\n-            int i;\n-\n-            if ((cur->nodesetval == NULL) || (cur->nodesetval->nodeNr <= 0)) {\n-                progresult = XMLLINT_ERR_XPATH_EMPTY;\n-                if (!quiet) {\n-                    fprintf(ERR_STREAM, \"XPath set is empty\\n\");\n-                }\n-                break;\n-            }\n-            buf = xmlOutputBufferCreateFile(stdout, NULL);\n-            if (buf == NULL) {\n-                fprintf(ERR_STREAM, \"Out of memory for XPath\\n\");\n-                progresult = XMLLINT_ERR_MEM;\n-                return;\n-            }\n-            for (i = 0;i < cur->nodesetval->nodeNr;i++) {\n-                node = cur->nodesetval->nodeTab[i];\n-                xmlNodeDumpOutput(buf, NULL, node, 0, 0, NULL);\n-                xmlOutputBufferWrite(buf, 1, \"\\n\");\n-            }\n-            xmlOutputBufferClose(buf);\n-#else\n-            printf(\"xpath returned %d nodes\\n\", cur->nodesetval->nodeNr);\n-#endif\n-        break;\n-        }\n-        case XPATH_BOOLEAN:\n-        if (cur->boolval) printf(\"true\\n\");\n-        else printf(\"false\\n\");\n-        break;\n-        case XPATH_NUMBER:\n-        switch (xmlXPathIsInf(cur->floatval)) {\n-        case 1:\n-        printf(\"Infinity\\n\");\n-        break;\n-        case -1:\n-        printf(\"-Infinity\\n\");\n-        break;\n-        default:\n-        if (xmlXPathIsNaN(cur->floatval)) {\n-            printf(\"NaN\\n\");\n-        } else {\n-            printf(\"%0g\\n\", cur->floatval);\n-        }\n-        }\n-        break;\n-        case XPATH_STRING:\n-        printf(\"%s\\n\", (const char *) cur->stringval);\n-        break;\n-        case XPATH_UNDEFINED:\n-        fprintf(ERR_STREAM, \"XPath Object is uninitialized\\n\");\n-            progresult = XMLLINT_ERR_XPATH;\n-        break;\n-    default:\n-        fprintf(ERR_STREAM, \"XPath object of unexpected type\\n\");\n-            progresult = XMLLINT_ERR_XPATH;\n-        break;\n-    }\n-}\n-\n-static void doXPathQuery(xmlDocPtr doc, const char *query) {\n-    xmlXPathContextPtr ctxt;\n-    xmlXPathObjectPtr res;\n-\n-    ctxt = xmlXPathNewContext(doc);\n-    if (ctxt == NULL) {\n-        fprintf(ERR_STREAM, \"Out of memory for XPath\\n\");\n-        progresult = XMLLINT_ERR_MEM;\n-        return;\n-    }\n-    ctxt->node = (xmlNodePtr) doc;\n-    res = xmlXPathEval(BAD_CAST query, ctxt);\n-    xmlXPathFreeContext(ctxt);\n-\n-    if (res == NULL) {\n-        fprintf(ERR_STREAM, \"XPath evaluation failure\\n\");\n-        progresult = XMLLINT_ERR_XPATH;\n-        return;\n-    }\n-    doXPathDump(res);\n-    xmlXPathFreeObject(res);\n-}\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-\n-\/************************************************************************\n- *                                    *\n- *            Tree Test processing                *\n- *                                    *\n- ************************************************************************\/\n-\n-static xmlDocPtr\n-parseFile(const char *filename, xmlParserCtxtPtr rectxt) {\n-    xmlParserCtxtPtr ctxt;\n-    xmlDocPtr doc = NULL;\n-\n-#ifdef LIBXML_TREE_ENABLED\n-    if ((generate) && (filename == NULL)) {\n-        xmlNodePtr n;\n-\n-        doc = xmlNewDoc(BAD_CAST \"1.0\");\n-        if (doc == NULL) {\n-            progresult = XMLLINT_ERR_MEM;\n-            return(NULL);\n-        }\n-        n = xmlNewDocNode(doc, NULL, BAD_CAST \"info\", NULL);\n-        if (n == NULL) {\n-            xmlFreeDoc(doc);\n-            progresult = XMLLINT_ERR_MEM;\n-            return(NULL);\n-        }\n-        if (xmlNodeSetContent(n, BAD_CAST \"abc\") < 0) {\n-            xmlFreeNode(n);\n-            xmlFreeDoc(doc);\n-            progresult = XMLLINT_ERR_MEM;\n-            return(NULL);\n-        }\n-        xmlDocSetRootElement(doc, n);\n-\n-        return(doc);\n-    }\n-#endif \/* LIBXML_TREE_ENABLED *\/\n-\n-#ifdef LIBXML_HTML_ENABLED\n-#ifdef LIBXML_PUSH_ENABLED\n-    if ((html) && (push)) {\n-        FILE *f;\n-        int res;\n-        char chars[4096];\n-\n-        if ((filename[0] == '-') && (filename[1] == 0)) {\n-            f = stdin;\n-        } else {\n-        f = fopen(filename, \"rb\");\n-            if (f == NULL) {\n-                fprintf(ERR_STREAM, \"Can't open %s\\n\", filename);\n-                progresult = XMLLINT_ERR_RDFILE;\n-                return(NULL);\n-            }\n-        }\n-\n-        res = fread(chars, 1, 4, f);\n-        ctxt = htmlCreatePushParserCtxt(NULL, NULL,\n-                    chars, res, filename, XML_CHAR_ENCODING_NONE);\n-        if (ctxt == NULL) {\n-            progresult = XMLLINT_ERR_MEM;\n-            if (f != stdin)\n-                fclose(f);\n-            return(NULL);\n-        }\n-        htmlCtxtUseOptions(ctxt, options);\n-        while ((res = fread(chars, 1, pushsize, f)) > 0) {\n-            htmlParseChunk(ctxt, chars, res, 0);\n-        }\n-        htmlParseChunk(ctxt, chars, 0, 1);\n-        doc = ctxt->myDoc;\n-        htmlFreeParserCtxt(ctxt);\n-        if (f != stdin)\n-            fclose(f);\n-\n-        return(doc);\n-    }\n-#endif \/* LIBXML_PUSH_ENABLED *\/\n-\n-#ifdef HAVE_MMAP\n-    if ((html) && (memory)) {\n-    int fd;\n-    struct stat info;\n-    const char *base;\n-    if (stat(filename, &info) < 0)\n-        return(NULL);\n-    if ((fd = open(filename, O_RDONLY)) < 0)\n-        return(NULL);\n-    base = mmap(NULL, info.st_size, PROT_READ, MAP_SHARED, fd, 0) ;\n-    if (base == (void *) MAP_FAILED) {\n-        close(fd);\n-        fprintf(ERR_STREAM, \"mmap failure for file %s\\n\", filename);\n-        progresult = XMLLINT_ERR_RDFILE;\n-        return(NULL);\n-    }\n-\n-    doc = htmlReadMemory((char *) base, info.st_size, filename,\n-                         NULL, options);\n-\n-    munmap((char *) base, info.st_size);\n-    close(fd);\n-\n-        return(doc);\n-    }\n-#endif\n-\n-    if (html) {\n-        if (strcmp(filename, \"-\") == 0)\n-            doc = htmlReadFd(STDIN_FILENO, \"-\", NULL, options);\n-        else\n-            doc = htmlReadFile(filename, NULL, options);\n-\n-        return(doc);\n-    }\n-#endif \/* LIBXML_HTML_ENABLED *\/\n-\n-#ifdef LIBXML_PUSH_ENABLED\n-    if (push) {\n-        FILE *f;\n-        int res;\n-        char chars[4096];\n-\n-        if ((filename[0] == '-') && (filename[1] == 0)) {\n-            f = stdin;\n-        } else {\n-            f = fopen(filename, \"rb\");\n-            if (f == NULL) {\n-                fprintf(ERR_STREAM, \"Can't open %s\\n\", filename);\n-                progresult = XMLLINT_ERR_RDFILE;\n-                return(NULL);\n-            }\n-        }\n-\n-        res = fread(chars, 1, 4, f);\n-        ctxt = xmlCreatePushParserCtxt(NULL, NULL,\n-                    chars, res, filename);\n-        if (ctxt == NULL) {\n-            progresult = XMLLINT_ERR_MEM;\n-            if (f != stdin)\n-                fclose(f);\n-            return(NULL);\n-        }\n-        xmlCtxtUseOptions(ctxt, options);\n-\n-        if (maxAmpl > 0)\n-            xmlCtxtSetMaxAmplification(ctxt, maxAmpl);\n-\n-        if (htmlout) {\n-            ctxt->sax->error = xmlHTMLError;\n-            ctxt->sax->warning = xmlHTMLWarning;\n-            ctxt->vctxt.error = xmlHTMLValidityError;\n-            ctxt->vctxt.warning = xmlHTMLValidityWarning;\n-        }\n-\n-        while ((res = fread(chars, 1, pushsize, f)) > 0) {\n-            xmlParseChunk(ctxt, chars, res, 0);\n-        }\n-        xmlParseChunk(ctxt, chars, 0, 1);\n-\n-        doc = ctxt->myDoc;\n-        if (f != stdin)\n-            fclose(f);\n-    } else\n-#endif \/* LIBXML_PUSH_ENABLED *\/\n-    {\n-        if (rectxt == NULL) {\n-            ctxt = xmlNewParserCtxt();\n-            if (ctxt == NULL) {\n-                progresult = XMLLINT_ERR_MEM;\n-                return(NULL);\n-            }\n-        } else {\n-            ctxt = rectxt;\n-        }\n-\n-        if (maxAmpl > 0)\n-            xmlCtxtSetMaxAmplification(ctxt, maxAmpl);\n-\n-        if (htmlout) {\n-            ctxt->sax->error = xmlHTMLError;\n-            ctxt->sax->warning = xmlHTMLWarning;\n-            ctxt->vctxt.error = xmlHTMLValidityError;\n-            ctxt->vctxt.warning = xmlHTMLValidityWarning;\n-        }\n-\n-        if (testIO) {\n-            FILE *f;\n-\n-            if ((filename[0] == '-') && (filename[1] == 0)) {\n-                f = stdin;\n-            } else {\n-                f = fopen(filename, \"rb\");\n-                if (f == NULL) {\n-                    fprintf(ERR_STREAM, \"Can't open %s\\n\", filename);\n-                    progresult = XMLLINT_ERR_RDFILE;\n-                    goto error;\n-                }\n-            }\n-\n-            doc = xmlCtxtReadIO(ctxt, myRead, myClose, f, filename, NULL,\n-                                options);\n-#ifdef HAVE_MMAP\n-        } else if (memory) {\n-            int fd;\n-            struct stat info;\n-            const char *base;\n-\n-            if (stat(filename, &info) < 0)\n-                goto error;\n-            if ((fd = open(filename, O_RDONLY)) < 0)\n-                goto error;\n-            base = mmap(NULL, info.st_size, PROT_READ, MAP_SHARED, fd, 0) ;\n-            if (base == (void *) MAP_FAILED) {\n-                close(fd);\n-                fprintf(ERR_STREAM, \"mmap failure for file %s\\n\", filename);\n-                progresult = XMLLINT_ERR_RDFILE;\n-                goto error;\n-            }\n-\n-            doc = xmlCtxtReadMemory(ctxt, base, info.st_size, filename, NULL,\n-                                    options);\n-\n-            munmap((char *) base, info.st_size);\n-            close(fd);\n-#endif\n-        } else {\n-            if (strcmp(filename, \"-\") == 0)\n-                doc = xmlCtxtReadFd(ctxt, STDIN_FILENO, \"-\", NULL,\n-                                    options | XML_PARSE_UNZIP);\n-            else\n-                doc = xmlCtxtReadFile(ctxt, filename, NULL, options);\n-        }\n-    }\n-\n-    if (doc == NULL) {\n-        if (ctxt->errNo == XML_ERR_NO_MEMORY)\n-            progresult = XMLLINT_ERR_MEM;\n-        else\n-        progresult = XMLLINT_ERR_RDFILE;\n-    } else {\n-#ifdef LIBXML_VALID_ENABLED\n-        if ((options & XML_PARSE_DTDVALID) && (ctxt->valid == 0))\n-            progresult = XMLLINT_ERR_VALID;\n-#endif \/* LIBXML_VALID_ENABLED *\/\n-    }\n-\n-error:\n-    if (ctxt != rectxt)\n-        xmlFreeParserCtxt(ctxt);\n-\n-    return(doc);\n-}\n-\n-static void\n-parseAndPrintFile(const char *filename, xmlParserCtxtPtr rectxt) {\n-    xmlDocPtr doc;\n-\n-    if ((timing) && (!repeat))\n-    startTimer();\n-\n-    doc = parseFile(filename, rectxt);\n-    if (doc == NULL) {\n-        if (progresult == XMLLINT_RETURN_OK)\n-            progresult = XMLLINT_ERR_UNCLASS;\n-    return;\n-    }\n-\n-    if ((timing) && (!repeat)) {\n-    endTimer(\"Parsing\");\n-    }\n-\n-    if (dropdtd) {\n-    xmlDtdPtr dtd;\n-\n-    dtd = xmlGetIntSubset(doc);\n-    if (dtd != NULL) {\n-        xmlUnlinkNode((xmlNodePtr)dtd);\n-            doc->intSubset = dtd;\n-    }\n-    }\n-\n-#ifdef LIBXML_XINCLUDE_ENABLED\n-    if (xinclude) {\n-    if ((timing) && (!repeat)) {\n-        startTimer();\n-    }\n-    if (xmlXIncludeProcessFlags(doc, options) < 0)\n-        progresult = XMLLINT_ERR_UNCLASS;\n-    if ((timing) && (!repeat)) {\n-        endTimer(\"Xinclude processing\");\n-    }\n-    }\n-#endif\n-\n-#ifdef LIBXML_XPATH_ENABLED\n-    if (xpathquery != NULL) {\n-        doXPathQuery(doc, xpathquery);\n-    }\n-#endif\n-\n-#ifdef LIBXML_DEBUG_ENABLED\n-#ifdef LIBXML_XPATH_ENABLED\n-    \/*\n-     * shell interaction\n-     *\/\n-    if (shell) {\n-        xmlXPathOrderDocElems(doc);\n-        xmlShell(doc, filename, xmlShellReadline, stdout);\n-    }\n-#endif\n-#endif\n-\n-#ifdef LIBXML_TREE_ENABLED\n-    \/*\n-     * test intermediate copy if needed.\n-     *\/\n-    if (copy) {\n-        xmlDocPtr tmp;\n-\n-        tmp = doc;\n-    if (timing) {\n-        startTimer();\n-    }\n-    doc = xmlCopyDoc(doc, 1);\n-        if (doc == NULL) {\n-            progresult = XMLLINT_ERR_MEM;\n-            xmlFreeDoc(tmp);\n-            return;\n-        }\n-    if (timing) {\n-        endTimer(\"Copying\");\n-    }\n-    if (timing) {\n-        startTimer();\n-    }\n-    xmlFreeDoc(tmp);\n-    if (timing) {\n-        endTimer(\"Freeing original\");\n-    }\n-    }\n-#endif \/* LIBXML_TREE_ENABLED *\/\n-\n-#ifdef LIBXML_VALID_ENABLED\n-    if ((insert)\n-#ifdef LIBXML_HTML_ENABLED\n-        && (!html)\n-#endif\n-    ) {\n-        const xmlChar* list[256];\n-    int nb, i;\n-    xmlNodePtr node;\n-\n-    if (doc->children != NULL) {\n-        node = doc->children;\n-        while ((node != NULL) &&\n-                   ((node->type != XML_ELEMENT_NODE) ||\n-                    (node->last == NULL)))\n-                node = node->next;\n-        if (node != NULL) {\n-        nb = xmlValidGetValidElements(node->last, NULL, list, 256);\n-        if (nb < 0) {\n-            fprintf(ERR_STREAM, \"could not get valid list of elements\\n\");\n-        } else if (nb == 0) {\n-            fprintf(ERR_STREAM, \"No element can be inserted under root\\n\");\n-        } else {\n-            fprintf(ERR_STREAM, \"%d element types can be inserted under root:\\n\",\n-                   nb);\n-            for (i = 0;i < nb;i++) {\n-             fprintf(ERR_STREAM, \"%s\\n\", (char *) list[i]);\n-            }\n-        }\n-        }\n-    }\n-    }else\n-#endif \/* LIBXML_VALID_ENABLED *\/\n-#ifdef LIBXML_READER_ENABLED\n-    if (walker) {\n-        walkDoc(doc);\n-    }\n-#endif \/* LIBXML_READER_ENABLED *\/\n-#ifdef LIBXML_OUTPUT_ENABLED\n-    if (noout == 0) {\n-        if (compress)\n-            xmlSetDocCompressMode(doc, 9);\n-\n-    \/*\n-     * print it.\n-     *\/\n-#ifdef LIBXML_DEBUG_ENABLED\n-    if (!debug) {\n-#endif\n-        if ((timing) && (!repeat)) {\n-        startTimer();\n-        }\n-#ifdef LIBXML_HTML_ENABLED\n-            if ((html) && (!xmlout)) {\n-        if (compress) {\n-            htmlSaveFile(output ? output : \"-\", doc);\n-        }\n-        else if (encoding != NULL) {\n-            if (format == 1) {\n-            htmlSaveFileFormat(output ? output : \"-\", doc, encoding, 1);\n-            }\n-            else {\n-            htmlSaveFileFormat(output ? output : \"-\", doc, encoding, 0);\n-            }\n-        }\n-        else if (format == 1) {\n-            htmlSaveFileFormat(output ? output : \"-\", doc, NULL, 1);\n-        }\n-        else {\n-            FILE *out;\n-            if (output == NULL)\n-            out = stdout;\n-            else {\n-            out = fopen(output,\"wb\");\n-            }\n-            if (out != NULL) {\n-            if (htmlDocDump(out, doc) < 0)\n-                progresult = XMLLINT_ERR_OUT;\n-\n-            if (output != NULL)\n-                fclose(out);\n-            } else {\n-            fprintf(ERR_STREAM, \"failed to open %s\\n\", output);\n-            progresult = XMLLINT_ERR_OUT;\n-            }\n-        }\n-        if ((timing) && (!repeat)) {\n-            endTimer(\"Saving\");\n-        }\n-        } else\n-#endif\n-#ifdef LIBXML_C14N_ENABLED\n-            if (canonical) {\n-            xmlChar *result = NULL;\n-        int size;\n-\n-        size = xmlC14NDocDumpMemory(doc, NULL, XML_C14N_1_0, NULL, 1, &result);\n-        if (size >= 0) {\n-            if (write(1, result, size) == -1) {\n-                fprintf(ERR_STREAM, \"Can't write data\\n\");\n-            }\n-            xmlFree(result);\n-        } else {\n-            fprintf(ERR_STREAM, \"Failed to canonicalize\\n\");\n-            progresult = XMLLINT_ERR_OUT;\n-        }\n-        } else if (canonical_11) {\n-            xmlChar *result = NULL;\n-        int size;\n-\n-        size = xmlC14NDocDumpMemory(doc, NULL, XML_C14N_1_1, NULL, 1, &result);\n-        if (size >= 0) {\n-            if (write(1, result, size) == -1) {\n-                fprintf(ERR_STREAM, \"Can't write data\\n\");\n-            }\n-            xmlFree(result);\n-        } else {\n-            fprintf(ERR_STREAM, \"Failed to canonicalize\\n\");\n-            progresult = XMLLINT_ERR_OUT;\n-        }\n-        } else\n-            if (exc_canonical) {\n-            xmlChar *result = NULL;\n-        int size;\n-\n-        size = xmlC14NDocDumpMemory(doc, NULL, XML_C14N_EXCLUSIVE_1_0, NULL, 1, &result);\n-        if (size >= 0) {\n-            if (write(1, result, size) == -1) {\n-                fprintf(ERR_STREAM, \"Can't write data\\n\");\n-            }\n-            xmlFree(result);\n-        } else {\n-            fprintf(ERR_STREAM, \"Failed to canonicalize\\n\");\n-            progresult = XMLLINT_ERR_OUT;\n-        }\n-        } else\n-#endif\n-#ifdef HAVE_MMAP\n-        if (memory) {\n-        xmlChar *result;\n-        int len;\n-\n-        if (encoding != NULL) {\n-            if (format == 1) {\n-                xmlDocDumpFormatMemoryEnc(doc, &result, &len, encoding, 1);\n-            } else {\n-            xmlDocDumpMemoryEnc(doc, &result, &len, encoding);\n-            }\n-        } else {\n-            if (format == 1)\n-            xmlDocDumpFormatMemory(doc, &result, &len, 1);\n-            else\n-            xmlDocDumpMemory(doc, &result, &len);\n-        }\n-        if (result == NULL) {\n-            fprintf(ERR_STREAM, \"Failed to save\\n\");\n-            progresult = XMLLINT_ERR_OUT;\n-        } else {\n-            if (write(1, result, len) == -1) {\n-                fprintf(ERR_STREAM, \"Can't write data\\n\");\n-            }\n-            xmlFree(result);\n-        }\n-\n-        } else\n-#endif \/* HAVE_MMAP *\/\n-        if (compress) {\n-        xmlSaveFile(output ? output : \"-\", doc);\n-        } else {\n-            xmlSaveCtxtPtr ctxt;\n-        int saveOpts = 0;\n-\n-                if (format == 1)\n-            saveOpts |= XML_SAVE_FORMAT;\n-                else if (format == 2)\n-                    saveOpts |= XML_SAVE_WSNONSIG;\n-\n-#if defined(LIBXML_HTML_ENABLED)\n-                if (xmlout)\n-                    saveOpts |= XML_SAVE_AS_XML;\n-#endif\n-\n-        if (output == NULL)\n-            ctxt = xmlSaveToFd(1, encoding, saveOpts);\n-        else\n-            ctxt = xmlSaveToFilename(output, encoding, saveOpts);\n-\n-        if (ctxt != NULL) {\n-            if (xmlSaveDoc(ctxt, doc) < 0) {\n-            fprintf(ERR_STREAM, \"failed save to %s\\n\",\n-                output ? output : \"-\");\n-            progresult = XMLLINT_ERR_OUT;\n-            }\n-            xmlSaveClose(ctxt);\n-        } else {\n-            progresult = XMLLINT_ERR_OUT;\n-        }\n-        }\n-        if ((timing) && (!repeat)) {\n-        endTimer(\"Saving\");\n-        }\n-#ifdef LIBXML_DEBUG_ENABLED\n-    } else {\n-        FILE *out;\n-        if (output == NULL)\n-            out = stdout;\n-        else {\n-        out = fopen(output,\"wb\");\n-        }\n-        if (out != NULL) {\n-        xmlDebugDumpDocument(out, doc);\n-\n-        if (output != NULL)\n-            fclose(out);\n-        } else {\n-        fprintf(ERR_STREAM, \"failed to open %s\\n\", output);\n-        progresult = XMLLINT_ERR_OUT;\n-        }\n-    }\n-#endif\n-    }\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-\n-#ifdef LIBXML_VALID_ENABLED\n-    \/*\n-     * A posteriori validation test\n-     *\/\n-    if ((dtdvalid != NULL) || (dtdvalidfpi != NULL)) {\n-    xmlDtdPtr dtd;\n-\n-    if ((timing) && (!repeat)) {\n-        startTimer();\n-    }\n-    if (dtdvalid != NULL)\n-        dtd = xmlParseDTD(NULL, (const xmlChar *)dtdvalid);\n-    else\n-        dtd = xmlParseDTD((const xmlChar *)dtdvalidfpi, NULL);\n-    if ((timing) && (!repeat)) {\n-        endTimer(\"Parsing DTD\");\n-    }\n-    if (dtd == NULL) {\n-        if (dtdvalid != NULL)\n-        fprintf(ERR_STREAM,\n-            \"Could not parse DTD %s\\n\", dtdvalid);\n-        else\n-        fprintf(ERR_STREAM,\n-            \"Could not parse DTD %s\\n\", dtdvalidfpi);\n-        progresult = XMLLINT_ERR_DTD;\n-    } else {\n-        xmlValidCtxtPtr cvp;\n-\n-        if ((cvp = xmlNewValidCtxt()) == NULL) {\n-        fprintf(ERR_STREAM,\n-            \"Couldn't allocate validation context\\n\");\n-                progresult = XMLLINT_ERR_MEM;\n-                xmlFreeDtd(dtd);\n-                return;\n-        }\n-\n-        if ((timing) && (!repeat)) {\n-        startTimer();\n-        }\n-        if (!xmlValidateDtd(cvp, doc, dtd)) {\n-        if (dtdvalid != NULL)\n-            fprintf(ERR_STREAM,\n-                \"Document %s does not validate against %s\\n\",\n-                filename, dtdvalid);\n-        else\n-            fprintf(ERR_STREAM,\n-                \"Document %s does not validate against %s\\n\",\n-                filename, dtdvalidfpi);\n-        progresult = XMLLINT_ERR_VALID;\n-        }\n-        if ((timing) && (!repeat)) {\n-        endTimer(\"Validating against DTD\");\n-        }\n-        xmlFreeValidCtxt(cvp);\n-        xmlFreeDtd(dtd);\n-    }\n-    } else if (postvalid) {\n-    xmlValidCtxtPtr cvp;\n-\n-    if ((cvp = xmlNewValidCtxt()) == NULL) {\n-        fprintf(ERR_STREAM,\n-            \"Couldn't allocate validation context\\n\");\n-            progresult = XMLLINT_ERR_MEM;\n-            xmlFreeDoc(doc);\n-            return;\n-    }\n-\n-    if ((timing) && (!repeat)) {\n-        startTimer();\n-    }\n-    if (!xmlValidateDocument(cvp, doc)) {\n-        fprintf(ERR_STREAM,\n-            \"Document %s does not validate\\n\", filename);\n-        progresult = XMLLINT_ERR_VALID;\n-    }\n-    if ((timing) && (!repeat)) {\n-        endTimer(\"Validating\");\n-    }\n-    xmlFreeValidCtxt(cvp);\n-    }\n-#endif \/* LIBXML_VALID_ENABLED *\/\n-#ifdef LIBXML_SCHEMATRON_ENABLED\n-    if (wxschematron != NULL) {\n-    xmlSchematronValidCtxtPtr ctxt;\n-    int ret;\n-    int flag;\n-\n-    if ((timing) && (!repeat)) {\n-        startTimer();\n-    }\n-\n-    if (debug)\n-        flag = XML_SCHEMATRON_OUT_XML;\n-    else\n-        flag = XML_SCHEMATRON_OUT_TEXT;\n-    if (noout)\n-        flag |= XML_SCHEMATRON_OUT_QUIET;\n-    ctxt = xmlSchematronNewValidCtxt(wxschematron, flag);\n-        if (ctxt == NULL) {\n-            progresult = XMLLINT_ERR_MEM;\n-            xmlFreeDoc(doc);\n-            return;\n-        }\n-    ret = xmlSchematronValidateDoc(ctxt, doc);\n-    if (ret == 0) {\n-        if (!quiet) {\n-            fprintf(ERR_STREAM, \"%s validates\\n\", filename);\n-        }\n-    } else if (ret > 0) {\n-        fprintf(ERR_STREAM, \"%s fails to validate\\n\", filename);\n-        progresult = XMLLINT_ERR_VALID;\n-    } else {\n-        fprintf(ERR_STREAM, \"%s validation generated an internal error\\n\",\n-           filename);\n-        progresult = XMLLINT_ERR_VALID;\n-    }\n-    xmlSchematronFreeValidCtxt(ctxt);\n-    if ((timing) && (!repeat)) {\n-        endTimer(\"Validating\");\n-    }\n-    }\n-#endif\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-    if (relaxngschemas != NULL) {\n-    xmlRelaxNGValidCtxtPtr ctxt;\n-    int ret;\n-\n-    if ((timing) && (!repeat)) {\n-        startTimer();\n-    }\n-\n-    ctxt = xmlRelaxNGNewValidCtxt(relaxngschemas);\n-        if (ctxt == NULL) {\n-            progresult = XMLLINT_ERR_MEM;\n-            xmlFreeDoc(doc);\n-            return;\n-        }\n-    ret = xmlRelaxNGValidateDoc(ctxt, doc);\n-    if (ret == 0) {\n-        if (!quiet) {\n-            fprintf(ERR_STREAM, \"%s validates\\n\", filename);\n-        }\n-    } else if (ret > 0) {\n-        fprintf(ERR_STREAM, \"%s fails to validate\\n\", filename);\n-        progresult = XMLLINT_ERR_VALID;\n-    } else {\n-        fprintf(ERR_STREAM, \"%s validation generated an internal error\\n\",\n-           filename);\n-        progresult = XMLLINT_ERR_VALID;\n-    }\n-    xmlRelaxNGFreeValidCtxt(ctxt);\n-    if ((timing) && (!repeat)) {\n-        endTimer(\"Validating\");\n-    }\n-    } else if (wxschemas != NULL) {\n-    xmlSchemaValidCtxtPtr ctxt;\n-    int ret;\n-\n-    if ((timing) && (!repeat)) {\n-        startTimer();\n-    }\n-\n-    ctxt = xmlSchemaNewValidCtxt(wxschemas);\n-        if (ctxt == NULL) {\n-            progresult = XMLLINT_ERR_MEM;\n-            xmlFreeDoc(doc);\n-            return;\n-        }\n-    ret = xmlSchemaValidateDoc(ctxt, doc);\n-    if (ret == 0) {\n-        if (!quiet) {\n-            fprintf(ERR_STREAM, \"%s validates\\n\", filename);\n-        }\n-    } else if (ret > 0) {\n-        fprintf(ERR_STREAM, \"%s fails to validate\\n\", filename);\n-        progresult = XMLLINT_ERR_VALID;\n-    } else {\n-        fprintf(ERR_STREAM, \"%s validation generated an internal error\\n\",\n-           filename);\n-        progresult = XMLLINT_ERR_VALID;\n-    }\n-    xmlSchemaFreeValidCtxt(ctxt);\n-    if ((timing) && (!repeat)) {\n-        endTimer(\"Validating\");\n-    }\n-    }\n-#endif\n-\n-#ifdef LIBXML_DEBUG_ENABLED\n-    if ((debugent)\n-#if defined(LIBXML_HTML_ENABLED)\n-        && (!html)\n-#endif\n-    )\n-    xmlDebugDumpEntities(ERR_STREAM, doc);\n-#endif\n-\n-    \/*\n-     * free it.\n-     *\/\n-    if ((timing) && (!repeat)) {\n-    startTimer();\n-    }\n-    xmlFreeDoc(doc);\n-    if ((timing) && (!repeat)) {\n-    endTimer(\"Freeing\");\n-    }\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Usage and Main                    *\n- *                                    *\n- ************************************************************************\/\n-\n-static void showVersion(const char *name) {\n-    fprintf(ERR_STREAM, \"%s: using libxml version %s\\n\", name, xmlParserVersion);\n-    fprintf(ERR_STREAM, \"   compiled with: \");\n-    if (xmlHasFeature(XML_WITH_THREAD)) fprintf(ERR_STREAM, \"Threads \");\n-    if (xmlHasFeature(XML_WITH_TREE)) fprintf(ERR_STREAM, \"Tree \");\n-    if (xmlHasFeature(XML_WITH_OUTPUT)) fprintf(ERR_STREAM, \"Output \");\n-    if (xmlHasFeature(XML_WITH_PUSH)) fprintf(ERR_STREAM, \"Push \");\n-    if (xmlHasFeature(XML_WITH_READER)) fprintf(ERR_STREAM, \"Reader \");\n-    if (xmlHasFeature(XML_WITH_PATTERN)) fprintf(ERR_STREAM, \"Patterns \");\n-    if (xmlHasFeature(XML_WITH_WRITER)) fprintf(ERR_STREAM, \"Writer \");\n-    if (xmlHasFeature(XML_WITH_SAX1)) fprintf(ERR_STREAM, \"SAXv1 \");\n-    if (xmlHasFeature(XML_WITH_FTP)) fprintf(ERR_STREAM, \"FTP \");\n-    if (xmlHasFeature(XML_WITH_HTTP)) fprintf(ERR_STREAM, \"HTTP \");\n-    if (xmlHasFeature(XML_WITH_VALID)) fprintf(ERR_STREAM, \"DTDValid \");\n-    if (xmlHasFeature(XML_WITH_HTML)) fprintf(ERR_STREAM, \"HTML \");\n-    if (xmlHasFeature(XML_WITH_LEGACY)) fprintf(ERR_STREAM, \"Legacy \");\n-    if (xmlHasFeature(XML_WITH_C14N)) fprintf(ERR_STREAM, \"C14N \");\n-    if (xmlHasFeature(XML_WITH_CATALOG)) fprintf(ERR_STREAM, \"Catalog \");\n-    if (xmlHasFeature(XML_WITH_XPATH)) fprintf(ERR_STREAM, \"XPath \");\n-    if (xmlHasFeature(XML_WITH_XPTR)) fprintf(ERR_STREAM, \"XPointer \");\n-    if (xmlHasFeature(XML_WITH_XINCLUDE)) fprintf(ERR_STREAM, \"XInclude \");\n-    if (xmlHasFeature(XML_WITH_ICONV)) fprintf(ERR_STREAM, \"Iconv \");\n-    if (xmlHasFeature(XML_WITH_ICU)) fprintf(ERR_STREAM, \"ICU \");\n-    if (xmlHasFeature(XML_WITH_ISO8859X)) fprintf(ERR_STREAM, \"ISO8859X \");\n-    if (xmlHasFeature(XML_WITH_UNICODE)) fprintf(ERR_STREAM, \"Unicode \");\n-    if (xmlHasFeature(XML_WITH_REGEXP)) fprintf(ERR_STREAM, \"Regexps \");\n-    if (xmlHasFeature(XML_WITH_AUTOMATA)) fprintf(ERR_STREAM, \"Automata \");\n-    if (xmlHasFeature(XML_WITH_EXPR)) fprintf(ERR_STREAM, \"Expr \");\n-    if (xmlHasFeature(XML_WITH_SCHEMAS)) fprintf(ERR_STREAM, \"Schemas \");\n-    if (xmlHasFeature(XML_WITH_SCHEMATRON)) fprintf(ERR_STREAM, \"Schematron \");\n-    if (xmlHasFeature(XML_WITH_MODULES)) fprintf(ERR_STREAM, \"Modules \");\n-    if (xmlHasFeature(XML_WITH_DEBUG)) fprintf(ERR_STREAM, \"Debug \");\n-    if (xmlHasFeature(XML_WITH_ZLIB)) fprintf(ERR_STREAM, \"Zlib \");\n-    if (xmlHasFeature(XML_WITH_LZMA)) fprintf(ERR_STREAM, \"Lzma \");\n-    fprintf(ERR_STREAM, \"\\n\");\n-}\n-\n-static void usage(FILE *f, const char *name) {\n-    fprintf(f, \"Usage : %s [options] XMLfiles ...\\n\", name);\n-#ifdef LIBXML_OUTPUT_ENABLED\n-    fprintf(f, \"\\tParse the XML files and output the result of the parsing\\n\");\n-#else\n-    fprintf(f, \"\\tParse the XML files\\n\");\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-    fprintf(f, \"\\t--version : display the version of the XML library used\\n\");\n-#ifdef LIBXML_DEBUG_ENABLED\n-    fprintf(f, \"\\t--debug : dump a debug tree of the in-memory document\\n\");\n-    fprintf(f, \"\\t--shell : run a navigating shell\\n\");\n-    fprintf(f, \"\\t--debugent : debug the entities defined in the document\\n\");\n-#else\n-#ifdef LIBXML_READER_ENABLED\n-    fprintf(f, \"\\t--debug : dump the nodes content when using --stream\\n\");\n-#endif \/* LIBXML_READER_ENABLED *\/\n-#endif\n-#ifdef LIBXML_TREE_ENABLED\n-    fprintf(f, \"\\t--copy : used to test the internal copy implementation\\n\");\n-#endif \/* LIBXML_TREE_ENABLED *\/\n-    fprintf(f, \"\\t--recover : output what was parsable on broken XML documents\\n\");\n-    fprintf(f, \"\\t--huge : remove any internal arbitrary parser limits\\n\");\n-    fprintf(f, \"\\t--noent : substitute entity references by their value\\n\");\n-    fprintf(f, \"\\t--noenc : ignore any encoding specified inside the document\\n\");\n-    fprintf(f, \"\\t--noout : don't output the result tree\\n\");\n-    fprintf(f, \"\\t--path 'paths': provide a set of paths for resources\\n\");\n-    fprintf(f, \"\\t--load-trace : print trace of all external entities loaded\\n\");\n-    fprintf(f, \"\\t--nonet : refuse to fetch DTDs or entities over network\\n\");\n-    fprintf(f, \"\\t--nocompact : do not generate compact text nodes\\n\");\n-    fprintf(f, \"\\t--htmlout : output results as HTML\\n\");\n-    fprintf(f, \"\\t--nowrap : do not put HTML doc wrapper\\n\");\n-#ifdef LIBXML_VALID_ENABLED\n-    fprintf(f, \"\\t--valid : validate the document in addition to std well-formed check\\n\");\n-    fprintf(f, \"\\t--postvalid : do a posteriori validation, i.e after parsing\\n\");\n-    fprintf(f, \"\\t--dtdvalid URL : do a posteriori validation against a given DTD\\n\");\n-    fprintf(f, \"\\t--dtdvalidfpi FPI : same but name the DTD with a Public Identifier\\n\");\n-    fprintf(f, \"\\t--insert : ad-hoc test for valid insertions\\n\");\n-#endif \/* LIBXML_VALID_ENABLED *\/\n-    fprintf(f, \"\\t--quiet : be quiet when succeeded\\n\");\n-    fprintf(f, \"\\t--timing : print some timings\\n\");\n-    fprintf(f, \"\\t--repeat : repeat 100 times, for timing or profiling\\n\");\n-    fprintf(f, \"\\t--dropdtd : remove the DOCTYPE of the input docs\\n\");\n-#ifdef LIBXML_HTML_ENABLED\n-    fprintf(f, \"\\t--html : use the HTML parser\\n\");\n-    fprintf(f, \"\\t--xmlout : force to use the XML serializer when using --html\\n\");\n-    fprintf(f, \"\\t--nodefdtd : do not default HTML doctype\\n\");\n-#endif\n-#ifdef LIBXML_PUSH_ENABLED\n-    fprintf(f, \"\\t--push : use the push mode of the parser\\n\");\n-    fprintf(f, \"\\t--pushsmall : use the push mode of the parser using tiny increments\\n\");\n-#endif \/* LIBXML_PUSH_ENABLED *\/\n-#ifdef HAVE_MMAP\n-    fprintf(f, \"\\t--memory : parse from memory\\n\");\n-#endif\n-    fprintf(f, \"\\t--maxmem nbbytes : limits memory allocation to nbbytes bytes\\n\");\n-    fprintf(f, \"\\t--nowarning : do not emit warnings from parser\/validator\\n\");\n-    fprintf(f, \"\\t--noblanks : drop (ignorable?) blanks spaces\\n\");\n-    fprintf(f, \"\\t--nocdata : replace cdata section with text nodes\\n\");\n-#ifdef LIBXML_OUTPUT_ENABLED\n-    fprintf(f, \"\\t--output file or -o file: save to a given file\\n\");\n-    fprintf(f, \"\\t--format : reformat\/reindent the output\\n\");\n-    fprintf(f, \"\\t--encode encoding : output in the given encoding\\n\");\n-    fprintf(f, \"\\t--pretty STYLE : pretty-print in a particular style\\n\");\n-    fprintf(f, \"\\t                 0 Do not pretty print\\n\");\n-    fprintf(f, \"\\t                 1 Format the XML content, as --format\\n\");\n-    fprintf(f, \"\\t                 2 Add whitespace inside tags, preserving content\\n\");\n-#ifdef LIBXML_ZLIB_ENABLED\n-    fprintf(f, \"\\t--compress : turn on gzip compression of output\\n\");\n-#endif\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-    fprintf(f, \"\\t--c14n : save in W3C canonical format v1.0 (with comments)\\n\");\n-    fprintf(f, \"\\t--c14n11 : save in W3C canonical format v1.1 (with comments)\\n\");\n-    fprintf(f, \"\\t--exc-c14n : save in W3C exclusive canonical format (with comments)\\n\");\n-#ifdef LIBXML_C14N_ENABLED\n-#endif \/* LIBXML_C14N_ENABLED *\/\n-    fprintf(f, \"\\t--nsclean : remove redundant namespace declarations\\n\");\n-    fprintf(f, \"\\t--testIO : test user I\/O support\\n\");\n-#ifdef LIBXML_CATALOG_ENABLED\n-    fprintf(f, \"\\t--catalogs : use SGML catalogs from $SGML_CATALOG_FILES\\n\");\n-    fprintf(f, \"\\t             otherwise XML Catalogs starting from \\n\");\n-    fprintf(f, \"\\t         %s are activated by default\\n\", XML_XML_DEFAULT_CATALOG);\n-    fprintf(f, \"\\t--nocatalogs: deactivate all catalogs\\n\");\n-#endif\n-    fprintf(f, \"\\t--auto : generate a small doc on the fly\\n\");\n-#ifdef LIBXML_XINCLUDE_ENABLED\n-    fprintf(f, \"\\t--xinclude : do XInclude processing\\n\");\n-    fprintf(f, \"\\t--noxincludenode : same but do not generate XInclude nodes\\n\");\n-    fprintf(f, \"\\t--nofixup-base-uris : do not fixup xml:base uris\\n\");\n-#endif\n-    fprintf(f, \"\\t--loaddtd : fetch external DTD\\n\");\n-    fprintf(f, \"\\t--dtdattr : loaddtd + populate the tree with inherited attributes \\n\");\n-#ifdef LIBXML_READER_ENABLED\n-    fprintf(f, \"\\t--stream : use the streaming interface to process very large files\\n\");\n-    fprintf(f, \"\\t--walker : create a reader and walk though the resulting doc\\n\");\n-#ifdef LIBXML_PATTERN_ENABLED\n-    fprintf(f, \"\\t--pattern pattern_value : test the pattern support\\n\");\n-#endif\n-#endif \/* LIBXML_READER_ENABLED *\/\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-    fprintf(f, \"\\t--relaxng schema : do RelaxNG validation against the schema\\n\");\n-    fprintf(f, \"\\t--schema schema : do validation against the WXS schema\\n\");\n-#endif\n-#ifdef LIBXML_SCHEMATRON_ENABLED\n-    fprintf(f, \"\\t--schematron schema : do validation against a schematron\\n\");\n-#endif\n-#ifdef LIBXML_SAX1_ENABLED\n-    fprintf(f, \"\\t--sax1: use the old SAX1 interfaces for processing\\n\");\n-#endif\n-    fprintf(f, \"\\t--sax: do not build a tree but work just at the SAX level\\n\");\n-    fprintf(f, \"\\t--oldxml10: use XML-1.0 parsing rules before the 5th edition\\n\");\n-#ifdef LIBXML_XPATH_ENABLED\n-    fprintf(f, \"\\t--xpath expr: evaluate the XPath expression, imply --noout\\n\");\n-#endif\n-    fprintf(f, \"\\t--max-ampl value: set maximum amplification factor\\n\");\n-\n-    fprintf(f, \"\\nLibxml project home page: https:\/\/gitlab.gnome.org\/GNOME\/libxml2\\n\");\n-}\n-\n-static unsigned long\n-parseInteger(const char *ctxt, const char *str,\n-             unsigned long min, unsigned long max) {\n-    char *strEnd;\n-    unsigned long val;\n-\n-    errno = 0;\n-    val = strtoul(str, &strEnd, 10);\n-    if (errno == EINVAL || *strEnd != 0) {\n-        fprintf(ERR_STREAM, \"%s: invalid integer: %s\\n\", ctxt, str);\n-        exit(XMLLINT_ERR_UNCLASS);\n-    }\n-    if (errno != 0 || val < min || val > max) {\n-        fprintf(ERR_STREAM, \"%s: integer out of range: %s\\n\", ctxt, str);\n-        exit(XMLLINT_ERR_UNCLASS);\n-    }\n-\n-    return(val);\n-}\n-\n-static int\n-skipArgs(const char *arg) {\n-    if ((!strcmp(arg, \"-path\")) ||\n-        (!strcmp(arg, \"--path\")) ||\n-        (!strcmp(arg, \"-maxmem\")) ||\n-        (!strcmp(arg, \"--maxmem\")) ||\n-#ifdef LIBXML_OUTPUT_ENABLED\n-        (!strcmp(arg, \"-o\")) ||\n-        (!strcmp(arg, \"-output\")) ||\n-        (!strcmp(arg, \"--output\")) ||\n-        (!strcmp(arg, \"-encode\")) ||\n-        (!strcmp(arg, \"--encode\")) ||\n-        (!strcmp(arg, \"-pretty\")) ||\n-        (!strcmp(arg, \"--pretty\")) ||\n-#endif\n-#ifdef LIBXML_VALID_ENABLED\n-        (!strcmp(arg, \"-dtdvalid\")) ||\n-        (!strcmp(arg, \"--dtdvalid\")) ||\n-        (!strcmp(arg, \"-dtdvalidfpi\")) ||\n-        (!strcmp(arg, \"--dtdvalidfpi\")) ||\n-#endif\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-        (!strcmp(arg, \"-relaxng\")) ||\n-        (!strcmp(arg, \"--relaxng\")) ||\n-        (!strcmp(arg, \"-schema\")) ||\n-        (!strcmp(arg, \"--schema\")) ||\n-#endif\n-#ifdef LIBXML_SCHEMATRON_ENABLED\n-        (!strcmp(arg, \"-schematron\")) ||\n-        (!strcmp(arg, \"--schematron\")) ||\n-#endif\n-#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_PATTERN_ENABLED)\n-        (!strcmp(arg, \"-pattern\")) ||\n-        (!strcmp(arg, \"--pattern\")) ||\n-#endif\n-#ifdef LIBXML_XPATH_ENABLED\n-        (!strcmp(arg, \"-xpath\")) ||\n-        (!strcmp(arg, \"--xpath\")) ||\n-#endif\n-        (!strcmp(arg, \"-max-ampl\")) ||\n-        (!strcmp(arg, \"--max-ampl\"))\n-    ) {\n-        return(1);\n-    }\n-\n-    return(0);\n-}\n-\n-static int\n-xmllintMain(int argc, const char **argv) {\n-    int i, acount;\n-    int files = 0;\n-    int version = 0;\n-    int nowrap = 0;\n-    int sax = 0;\n-#ifdef LIBXML_READER_ENABLED\n-    int stream = 0;\n-#endif\n-#ifdef LIBXML_CATALOG_ENABLED\n-    int catalogs = 0;\n-    int nocatalogs = 0;\n-#endif\n-\n-#ifdef XMLLINT_FUZZ\n-#ifdef LIBXML_DEBUG_ENABLED\n-    shell = 0;\n-    debugent = 0;\n-#endif\n-    debug = 0;\n-    maxmem = 0;\n-#ifdef LIBXML_TREE_ENABLED\n-    copy = 0;\n-#endif \/* LIBXML_TREE_ENABLED *\/\n-    noout = 0;\n-#ifdef LIBXML_OUTPUT_ENABLED\n-    format = 0;\n-    output = NULL;\n-    compress = 0;\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-#ifdef LIBXML_VALID_ENABLED\n-    postvalid = 0;\n-    dtdvalid = NULL;\n-    dtdvalidfpi = NULL;\n-    insert = 0;\n-#endif\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-    relaxng = NULL;\n-    relaxngschemas = NULL;\n-    schema = NULL;\n-    wxschemas = NULL;\n-#endif\n-#ifdef LIBXML_SCHEMATRON_ENABLED\n-    schematron = NULL;\n-    wxschematron = NULL;\n-#endif\n-    repeat = 0;\n-#if defined(LIBXML_HTML_ENABLED)\n-    html = 0;\n-    xmlout = 0;\n-#endif\n-    htmlout = 0;\n-#ifdef LIBXML_PUSH_ENABLED\n-    push = 0;\n-    pushsize = 4096;\n-#endif \/* LIBXML_PUSH_ENABLED *\/\n-#ifdef HAVE_MMAP\n-    memory = 0;\n-#endif\n-    testIO = 0;\n-    encoding = NULL;\n-#ifdef LIBXML_XINCLUDE_ENABLED\n-    xinclude = 0;\n-#endif\n-    progresult = XMLLINT_RETURN_OK;\n-    quiet = 0;\n-    timing = 0;\n-    generate = 0;\n-    dropdtd = 0;\n-#ifdef LIBXML_C14N_ENABLED\n-    canonical = 0;\n-    canonical_11 = 0;\n-    exc_canonical = 0;\n-#endif\n-#ifdef LIBXML_READER_ENABLED\n-    walker = 0;\n-#ifdef LIBXML_PATTERN_ENABLED\n-    pattern = NULL;\n-    patternc = NULL;\n-    patstream = NULL;\n-#endif\n-#endif \/* LIBXML_READER_ENABLED *\/\n-#ifdef LIBXML_XPATH_ENABLED\n-    xpathquery = NULL;\n-#endif\n-    options = XML_PARSE_COMPACT | XML_PARSE_BIG_LINES;\n-    maxAmpl = 0;\n-    defaultEntityLoader = NULL;\n-#endif \/* XMLLINT_FUZZ *\/\n-\n-    if (argc <= 1) {\n-    usage(ERR_STREAM, argv[0]);\n-    return(XMLLINT_ERR_UNCLASS);\n-    }\n-\n-    \/* xmlMemSetup must be called before initializing the parser. *\/\n-    for (i = 1; i < argc ; i++) {\n-    if ((!strcmp(argv[i], \"-maxmem\")) ||\n-        (!strcmp(argv[i], \"--maxmem\"))) {\n-            i++;\n-            if (i >= argc) {\n-                fprintf(ERR_STREAM, \"maxmem: missing integer value\\n\");\n-                return(XMLLINT_ERR_UNCLASS);\n-            }\n-            errno = 0;\n-            maxmem = parseInteger(\"maxmem\", argv[i], 0, INT_MAX);\n-        } else if (argv[i][0] == '-') {\n-            i += skipArgs(argv[i]);\n-    }\n-    }\n-    if (maxmem != 0)\n-        xmlMemSetup(myFreeFunc, myMallocFunc, myReallocFunc, myStrdupFunc);\n-\n-    LIBXML_TEST_VERSION\n-\n-    for (i = 1; i < argc ; i++) {\n-    if (argv[i][0] != '-' || argv[i][1] == 0)\n-        continue;\n-\n-    if ((!strcmp(argv[i], \"-debug\")) || (!strcmp(argv[i], \"--debug\")))\n-        debug++;\n-    else\n-#ifdef LIBXML_DEBUG_ENABLED\n-    if ((!strcmp(argv[i], \"-shell\")) ||\n-             (!strcmp(argv[i], \"--shell\"))) {\n-        shell++;\n-            noout = 1;\n-        } else\n-#endif\n-#ifdef LIBXML_TREE_ENABLED\n-    if ((!strcmp(argv[i], \"-copy\")) || (!strcmp(argv[i], \"--copy\")))\n-        copy++;\n-    else\n-#endif \/* LIBXML_TREE_ENABLED *\/\n-    if ((!strcmp(argv[i], \"-recover\")) ||\n-             (!strcmp(argv[i], \"--recover\"))) {\n-        options |= XML_PARSE_RECOVER;\n-    } else if ((!strcmp(argv[i], \"-huge\")) ||\n-             (!strcmp(argv[i], \"--huge\"))) {\n-        options |= XML_PARSE_HUGE;\n-    } else if ((!strcmp(argv[i], \"-noent\")) ||\n-             (!strcmp(argv[i], \"--noent\"))) {\n-        options |= XML_PARSE_NOENT;\n-    } else if ((!strcmp(argv[i], \"-noenc\")) ||\n-             (!strcmp(argv[i], \"--noenc\"))) {\n-        options |= XML_PARSE_IGNORE_ENC;\n-    } else if ((!strcmp(argv[i], \"-nsclean\")) ||\n-             (!strcmp(argv[i], \"--nsclean\"))) {\n-        options |= XML_PARSE_NSCLEAN;\n-    } else if ((!strcmp(argv[i], \"-nocdata\")) ||\n-             (!strcmp(argv[i], \"--nocdata\"))) {\n-        options |= XML_PARSE_NOCDATA;\n-    } else if ((!strcmp(argv[i], \"-nodict\")) ||\n-             (!strcmp(argv[i], \"--nodict\"))) {\n-        options |= XML_PARSE_NODICT;\n-    } else if ((!strcmp(argv[i], \"-version\")) ||\n-             (!strcmp(argv[i], \"--version\"))) {\n-        showVersion(argv[0]);\n-        version = 1;\n-    } else if ((!strcmp(argv[i], \"-noout\")) ||\n-             (!strcmp(argv[i], \"--noout\")))\n-        noout++;\n-    else if ((!strcmp(argv[i], \"-htmlout\")) ||\n-             (!strcmp(argv[i], \"--htmlout\")))\n-        htmlout++;\n-    else if ((!strcmp(argv[i], \"-nowrap\")) ||\n-             (!strcmp(argv[i], \"--nowrap\")))\n-        nowrap++;\n-#ifdef LIBXML_HTML_ENABLED\n-    else if ((!strcmp(argv[i], \"-html\")) ||\n-             (!strcmp(argv[i], \"--html\"))) {\n-        html++;\n-        }\n-    else if ((!strcmp(argv[i], \"-xmlout\")) ||\n-             (!strcmp(argv[i], \"--xmlout\"))) {\n-        xmlout++;\n-    } else if ((!strcmp(argv[i], \"-nodefdtd\")) ||\n-             (!strcmp(argv[i], \"--nodefdtd\"))) {\n-        options |= HTML_PARSE_NODEFDTD;\n-        }\n-#endif \/* LIBXML_HTML_ENABLED *\/\n-    else if ((!strcmp(argv[i], \"-loaddtd\")) ||\n-             (!strcmp(argv[i], \"--loaddtd\"))) {\n-        options |= XML_PARSE_DTDLOAD;\n-    } else if ((!strcmp(argv[i], \"-dtdattr\")) ||\n-             (!strcmp(argv[i], \"--dtdattr\"))) {\n-        options |= XML_PARSE_DTDATTR;\n-    }\n-#ifdef LIBXML_VALID_ENABLED\n-    else if ((!strcmp(argv[i], \"-valid\")) ||\n-             (!strcmp(argv[i], \"--valid\"))) {\n-        options |= XML_PARSE_DTDVALID;\n-    } else if ((!strcmp(argv[i], \"-postvalid\")) ||\n-             (!strcmp(argv[i], \"--postvalid\"))) {\n-        postvalid++;\n-        options |= XML_PARSE_DTDLOAD;\n-    } else if ((!strcmp(argv[i], \"-dtdvalid\")) ||\n-             (!strcmp(argv[i], \"--dtdvalid\"))) {\n-        i++;\n-        dtdvalid = argv[i];\n-        options |= XML_PARSE_DTDLOAD;\n-    } else if ((!strcmp(argv[i], \"-dtdvalidfpi\")) ||\n-             (!strcmp(argv[i], \"--dtdvalidfpi\"))) {\n-        i++;\n-        dtdvalidfpi = argv[i];\n-        options |= XML_PARSE_DTDLOAD;\n-        }\n-    else if ((!strcmp(argv[i], \"-insert\")) ||\n-             (!strcmp(argv[i], \"--insert\")))\n-        insert++;\n-#endif \/* LIBXML_VALID_ENABLED *\/\n-    else if ((!strcmp(argv[i], \"-dropdtd\")) ||\n-             (!strcmp(argv[i], \"--dropdtd\")))\n-        dropdtd++;\n-    else if ((!strcmp(argv[i], \"-quiet\")) ||\n-             (!strcmp(argv[i], \"--quiet\")))\n-        quiet++;\n-    else if ((!strcmp(argv[i], \"-timing\")) ||\n-             (!strcmp(argv[i], \"--timing\")))\n-        timing++;\n-    else if ((!strcmp(argv[i], \"-auto\")) ||\n-             (!strcmp(argv[i], \"--auto\")))\n-        generate++;\n-    else if ((!strcmp(argv[i], \"-repeat\")) ||\n-             (!strcmp(argv[i], \"--repeat\"))) {\n-        if (repeat)\n-            repeat *= 10;\n-        else\n-            repeat = 100;\n-    }\n-#ifdef LIBXML_PUSH_ENABLED\n-    else if ((!strcmp(argv[i], \"-push\")) ||\n-             (!strcmp(argv[i], \"--push\")))\n-        push++;\n-    else if ((!strcmp(argv[i], \"-pushsmall\")) ||\n-             (!strcmp(argv[i], \"--pushsmall\"))) {\n-        push++;\n-            pushsize = 10;\n-        }\n-#endif \/* LIBXML_PUSH_ENABLED *\/\n-#ifdef HAVE_MMAP\n-    else if ((!strcmp(argv[i], \"-memory\")) ||\n-             (!strcmp(argv[i], \"--memory\")))\n-        memory++;\n-#endif\n-    else if ((!strcmp(argv[i], \"-testIO\")) ||\n-             (!strcmp(argv[i], \"--testIO\")))\n-        testIO++;\n-#ifdef LIBXML_XINCLUDE_ENABLED\n-    else if ((!strcmp(argv[i], \"-xinclude\")) ||\n-             (!strcmp(argv[i], \"--xinclude\"))) {\n-        xinclude++;\n-        options |= XML_PARSE_XINCLUDE;\n-    }\n-    else if ((!strcmp(argv[i], \"-noxincludenode\")) ||\n-             (!strcmp(argv[i], \"--noxincludenode\"))) {\n-        xinclude++;\n-        options |= XML_PARSE_XINCLUDE;\n-        options |= XML_PARSE_NOXINCNODE;\n-    }\n-    else if ((!strcmp(argv[i], \"-nofixup-base-uris\")) ||\n-             (!strcmp(argv[i], \"--nofixup-base-uris\"))) {\n-        xinclude++;\n-        options |= XML_PARSE_XINCLUDE;\n-        options |= XML_PARSE_NOBASEFIX;\n-    }\n-#endif\n-    else if ((!strcmp(argv[i], \"-nowarning\")) ||\n-             (!strcmp(argv[i], \"--nowarning\"))) {\n-        options |= XML_PARSE_NOWARNING;\n-            options &= ~XML_PARSE_PEDANTIC;\n-        }\n-    else if ((!strcmp(argv[i], \"-pedantic\")) ||\n-             (!strcmp(argv[i], \"--pedantic\"))) {\n-        options |= XML_PARSE_PEDANTIC;\n-            options &= ~XML_PARSE_NOWARNING;\n-        }\n-#ifdef LIBXML_DEBUG_ENABLED\n-    else if ((!strcmp(argv[i], \"-debugent\")) ||\n-         (!strcmp(argv[i], \"--debugent\"))) {\n-        debugent++;\n-    }\n-#endif\n-#ifdef LIBXML_C14N_ENABLED\n-    else if ((!strcmp(argv[i], \"-c14n\")) ||\n-         (!strcmp(argv[i], \"--c14n\"))) {\n-        canonical++;\n-        options |= XML_PARSE_NOENT | XML_PARSE_DTDATTR | XML_PARSE_DTDLOAD;\n-    }\n-    else if ((!strcmp(argv[i], \"-c14n11\")) ||\n-         (!strcmp(argv[i], \"--c14n11\"))) {\n-        canonical_11++;\n-        options |= XML_PARSE_NOENT | XML_PARSE_DTDATTR | XML_PARSE_DTDLOAD;\n-    }\n-    else if ((!strcmp(argv[i], \"-exc-c14n\")) ||\n-         (!strcmp(argv[i], \"--exc-c14n\"))) {\n-        exc_canonical++;\n-        options |= XML_PARSE_NOENT | XML_PARSE_DTDATTR | XML_PARSE_DTDLOAD;\n-    }\n-#endif\n-#ifdef LIBXML_CATALOG_ENABLED\n-    else if ((!strcmp(argv[i], \"-catalogs\")) ||\n-         (!strcmp(argv[i], \"--catalogs\"))) {\n-        catalogs++;\n-    } else if ((!strcmp(argv[i], \"-nocatalogs\")) ||\n-         (!strcmp(argv[i], \"--nocatalogs\"))) {\n-        nocatalogs++;\n-    }\n-#endif\n-    else if ((!strcmp(argv[i], \"-noblanks\")) ||\n-             (!strcmp(argv[i], \"--noblanks\"))) {\n-            options |= XML_PARSE_NOBLANKS;\n-        }\n-    else if ((!strcmp(argv[i], \"-maxmem\")) ||\n-             (!strcmp(argv[i], \"--maxmem\"))) {\n-         i++;\n-        }\n-#ifdef LIBXML_OUTPUT_ENABLED\n-    else if ((!strcmp(argv[i], \"-o\")) ||\n-             (!strcmp(argv[i], \"-output\")) ||\n-             (!strcmp(argv[i], \"--output\"))) {\n-        i++;\n-        output = argv[i];\n-    }\n-    else if ((!strcmp(argv[i], \"-format\")) ||\n-             (!strcmp(argv[i], \"--format\"))) {\n-        format = 1;\n-            options |= XML_PARSE_NOBLANKS;\n-    }\n-    else if ((!strcmp(argv[i], \"-encode\")) ||\n-             (!strcmp(argv[i], \"--encode\"))) {\n-        i++;\n-        encoding = argv[i];\n-        \/*\n-         * OK it's for testing purposes\n-         *\/\n-        xmlAddEncodingAlias(\"UTF-8\", \"DVEnc\");\n-        }\n-    else if ((!strcmp(argv[i], \"-pretty\")) ||\n-             (!strcmp(argv[i], \"--pretty\"))) {\n-        i++;\n-            if (argv[i] != NULL)\n-            format = atoi(argv[i]);\n-    }\n-#ifdef LIBXML_ZLIB_ENABLED\n-    else if ((!strcmp(argv[i], \"-compress\")) ||\n-             (!strcmp(argv[i], \"--compress\"))) {\n-        compress++;\n-        }\n-#endif\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-#ifdef LIBXML_READER_ENABLED\n-    else if ((!strcmp(argv[i], \"-stream\")) ||\n-             (!strcmp(argv[i], \"--stream\"))) {\n-         stream++;\n-    }\n-    else if ((!strcmp(argv[i], \"-walker\")) ||\n-             (!strcmp(argv[i], \"--walker\"))) {\n-         walker++;\n-             noout++;\n-        }\n-#ifdef LIBXML_PATTERN_ENABLED\n-        else if ((!strcmp(argv[i], \"-pattern\")) ||\n-                   (!strcmp(argv[i], \"--pattern\"))) {\n-        i++;\n-        pattern = argv[i];\n-    }\n-#endif\n-#endif \/* LIBXML_READER_ENABLED *\/\n-#ifdef LIBXML_SAX1_ENABLED\n-    else if ((!strcmp(argv[i], \"-sax1\")) ||\n-             (!strcmp(argv[i], \"--sax1\"))) {\n-        options |= XML_PARSE_SAX1;\n-    }\n-#endif \/* LIBXML_SAX1_ENABLED *\/\n-    else if ((!strcmp(argv[i], \"-sax\")) ||\n-             (!strcmp(argv[i], \"--sax\"))) {\n-        sax++;\n-        }\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-    else if ((!strcmp(argv[i], \"-relaxng\")) ||\n-             (!strcmp(argv[i], \"--relaxng\"))) {\n-        i++;\n-        relaxng = argv[i];\n-        options |= XML_PARSE_NOENT;\n-    } else if ((!strcmp(argv[i], \"-schema\")) ||\n-             (!strcmp(argv[i], \"--schema\"))) {\n-        i++;\n-        schema = argv[i];\n-        options |= XML_PARSE_NOENT;\n-        }\n-#endif\n-#ifdef LIBXML_SCHEMATRON_ENABLED\n-    else if ((!strcmp(argv[i], \"-schematron\")) ||\n-             (!strcmp(argv[i], \"--schematron\"))) {\n-        i++;\n-        schematron = argv[i];\n-        options |= XML_PARSE_NOENT;\n-        }\n-#endif\n-        else if ((!strcmp(argv[i], \"-nonet\")) ||\n-                   (!strcmp(argv[i], \"--nonet\"))) {\n-        options |= XML_PARSE_NONET;\n-#ifndef XMLLINT_FUZZ\n-        xmlSetExternalEntityLoader(xmlNoNetExternalEntityLoader);\n-#endif\n-        } else if ((!strcmp(argv[i], \"-nocompact\")) ||\n-                   (!strcmp(argv[i], \"--nocompact\"))) {\n-        options &= ~XML_PARSE_COMPACT;\n-    } else if ((!strcmp(argv[i], \"-load-trace\")) ||\n-               (!strcmp(argv[i], \"--load-trace\"))) {\n-        load_trace++;\n-        } else if ((!strcmp(argv[i], \"-path\")) ||\n-                   (!strcmp(argv[i], \"--path\"))) {\n-        i++;\n-        parsePath(BAD_CAST argv[i]);\n-        }\n-#ifdef LIBXML_XPATH_ENABLED\n-        else if ((!strcmp(argv[i], \"-xpath\")) ||\n-                   (!strcmp(argv[i], \"--xpath\"))) {\n-        i++;\n-        noout++;\n-        xpathquery = argv[i];\n-        }\n-#endif\n-    else if ((!strcmp(argv[i], \"-oldxml10\")) ||\n-               (!strcmp(argv[i], \"--oldxml10\"))) {\n-        options |= XML_PARSE_OLD10;\n-    } else if ((!strcmp(argv[i], \"-max-ampl\")) ||\n-               (!strcmp(argv[i], \"--max-ampl\"))) {\n-            i++;\n-            if (i >= argc) {\n-                fprintf(ERR_STREAM, \"max-ampl: missing integer value\\n\");\n-                return(XMLLINT_ERR_UNCLASS);\n-            }\n-            maxAmpl = parseInteger(\"max-ampl\", argv[i], 1, UINT_MAX);\n-    } else {\n-        fprintf(ERR_STREAM, \"Unknown option %s\\n\", argv[i]);\n-        usage(ERR_STREAM, argv[0]);\n-        return(XMLLINT_ERR_UNCLASS);\n-    }\n-    }\n-\n-#ifdef LIBXML_CATALOG_ENABLED\n-    if (nocatalogs == 0) {\n-    if (catalogs) {\n-        const char *catal;\n-\n-        catal = getenv(\"SGML_CATALOG_FILES\");\n-        if (catal != NULL) {\n-        xmlLoadCatalogs(catal);\n-        } else {\n-        fprintf(ERR_STREAM, \"Variable $SGML_CATALOG_FILES not set\\n\");\n-        }\n-    }\n-    }\n-#endif\n-\n-#ifdef LIBXML_OUTPUT_ENABLED\n-    {\n-        const char *indent = getenv(\"XMLLINT_INDENT\");\n-        if (indent != NULL) {\n-            xmlTreeIndentString = indent;\n-        }\n-    }\n-#endif\n-\n-    defaultEntityLoader = xmlGetExternalEntityLoader();\n-    xmlSetExternalEntityLoader(xmllintExternalEntityLoader);\n-\n-    if ((htmlout) && (!nowrap)) {\n-    fprintf(ERR_STREAM,\n-         \"<!DOCTYPE HTML PUBLIC \\\"-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\\\"\\n\");\n-    fprintf(ERR_STREAM,\n-        \"\\t\\\"http:\/\/www.w3.org\/TR\/REC-html40\/loose.dtd\\\">\\n\");\n-    fprintf(ERR_STREAM,\n-     \"<html><head><title>%s output<\/title><\/head>\\n\",\n-        argv[0]);\n-    fprintf(ERR_STREAM,\n-     \"<body bgcolor=\\\"#ffffff\\\"><h1 align=\\\"center\\\">%s output<\/h1>\\n\",\n-        argv[0]);\n-    }\n-\n-#ifdef LIBXML_SCHEMATRON_ENABLED\n-    if ((schematron != NULL) && (sax == 0)\n-#ifdef LIBXML_READER_ENABLED\n-        && (stream == 0)\n-#endif \/* LIBXML_READER_ENABLED *\/\n-    ) {\n-    xmlSchematronParserCtxtPtr ctxt;\n-\n-        \/* forces loading the DTDs *\/\n-    options |= XML_PARSE_DTDLOAD;\n-    if (timing) {\n-        startTimer();\n-    }\n-    ctxt = xmlSchematronNewParserCtxt(schematron);\n-        if (ctxt == NULL) {\n-            progresult = XMLLINT_ERR_MEM;\n-            goto error;\n-        }\n-    wxschematron = xmlSchematronParse(ctxt);\n-    if (wxschematron == NULL) {\n-        fprintf(ERR_STREAM,\n-            \"Schematron schema %s failed to compile\\n\", schematron);\n-            progresult = XMLLINT_ERR_SCHEMACOMP;\n-        schematron = NULL;\n-    }\n-    xmlSchematronFreeParserCtxt(ctxt);\n-    if (timing) {\n-        endTimer(\"Compiling the schemas\");\n-    }\n-    }\n-#endif\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-    if ((relaxng != NULL) && (sax == 0)\n-#ifdef LIBXML_READER_ENABLED\n-        && (stream == 0)\n-#endif \/* LIBXML_READER_ENABLED *\/\n-    ) {\n-    xmlRelaxNGParserCtxtPtr ctxt;\n-\n-        \/* forces loading the DTDs *\/\n-    options |= XML_PARSE_DTDLOAD;\n-    if (timing) {\n-        startTimer();\n-    }\n-    ctxt = xmlRelaxNGNewParserCtxt(relaxng);\n-        if (ctxt == NULL) {\n-            progresult = XMLLINT_ERR_MEM;\n-            goto error;\n-        }\n-    relaxngschemas = xmlRelaxNGParse(ctxt);\n-    if (relaxngschemas == NULL) {\n-        fprintf(ERR_STREAM,\n-            \"Relax-NG schema %s failed to compile\\n\", relaxng);\n-            progresult = XMLLINT_ERR_SCHEMACOMP;\n-        relaxng = NULL;\n-    }\n-    xmlRelaxNGFreeParserCtxt(ctxt);\n-    if (timing) {\n-        endTimer(\"Compiling the schemas\");\n-    }\n-    } else if ((schema != NULL)\n-#ifdef LIBXML_READER_ENABLED\n-        && (stream == 0)\n-#endif\n-    ) {\n-    xmlSchemaParserCtxtPtr ctxt;\n-\n-    if (timing) {\n-        startTimer();\n-    }\n-    ctxt = xmlSchemaNewParserCtxt(schema);\n-        if (ctxt == NULL) {\n-            progresult = XMLLINT_ERR_MEM;\n-            goto error;\n-        }\n-    wxschemas = xmlSchemaParse(ctxt);\n-    if (wxschemas == NULL) {\n-        fprintf(ERR_STREAM,\n-            \"WXS schema %s failed to compile\\n\", schema);\n-            progresult = XMLLINT_ERR_SCHEMACOMP;\n-        schema = NULL;\n-    }\n-    xmlSchemaFreeParserCtxt(ctxt);\n-    if (timing) {\n-        endTimer(\"Compiling the schemas\");\n-    }\n-    }\n-#endif \/* LIBXML_SCHEMAS_ENABLED *\/\n-#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_PATTERN_ENABLED)\n-    if ((pattern != NULL) && (walker == 0)) {\n-        patternc = xmlPatterncompile((const xmlChar *) pattern, NULL, 0, NULL);\n-    if (patternc == NULL) {\n-        fprintf(ERR_STREAM,\n-            \"Pattern %s failed to compile\\n\", pattern);\n-            progresult = XMLLINT_ERR_SCHEMAPAT;\n-        pattern = NULL;\n-    }\n-    }\n-#endif \/* LIBXML_READER_ENABLED && LIBXML_PATTERN_ENABLED *\/\n-    for (i = 1; i < argc ; i++) {\n-    if ((argv[i][0] == '-') && (strcmp(argv[i], \"-\") != 0)) {\n-            i += skipArgs(argv[i]);\n-            continue;\n-        }\n-    if ((timing) && (repeat))\n-        startTimer();\n-        if (repeat) {\n-            xmlParserCtxtPtr ctxt;\n-\n-            ctxt = xmlNewParserCtxt();\n-            if (ctxt == NULL) {\n-                progresult = XMLLINT_ERR_MEM;\n-                goto error;\n-            }\n-            if (maxAmpl > 0)\n-                xmlCtxtSetMaxAmplification(ctxt, maxAmpl);\n-\n-            for (acount = 0;acount < repeat;acount++) {\n-#ifdef LIBXML_READER_ENABLED\n-                if (stream != 0) {\n-                    streamFile(argv[i]);\n-                } else {\n-#endif \/* LIBXML_READER_ENABLED *\/\n-                    if (sax) {\n-                        testSAX(argv[i]);\n-                    } else {\n-                        parseAndPrintFile(argv[i], ctxt);\n-                    }\n-#ifdef LIBXML_READER_ENABLED\n-                }\n-#endif \/* LIBXML_READER_ENABLED *\/\n-            }\n-\n-            xmlFreeParserCtxt(ctxt);\n-        } else {\n-#ifdef LIBXML_READER_ENABLED\n-            if (stream != 0)\n-                streamFile(argv[i]);\n-            else\n-#endif \/* LIBXML_READER_ENABLED *\/\n-            if (sax) {\n-                testSAX(argv[i]);\n-            } else {\n-                parseAndPrintFile(argv[i], NULL);\n-            }\n-        }\n-        files ++;\n-        if ((timing) && (repeat)) {\n-            endTimer(\"%d iterations\", repeat);\n-        }\n-    }\n-    if (generate)\n-    parseAndPrintFile(NULL, NULL);\n-    if ((htmlout) && (!nowrap)) {\n-    fprintf(ERR_STREAM, \"<\/body><\/html>\\n\");\n-    }\n-    if ((files == 0) && (!generate) && (version == 0)) {\n-    usage(ERR_STREAM, argv[0]);\n-        progresult = XMLLINT_ERR_UNCLASS;\n-    }\n-#ifdef LIBXML_SCHEMATRON_ENABLED\n-    if (wxschematron != NULL)\n-    xmlSchematronFree(wxschematron);\n-#endif\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-    if (relaxngschemas != NULL)\n-    xmlRelaxNGFree(relaxngschemas);\n-    if (wxschemas != NULL)\n-    xmlSchemaFree(wxschemas);\n-#endif\n-#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_PATTERN_ENABLED)\n-    if (patternc != NULL)\n-        xmlFreePattern(patternc);\n-#endif\n-\n-    \/* Avoid unused label warning if features are disabled. *\/\n-    goto error;\n-\n-error:\n-    if (defaultEntityLoader != NULL)\n-        xmlSetExternalEntityLoader(defaultEntityLoader);\n-    xmlCleanupParser();\n-\n-    return(progresult);\n-}\n-\n-#ifndef XMLLINT_FUZZ\n-int\n-main(int argc, char **argv) {\n-    return(xmllintMain(argc, (const char **) argv));\n-}\n-#endif\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmllint.c","additions":0,"deletions":3792,"binary":false,"changes":3792,"status":"deleted"},{"patch":"@@ -1,304 +0,0 @@\n-\/*\n- * xmlmodule.c : basic API for dynamic module loading added 2.6.17\n- *\n- * See Copyright for the status of this software.\n- *\n- * joelwreed@comcast.net\n- *\n- * http:\/\/www.fortran-2000.com\/ArnaudRecipes\/sharedlib.html\n- *\/\n-\n-\/* In order RTLD_GLOBAL and RTLD_NOW to be defined on zOS *\/\n-#if defined(__MVS__)\n-#define _UNIX03_SOURCE\n-#endif\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-\n-#include <string.h>\n-#include <libxml\/xmlmodule.h>\n-#include <libxml\/xmlmemory.h>\n-#include <libxml\/xmlerror.h>\n-#include <libxml\/xmlstring.h>\n-\n-#include \"private\/error.h\"\n-\n-#ifdef LIBXML_MODULES_ENABLED\n-\n-struct _xmlModule {\n-    unsigned char *name;\n-    void *handle;\n-};\n-\n-static void *xmlModulePlatformOpen(const char *name);\n-static int xmlModulePlatformClose(void *handle);\n-static int xmlModulePlatformSymbol(void *handle, const char *name, void **result);\n-\n-\/************************************************************************\n- *                                    *\n- *        module memory error handler                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlModuleOpen:\n- * @name: the module name\n- * @options: a set of xmlModuleOption\n- *\n- * Opens a module\/shared library given its name or path\n- * NOTE: that due to portability issues, behaviour can only be\n- * guaranteed with @name using ASCII. We cannot guarantee that\n- * an UTF-8 string would work, which is why name is a const char *\n- * and not a const xmlChar * .\n- * TODO: options are not yet implemented.\n- *\n- * Returns a handle for the module or NULL in case of error\n- *\/\n-xmlModulePtr\n-xmlModuleOpen(const char *name, int options ATTRIBUTE_UNUSED)\n-{\n-    xmlModulePtr module;\n-\n-    module = (xmlModulePtr) xmlMalloc(sizeof(xmlModule));\n-    if (module == NULL)\n-        return (NULL);\n-\n-    memset(module, 0, sizeof(xmlModule));\n-\n-    module->handle = xmlModulePlatformOpen(name);\n-\n-    if (module->handle == NULL) {\n-        xmlFree(module);\n-        return(NULL);\n-    }\n-\n-    module->name = xmlStrdup((const xmlChar *) name);\n-    return (module);\n-}\n-\n-\/**\n- * xmlModuleSymbol:\n- * @module: the module\n- * @name: the name of the symbol\n- * @symbol: the resulting symbol address\n- *\n- * Lookup for a symbol address in the given module\n- * NOTE: that due to portability issues, behaviour can only be\n- * guaranteed with @name using ASCII. We cannot guarantee that\n- * an UTF-8 string would work, which is why name is a const char *\n- * and not a const xmlChar * .\n- *\n- * Returns 0 if the symbol was found, or -1 in case of error\n- *\/\n-int\n-xmlModuleSymbol(xmlModulePtr module, const char *name, void **symbol)\n-{\n-    int rc = -1;\n-\n-    if ((NULL == module) || (symbol == NULL) || (name == NULL))\n-        return rc;\n-\n-    rc = xmlModulePlatformSymbol(module->handle, name, symbol);\n-\n-    if (rc == -1)\n-        return rc;\n-\n-    return rc;\n-}\n-\n-\/**\n- * xmlModuleClose:\n- * @module: the module handle\n- *\n- * The close operations unload the associated module and free the\n- * data associated to the module.\n- *\n- * Returns 0 in case of success, -1 in case of argument error and -2\n- *         if the module could not be closed\/unloaded.\n- *\/\n-int\n-xmlModuleClose(xmlModulePtr module)\n-{\n-    int rc;\n-\n-    if (NULL == module)\n-        return -1;\n-\n-    rc = xmlModulePlatformClose(module->handle);\n-\n-    if (rc != 0)\n-        return -2;\n-\n-    rc = xmlModuleFree(module);\n-    return (rc);\n-}\n-\n-\/**\n- * xmlModuleFree:\n- * @module: the module handle\n- *\n- * The free operations free the data associated to the module\n- * but does not unload the associated shared library which may still\n- * be in use.\n- *\n- * Returns 0 in case of success, -1 in case of argument error\n- *\/\n-int\n-xmlModuleFree(xmlModulePtr module)\n-{\n-    if (NULL == module)\n-        return -1;\n-\n-    xmlFree(module->name);\n-    xmlFree(module);\n-\n-    return (0);\n-}\n-\n-#if defined(HAVE_DLOPEN) && !defined(_WIN32)\n-#ifdef HAVE_DLFCN_H\n-#include <dlfcn.h>\n-#endif\n-\n-#ifndef RTLD_GLOBAL            \/* For Tru64 UNIX 4.0 *\/\n-#define RTLD_GLOBAL 0\n-#endif\n-\n-\/**\n- * xmlModulePlatformOpen:\n- * @name: path to the module\n- *\n- * returns a handle on success, and zero on error.\n- *\/\n-\n-static void *\n-xmlModulePlatformOpen(const char *name)\n-{\n-    return dlopen(name, RTLD_GLOBAL | RTLD_NOW);\n-}\n-\n-\/*\n- * xmlModulePlatformClose:\n- * @handle: handle to the module\n- *\n- * returns 0 on success, and non-zero on error.\n- *\/\n-\n-static int\n-xmlModulePlatformClose(void *handle)\n-{\n-    return dlclose(handle);\n-}\n-\n-\/*\n- * xmlModulePlatformSymbol:\n- * http:\/\/www.opengroup.org\/onlinepubs\/009695399\/functions\/dlsym.html\n- * returns 0 on success and the loaded symbol in result, and -1 on error.\n- *\/\n-\n-static int\n-xmlModulePlatformSymbol(void *handle, const char *name, void **symbol)\n-{\n-    *symbol = dlsym(handle, name);\n-    if (dlerror() != NULL) {\n-    return -1;\n-    }\n-    return 0;\n-}\n-\n-#else \/* ! HAVE_DLOPEN *\/\n-\n-#ifdef HAVE_SHLLOAD             \/* HAVE_SHLLOAD *\/\n-#ifdef HAVE_DL_H\n-#include <dl.h>\n-#endif\n-\/*\n- * xmlModulePlatformOpen:\n- * returns a handle on success, and zero on error.\n- *\/\n-\n-static void *\n-xmlModulePlatformOpen(const char *name)\n-{\n-    return shl_load(name, BIND_IMMEDIATE, 0L);\n-}\n-\n-\/*\n- * xmlModulePlatformClose:\n- * returns 0 on success, and non-zero on error.\n- *\/\n-\n-static int\n-xmlModulePlatformClose(void *handle)\n-{\n-    return shl_unload(handle);\n-}\n-\n-\/*\n- * xmlModulePlatformSymbol:\n- * http:\/\/docs.hp.com\/en\/B2355-90683\/shl_load.3X.html\n- * returns 0 on success and the loaded symbol in result, and -1 on error.\n- *\/\n-\n-static int\n-xmlModulePlatformSymbol(void *handle, const char *name, void **symbol)\n-{\n-    int rc;\n-\n-    errno = 0;\n-    rc = shl_findsym(&handle, name, TYPE_UNDEFINED, symbol);\n-    return rc;\n-}\n-\n-#endif \/* HAVE_SHLLOAD *\/\n-#endif \/* ! HAVE_DLOPEN *\/\n-\n-#if defined(_WIN32)\n-\n-#define WIN32_LEAN_AND_MEAN\n-#include <windows.h>\n-\n-\/*\n- * xmlModulePlatformOpen:\n- * returns a handle on success, and zero on error.\n- *\/\n-\n-static void *\n-xmlModulePlatformOpen(const char *name)\n-{\n-    return LoadLibraryA(name);\n-}\n-\n-\/*\n- * xmlModulePlatformClose:\n- * returns 0 on success, and non-zero on error.\n- *\/\n-\n-static int\n-xmlModulePlatformClose(void *handle)\n-{\n-    int rc;\n-\n-    rc = FreeLibrary(handle);\n-    return (0 == rc);\n-}\n-\n-\/*\n- * xmlModulePlatformSymbol:\n- * http:\/\/msdn.microsoft.com\/library\/default.asp?url=\/library\/en-us\/dllproc\/base\/getprocaddress.asp\n- * returns 0 on success and the loaded symbol in result, and -1 on error.\n- *\/\n-\n-static int\n-xmlModulePlatformSymbol(void *handle, const char *name, void **symbol)\n-{\n-XML_IGNORE_FPTR_CAST_WARNINGS\n-    *symbol = GetProcAddress(handle, name);\n-    return (NULL == *symbol) ? -1 : 0;\n-XML_POP_WARNINGS\n-}\n-\n-#endif \/* _WIN32 *\/\n-\n-#endif \/* LIBXML_MODULES_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlmodule.c","additions":0,"deletions":304,"binary":false,"changes":304,"status":"deleted"},{"patch":"@@ -1,8015 +0,0 @@\n-\/*\n- * regexp.c: generic and extensible Regular Expression engine\n- *\n- * Basically designed with the purpose of compiling regexps for\n- * the variety of validation\/schemas mechanisms now available in\n- * XML related specifications these include:\n- *    - XML-1.0 DTD validation\n- *    - XML Schemas structure part 1\n- *    - XML Schemas Datatypes part 2 especially Appendix F\n- *    - RELAX-NG\/TREX i.e. the counter proposal\n- *\n- * See Copyright for the status of this software.\n- *\n- * Daniel Veillard <veillard@redhat.com>\n- *\/\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-\n-#ifdef LIBXML_REGEXP_ENABLED\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <limits.h>\n-\n-#include <libxml\/tree.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/xmlregexp.h>\n-#include <libxml\/xmlautomata.h>\n-#include <libxml\/xmlunicode.h>\n-\n-#include \"private\/error.h\"\n-#include \"private\/regexp.h\"\n-\n-#ifndef SIZE_MAX\n-#define SIZE_MAX ((size_t) -1)\n-#endif\n-\n-#define MAX_PUSH 10000000\n-\n-#ifdef ERROR\n-#undef ERROR\n-#endif\n-#define ERROR(str)                            \\\n-    ctxt->error = XML_REGEXP_COMPILE_ERROR;                \\\n-    xmlRegexpErrCompile(ctxt, str);\n-#define NEXT ctxt->cur++\n-#define CUR (*(ctxt->cur))\n-#define NXT(index) (ctxt->cur[index])\n-\n-#define NEXTL(l) ctxt->cur += l;\n-#define XML_REG_STRING_SEPARATOR '|'\n-\/*\n- * Need PREV to check on a '-' within a Character Group. May only be used\n- * when it's guaranteed that cur is not at the beginning of ctxt->string!\n- *\/\n-#define PREV (ctxt->cur[-1])\n-\n-\/************************************************************************\n- *                                    *\n- *            Datatypes and structures            *\n- *                                    *\n- ************************************************************************\/\n-\n-\/*\n- * Note: the order of the enums below is significant, do not shuffle\n- *\/\n-typedef enum {\n-    XML_REGEXP_EPSILON = 1,\n-    XML_REGEXP_CHARVAL,\n-    XML_REGEXP_RANGES,\n-    XML_REGEXP_SUBREG,  \/* used for () sub regexps *\/\n-    XML_REGEXP_STRING,\n-    XML_REGEXP_ANYCHAR, \/* . *\/\n-    XML_REGEXP_ANYSPACE, \/* \\s *\/\n-    XML_REGEXP_NOTSPACE, \/* \\S *\/\n-    XML_REGEXP_INITNAME, \/* \\l *\/\n-    XML_REGEXP_NOTINITNAME, \/* \\L *\/\n-    XML_REGEXP_NAMECHAR, \/* \\c *\/\n-    XML_REGEXP_NOTNAMECHAR, \/* \\C *\/\n-    XML_REGEXP_DECIMAL, \/* \\d *\/\n-    XML_REGEXP_NOTDECIMAL, \/* \\D *\/\n-    XML_REGEXP_REALCHAR, \/* \\w *\/\n-    XML_REGEXP_NOTREALCHAR, \/* \\W *\/\n-    XML_REGEXP_LETTER = 100,\n-    XML_REGEXP_LETTER_UPPERCASE,\n-    XML_REGEXP_LETTER_LOWERCASE,\n-    XML_REGEXP_LETTER_TITLECASE,\n-    XML_REGEXP_LETTER_MODIFIER,\n-    XML_REGEXP_LETTER_OTHERS,\n-    XML_REGEXP_MARK,\n-    XML_REGEXP_MARK_NONSPACING,\n-    XML_REGEXP_MARK_SPACECOMBINING,\n-    XML_REGEXP_MARK_ENCLOSING,\n-    XML_REGEXP_NUMBER,\n-    XML_REGEXP_NUMBER_DECIMAL,\n-    XML_REGEXP_NUMBER_LETTER,\n-    XML_REGEXP_NUMBER_OTHERS,\n-    XML_REGEXP_PUNCT,\n-    XML_REGEXP_PUNCT_CONNECTOR,\n-    XML_REGEXP_PUNCT_DASH,\n-    XML_REGEXP_PUNCT_OPEN,\n-    XML_REGEXP_PUNCT_CLOSE,\n-    XML_REGEXP_PUNCT_INITQUOTE,\n-    XML_REGEXP_PUNCT_FINQUOTE,\n-    XML_REGEXP_PUNCT_OTHERS,\n-    XML_REGEXP_SEPAR,\n-    XML_REGEXP_SEPAR_SPACE,\n-    XML_REGEXP_SEPAR_LINE,\n-    XML_REGEXP_SEPAR_PARA,\n-    XML_REGEXP_SYMBOL,\n-    XML_REGEXP_SYMBOL_MATH,\n-    XML_REGEXP_SYMBOL_CURRENCY,\n-    XML_REGEXP_SYMBOL_MODIFIER,\n-    XML_REGEXP_SYMBOL_OTHERS,\n-    XML_REGEXP_OTHER,\n-    XML_REGEXP_OTHER_CONTROL,\n-    XML_REGEXP_OTHER_FORMAT,\n-    XML_REGEXP_OTHER_PRIVATE,\n-    XML_REGEXP_OTHER_NA,\n-    XML_REGEXP_BLOCK_NAME\n-} xmlRegAtomType;\n-\n-typedef enum {\n-    XML_REGEXP_QUANT_EPSILON = 1,\n-    XML_REGEXP_QUANT_ONCE,\n-    XML_REGEXP_QUANT_OPT,\n-    XML_REGEXP_QUANT_MULT,\n-    XML_REGEXP_QUANT_PLUS,\n-    XML_REGEXP_QUANT_ONCEONLY,\n-    XML_REGEXP_QUANT_ALL,\n-    XML_REGEXP_QUANT_RANGE\n-} xmlRegQuantType;\n-\n-typedef enum {\n-    XML_REGEXP_START_STATE = 1,\n-    XML_REGEXP_FINAL_STATE,\n-    XML_REGEXP_TRANS_STATE,\n-    XML_REGEXP_SINK_STATE,\n-    XML_REGEXP_UNREACH_STATE\n-} xmlRegStateType;\n-\n-typedef enum {\n-    XML_REGEXP_MARK_NORMAL = 0,\n-    XML_REGEXP_MARK_START,\n-    XML_REGEXP_MARK_VISITED\n-} xmlRegMarkedType;\n-\n-typedef struct _xmlRegRange xmlRegRange;\n-typedef xmlRegRange *xmlRegRangePtr;\n-\n-struct _xmlRegRange {\n-    int neg;        \/* 0 normal, 1 not, 2 exclude *\/\n-    xmlRegAtomType type;\n-    int start;\n-    int end;\n-    xmlChar *blockName;\n-};\n-\n-typedef struct _xmlRegAtom xmlRegAtom;\n-typedef xmlRegAtom *xmlRegAtomPtr;\n-\n-typedef struct _xmlAutomataState xmlRegState;\n-typedef xmlRegState *xmlRegStatePtr;\n-\n-struct _xmlRegAtom {\n-    int no;\n-    xmlRegAtomType type;\n-    xmlRegQuantType quant;\n-    int min;\n-    int max;\n-\n-    void *valuep;\n-    void *valuep2;\n-    int neg;\n-    int codepoint;\n-    xmlRegStatePtr start;\n-    xmlRegStatePtr start0;\n-    xmlRegStatePtr stop;\n-    int maxRanges;\n-    int nbRanges;\n-    xmlRegRangePtr *ranges;\n-    void *data;\n-};\n-\n-typedef struct _xmlRegCounter xmlRegCounter;\n-typedef xmlRegCounter *xmlRegCounterPtr;\n-\n-struct _xmlRegCounter {\n-    int min;\n-    int max;\n-};\n-\n-typedef struct _xmlRegTrans xmlRegTrans;\n-typedef xmlRegTrans *xmlRegTransPtr;\n-\n-struct _xmlRegTrans {\n-    xmlRegAtomPtr atom;\n-    int to;\n-    int counter;\n-    int count;\n-    int nd;\n-};\n-\n-struct _xmlAutomataState {\n-    xmlRegStateType type;\n-    xmlRegMarkedType mark;\n-    xmlRegMarkedType markd;\n-    xmlRegMarkedType reached;\n-    int no;\n-    int maxTrans;\n-    int nbTrans;\n-    xmlRegTrans *trans;\n-    \/*  knowing states pointing to us can speed things up *\/\n-    int maxTransTo;\n-    int nbTransTo;\n-    int *transTo;\n-};\n-\n-typedef struct _xmlAutomata xmlRegParserCtxt;\n-typedef xmlRegParserCtxt *xmlRegParserCtxtPtr;\n-\n-#define AM_AUTOMATA_RNG 1\n-\n-struct _xmlAutomata {\n-    xmlChar *string;\n-    xmlChar *cur;\n-\n-    int error;\n-    int neg;\n-\n-    xmlRegStatePtr start;\n-    xmlRegStatePtr end;\n-    xmlRegStatePtr state;\n-\n-    xmlRegAtomPtr atom;\n-\n-    int maxAtoms;\n-    int nbAtoms;\n-    xmlRegAtomPtr *atoms;\n-\n-    int maxStates;\n-    int nbStates;\n-    xmlRegStatePtr *states;\n-\n-    int maxCounters;\n-    int nbCounters;\n-    xmlRegCounter *counters;\n-\n-    int determinist;\n-    int negs;\n-    int flags;\n-\n-    int depth;\n-};\n-\n-struct _xmlRegexp {\n-    xmlChar *string;\n-    int nbStates;\n-    xmlRegStatePtr *states;\n-    int nbAtoms;\n-    xmlRegAtomPtr *atoms;\n-    int nbCounters;\n-    xmlRegCounter *counters;\n-    int determinist;\n-    int flags;\n-    \/*\n-     * That's the compact form for determinists automatas\n-     *\/\n-    int nbstates;\n-    int *compact;\n-    void **transdata;\n-    int nbstrings;\n-    xmlChar **stringMap;\n-};\n-\n-typedef struct _xmlRegExecRollback xmlRegExecRollback;\n-typedef xmlRegExecRollback *xmlRegExecRollbackPtr;\n-\n-struct _xmlRegExecRollback {\n-    xmlRegStatePtr state;\/* the current state *\/\n-    int index;        \/* the index in the input stack *\/\n-    int nextbranch;    \/* the next transition to explore in that state *\/\n-    int *counts;    \/* save the automata state if it has some *\/\n-};\n-\n-typedef struct _xmlRegInputToken xmlRegInputToken;\n-typedef xmlRegInputToken *xmlRegInputTokenPtr;\n-\n-struct _xmlRegInputToken {\n-    xmlChar *value;\n-    void *data;\n-};\n-\n-struct _xmlRegExecCtxt {\n-    int status;        \/* execution status != 0 indicate an error *\/\n-    int determinist;    \/* did we find an indeterministic behaviour *\/\n-    xmlRegexpPtr comp;    \/* the compiled regexp *\/\n-    xmlRegExecCallbacks callback;\n-    void *data;\n-\n-    xmlRegStatePtr state;\/* the current state *\/\n-    int transno;    \/* the current transition on that state *\/\n-    int transcount;    \/* the number of chars in char counted transitions *\/\n-\n-    \/*\n-     * A stack of rollback states\n-     *\/\n-    int maxRollbacks;\n-    int nbRollbacks;\n-    xmlRegExecRollback *rollbacks;\n-\n-    \/*\n-     * The state of the automata if any\n-     *\/\n-    int *counts;\n-\n-    \/*\n-     * The input stack\n-     *\/\n-    int inputStackMax;\n-    int inputStackNr;\n-    int index;\n-    int *charStack;\n-    const xmlChar *inputString; \/* when operating on characters *\/\n-    xmlRegInputTokenPtr inputStack;\/* when operating on strings *\/\n-\n-    \/*\n-     * error handling\n-     *\/\n-    int errStateNo;        \/* the error state number *\/\n-    xmlRegStatePtr errState;    \/* the error state *\/\n-    xmlChar *errString;        \/* the string raising the error *\/\n-    int *errCounts;        \/* counters at the error state *\/\n-    int nbPush;\n-};\n-\n-#define REGEXP_ALL_COUNTER    0x123456\n-#define REGEXP_ALL_LAX_COUNTER    0x123457\n-\n-static void xmlFAParseRegExp(xmlRegParserCtxtPtr ctxt, int top);\n-static void xmlRegFreeState(xmlRegStatePtr state);\n-static void xmlRegFreeAtom(xmlRegAtomPtr atom);\n-static int xmlRegStrEqualWildcard(const xmlChar *expStr, const xmlChar *valStr);\n-static int xmlRegCheckCharacter(xmlRegAtomPtr atom, int codepoint);\n-static int xmlRegCheckCharacterRange(xmlRegAtomType type, int codepoint,\n-                  int neg, int start, int end, const xmlChar *blockName);\n-\n-\/************************************************************************\n- *                                    *\n- *        Regexp memory error handler                *\n- *                                    *\n- ************************************************************************\/\n-\/**\n- * xmlRegexpErrMemory:\n- * @extra:  extra information\n- *\n- * Handle an out of memory condition\n- *\/\n-static void\n-xmlRegexpErrMemory(xmlRegParserCtxtPtr ctxt)\n-{\n-    if (ctxt != NULL)\n-        ctxt->error = XML_ERR_NO_MEMORY;\n-\n-    xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_REGEXP, NULL);\n-}\n-\n-\/**\n- * xmlRegexpErrCompile:\n- * @extra:  extra information\n- *\n- * Handle a compilation failure\n- *\/\n-static void\n-xmlRegexpErrCompile(xmlRegParserCtxtPtr ctxt, const char *extra)\n-{\n-    const char *regexp = NULL;\n-    int idx = 0;\n-    int res;\n-\n-    if (ctxt != NULL) {\n-        regexp = (const char *) ctxt->string;\n-    idx = ctxt->cur - ctxt->string;\n-    ctxt->error = XML_REGEXP_COMPILE_ERROR;\n-    }\n-\n-    res = __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,\n-                          XML_REGEXP_COMPILE_ERROR, XML_ERR_FATAL,\n-                          NULL, 0, extra, regexp, NULL, idx, 0,\n-                          \"failed to compile: %s\\n\", extra);\n-    if (res < 0)\n-        xmlRegexpErrMemory(ctxt);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Allocation\/Deallocation                *\n- *                                    *\n- ************************************************************************\/\n-\n-static int xmlFAComputesDeterminism(xmlRegParserCtxtPtr ctxt);\n-\n-\/**\n- * xmlRegCalloc2:\n- * @dim1:  size of first dimension\n- * @dim2:  size of second dimension\n- * @elemSize:  size of element\n- *\n- * Allocate a two-dimensional array and set all elements to zero.\n- *\n- * Returns the new array or NULL in case of error.\n- *\/\n-static void*\n-xmlRegCalloc2(size_t dim1, size_t dim2, size_t elemSize) {\n-    size_t totalSize;\n-    void *ret;\n-\n-    \/* Check for overflow *\/\n-    if ((dim2 == 0) || (elemSize == 0) ||\n-        (dim1 > SIZE_MAX \/ dim2 \/ elemSize))\n-        return (NULL);\n-    totalSize = dim1 * dim2 * elemSize;\n-    ret = xmlMalloc(totalSize);\n-    if (ret != NULL)\n-        memset(ret, 0, totalSize);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlRegEpxFromParse:\n- * @ctxt:  the parser context used to build it\n- *\n- * Allocate a new regexp and fill it with the result from the parser\n- *\n- * Returns the new regexp or NULL in case of error\n- *\/\n-static xmlRegexpPtr\n-xmlRegEpxFromParse(xmlRegParserCtxtPtr ctxt) {\n-    xmlRegexpPtr ret;\n-\n-    ret = (xmlRegexpPtr) xmlMalloc(sizeof(xmlRegexp));\n-    if (ret == NULL) {\n-    xmlRegexpErrMemory(ctxt);\n-    return(NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlRegexp));\n-    ret->string = ctxt->string;\n-    ret->nbStates = ctxt->nbStates;\n-    ret->states = ctxt->states;\n-    ret->nbAtoms = ctxt->nbAtoms;\n-    ret->atoms = ctxt->atoms;\n-    ret->nbCounters = ctxt->nbCounters;\n-    ret->counters = ctxt->counters;\n-    ret->determinist = ctxt->determinist;\n-    ret->flags = ctxt->flags;\n-    if (ret->determinist == -1) {\n-        if (xmlRegexpIsDeterminist(ret) < 0) {\n-            xmlRegexpErrMemory(ctxt);\n-            xmlFree(ret);\n-            return(NULL);\n-        }\n-    }\n-\n-    if ((ret->determinist != 0) &&\n-    (ret->nbCounters == 0) &&\n-    (ctxt->negs == 0) &&\n-    (ret->atoms != NULL) &&\n-    (ret->atoms[0] != NULL) &&\n-    (ret->atoms[0]->type == XML_REGEXP_STRING)) {\n-    int i, j, nbstates = 0, nbatoms = 0;\n-    int *stateRemap;\n-    int *stringRemap;\n-    int *transitions;\n-    void **transdata;\n-    xmlChar **stringMap;\n-        xmlChar *value;\n-\n-    \/*\n-     * Switch to a compact representation\n-     * 1\/ counting the effective number of states left\n-     * 2\/ counting the unique number of atoms, and check that\n-     *    they are all of the string type\n-     * 3\/ build a table state x atom for the transitions\n-     *\/\n-\n-    stateRemap = xmlMalloc(ret->nbStates * sizeof(int));\n-    if (stateRemap == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n-    for (i = 0;i < ret->nbStates;i++) {\n-        if (ret->states[i] != NULL) {\n-        stateRemap[i] = nbstates;\n-        nbstates++;\n-        } else {\n-        stateRemap[i] = -1;\n-        }\n-    }\n-    stringMap = xmlMalloc(ret->nbAtoms * sizeof(char *));\n-    if (stringMap == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        xmlFree(stateRemap);\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n-    stringRemap = xmlMalloc(ret->nbAtoms * sizeof(int));\n-    if (stringRemap == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        xmlFree(stringMap);\n-        xmlFree(stateRemap);\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n-    for (i = 0;i < ret->nbAtoms;i++) {\n-        if ((ret->atoms[i]->type == XML_REGEXP_STRING) &&\n-        (ret->atoms[i]->quant == XML_REGEXP_QUANT_ONCE)) {\n-        value = ret->atoms[i]->valuep;\n-                for (j = 0;j < nbatoms;j++) {\n-            if (xmlStrEqual(stringMap[j], value)) {\n-            stringRemap[i] = j;\n-            break;\n-            }\n-        }\n-        if (j >= nbatoms) {\n-            stringRemap[i] = nbatoms;\n-            stringMap[nbatoms] = xmlStrdup(value);\n-            if (stringMap[nbatoms] == NULL) {\n-            for (i = 0;i < nbatoms;i++)\n-                xmlFree(stringMap[i]);\n-            xmlFree(stringRemap);\n-            xmlFree(stringMap);\n-            xmlFree(stateRemap);\n-            xmlFree(ret);\n-            return(NULL);\n-            }\n-            nbatoms++;\n-        }\n-        } else {\n-        xmlFree(stateRemap);\n-        xmlFree(stringRemap);\n-        for (i = 0;i < nbatoms;i++)\n-            xmlFree(stringMap[i]);\n-        xmlFree(stringMap);\n-        xmlFree(ret);\n-        return(NULL);\n-        }\n-    }\n-    transitions = (int *) xmlRegCalloc2(nbstates + 1, nbatoms + 1,\n-                                            sizeof(int));\n-    if (transitions == NULL) {\n-        xmlFree(stateRemap);\n-        xmlFree(stringRemap);\n-            for (i = 0;i < nbatoms;i++)\n-        xmlFree(stringMap[i]);\n-        xmlFree(stringMap);\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n-\n-    \/*\n-     * Allocate the transition table. The first entry for each\n-     * state corresponds to the state type.\n-     *\/\n-    transdata = NULL;\n-\n-    for (i = 0;i < ret->nbStates;i++) {\n-        int stateno, atomno, targetno, prev;\n-        xmlRegStatePtr state;\n-        xmlRegTransPtr trans;\n-\n-        stateno = stateRemap[i];\n-        if (stateno == -1)\n-        continue;\n-        state = ret->states[i];\n-\n-        transitions[stateno * (nbatoms + 1)] = state->type;\n-\n-        for (j = 0;j < state->nbTrans;j++) {\n-        trans = &(state->trans[j]);\n-        if ((trans->to < 0) || (trans->atom == NULL))\n-            continue;\n-                atomno = stringRemap[trans->atom->no];\n-        if ((trans->atom->data != NULL) && (transdata == NULL)) {\n-            transdata = (void **) xmlRegCalloc2(nbstates, nbatoms,\n-                                            sizeof(void *));\n-            if (transdata == NULL) {\n-            xmlRegexpErrMemory(ctxt);\n-            break;\n-            }\n-        }\n-        targetno = stateRemap[trans->to];\n-        \/*\n-         * if the same atom can generate transitions to 2 different\n-         * states then it means the automata is not deterministic and\n-         * the compact form can't be used !\n-         *\/\n-        prev = transitions[stateno * (nbatoms + 1) + atomno + 1];\n-        if (prev != 0) {\n-            if (prev != targetno + 1) {\n-            ret->determinist = 0;\n-            if (transdata != NULL)\n-                xmlFree(transdata);\n-            xmlFree(transitions);\n-            xmlFree(stateRemap);\n-            xmlFree(stringRemap);\n-            for (i = 0;i < nbatoms;i++)\n-                xmlFree(stringMap[i]);\n-            xmlFree(stringMap);\n-            goto not_determ;\n-            }\n-        } else {\n-#if 0\n-            printf(\"State %d trans %d: atom %d to %d : %d to %d\\n\",\n-               i, j, trans->atom->no, trans->to, atomno, targetno);\n-#endif\n-            transitions[stateno * (nbatoms + 1) + atomno + 1] =\n-            targetno + 1; \/* to avoid 0 *\/\n-            if (transdata != NULL)\n-            transdata[stateno * nbatoms + atomno] =\n-                trans->atom->data;\n-        }\n-        }\n-    }\n-    ret->determinist = 1;\n-    \/*\n-     * Cleanup of the old data\n-     *\/\n-    if (ret->states != NULL) {\n-        for (i = 0;i < ret->nbStates;i++)\n-        xmlRegFreeState(ret->states[i]);\n-        xmlFree(ret->states);\n-    }\n-    ret->states = NULL;\n-    ret->nbStates = 0;\n-    if (ret->atoms != NULL) {\n-        for (i = 0;i < ret->nbAtoms;i++)\n-        xmlRegFreeAtom(ret->atoms[i]);\n-        xmlFree(ret->atoms);\n-    }\n-    ret->atoms = NULL;\n-    ret->nbAtoms = 0;\n-\n-    ret->compact = transitions;\n-    ret->transdata = transdata;\n-    ret->stringMap = stringMap;\n-    ret->nbstrings = nbatoms;\n-    ret->nbstates = nbstates;\n-    xmlFree(stateRemap);\n-    xmlFree(stringRemap);\n-    }\n-not_determ:\n-    ctxt->string = NULL;\n-    ctxt->nbStates = 0;\n-    ctxt->states = NULL;\n-    ctxt->nbAtoms = 0;\n-    ctxt->atoms = NULL;\n-    ctxt->nbCounters = 0;\n-    ctxt->counters = NULL;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlRegNewParserCtxt:\n- * @string:  the string to parse\n- *\n- * Allocate a new regexp parser context\n- *\n- * Returns the new context or NULL in case of error\n- *\/\n-static xmlRegParserCtxtPtr\n-xmlRegNewParserCtxt(const xmlChar *string) {\n-    xmlRegParserCtxtPtr ret;\n-\n-    ret = (xmlRegParserCtxtPtr) xmlMalloc(sizeof(xmlRegParserCtxt));\n-    if (ret == NULL)\n-    return(NULL);\n-    memset(ret, 0, sizeof(xmlRegParserCtxt));\n-    if (string != NULL) {\n-    ret->string = xmlStrdup(string);\n-        if (ret->string == NULL) {\n-            xmlFree(ret);\n-            return(NULL);\n-        }\n-    }\n-    ret->cur = ret->string;\n-    ret->neg = 0;\n-    ret->negs = 0;\n-    ret->error = 0;\n-    ret->determinist = -1;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlRegNewRange:\n- * @ctxt:  the regexp parser context\n- * @neg:  is that negative\n- * @type:  the type of range\n- * @start:  the start codepoint\n- * @end:  the end codepoint\n- *\n- * Allocate a new regexp range\n- *\n- * Returns the new range or NULL in case of error\n- *\/\n-static xmlRegRangePtr\n-xmlRegNewRange(xmlRegParserCtxtPtr ctxt,\n-           int neg, xmlRegAtomType type, int start, int end) {\n-    xmlRegRangePtr ret;\n-\n-    ret = (xmlRegRangePtr) xmlMalloc(sizeof(xmlRegRange));\n-    if (ret == NULL) {\n-    xmlRegexpErrMemory(ctxt);\n-    return(NULL);\n-    }\n-    ret->neg = neg;\n-    ret->type = type;\n-    ret->start = start;\n-    ret->end = end;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlRegFreeRange:\n- * @range:  the regexp range\n- *\n- * Free a regexp range\n- *\/\n-static void\n-xmlRegFreeRange(xmlRegRangePtr range) {\n-    if (range == NULL)\n-    return;\n-\n-    if (range->blockName != NULL)\n-    xmlFree(range->blockName);\n-    xmlFree(range);\n-}\n-\n-\/**\n- * xmlRegCopyRange:\n- * @range:  the regexp range\n- *\n- * Copy a regexp range\n- *\n- * Returns the new copy or NULL in case of error.\n- *\/\n-static xmlRegRangePtr\n-xmlRegCopyRange(xmlRegParserCtxtPtr ctxt, xmlRegRangePtr range) {\n-    xmlRegRangePtr ret;\n-\n-    if (range == NULL)\n-    return(NULL);\n-\n-    ret = xmlRegNewRange(ctxt, range->neg, range->type, range->start,\n-                         range->end);\n-    if (ret == NULL)\n-        return(NULL);\n-    if (range->blockName != NULL) {\n-    ret->blockName = xmlStrdup(range->blockName);\n-    if (ret->blockName == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        xmlRegFreeRange(ret);\n-        return(NULL);\n-    }\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlRegNewAtom:\n- * @ctxt:  the regexp parser context\n- * @type:  the type of atom\n- *\n- * Allocate a new atom\n- *\n- * Returns the new atom or NULL in case of error\n- *\/\n-static xmlRegAtomPtr\n-xmlRegNewAtom(xmlRegParserCtxtPtr ctxt, xmlRegAtomType type) {\n-    xmlRegAtomPtr ret;\n-\n-    ret = (xmlRegAtomPtr) xmlMalloc(sizeof(xmlRegAtom));\n-    if (ret == NULL) {\n-    xmlRegexpErrMemory(ctxt);\n-    return(NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlRegAtom));\n-    ret->type = type;\n-    ret->quant = XML_REGEXP_QUANT_ONCE;\n-    ret->min = 0;\n-    ret->max = 0;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlRegFreeAtom:\n- * @atom:  the regexp atom\n- *\n- * Free a regexp atom\n- *\/\n-static void\n-xmlRegFreeAtom(xmlRegAtomPtr atom) {\n-    int i;\n-\n-    if (atom == NULL)\n-    return;\n-\n-    for (i = 0;i < atom->nbRanges;i++)\n-    xmlRegFreeRange(atom->ranges[i]);\n-    if (atom->ranges != NULL)\n-    xmlFree(atom->ranges);\n-    if ((atom->type == XML_REGEXP_STRING) && (atom->valuep != NULL))\n-    xmlFree(atom->valuep);\n-    if ((atom->type == XML_REGEXP_STRING) && (atom->valuep2 != NULL))\n-    xmlFree(atom->valuep2);\n-    if ((atom->type == XML_REGEXP_BLOCK_NAME) && (atom->valuep != NULL))\n-    xmlFree(atom->valuep);\n-    xmlFree(atom);\n-}\n-\n-\/**\n- * xmlRegCopyAtom:\n- * @ctxt:  the regexp parser context\n- * @atom:  the original atom\n- *\n- * Allocate a new regexp range\n- *\n- * Returns the new atom or NULL in case of error\n- *\/\n-static xmlRegAtomPtr\n-xmlRegCopyAtom(xmlRegParserCtxtPtr ctxt, xmlRegAtomPtr atom) {\n-    xmlRegAtomPtr ret;\n-\n-    ret = (xmlRegAtomPtr) xmlMalloc(sizeof(xmlRegAtom));\n-    if (ret == NULL) {\n-    xmlRegexpErrMemory(ctxt);\n-    return(NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlRegAtom));\n-    ret->type = atom->type;\n-    ret->quant = atom->quant;\n-    ret->min = atom->min;\n-    ret->max = atom->max;\n-    if (atom->nbRanges > 0) {\n-        int i;\n-\n-        ret->ranges = (xmlRegRangePtr *) xmlMalloc(sizeof(xmlRegRangePtr) *\n-                                               atom->nbRanges);\n-    if (ret->ranges == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        goto error;\n-    }\n-    for (i = 0;i < atom->nbRanges;i++) {\n-        ret->ranges[i] = xmlRegCopyRange(ctxt, atom->ranges[i]);\n-        if (ret->ranges[i] == NULL)\n-            goto error;\n-        ret->nbRanges = i + 1;\n-    }\n-    }\n-    return(ret);\n-\n-error:\n-    xmlRegFreeAtom(ret);\n-    return(NULL);\n-}\n-\n-static xmlRegStatePtr\n-xmlRegNewState(xmlRegParserCtxtPtr ctxt) {\n-    xmlRegStatePtr ret;\n-\n-    ret = (xmlRegStatePtr) xmlMalloc(sizeof(xmlRegState));\n-    if (ret == NULL) {\n-    xmlRegexpErrMemory(ctxt);\n-    return(NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlRegState));\n-    ret->type = XML_REGEXP_TRANS_STATE;\n-    ret->mark = XML_REGEXP_MARK_NORMAL;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlRegFreeState:\n- * @state:  the regexp state\n- *\n- * Free a regexp state\n- *\/\n-static void\n-xmlRegFreeState(xmlRegStatePtr state) {\n-    if (state == NULL)\n-    return;\n-\n-    if (state->trans != NULL)\n-    xmlFree(state->trans);\n-    if (state->transTo != NULL)\n-    xmlFree(state->transTo);\n-    xmlFree(state);\n-}\n-\n-\/**\n- * xmlRegFreeParserCtxt:\n- * @ctxt:  the regexp parser context\n- *\n- * Free a regexp parser context\n- *\/\n-static void\n-xmlRegFreeParserCtxt(xmlRegParserCtxtPtr ctxt) {\n-    int i;\n-    if (ctxt == NULL)\n-    return;\n-\n-    if (ctxt->string != NULL)\n-    xmlFree(ctxt->string);\n-    if (ctxt->states != NULL) {\n-    for (i = 0;i < ctxt->nbStates;i++)\n-        xmlRegFreeState(ctxt->states[i]);\n-    xmlFree(ctxt->states);\n-    }\n-    if (ctxt->atoms != NULL) {\n-    for (i = 0;i < ctxt->nbAtoms;i++)\n-        xmlRegFreeAtom(ctxt->atoms[i]);\n-    xmlFree(ctxt->atoms);\n-    }\n-    if (ctxt->counters != NULL)\n-    xmlFree(ctxt->counters);\n-    xmlFree(ctxt);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Display of Data structures            *\n- *                                    *\n- ************************************************************************\/\n-\n-static void\n-xmlRegPrintAtomType(FILE *output, xmlRegAtomType type) {\n-    switch (type) {\n-        case XML_REGEXP_EPSILON:\n-        fprintf(output, \"epsilon \"); break;\n-        case XML_REGEXP_CHARVAL:\n-        fprintf(output, \"charval \"); break;\n-        case XML_REGEXP_RANGES:\n-        fprintf(output, \"ranges \"); break;\n-        case XML_REGEXP_SUBREG:\n-        fprintf(output, \"subexpr \"); break;\n-        case XML_REGEXP_STRING:\n-        fprintf(output, \"string \"); break;\n-        case XML_REGEXP_ANYCHAR:\n-        fprintf(output, \"anychar \"); break;\n-        case XML_REGEXP_ANYSPACE:\n-        fprintf(output, \"anyspace \"); break;\n-        case XML_REGEXP_NOTSPACE:\n-        fprintf(output, \"notspace \"); break;\n-        case XML_REGEXP_INITNAME:\n-        fprintf(output, \"initname \"); break;\n-        case XML_REGEXP_NOTINITNAME:\n-        fprintf(output, \"notinitname \"); break;\n-        case XML_REGEXP_NAMECHAR:\n-        fprintf(output, \"namechar \"); break;\n-        case XML_REGEXP_NOTNAMECHAR:\n-        fprintf(output, \"notnamechar \"); break;\n-        case XML_REGEXP_DECIMAL:\n-        fprintf(output, \"decimal \"); break;\n-        case XML_REGEXP_NOTDECIMAL:\n-        fprintf(output, \"notdecimal \"); break;\n-        case XML_REGEXP_REALCHAR:\n-        fprintf(output, \"realchar \"); break;\n-        case XML_REGEXP_NOTREALCHAR:\n-        fprintf(output, \"notrealchar \"); break;\n-        case XML_REGEXP_LETTER:\n-            fprintf(output, \"LETTER \"); break;\n-        case XML_REGEXP_LETTER_UPPERCASE:\n-            fprintf(output, \"LETTER_UPPERCASE \"); break;\n-        case XML_REGEXP_LETTER_LOWERCASE:\n-            fprintf(output, \"LETTER_LOWERCASE \"); break;\n-        case XML_REGEXP_LETTER_TITLECASE:\n-            fprintf(output, \"LETTER_TITLECASE \"); break;\n-        case XML_REGEXP_LETTER_MODIFIER:\n-            fprintf(output, \"LETTER_MODIFIER \"); break;\n-        case XML_REGEXP_LETTER_OTHERS:\n-            fprintf(output, \"LETTER_OTHERS \"); break;\n-        case XML_REGEXP_MARK:\n-            fprintf(output, \"MARK \"); break;\n-        case XML_REGEXP_MARK_NONSPACING:\n-            fprintf(output, \"MARK_NONSPACING \"); break;\n-        case XML_REGEXP_MARK_SPACECOMBINING:\n-            fprintf(output, \"MARK_SPACECOMBINING \"); break;\n-        case XML_REGEXP_MARK_ENCLOSING:\n-            fprintf(output, \"MARK_ENCLOSING \"); break;\n-        case XML_REGEXP_NUMBER:\n-            fprintf(output, \"NUMBER \"); break;\n-        case XML_REGEXP_NUMBER_DECIMAL:\n-            fprintf(output, \"NUMBER_DECIMAL \"); break;\n-        case XML_REGEXP_NUMBER_LETTER:\n-            fprintf(output, \"NUMBER_LETTER \"); break;\n-        case XML_REGEXP_NUMBER_OTHERS:\n-            fprintf(output, \"NUMBER_OTHERS \"); break;\n-        case XML_REGEXP_PUNCT:\n-            fprintf(output, \"PUNCT \"); break;\n-        case XML_REGEXP_PUNCT_CONNECTOR:\n-            fprintf(output, \"PUNCT_CONNECTOR \"); break;\n-        case XML_REGEXP_PUNCT_DASH:\n-            fprintf(output, \"PUNCT_DASH \"); break;\n-        case XML_REGEXP_PUNCT_OPEN:\n-            fprintf(output, \"PUNCT_OPEN \"); break;\n-        case XML_REGEXP_PUNCT_CLOSE:\n-            fprintf(output, \"PUNCT_CLOSE \"); break;\n-        case XML_REGEXP_PUNCT_INITQUOTE:\n-            fprintf(output, \"PUNCT_INITQUOTE \"); break;\n-        case XML_REGEXP_PUNCT_FINQUOTE:\n-            fprintf(output, \"PUNCT_FINQUOTE \"); break;\n-        case XML_REGEXP_PUNCT_OTHERS:\n-            fprintf(output, \"PUNCT_OTHERS \"); break;\n-        case XML_REGEXP_SEPAR:\n-            fprintf(output, \"SEPAR \"); break;\n-        case XML_REGEXP_SEPAR_SPACE:\n-            fprintf(output, \"SEPAR_SPACE \"); break;\n-        case XML_REGEXP_SEPAR_LINE:\n-            fprintf(output, \"SEPAR_LINE \"); break;\n-        case XML_REGEXP_SEPAR_PARA:\n-            fprintf(output, \"SEPAR_PARA \"); break;\n-        case XML_REGEXP_SYMBOL:\n-            fprintf(output, \"SYMBOL \"); break;\n-        case XML_REGEXP_SYMBOL_MATH:\n-            fprintf(output, \"SYMBOL_MATH \"); break;\n-        case XML_REGEXP_SYMBOL_CURRENCY:\n-            fprintf(output, \"SYMBOL_CURRENCY \"); break;\n-        case XML_REGEXP_SYMBOL_MODIFIER:\n-            fprintf(output, \"SYMBOL_MODIFIER \"); break;\n-        case XML_REGEXP_SYMBOL_OTHERS:\n-            fprintf(output, \"SYMBOL_OTHERS \"); break;\n-        case XML_REGEXP_OTHER:\n-            fprintf(output, \"OTHER \"); break;\n-        case XML_REGEXP_OTHER_CONTROL:\n-            fprintf(output, \"OTHER_CONTROL \"); break;\n-        case XML_REGEXP_OTHER_FORMAT:\n-            fprintf(output, \"OTHER_FORMAT \"); break;\n-        case XML_REGEXP_OTHER_PRIVATE:\n-            fprintf(output, \"OTHER_PRIVATE \"); break;\n-        case XML_REGEXP_OTHER_NA:\n-            fprintf(output, \"OTHER_NA \"); break;\n-        case XML_REGEXP_BLOCK_NAME:\n-        fprintf(output, \"BLOCK \"); break;\n-    }\n-}\n-\n-static void\n-xmlRegPrintQuantType(FILE *output, xmlRegQuantType type) {\n-    switch (type) {\n-        case XML_REGEXP_QUANT_EPSILON:\n-        fprintf(output, \"epsilon \"); break;\n-        case XML_REGEXP_QUANT_ONCE:\n-        fprintf(output, \"once \"); break;\n-        case XML_REGEXP_QUANT_OPT:\n-        fprintf(output, \"? \"); break;\n-        case XML_REGEXP_QUANT_MULT:\n-        fprintf(output, \"* \"); break;\n-        case XML_REGEXP_QUANT_PLUS:\n-        fprintf(output, \"+ \"); break;\n-    case XML_REGEXP_QUANT_RANGE:\n-        fprintf(output, \"range \"); break;\n-    case XML_REGEXP_QUANT_ONCEONLY:\n-        fprintf(output, \"onceonly \"); break;\n-    case XML_REGEXP_QUANT_ALL:\n-        fprintf(output, \"all \"); break;\n-    }\n-}\n-static void\n-xmlRegPrintRange(FILE *output, xmlRegRangePtr range) {\n-    fprintf(output, \"  range: \");\n-    if (range->neg)\n-    fprintf(output, \"negative \");\n-    xmlRegPrintAtomType(output, range->type);\n-    fprintf(output, \"%c - %c\\n\", range->start, range->end);\n-}\n-\n-static void\n-xmlRegPrintAtom(FILE *output, xmlRegAtomPtr atom) {\n-    fprintf(output, \" atom: \");\n-    if (atom == NULL) {\n-    fprintf(output, \"NULL\\n\");\n-    return;\n-    }\n-    if (atom->neg)\n-        fprintf(output, \"not \");\n-    xmlRegPrintAtomType(output, atom->type);\n-    xmlRegPrintQuantType(output, atom->quant);\n-    if (atom->quant == XML_REGEXP_QUANT_RANGE)\n-    fprintf(output, \"%d-%d \", atom->min, atom->max);\n-    if (atom->type == XML_REGEXP_STRING)\n-    fprintf(output, \"'%s' \", (char *) atom->valuep);\n-    if (atom->type == XML_REGEXP_CHARVAL)\n-    fprintf(output, \"char %c\\n\", atom->codepoint);\n-    else if (atom->type == XML_REGEXP_RANGES) {\n-    int i;\n-    fprintf(output, \"%d entries\\n\", atom->nbRanges);\n-    for (i = 0; i < atom->nbRanges;i++)\n-        xmlRegPrintRange(output, atom->ranges[i]);\n-    } else if (atom->type == XML_REGEXP_SUBREG) {\n-    fprintf(output, \"start %d end %d\\n\", atom->start->no, atom->stop->no);\n-    } else {\n-    fprintf(output, \"\\n\");\n-    }\n-}\n-\n-static void\n-xmlRegPrintTrans(FILE *output, xmlRegTransPtr trans) {\n-    fprintf(output, \"  trans: \");\n-    if (trans == NULL) {\n-    fprintf(output, \"NULL\\n\");\n-    return;\n-    }\n-    if (trans->to < 0) {\n-    fprintf(output, \"removed\\n\");\n-    return;\n-    }\n-    if (trans->nd != 0) {\n-    if (trans->nd == 2)\n-        fprintf(output, \"last not determinist, \");\n-    else\n-        fprintf(output, \"not determinist, \");\n-    }\n-    if (trans->counter >= 0) {\n-    fprintf(output, \"counted %d, \", trans->counter);\n-    }\n-    if (trans->count == REGEXP_ALL_COUNTER) {\n-    fprintf(output, \"all transition, \");\n-    } else if (trans->count >= 0) {\n-    fprintf(output, \"count based %d, \", trans->count);\n-    }\n-    if (trans->atom == NULL) {\n-    fprintf(output, \"epsilon to %d\\n\", trans->to);\n-    return;\n-    }\n-    if (trans->atom->type == XML_REGEXP_CHARVAL)\n-    fprintf(output, \"char %c \", trans->atom->codepoint);\n-    fprintf(output, \"atom %d, to %d\\n\", trans->atom->no, trans->to);\n-}\n-\n-static void\n-xmlRegPrintState(FILE *output, xmlRegStatePtr state) {\n-    int i;\n-\n-    fprintf(output, \" state: \");\n-    if (state == NULL) {\n-    fprintf(output, \"NULL\\n\");\n-    return;\n-    }\n-    if (state->type == XML_REGEXP_START_STATE)\n-    fprintf(output, \"START \");\n-    if (state->type == XML_REGEXP_FINAL_STATE)\n-    fprintf(output, \"FINAL \");\n-\n-    fprintf(output, \"%d, %d transitions:\\n\", state->no, state->nbTrans);\n-    for (i = 0;i < state->nbTrans; i++) {\n-    xmlRegPrintTrans(output, &(state->trans[i]));\n-    }\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *         Finite Automata structures manipulations        *\n- *                                    *\n- ************************************************************************\/\n-\n-static xmlRegRangePtr\n-xmlRegAtomAddRange(xmlRegParserCtxtPtr ctxt, xmlRegAtomPtr atom,\n-               int neg, xmlRegAtomType type, int start, int end,\n-           xmlChar *blockName) {\n-    xmlRegRangePtr range;\n-\n-    if (atom == NULL) {\n-    ERROR(\"add range: atom is NULL\");\n-    return(NULL);\n-    }\n-    if (atom->type != XML_REGEXP_RANGES) {\n-    ERROR(\"add range: atom is not ranges\");\n-    return(NULL);\n-    }\n-    if (atom->maxRanges == 0) {\n-    atom->maxRanges = 4;\n-    atom->ranges = (xmlRegRangePtr *) xmlMalloc(atom->maxRanges *\n-                                     sizeof(xmlRegRangePtr));\n-    if (atom->ranges == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        atom->maxRanges = 0;\n-        return(NULL);\n-    }\n-    } else if (atom->nbRanges >= atom->maxRanges) {\n-    xmlRegRangePtr *tmp;\n-    atom->maxRanges *= 2;\n-    tmp = (xmlRegRangePtr *) xmlRealloc(atom->ranges, atom->maxRanges *\n-                                     sizeof(xmlRegRangePtr));\n-    if (tmp == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        atom->maxRanges \/= 2;\n-        return(NULL);\n-    }\n-    atom->ranges = tmp;\n-    }\n-    range = xmlRegNewRange(ctxt, neg, type, start, end);\n-    if (range == NULL)\n-    return(NULL);\n-    range->blockName = blockName;\n-    atom->ranges[atom->nbRanges++] = range;\n-\n-    return(range);\n-}\n-\n-static int\n-xmlRegGetCounter(xmlRegParserCtxtPtr ctxt) {\n-    if (ctxt->maxCounters == 0) {\n-    ctxt->maxCounters = 4;\n-    ctxt->counters = (xmlRegCounter *) xmlMalloc(ctxt->maxCounters *\n-                                     sizeof(xmlRegCounter));\n-    if (ctxt->counters == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        ctxt->maxCounters = 0;\n-        return(-1);\n-    }\n-    } else if (ctxt->nbCounters >= ctxt->maxCounters) {\n-    xmlRegCounter *tmp;\n-    ctxt->maxCounters *= 2;\n-    tmp = (xmlRegCounter *) xmlRealloc(ctxt->counters, ctxt->maxCounters *\n-                                   sizeof(xmlRegCounter));\n-    if (tmp == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        ctxt->maxCounters \/= 2;\n-        return(-1);\n-    }\n-    ctxt->counters = tmp;\n-    }\n-    ctxt->counters[ctxt->nbCounters].min = -1;\n-    ctxt->counters[ctxt->nbCounters].max = -1;\n-    return(ctxt->nbCounters++);\n-}\n-\n-static int\n-xmlRegAtomPush(xmlRegParserCtxtPtr ctxt, xmlRegAtomPtr atom) {\n-    if (atom == NULL) {\n-    ERROR(\"atom push: atom is NULL\");\n-    return(-1);\n-    }\n-    if (ctxt->nbAtoms >= ctxt->maxAtoms) {\n-        size_t newSize = ctxt->maxAtoms ? ctxt->maxAtoms * 2 : 4;\n-    xmlRegAtomPtr *tmp;\n-\n-    tmp = xmlRealloc(ctxt->atoms, newSize * sizeof(xmlRegAtomPtr));\n-    if (tmp == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        return(-1);\n-    }\n-    ctxt->atoms = tmp;\n-        ctxt->maxAtoms = newSize;\n-    }\n-    atom->no = ctxt->nbAtoms;\n-    ctxt->atoms[ctxt->nbAtoms++] = atom;\n-    return(0);\n-}\n-\n-static void\n-xmlRegStateAddTransTo(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr target,\n-                      int from) {\n-    if (target->maxTransTo == 0) {\n-    target->maxTransTo = 8;\n-    target->transTo = (int *) xmlMalloc(target->maxTransTo *\n-                                     sizeof(int));\n-    if (target->transTo == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        target->maxTransTo = 0;\n-        return;\n-    }\n-    } else if (target->nbTransTo >= target->maxTransTo) {\n-    int *tmp;\n-    target->maxTransTo *= 2;\n-    tmp = (int *) xmlRealloc(target->transTo, target->maxTransTo *\n-                                     sizeof(int));\n-    if (tmp == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        target->maxTransTo \/= 2;\n-        return;\n-    }\n-    target->transTo = tmp;\n-    }\n-    target->transTo[target->nbTransTo] = from;\n-    target->nbTransTo++;\n-}\n-\n-static void\n-xmlRegStateAddTrans(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr state,\n-                xmlRegAtomPtr atom, xmlRegStatePtr target,\n-            int counter, int count) {\n-\n-    int nrtrans;\n-\n-    if (state == NULL) {\n-    ERROR(\"add state: state is NULL\");\n-    return;\n-    }\n-    if (target == NULL) {\n-    ERROR(\"add state: target is NULL\");\n-    return;\n-    }\n-    \/*\n-     * Other routines follow the philosophy 'When in doubt, add a transition'\n-     * so we check here whether such a transition is already present and, if\n-     * so, silently ignore this request.\n-     *\/\n-\n-    for (nrtrans = state->nbTrans - 1; nrtrans >= 0; nrtrans--) {\n-    xmlRegTransPtr trans = &(state->trans[nrtrans]);\n-    if ((trans->atom == atom) &&\n-        (trans->to == target->no) &&\n-        (trans->counter == counter) &&\n-        (trans->count == count)) {\n-        return;\n-    }\n-    }\n-\n-    if (state->maxTrans == 0) {\n-    state->maxTrans = 8;\n-    state->trans = (xmlRegTrans *) xmlMalloc(state->maxTrans *\n-                                     sizeof(xmlRegTrans));\n-    if (state->trans == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        state->maxTrans = 0;\n-        return;\n-    }\n-    } else if (state->nbTrans >= state->maxTrans) {\n-    xmlRegTrans *tmp;\n-    state->maxTrans *= 2;\n-    tmp = (xmlRegTrans *) xmlRealloc(state->trans, state->maxTrans *\n-                                     sizeof(xmlRegTrans));\n-    if (tmp == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        state->maxTrans \/= 2;\n-        return;\n-    }\n-    state->trans = tmp;\n-    }\n-\n-    state->trans[state->nbTrans].atom = atom;\n-    state->trans[state->nbTrans].to = target->no;\n-    state->trans[state->nbTrans].counter = counter;\n-    state->trans[state->nbTrans].count = count;\n-    state->trans[state->nbTrans].nd = 0;\n-    state->nbTrans++;\n-    xmlRegStateAddTransTo(ctxt, target, state->no);\n-}\n-\n-static xmlRegStatePtr\n-xmlRegStatePush(xmlRegParserCtxtPtr ctxt) {\n-    xmlRegStatePtr state;\n-\n-    if (ctxt->nbStates >= ctxt->maxStates) {\n-        size_t newSize = ctxt->maxStates ? ctxt->maxStates * 2 : 4;\n-    xmlRegStatePtr *tmp;\n-\n-    tmp = xmlRealloc(ctxt->states, newSize * sizeof(tmp[0]));\n-    if (tmp == NULL) {\n-        xmlRegexpErrMemory(ctxt);\n-        return(NULL);\n-    }\n-    ctxt->states = tmp;\n-    ctxt->maxStates = newSize;\n-    }\n-\n-    state = xmlRegNewState(ctxt);\n-    if (state == NULL)\n-        return(NULL);\n-\n-    state->no = ctxt->nbStates;\n-    ctxt->states[ctxt->nbStates++] = state;\n-\n-    return(state);\n-}\n-\n-\/**\n- * xmlFAGenerateAllTransition:\n- * @ctxt:  a regexp parser context\n- * @from:  the from state\n- * @to:  the target state or NULL for building a new one\n- * @lax:\n- *\n- *\/\n-static int\n-xmlFAGenerateAllTransition(xmlRegParserCtxtPtr ctxt,\n-               xmlRegStatePtr from, xmlRegStatePtr to,\n-               int lax) {\n-    if (to == NULL) {\n-    to = xmlRegStatePush(ctxt);\n-        if (to == NULL)\n-            return(-1);\n-    ctxt->state = to;\n-    }\n-    if (lax)\n-    xmlRegStateAddTrans(ctxt, from, NULL, to, -1, REGEXP_ALL_LAX_COUNTER);\n-    else\n-    xmlRegStateAddTrans(ctxt, from, NULL, to, -1, REGEXP_ALL_COUNTER);\n-    return(0);\n-}\n-\n-\/**\n- * xmlFAGenerateEpsilonTransition:\n- * @ctxt:  a regexp parser context\n- * @from:  the from state\n- * @to:  the target state or NULL for building a new one\n- *\n- *\/\n-static int\n-xmlFAGenerateEpsilonTransition(xmlRegParserCtxtPtr ctxt,\n-                   xmlRegStatePtr from, xmlRegStatePtr to) {\n-    if (to == NULL) {\n-    to = xmlRegStatePush(ctxt);\n-        if (to == NULL)\n-            return(-1);\n-    ctxt->state = to;\n-    }\n-    xmlRegStateAddTrans(ctxt, from, NULL, to, -1, -1);\n-    return(0);\n-}\n-\n-\/**\n- * xmlFAGenerateCountedEpsilonTransition:\n- * @ctxt:  a regexp parser context\n- * @from:  the from state\n- * @to:  the target state or NULL for building a new one\n- * counter:  the counter for that transition\n- *\n- *\/\n-static int\n-xmlFAGenerateCountedEpsilonTransition(xmlRegParserCtxtPtr ctxt,\n-        xmlRegStatePtr from, xmlRegStatePtr to, int counter) {\n-    if (to == NULL) {\n-    to = xmlRegStatePush(ctxt);\n-        if (to == NULL)\n-            return(-1);\n-    ctxt->state = to;\n-    }\n-    xmlRegStateAddTrans(ctxt, from, NULL, to, counter, -1);\n-    return(0);\n-}\n-\n-\/**\n- * xmlFAGenerateCountedTransition:\n- * @ctxt:  a regexp parser context\n- * @from:  the from state\n- * @to:  the target state or NULL for building a new one\n- * counter:  the counter for that transition\n- *\n- *\/\n-static int\n-xmlFAGenerateCountedTransition(xmlRegParserCtxtPtr ctxt,\n-        xmlRegStatePtr from, xmlRegStatePtr to, int counter) {\n-    if (to == NULL) {\n-    to = xmlRegStatePush(ctxt);\n-        if (to == NULL)\n-            return(-1);\n-    ctxt->state = to;\n-    }\n-    xmlRegStateAddTrans(ctxt, from, NULL, to, -1, counter);\n-    return(0);\n-}\n-\n-\/**\n- * xmlFAGenerateTransitions:\n- * @ctxt:  a regexp parser context\n- * @from:  the from state\n- * @to:  the target state or NULL for building a new one\n- * @atom:  the atom generating the transition\n- *\n- * Returns 0 if success and -1 in case of error.\n- *\/\n-static int\n-xmlFAGenerateTransitions(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr from,\n-                     xmlRegStatePtr to, xmlRegAtomPtr atom) {\n-    xmlRegStatePtr end;\n-    int nullable = 0;\n-\n-    if (atom == NULL) {\n-    ERROR(\"generate transition: atom == NULL\");\n-    return(-1);\n-    }\n-    if (atom->type == XML_REGEXP_SUBREG) {\n-    \/*\n-     * this is a subexpression handling one should not need to\n-     * create a new node except for XML_REGEXP_QUANT_RANGE.\n-     *\/\n-    if ((to != NULL) && (atom->stop != to) &&\n-        (atom->quant != XML_REGEXP_QUANT_RANGE)) {\n-        \/*\n-         * Generate an epsilon transition to link to the target\n-         *\/\n-        xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);\n-#ifdef DV\n-    } else if ((to == NULL) && (atom->quant != XML_REGEXP_QUANT_RANGE) &&\n-           (atom->quant != XML_REGEXP_QUANT_ONCE)) {\n-        to = xmlRegStatePush(ctxt, to);\n-            if (to == NULL)\n-                return(-1);\n-        ctxt->state = to;\n-        xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);\n-#endif\n-    }\n-    switch (atom->quant) {\n-        case XML_REGEXP_QUANT_OPT:\n-        atom->quant = XML_REGEXP_QUANT_ONCE;\n-        \/*\n-         * transition done to the state after end of atom.\n-         *      1. set transition from atom start to new state\n-         *      2. set transition from atom end to this state.\n-         *\/\n-                if (to == NULL) {\n-                    xmlFAGenerateEpsilonTransition(ctxt, atom->start, 0);\n-                    xmlFAGenerateEpsilonTransition(ctxt, atom->stop,\n-                                                   ctxt->state);\n-                } else {\n-                    xmlFAGenerateEpsilonTransition(ctxt, atom->start, to);\n-                }\n-        break;\n-        case XML_REGEXP_QUANT_MULT:\n-        atom->quant = XML_REGEXP_QUANT_ONCE;\n-        xmlFAGenerateEpsilonTransition(ctxt, atom->start, atom->stop);\n-        xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);\n-        break;\n-        case XML_REGEXP_QUANT_PLUS:\n-        atom->quant = XML_REGEXP_QUANT_ONCE;\n-        xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);\n-        break;\n-        case XML_REGEXP_QUANT_RANGE: {\n-        int counter;\n-        xmlRegStatePtr inter, newstate;\n-\n-        \/*\n-         * create the final state now if needed\n-         *\/\n-        if (to != NULL) {\n-            newstate = to;\n-        } else {\n-            newstate = xmlRegStatePush(ctxt);\n-                    if (newstate == NULL)\n-                        return(-1);\n-        }\n-\n-        \/*\n-         * The principle here is to use counted transition\n-         * to avoid explosion in the number of states in the\n-         * graph. This is clearly more complex but should not\n-         * be exploitable at runtime.\n-         *\/\n-        if ((atom->min == 0) && (atom->start0 == NULL)) {\n-            xmlRegAtomPtr copy;\n-            \/*\n-             * duplicate a transition based on atom to count next\n-             * occurrences after 1. We cannot loop to atom->start\n-             * directly because we need an epsilon transition to\n-             * newstate.\n-             *\/\n-             \/* ???? For some reason it seems we never reach that\n-                case, I suppose this got optimized out before when\n-            building the automata *\/\n-            copy = xmlRegCopyAtom(ctxt, atom);\n-            if (copy == NULL)\n-                return(-1);\n-            copy->quant = XML_REGEXP_QUANT_ONCE;\n-            copy->min = 0;\n-            copy->max = 0;\n-\n-            if (xmlFAGenerateTransitions(ctxt, atom->start, NULL, copy)\n-                < 0) {\n-                        xmlRegFreeAtom(copy);\n-            return(-1);\n-                    }\n-            inter = ctxt->state;\n-            counter = xmlRegGetCounter(ctxt);\n-                    if (counter < 0)\n-                        return(-1);\n-            ctxt->counters[counter].min = atom->min - 1;\n-            ctxt->counters[counter].max = atom->max - 1;\n-            \/* count the number of times we see it again *\/\n-            xmlFAGenerateCountedEpsilonTransition(ctxt, inter,\n-                           atom->stop, counter);\n-            \/* allow a way out based on the count *\/\n-            xmlFAGenerateCountedTransition(ctxt, inter,\n-                                       newstate, counter);\n-            \/* and also allow a direct exit for 0 *\/\n-            xmlFAGenerateEpsilonTransition(ctxt, atom->start,\n-                                           newstate);\n-        } else {\n-            \/*\n-             * either we need the atom at least once or there\n-             * is an atom->start0 allowing to easily plug the\n-             * epsilon transition.\n-             *\/\n-            counter = xmlRegGetCounter(ctxt);\n-                    if (counter < 0)\n-                        return(-1);\n-            ctxt->counters[counter].min = atom->min - 1;\n-            ctxt->counters[counter].max = atom->max - 1;\n-            \/* allow a way out based on the count *\/\n-            xmlFAGenerateCountedTransition(ctxt, atom->stop,\n-                                       newstate, counter);\n-            \/* count the number of times we see it again *\/\n-            xmlFAGenerateCountedEpsilonTransition(ctxt, atom->stop,\n-                           atom->start, counter);\n-            \/* and if needed allow a direct exit for 0 *\/\n-            if (atom->min == 0)\n-            xmlFAGenerateEpsilonTransition(ctxt, atom->start0,\n-                               newstate);\n-\n-        }\n-        atom->min = 0;\n-        atom->max = 0;\n-        atom->quant = XML_REGEXP_QUANT_ONCE;\n-        ctxt->state = newstate;\n-        }\n-        default:\n-        break;\n-    }\n-    if (xmlRegAtomPush(ctxt, atom) < 0)\n-        return(-1);\n-    return(0);\n-    }\n-    if ((atom->min == 0) && (atom->max == 0) &&\n-               (atom->quant == XML_REGEXP_QUANT_RANGE)) {\n-        \/*\n-     * we can discard the atom and generate an epsilon transition instead\n-     *\/\n-    if (to == NULL) {\n-        to = xmlRegStatePush(ctxt);\n-        if (to == NULL)\n-        return(-1);\n-    }\n-    xmlFAGenerateEpsilonTransition(ctxt, from, to);\n-    ctxt->state = to;\n-    xmlRegFreeAtom(atom);\n-    return(0);\n-    }\n-    if (to == NULL) {\n-    to = xmlRegStatePush(ctxt);\n-    if (to == NULL)\n-        return(-1);\n-    }\n-    end = to;\n-    if ((atom->quant == XML_REGEXP_QUANT_MULT) ||\n-        (atom->quant == XML_REGEXP_QUANT_PLUS)) {\n-    \/*\n-     * Do not pollute the target state by adding transitions from\n-     * it as it is likely to be the shared target of multiple branches.\n-     * So isolate with an epsilon transition.\n-     *\/\n-        xmlRegStatePtr tmp;\n-\n-    tmp = xmlRegStatePush(ctxt);\n-        if (tmp == NULL)\n-        return(-1);\n-    xmlFAGenerateEpsilonTransition(ctxt, tmp, to);\n-    to = tmp;\n-    }\n-    if ((atom->quant == XML_REGEXP_QUANT_RANGE) &&\n-        (atom->min == 0) && (atom->max > 0)) {\n-    nullable = 1;\n-    atom->min = 1;\n-        if (atom->max == 1)\n-        atom->quant = XML_REGEXP_QUANT_OPT;\n-    }\n-    xmlRegStateAddTrans(ctxt, from, atom, to, -1, -1);\n-    ctxt->state = end;\n-    switch (atom->quant) {\n-    case XML_REGEXP_QUANT_OPT:\n-        atom->quant = XML_REGEXP_QUANT_ONCE;\n-        xmlFAGenerateEpsilonTransition(ctxt, from, to);\n-        break;\n-    case XML_REGEXP_QUANT_MULT:\n-        atom->quant = XML_REGEXP_QUANT_ONCE;\n-        xmlFAGenerateEpsilonTransition(ctxt, from, to);\n-        xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);\n-        break;\n-    case XML_REGEXP_QUANT_PLUS:\n-        atom->quant = XML_REGEXP_QUANT_ONCE;\n-        xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);\n-        break;\n-    case XML_REGEXP_QUANT_RANGE:\n-        if (nullable)\n-        xmlFAGenerateEpsilonTransition(ctxt, from, to);\n-        break;\n-    default:\n-        break;\n-    }\n-    if (xmlRegAtomPush(ctxt, atom) < 0)\n-    return(-1);\n-    return(0);\n-}\n-\n-\/**\n- * xmlFAReduceEpsilonTransitions:\n- * @ctxt:  a regexp parser context\n- * @fromnr:  the from state\n- * @tonr:  the to state\n- * @counter:  should that transition be associated to a counted\n- *\n- *\/\n-static void\n-xmlFAReduceEpsilonTransitions(xmlRegParserCtxtPtr ctxt, int fromnr,\n-                          int tonr, int counter) {\n-    int transnr;\n-    xmlRegStatePtr from;\n-    xmlRegStatePtr to;\n-\n-    from = ctxt->states[fromnr];\n-    if (from == NULL)\n-    return;\n-    to = ctxt->states[tonr];\n-    if (to == NULL)\n-    return;\n-    if ((to->mark == XML_REGEXP_MARK_START) ||\n-    (to->mark == XML_REGEXP_MARK_VISITED))\n-    return;\n-\n-    to->mark = XML_REGEXP_MARK_VISITED;\n-    if (to->type == XML_REGEXP_FINAL_STATE) {\n-    from->type = XML_REGEXP_FINAL_STATE;\n-    }\n-    for (transnr = 0;transnr < to->nbTrans;transnr++) {\n-        xmlRegTransPtr t1 = &to->trans[transnr];\n-        int tcounter;\n-\n-        if (t1->to < 0)\n-        continue;\n-        if (t1->counter >= 0) {\n-            \/* assert(counter < 0); *\/\n-            tcounter = t1->counter;\n-        } else {\n-            tcounter = counter;\n-        }\n-    if (t1->atom == NULL) {\n-        \/*\n-         * Don't remove counted transitions\n-         * Don't loop either\n-         *\/\n-        if (t1->to != fromnr) {\n-        if (t1->count >= 0) {\n-            xmlRegStateAddTrans(ctxt, from, NULL, ctxt->states[t1->to],\n-                    -1, t1->count);\n-        } else {\n-                    xmlFAReduceEpsilonTransitions(ctxt, fromnr, t1->to,\n-                                                  tcounter);\n-        }\n-        }\n-    } else {\n-            xmlRegStateAddTrans(ctxt, from, t1->atom,\n-                                ctxt->states[t1->to], tcounter, -1);\n-    }\n-    }\n-}\n-\n-\/**\n- * xmlFAFinishReduceEpsilonTransitions:\n- * @ctxt:  a regexp parser context\n- * @fromnr:  the from state\n- * @tonr:  the to state\n- * @counter:  should that transition be associated to a counted\n- *\n- *\/\n-static void\n-xmlFAFinishReduceEpsilonTransitions(xmlRegParserCtxtPtr ctxt, int tonr) {\n-    int transnr;\n-    xmlRegStatePtr to;\n-\n-    to = ctxt->states[tonr];\n-    if (to == NULL)\n-    return;\n-    if ((to->mark == XML_REGEXP_MARK_START) ||\n-    (to->mark == XML_REGEXP_MARK_NORMAL))\n-    return;\n-\n-    to->mark = XML_REGEXP_MARK_NORMAL;\n-    for (transnr = 0;transnr < to->nbTrans;transnr++) {\n-    xmlRegTransPtr t1 = &to->trans[transnr];\n-    if ((t1->to >= 0) && (t1->atom == NULL))\n-            xmlFAFinishReduceEpsilonTransitions(ctxt, t1->to);\n-    }\n-}\n-\n-\/**\n- * xmlFAEliminateSimpleEpsilonTransitions:\n- * @ctxt:  a regexp parser context\n- *\n- * Eliminating general epsilon transitions can get costly in the general\n- * algorithm due to the large amount of generated new transitions and\n- * associated comparisons. However for simple epsilon transition used just\n- * to separate building blocks when generating the automata this can be\n- * reduced to state elimination:\n- *    - if there exists an epsilon from X to Y\n- *    - if there is no other transition from X\n- * then X and Y are semantically equivalent and X can be eliminated\n- * If X is the start state then make Y the start state, else replace the\n- * target of all transitions to X by transitions to Y.\n- *\n- * If X is a final state, skip it.\n- * Otherwise it would be necessary to manipulate counters for this case when\n- * eliminating state 2:\n- * State 1 has a transition with an atom to state 2.\n- * State 2 is final and has an epsilon transition to state 1.\n- *\/\n-static void\n-xmlFAEliminateSimpleEpsilonTransitions(xmlRegParserCtxtPtr ctxt) {\n-    int statenr, i, j, newto;\n-    xmlRegStatePtr state, tmp;\n-\n-    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {\n-    state = ctxt->states[statenr];\n-    if (state == NULL)\n-        continue;\n-    if (state->nbTrans != 1)\n-        continue;\n-       if (state->type == XML_REGEXP_UNREACH_STATE ||\n-           state->type == XML_REGEXP_FINAL_STATE)\n-        continue;\n-    \/* is the only transition out a basic transition *\/\n-    if ((state->trans[0].atom == NULL) &&\n-        (state->trans[0].to >= 0) &&\n-        (state->trans[0].to != statenr) &&\n-        (state->trans[0].counter < 0) &&\n-        (state->trans[0].count < 0)) {\n-        newto = state->trans[0].to;\n-\n-            if (state->type == XML_REGEXP_START_STATE) {\n-            } else {\n-            for (i = 0;i < state->nbTransTo;i++) {\n-            tmp = ctxt->states[state->transTo[i]];\n-            for (j = 0;j < tmp->nbTrans;j++) {\n-            if (tmp->trans[j].to == statenr) {\n-                tmp->trans[j].to = -1;\n-                xmlRegStateAddTrans(ctxt, tmp, tmp->trans[j].atom,\n-                        ctxt->states[newto],\n-                            tmp->trans[j].counter,\n-                        tmp->trans[j].count);\n-            }\n-            }\n-        }\n-        if (state->type == XML_REGEXP_FINAL_STATE)\n-            ctxt->states[newto]->type = XML_REGEXP_FINAL_STATE;\n-        \/* eliminate the transition completely *\/\n-        state->nbTrans = 0;\n-\n-                state->type = XML_REGEXP_UNREACH_STATE;\n-\n-        }\n-\n-    }\n-    }\n-}\n-\/**\n- * xmlFAEliminateEpsilonTransitions:\n- * @ctxt:  a regexp parser context\n- *\n- *\/\n-static void\n-xmlFAEliminateEpsilonTransitions(xmlRegParserCtxtPtr ctxt) {\n-    int statenr, transnr;\n-    xmlRegStatePtr state;\n-    int has_epsilon;\n-\n-    if (ctxt->states == NULL) return;\n-\n-    \/*\n-     * Eliminate simple epsilon transition and the associated unreachable\n-     * states.\n-     *\/\n-    xmlFAEliminateSimpleEpsilonTransitions(ctxt);\n-    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {\n-    state = ctxt->states[statenr];\n-    if ((state != NULL) && (state->type == XML_REGEXP_UNREACH_STATE)) {\n-        xmlRegFreeState(state);\n-        ctxt->states[statenr] = NULL;\n-    }\n-    }\n-\n-    has_epsilon = 0;\n-\n-    \/*\n-     * Build the completed transitions bypassing the epsilons\n-     * Use a marking algorithm to avoid loops\n-     * Mark sink states too.\n-     * Process from the latest states backward to the start when\n-     * there is long cascading epsilon chains this minimize the\n-     * recursions and transition compares when adding the new ones\n-     *\/\n-    for (statenr = ctxt->nbStates - 1;statenr >= 0;statenr--) {\n-    state = ctxt->states[statenr];\n-    if (state == NULL)\n-        continue;\n-    if ((state->nbTrans == 0) &&\n-        (state->type != XML_REGEXP_FINAL_STATE)) {\n-        state->type = XML_REGEXP_SINK_STATE;\n-    }\n-    for (transnr = 0;transnr < state->nbTrans;transnr++) {\n-        if ((state->trans[transnr].atom == NULL) &&\n-        (state->trans[transnr].to >= 0)) {\n-        if (state->trans[transnr].to == statenr) {\n-            state->trans[transnr].to = -1;\n-        } else if (state->trans[transnr].count < 0) {\n-            int newto = state->trans[transnr].to;\n-\n-            has_epsilon = 1;\n-            state->trans[transnr].to = -2;\n-            state->mark = XML_REGEXP_MARK_START;\n-            xmlFAReduceEpsilonTransitions(ctxt, statenr,\n-                      newto, state->trans[transnr].counter);\n-            xmlFAFinishReduceEpsilonTransitions(ctxt, newto);\n-            state->mark = XML_REGEXP_MARK_NORMAL;\n-            }\n-        }\n-    }\n-    }\n-    \/*\n-     * Eliminate the epsilon transitions\n-     *\/\n-    if (has_epsilon) {\n-    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {\n-        state = ctxt->states[statenr];\n-        if (state == NULL)\n-        continue;\n-        for (transnr = 0;transnr < state->nbTrans;transnr++) {\n-        xmlRegTransPtr trans = &(state->trans[transnr]);\n-        if ((trans->atom == NULL) &&\n-            (trans->count < 0) &&\n-            (trans->to >= 0)) {\n-            trans->to = -1;\n-        }\n-        }\n-    }\n-    }\n-\n-    \/*\n-     * Use this pass to detect unreachable states too\n-     *\/\n-    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {\n-    state = ctxt->states[statenr];\n-    if (state != NULL)\n-        state->reached = XML_REGEXP_MARK_NORMAL;\n-    }\n-    state = ctxt->states[0];\n-    if (state != NULL)\n-    state->reached = XML_REGEXP_MARK_START;\n-    while (state != NULL) {\n-    xmlRegStatePtr target = NULL;\n-    state->reached = XML_REGEXP_MARK_VISITED;\n-    \/*\n-     * Mark all states reachable from the current reachable state\n-     *\/\n-    for (transnr = 0;transnr < state->nbTrans;transnr++) {\n-        if ((state->trans[transnr].to >= 0) &&\n-        ((state->trans[transnr].atom != NULL) ||\n-         (state->trans[transnr].count >= 0))) {\n-        int newto = state->trans[transnr].to;\n-\n-        if (ctxt->states[newto] == NULL)\n-            continue;\n-        if (ctxt->states[newto]->reached == XML_REGEXP_MARK_NORMAL) {\n-            ctxt->states[newto]->reached = XML_REGEXP_MARK_START;\n-            target = ctxt->states[newto];\n-        }\n-        }\n-    }\n-\n-    \/*\n-     * find the next accessible state not explored\n-     *\/\n-    if (target == NULL) {\n-        for (statenr = 1;statenr < ctxt->nbStates;statenr++) {\n-        state = ctxt->states[statenr];\n-        if ((state != NULL) && (state->reached ==\n-            XML_REGEXP_MARK_START)) {\n-            target = state;\n-            break;\n-        }\n-        }\n-    }\n-    state = target;\n-    }\n-    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {\n-    state = ctxt->states[statenr];\n-    if ((state != NULL) && (state->reached == XML_REGEXP_MARK_NORMAL)) {\n-        xmlRegFreeState(state);\n-        ctxt->states[statenr] = NULL;\n-    }\n-    }\n-\n-}\n-\n-static int\n-xmlFACompareRanges(xmlRegRangePtr range1, xmlRegRangePtr range2) {\n-    int ret = 0;\n-\n-    if ((range1->type == XML_REGEXP_RANGES) ||\n-        (range2->type == XML_REGEXP_RANGES) ||\n-        (range2->type == XML_REGEXP_SUBREG) ||\n-        (range1->type == XML_REGEXP_SUBREG) ||\n-        (range1->type == XML_REGEXP_STRING) ||\n-        (range2->type == XML_REGEXP_STRING))\n-    return(-1);\n-\n-    \/* put them in order *\/\n-    if (range1->type > range2->type) {\n-        xmlRegRangePtr tmp;\n-\n-    tmp = range1;\n-    range1 = range2;\n-    range2 = tmp;\n-    }\n-    if ((range1->type == XML_REGEXP_ANYCHAR) ||\n-        (range2->type == XML_REGEXP_ANYCHAR)) {\n-    ret = 1;\n-    } else if ((range1->type == XML_REGEXP_EPSILON) ||\n-               (range2->type == XML_REGEXP_EPSILON)) {\n-    return(0);\n-    } else if (range1->type == range2->type) {\n-        if (range1->type != XML_REGEXP_CHARVAL)\n-            ret = 1;\n-        else if ((range1->end < range2->start) ||\n-             (range2->end < range1->start))\n-        ret = 0;\n-    else\n-        ret = 1;\n-    } else if (range1->type == XML_REGEXP_CHARVAL) {\n-        int codepoint;\n-    int neg = 0;\n-\n-    \/*\n-     * just check all codepoints in the range for acceptance,\n-     * this is usually way cheaper since done only once at\n-     * compilation than testing over and over at runtime or\n-     * pushing too many states when evaluating.\n-     *\/\n-    if (((range1->neg == 0) && (range2->neg != 0)) ||\n-        ((range1->neg != 0) && (range2->neg == 0)))\n-        neg = 1;\n-\n-    for (codepoint = range1->start;codepoint <= range1->end ;codepoint++) {\n-        ret = xmlRegCheckCharacterRange(range2->type, codepoint,\n-                        0, range2->start, range2->end,\n-                        range2->blockName);\n-        if (ret < 0)\n-            return(-1);\n-        if (((neg == 1) && (ret == 0)) ||\n-            ((neg == 0) && (ret == 1)))\n-        return(1);\n-    }\n-    return(0);\n-    } else if ((range1->type == XML_REGEXP_BLOCK_NAME) ||\n-               (range2->type == XML_REGEXP_BLOCK_NAME)) {\n-    if (range1->type == range2->type) {\n-        ret = xmlStrEqual(range1->blockName, range2->blockName);\n-    } else {\n-        \/*\n-         * comparing a block range with anything else is way\n-         * too costly, and maintaining the table is like too much\n-         * memory too, so let's force the automata to save state\n-         * here.\n-         *\/\n-        return(1);\n-    }\n-    } else if ((range1->type < XML_REGEXP_LETTER) ||\n-               (range2->type < XML_REGEXP_LETTER)) {\n-    if ((range1->type == XML_REGEXP_ANYSPACE) &&\n-        (range2->type == XML_REGEXP_NOTSPACE))\n-        ret = 0;\n-    else if ((range1->type == XML_REGEXP_INITNAME) &&\n-             (range2->type == XML_REGEXP_NOTINITNAME))\n-        ret = 0;\n-    else if ((range1->type == XML_REGEXP_NAMECHAR) &&\n-             (range2->type == XML_REGEXP_NOTNAMECHAR))\n-        ret = 0;\n-    else if ((range1->type == XML_REGEXP_DECIMAL) &&\n-             (range2->type == XML_REGEXP_NOTDECIMAL))\n-        ret = 0;\n-    else if ((range1->type == XML_REGEXP_REALCHAR) &&\n-             (range2->type == XML_REGEXP_NOTREALCHAR))\n-        ret = 0;\n-    else {\n-        \/* same thing to limit complexity *\/\n-        return(1);\n-    }\n-    } else {\n-        ret = 0;\n-        \/* range1->type < range2->type here *\/\n-        switch (range1->type) {\n-        case XML_REGEXP_LETTER:\n-             \/* all disjoint except in the subgroups *\/\n-             if ((range2->type == XML_REGEXP_LETTER_UPPERCASE) ||\n-             (range2->type == XML_REGEXP_LETTER_LOWERCASE) ||\n-             (range2->type == XML_REGEXP_LETTER_TITLECASE) ||\n-             (range2->type == XML_REGEXP_LETTER_MODIFIER) ||\n-             (range2->type == XML_REGEXP_LETTER_OTHERS))\n-             ret = 1;\n-         break;\n-        case XML_REGEXP_MARK:\n-             if ((range2->type == XML_REGEXP_MARK_NONSPACING) ||\n-             (range2->type == XML_REGEXP_MARK_SPACECOMBINING) ||\n-             (range2->type == XML_REGEXP_MARK_ENCLOSING))\n-             ret = 1;\n-         break;\n-        case XML_REGEXP_NUMBER:\n-             if ((range2->type == XML_REGEXP_NUMBER_DECIMAL) ||\n-             (range2->type == XML_REGEXP_NUMBER_LETTER) ||\n-             (range2->type == XML_REGEXP_NUMBER_OTHERS))\n-             ret = 1;\n-         break;\n-        case XML_REGEXP_PUNCT:\n-             if ((range2->type == XML_REGEXP_PUNCT_CONNECTOR) ||\n-             (range2->type == XML_REGEXP_PUNCT_DASH) ||\n-             (range2->type == XML_REGEXP_PUNCT_OPEN) ||\n-             (range2->type == XML_REGEXP_PUNCT_CLOSE) ||\n-             (range2->type == XML_REGEXP_PUNCT_INITQUOTE) ||\n-             (range2->type == XML_REGEXP_PUNCT_FINQUOTE) ||\n-             (range2->type == XML_REGEXP_PUNCT_OTHERS))\n-             ret = 1;\n-         break;\n-        case XML_REGEXP_SEPAR:\n-             if ((range2->type == XML_REGEXP_SEPAR_SPACE) ||\n-             (range2->type == XML_REGEXP_SEPAR_LINE) ||\n-             (range2->type == XML_REGEXP_SEPAR_PARA))\n-             ret = 1;\n-         break;\n-        case XML_REGEXP_SYMBOL:\n-             if ((range2->type == XML_REGEXP_SYMBOL_MATH) ||\n-             (range2->type == XML_REGEXP_SYMBOL_CURRENCY) ||\n-             (range2->type == XML_REGEXP_SYMBOL_MODIFIER) ||\n-             (range2->type == XML_REGEXP_SYMBOL_OTHERS))\n-             ret = 1;\n-         break;\n-        case XML_REGEXP_OTHER:\n-             if ((range2->type == XML_REGEXP_OTHER_CONTROL) ||\n-             (range2->type == XML_REGEXP_OTHER_FORMAT) ||\n-             (range2->type == XML_REGEXP_OTHER_PRIVATE))\n-             ret = 1;\n-         break;\n-            default:\n-             if ((range2->type >= XML_REGEXP_LETTER) &&\n-             (range2->type < XML_REGEXP_BLOCK_NAME))\n-             ret = 0;\n-         else {\n-             \/* safety net ! *\/\n-             return(1);\n-         }\n-    }\n-    }\n-    if (((range1->neg == 0) && (range2->neg != 0)) ||\n-        ((range1->neg != 0) && (range2->neg == 0)))\n-    ret = !ret;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlFACompareAtomTypes:\n- * @type1:  an atom type\n- * @type2:  an atom type\n- *\n- * Compares two atoms type to check whether they intersect in some ways,\n- * this is used by xmlFACompareAtoms only\n- *\n- * Returns 1 if they may intersect and 0 otherwise\n- *\/\n-static int\n-xmlFACompareAtomTypes(xmlRegAtomType type1, xmlRegAtomType type2) {\n-    if ((type1 == XML_REGEXP_EPSILON) ||\n-        (type1 == XML_REGEXP_CHARVAL) ||\n-    (type1 == XML_REGEXP_RANGES) ||\n-    (type1 == XML_REGEXP_SUBREG) ||\n-    (type1 == XML_REGEXP_STRING) ||\n-    (type1 == XML_REGEXP_ANYCHAR))\n-    return(1);\n-    if ((type2 == XML_REGEXP_EPSILON) ||\n-        (type2 == XML_REGEXP_CHARVAL) ||\n-    (type2 == XML_REGEXP_RANGES) ||\n-    (type2 == XML_REGEXP_SUBREG) ||\n-    (type2 == XML_REGEXP_STRING) ||\n-    (type2 == XML_REGEXP_ANYCHAR))\n-    return(1);\n-\n-    if (type1 == type2) return(1);\n-\n-    \/* simplify subsequent compares by making sure type1 < type2 *\/\n-    if (type1 > type2) {\n-        xmlRegAtomType tmp = type1;\n-    type1 = type2;\n-    type2 = tmp;\n-    }\n-    switch (type1) {\n-        case XML_REGEXP_ANYSPACE: \/* \\s *\/\n-        \/* can't be a letter, number, mark, punctuation, symbol *\/\n-        if ((type2 == XML_REGEXP_NOTSPACE) ||\n-        ((type2 >= XML_REGEXP_LETTER) &&\n-         (type2 <= XML_REGEXP_LETTER_OTHERS)) ||\n-            ((type2 >= XML_REGEXP_NUMBER) &&\n-         (type2 <= XML_REGEXP_NUMBER_OTHERS)) ||\n-            ((type2 >= XML_REGEXP_MARK) &&\n-         (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||\n-            ((type2 >= XML_REGEXP_PUNCT) &&\n-         (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||\n-            ((type2 >= XML_REGEXP_SYMBOL) &&\n-         (type2 <= XML_REGEXP_SYMBOL_OTHERS))\n-            ) return(0);\n-        break;\n-        case XML_REGEXP_NOTSPACE: \/* \\S *\/\n-        break;\n-        case XML_REGEXP_INITNAME: \/* \\l *\/\n-        \/* can't be a number, mark, separator, punctuation, symbol or other *\/\n-        if ((type2 == XML_REGEXP_NOTINITNAME) ||\n-            ((type2 >= XML_REGEXP_NUMBER) &&\n-         (type2 <= XML_REGEXP_NUMBER_OTHERS)) ||\n-            ((type2 >= XML_REGEXP_MARK) &&\n-         (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||\n-            ((type2 >= XML_REGEXP_SEPAR) &&\n-         (type2 <= XML_REGEXP_SEPAR_PARA)) ||\n-            ((type2 >= XML_REGEXP_PUNCT) &&\n-         (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||\n-            ((type2 >= XML_REGEXP_SYMBOL) &&\n-         (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||\n-            ((type2 >= XML_REGEXP_OTHER) &&\n-         (type2 <= XML_REGEXP_OTHER_NA))\n-        ) return(0);\n-        break;\n-        case XML_REGEXP_NOTINITNAME: \/* \\L *\/\n-        break;\n-        case XML_REGEXP_NAMECHAR: \/* \\c *\/\n-        \/* can't be a mark, separator, punctuation, symbol or other *\/\n-        if ((type2 == XML_REGEXP_NOTNAMECHAR) ||\n-            ((type2 >= XML_REGEXP_MARK) &&\n-         (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||\n-            ((type2 >= XML_REGEXP_PUNCT) &&\n-         (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||\n-            ((type2 >= XML_REGEXP_SEPAR) &&\n-         (type2 <= XML_REGEXP_SEPAR_PARA)) ||\n-            ((type2 >= XML_REGEXP_SYMBOL) &&\n-         (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||\n-            ((type2 >= XML_REGEXP_OTHER) &&\n-         (type2 <= XML_REGEXP_OTHER_NA))\n-        ) return(0);\n-        break;\n-        case XML_REGEXP_NOTNAMECHAR: \/* \\C *\/\n-        break;\n-        case XML_REGEXP_DECIMAL: \/* \\d *\/\n-        \/* can't be a letter, mark, separator, punctuation, symbol or other *\/\n-        if ((type2 == XML_REGEXP_NOTDECIMAL) ||\n-            (type2 == XML_REGEXP_REALCHAR) ||\n-        ((type2 >= XML_REGEXP_LETTER) &&\n-         (type2 <= XML_REGEXP_LETTER_OTHERS)) ||\n-            ((type2 >= XML_REGEXP_MARK) &&\n-         (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||\n-            ((type2 >= XML_REGEXP_PUNCT) &&\n-         (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||\n-            ((type2 >= XML_REGEXP_SEPAR) &&\n-         (type2 <= XML_REGEXP_SEPAR_PARA)) ||\n-            ((type2 >= XML_REGEXP_SYMBOL) &&\n-         (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||\n-            ((type2 >= XML_REGEXP_OTHER) &&\n-         (type2 <= XML_REGEXP_OTHER_NA))\n-        )return(0);\n-        break;\n-        case XML_REGEXP_NOTDECIMAL: \/* \\D *\/\n-        break;\n-        case XML_REGEXP_REALCHAR: \/* \\w *\/\n-        \/* can't be a mark, separator, punctuation, symbol or other *\/\n-        if ((type2 == XML_REGEXP_NOTDECIMAL) ||\n-            ((type2 >= XML_REGEXP_MARK) &&\n-         (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||\n-            ((type2 >= XML_REGEXP_PUNCT) &&\n-         (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||\n-            ((type2 >= XML_REGEXP_SEPAR) &&\n-         (type2 <= XML_REGEXP_SEPAR_PARA)) ||\n-            ((type2 >= XML_REGEXP_SYMBOL) &&\n-         (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||\n-            ((type2 >= XML_REGEXP_OTHER) &&\n-         (type2 <= XML_REGEXP_OTHER_NA))\n-        )return(0);\n-        break;\n-        case XML_REGEXP_NOTREALCHAR: \/* \\W *\/\n-        break;\n-    \/*\n-     * at that point we know both type 1 and type2 are from\n-     * character categories are ordered and are different,\n-     * it becomes simple because this is a partition\n-     *\/\n-        case XML_REGEXP_LETTER:\n-        if (type2 <= XML_REGEXP_LETTER_OTHERS)\n-            return(1);\n-        return(0);\n-        case XML_REGEXP_LETTER_UPPERCASE:\n-        case XML_REGEXP_LETTER_LOWERCASE:\n-        case XML_REGEXP_LETTER_TITLECASE:\n-        case XML_REGEXP_LETTER_MODIFIER:\n-        case XML_REGEXP_LETTER_OTHERS:\n-        return(0);\n-        case XML_REGEXP_MARK:\n-        if (type2 <= XML_REGEXP_MARK_ENCLOSING)\n-            return(1);\n-        return(0);\n-        case XML_REGEXP_MARK_NONSPACING:\n-        case XML_REGEXP_MARK_SPACECOMBINING:\n-        case XML_REGEXP_MARK_ENCLOSING:\n-        return(0);\n-        case XML_REGEXP_NUMBER:\n-        if (type2 <= XML_REGEXP_NUMBER_OTHERS)\n-            return(1);\n-        return(0);\n-        case XML_REGEXP_NUMBER_DECIMAL:\n-        case XML_REGEXP_NUMBER_LETTER:\n-        case XML_REGEXP_NUMBER_OTHERS:\n-        return(0);\n-        case XML_REGEXP_PUNCT:\n-        if (type2 <= XML_REGEXP_PUNCT_OTHERS)\n-            return(1);\n-        return(0);\n-        case XML_REGEXP_PUNCT_CONNECTOR:\n-        case XML_REGEXP_PUNCT_DASH:\n-        case XML_REGEXP_PUNCT_OPEN:\n-        case XML_REGEXP_PUNCT_CLOSE:\n-        case XML_REGEXP_PUNCT_INITQUOTE:\n-        case XML_REGEXP_PUNCT_FINQUOTE:\n-        case XML_REGEXP_PUNCT_OTHERS:\n-        return(0);\n-        case XML_REGEXP_SEPAR:\n-        if (type2 <= XML_REGEXP_SEPAR_PARA)\n-            return(1);\n-        return(0);\n-        case XML_REGEXP_SEPAR_SPACE:\n-        case XML_REGEXP_SEPAR_LINE:\n-        case XML_REGEXP_SEPAR_PARA:\n-        return(0);\n-        case XML_REGEXP_SYMBOL:\n-        if (type2 <= XML_REGEXP_SYMBOL_OTHERS)\n-            return(1);\n-        return(0);\n-        case XML_REGEXP_SYMBOL_MATH:\n-        case XML_REGEXP_SYMBOL_CURRENCY:\n-        case XML_REGEXP_SYMBOL_MODIFIER:\n-        case XML_REGEXP_SYMBOL_OTHERS:\n-        return(0);\n-        case XML_REGEXP_OTHER:\n-        if (type2 <= XML_REGEXP_OTHER_NA)\n-            return(1);\n-        return(0);\n-        case XML_REGEXP_OTHER_CONTROL:\n-        case XML_REGEXP_OTHER_FORMAT:\n-        case XML_REGEXP_OTHER_PRIVATE:\n-        case XML_REGEXP_OTHER_NA:\n-        return(0);\n-    default:\n-        break;\n-    }\n-    return(1);\n-}\n-\n-\/**\n- * xmlFAEqualAtoms:\n- * @atom1:  an atom\n- * @atom2:  an atom\n- * @deep: if not set only compare string pointers\n- *\n- * Compares two atoms to check whether they are the same exactly\n- * this is used to remove equivalent transitions\n- *\n- * Returns 1 if same and 0 otherwise\n- *\/\n-static int\n-xmlFAEqualAtoms(xmlRegAtomPtr atom1, xmlRegAtomPtr atom2, int deep) {\n-    int ret = 0;\n-\n-    if (atom1 == atom2)\n-    return(1);\n-    if ((atom1 == NULL) || (atom2 == NULL))\n-    return(0);\n-\n-    if (atom1->type != atom2->type)\n-        return(0);\n-    switch (atom1->type) {\n-        case XML_REGEXP_EPSILON:\n-        ret = 0;\n-        break;\n-        case XML_REGEXP_STRING:\n-            if (!deep)\n-                ret = (atom1->valuep == atom2->valuep);\n-            else\n-                ret = xmlStrEqual((xmlChar *)atom1->valuep,\n-                                  (xmlChar *)atom2->valuep);\n-        break;\n-        case XML_REGEXP_CHARVAL:\n-        ret = (atom1->codepoint == atom2->codepoint);\n-        break;\n-    case XML_REGEXP_RANGES:\n-        \/* too hard to do in the general case *\/\n-        ret = 0;\n-    default:\n-        break;\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlFACompareAtoms:\n- * @atom1:  an atom\n- * @atom2:  an atom\n- * @deep: if not set only compare string pointers\n- *\n- * Compares two atoms to check whether they intersect in some ways,\n- * this is used by xmlFAComputesDeterminism and xmlFARecurseDeterminism only\n- *\n- * Returns 1 if yes and 0 otherwise\n- *\/\n-static int\n-xmlFACompareAtoms(xmlRegAtomPtr atom1, xmlRegAtomPtr atom2, int deep) {\n-    int ret = 1;\n-\n-    if (atom1 == atom2)\n-    return(1);\n-    if ((atom1 == NULL) || (atom2 == NULL))\n-    return(0);\n-\n-    if ((atom1->type == XML_REGEXP_ANYCHAR) ||\n-        (atom2->type == XML_REGEXP_ANYCHAR))\n-    return(1);\n-\n-    if (atom1->type > atom2->type) {\n-    xmlRegAtomPtr tmp;\n-    tmp = atom1;\n-    atom1 = atom2;\n-    atom2 = tmp;\n-    }\n-    if (atom1->type != atom2->type) {\n-        ret = xmlFACompareAtomTypes(atom1->type, atom2->type);\n-    \/* if they can't intersect at the type level break now *\/\n-    if (ret == 0)\n-        return(0);\n-    }\n-    switch (atom1->type) {\n-        case XML_REGEXP_STRING:\n-            if (!deep)\n-                ret = (atom1->valuep != atom2->valuep);\n-            else {\n-                xmlChar *val1 = (xmlChar *)atom1->valuep;\n-                xmlChar *val2 = (xmlChar *)atom2->valuep;\n-                int compound1 = (xmlStrchr(val1, '|') != NULL);\n-                int compound2 = (xmlStrchr(val2, '|') != NULL);\n-\n-                \/* Ignore negative match flag for ##other namespaces *\/\n-                if (compound1 != compound2)\n-                    return(0);\n-\n-                ret = xmlRegStrEqualWildcard(val1, val2);\n-            }\n-        break;\n-        case XML_REGEXP_EPSILON:\n-        goto not_determinist;\n-        case XML_REGEXP_CHARVAL:\n-        if (atom2->type == XML_REGEXP_CHARVAL) {\n-        ret = (atom1->codepoint == atom2->codepoint);\n-        } else {\n-            ret = xmlRegCheckCharacter(atom2, atom1->codepoint);\n-        if (ret < 0)\n-            ret = 1;\n-        }\n-        break;\n-        case XML_REGEXP_RANGES:\n-        if (atom2->type == XML_REGEXP_RANGES) {\n-            int i, j, res;\n-        xmlRegRangePtr r1, r2;\n-\n-        \/*\n-         * need to check that none of the ranges eventually matches\n-         *\/\n-        for (i = 0;i < atom1->nbRanges;i++) {\n-            for (j = 0;j < atom2->nbRanges;j++) {\n-            r1 = atom1->ranges[i];\n-            r2 = atom2->ranges[j];\n-            res = xmlFACompareRanges(r1, r2);\n-            if (res == 1) {\n-                ret = 1;\n-                goto done;\n-            }\n-            }\n-        }\n-        ret = 0;\n-        }\n-        break;\n-    default:\n-        goto not_determinist;\n-    }\n-done:\n-    if (atom1->neg != atom2->neg) {\n-        ret = !ret;\n-    }\n-    if (ret == 0)\n-        return(0);\n-not_determinist:\n-    return(1);\n-}\n-\n-\/**\n- * xmlFARecurseDeterminism:\n- * @ctxt:  a regexp parser context\n- *\n- * Check whether the associated regexp is determinist,\n- * should be called after xmlFAEliminateEpsilonTransitions()\n- *\n- *\/\n-static int\n-xmlFARecurseDeterminism(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr state,\n-                    int fromnr, int tonr, xmlRegAtomPtr atom) {\n-    int ret = 1;\n-    int res;\n-    int transnr, nbTrans;\n-    xmlRegTransPtr t1;\n-    int deep = 1;\n-\n-    if (state == NULL)\n-    return(ret);\n-    if (state->markd == XML_REGEXP_MARK_VISITED)\n-    return(ret);\n-\n-    if (ctxt->flags & AM_AUTOMATA_RNG)\n-        deep = 0;\n-\n-    \/*\n-     * don't recurse on transitions potentially added in the course of\n-     * the elimination.\n-     *\/\n-    nbTrans = state->nbTrans;\n-    for (transnr = 0;transnr < nbTrans;transnr++) {\n-    t1 = &(state->trans[transnr]);\n-    \/*\n-     * check transitions conflicting with the one looked at\n-     *\/\n-        if ((t1->to < 0) || (t1->to == fromnr))\n-            continue;\n-    if (t1->atom == NULL) {\n-        state->markd = XML_REGEXP_MARK_VISITED;\n-        res = xmlFARecurseDeterminism(ctxt, ctxt->states[t1->to],\n-                                  fromnr, tonr, atom);\n-        if (res == 0) {\n-            ret = 0;\n-        \/* t1->nd = 1; *\/\n-        }\n-        continue;\n-    }\n-    if (xmlFACompareAtoms(t1->atom, atom, deep)) {\n-            \/* Treat equal transitions as deterministic. *\/\n-            if ((t1->to != tonr) ||\n-                (!xmlFAEqualAtoms(t1->atom, atom, deep)))\n-                ret = 0;\n-        \/* mark the transition as non-deterministic *\/\n-        t1->nd = 1;\n-    }\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlFAFinishRecurseDeterminism:\n- * @ctxt:  a regexp parser context\n- *\n- * Reset flags after checking determinism.\n- *\/\n-static void\n-xmlFAFinishRecurseDeterminism(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr state) {\n-    int transnr, nbTrans;\n-\n-    if (state == NULL)\n-    return;\n-    if (state->markd != XML_REGEXP_MARK_VISITED)\n-    return;\n-    state->markd = 0;\n-\n-    nbTrans = state->nbTrans;\n-    for (transnr = 0; transnr < nbTrans; transnr++) {\n-    xmlRegTransPtr t1 = &state->trans[transnr];\n-    if ((t1->atom == NULL) && (t1->to >= 0))\n-        xmlFAFinishRecurseDeterminism(ctxt, ctxt->states[t1->to]);\n-    }\n-}\n-\n-\/**\n- * xmlFAComputesDeterminism:\n- * @ctxt:  a regexp parser context\n- *\n- * Check whether the associated regexp is determinist,\n- * should be called after xmlFAEliminateEpsilonTransitions()\n- *\n- *\/\n-static int\n-xmlFAComputesDeterminism(xmlRegParserCtxtPtr ctxt) {\n-    int statenr, transnr;\n-    xmlRegStatePtr state;\n-    xmlRegTransPtr t1, t2, last;\n-    int i;\n-    int ret = 1;\n-    int deep = 1;\n-\n-    if (ctxt->determinist != -1)\n-    return(ctxt->determinist);\n-\n-    if (ctxt->flags & AM_AUTOMATA_RNG)\n-        deep = 0;\n-\n-    \/*\n-     * First cleanup the automata removing cancelled transitions\n-     *\/\n-    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {\n-    state = ctxt->states[statenr];\n-    if (state == NULL)\n-        continue;\n-    if (state->nbTrans < 2)\n-        continue;\n-    for (transnr = 0;transnr < state->nbTrans;transnr++) {\n-        t1 = &(state->trans[transnr]);\n-        \/*\n-         * Determinism checks in case of counted or all transitions\n-         * will have to be handled separately\n-         *\/\n-        if (t1->atom == NULL) {\n-        \/* t1->nd = 1; *\/\n-        continue;\n-        }\n-        if (t1->to < 0) \/* eliminated *\/\n-        continue;\n-        for (i = 0;i < transnr;i++) {\n-        t2 = &(state->trans[i]);\n-        if (t2->to < 0) \/* eliminated *\/\n-            continue;\n-        if (t2->atom != NULL) {\n-            if (t1->to == t2->to) {\n-                        \/*\n-                         * Here we use deep because we want to keep the\n-                         * transitions which indicate a conflict\n-                         *\/\n-            if (xmlFAEqualAtoms(t1->atom, t2->atom, deep) &&\n-                            (t1->counter == t2->counter) &&\n-                            (t1->count == t2->count))\n-                t2->to = -1; \/* eliminated *\/\n-            }\n-        }\n-        }\n-    }\n-    }\n-\n-    \/*\n-     * Check for all states that there aren't 2 transitions\n-     * with the same atom and a different target.\n-     *\/\n-    for (statenr = 0;statenr < ctxt->nbStates;statenr++) {\n-    state = ctxt->states[statenr];\n-    if (state == NULL)\n-        continue;\n-    if (state->nbTrans < 2)\n-        continue;\n-    last = NULL;\n-    for (transnr = 0;transnr < state->nbTrans;transnr++) {\n-        t1 = &(state->trans[transnr]);\n-        \/*\n-         * Determinism checks in case of counted or all transitions\n-         * will have to be handled separately\n-         *\/\n-        if (t1->atom == NULL) {\n-        continue;\n-        }\n-        if (t1->to < 0) \/* eliminated *\/\n-        continue;\n-        for (i = 0;i < transnr;i++) {\n-        t2 = &(state->trans[i]);\n-        if (t2->to < 0) \/* eliminated *\/\n-            continue;\n-        if (t2->atom != NULL) {\n-                    \/*\n-                     * But here we don't use deep because we want to\n-                     * find transitions which indicate a conflict\n-                     *\/\n-            if (xmlFACompareAtoms(t1->atom, t2->atom, 1)) {\n-                        \/*\n-                         * Treat equal counter transitions that couldn't be\n-                         * eliminated as deterministic.\n-                         *\/\n-                        if ((t1->to != t2->to) ||\n-                            (t1->counter == t2->counter) ||\n-                            (!xmlFAEqualAtoms(t1->atom, t2->atom, deep)))\n-                            ret = 0;\n-            \/* mark the transitions as non-deterministic ones *\/\n-            t1->nd = 1;\n-            t2->nd = 1;\n-            last = t1;\n-            }\n-        } else {\n-                    int res;\n-\n-            \/*\n-             * do the closure in case of remaining specific\n-             * epsilon transitions like choices or all\n-             *\/\n-            res = xmlFARecurseDeterminism(ctxt, ctxt->states[t2->to],\n-                          statenr, t1->to, t1->atom);\n-                    xmlFAFinishRecurseDeterminism(ctxt, ctxt->states[t2->to]);\n-            \/* don't shortcut the computation so all non deterministic\n-               transition get marked down\n-            if (ret == 0)\n-            return(0);\n-             *\/\n-            if (res == 0) {\n-            t1->nd = 1;\n-            \/* t2->nd = 1; *\/\n-            last = t1;\n-                        ret = 0;\n-            }\n-        }\n-        }\n-        \/* don't shortcut the computation so all non deterministic\n-           transition get marked down\n-        if (ret == 0)\n-        break; *\/\n-    }\n-\n-    \/*\n-     * mark specifically the last non-deterministic transition\n-     * from a state since there is no need to set-up rollback\n-     * from it\n-     *\/\n-    if (last != NULL) {\n-        last->nd = 2;\n-    }\n-\n-    \/* don't shortcut the computation so all non deterministic\n-       transition get marked down\n-    if (ret == 0)\n-        break; *\/\n-    }\n-\n-    ctxt->determinist = ret;\n-    return(ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *    Routines to check input against transition atoms        *\n- *                                    *\n- ************************************************************************\/\n-\n-static int\n-xmlRegCheckCharacterRange(xmlRegAtomType type, int codepoint, int neg,\n-                      int start, int end, const xmlChar *blockName) {\n-    int ret = 0;\n-\n-    switch (type) {\n-        case XML_REGEXP_STRING:\n-        case XML_REGEXP_SUBREG:\n-        case XML_REGEXP_RANGES:\n-        case XML_REGEXP_EPSILON:\n-        return(-1);\n-        case XML_REGEXP_ANYCHAR:\n-        ret = ((codepoint != '\\n') && (codepoint != '\\r'));\n-        break;\n-        case XML_REGEXP_CHARVAL:\n-        ret = ((codepoint >= start) && (codepoint <= end));\n-        break;\n-        case XML_REGEXP_NOTSPACE:\n-        neg = !neg;\n-            \/* Falls through. *\/\n-        case XML_REGEXP_ANYSPACE:\n-        ret = ((codepoint == '\\n') || (codepoint == '\\r') ||\n-           (codepoint == '\\t') || (codepoint == ' '));\n-        break;\n-        case XML_REGEXP_NOTINITNAME:\n-        neg = !neg;\n-            \/* Falls through. *\/\n-        case XML_REGEXP_INITNAME:\n-        ret = (IS_LETTER(codepoint) ||\n-           (codepoint == '_') || (codepoint == ':'));\n-        break;\n-        case XML_REGEXP_NOTNAMECHAR:\n-        neg = !neg;\n-            \/* Falls through. *\/\n-        case XML_REGEXP_NAMECHAR:\n-        ret = (IS_LETTER(codepoint) || IS_DIGIT(codepoint) ||\n-           (codepoint == '.') || (codepoint == '-') ||\n-           (codepoint == '_') || (codepoint == ':') ||\n-           IS_COMBINING(codepoint) || IS_EXTENDER(codepoint));\n-        break;\n-        case XML_REGEXP_NOTDECIMAL:\n-        neg = !neg;\n-            \/* Falls through. *\/\n-        case XML_REGEXP_DECIMAL:\n-        ret = xmlUCSIsCatNd(codepoint);\n-        break;\n-        case XML_REGEXP_REALCHAR:\n-        neg = !neg;\n-            \/* Falls through. *\/\n-        case XML_REGEXP_NOTREALCHAR:\n-        ret = xmlUCSIsCatP(codepoint);\n-        if (ret == 0)\n-        ret = xmlUCSIsCatZ(codepoint);\n-        if (ret == 0)\n-        ret = xmlUCSIsCatC(codepoint);\n-        break;\n-        case XML_REGEXP_LETTER:\n-        ret = xmlUCSIsCatL(codepoint);\n-        break;\n-        case XML_REGEXP_LETTER_UPPERCASE:\n-        ret = xmlUCSIsCatLu(codepoint);\n-        break;\n-        case XML_REGEXP_LETTER_LOWERCASE:\n-        ret = xmlUCSIsCatLl(codepoint);\n-        break;\n-        case XML_REGEXP_LETTER_TITLECASE:\n-        ret = xmlUCSIsCatLt(codepoint);\n-        break;\n-        case XML_REGEXP_LETTER_MODIFIER:\n-        ret = xmlUCSIsCatLm(codepoint);\n-        break;\n-        case XML_REGEXP_LETTER_OTHERS:\n-        ret = xmlUCSIsCatLo(codepoint);\n-        break;\n-        case XML_REGEXP_MARK:\n-        ret = xmlUCSIsCatM(codepoint);\n-        break;\n-        case XML_REGEXP_MARK_NONSPACING:\n-        ret = xmlUCSIsCatMn(codepoint);\n-        break;\n-        case XML_REGEXP_MARK_SPACECOMBINING:\n-        ret = xmlUCSIsCatMc(codepoint);\n-        break;\n-        case XML_REGEXP_MARK_ENCLOSING:\n-        ret = xmlUCSIsCatMe(codepoint);\n-        break;\n-        case XML_REGEXP_NUMBER:\n-        ret = xmlUCSIsCatN(codepoint);\n-        break;\n-        case XML_REGEXP_NUMBER_DECIMAL:\n-        ret = xmlUCSIsCatNd(codepoint);\n-        break;\n-        case XML_REGEXP_NUMBER_LETTER:\n-        ret = xmlUCSIsCatNl(codepoint);\n-        break;\n-        case XML_REGEXP_NUMBER_OTHERS:\n-        ret = xmlUCSIsCatNo(codepoint);\n-        break;\n-        case XML_REGEXP_PUNCT:\n-        ret = xmlUCSIsCatP(codepoint);\n-        break;\n-        case XML_REGEXP_PUNCT_CONNECTOR:\n-        ret = xmlUCSIsCatPc(codepoint);\n-        break;\n-        case XML_REGEXP_PUNCT_DASH:\n-        ret = xmlUCSIsCatPd(codepoint);\n-        break;\n-        case XML_REGEXP_PUNCT_OPEN:\n-        ret = xmlUCSIsCatPs(codepoint);\n-        break;\n-        case XML_REGEXP_PUNCT_CLOSE:\n-        ret = xmlUCSIsCatPe(codepoint);\n-        break;\n-        case XML_REGEXP_PUNCT_INITQUOTE:\n-        ret = xmlUCSIsCatPi(codepoint);\n-        break;\n-        case XML_REGEXP_PUNCT_FINQUOTE:\n-        ret = xmlUCSIsCatPf(codepoint);\n-        break;\n-        case XML_REGEXP_PUNCT_OTHERS:\n-        ret = xmlUCSIsCatPo(codepoint);\n-        break;\n-        case XML_REGEXP_SEPAR:\n-        ret = xmlUCSIsCatZ(codepoint);\n-        break;\n-        case XML_REGEXP_SEPAR_SPACE:\n-        ret = xmlUCSIsCatZs(codepoint);\n-        break;\n-        case XML_REGEXP_SEPAR_LINE:\n-        ret = xmlUCSIsCatZl(codepoint);\n-        break;\n-        case XML_REGEXP_SEPAR_PARA:\n-        ret = xmlUCSIsCatZp(codepoint);\n-        break;\n-        case XML_REGEXP_SYMBOL:\n-        ret = xmlUCSIsCatS(codepoint);\n-        break;\n-        case XML_REGEXP_SYMBOL_MATH:\n-        ret = xmlUCSIsCatSm(codepoint);\n-        break;\n-        case XML_REGEXP_SYMBOL_CURRENCY:\n-        ret = xmlUCSIsCatSc(codepoint);\n-        break;\n-        case XML_REGEXP_SYMBOL_MODIFIER:\n-        ret = xmlUCSIsCatSk(codepoint);\n-        break;\n-        case XML_REGEXP_SYMBOL_OTHERS:\n-        ret = xmlUCSIsCatSo(codepoint);\n-        break;\n-        case XML_REGEXP_OTHER:\n-        ret = xmlUCSIsCatC(codepoint);\n-        break;\n-        case XML_REGEXP_OTHER_CONTROL:\n-        ret = xmlUCSIsCatCc(codepoint);\n-        break;\n-        case XML_REGEXP_OTHER_FORMAT:\n-        ret = xmlUCSIsCatCf(codepoint);\n-        break;\n-        case XML_REGEXP_OTHER_PRIVATE:\n-        ret = xmlUCSIsCatCo(codepoint);\n-        break;\n-        case XML_REGEXP_OTHER_NA:\n-        \/* ret = xmlUCSIsCatCn(codepoint); *\/\n-        \/* Seems it doesn't exist anymore in recent Unicode releases *\/\n-        ret = 0;\n-        break;\n-        case XML_REGEXP_BLOCK_NAME:\n-        ret = xmlUCSIsBlock(codepoint, (const char *) blockName);\n-        break;\n-    }\n-    if (neg)\n-    return(!ret);\n-    return(ret);\n-}\n-\n-static int\n-xmlRegCheckCharacter(xmlRegAtomPtr atom, int codepoint) {\n-    int i, ret = 0;\n-    xmlRegRangePtr range;\n-\n-    if ((atom == NULL) || (!IS_CHAR(codepoint)))\n-    return(-1);\n-\n-    switch (atom->type) {\n-        case XML_REGEXP_SUBREG:\n-        case XML_REGEXP_EPSILON:\n-        return(-1);\n-        case XML_REGEXP_CHARVAL:\n-            return(codepoint == atom->codepoint);\n-        case XML_REGEXP_RANGES: {\n-        int accept = 0;\n-\n-        for (i = 0;i < atom->nbRanges;i++) {\n-        range = atom->ranges[i];\n-        if (range->neg == 2) {\n-            ret = xmlRegCheckCharacterRange(range->type, codepoint,\n-                        0, range->start, range->end,\n-                        range->blockName);\n-            if (ret != 0)\n-            return(0); \/* excluded char *\/\n-        } else if (range->neg) {\n-            ret = xmlRegCheckCharacterRange(range->type, codepoint,\n-                        0, range->start, range->end,\n-                        range->blockName);\n-            if (ret == 0)\n-                accept = 1;\n-            else\n-                return(0);\n-        } else {\n-            ret = xmlRegCheckCharacterRange(range->type, codepoint,\n-                        0, range->start, range->end,\n-                        range->blockName);\n-            if (ret != 0)\n-            accept = 1; \/* might still be excluded *\/\n-        }\n-        }\n-        return(accept);\n-    }\n-        case XML_REGEXP_STRING:\n-        printf(\"TODO: XML_REGEXP_STRING\\n\");\n-        return(-1);\n-        case XML_REGEXP_ANYCHAR:\n-        case XML_REGEXP_ANYSPACE:\n-        case XML_REGEXP_NOTSPACE:\n-        case XML_REGEXP_INITNAME:\n-        case XML_REGEXP_NOTINITNAME:\n-        case XML_REGEXP_NAMECHAR:\n-        case XML_REGEXP_NOTNAMECHAR:\n-        case XML_REGEXP_DECIMAL:\n-        case XML_REGEXP_NOTDECIMAL:\n-        case XML_REGEXP_REALCHAR:\n-        case XML_REGEXP_NOTREALCHAR:\n-        case XML_REGEXP_LETTER:\n-        case XML_REGEXP_LETTER_UPPERCASE:\n-        case XML_REGEXP_LETTER_LOWERCASE:\n-        case XML_REGEXP_LETTER_TITLECASE:\n-        case XML_REGEXP_LETTER_MODIFIER:\n-        case XML_REGEXP_LETTER_OTHERS:\n-        case XML_REGEXP_MARK:\n-        case XML_REGEXP_MARK_NONSPACING:\n-        case XML_REGEXP_MARK_SPACECOMBINING:\n-        case XML_REGEXP_MARK_ENCLOSING:\n-        case XML_REGEXP_NUMBER:\n-        case XML_REGEXP_NUMBER_DECIMAL:\n-        case XML_REGEXP_NUMBER_LETTER:\n-        case XML_REGEXP_NUMBER_OTHERS:\n-        case XML_REGEXP_PUNCT:\n-        case XML_REGEXP_PUNCT_CONNECTOR:\n-        case XML_REGEXP_PUNCT_DASH:\n-        case XML_REGEXP_PUNCT_OPEN:\n-        case XML_REGEXP_PUNCT_CLOSE:\n-        case XML_REGEXP_PUNCT_INITQUOTE:\n-        case XML_REGEXP_PUNCT_FINQUOTE:\n-        case XML_REGEXP_PUNCT_OTHERS:\n-        case XML_REGEXP_SEPAR:\n-        case XML_REGEXP_SEPAR_SPACE:\n-        case XML_REGEXP_SEPAR_LINE:\n-        case XML_REGEXP_SEPAR_PARA:\n-        case XML_REGEXP_SYMBOL:\n-        case XML_REGEXP_SYMBOL_MATH:\n-        case XML_REGEXP_SYMBOL_CURRENCY:\n-        case XML_REGEXP_SYMBOL_MODIFIER:\n-        case XML_REGEXP_SYMBOL_OTHERS:\n-        case XML_REGEXP_OTHER:\n-        case XML_REGEXP_OTHER_CONTROL:\n-        case XML_REGEXP_OTHER_FORMAT:\n-        case XML_REGEXP_OTHER_PRIVATE:\n-        case XML_REGEXP_OTHER_NA:\n-    case XML_REGEXP_BLOCK_NAME:\n-        ret = xmlRegCheckCharacterRange(atom->type, codepoint, 0, 0, 0,\n-                                    (const xmlChar *)atom->valuep);\n-        if (atom->neg)\n-        ret = !ret;\n-        break;\n-    }\n-    return(ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *    Saving and restoring state of an execution context        *\n- *                                    *\n- ************************************************************************\/\n-\n-static void\n-xmlFARegExecSave(xmlRegExecCtxtPtr exec) {\n-#ifdef MAX_PUSH\n-    if (exec->nbPush > MAX_PUSH) {\n-        exec->status = XML_REGEXP_INTERNAL_LIMIT;\n-        return;\n-    }\n-    exec->nbPush++;\n-#endif\n-\n-    if (exec->maxRollbacks == 0) {\n-    exec->maxRollbacks = 4;\n-    exec->rollbacks = (xmlRegExecRollback *) xmlMalloc(exec->maxRollbacks *\n-                                     sizeof(xmlRegExecRollback));\n-    if (exec->rollbacks == NULL) {\n-        exec->maxRollbacks = 0;\n-            exec->status = XML_REGEXP_OUT_OF_MEMORY;\n-        return;\n-    }\n-    memset(exec->rollbacks, 0,\n-           exec->maxRollbacks * sizeof(xmlRegExecRollback));\n-    } else if (exec->nbRollbacks >= exec->maxRollbacks) {\n-    xmlRegExecRollback *tmp;\n-    int len = exec->maxRollbacks;\n-\n-    exec->maxRollbacks *= 2;\n-    tmp = (xmlRegExecRollback *) xmlRealloc(exec->rollbacks,\n-            exec->maxRollbacks * sizeof(xmlRegExecRollback));\n-    if (tmp == NULL) {\n-        exec->maxRollbacks \/= 2;\n-            exec->status = XML_REGEXP_OUT_OF_MEMORY;\n-        return;\n-    }\n-    exec->rollbacks = tmp;\n-    tmp = &exec->rollbacks[len];\n-    memset(tmp, 0, (exec->maxRollbacks - len) * sizeof(xmlRegExecRollback));\n-    }\n-    exec->rollbacks[exec->nbRollbacks].state = exec->state;\n-    exec->rollbacks[exec->nbRollbacks].index = exec->index;\n-    exec->rollbacks[exec->nbRollbacks].nextbranch = exec->transno + 1;\n-    if (exec->comp->nbCounters > 0) {\n-    if (exec->rollbacks[exec->nbRollbacks].counts == NULL) {\n-        exec->rollbacks[exec->nbRollbacks].counts = (int *)\n-        xmlMalloc(exec->comp->nbCounters * sizeof(int));\n-        if (exec->rollbacks[exec->nbRollbacks].counts == NULL) {\n-        exec->status = XML_REGEXP_OUT_OF_MEMORY;\n-        return;\n-        }\n-    }\n-    memcpy(exec->rollbacks[exec->nbRollbacks].counts, exec->counts,\n-           exec->comp->nbCounters * sizeof(int));\n-    }\n-    exec->nbRollbacks++;\n-}\n-\n-static void\n-xmlFARegExecRollBack(xmlRegExecCtxtPtr exec) {\n-    if (exec->status != XML_REGEXP_OK)\n-        return;\n-    if (exec->nbRollbacks <= 0) {\n-    exec->status = XML_REGEXP_NOT_FOUND;\n-    return;\n-    }\n-    exec->nbRollbacks--;\n-    exec->state = exec->rollbacks[exec->nbRollbacks].state;\n-    exec->index = exec->rollbacks[exec->nbRollbacks].index;\n-    exec->transno = exec->rollbacks[exec->nbRollbacks].nextbranch;\n-    if (exec->comp->nbCounters > 0) {\n-    if (exec->rollbacks[exec->nbRollbacks].counts == NULL) {\n-        fprintf(stderr, \"exec save: allocation failed\");\n-        exec->status = XML_REGEXP_INTERNAL_ERROR;\n-        return;\n-    }\n-    if (exec->counts) {\n-        memcpy(exec->counts, exec->rollbacks[exec->nbRollbacks].counts,\n-           exec->comp->nbCounters * sizeof(int));\n-    }\n-    }\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *    Verifier, running an input against a compiled regexp        *\n- *                                    *\n- ************************************************************************\/\n-\n-static int\n-xmlFARegExec(xmlRegexpPtr comp, const xmlChar *content) {\n-    xmlRegExecCtxt execval;\n-    xmlRegExecCtxtPtr exec = &execval;\n-    int ret, codepoint = 0, len, deter;\n-\n-    exec->inputString = content;\n-    exec->index = 0;\n-    exec->nbPush = 0;\n-    exec->determinist = 1;\n-    exec->maxRollbacks = 0;\n-    exec->nbRollbacks = 0;\n-    exec->rollbacks = NULL;\n-    exec->status = XML_REGEXP_OK;\n-    exec->comp = comp;\n-    exec->state = comp->states[0];\n-    exec->transno = 0;\n-    exec->transcount = 0;\n-    exec->inputStack = NULL;\n-    exec->inputStackMax = 0;\n-    if (comp->nbCounters > 0) {\n-    exec->counts = (int *) xmlMalloc(comp->nbCounters * sizeof(int));\n-    if (exec->counts == NULL) {\n-        return(XML_REGEXP_OUT_OF_MEMORY);\n-    }\n-        memset(exec->counts, 0, comp->nbCounters * sizeof(int));\n-    } else\n-    exec->counts = NULL;\n-    while ((exec->status == XML_REGEXP_OK) && (exec->state != NULL) &&\n-       ((exec->inputString[exec->index] != 0) ||\n-        ((exec->state != NULL) &&\n-         (exec->state->type != XML_REGEXP_FINAL_STATE)))) {\n-    xmlRegTransPtr trans;\n-    xmlRegAtomPtr atom;\n-\n-    \/*\n-     * If end of input on non-terminal state, rollback, however we may\n-     * still have epsilon like transition for counted transitions\n-     * on counters, in that case don't break too early.  Additionally,\n-     * if we are working on a range like \"AB{0,2}\", where B is not present,\n-     * we don't want to break.\n-     *\/\n-    len = 1;\n-    if ((exec->inputString[exec->index] == 0) && (exec->counts == NULL)) {\n-        \/*\n-         * if there is a transition, we must check if\n-         *  atom allows minOccurs of 0\n-         *\/\n-        if (exec->transno < exec->state->nbTrans) {\n-            trans = &exec->state->trans[exec->transno];\n-        if (trans->to >=0) {\n-            atom = trans->atom;\n-            if (!((atom->min == 0) && (atom->max > 0)))\n-                goto rollback;\n-        }\n-        } else\n-            goto rollback;\n-    }\n-\n-    exec->transcount = 0;\n-    for (;exec->transno < exec->state->nbTrans;exec->transno++) {\n-        trans = &exec->state->trans[exec->transno];\n-        if (trans->to < 0)\n-        continue;\n-        atom = trans->atom;\n-        ret = 0;\n-        deter = 1;\n-        if (trans->count >= 0) {\n-        int count;\n-        xmlRegCounterPtr counter;\n-\n-        if (exec->counts == NULL) {\n-            exec->status = XML_REGEXP_INTERNAL_ERROR;\n-            goto error;\n-        }\n-        \/*\n-         * A counted transition.\n-         *\/\n-\n-        count = exec->counts[trans->count];\n-        counter = &exec->comp->counters[trans->count];\n-        ret = ((count >= counter->min) && (count <= counter->max));\n-        if ((ret) && (counter->min != counter->max))\n-            deter = 0;\n-        } else if (atom == NULL) {\n-        fprintf(stderr, \"epsilon transition left at runtime\\n\");\n-        exec->status = XML_REGEXP_INTERNAL_ERROR;\n-        break;\n-        } else if (exec->inputString[exec->index] != 0) {\n-                len = 4;\n-                codepoint = xmlGetUTF8Char(&exec->inputString[exec->index],\n-                                           &len);\n-                if (codepoint < 0) {\n-                    exec->status = XML_REGEXP_INVALID_UTF8;\n-                    goto error;\n-                }\n-        ret = xmlRegCheckCharacter(atom, codepoint);\n-        if ((ret == 1) && (atom->min >= 0) && (atom->max > 0)) {\n-            xmlRegStatePtr to = comp->states[trans->to];\n-\n-            \/*\n-             * this is a multiple input sequence\n-             * If there is a counter associated increment it now.\n-             * do not increment if the counter is already over the\n-             * maximum limit in which case get to next transition\n-             *\/\n-            if (trans->counter >= 0) {\n-            xmlRegCounterPtr counter;\n-\n-            if ((exec->counts == NULL) ||\n-                (exec->comp == NULL) ||\n-                (exec->comp->counters == NULL)) {\n-                exec->status = XML_REGEXP_INTERNAL_ERROR;\n-                goto error;\n-            }\n-            counter = &exec->comp->counters[trans->counter];\n-            if (exec->counts[trans->counter] >= counter->max)\n-                continue; \/* for loop on transitions *\/\n-                    }\n-                    \/* Save before incrementing *\/\n-            if (exec->state->nbTrans > exec->transno + 1) {\n-            xmlFARegExecSave(exec);\n-                        if (exec->status != XML_REGEXP_OK)\n-                            goto error;\n-            }\n-            if (trans->counter >= 0) {\n-            exec->counts[trans->counter]++;\n-            }\n-            exec->transcount = 1;\n-            do {\n-            \/*\n-             * Try to progress as much as possible on the input\n-             *\/\n-            if (exec->transcount == atom->max) {\n-                break;\n-            }\n-            exec->index += len;\n-            \/*\n-             * End of input: stop here\n-             *\/\n-            if (exec->inputString[exec->index] == 0) {\n-                exec->index -= len;\n-                break;\n-            }\n-            if (exec->transcount >= atom->min) {\n-                int transno = exec->transno;\n-                xmlRegStatePtr state = exec->state;\n-\n-                \/*\n-                 * The transition is acceptable save it\n-                 *\/\n-                exec->transno = -1; \/* trick *\/\n-                exec->state = to;\n-                xmlFARegExecSave(exec);\n-                            if (exec->status != XML_REGEXP_OK)\n-                                goto error;\n-                exec->transno = transno;\n-                exec->state = state;\n-            }\n-                        len = 4;\n-                        codepoint = xmlGetUTF8Char(\n-                                &exec->inputString[exec->index], &len);\n-                        if (codepoint < 0) {\n-                            exec->status = XML_REGEXP_INVALID_UTF8;\n-                            goto error;\n-                        }\n-            ret = xmlRegCheckCharacter(atom, codepoint);\n-            exec->transcount++;\n-            } while (ret == 1);\n-            if (exec->transcount < atom->min)\n-            ret = 0;\n-\n-            \/*\n-             * If the last check failed but one transition was found\n-             * possible, rollback\n-             *\/\n-            if (ret < 0)\n-            ret = 0;\n-            if (ret == 0) {\n-            goto rollback;\n-            }\n-            if (trans->counter >= 0) {\n-            if (exec->counts == NULL) {\n-                exec->status = XML_REGEXP_INTERNAL_ERROR;\n-                goto error;\n-            }\n-            exec->counts[trans->counter]--;\n-            }\n-        } else if ((ret == 0) && (atom->min == 0) && (atom->max > 0)) {\n-            \/*\n-             * we don't match on the codepoint, but minOccurs of 0\n-             * says that's ok.  Setting len to 0 inhibits stepping\n-             * over the codepoint.\n-             *\/\n-            exec->transcount = 1;\n-            len = 0;\n-            ret = 1;\n-        }\n-        } else if ((atom->min == 0) && (atom->max > 0)) {\n-            \/* another spot to match when minOccurs is 0 *\/\n-        exec->transcount = 1;\n-        len = 0;\n-        ret = 1;\n-        }\n-        if (ret == 1) {\n-        if ((trans->nd == 1) ||\n-            ((trans->count >= 0) && (deter == 0) &&\n-             (exec->state->nbTrans > exec->transno + 1))) {\n-            xmlFARegExecSave(exec);\n-                    if (exec->status != XML_REGEXP_OK)\n-                        goto error;\n-        }\n-        if (trans->counter >= 0) {\n-            xmlRegCounterPtr counter;\n-\n-                    \/* make sure we don't go over the counter maximum value *\/\n-            if ((exec->counts == NULL) ||\n-            (exec->comp == NULL) ||\n-            (exec->comp->counters == NULL)) {\n-            exec->status = XML_REGEXP_INTERNAL_ERROR;\n-            goto error;\n-            }\n-            counter = &exec->comp->counters[trans->counter];\n-            if (exec->counts[trans->counter] >= counter->max)\n-            continue; \/* for loop on transitions *\/\n-            exec->counts[trans->counter]++;\n-        }\n-        if ((trans->count >= 0) &&\n-            (trans->count < REGEXP_ALL_COUNTER)) {\n-            if (exec->counts == NULL) {\n-                exec->status = XML_REGEXP_INTERNAL_ERROR;\n-            goto error;\n-            }\n-            exec->counts[trans->count] = 0;\n-        }\n-        exec->state = comp->states[trans->to];\n-        exec->transno = 0;\n-        if (trans->atom != NULL) {\n-            exec->index += len;\n-        }\n-        goto progress;\n-        } else if (ret < 0) {\n-        exec->status = XML_REGEXP_INTERNAL_ERROR;\n-        break;\n-        }\n-    }\n-    if ((exec->transno != 0) || (exec->state->nbTrans == 0)) {\n-rollback:\n-        \/*\n-         * Failed to find a way out\n-         *\/\n-        exec->determinist = 0;\n-        xmlFARegExecRollBack(exec);\n-    }\n-progress:\n-    continue;\n-    }\n-error:\n-    if (exec->rollbacks != NULL) {\n-    if (exec->counts != NULL) {\n-        int i;\n-\n-        for (i = 0;i < exec->maxRollbacks;i++)\n-        if (exec->rollbacks[i].counts != NULL)\n-            xmlFree(exec->rollbacks[i].counts);\n-    }\n-    xmlFree(exec->rollbacks);\n-    }\n-    if (exec->state == NULL)\n-        return(XML_REGEXP_INTERNAL_ERROR);\n-    if (exec->counts != NULL)\n-    xmlFree(exec->counts);\n-    if (exec->status == XML_REGEXP_OK)\n-    return(1);\n-    if (exec->status == XML_REGEXP_NOT_FOUND)\n-    return(0);\n-    return(exec->status);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *    Progressive interface to the verifier one atom at a time    *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlRegNewExecCtxt:\n- * @comp: a precompiled regular expression\n- * @callback: a callback function used for handling progresses in the\n- *            automata matching phase\n- * @data: the context data associated to the callback in this context\n- *\n- * Build a context used for progressive evaluation of a regexp.\n- *\n- * Returns the new context\n- *\/\n-xmlRegExecCtxtPtr\n-xmlRegNewExecCtxt(xmlRegexpPtr comp, xmlRegExecCallbacks callback, void *data) {\n-    xmlRegExecCtxtPtr exec;\n-\n-    if (comp == NULL)\n-    return(NULL);\n-    if ((comp->compact == NULL) && (comp->states == NULL))\n-        return(NULL);\n-    exec = (xmlRegExecCtxtPtr) xmlMalloc(sizeof(xmlRegExecCtxt));\n-    if (exec == NULL)\n-    return(NULL);\n-    memset(exec, 0, sizeof(xmlRegExecCtxt));\n-    exec->inputString = NULL;\n-    exec->index = 0;\n-    exec->determinist = 1;\n-    exec->maxRollbacks = 0;\n-    exec->nbRollbacks = 0;\n-    exec->rollbacks = NULL;\n-    exec->status = XML_REGEXP_OK;\n-    exec->comp = comp;\n-    if (comp->compact == NULL)\n-    exec->state = comp->states[0];\n-    exec->transno = 0;\n-    exec->transcount = 0;\n-    exec->callback = callback;\n-    exec->data = data;\n-    if (comp->nbCounters > 0) {\n-        \/*\n-     * For error handling, exec->counts is allocated twice the size\n-     * the second half is used to store the data in case of rollback\n-     *\/\n-    exec->counts = (int *) xmlMalloc(comp->nbCounters * sizeof(int)\n-                                     * 2);\n-    if (exec->counts == NULL) {\n-        xmlFree(exec);\n-        return(NULL);\n-    }\n-        memset(exec->counts, 0, comp->nbCounters * sizeof(int) * 2);\n-    exec->errCounts = &exec->counts[comp->nbCounters];\n-    } else {\n-    exec->counts = NULL;\n-    exec->errCounts = NULL;\n-    }\n-    exec->inputStackMax = 0;\n-    exec->inputStackNr = 0;\n-    exec->inputStack = NULL;\n-    exec->errStateNo = -1;\n-    exec->errString = NULL;\n-    exec->nbPush = 0;\n-    return(exec);\n-}\n-\n-\/**\n- * xmlRegFreeExecCtxt:\n- * @exec: a regular expression evaluation context\n- *\n- * Free the structures associated to a regular expression evaluation context.\n- *\/\n-void\n-xmlRegFreeExecCtxt(xmlRegExecCtxtPtr exec) {\n-    if (exec == NULL)\n-    return;\n-\n-    if (exec->rollbacks != NULL) {\n-    if (exec->counts != NULL) {\n-        int i;\n-\n-        for (i = 0;i < exec->maxRollbacks;i++)\n-        if (exec->rollbacks[i].counts != NULL)\n-            xmlFree(exec->rollbacks[i].counts);\n-    }\n-    xmlFree(exec->rollbacks);\n-    }\n-    if (exec->counts != NULL)\n-    xmlFree(exec->counts);\n-    if (exec->inputStack != NULL) {\n-    int i;\n-\n-    for (i = 0;i < exec->inputStackNr;i++) {\n-        if (exec->inputStack[i].value != NULL)\n-        xmlFree(exec->inputStack[i].value);\n-    }\n-    xmlFree(exec->inputStack);\n-    }\n-    if (exec->errString != NULL)\n-        xmlFree(exec->errString);\n-    xmlFree(exec);\n-}\n-\n-static int\n-xmlRegExecSetErrString(xmlRegExecCtxtPtr exec, const xmlChar *value) {\n-    if (exec->errString != NULL)\n-        xmlFree(exec->errString);\n-    if (value == NULL) {\n-        exec->errString = NULL;\n-    } else {\n-        exec->errString = xmlStrdup(value);\n-        if (exec->errString == NULL) {\n-            exec->status = XML_REGEXP_OUT_OF_MEMORY;\n-            return(-1);\n-        }\n-    }\n-    return(0);\n-}\n-\n-static void\n-xmlFARegExecSaveInputString(xmlRegExecCtxtPtr exec, const xmlChar *value,\n-                        void *data) {\n-    if (exec->inputStackMax == 0) {\n-    exec->inputStackMax = 4;\n-    exec->inputStack = (xmlRegInputTokenPtr)\n-        xmlMalloc(exec->inputStackMax * sizeof(xmlRegInputToken));\n-    if (exec->inputStack == NULL) {\n-        exec->inputStackMax = 0;\n-            exec->status = XML_REGEXP_OUT_OF_MEMORY;\n-        return;\n-    }\n-    } else if (exec->inputStackNr + 1 >= exec->inputStackMax) {\n-    xmlRegInputTokenPtr tmp;\n-\n-    exec->inputStackMax *= 2;\n-    tmp = (xmlRegInputTokenPtr) xmlRealloc(exec->inputStack,\n-            exec->inputStackMax * sizeof(xmlRegInputToken));\n-    if (tmp == NULL) {\n-        exec->inputStackMax \/= 2;\n-            exec->status = XML_REGEXP_OUT_OF_MEMORY;\n-        return;\n-    }\n-    exec->inputStack = tmp;\n-    }\n-    if (value == NULL) {\n-        exec->inputStack[exec->inputStackNr].value = NULL;\n-    } else {\n-        exec->inputStack[exec->inputStackNr].value = xmlStrdup(value);\n-        if (exec->inputStack[exec->inputStackNr].value == NULL) {\n-            exec->status = XML_REGEXP_OUT_OF_MEMORY;\n-            return;\n-        }\n-    }\n-    exec->inputStack[exec->inputStackNr].data = data;\n-    exec->inputStackNr++;\n-    exec->inputStack[exec->inputStackNr].value = NULL;\n-    exec->inputStack[exec->inputStackNr].data = NULL;\n-}\n-\n-\/**\n- * xmlRegStrEqualWildcard:\n- * @expStr:  the string to be evaluated\n- * @valStr:  the validation string\n- *\n- * Checks if both strings are equal or have the same content. \"*\"\n- * can be used as a wildcard in @valStr; \"|\" is used as a separator of\n- * substrings in both @expStr and @valStr.\n- *\n- * Returns 1 if the comparison is satisfied and the number of substrings\n- * is equal, 0 otherwise.\n- *\/\n-\n-static int\n-xmlRegStrEqualWildcard(const xmlChar *expStr, const xmlChar *valStr) {\n-    if (expStr == valStr) return(1);\n-    if (expStr == NULL) return(0);\n-    if (valStr == NULL) return(0);\n-    do {\n-    \/*\n-    * Eval if we have a wildcard for the current item.\n-    *\/\n-        if (*expStr != *valStr) {\n-        \/* if one of them starts with a wildcard make valStr be it *\/\n-        if (*valStr == '*') {\n-            const xmlChar *tmp;\n-\n-        tmp = valStr;\n-        valStr = expStr;\n-        expStr = tmp;\n-        }\n-        if ((*valStr != 0) && (*expStr != 0) && (*expStr++ == '*')) {\n-        do {\n-            if (*valStr == XML_REG_STRING_SEPARATOR)\n-            break;\n-            valStr++;\n-        } while (*valStr != 0);\n-        continue;\n-        } else\n-        return(0);\n-    }\n-    expStr++;\n-    valStr++;\n-    } while (*valStr != 0);\n-    if (*expStr != 0)\n-    return (0);\n-    else\n-    return (1);\n-}\n-\n-\/**\n- * xmlRegCompactPushString:\n- * @exec: a regexp execution context\n- * @comp:  the precompiled exec with a compact table\n- * @value: a string token input\n- * @data: data associated to the token to reuse in callbacks\n- *\n- * Push one input token in the execution context\n- *\n- * Returns: 1 if the regexp reached a final state, 0 if non-final, and\n- *     a negative value in case of error.\n- *\/\n-static int\n-xmlRegCompactPushString(xmlRegExecCtxtPtr exec,\n-                    xmlRegexpPtr comp,\n-                    const xmlChar *value,\n-                    void *data) {\n-    int state = exec->index;\n-    int i, target;\n-\n-    if ((comp == NULL) || (comp->compact == NULL) || (comp->stringMap == NULL))\n-    return(-1);\n-\n-    if (value == NULL) {\n-    \/*\n-     * are we at a final state ?\n-     *\/\n-    if (comp->compact[state * (comp->nbstrings + 1)] ==\n-            XML_REGEXP_FINAL_STATE)\n-        return(1);\n-    return(0);\n-    }\n-\n-    \/*\n-     * Examine all outside transitions from current state\n-     *\/\n-    for (i = 0;i < comp->nbstrings;i++) {\n-    target = comp->compact[state * (comp->nbstrings + 1) + i + 1];\n-    if ((target > 0) && (target <= comp->nbstates)) {\n-        target--; \/* to avoid 0 *\/\n-        if (xmlRegStrEqualWildcard(comp->stringMap[i], value)) {\n-        exec->index = target;\n-        if ((exec->callback != NULL) && (comp->transdata != NULL)) {\n-            exec->callback(exec->data, value,\n-              comp->transdata[state * comp->nbstrings + i], data);\n-        }\n-        if (comp->compact[target * (comp->nbstrings + 1)] ==\n-            XML_REGEXP_SINK_STATE)\n-            goto error;\n-\n-        if (comp->compact[target * (comp->nbstrings + 1)] ==\n-            XML_REGEXP_FINAL_STATE)\n-            return(1);\n-        return(0);\n-        }\n-    }\n-    }\n-    \/*\n-     * Failed to find an exit transition out from current state for the\n-     * current token\n-     *\/\n-error:\n-    exec->errStateNo = state;\n-    exec->status = XML_REGEXP_NOT_FOUND;\n-    xmlRegExecSetErrString(exec, value);\n-    return(exec->status);\n-}\n-\n-\/**\n- * xmlRegExecPushStringInternal:\n- * @exec: a regexp execution context or NULL to indicate the end\n- * @value: a string token input\n- * @data: data associated to the token to reuse in callbacks\n- * @compound: value was assembled from 2 strings\n- *\n- * Push one input token in the execution context\n- *\n- * Returns: 1 if the regexp reached a final state, 0 if non-final, and\n- *     a negative value in case of error.\n- *\/\n-static int\n-xmlRegExecPushStringInternal(xmlRegExecCtxtPtr exec, const xmlChar *value,\n-                         void *data, int compound) {\n-    xmlRegTransPtr trans;\n-    xmlRegAtomPtr atom;\n-    int ret;\n-    int final = 0;\n-    int progress = 1;\n-\n-    if (exec == NULL)\n-    return(-1);\n-    if (exec->comp == NULL)\n-    return(-1);\n-    if (exec->status != XML_REGEXP_OK)\n-    return(exec->status);\n-\n-    if (exec->comp->compact != NULL)\n-    return(xmlRegCompactPushString(exec, exec->comp, value, data));\n-\n-    if (value == NULL) {\n-        if (exec->state->type == XML_REGEXP_FINAL_STATE)\n-        return(1);\n-    final = 1;\n-    }\n-\n-    \/*\n-     * If we have an active rollback stack push the new value there\n-     * and get back to where we were left\n-     *\/\n-    if ((value != NULL) && (exec->inputStackNr > 0)) {\n-    xmlFARegExecSaveInputString(exec, value, data);\n-    value = exec->inputStack[exec->index].value;\n-    data = exec->inputStack[exec->index].data;\n-    }\n-\n-    while ((exec->status == XML_REGEXP_OK) &&\n-       ((value != NULL) ||\n-        ((final == 1) &&\n-         (exec->state->type != XML_REGEXP_FINAL_STATE)))) {\n-\n-    \/*\n-     * End of input on non-terminal state, rollback, however we may\n-     * still have epsilon like transition for counted transitions\n-     * on counters, in that case don't break too early.\n-     *\/\n-    if ((value == NULL) && (exec->counts == NULL))\n-        goto rollback;\n-\n-    exec->transcount = 0;\n-    for (;exec->transno < exec->state->nbTrans;exec->transno++) {\n-        trans = &exec->state->trans[exec->transno];\n-        if (trans->to < 0)\n-        continue;\n-        atom = trans->atom;\n-        ret = 0;\n-        if (trans->count == REGEXP_ALL_LAX_COUNTER) {\n-        int i;\n-        int count;\n-        xmlRegTransPtr t;\n-        xmlRegCounterPtr counter;\n-\n-        ret = 0;\n-\n-        \/*\n-         * Check all counted transitions from the current state\n-         *\/\n-        if ((value == NULL) && (final)) {\n-            ret = 1;\n-        } else if (value != NULL) {\n-            for (i = 0;i < exec->state->nbTrans;i++) {\n-            t = &exec->state->trans[i];\n-            if ((t->counter < 0) || (t == trans))\n-                continue;\n-            counter = &exec->comp->counters[t->counter];\n-            count = exec->counts[t->counter];\n-            if ((count < counter->max) &&\n-                    (t->atom != NULL) &&\n-                (xmlStrEqual(value, t->atom->valuep))) {\n-                ret = 0;\n-                break;\n-            }\n-            if ((count >= counter->min) &&\n-                (count < counter->max) &&\n-                (t->atom != NULL) &&\n-                (xmlStrEqual(value, t->atom->valuep))) {\n-                ret = 1;\n-                break;\n-            }\n-            }\n-        }\n-        } else if (trans->count == REGEXP_ALL_COUNTER) {\n-        int i;\n-        int count;\n-        xmlRegTransPtr t;\n-        xmlRegCounterPtr counter;\n-\n-        ret = 1;\n-\n-        \/*\n-         * Check all counted transitions from the current state\n-         *\/\n-        for (i = 0;i < exec->state->nbTrans;i++) {\n-                    t = &exec->state->trans[i];\n-            if ((t->counter < 0) || (t == trans))\n-            continue;\n-                    counter = &exec->comp->counters[t->counter];\n-            count = exec->counts[t->counter];\n-            if ((count < counter->min) || (count > counter->max)) {\n-            ret = 0;\n-            break;\n-            }\n-        }\n-        } else if (trans->count >= 0) {\n-        int count;\n-        xmlRegCounterPtr counter;\n-\n-        \/*\n-         * A counted transition.\n-         *\/\n-\n-        count = exec->counts[trans->count];\n-        counter = &exec->comp->counters[trans->count];\n-        ret = ((count >= counter->min) && (count <= counter->max));\n-        } else if (atom == NULL) {\n-        fprintf(stderr, \"epsilon transition left at runtime\\n\");\n-        exec->status = XML_REGEXP_INTERNAL_ERROR;\n-        break;\n-        } else if (value != NULL) {\n-        ret = xmlRegStrEqualWildcard(atom->valuep, value);\n-        if (atom->neg) {\n-            ret = !ret;\n-            if (!compound)\n-                ret = 0;\n-        }\n-        if ((ret == 1) && (trans->counter >= 0)) {\n-            xmlRegCounterPtr counter;\n-            int count;\n-\n-            count = exec->counts[trans->counter];\n-            counter = &exec->comp->counters[trans->counter];\n-            if (count >= counter->max)\n-            ret = 0;\n-        }\n-\n-        if ((ret == 1) && (atom->min > 0) && (atom->max > 0)) {\n-            xmlRegStatePtr to = exec->comp->states[trans->to];\n-\n-            \/*\n-             * this is a multiple input sequence\n-             *\/\n-            if (exec->state->nbTrans > exec->transno + 1) {\n-            if (exec->inputStackNr <= 0) {\n-                xmlFARegExecSaveInputString(exec, value, data);\n-            }\n-            xmlFARegExecSave(exec);\n-            }\n-            exec->transcount = 1;\n-            do {\n-            \/*\n-             * Try to progress as much as possible on the input\n-             *\/\n-            if (exec->transcount == atom->max) {\n-                break;\n-            }\n-            exec->index++;\n-            value = exec->inputStack[exec->index].value;\n-            data = exec->inputStack[exec->index].data;\n-\n-            \/*\n-             * End of input: stop here\n-             *\/\n-            if (value == NULL) {\n-                exec->index --;\n-                break;\n-            }\n-            if (exec->transcount >= atom->min) {\n-                int transno = exec->transno;\n-                xmlRegStatePtr state = exec->state;\n-\n-                \/*\n-                 * The transition is acceptable save it\n-                 *\/\n-                exec->transno = -1; \/* trick *\/\n-                exec->state = to;\n-                if (exec->inputStackNr <= 0) {\n-                xmlFARegExecSaveInputString(exec, value, data);\n-                }\n-                xmlFARegExecSave(exec);\n-                exec->transno = transno;\n-                exec->state = state;\n-            }\n-            ret = xmlStrEqual(value, atom->valuep);\n-            exec->transcount++;\n-            } while (ret == 1);\n-            if (exec->transcount < atom->min)\n-            ret = 0;\n-\n-            \/*\n-             * If the last check failed but one transition was found\n-             * possible, rollback\n-             *\/\n-            if (ret < 0)\n-            ret = 0;\n-            if (ret == 0) {\n-            goto rollback;\n-            }\n-        }\n-        }\n-        if (ret == 1) {\n-        if ((exec->callback != NULL) && (atom != NULL) &&\n-            (data != NULL)) {\n-            exec->callback(exec->data, atom->valuep,\n-                       atom->data, data);\n-        }\n-        if (exec->state->nbTrans > exec->transno + 1) {\n-            if (exec->inputStackNr <= 0) {\n-            xmlFARegExecSaveInputString(exec, value, data);\n-            }\n-            xmlFARegExecSave(exec);\n-        }\n-        if (trans->counter >= 0) {\n-            exec->counts[trans->counter]++;\n-        }\n-        if ((trans->count >= 0) &&\n-            (trans->count < REGEXP_ALL_COUNTER)) {\n-            exec->counts[trans->count] = 0;\n-        }\n-                if ((exec->comp->states[trans->to] != NULL) &&\n-            (exec->comp->states[trans->to]->type ==\n-             XML_REGEXP_SINK_STATE)) {\n-            \/*\n-             * entering a sink state, save the current state as error\n-             * state.\n-             *\/\n-                    if (xmlRegExecSetErrString(exec, value) < 0)\n-                        break;\n-            exec->errState = exec->state;\n-            memcpy(exec->errCounts, exec->counts,\n-               exec->comp->nbCounters * sizeof(int));\n-        }\n-        exec->state = exec->comp->states[trans->to];\n-        exec->transno = 0;\n-        if (trans->atom != NULL) {\n-            if (exec->inputStack != NULL) {\n-            exec->index++;\n-            if (exec->index < exec->inputStackNr) {\n-                value = exec->inputStack[exec->index].value;\n-                data = exec->inputStack[exec->index].data;\n-            } else {\n-                value = NULL;\n-                data = NULL;\n-            }\n-            } else {\n-            value = NULL;\n-            data = NULL;\n-            }\n-        }\n-        goto progress;\n-        } else if (ret < 0) {\n-        exec->status = XML_REGEXP_INTERNAL_ERROR;\n-        break;\n-        }\n-    }\n-    if ((exec->transno != 0) || (exec->state->nbTrans == 0)) {\n-rollback:\n-            \/*\n-         * if we didn't yet rollback on the current input\n-         * store the current state as the error state.\n-         *\/\n-        if ((progress) && (exec->state != NULL) &&\n-            (exec->state->type != XML_REGEXP_SINK_STATE)) {\n-            progress = 0;\n-                if (xmlRegExecSetErrString(exec, value) < 0)\n-                    break;\n-        exec->errState = exec->state;\n-                if (exec->comp->nbCounters)\n-                    memcpy(exec->errCounts, exec->counts,\n-                           exec->comp->nbCounters * sizeof(int));\n-        }\n-\n-        \/*\n-         * Failed to find a way out\n-         *\/\n-        exec->determinist = 0;\n-        xmlFARegExecRollBack(exec);\n-        if ((exec->inputStack != NULL ) &&\n-                (exec->status == XML_REGEXP_OK)) {\n-        value = exec->inputStack[exec->index].value;\n-        data = exec->inputStack[exec->index].data;\n-        }\n-    }\n-    continue;\n-progress:\n-        progress = 1;\n-    continue;\n-    }\n-    if (exec->status == XML_REGEXP_OK) {\n-        return(exec->state->type == XML_REGEXP_FINAL_STATE);\n-    }\n-    return(exec->status);\n-}\n-\n-\/**\n- * xmlRegExecPushString:\n- * @exec: a regexp execution context or NULL to indicate the end\n- * @value: a string token input\n- * @data: data associated to the token to reuse in callbacks\n- *\n- * Push one input token in the execution context\n- *\n- * Returns: 1 if the regexp reached a final state, 0 if non-final, and\n- *     a negative value in case of error.\n- *\/\n-int\n-xmlRegExecPushString(xmlRegExecCtxtPtr exec, const xmlChar *value,\n-                 void *data) {\n-    return(xmlRegExecPushStringInternal(exec, value, data, 0));\n-}\n-\n-\/**\n- * xmlRegExecPushString2:\n- * @exec: a regexp execution context or NULL to indicate the end\n- * @value: the first string token input\n- * @value2: the second string token input\n- * @data: data associated to the token to reuse in callbacks\n- *\n- * Push one input token in the execution context\n- *\n- * Returns: 1 if the regexp reached a final state, 0 if non-final, and\n- *     a negative value in case of error.\n- *\/\n-int\n-xmlRegExecPushString2(xmlRegExecCtxtPtr exec, const xmlChar *value,\n-                      const xmlChar *value2, void *data) {\n-    xmlChar buf[150];\n-    int lenn, lenp, ret;\n-    xmlChar *str;\n-\n-    if (exec == NULL)\n-    return(-1);\n-    if (exec->comp == NULL)\n-    return(-1);\n-    if (exec->status != XML_REGEXP_OK)\n-    return(exec->status);\n-\n-    if (value2 == NULL)\n-        return(xmlRegExecPushString(exec, value, data));\n-\n-    lenn = strlen((char *) value2);\n-    lenp = strlen((char *) value);\n-\n-    if (150 < lenn + lenp + 2) {\n-    str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);\n-    if (str == NULL) {\n-        exec->status = XML_REGEXP_OUT_OF_MEMORY;\n-        return(-1);\n-    }\n-    } else {\n-    str = buf;\n-    }\n-    memcpy(&str[0], value, lenp);\n-    str[lenp] = XML_REG_STRING_SEPARATOR;\n-    memcpy(&str[lenp + 1], value2, lenn);\n-    str[lenn + lenp + 1] = 0;\n-\n-    if (exec->comp->compact != NULL)\n-    ret = xmlRegCompactPushString(exec, exec->comp, str, data);\n-    else\n-        ret = xmlRegExecPushStringInternal(exec, str, data, 1);\n-\n-    if (str != buf)\n-        xmlFree(str);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlRegExecGetValues:\n- * @exec: a regexp execution context\n- * @err: error extraction or normal one\n- * @nbval: pointer to the number of accepted values IN\/OUT\n- * @nbneg: return number of negative transitions\n- * @values: pointer to the array of acceptable values\n- * @terminal: return value if this was a terminal state\n- *\n- * Extract information from the regexp execution, internal routine to\n- * implement xmlRegExecNextValues() and xmlRegExecErrInfo()\n- *\n- * Returns: 0 in case of success or -1 in case of error.\n- *\/\n-static int\n-xmlRegExecGetValues(xmlRegExecCtxtPtr exec, int err,\n-                    int *nbval, int *nbneg,\n-            xmlChar **values, int *terminal) {\n-    int maxval;\n-    int nb = 0;\n-\n-    if ((exec == NULL) || (nbval == NULL) || (nbneg == NULL) ||\n-        (values == NULL) || (*nbval <= 0))\n-        return(-1);\n-\n-    maxval = *nbval;\n-    *nbval = 0;\n-    *nbneg = 0;\n-    if ((exec->comp != NULL) && (exec->comp->compact != NULL)) {\n-        xmlRegexpPtr comp;\n-    int target, i, state;\n-\n-        comp = exec->comp;\n-\n-    if (err) {\n-        if (exec->errStateNo == -1) return(-1);\n-        state = exec->errStateNo;\n-    } else {\n-        state = exec->index;\n-    }\n-    if (terminal != NULL) {\n-        if (comp->compact[state * (comp->nbstrings + 1)] ==\n-            XML_REGEXP_FINAL_STATE)\n-        *terminal = 1;\n-        else\n-        *terminal = 0;\n-    }\n-    for (i = 0;(i < comp->nbstrings) && (nb < maxval);i++) {\n-        target = comp->compact[state * (comp->nbstrings + 1) + i + 1];\n-        if ((target > 0) && (target <= comp->nbstates) &&\n-            (comp->compact[(target - 1) * (comp->nbstrings + 1)] !=\n-         XML_REGEXP_SINK_STATE)) {\n-            values[nb++] = comp->stringMap[i];\n-        (*nbval)++;\n-        }\n-    }\n-    for (i = 0;(i < comp->nbstrings) && (nb < maxval);i++) {\n-        target = comp->compact[state * (comp->nbstrings + 1) + i + 1];\n-        if ((target > 0) && (target <= comp->nbstates) &&\n-            (comp->compact[(target - 1) * (comp->nbstrings + 1)] ==\n-         XML_REGEXP_SINK_STATE)) {\n-            values[nb++] = comp->stringMap[i];\n-        (*nbneg)++;\n-        }\n-    }\n-    } else {\n-        int transno;\n-    xmlRegTransPtr trans;\n-    xmlRegAtomPtr atom;\n-    xmlRegStatePtr state;\n-\n-    if (terminal != NULL) {\n-        if (exec->state->type == XML_REGEXP_FINAL_STATE)\n-        *terminal = 1;\n-        else\n-        *terminal = 0;\n-    }\n-\n-    if (err) {\n-        if (exec->errState == NULL) return(-1);\n-        state = exec->errState;\n-    } else {\n-        if (exec->state == NULL) return(-1);\n-        state = exec->state;\n-    }\n-    for (transno = 0;\n-         (transno < state->nbTrans) && (nb < maxval);\n-         transno++) {\n-        trans = &state->trans[transno];\n-        if (trans->to < 0)\n-        continue;\n-        atom = trans->atom;\n-        if ((atom == NULL) || (atom->valuep == NULL))\n-        continue;\n-        if (trans->count == REGEXP_ALL_LAX_COUNTER) {\n-            \/* this should not be reached but ... *\/\n-        } else if (trans->count == REGEXP_ALL_COUNTER) {\n-            \/* this should not be reached but ... *\/\n-        } else if (trans->counter >= 0) {\n-        xmlRegCounterPtr counter = NULL;\n-        int count;\n-\n-        if (err)\n-            count = exec->errCounts[trans->counter];\n-        else\n-            count = exec->counts[trans->counter];\n-        if (exec->comp != NULL)\n-            counter = &exec->comp->counters[trans->counter];\n-        if ((counter == NULL) || (count < counter->max)) {\n-            if (atom->neg)\n-            values[nb++] = (xmlChar *) atom->valuep2;\n-            else\n-            values[nb++] = (xmlChar *) atom->valuep;\n-            (*nbval)++;\n-        }\n-        } else {\n-                if ((exec->comp != NULL) && (exec->comp->states[trans->to] != NULL) &&\n-            (exec->comp->states[trans->to]->type !=\n-             XML_REGEXP_SINK_STATE)) {\n-            if (atom->neg)\n-            values[nb++] = (xmlChar *) atom->valuep2;\n-            else\n-            values[nb++] = (xmlChar *) atom->valuep;\n-            (*nbval)++;\n-        }\n-        }\n-    }\n-    for (transno = 0;\n-         (transno < state->nbTrans) && (nb < maxval);\n-         transno++) {\n-        trans = &state->trans[transno];\n-        if (trans->to < 0)\n-        continue;\n-        atom = trans->atom;\n-        if ((atom == NULL) || (atom->valuep == NULL))\n-        continue;\n-        if (trans->count == REGEXP_ALL_LAX_COUNTER) {\n-            continue;\n-        } else if (trans->count == REGEXP_ALL_COUNTER) {\n-            continue;\n-        } else if (trans->counter >= 0) {\n-            continue;\n-        } else {\n-                if ((exec->comp->states[trans->to] != NULL) &&\n-            (exec->comp->states[trans->to]->type ==\n-             XML_REGEXP_SINK_STATE)) {\n-            if (atom->neg)\n-            values[nb++] = (xmlChar *) atom->valuep2;\n-            else\n-            values[nb++] = (xmlChar *) atom->valuep;\n-            (*nbneg)++;\n-        }\n-        }\n-    }\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlRegExecNextValues:\n- * @exec: a regexp execution context\n- * @nbval: pointer to the number of accepted values IN\/OUT\n- * @nbneg: return number of negative transitions\n- * @values: pointer to the array of acceptable values\n- * @terminal: return value if this was a terminal state\n- *\n- * Extract information from the regexp execution,\n- * the parameter @values must point to an array of @nbval string pointers\n- * on return nbval will contain the number of possible strings in that\n- * state and the @values array will be updated with them. The string values\n- * returned will be freed with the @exec context and don't need to be\n- * deallocated.\n- *\n- * Returns: 0 in case of success or -1 in case of error.\n- *\/\n-int\n-xmlRegExecNextValues(xmlRegExecCtxtPtr exec, int *nbval, int *nbneg,\n-                     xmlChar **values, int *terminal) {\n-    return(xmlRegExecGetValues(exec, 0, nbval, nbneg, values, terminal));\n-}\n-\n-\/**\n- * xmlRegExecErrInfo:\n- * @exec: a regexp execution context generating an error\n- * @string: return value for the error string\n- * @nbval: pointer to the number of accepted values IN\/OUT\n- * @nbneg: return number of negative transitions\n- * @values: pointer to the array of acceptable values\n- * @terminal: return value if this was a terminal state\n- *\n- * Extract error information from the regexp execution, the parameter\n- * @string will be updated with the value pushed and not accepted,\n- * the parameter @values must point to an array of @nbval string pointers\n- * on return nbval will contain the number of possible strings in that\n- * state and the @values array will be updated with them. The string values\n- * returned will be freed with the @exec context and don't need to be\n- * deallocated.\n- *\n- * Returns: 0 in case of success or -1 in case of error.\n- *\/\n-int\n-xmlRegExecErrInfo(xmlRegExecCtxtPtr exec, const xmlChar **string,\n-                  int *nbval, int *nbneg, xmlChar **values, int *terminal) {\n-    if (exec == NULL)\n-        return(-1);\n-    if (string != NULL) {\n-        if (exec->status != XML_REGEXP_OK)\n-        *string = exec->errString;\n-    else\n-        *string = NULL;\n-    }\n-    return(xmlRegExecGetValues(exec, 1, nbval, nbneg, values, terminal));\n-}\n-\n-#if 0\n-static int\n-xmlRegExecPushChar(xmlRegExecCtxtPtr exec, int UCS) {\n-    xmlRegTransPtr trans;\n-    xmlRegAtomPtr atom;\n-    int ret;\n-    int codepoint, len;\n-\n-    if (exec == NULL)\n-    return(-1);\n-    if (exec->status != XML_REGEXP_OK)\n-    return(exec->status);\n-\n-    while ((exec->status == XML_REGEXP_OK) &&\n-       ((exec->inputString[exec->index] != 0) ||\n-        (exec->state->type != XML_REGEXP_FINAL_STATE))) {\n-\n-    \/*\n-     * End of input on non-terminal state, rollback, however we may\n-     * still have epsilon like transition for counted transitions\n-     * on counters, in that case don't break too early.\n-     *\/\n-    if ((exec->inputString[exec->index] == 0) && (exec->counts == NULL))\n-        goto rollback;\n-\n-    exec->transcount = 0;\n-    for (;exec->transno < exec->state->nbTrans;exec->transno++) {\n-        trans = &exec->state->trans[exec->transno];\n-        if (trans->to < 0)\n-        continue;\n-        atom = trans->atom;\n-        ret = 0;\n-        if (trans->count >= 0) {\n-        int count;\n-        xmlRegCounterPtr counter;\n-\n-        \/*\n-         * A counted transition.\n-         *\/\n-\n-        count = exec->counts[trans->count];\n-        counter = &exec->comp->counters[trans->count];\n-        ret = ((count >= counter->min) && (count <= counter->max));\n-        } else if (atom == NULL) {\n-        fprintf(stderr, \"epsilon transition left at runtime\\n\");\n-        exec->status = XML_REGEXP_INTERNAL_ERROR;\n-        break;\n-        } else if (exec->inputString[exec->index] != 0) {\n-                codepoint = CUR_SCHAR(&(exec->inputString[exec->index]), len);\n-        ret = xmlRegCheckCharacter(atom, codepoint);\n-        if ((ret == 1) && (atom->min > 0) && (atom->max > 0)) {\n-            xmlRegStatePtr to = exec->comp->states[trans->to];\n-\n-            \/*\n-             * this is a multiple input sequence\n-             *\/\n-            if (exec->state->nbTrans > exec->transno + 1) {\n-            xmlFARegExecSave(exec);\n-            }\n-            exec->transcount = 1;\n-            do {\n-            \/*\n-             * Try to progress as much as possible on the input\n-             *\/\n-            if (exec->transcount == atom->max) {\n-                break;\n-            }\n-            exec->index += len;\n-            \/*\n-             * End of input: stop here\n-             *\/\n-            if (exec->inputString[exec->index] == 0) {\n-                exec->index -= len;\n-                break;\n-            }\n-            if (exec->transcount >= atom->min) {\n-                int transno = exec->transno;\n-                xmlRegStatePtr state = exec->state;\n-\n-                \/*\n-                 * The transition is acceptable save it\n-                 *\/\n-                exec->transno = -1; \/* trick *\/\n-                exec->state = to;\n-                xmlFARegExecSave(exec);\n-                exec->transno = transno;\n-                exec->state = state;\n-            }\n-            codepoint = CUR_SCHAR(&(exec->inputString[exec->index]),\n-                              len);\n-            ret = xmlRegCheckCharacter(atom, codepoint);\n-            exec->transcount++;\n-            } while (ret == 1);\n-            if (exec->transcount < atom->min)\n-            ret = 0;\n-\n-            \/*\n-             * If the last check failed but one transition was found\n-             * possible, rollback\n-             *\/\n-            if (ret < 0)\n-            ret = 0;\n-            if (ret == 0) {\n-            goto rollback;\n-            }\n-        }\n-        }\n-        if (ret == 1) {\n-        if (exec->state->nbTrans > exec->transno + 1) {\n-            xmlFARegExecSave(exec);\n-        }\n-        \/*\n-         * restart count for expressions like this ((abc){2})*\n-         *\/\n-        if (trans->count >= 0) {\n-            exec->counts[trans->count] = 0;\n-        }\n-        if (trans->counter >= 0) {\n-            exec->counts[trans->counter]++;\n-        }\n-        exec->state = exec->comp->states[trans->to];\n-        exec->transno = 0;\n-        if (trans->atom != NULL) {\n-            exec->index += len;\n-        }\n-        goto progress;\n-        } else if (ret < 0) {\n-        exec->status = XML_REGEXP_INTERNAL_ERROR;\n-        break;\n-        }\n-    }\n-    if ((exec->transno != 0) || (exec->state->nbTrans == 0)) {\n-rollback:\n-        \/*\n-         * Failed to find a way out\n-         *\/\n-        exec->determinist = 0;\n-        xmlFARegExecRollBack(exec);\n-    }\n-progress:\n-    continue;\n-    }\n-}\n-#endif\n-\/************************************************************************\n- *                                    *\n- *    Parser for the Schemas Datatype Regular Expressions        *\n- *    http:\/\/www.w3.org\/TR\/2001\/REC-xmlschema-2-20010502\/#regexs    *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlFAIsChar:\n- * @ctxt:  a regexp parser context\n- *\n- * [10]   Char   ::=   [^.\\?*+()|#x5B#x5D]\n- *\/\n-static int\n-xmlFAIsChar(xmlRegParserCtxtPtr ctxt) {\n-    int cur;\n-    int len;\n-\n-    len = 4;\n-    cur = xmlGetUTF8Char(ctxt->cur, &len);\n-    if (cur < 0) {\n-        ERROR(\"Invalid UTF-8\");\n-        return(0);\n-    }\n-    if ((cur == '.') || (cur == '\\\\') || (cur == '?') ||\n-    (cur == '*') || (cur == '+') || (cur == '(') ||\n-    (cur == ')') || (cur == '|') || (cur == 0x5B) ||\n-    (cur == 0x5D) || (cur == 0))\n-    return(-1);\n-    return(cur);\n-}\n-\n-\/**\n- * xmlFAParseCharProp:\n- * @ctxt:  a regexp parser context\n- *\n- * [27]   charProp   ::=   IsCategory | IsBlock\n- * [28]   IsCategory ::= Letters | Marks | Numbers | Punctuation |\n- *                       Separators | Symbols | Others\n- * [29]   Letters   ::=   'L' [ultmo]?\n- * [30]   Marks   ::=   'M' [nce]?\n- * [31]   Numbers   ::=   'N' [dlo]?\n- * [32]   Punctuation   ::=   'P' [cdseifo]?\n- * [33]   Separators   ::=   'Z' [slp]?\n- * [34]   Symbols   ::=   'S' [mcko]?\n- * [35]   Others   ::=   'C' [cfon]?\n- * [36]   IsBlock   ::=   'Is' [a-zA-Z0-9#x2D]+\n- *\/\n-static void\n-xmlFAParseCharProp(xmlRegParserCtxtPtr ctxt) {\n-    int cur;\n-    xmlRegAtomType type = (xmlRegAtomType) 0;\n-    xmlChar *blockName = NULL;\n-\n-    cur = CUR;\n-    if (cur == 'L') {\n-    NEXT;\n-    cur = CUR;\n-    if (cur == 'u') {\n-        NEXT;\n-        type = XML_REGEXP_LETTER_UPPERCASE;\n-    } else if (cur == 'l') {\n-        NEXT;\n-        type = XML_REGEXP_LETTER_LOWERCASE;\n-    } else if (cur == 't') {\n-        NEXT;\n-        type = XML_REGEXP_LETTER_TITLECASE;\n-    } else if (cur == 'm') {\n-        NEXT;\n-        type = XML_REGEXP_LETTER_MODIFIER;\n-    } else if (cur == 'o') {\n-        NEXT;\n-        type = XML_REGEXP_LETTER_OTHERS;\n-    } else {\n-        type = XML_REGEXP_LETTER;\n-    }\n-    } else if (cur == 'M') {\n-    NEXT;\n-    cur = CUR;\n-    if (cur == 'n') {\n-        NEXT;\n-        \/* nonspacing *\/\n-        type = XML_REGEXP_MARK_NONSPACING;\n-    } else if (cur == 'c') {\n-        NEXT;\n-        \/* spacing combining *\/\n-        type = XML_REGEXP_MARK_SPACECOMBINING;\n-    } else if (cur == 'e') {\n-        NEXT;\n-        \/* enclosing *\/\n-        type = XML_REGEXP_MARK_ENCLOSING;\n-    } else {\n-        \/* all marks *\/\n-        type = XML_REGEXP_MARK;\n-    }\n-    } else if (cur == 'N') {\n-    NEXT;\n-    cur = CUR;\n-    if (cur == 'd') {\n-        NEXT;\n-        \/* digital *\/\n-        type = XML_REGEXP_NUMBER_DECIMAL;\n-    } else if (cur == 'l') {\n-        NEXT;\n-        \/* letter *\/\n-        type = XML_REGEXP_NUMBER_LETTER;\n-    } else if (cur == 'o') {\n-        NEXT;\n-        \/* other *\/\n-        type = XML_REGEXP_NUMBER_OTHERS;\n-    } else {\n-        \/* all numbers *\/\n-        type = XML_REGEXP_NUMBER;\n-    }\n-    } else if (cur == 'P') {\n-    NEXT;\n-    cur = CUR;\n-    if (cur == 'c') {\n-        NEXT;\n-        \/* connector *\/\n-        type = XML_REGEXP_PUNCT_CONNECTOR;\n-    } else if (cur == 'd') {\n-        NEXT;\n-        \/* dash *\/\n-        type = XML_REGEXP_PUNCT_DASH;\n-    } else if (cur == 's') {\n-        NEXT;\n-        \/* open *\/\n-        type = XML_REGEXP_PUNCT_OPEN;\n-    } else if (cur == 'e') {\n-        NEXT;\n-        \/* close *\/\n-        type = XML_REGEXP_PUNCT_CLOSE;\n-    } else if (cur == 'i') {\n-        NEXT;\n-        \/* initial quote *\/\n-        type = XML_REGEXP_PUNCT_INITQUOTE;\n-    } else if (cur == 'f') {\n-        NEXT;\n-        \/* final quote *\/\n-        type = XML_REGEXP_PUNCT_FINQUOTE;\n-    } else if (cur == 'o') {\n-        NEXT;\n-        \/* other *\/\n-        type = XML_REGEXP_PUNCT_OTHERS;\n-    } else {\n-        \/* all punctuation *\/\n-        type = XML_REGEXP_PUNCT;\n-    }\n-    } else if (cur == 'Z') {\n-    NEXT;\n-    cur = CUR;\n-    if (cur == 's') {\n-        NEXT;\n-        \/* space *\/\n-        type = XML_REGEXP_SEPAR_SPACE;\n-    } else if (cur == 'l') {\n-        NEXT;\n-        \/* line *\/\n-        type = XML_REGEXP_SEPAR_LINE;\n-    } else if (cur == 'p') {\n-        NEXT;\n-        \/* paragraph *\/\n-        type = XML_REGEXP_SEPAR_PARA;\n-    } else {\n-        \/* all separators *\/\n-        type = XML_REGEXP_SEPAR;\n-    }\n-    } else if (cur == 'S') {\n-    NEXT;\n-    cur = CUR;\n-    if (cur == 'm') {\n-        NEXT;\n-        type = XML_REGEXP_SYMBOL_MATH;\n-        \/* math *\/\n-    } else if (cur == 'c') {\n-        NEXT;\n-        type = XML_REGEXP_SYMBOL_CURRENCY;\n-        \/* currency *\/\n-    } else if (cur == 'k') {\n-        NEXT;\n-        type = XML_REGEXP_SYMBOL_MODIFIER;\n-        \/* modifiers *\/\n-    } else if (cur == 'o') {\n-        NEXT;\n-        type = XML_REGEXP_SYMBOL_OTHERS;\n-        \/* other *\/\n-    } else {\n-        \/* all symbols *\/\n-        type = XML_REGEXP_SYMBOL;\n-    }\n-    } else if (cur == 'C') {\n-    NEXT;\n-    cur = CUR;\n-    if (cur == 'c') {\n-        NEXT;\n-        \/* control *\/\n-        type = XML_REGEXP_OTHER_CONTROL;\n-    } else if (cur == 'f') {\n-        NEXT;\n-        \/* format *\/\n-        type = XML_REGEXP_OTHER_FORMAT;\n-    } else if (cur == 'o') {\n-        NEXT;\n-        \/* private use *\/\n-        type = XML_REGEXP_OTHER_PRIVATE;\n-    } else if (cur == 'n') {\n-        NEXT;\n-        \/* not assigned *\/\n-        type = XML_REGEXP_OTHER_NA;\n-    } else {\n-        \/* all others *\/\n-        type = XML_REGEXP_OTHER;\n-    }\n-    } else if (cur == 'I') {\n-    const xmlChar *start;\n-    NEXT;\n-    cur = CUR;\n-    if (cur != 's') {\n-        ERROR(\"IsXXXX expected\");\n-        return;\n-    }\n-    NEXT;\n-    start = ctxt->cur;\n-    cur = CUR;\n-    if (((cur >= 'a') && (cur <= 'z')) ||\n-        ((cur >= 'A') && (cur <= 'Z')) ||\n-        ((cur >= '0') && (cur <= '9')) ||\n-        (cur == 0x2D)) {\n-        NEXT;\n-        cur = CUR;\n-        while (((cur >= 'a') && (cur <= 'z')) ||\n-        ((cur >= 'A') && (cur <= 'Z')) ||\n-        ((cur >= '0') && (cur <= '9')) ||\n-        (cur == 0x2D)) {\n-        NEXT;\n-        cur = CUR;\n-        }\n-    }\n-    type = XML_REGEXP_BLOCK_NAME;\n-    blockName = xmlStrndup(start, ctxt->cur - start);\n-        if (blockName == NULL)\n-        xmlRegexpErrMemory(ctxt);\n-    } else {\n-    ERROR(\"Unknown char property\");\n-    return;\n-    }\n-    if (ctxt->atom == NULL) {\n-    ctxt->atom = xmlRegNewAtom(ctxt, type);\n-        if (ctxt->atom == NULL) {\n-            xmlFree(blockName);\n-            return;\n-        }\n-    ctxt->atom->valuep = blockName;\n-    } else if (ctxt->atom->type == XML_REGEXP_RANGES) {\n-        if (xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,\n-                               type, 0, 0, blockName) == NULL) {\n-            xmlFree(blockName);\n-        }\n-    }\n-}\n-\n-static int parse_escaped_codeunit(xmlRegParserCtxtPtr ctxt)\n-{\n-    int val = 0, i, cur;\n-    for (i = 0; i < 4; i++) {\n-    NEXT;\n-    val *= 16;\n-    cur = CUR;\n-    if (cur >= '0' && cur <= '9') {\n-        val += cur - '0';\n-    } else if (cur >= 'A' && cur <= 'F') {\n-        val += cur - 'A' + 10;\n-    } else if (cur >= 'a' && cur <= 'f') {\n-        val += cur - 'a' + 10;\n-    } else {\n-        ERROR(\"Expecting hex digit\");\n-        return -1;\n-    }\n-    }\n-    return val;\n-}\n-\n-static int parse_escaped_codepoint(xmlRegParserCtxtPtr ctxt)\n-{\n-    int val = parse_escaped_codeunit(ctxt);\n-    if (0xD800 <= val && val <= 0xDBFF) {\n-    NEXT;\n-    if (CUR == '\\\\') {\n-        NEXT;\n-        if (CUR == 'u') {\n-        int low = parse_escaped_codeunit(ctxt);\n-        if (0xDC00 <= low && low <= 0xDFFF) {\n-            return (val - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000;\n-        }\n-        }\n-    }\n-    ERROR(\"Invalid low surrogate pair code unit\");\n-    val = -1;\n-    }\n-    return val;\n-}\n-\n-\/**\n- * xmlFAParseCharClassEsc:\n- * @ctxt:  a regexp parser context\n- *\n- * [23] charClassEsc ::= ( SingleCharEsc | MultiCharEsc | catEsc | complEsc )\n- * [24] SingleCharEsc ::= '\\' [nrt\\|.?*+(){}#x2D#x5B#x5D#x5E]\n- * [25] catEsc   ::=   '\\p{' charProp '}'\n- * [26] complEsc ::=   '\\P{' charProp '}'\n- * [37] MultiCharEsc ::= '.' | ('\\' [sSiIcCdDwW])\n- *\/\n-static void\n-xmlFAParseCharClassEsc(xmlRegParserCtxtPtr ctxt) {\n-    int cur;\n-\n-    if (CUR == '.') {\n-    if (ctxt->atom == NULL) {\n-        ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_ANYCHAR);\n-    } else if (ctxt->atom->type == XML_REGEXP_RANGES) {\n-        xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,\n-                   XML_REGEXP_ANYCHAR, 0, 0, NULL);\n-    }\n-    NEXT;\n-    return;\n-    }\n-    if (CUR != '\\\\') {\n-    ERROR(\"Escaped sequence: expecting \\\\\");\n-    return;\n-    }\n-    NEXT;\n-    cur = CUR;\n-    if (cur == 'p') {\n-    NEXT;\n-    if (CUR != '{') {\n-        ERROR(\"Expecting '{'\");\n-        return;\n-    }\n-    NEXT;\n-    xmlFAParseCharProp(ctxt);\n-    if (CUR != '}') {\n-        ERROR(\"Expecting '}'\");\n-        return;\n-    }\n-    NEXT;\n-    } else if (cur == 'P') {\n-    NEXT;\n-    if (CUR != '{') {\n-        ERROR(\"Expecting '{'\");\n-        return;\n-    }\n-    NEXT;\n-    xmlFAParseCharProp(ctxt);\n-        if (ctxt->atom != NULL)\n-        ctxt->atom->neg = 1;\n-    if (CUR != '}') {\n-        ERROR(\"Expecting '}'\");\n-        return;\n-    }\n-    NEXT;\n-    } else if ((cur == 'n') || (cur == 'r') || (cur == 't') || (cur == '\\\\') ||\n-    (cur == '|') || (cur == '.') || (cur == '?') || (cur == '*') ||\n-    (cur == '+') || (cur == '(') || (cur == ')') || (cur == '{') ||\n-    (cur == '}') || (cur == 0x2D) || (cur == 0x5B) || (cur == 0x5D) ||\n-    (cur == 0x5E) ||\n-\n-    \/* Non-standard escape sequences:\n-     *                  Java 1.8|.NET Core 3.1|MSXML 6 *\/\n-    (cur == '!') ||     \/*   +  |     +       |    +   *\/\n-    (cur == '\"') ||     \/*   +  |     +       |    +   *\/\n-    (cur == '#') ||     \/*   +  |     +       |    +   *\/\n-    (cur == '$') ||     \/*   +  |     +       |    +   *\/\n-    (cur == '%') ||     \/*   +  |     +       |    +   *\/\n-    (cur == ',') ||     \/*   +  |     +       |    +   *\/\n-    (cur == '\/') ||     \/*   +  |     +       |    +   *\/\n-    (cur == ':') ||     \/*   +  |     +       |    +   *\/\n-    (cur == ';') ||     \/*   +  |     +       |    +   *\/\n-    (cur == '=') ||     \/*   +  |     +       |    +   *\/\n-    (cur == '>') ||     \/*      |     +       |    +   *\/\n-    (cur == '@') ||     \/*   +  |     +       |    +   *\/\n-    (cur == '`') ||     \/*   +  |     +       |    +   *\/\n-    (cur == '~') ||     \/*   +  |     +       |    +   *\/\n-    (cur == 'u')) {     \/*      |     +       |    +   *\/\n-    if (ctxt->atom == NULL) {\n-        ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_CHARVAL);\n-        if (ctxt->atom != NULL) {\n-            switch (cur) {\n-            case 'n':\n-                ctxt->atom->codepoint = '\\n';\n-            break;\n-            case 'r':\n-                ctxt->atom->codepoint = '\\r';\n-            break;\n-            case 't':\n-                ctxt->atom->codepoint = '\\t';\n-            break;\n-            case 'u':\n-            cur = parse_escaped_codepoint(ctxt);\n-            if (cur < 0) {\n-                return;\n-            }\n-            ctxt->atom->codepoint = cur;\n-            break;\n-            default:\n-            ctxt->atom->codepoint = cur;\n-        }\n-        }\n-    } else if (ctxt->atom->type == XML_REGEXP_RANGES) {\n-            switch (cur) {\n-                case 'n':\n-                    cur = '\\n';\n-                    break;\n-                case 'r':\n-                    cur = '\\r';\n-                    break;\n-                case 't':\n-                    cur = '\\t';\n-                    break;\n-            }\n-        xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,\n-                   XML_REGEXP_CHARVAL, cur, cur, NULL);\n-    }\n-    NEXT;\n-    } else if ((cur == 's') || (cur == 'S') || (cur == 'i') || (cur == 'I') ||\n-    (cur == 'c') || (cur == 'C') || (cur == 'd') || (cur == 'D') ||\n-    (cur == 'w') || (cur == 'W')) {\n-    xmlRegAtomType type = XML_REGEXP_ANYSPACE;\n-\n-    switch (cur) {\n-        case 's':\n-        type = XML_REGEXP_ANYSPACE;\n-        break;\n-        case 'S':\n-        type = XML_REGEXP_NOTSPACE;\n-        break;\n-        case 'i':\n-        type = XML_REGEXP_INITNAME;\n-        break;\n-        case 'I':\n-        type = XML_REGEXP_NOTINITNAME;\n-        break;\n-        case 'c':\n-        type = XML_REGEXP_NAMECHAR;\n-        break;\n-        case 'C':\n-        type = XML_REGEXP_NOTNAMECHAR;\n-        break;\n-        case 'd':\n-        type = XML_REGEXP_DECIMAL;\n-        break;\n-        case 'D':\n-        type = XML_REGEXP_NOTDECIMAL;\n-        break;\n-        case 'w':\n-        type = XML_REGEXP_REALCHAR;\n-        break;\n-        case 'W':\n-        type = XML_REGEXP_NOTREALCHAR;\n-        break;\n-    }\n-    NEXT;\n-    if (ctxt->atom == NULL) {\n-        ctxt->atom = xmlRegNewAtom(ctxt, type);\n-    } else if (ctxt->atom->type == XML_REGEXP_RANGES) {\n-        xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,\n-                   type, 0, 0, NULL);\n-    }\n-    } else {\n-    ERROR(\"Wrong escape sequence, misuse of character '\\\\'\");\n-    }\n-}\n-\n-\/**\n- * xmlFAParseCharRange:\n- * @ctxt:  a regexp parser context\n- *\n- * [17]   charRange   ::=     seRange | XmlCharRef | XmlCharIncDash\n- * [18]   seRange   ::=   charOrEsc '-' charOrEsc\n- * [20]   charOrEsc   ::=   XmlChar | SingleCharEsc\n- * [21]   XmlChar   ::=   [^\\#x2D#x5B#x5D]\n- * [22]   XmlCharIncDash   ::=   [^\\#x5B#x5D]\n- *\/\n-static void\n-xmlFAParseCharRange(xmlRegParserCtxtPtr ctxt) {\n-    int cur, len;\n-    int start = -1;\n-    int end = -1;\n-\n-    if (CUR == '\\0') {\n-        ERROR(\"Expecting ']'\");\n-    return;\n-    }\n-\n-    cur = CUR;\n-    if (cur == '\\\\') {\n-    NEXT;\n-    cur = CUR;\n-    switch (cur) {\n-        case 'n': start = 0xA; break;\n-        case 'r': start = 0xD; break;\n-        case 't': start = 0x9; break;\n-        case '\\\\': case '|': case '.': case '-': case '^': case '?':\n-        case '*': case '+': case '{': case '}': case '(': case ')':\n-        case '[': case ']':\n-        start = cur; break;\n-        default:\n-        ERROR(\"Invalid escape value\");\n-        return;\n-    }\n-    end = start;\n-        len = 1;\n-    } else if ((cur != 0x5B) && (cur != 0x5D)) {\n-        len = 4;\n-        end = start = xmlGetUTF8Char(ctxt->cur, &len);\n-        if (start < 0) {\n-            ERROR(\"Invalid UTF-8\");\n-            return;\n-        }\n-    } else {\n-    ERROR(\"Expecting a char range\");\n-    return;\n-    }\n-    \/*\n-     * Since we are \"inside\" a range, we can assume ctxt->cur is past\n-     * the start of ctxt->string, and PREV should be safe\n-     *\/\n-    if ((start == '-') && (NXT(1) != ']') && (PREV != '[') && (PREV != '^')) {\n-    NEXTL(len);\n-    return;\n-    }\n-    NEXTL(len);\n-    cur = CUR;\n-    if ((cur != '-') || (NXT(1) == '[') || (NXT(1) == ']')) {\n-        xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,\n-                      XML_REGEXP_CHARVAL, start, end, NULL);\n-    return;\n-    }\n-    NEXT;\n-    cur = CUR;\n-    if (cur == '\\\\') {\n-    NEXT;\n-    cur = CUR;\n-    switch (cur) {\n-        case 'n': end = 0xA; break;\n-        case 'r': end = 0xD; break;\n-        case 't': end = 0x9; break;\n-        case '\\\\': case '|': case '.': case '-': case '^': case '?':\n-        case '*': case '+': case '{': case '}': case '(': case ')':\n-        case '[': case ']':\n-        end = cur; break;\n-        default:\n-        ERROR(\"Invalid escape value\");\n-        return;\n-    }\n-        len = 1;\n-    } else if ((cur != '\\0') && (cur != 0x5B) && (cur != 0x5D)) {\n-        len = 4;\n-        end = xmlGetUTF8Char(ctxt->cur, &len);\n-        if (end < 0) {\n-            ERROR(\"Invalid UTF-8\");\n-            return;\n-        }\n-    } else {\n-    ERROR(\"Expecting the end of a char range\");\n-    return;\n-    }\n-\n-    \/* TODO check that the values are acceptable character ranges for XML *\/\n-    if (end < start) {\n-    ERROR(\"End of range is before start of range\");\n-    } else {\n-        NEXTL(len);\n-        xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,\n-                   XML_REGEXP_CHARVAL, start, end, NULL);\n-    }\n-    return;\n-}\n-\n-\/**\n- * xmlFAParsePosCharGroup:\n- * @ctxt:  a regexp parser context\n- *\n- * [14]   posCharGroup ::= ( charRange | charClassEsc  )+\n- *\/\n-static void\n-xmlFAParsePosCharGroup(xmlRegParserCtxtPtr ctxt) {\n-    do {\n-    if (CUR == '\\\\') {\n-        xmlFAParseCharClassEsc(ctxt);\n-    } else {\n-        xmlFAParseCharRange(ctxt);\n-    }\n-    } while ((CUR != ']') && (CUR != '-') &&\n-             (CUR != 0) && (ctxt->error == 0));\n-}\n-\n-\/**\n- * xmlFAParseCharGroup:\n- * @ctxt:  a regexp parser context\n- *\n- * [13]   charGroup    ::= posCharGroup | negCharGroup | charClassSub\n- * [15]   negCharGroup ::= '^' posCharGroup\n- * [16]   charClassSub ::= ( posCharGroup | negCharGroup ) '-' charClassExpr\n- * [12]   charClassExpr ::= '[' charGroup ']'\n- *\/\n-static void\n-xmlFAParseCharGroup(xmlRegParserCtxtPtr ctxt) {\n-    int neg = ctxt->neg;\n-\n-    if (CUR == '^') {\n-    NEXT;\n-    ctxt->neg = !ctxt->neg;\n-    xmlFAParsePosCharGroup(ctxt);\n-    ctxt->neg = neg;\n-    }\n-    while ((CUR != ']') && (ctxt->error == 0)) {\n-    if ((CUR == '-') && (NXT(1) == '[')) {\n-        NEXT;    \/* eat the '-' *\/\n-        NEXT;    \/* eat the '[' *\/\n-        ctxt->neg = 2;\n-        xmlFAParseCharGroup(ctxt);\n-        ctxt->neg = neg;\n-        if (CUR == ']') {\n-        NEXT;\n-        } else {\n-        ERROR(\"charClassExpr: ']' expected\");\n-        }\n-        break;\n-    } else {\n-        xmlFAParsePosCharGroup(ctxt);\n-    }\n-    }\n-}\n-\n-\/**\n- * xmlFAParseCharClass:\n- * @ctxt:  a regexp parser context\n- *\n- * [11]   charClass   ::=     charClassEsc | charClassExpr\n- * [12]   charClassExpr   ::=   '[' charGroup ']'\n- *\/\n-static void\n-xmlFAParseCharClass(xmlRegParserCtxtPtr ctxt) {\n-    if (CUR == '[') {\n-    NEXT;\n-    ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_RANGES);\n-    if (ctxt->atom == NULL)\n-        return;\n-    xmlFAParseCharGroup(ctxt);\n-    if (CUR == ']') {\n-        NEXT;\n-    } else {\n-        ERROR(\"xmlFAParseCharClass: ']' expected\");\n-    }\n-    } else {\n-    xmlFAParseCharClassEsc(ctxt);\n-    }\n-}\n-\n-\/**\n- * xmlFAParseQuantExact:\n- * @ctxt:  a regexp parser context\n- *\n- * [8]   QuantExact   ::=   [0-9]+\n- *\n- * Returns 0 if success or -1 in case of error\n- *\/\n-static int\n-xmlFAParseQuantExact(xmlRegParserCtxtPtr ctxt) {\n-    int ret = 0;\n-    int ok = 0;\n-    int overflow = 0;\n-\n-    while ((CUR >= '0') && (CUR <= '9')) {\n-        if (ret > INT_MAX \/ 10) {\n-            overflow = 1;\n-        } else {\n-            int digit = CUR - '0';\n-\n-            ret *= 10;\n-            if (ret > INT_MAX - digit)\n-                overflow = 1;\n-            else\n-                ret += digit;\n-        }\n-    ok = 1;\n-    NEXT;\n-    }\n-    if ((ok != 1) || (overflow == 1)) {\n-    return(-1);\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlFAParseQuantifier:\n- * @ctxt:  a regexp parser context\n- *\n- * [4]   quantifier   ::=   [?*+] | ( '{' quantity '}' )\n- * [5]   quantity   ::=   quantRange | quantMin | QuantExact\n- * [6]   quantRange   ::=   QuantExact ',' QuantExact\n- * [7]   quantMin   ::=   QuantExact ','\n- * [8]   QuantExact   ::=   [0-9]+\n- *\/\n-static int\n-xmlFAParseQuantifier(xmlRegParserCtxtPtr ctxt) {\n-    int cur;\n-\n-    cur = CUR;\n-    if ((cur == '?') || (cur == '*') || (cur == '+')) {\n-    if (ctxt->atom != NULL) {\n-        if (cur == '?')\n-        ctxt->atom->quant = XML_REGEXP_QUANT_OPT;\n-        else if (cur == '*')\n-        ctxt->atom->quant = XML_REGEXP_QUANT_MULT;\n-        else if (cur == '+')\n-        ctxt->atom->quant = XML_REGEXP_QUANT_PLUS;\n-    }\n-    NEXT;\n-    return(1);\n-    }\n-    if (cur == '{') {\n-    int min = 0, max = 0;\n-\n-    NEXT;\n-    cur = xmlFAParseQuantExact(ctxt);\n-    if (cur >= 0)\n-        min = cur;\n-        else {\n-            ERROR(\"Improper quantifier\");\n-        }\n-    if (CUR == ',') {\n-        NEXT;\n-        if (CUR == '}')\n-            max = INT_MAX;\n-        else {\n-            cur = xmlFAParseQuantExact(ctxt);\n-            if (cur >= 0)\n-            max = cur;\n-        else {\n-            ERROR(\"Improper quantifier\");\n-        }\n-        }\n-    }\n-    if (CUR == '}') {\n-        NEXT;\n-    } else {\n-        ERROR(\"Unterminated quantifier\");\n-    }\n-    if (max == 0)\n-        max = min;\n-    if (ctxt->atom != NULL) {\n-        ctxt->atom->quant = XML_REGEXP_QUANT_RANGE;\n-        ctxt->atom->min = min;\n-        ctxt->atom->max = max;\n-    }\n-    return(1);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlFAParseAtom:\n- * @ctxt:  a regexp parser context\n- *\n- * [9]   atom   ::=   Char | charClass | ( '(' regExp ')' )\n- *\/\n-static int\n-xmlFAParseAtom(xmlRegParserCtxtPtr ctxt) {\n-    int codepoint, len;\n-\n-    codepoint = xmlFAIsChar(ctxt);\n-    if (codepoint > 0) {\n-    ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_CHARVAL);\n-    if (ctxt->atom == NULL)\n-        return(-1);\n-        len = 4;\n-        codepoint = xmlGetUTF8Char(ctxt->cur, &len);\n-        if (codepoint < 0) {\n-            ERROR(\"Invalid UTF-8\");\n-            return(-1);\n-        }\n-    ctxt->atom->codepoint = codepoint;\n-    NEXTL(len);\n-    return(1);\n-    } else if (CUR == '|') {\n-    return(0);\n-    } else if (CUR == 0) {\n-    return(0);\n-    } else if (CUR == ')') {\n-    return(0);\n-    } else if (CUR == '(') {\n-    xmlRegStatePtr start, oldend, start0;\n-\n-    NEXT;\n-        if (ctxt->depth >= 50) {\n-        ERROR(\"xmlFAParseAtom: maximum nesting depth exceeded\");\n-            return(-1);\n-        }\n-    \/*\n-     * this extra Epsilon transition is needed if we count with 0 allowed\n-     * unfortunately this can't be known at that point\n-     *\/\n-    xmlFAGenerateEpsilonTransition(ctxt, ctxt->state, NULL);\n-    start0 = ctxt->state;\n-    xmlFAGenerateEpsilonTransition(ctxt, ctxt->state, NULL);\n-    start = ctxt->state;\n-    oldend = ctxt->end;\n-    ctxt->end = NULL;\n-    ctxt->atom = NULL;\n-        ctxt->depth++;\n-    xmlFAParseRegExp(ctxt, 0);\n-        ctxt->depth--;\n-    if (CUR == ')') {\n-        NEXT;\n-    } else {\n-        ERROR(\"xmlFAParseAtom: expecting ')'\");\n-    }\n-    ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_SUBREG);\n-    if (ctxt->atom == NULL)\n-        return(-1);\n-    ctxt->atom->start = start;\n-    ctxt->atom->start0 = start0;\n-    ctxt->atom->stop = ctxt->state;\n-    ctxt->end = oldend;\n-    return(1);\n-    } else if ((CUR == '[') || (CUR == '\\\\') || (CUR == '.')) {\n-    xmlFAParseCharClass(ctxt);\n-    return(1);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlFAParsePiece:\n- * @ctxt:  a regexp parser context\n- *\n- * [3]   piece   ::=   atom quantifier?\n- *\/\n-static int\n-xmlFAParsePiece(xmlRegParserCtxtPtr ctxt) {\n-    int ret;\n-\n-    ctxt->atom = NULL;\n-    ret = xmlFAParseAtom(ctxt);\n-    if (ret == 0)\n-    return(0);\n-    if (ctxt->atom == NULL) {\n-    ERROR(\"internal: no atom generated\");\n-    }\n-    xmlFAParseQuantifier(ctxt);\n-    return(1);\n-}\n-\n-\/**\n- * xmlFAParseBranch:\n- * @ctxt:  a regexp parser context\n- * @to: optional target to the end of the branch\n- *\n- * @to is used to optimize by removing duplicate path in automata\n- * in expressions like (a|b)(c|d)\n- *\n- * [2]   branch   ::=   piece*\n- *\/\n-static int\n-xmlFAParseBranch(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr to) {\n-    xmlRegStatePtr previous;\n-    int ret;\n-\n-    previous = ctxt->state;\n-    ret = xmlFAParsePiece(ctxt);\n-    if (ret == 0) {\n-        \/* Empty branch *\/\n-    xmlFAGenerateEpsilonTransition(ctxt, previous, to);\n-    } else {\n-    if (xmlFAGenerateTransitions(ctxt, previous,\n-            (CUR=='|' || CUR==')' || CUR==0) ? to : NULL,\n-                ctxt->atom) < 0) {\n-            xmlRegFreeAtom(ctxt->atom);\n-            ctxt->atom = NULL;\n-        return(-1);\n-        }\n-    previous = ctxt->state;\n-    ctxt->atom = NULL;\n-    }\n-    while ((ret != 0) && (ctxt->error == 0)) {\n-    ret = xmlFAParsePiece(ctxt);\n-    if (ret != 0) {\n-        if (xmlFAGenerateTransitions(ctxt, previous,\n-                (CUR=='|' || CUR==')' || CUR==0) ? to : NULL,\n-                    ctxt->atom) < 0) {\n-                xmlRegFreeAtom(ctxt->atom);\n-                ctxt->atom = NULL;\n-                return(-1);\n-            }\n-        previous = ctxt->state;\n-        ctxt->atom = NULL;\n-    }\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlFAParseRegExp:\n- * @ctxt:  a regexp parser context\n- * @top:  is this the top-level expression ?\n- *\n- * [1]   regExp   ::=     branch  ( '|' branch )*\n- *\/\n-static void\n-xmlFAParseRegExp(xmlRegParserCtxtPtr ctxt, int top) {\n-    xmlRegStatePtr start, end;\n-\n-    \/* if not top start should have been generated by an epsilon trans *\/\n-    start = ctxt->state;\n-    ctxt->end = NULL;\n-    xmlFAParseBranch(ctxt, NULL);\n-    if (top) {\n-    ctxt->state->type = XML_REGEXP_FINAL_STATE;\n-    }\n-    if (CUR != '|') {\n-    ctxt->end = ctxt->state;\n-    return;\n-    }\n-    end = ctxt->state;\n-    while ((CUR == '|') && (ctxt->error == 0)) {\n-    NEXT;\n-    ctxt->state = start;\n-    ctxt->end = NULL;\n-    xmlFAParseBranch(ctxt, end);\n-    }\n-    if (!top) {\n-    ctxt->state = end;\n-    ctxt->end = end;\n-    }\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            The basic API                    *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlRegexpPrint:\n- * @output: the file for the output debug\n- * @regexp: the compiled regexp\n- *\n- * Print the content of the compiled regular expression\n- *\/\n-void\n-xmlRegexpPrint(FILE *output, xmlRegexpPtr regexp) {\n-    int i;\n-\n-    if (output == NULL)\n-        return;\n-    fprintf(output, \" regexp: \");\n-    if (regexp == NULL) {\n-    fprintf(output, \"NULL\\n\");\n-    return;\n-    }\n-    fprintf(output, \"'%s' \", regexp->string);\n-    fprintf(output, \"\\n\");\n-    fprintf(output, \"%d atoms:\\n\", regexp->nbAtoms);\n-    for (i = 0;i < regexp->nbAtoms; i++) {\n-    fprintf(output, \" %02d \", i);\n-    xmlRegPrintAtom(output, regexp->atoms[i]);\n-    }\n-    fprintf(output, \"%d states:\", regexp->nbStates);\n-    fprintf(output, \"\\n\");\n-    for (i = 0;i < regexp->nbStates; i++) {\n-    xmlRegPrintState(output, regexp->states[i]);\n-    }\n-    fprintf(output, \"%d counters:\\n\", regexp->nbCounters);\n-    for (i = 0;i < regexp->nbCounters; i++) {\n-    fprintf(output, \" %d: min %d max %d\\n\", i, regexp->counters[i].min,\n-                                        regexp->counters[i].max);\n-    }\n-}\n-\n-\/**\n- * xmlRegexpCompile:\n- * @regexp:  a regular expression string\n- *\n- * Parses a regular expression conforming to XML Schemas Part 2 Datatype\n- * Appendix F and builds an automata suitable for testing strings against\n- * that regular expression\n- *\n- * Returns the compiled expression or NULL in case of error\n- *\/\n-xmlRegexpPtr\n-xmlRegexpCompile(const xmlChar *regexp) {\n-    xmlRegexpPtr ret = NULL;\n-    xmlRegParserCtxtPtr ctxt;\n-\n-    if (regexp == NULL)\n-        return(NULL);\n-\n-    ctxt = xmlRegNewParserCtxt(regexp);\n-    if (ctxt == NULL)\n-    return(NULL);\n-\n-    \/* initialize the parser *\/\n-    ctxt->state = xmlRegStatePush(ctxt);\n-    if (ctxt->state == NULL)\n-        goto error;\n-    ctxt->start = ctxt->state;\n-    ctxt->end = NULL;\n-\n-    \/* parse the expression building an automata *\/\n-    xmlFAParseRegExp(ctxt, 1);\n-    if (CUR != 0) {\n-    ERROR(\"xmlFAParseRegExp: extra characters\");\n-    }\n-    if (ctxt->error != 0)\n-        goto error;\n-    ctxt->end = ctxt->state;\n-    ctxt->start->type = XML_REGEXP_START_STATE;\n-    ctxt->end->type = XML_REGEXP_FINAL_STATE;\n-\n-    \/* remove the Epsilon except for counted transitions *\/\n-    xmlFAEliminateEpsilonTransitions(ctxt);\n-\n-\n-    if (ctxt->error != 0)\n-        goto error;\n-    ret = xmlRegEpxFromParse(ctxt);\n-\n-error:\n-    xmlRegFreeParserCtxt(ctxt);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlRegexpExec:\n- * @comp:  the compiled regular expression\n- * @content:  the value to check against the regular expression\n- *\n- * Check if the regular expression generates the value\n- *\n- * Returns 1 if it matches, 0 if not and a negative value in case of error\n- *\/\n-int\n-xmlRegexpExec(xmlRegexpPtr comp, const xmlChar *content) {\n-    if ((comp == NULL) || (content == NULL))\n-    return(-1);\n-    return(xmlFARegExec(comp, content));\n-}\n-\n-\/**\n- * xmlRegexpIsDeterminist:\n- * @comp:  the compiled regular expression\n- *\n- * Check if the regular expression is determinist\n- *\n- * Returns 1 if it yes, 0 if not and a negative value in case of error\n- *\/\n-int\n-xmlRegexpIsDeterminist(xmlRegexpPtr comp) {\n-    xmlAutomataPtr am;\n-    int ret;\n-\n-    if (comp == NULL)\n-    return(-1);\n-    if (comp->determinist != -1)\n-    return(comp->determinist);\n-\n-    am = xmlNewAutomata();\n-    if (am == NULL)\n-        return(-1);\n-    if (am->states != NULL) {\n-    int i;\n-\n-    for (i = 0;i < am->nbStates;i++)\n-        xmlRegFreeState(am->states[i]);\n-    xmlFree(am->states);\n-    }\n-    am->nbAtoms = comp->nbAtoms;\n-    am->atoms = comp->atoms;\n-    am->nbStates = comp->nbStates;\n-    am->states = comp->states;\n-    am->determinist = -1;\n-    am->flags = comp->flags;\n-    ret = xmlFAComputesDeterminism(am);\n-    am->atoms = NULL;\n-    am->states = NULL;\n-    xmlFreeAutomata(am);\n-    comp->determinist = ret;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlRegFreeRegexp:\n- * @regexp:  the regexp\n- *\n- * Free a regexp\n- *\/\n-void\n-xmlRegFreeRegexp(xmlRegexpPtr regexp) {\n-    int i;\n-    if (regexp == NULL)\n-    return;\n-\n-    if (regexp->string != NULL)\n-    xmlFree(regexp->string);\n-    if (regexp->states != NULL) {\n-    for (i = 0;i < regexp->nbStates;i++)\n-        xmlRegFreeState(regexp->states[i]);\n-    xmlFree(regexp->states);\n-    }\n-    if (regexp->atoms != NULL) {\n-    for (i = 0;i < regexp->nbAtoms;i++)\n-        xmlRegFreeAtom(regexp->atoms[i]);\n-    xmlFree(regexp->atoms);\n-    }\n-    if (regexp->counters != NULL)\n-    xmlFree(regexp->counters);\n-    if (regexp->compact != NULL)\n-    xmlFree(regexp->compact);\n-    if (regexp->transdata != NULL)\n-    xmlFree(regexp->transdata);\n-    if (regexp->stringMap != NULL) {\n-    for (i = 0; i < regexp->nbstrings;i++)\n-        xmlFree(regexp->stringMap[i]);\n-    xmlFree(regexp->stringMap);\n-    }\n-\n-    xmlFree(regexp);\n-}\n-\n-#ifdef LIBXML_AUTOMATA_ENABLED\n-\/************************************************************************\n- *                                    *\n- *            The Automata interface                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlNewAutomata:\n- *\n- * Create a new automata\n- *\n- * Returns the new object or NULL in case of failure\n- *\/\n-xmlAutomataPtr\n-xmlNewAutomata(void) {\n-    xmlAutomataPtr ctxt;\n-\n-    ctxt = xmlRegNewParserCtxt(NULL);\n-    if (ctxt == NULL)\n-    return(NULL);\n-\n-    \/* initialize the parser *\/\n-    ctxt->state = xmlRegStatePush(ctxt);\n-    if (ctxt->state == NULL) {\n-    xmlFreeAutomata(ctxt);\n-    return(NULL);\n-    }\n-    ctxt->start = ctxt->state;\n-    ctxt->end = NULL;\n-\n-    ctxt->start->type = XML_REGEXP_START_STATE;\n-    ctxt->flags = 0;\n-\n-    return(ctxt);\n-}\n-\n-\/**\n- * xmlFreeAutomata:\n- * @am: an automata\n- *\n- * Free an automata\n- *\/\n-void\n-xmlFreeAutomata(xmlAutomataPtr am) {\n-    if (am == NULL)\n-    return;\n-    xmlRegFreeParserCtxt(am);\n-}\n-\n-\/**\n- * xmlAutomataSetFlags:\n- * @am: an automata\n- * @flags:  a set of internal flags\n- *\n- * Set some flags on the automata\n- *\/\n-void\n-xmlAutomataSetFlags(xmlAutomataPtr am, int flags) {\n-    if (am == NULL)\n-    return;\n-    am->flags |= flags;\n-}\n-\n-\/**\n- * xmlAutomataGetInitState:\n- * @am: an automata\n- *\n- * Initial state lookup\n- *\n- * Returns the initial state of the automata\n- *\/\n-xmlAutomataStatePtr\n-xmlAutomataGetInitState(xmlAutomataPtr am) {\n-    if (am == NULL)\n-    return(NULL);\n-    return(am->start);\n-}\n-\n-\/**\n- * xmlAutomataSetFinalState:\n- * @am: an automata\n- * @state: a state in this automata\n- *\n- * Makes that state a final state\n- *\n- * Returns 0 or -1 in case of error\n- *\/\n-int\n-xmlAutomataSetFinalState(xmlAutomataPtr am, xmlAutomataStatePtr state) {\n-    if ((am == NULL) || (state == NULL))\n-    return(-1);\n-    state->type = XML_REGEXP_FINAL_STATE;\n-    return(0);\n-}\n-\n-\/**\n- * xmlAutomataNewTransition:\n- * @am: an automata\n- * @from: the starting point of the transition\n- * @to: the target point of the transition or NULL\n- * @token: the input string associated to that transition\n- * @data: data passed to the callback function if the transition is activated\n- *\n- * If @to is NULL, this creates first a new target state in the automata\n- * and then adds a transition from the @from state to the target state\n- * activated by the value of @token\n- *\n- * Returns the target state or NULL in case of error\n- *\/\n-xmlAutomataStatePtr\n-xmlAutomataNewTransition(xmlAutomataPtr am, xmlAutomataStatePtr from,\n-             xmlAutomataStatePtr to, const xmlChar *token,\n-             void *data) {\n-    xmlRegAtomPtr atom;\n-\n-    if ((am == NULL) || (from == NULL) || (token == NULL))\n-    return(NULL);\n-    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);\n-    if (atom == NULL)\n-        return(NULL);\n-    atom->data = data;\n-    atom->valuep = xmlStrdup(token);\n-    if (atom->valuep == NULL) {\n-        xmlRegFreeAtom(atom);\n-        xmlRegexpErrMemory(am);\n-        return(NULL);\n-    }\n-\n-    if (xmlFAGenerateTransitions(am, from, to, atom) < 0) {\n-        xmlRegFreeAtom(atom);\n-    return(NULL);\n-    }\n-    if (to == NULL)\n-    return(am->state);\n-    return(to);\n-}\n-\n-\/**\n- * xmlAutomataNewTransition2:\n- * @am: an automata\n- * @from: the starting point of the transition\n- * @to: the target point of the transition or NULL\n- * @token: the first input string associated to that transition\n- * @token2: the second input string associated to that transition\n- * @data: data passed to the callback function if the transition is activated\n- *\n- * If @to is NULL, this creates first a new target state in the automata\n- * and then adds a transition from the @from state to the target state\n- * activated by the value of @token\n- *\n- * Returns the target state or NULL in case of error\n- *\/\n-xmlAutomataStatePtr\n-xmlAutomataNewTransition2(xmlAutomataPtr am, xmlAutomataStatePtr from,\n-              xmlAutomataStatePtr to, const xmlChar *token,\n-              const xmlChar *token2, void *data) {\n-    xmlRegAtomPtr atom;\n-\n-    if ((am == NULL) || (from == NULL) || (token == NULL))\n-    return(NULL);\n-    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);\n-    if (atom == NULL)\n-    return(NULL);\n-    atom->data = data;\n-    if ((token2 == NULL) || (*token2 == 0)) {\n-    atom->valuep = xmlStrdup(token);\n-    } else {\n-    int lenn, lenp;\n-    xmlChar *str;\n-\n-    lenn = strlen((char *) token2);\n-    lenp = strlen((char *) token);\n-\n-    str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);\n-    if (str == NULL) {\n-        xmlRegFreeAtom(atom);\n-        return(NULL);\n-    }\n-    memcpy(&str[0], token, lenp);\n-    str[lenp] = '|';\n-    memcpy(&str[lenp + 1], token2, lenn);\n-    str[lenn + lenp + 1] = 0;\n-\n-    atom->valuep = str;\n-    }\n-\n-    if (xmlFAGenerateTransitions(am, from, to, atom) < 0) {\n-        xmlRegFreeAtom(atom);\n-    return(NULL);\n-    }\n-    if (to == NULL)\n-    return(am->state);\n-    return(to);\n-}\n-\n-\/**\n- * xmlAutomataNewNegTrans:\n- * @am: an automata\n- * @from: the starting point of the transition\n- * @to: the target point of the transition or NULL\n- * @token: the first input string associated to that transition\n- * @token2: the second input string associated to that transition\n- * @data: data passed to the callback function if the transition is activated\n- *\n- * If @to is NULL, this creates first a new target state in the automata\n- * and then adds a transition from the @from state to the target state\n- * activated by any value except (@token,@token2)\n- * Note that if @token2 is not NULL, then (X, NULL) won't match to follow\n- # the semantic of XSD ##other\n- *\n- * Returns the target state or NULL in case of error\n- *\/\n-xmlAutomataStatePtr\n-xmlAutomataNewNegTrans(xmlAutomataPtr am, xmlAutomataStatePtr from,\n-               xmlAutomataStatePtr to, const xmlChar *token,\n-               const xmlChar *token2, void *data) {\n-    xmlRegAtomPtr atom;\n-    xmlChar err_msg[200];\n-\n-    if ((am == NULL) || (from == NULL) || (token == NULL))\n-    return(NULL);\n-    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);\n-    if (atom == NULL)\n-    return(NULL);\n-    atom->data = data;\n-    atom->neg = 1;\n-    if ((token2 == NULL) || (*token2 == 0)) {\n-    atom->valuep = xmlStrdup(token);\n-    } else {\n-    int lenn, lenp;\n-    xmlChar *str;\n-\n-    lenn = strlen((char *) token2);\n-    lenp = strlen((char *) token);\n-\n-    str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);\n-    if (str == NULL) {\n-        xmlRegFreeAtom(atom);\n-        return(NULL);\n-    }\n-    memcpy(&str[0], token, lenp);\n-    str[lenp] = '|';\n-    memcpy(&str[lenp + 1], token2, lenn);\n-    str[lenn + lenp + 1] = 0;\n-\n-    atom->valuep = str;\n-    }\n-    snprintf((char *) err_msg, 199, \"not %s\", (const char *) atom->valuep);\n-    err_msg[199] = 0;\n-    atom->valuep2 = xmlStrdup(err_msg);\n-\n-    if (xmlFAGenerateTransitions(am, from, to, atom) < 0) {\n-        xmlRegFreeAtom(atom);\n-    return(NULL);\n-    }\n-    am->negs++;\n-    if (to == NULL)\n-    return(am->state);\n-    return(to);\n-}\n-\n-\/**\n- * xmlAutomataNewCountTrans2:\n- * @am: an automata\n- * @from: the starting point of the transition\n- * @to: the target point of the transition or NULL\n- * @token: the input string associated to that transition\n- * @token2: the second input string associated to that transition\n- * @min:  the minimum successive occurrences of token\n- * @max:  the maximum successive occurrences of token\n- * @data:  data associated to the transition\n- *\n- * If @to is NULL, this creates first a new target state in the automata\n- * and then adds a transition from the @from state to the target state\n- * activated by a succession of input of value @token and @token2 and\n- * whose number is between @min and @max\n- *\n- * Returns the target state or NULL in case of error\n- *\/\n-xmlAutomataStatePtr\n-xmlAutomataNewCountTrans2(xmlAutomataPtr am, xmlAutomataStatePtr from,\n-             xmlAutomataStatePtr to, const xmlChar *token,\n-             const xmlChar *token2,\n-             int min, int max, void *data) {\n-    xmlRegAtomPtr atom;\n-    int counter;\n-\n-    if ((am == NULL) || (from == NULL) || (token == NULL))\n-    return(NULL);\n-    if (min < 0)\n-    return(NULL);\n-    if ((max < min) || (max < 1))\n-    return(NULL);\n-    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);\n-    if (atom == NULL)\n-    return(NULL);\n-    if ((token2 == NULL) || (*token2 == 0)) {\n-    atom->valuep = xmlStrdup(token);\n-        if (atom->valuep == NULL)\n-            goto error;\n-    } else {\n-    int lenn, lenp;\n-    xmlChar *str;\n-\n-    lenn = strlen((char *) token2);\n-    lenp = strlen((char *) token);\n-\n-    str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);\n-    if (str == NULL)\n-        goto error;\n-    memcpy(&str[0], token, lenp);\n-    str[lenp] = '|';\n-    memcpy(&str[lenp + 1], token2, lenn);\n-    str[lenn + lenp + 1] = 0;\n-\n-    atom->valuep = str;\n-    }\n-    atom->data = data;\n-    if (min == 0)\n-    atom->min = 1;\n-    else\n-    atom->min = min;\n-    atom->max = max;\n-\n-    \/*\n-     * associate a counter to the transition.\n-     *\/\n-    counter = xmlRegGetCounter(am);\n-    if (counter < 0)\n-        goto error;\n-    am->counters[counter].min = min;\n-    am->counters[counter].max = max;\n-\n-    \/* xmlFAGenerateTransitions(am, from, to, atom); *\/\n-    if (to == NULL) {\n-    to = xmlRegStatePush(am);\n-        if (to == NULL)\n-            goto error;\n-    }\n-    xmlRegStateAddTrans(am, from, atom, to, counter, -1);\n-    if (xmlRegAtomPush(am, atom) < 0)\n-        goto error;\n-    am->state = to;\n-\n-    if (to == NULL)\n-    to = am->state;\n-    if (to == NULL)\n-    return(NULL);\n-    if (min == 0)\n-    xmlFAGenerateEpsilonTransition(am, from, to);\n-    return(to);\n-\n-error:\n-    xmlRegFreeAtom(atom);\n-    return(NULL);\n-}\n-\n-\/**\n- * xmlAutomataNewCountTrans:\n- * @am: an automata\n- * @from: the starting point of the transition\n- * @to: the target point of the transition or NULL\n- * @token: the input string associated to that transition\n- * @min:  the minimum successive occurrences of token\n- * @max:  the maximum successive occurrences of token\n- * @data:  data associated to the transition\n- *\n- * If @to is NULL, this creates first a new target state in the automata\n- * and then adds a transition from the @from state to the target state\n- * activated by a succession of input of value @token and whose number\n- * is between @min and @max\n- *\n- * Returns the target state or NULL in case of error\n- *\/\n-xmlAutomataStatePtr\n-xmlAutomataNewCountTrans(xmlAutomataPtr am, xmlAutomataStatePtr from,\n-             xmlAutomataStatePtr to, const xmlChar *token,\n-             int min, int max, void *data) {\n-    xmlRegAtomPtr atom;\n-    int counter;\n-\n-    if ((am == NULL) || (from == NULL) || (token == NULL))\n-    return(NULL);\n-    if (min < 0)\n-    return(NULL);\n-    if ((max < min) || (max < 1))\n-    return(NULL);\n-    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);\n-    if (atom == NULL)\n-    return(NULL);\n-    atom->valuep = xmlStrdup(token);\n-    if (atom->valuep == NULL)\n-        goto error;\n-    atom->data = data;\n-    if (min == 0)\n-    atom->min = 1;\n-    else\n-    atom->min = min;\n-    atom->max = max;\n-\n-    \/*\n-     * associate a counter to the transition.\n-     *\/\n-    counter = xmlRegGetCounter(am);\n-    if (counter < 0)\n-        goto error;\n-    am->counters[counter].min = min;\n-    am->counters[counter].max = max;\n-\n-    \/* xmlFAGenerateTransitions(am, from, to, atom); *\/\n-    if (to == NULL) {\n-    to = xmlRegStatePush(am);\n-        if (to == NULL)\n-            goto error;\n-    }\n-    xmlRegStateAddTrans(am, from, atom, to, counter, -1);\n-    if (xmlRegAtomPush(am, atom) < 0)\n-        goto error;\n-    am->state = to;\n-\n-    if (to == NULL)\n-    to = am->state;\n-    if (to == NULL)\n-    return(NULL);\n-    if (min == 0)\n-    xmlFAGenerateEpsilonTransition(am, from, to);\n-    return(to);\n-\n-error:\n-    xmlRegFreeAtom(atom);\n-    return(NULL);\n-}\n-\n-\/**\n- * xmlAutomataNewOnceTrans2:\n- * @am: an automata\n- * @from: the starting point of the transition\n- * @to: the target point of the transition or NULL\n- * @token: the input string associated to that transition\n- * @token2: the second input string associated to that transition\n- * @min:  the minimum successive occurrences of token\n- * @max:  the maximum successive occurrences of token\n- * @data:  data associated to the transition\n- *\n- * If @to is NULL, this creates first a new target state in the automata\n- * and then adds a transition from the @from state to the target state\n- * activated by a succession of input of value @token and @token2 and whose\n- * number is between @min and @max, moreover that transition can only be\n- * crossed once.\n- *\n- * Returns the target state or NULL in case of error\n- *\/\n-xmlAutomataStatePtr\n-xmlAutomataNewOnceTrans2(xmlAutomataPtr am, xmlAutomataStatePtr from,\n-             xmlAutomataStatePtr to, const xmlChar *token,\n-             const xmlChar *token2,\n-             int min, int max, void *data) {\n-    xmlRegAtomPtr atom;\n-    int counter;\n-\n-    if ((am == NULL) || (from == NULL) || (token == NULL))\n-    return(NULL);\n-    if (min < 1)\n-    return(NULL);\n-    if (max < min)\n-    return(NULL);\n-    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);\n-    if (atom == NULL)\n-    return(NULL);\n-    if ((token2 == NULL) || (*token2 == 0)) {\n-    atom->valuep = xmlStrdup(token);\n-        if (atom->valuep == NULL)\n-            goto error;\n-    } else {\n-    int lenn, lenp;\n-    xmlChar *str;\n-\n-    lenn = strlen((char *) token2);\n-    lenp = strlen((char *) token);\n-\n-    str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);\n-    if (str == NULL)\n-        goto error;\n-    memcpy(&str[0], token, lenp);\n-    str[lenp] = '|';\n-    memcpy(&str[lenp + 1], token2, lenn);\n-    str[lenn + lenp + 1] = 0;\n-\n-    atom->valuep = str;\n-    }\n-    atom->data = data;\n-    atom->quant = XML_REGEXP_QUANT_ONCEONLY;\n-    atom->min = min;\n-    atom->max = max;\n-    \/*\n-     * associate a counter to the transition.\n-     *\/\n-    counter = xmlRegGetCounter(am);\n-    if (counter < 0)\n-        goto error;\n-    am->counters[counter].min = 1;\n-    am->counters[counter].max = 1;\n-\n-    \/* xmlFAGenerateTransitions(am, from, to, atom); *\/\n-    if (to == NULL) {\n-    to = xmlRegStatePush(am);\n-        if (to == NULL)\n-            goto error;\n-    }\n-    xmlRegStateAddTrans(am, from, atom, to, counter, -1);\n-    if (xmlRegAtomPush(am, atom) < 0)\n-        goto error;\n-    am->state = to;\n-    return(to);\n-\n-error:\n-    xmlRegFreeAtom(atom);\n-    return(NULL);\n-}\n-\n-\n-\n-\/**\n- * xmlAutomataNewOnceTrans:\n- * @am: an automata\n- * @from: the starting point of the transition\n- * @to: the target point of the transition or NULL\n- * @token: the input string associated to that transition\n- * @min:  the minimum successive occurrences of token\n- * @max:  the maximum successive occurrences of token\n- * @data:  data associated to the transition\n- *\n- * If @to is NULL, this creates first a new target state in the automata\n- * and then adds a transition from the @from state to the target state\n- * activated by a succession of input of value @token and whose number\n- * is between @min and @max, moreover that transition can only be crossed\n- * once.\n- *\n- * Returns the target state or NULL in case of error\n- *\/\n-xmlAutomataStatePtr\n-xmlAutomataNewOnceTrans(xmlAutomataPtr am, xmlAutomataStatePtr from,\n-             xmlAutomataStatePtr to, const xmlChar *token,\n-             int min, int max, void *data) {\n-    xmlRegAtomPtr atom;\n-    int counter;\n-\n-    if ((am == NULL) || (from == NULL) || (token == NULL))\n-    return(NULL);\n-    if (min < 1)\n-    return(NULL);\n-    if (max < min)\n-    return(NULL);\n-    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);\n-    if (atom == NULL)\n-    return(NULL);\n-    atom->valuep = xmlStrdup(token);\n-    atom->data = data;\n-    atom->quant = XML_REGEXP_QUANT_ONCEONLY;\n-    atom->min = min;\n-    atom->max = max;\n-    \/*\n-     * associate a counter to the transition.\n-     *\/\n-    counter = xmlRegGetCounter(am);\n-    if (counter < 0)\n-        goto error;\n-    am->counters[counter].min = 1;\n-    am->counters[counter].max = 1;\n-\n-    \/* xmlFAGenerateTransitions(am, from, to, atom); *\/\n-    if (to == NULL) {\n-    to = xmlRegStatePush(am);\n-        if (to == NULL)\n-            goto error;\n-    }\n-    xmlRegStateAddTrans(am, from, atom, to, counter, -1);\n-    if (xmlRegAtomPush(am, atom) < 0)\n-        goto error;\n-    am->state = to;\n-    return(to);\n-\n-error:\n-    xmlRegFreeAtom(atom);\n-    return(NULL);\n-}\n-\n-\/**\n- * xmlAutomataNewState:\n- * @am: an automata\n- *\n- * Create a new disconnected state in the automata\n- *\n- * Returns the new state or NULL in case of error\n- *\/\n-xmlAutomataStatePtr\n-xmlAutomataNewState(xmlAutomataPtr am) {\n-    if (am == NULL)\n-    return(NULL);\n-    return(xmlRegStatePush(am));\n-}\n-\n-\/**\n- * xmlAutomataNewEpsilon:\n- * @am: an automata\n- * @from: the starting point of the transition\n- * @to: the target point of the transition or NULL\n- *\n- * If @to is NULL, this creates first a new target state in the automata\n- * and then adds an epsilon transition from the @from state to the\n- * target state\n- *\n- * Returns the target state or NULL in case of error\n- *\/\n-xmlAutomataStatePtr\n-xmlAutomataNewEpsilon(xmlAutomataPtr am, xmlAutomataStatePtr from,\n-              xmlAutomataStatePtr to) {\n-    if ((am == NULL) || (from == NULL))\n-    return(NULL);\n-    xmlFAGenerateEpsilonTransition(am, from, to);\n-    if (to == NULL)\n-    return(am->state);\n-    return(to);\n-}\n-\n-\/**\n- * xmlAutomataNewAllTrans:\n- * @am: an automata\n- * @from: the starting point of the transition\n- * @to: the target point of the transition or NULL\n- * @lax: allow to transition if not all all transitions have been activated\n- *\n- * If @to is NULL, this creates first a new target state in the automata\n- * and then adds a an ALL transition from the @from state to the\n- * target state. That transition is an epsilon transition allowed only when\n- * all transitions from the @from node have been activated.\n- *\n- * Returns the target state or NULL in case of error\n- *\/\n-xmlAutomataStatePtr\n-xmlAutomataNewAllTrans(xmlAutomataPtr am, xmlAutomataStatePtr from,\n-               xmlAutomataStatePtr to, int lax) {\n-    if ((am == NULL) || (from == NULL))\n-    return(NULL);\n-    xmlFAGenerateAllTransition(am, from, to, lax);\n-    if (to == NULL)\n-    return(am->state);\n-    return(to);\n-}\n-\n-\/**\n- * xmlAutomataNewCounter:\n- * @am: an automata\n- * @min:  the minimal value on the counter\n- * @max:  the maximal value on the counter\n- *\n- * Create a new counter\n- *\n- * Returns the counter number or -1 in case of error\n- *\/\n-int\n-xmlAutomataNewCounter(xmlAutomataPtr am, int min, int max) {\n-    int ret;\n-\n-    if (am == NULL)\n-    return(-1);\n-\n-    ret = xmlRegGetCounter(am);\n-    if (ret < 0)\n-    return(-1);\n-    am->counters[ret].min = min;\n-    am->counters[ret].max = max;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlAutomataNewCountedTrans:\n- * @am: an automata\n- * @from: the starting point of the transition\n- * @to: the target point of the transition or NULL\n- * @counter: the counter associated to that transition\n- *\n- * If @to is NULL, this creates first a new target state in the automata\n- * and then adds an epsilon transition from the @from state to the target state\n- * which will increment the counter provided\n- *\n- * Returns the target state or NULL in case of error\n- *\/\n-xmlAutomataStatePtr\n-xmlAutomataNewCountedTrans(xmlAutomataPtr am, xmlAutomataStatePtr from,\n-        xmlAutomataStatePtr to, int counter) {\n-    if ((am == NULL) || (from == NULL) || (counter < 0))\n-    return(NULL);\n-    xmlFAGenerateCountedEpsilonTransition(am, from, to, counter);\n-    if (to == NULL)\n-    return(am->state);\n-    return(to);\n-}\n-\n-\/**\n- * xmlAutomataNewCounterTrans:\n- * @am: an automata\n- * @from: the starting point of the transition\n- * @to: the target point of the transition or NULL\n- * @counter: the counter associated to that transition\n- *\n- * If @to is NULL, this creates first a new target state in the automata\n- * and then adds an epsilon transition from the @from state to the target state\n- * which will be allowed only if the counter is within the right range.\n- *\n- * Returns the target state or NULL in case of error\n- *\/\n-xmlAutomataStatePtr\n-xmlAutomataNewCounterTrans(xmlAutomataPtr am, xmlAutomataStatePtr from,\n-        xmlAutomataStatePtr to, int counter) {\n-    if ((am == NULL) || (from == NULL) || (counter < 0))\n-    return(NULL);\n-    xmlFAGenerateCountedTransition(am, from, to, counter);\n-    if (to == NULL)\n-    return(am->state);\n-    return(to);\n-}\n-\n-\/**\n- * xmlAutomataCompile:\n- * @am: an automata\n- *\n- * Compile the automata into a Reg Exp ready for being executed.\n- * The automata should be free after this point.\n- *\n- * Returns the compiled regexp or NULL in case of error\n- *\/\n-xmlRegexpPtr\n-xmlAutomataCompile(xmlAutomataPtr am) {\n-    xmlRegexpPtr ret;\n-\n-    if ((am == NULL) || (am->error != 0)) return(NULL);\n-    xmlFAEliminateEpsilonTransitions(am);\n-    if (am->error != 0)\n-        return(NULL);\n-    \/* xmlFAComputesDeterminism(am); *\/\n-    ret = xmlRegEpxFromParse(am);\n-\n-    return(ret);\n-}\n-\n-\/**\n- * xmlAutomataIsDeterminist:\n- * @am: an automata\n- *\n- * Checks if an automata is determinist.\n- *\n- * Returns 1 if true, 0 if not, and -1 in case of error\n- *\/\n-int\n-xmlAutomataIsDeterminist(xmlAutomataPtr am) {\n-    int ret;\n-\n-    if (am == NULL)\n-    return(-1);\n-\n-    ret = xmlFAComputesDeterminism(am);\n-    return(ret);\n-}\n-#endif \/* LIBXML_AUTOMATA_ENABLED *\/\n-\n-#ifdef LIBXML_EXPR_ENABLED\n-\/************************************************************************\n- *                                    *\n- *        Formal Expression handling code                *\n- *                                    *\n- ************************************************************************\/\n-\/************************************************************************\n- *                                    *\n- *        Expression handling context                *\n- *                                    *\n- ************************************************************************\/\n-\n-struct _xmlExpCtxt {\n-    xmlDictPtr dict;\n-    xmlExpNodePtr *table;\n-    int size;\n-    int nbElems;\n-    int nb_nodes;\n-    int maxNodes;\n-    const char *expr;\n-    const char *cur;\n-    int nb_cons;\n-    int tabSize;\n-};\n-\n-\/**\n- * xmlExpNewCtxt:\n- * @maxNodes:  the maximum number of nodes\n- * @dict:  optional dictionary to use internally\n- *\n- * Creates a new context for manipulating expressions\n- *\n- * Returns the context or NULL in case of error\n- *\/\n-xmlExpCtxtPtr\n-xmlExpNewCtxt(int maxNodes, xmlDictPtr dict) {\n-    xmlExpCtxtPtr ret;\n-    int size = 256;\n-\n-    if (maxNodes <= 4096)\n-        maxNodes = 4096;\n-\n-    ret = (xmlExpCtxtPtr) xmlMalloc(sizeof(xmlExpCtxt));\n-    if (ret == NULL)\n-        return(NULL);\n-    memset(ret, 0, sizeof(xmlExpCtxt));\n-    ret->size = size;\n-    ret->nbElems = 0;\n-    ret->maxNodes = maxNodes;\n-    ret->table = xmlMalloc(size * sizeof(xmlExpNodePtr));\n-    if (ret->table == NULL) {\n-        xmlFree(ret);\n-    return(NULL);\n-    }\n-    memset(ret->table, 0, size * sizeof(xmlExpNodePtr));\n-    if (dict == NULL) {\n-        ret->dict = xmlDictCreate();\n-    if (ret->dict == NULL) {\n-        xmlFree(ret->table);\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n-    } else {\n-        ret->dict = dict;\n-    xmlDictReference(ret->dict);\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlExpFreeCtxt:\n- * @ctxt:  an expression context\n- *\n- * Free an expression context\n- *\/\n-void\n-xmlExpFreeCtxt(xmlExpCtxtPtr ctxt) {\n-    if (ctxt == NULL)\n-        return;\n-    xmlDictFree(ctxt->dict);\n-    if (ctxt->table != NULL)\n-    xmlFree(ctxt->table);\n-    xmlFree(ctxt);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Structure associated to an expression node        *\n- *                                    *\n- ************************************************************************\/\n-#define MAX_NODES 10000\n-\n-\/*\n- * TODO:\n- * - Wildcards\n- * - public API for creation\n- *\n- * Started\n- * - regression testing\n- *\n- * Done\n- * - split into module and test tool\n- * - memleaks\n- *\/\n-\n-typedef enum {\n-    XML_EXP_NILABLE = (1 << 0)\n-} xmlExpNodeInfo;\n-\n-#define IS_NILLABLE(node) ((node)->info & XML_EXP_NILABLE)\n-\n-struct _xmlExpNode {\n-    unsigned char type;\/* xmlExpNodeType *\/\n-    unsigned char info;\/* OR of xmlExpNodeInfo *\/\n-    unsigned short key;    \/* the hash key *\/\n-    unsigned int ref;    \/* The number of references *\/\n-    int c_max;        \/* the maximum length it can consume *\/\n-    xmlExpNodePtr exp_left;\n-    xmlExpNodePtr next;\/* the next node in the hash table or free list *\/\n-    union {\n-    struct {\n-        int f_min;\n-        int f_max;\n-    } count;\n-    struct {\n-        xmlExpNodePtr f_right;\n-    } children;\n-        const xmlChar *f_str;\n-    } field;\n-};\n-\n-#define exp_min field.count.f_min\n-#define exp_max field.count.f_max\n-\/* #define exp_left field.children.f_left *\/\n-#define exp_right field.children.f_right\n-#define exp_str field.f_str\n-\n-static xmlExpNodePtr xmlExpNewNode(xmlExpCtxtPtr ctxt, xmlExpNodeType type);\n-static xmlExpNode forbiddenExpNode = {\n-    XML_EXP_FORBID, 0, 0, 0, 0, NULL, NULL, {{ 0, 0}}\n-};\n-xmlExpNodePtr forbiddenExp = &forbiddenExpNode;\n-static xmlExpNode emptyExpNode = {\n-    XML_EXP_EMPTY, 1, 0, 0, 0, NULL, NULL, {{ 0, 0}}\n-};\n-xmlExpNodePtr emptyExp = &emptyExpNode;\n-\n-\/************************************************************************\n- *                                    *\n- *  The custom hash table for unicity and canonicalization        *\n- *  of sub-expressions pointers                        *\n- *                                    *\n- ************************************************************************\/\n-\/*\n- * xmlExpHashNameComputeKey:\n- * Calculate the hash key for a token\n- *\/\n-static unsigned short\n-xmlExpHashNameComputeKey(const xmlChar *name) {\n-    unsigned short value = 0L;\n-    char ch;\n-\n-    if (name != NULL) {\n-    value += 30 * (*name);\n-    while ((ch = *name++) != 0) {\n-        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n-    }\n-    }\n-    return (value);\n-}\n-\n-\/*\n- * xmlExpHashComputeKey:\n- * Calculate the hash key for a compound expression\n- *\/\n-static unsigned short\n-xmlExpHashComputeKey(xmlExpNodeType type, xmlExpNodePtr left,\n-                     xmlExpNodePtr right) {\n-    unsigned long value;\n-    unsigned short ret;\n-\n-    switch (type) {\n-        case XML_EXP_SEQ:\n-        value = left->key;\n-        value += right->key;\n-        value *= 3;\n-        ret = (unsigned short) value;\n-        break;\n-        case XML_EXP_OR:\n-        value = left->key;\n-        value += right->key;\n-        value *= 7;\n-        ret = (unsigned short) value;\n-        break;\n-        case XML_EXP_COUNT:\n-        value = left->key;\n-        value += right->key;\n-        ret = (unsigned short) value;\n-        break;\n-    default:\n-        ret = 0;\n-    }\n-    return(ret);\n-}\n-\n-\n-static xmlExpNodePtr\n-xmlExpNewNode(xmlExpCtxtPtr ctxt, xmlExpNodeType type) {\n-    xmlExpNodePtr ret;\n-\n-    if (ctxt->nb_nodes >= MAX_NODES)\n-        return(NULL);\n-    ret = (xmlExpNodePtr) xmlMalloc(sizeof(xmlExpNode));\n-    if (ret == NULL)\n-        return(NULL);\n-    memset(ret, 0, sizeof(xmlExpNode));\n-    ret->type = type;\n-    ret->next = NULL;\n-    ctxt->nb_nodes++;\n-    ctxt->nb_cons++;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlExpHashGetEntry:\n- * @table: the hash table\n- *\n- * Get the unique entry from the hash table. The entry is created if\n- * needed. @left and @right are consumed, i.e. their ref count will\n- * be decremented by the operation.\n- *\n- * Returns the pointer or NULL in case of error\n- *\/\n-static xmlExpNodePtr\n-xmlExpHashGetEntry(xmlExpCtxtPtr ctxt, xmlExpNodeType type,\n-                   xmlExpNodePtr left, xmlExpNodePtr right,\n-           const xmlChar *name, int min, int max) {\n-    unsigned short kbase, key;\n-    xmlExpNodePtr entry;\n-    xmlExpNodePtr insert;\n-\n-    if (ctxt == NULL)\n-    return(NULL);\n-\n-    \/*\n-     * Check for duplicate and insertion location.\n-     *\/\n-    if (type == XML_EXP_ATOM) {\n-    kbase = xmlExpHashNameComputeKey(name);\n-    } else if (type == XML_EXP_COUNT) {\n-        \/* COUNT reduction rule 1 *\/\n-    \/* a{1} -> a *\/\n-    if (min == max) {\n-        if (min == 1) {\n-        return(left);\n-        }\n-        if (min == 0) {\n-        xmlExpFree(ctxt, left);\n-            return(emptyExp);\n-        }\n-    }\n-    if (min < 0) {\n-        xmlExpFree(ctxt, left);\n-        return(forbiddenExp);\n-    }\n-        if (max == -1)\n-        kbase = min + 79;\n-    else\n-        kbase = max - min;\n-    kbase += left->key;\n-    } else if (type == XML_EXP_OR) {\n-        \/* Forbid reduction rules *\/\n-        if (left->type == XML_EXP_FORBID) {\n-        xmlExpFree(ctxt, left);\n-        return(right);\n-    }\n-        if (right->type == XML_EXP_FORBID) {\n-        xmlExpFree(ctxt, right);\n-        return(left);\n-    }\n-\n-        \/* OR reduction rule 1 *\/\n-    \/* a | a reduced to a *\/\n-        if (left == right) {\n-        xmlExpFree(ctxt, right);\n-        return(left);\n-    }\n-        \/* OR canonicalization rule 1 *\/\n-    \/* linearize (a | b) | c into a | (b | c) *\/\n-        if ((left->type == XML_EXP_OR) && (right->type != XML_EXP_OR)) {\n-        xmlExpNodePtr tmp = left;\n-            left = right;\n-        right = tmp;\n-    }\n-        \/* OR reduction rule 2 *\/\n-    \/* a | (a | b) and b | (a | b) are reduced to a | b *\/\n-        if (right->type == XML_EXP_OR) {\n-        if ((left == right->exp_left) ||\n-            (left == right->exp_right)) {\n-        xmlExpFree(ctxt, left);\n-        return(right);\n-        }\n-    }\n-        \/* OR canonicalization rule 2 *\/\n-    \/* linearize (a | b) | c into a | (b | c) *\/\n-        if (left->type == XML_EXP_OR) {\n-        xmlExpNodePtr tmp;\n-\n-        \/* OR canonicalization rule 2 *\/\n-        if ((left->exp_right->type != XML_EXP_OR) &&\n-            (left->exp_right->key < left->exp_left->key)) {\n-            tmp = left->exp_right;\n-        left->exp_right = left->exp_left;\n-        left->exp_left = tmp;\n-        }\n-        left->exp_right->ref++;\n-        tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left->exp_right, right,\n-                                 NULL, 0, 0);\n-        left->exp_left->ref++;\n-        tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left->exp_left, tmp,\n-                                 NULL, 0, 0);\n-\n-        xmlExpFree(ctxt, left);\n-        return(tmp);\n-    }\n-    if (right->type == XML_EXP_OR) {\n-        \/* Ordering in the tree *\/\n-        \/* C | (A | B) -> A | (B | C) *\/\n-        if (left->key > right->exp_right->key) {\n-        xmlExpNodePtr tmp;\n-        right->exp_right->ref++;\n-        tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_right,\n-                                 left, NULL, 0, 0);\n-        right->exp_left->ref++;\n-        tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_left,\n-                                 tmp, NULL, 0, 0);\n-        xmlExpFree(ctxt, right);\n-        return(tmp);\n-        }\n-        \/* Ordering in the tree *\/\n-        \/* B | (A | C) -> A | (B | C) *\/\n-        if (left->key > right->exp_left->key) {\n-        xmlExpNodePtr tmp;\n-        right->exp_right->ref++;\n-        tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left,\n-                                 right->exp_right, NULL, 0, 0);\n-        right->exp_left->ref++;\n-        tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_left,\n-                                 tmp, NULL, 0, 0);\n-        xmlExpFree(ctxt, right);\n-        return(tmp);\n-        }\n-    }\n-    \/* we know both types are != XML_EXP_OR here *\/\n-        else if (left->key > right->key) {\n-        xmlExpNodePtr tmp = left;\n-            left = right;\n-        right = tmp;\n-    }\n-    kbase = xmlExpHashComputeKey(type, left, right);\n-    } else if (type == XML_EXP_SEQ) {\n-        \/* Forbid reduction rules *\/\n-        if (left->type == XML_EXP_FORBID) {\n-        xmlExpFree(ctxt, right);\n-        return(left);\n-    }\n-        if (right->type == XML_EXP_FORBID) {\n-        xmlExpFree(ctxt, left);\n-        return(right);\n-    }\n-        \/* Empty reduction rules *\/\n-        if (right->type == XML_EXP_EMPTY) {\n-        return(left);\n-    }\n-        if (left->type == XML_EXP_EMPTY) {\n-        return(right);\n-    }\n-    kbase = xmlExpHashComputeKey(type, left, right);\n-    } else\n-        return(NULL);\n-\n-    key = kbase % ctxt->size;\n-    if (ctxt->table[key] != NULL) {\n-    for (insert = ctxt->table[key]; insert != NULL;\n-         insert = insert->next) {\n-        if ((insert->key == kbase) &&\n-            (insert->type == type)) {\n-        if (type == XML_EXP_ATOM) {\n-            if (name == insert->exp_str) {\n-            insert->ref++;\n-            return(insert);\n-            }\n-        } else if (type == XML_EXP_COUNT) {\n-            if ((insert->exp_min == min) && (insert->exp_max == max) &&\n-                (insert->exp_left == left)) {\n-            insert->ref++;\n-            left->ref--;\n-            return(insert);\n-            }\n-        } else if ((insert->exp_left == left) &&\n-               (insert->exp_right == right)) {\n-            insert->ref++;\n-            left->ref--;\n-            right->ref--;\n-            return(insert);\n-        }\n-        }\n-    }\n-    }\n-\n-    entry = xmlExpNewNode(ctxt, type);\n-    if (entry == NULL)\n-        return(NULL);\n-    entry->key = kbase;\n-    if (type == XML_EXP_ATOM) {\n-    entry->exp_str = name;\n-    entry->c_max = 1;\n-    } else if (type == XML_EXP_COUNT) {\n-        entry->exp_min = min;\n-        entry->exp_max = max;\n-    entry->exp_left = left;\n-    if ((min == 0) || (IS_NILLABLE(left)))\n-        entry->info |= XML_EXP_NILABLE;\n-    if (max < 0)\n-        entry->c_max = -1;\n-    else\n-        entry->c_max = max * entry->exp_left->c_max;\n-    } else {\n-    entry->exp_left = left;\n-    entry->exp_right = right;\n-    if (type == XML_EXP_OR) {\n-        if ((IS_NILLABLE(left)) || (IS_NILLABLE(right)))\n-        entry->info |= XML_EXP_NILABLE;\n-        if ((entry->exp_left->c_max == -1) ||\n-            (entry->exp_right->c_max == -1))\n-        entry->c_max = -1;\n-        else if (entry->exp_left->c_max > entry->exp_right->c_max)\n-            entry->c_max = entry->exp_left->c_max;\n-        else\n-            entry->c_max = entry->exp_right->c_max;\n-    } else {\n-        if ((IS_NILLABLE(left)) && (IS_NILLABLE(right)))\n-        entry->info |= XML_EXP_NILABLE;\n-        if ((entry->exp_left->c_max == -1) ||\n-            (entry->exp_right->c_max == -1))\n-        entry->c_max = -1;\n-        else\n-            entry->c_max = entry->exp_left->c_max + entry->exp_right->c_max;\n-    }\n-    }\n-    entry->ref = 1;\n-    if (ctxt->table[key] != NULL)\n-        entry->next = ctxt->table[key];\n-\n-    ctxt->table[key] = entry;\n-    ctxt->nbElems++;\n-\n-    return(entry);\n-}\n-\n-\/**\n- * xmlExpFree:\n- * @ctxt: the expression context\n- * @exp: the expression\n- *\n- * Dereference the expression\n- *\/\n-void\n-xmlExpFree(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp) {\n-    if ((exp == NULL) || (exp == forbiddenExp) || (exp == emptyExp))\n-        return;\n-    exp->ref--;\n-    if (exp->ref == 0) {\n-        unsigned short key;\n-\n-        \/* Unlink it first from the hash table *\/\n-    key = exp->key % ctxt->size;\n-    if (ctxt->table[key] == exp) {\n-        ctxt->table[key] = exp->next;\n-    } else {\n-        xmlExpNodePtr tmp;\n-\n-        tmp = ctxt->table[key];\n-        while (tmp != NULL) {\n-            if (tmp->next == exp) {\n-            tmp->next = exp->next;\n-            break;\n-        }\n-            tmp = tmp->next;\n-        }\n-    }\n-\n-        if ((exp->type == XML_EXP_SEQ) || (exp->type == XML_EXP_OR)) {\n-        xmlExpFree(ctxt, exp->exp_left);\n-        xmlExpFree(ctxt, exp->exp_right);\n-    } else if (exp->type == XML_EXP_COUNT) {\n-        xmlExpFree(ctxt, exp->exp_left);\n-    }\n-        xmlFree(exp);\n-    ctxt->nb_nodes--;\n-    }\n-}\n-\n-\/**\n- * xmlExpRef:\n- * @exp: the expression\n- *\n- * Increase the reference count of the expression\n- *\/\n-void\n-xmlExpRef(xmlExpNodePtr exp) {\n-    if (exp != NULL)\n-        exp->ref++;\n-}\n-\n-\/**\n- * xmlExpNewAtom:\n- * @ctxt: the expression context\n- * @name: the atom name\n- * @len: the atom name length in byte (or -1);\n- *\n- * Get the atom associated to this name from that context\n- *\n- * Returns the node or NULL in case of error\n- *\/\n-xmlExpNodePtr\n-xmlExpNewAtom(xmlExpCtxtPtr ctxt, const xmlChar *name, int len) {\n-    if ((ctxt == NULL) || (name == NULL))\n-        return(NULL);\n-    name = xmlDictLookup(ctxt->dict, name, len);\n-    if (name == NULL)\n-        return(NULL);\n-    return(xmlExpHashGetEntry(ctxt, XML_EXP_ATOM, NULL, NULL, name, 0, 0));\n-}\n-\n-\/**\n- * xmlExpNewOr:\n- * @ctxt: the expression context\n- * @left: left expression\n- * @right: right expression\n- *\n- * Get the atom associated to the choice @left | @right\n- * Note that @left and @right are consumed in the operation, to keep\n- * an handle on them use xmlExpRef() and use xmlExpFree() to release them,\n- * this is true even in case of failure (unless ctxt == NULL).\n- *\n- * Returns the node or NULL in case of error\n- *\/\n-xmlExpNodePtr\n-xmlExpNewOr(xmlExpCtxtPtr ctxt, xmlExpNodePtr left, xmlExpNodePtr right) {\n-    if (ctxt == NULL)\n-        return(NULL);\n-    if ((left == NULL) || (right == NULL)) {\n-        xmlExpFree(ctxt, left);\n-        xmlExpFree(ctxt, right);\n-        return(NULL);\n-    }\n-    return(xmlExpHashGetEntry(ctxt, XML_EXP_OR, left, right, NULL, 0, 0));\n-}\n-\n-\/**\n- * xmlExpNewSeq:\n- * @ctxt: the expression context\n- * @left: left expression\n- * @right: right expression\n- *\n- * Get the atom associated to the sequence @left , @right\n- * Note that @left and @right are consumed in the operation, to keep\n- * an handle on them use xmlExpRef() and use xmlExpFree() to release them,\n- * this is true even in case of failure (unless ctxt == NULL).\n- *\n- * Returns the node or NULL in case of error\n- *\/\n-xmlExpNodePtr\n-xmlExpNewSeq(xmlExpCtxtPtr ctxt, xmlExpNodePtr left, xmlExpNodePtr right) {\n-    if (ctxt == NULL)\n-        return(NULL);\n-    if ((left == NULL) || (right == NULL)) {\n-        xmlExpFree(ctxt, left);\n-        xmlExpFree(ctxt, right);\n-        return(NULL);\n-    }\n-    return(xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, left, right, NULL, 0, 0));\n-}\n-\n-\/**\n- * xmlExpNewRange:\n- * @ctxt: the expression context\n- * @subset: the expression to be repeated\n- * @min: the lower bound for the repetition\n- * @max: the upper bound for the repetition, -1 means infinite\n- *\n- * Get the atom associated to the range (@subset){@min, @max}\n- * Note that @subset is consumed in the operation, to keep\n- * an handle on it use xmlExpRef() and use xmlExpFree() to release it,\n- * this is true even in case of failure (unless ctxt == NULL).\n- *\n- * Returns the node or NULL in case of error\n- *\/\n-xmlExpNodePtr\n-xmlExpNewRange(xmlExpCtxtPtr ctxt, xmlExpNodePtr subset, int min, int max) {\n-    if (ctxt == NULL)\n-        return(NULL);\n-    if ((subset == NULL) || (min < 0) || (max < -1) ||\n-        ((max >= 0) && (min > max))) {\n-    xmlExpFree(ctxt, subset);\n-        return(NULL);\n-    }\n-    return(xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, subset,\n-                              NULL, NULL, min, max));\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Public API for operations on expressions        *\n- *                                    *\n- ************************************************************************\/\n-\n-static int\n-xmlExpGetLanguageInt(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp,\n-                     const xmlChar**list, int len, int nb) {\n-    int tmp, tmp2;\n-tail:\n-    switch (exp->type) {\n-        case XML_EXP_EMPTY:\n-        return(0);\n-        case XML_EXP_ATOM:\n-        for (tmp = 0;tmp < nb;tmp++)\n-            if (list[tmp] == exp->exp_str)\n-            return(0);\n-            if (nb >= len)\n-            return(-2);\n-        list[nb] = exp->exp_str;\n-        return(1);\n-        case XML_EXP_COUNT:\n-        exp = exp->exp_left;\n-        goto tail;\n-        case XML_EXP_SEQ:\n-        case XML_EXP_OR:\n-        tmp = xmlExpGetLanguageInt(ctxt, exp->exp_left, list, len, nb);\n-        if (tmp < 0)\n-            return(tmp);\n-        tmp2 = xmlExpGetLanguageInt(ctxt, exp->exp_right, list, len,\n-                                    nb + tmp);\n-        if (tmp2 < 0)\n-            return(tmp2);\n-            return(tmp + tmp2);\n-    }\n-    return(-1);\n-}\n-\n-\/**\n- * xmlExpGetLanguage:\n- * @ctxt: the expression context\n- * @exp: the expression\n- * @langList: where to store the tokens\n- * @len: the allocated length of @list\n- *\n- * Find all the strings used in @exp and store them in @list\n- *\n- * Returns the number of unique strings found, -1 in case of errors and\n- *         -2 if there is more than @len strings\n- *\/\n-int\n-xmlExpGetLanguage(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp,\n-                  const xmlChar**langList, int len) {\n-    if ((ctxt == NULL) || (exp == NULL) || (langList == NULL) || (len <= 0))\n-        return(-1);\n-    return(xmlExpGetLanguageInt(ctxt, exp, langList, len, 0));\n-}\n-\n-static int\n-xmlExpGetStartInt(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp,\n-                  const xmlChar**list, int len, int nb) {\n-    int tmp, tmp2;\n-tail:\n-    switch (exp->type) {\n-        case XML_EXP_FORBID:\n-        return(0);\n-        case XML_EXP_EMPTY:\n-        return(0);\n-        case XML_EXP_ATOM:\n-        for (tmp = 0;tmp < nb;tmp++)\n-            if (list[tmp] == exp->exp_str)\n-            return(0);\n-            if (nb >= len)\n-            return(-2);\n-        list[nb] = exp->exp_str;\n-        return(1);\n-        case XML_EXP_COUNT:\n-        exp = exp->exp_left;\n-        goto tail;\n-        case XML_EXP_SEQ:\n-        tmp = xmlExpGetStartInt(ctxt, exp->exp_left, list, len, nb);\n-        if (tmp < 0)\n-            return(tmp);\n-        if (IS_NILLABLE(exp->exp_left)) {\n-        tmp2 = xmlExpGetStartInt(ctxt, exp->exp_right, list, len,\n-                        nb + tmp);\n-        if (tmp2 < 0)\n-            return(tmp2);\n-        tmp += tmp2;\n-        }\n-            return(tmp);\n-        case XML_EXP_OR:\n-        tmp = xmlExpGetStartInt(ctxt, exp->exp_left, list, len, nb);\n-        if (tmp < 0)\n-            return(tmp);\n-        tmp2 = xmlExpGetStartInt(ctxt, exp->exp_right, list, len,\n-                                    nb + tmp);\n-        if (tmp2 < 0)\n-            return(tmp2);\n-            return(tmp + tmp2);\n-    }\n-    return(-1);\n-}\n-\n-\/**\n- * xmlExpGetStart:\n- * @ctxt: the expression context\n- * @exp: the expression\n- * @tokList: where to store the tokens\n- * @len: the allocated length of @list\n- *\n- * Find all the strings that appears at the start of the languages\n- * accepted by @exp and store them in @list. E.g. for (a, b) | c\n- * it will return the list [a, c]\n- *\n- * Returns the number of unique strings found, -1 in case of errors and\n- *         -2 if there is more than @len strings\n- *\/\n-int\n-xmlExpGetStart(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp,\n-               const xmlChar**tokList, int len) {\n-    if ((ctxt == NULL) || (exp == NULL) || (tokList == NULL) || (len <= 0))\n-        return(-1);\n-    return(xmlExpGetStartInt(ctxt, exp, tokList, len, 0));\n-}\n-\n-\/**\n- * xmlExpIsNillable:\n- * @exp: the expression\n- *\n- * Finds if the expression is nillable, i.e. if it accepts the empty sequence\n- *\n- * Returns 1 if nillable, 0 if not and -1 in case of error\n- *\/\n-int\n-xmlExpIsNillable(xmlExpNodePtr exp) {\n-    if (exp == NULL)\n-        return(-1);\n-    return(IS_NILLABLE(exp) != 0);\n-}\n-\n-static xmlExpNodePtr\n-xmlExpStringDeriveInt(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp, const xmlChar *str)\n-{\n-    xmlExpNodePtr ret;\n-\n-    switch (exp->type) {\n-    case XML_EXP_EMPTY:\n-        return(forbiddenExp);\n-    case XML_EXP_FORBID:\n-        return(forbiddenExp);\n-    case XML_EXP_ATOM:\n-        if (exp->exp_str == str) {\n-            ret = emptyExp;\n-        } else {\n-            \/* TODO wildcards here *\/\n-        ret = forbiddenExp;\n-        }\n-        return(ret);\n-    case XML_EXP_OR: {\n-        xmlExpNodePtr tmp;\n-\n-        tmp = xmlExpStringDeriveInt(ctxt, exp->exp_left, str);\n-        if (tmp == NULL) {\n-        return(NULL);\n-        }\n-        ret = xmlExpStringDeriveInt(ctxt, exp->exp_right, str);\n-        if (ret == NULL) {\n-            xmlExpFree(ctxt, tmp);\n-        return(NULL);\n-        }\n-            ret = xmlExpHashGetEntry(ctxt, XML_EXP_OR, tmp, ret,\n-                 NULL, 0, 0);\n-        return(ret);\n-    }\n-    case XML_EXP_SEQ:\n-        ret = xmlExpStringDeriveInt(ctxt, exp->exp_left, str);\n-        if (ret == NULL) {\n-            return(NULL);\n-        } else if (ret == forbiddenExp) {\n-            if (IS_NILLABLE(exp->exp_left)) {\n-            ret = xmlExpStringDeriveInt(ctxt, exp->exp_right, str);\n-        }\n-        } else {\n-            exp->exp_right->ref++;\n-            ret = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret, exp->exp_right,\n-                                 NULL, 0, 0);\n-        }\n-        return(ret);\n-    case XML_EXP_COUNT: {\n-        int min, max;\n-        xmlExpNodePtr tmp;\n-\n-        if (exp->exp_max == 0)\n-        return(forbiddenExp);\n-        ret = xmlExpStringDeriveInt(ctxt, exp->exp_left, str);\n-        if (ret == NULL)\n-            return(NULL);\n-        if (ret == forbiddenExp) {\n-            return(ret);\n-        }\n-        if (exp->exp_max == 1)\n-        return(ret);\n-        if (exp->exp_max < 0) \/* unbounded *\/\n-        max = -1;\n-        else\n-        max = exp->exp_max - 1;\n-        if (exp->exp_min > 0)\n-        min = exp->exp_min - 1;\n-        else\n-        min = 0;\n-        exp->exp_left->ref++;\n-        tmp = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, exp->exp_left, NULL,\n-                     NULL, min, max);\n-        if (ret == emptyExp) {\n-            return(tmp);\n-        }\n-        return(xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret, tmp,\n-                                  NULL, 0, 0));\n-    }\n-    }\n-    return(NULL);\n-}\n-\n-\/**\n- * xmlExpStringDerive:\n- * @ctxt: the expression context\n- * @exp: the expression\n- * @str: the string\n- * @len: the string len in bytes if available\n- *\n- * Do one step of Brzozowski derivation of the expression @exp with\n- * respect to the input string\n- *\n- * Returns the resulting expression or NULL in case of internal error\n- *\/\n-xmlExpNodePtr\n-xmlExpStringDerive(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp,\n-                   const xmlChar *str, int len) {\n-    const xmlChar *input;\n-\n-    if ((exp == NULL) || (ctxt == NULL) || (str == NULL)) {\n-        return(NULL);\n-    }\n-    \/*\n-     * check the string is in the dictionary, if yes use an interned\n-     * copy, otherwise we know it's not an acceptable input\n-     *\/\n-    input = xmlDictExists(ctxt->dict, str, len);\n-    if (input == NULL) {\n-        return(forbiddenExp);\n-    }\n-    return(xmlExpStringDeriveInt(ctxt, exp, input));\n-}\n-\n-static int\n-xmlExpCheckCard(xmlExpNodePtr exp, xmlExpNodePtr sub) {\n-    int ret = 1;\n-\n-    if (sub->c_max == -1) {\n-        if (exp->c_max != -1)\n-        ret = 0;\n-    } else if ((exp->c_max >= 0) && (exp->c_max < sub->c_max)) {\n-        ret = 0;\n-    }\n-#if 0\n-    if ((IS_NILLABLE(sub)) && (!IS_NILLABLE(exp)))\n-        ret = 0;\n-#endif\n-    return(ret);\n-}\n-\n-static xmlExpNodePtr xmlExpExpDeriveInt(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp,\n-                                        xmlExpNodePtr sub);\n-\/**\n- * xmlExpDivide:\n- * @ctxt: the expressions context\n- * @exp: the englobing expression\n- * @sub: the subexpression\n- * @mult: the multiple expression\n- * @remain: the remain from the derivation of the multiple\n- *\n- * Check if exp is a multiple of sub, i.e. if there is a finite number n\n- * so that sub{n} subsume exp\n- *\n- * Returns the multiple value if successful, 0 if it is not a multiple\n- *         and -1 in case of internal error.\n- *\/\n-\n-static int\n-xmlExpDivide(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp, xmlExpNodePtr sub,\n-             xmlExpNodePtr *mult, xmlExpNodePtr *remain) {\n-    int i;\n-    xmlExpNodePtr tmp, tmp2;\n-\n-    if (mult != NULL) *mult = NULL;\n-    if (remain != NULL) *remain = NULL;\n-    if (exp->c_max == -1) return(0);\n-    if (IS_NILLABLE(exp) && (!IS_NILLABLE(sub))) return(0);\n-\n-    for (i = 1;i <= exp->c_max;i++) {\n-        sub->ref++;\n-        tmp = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT,\n-                 sub, NULL, NULL, i, i);\n-    if (tmp == NULL) {\n-        return(-1);\n-    }\n-    if (!xmlExpCheckCard(tmp, exp)) {\n-        xmlExpFree(ctxt, tmp);\n-        continue;\n-    }\n-    tmp2 = xmlExpExpDeriveInt(ctxt, tmp, exp);\n-    if (tmp2 == NULL) {\n-        xmlExpFree(ctxt, tmp);\n-        return(-1);\n-    }\n-    if ((tmp2 != forbiddenExp) && (IS_NILLABLE(tmp2))) {\n-        if (remain != NULL)\n-            *remain = tmp2;\n-        else\n-            xmlExpFree(ctxt, tmp2);\n-        if (mult != NULL)\n-            *mult = tmp;\n-        else\n-            xmlExpFree(ctxt, tmp);\n-        return(i);\n-    }\n-    xmlExpFree(ctxt, tmp);\n-    xmlExpFree(ctxt, tmp2);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlExpExpDeriveInt:\n- * @ctxt: the expressions context\n- * @exp: the englobing expression\n- * @sub: the subexpression\n- *\n- * Try to do a step of Brzozowski derivation but at a higher level\n- * the input being a subexpression.\n- *\n- * Returns the resulting expression or NULL in case of internal error\n- *\/\n-static xmlExpNodePtr\n-xmlExpExpDeriveInt(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp, xmlExpNodePtr sub) {\n-    xmlExpNodePtr ret, tmp, tmp2, tmp3;\n-    const xmlChar **tab;\n-    int len, i;\n-\n-    \/*\n-     * In case of equality and if the expression can only consume a finite\n-     * amount, then the derivation is empty\n-     *\/\n-    if ((exp == sub) && (exp->c_max >= 0)) {\n-        return(emptyExp);\n-    }\n-    \/*\n-     * decompose sub sequence first\n-     *\/\n-    if (sub->type == XML_EXP_EMPTY) {\n-    exp->ref++;\n-        return(exp);\n-    }\n-    if (sub->type == XML_EXP_SEQ) {\n-        tmp = xmlExpExpDeriveInt(ctxt, exp, sub->exp_left);\n-    if (tmp == NULL)\n-        return(NULL);\n-    if (tmp == forbiddenExp)\n-        return(tmp);\n-    ret = xmlExpExpDeriveInt(ctxt, tmp, sub->exp_right);\n-    xmlExpFree(ctxt, tmp);\n-    return(ret);\n-    }\n-    if (sub->type == XML_EXP_OR) {\n-        tmp = xmlExpExpDeriveInt(ctxt, exp, sub->exp_left);\n-    if (tmp == forbiddenExp)\n-        return(tmp);\n-    if (tmp == NULL)\n-        return(NULL);\n-    ret = xmlExpExpDeriveInt(ctxt, exp, sub->exp_right);\n-    if ((ret == NULL) || (ret == forbiddenExp)) {\n-        xmlExpFree(ctxt, tmp);\n-        return(ret);\n-    }\n-    return(xmlExpHashGetEntry(ctxt, XML_EXP_OR, tmp, ret, NULL, 0, 0));\n-    }\n-    if (!xmlExpCheckCard(exp, sub)) {\n-        return(forbiddenExp);\n-    }\n-    switch (exp->type) {\n-        case XML_EXP_EMPTY:\n-        if (sub == emptyExp)\n-            return(emptyExp);\n-        return(forbiddenExp);\n-        case XML_EXP_FORBID:\n-        return(forbiddenExp);\n-        case XML_EXP_ATOM:\n-        if (sub->type == XML_EXP_ATOM) {\n-            \/* TODO: handle wildcards *\/\n-            if (exp->exp_str == sub->exp_str) {\n-            return(emptyExp);\n-                }\n-            return(forbiddenExp);\n-        }\n-        if ((sub->type == XML_EXP_COUNT) &&\n-            (sub->exp_max == 1) &&\n-            (sub->exp_left->type == XML_EXP_ATOM)) {\n-            \/* TODO: handle wildcards *\/\n-            if (exp->exp_str == sub->exp_left->exp_str) {\n-            return(emptyExp);\n-        }\n-            return(forbiddenExp);\n-        }\n-        return(forbiddenExp);\n-        case XML_EXP_SEQ:\n-        \/* try to get the sequence consumed only if possible *\/\n-        if (xmlExpCheckCard(exp->exp_left, sub)) {\n-        \/* See if the sequence can be consumed directly *\/\n-        ret = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub);\n-        if ((ret != forbiddenExp) && (ret != NULL)) {\n-            \/*\n-             * TODO: assumption here that we are determinist\n-             *       i.e. we won't get to a nillable exp left\n-             *       subset which could be matched by the right\n-             *       part too.\n-             * e.g.: (a | b)+,(a | c) and 'a+,a'\n-             *\/\n-            exp->exp_right->ref++;\n-            return(xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret,\n-                          exp->exp_right, NULL, 0, 0));\n-        }\n-        }\n-        \/* Try instead to decompose *\/\n-        if (sub->type == XML_EXP_COUNT) {\n-        int min, max;\n-\n-            ret = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub->exp_left);\n-        if (ret == NULL)\n-            return(NULL);\n-        if (ret != forbiddenExp) {\n-            if (sub->exp_max < 0)\n-                max = -1;\n-                else\n-                max = sub->exp_max -1;\n-            if (sub->exp_min > 0)\n-                min = sub->exp_min -1;\n-            else\n-                min = 0;\n-            exp->exp_right->ref++;\n-            tmp = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret,\n-                                     exp->exp_right, NULL, 0, 0);\n-            if (tmp == NULL)\n-                return(NULL);\n-\n-            sub->exp_left->ref++;\n-            tmp2 = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT,\n-                      sub->exp_left, NULL, NULL, min, max);\n-            if (tmp2 == NULL) {\n-                xmlExpFree(ctxt, tmp);\n-            return(NULL);\n-            }\n-            ret = xmlExpExpDeriveInt(ctxt, tmp, tmp2);\n-            xmlExpFree(ctxt, tmp);\n-            xmlExpFree(ctxt, tmp2);\n-            return(ret);\n-        }\n-        }\n-        \/* we made no progress on structured operations *\/\n-        break;\n-        case XML_EXP_OR:\n-        ret = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub);\n-        if (ret == NULL)\n-            return(NULL);\n-        tmp = xmlExpExpDeriveInt(ctxt, exp->exp_right, sub);\n-        if (tmp == NULL) {\n-        xmlExpFree(ctxt, ret);\n-            return(NULL);\n-        }\n-        return(xmlExpHashGetEntry(ctxt, XML_EXP_OR, ret, tmp, NULL, 0, 0));\n-        case XML_EXP_COUNT: {\n-        int min, max;\n-\n-        if (sub->type == XML_EXP_COUNT) {\n-            \/*\n-         * Try to see if the loop is completely subsumed\n-         *\/\n-            tmp = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub->exp_left);\n-        if (tmp == NULL)\n-            return(NULL);\n-        if (tmp == forbiddenExp) {\n-            int mult;\n-\n-            mult = xmlExpDivide(ctxt, sub->exp_left, exp->exp_left,\n-                                NULL, &tmp);\n-            if (mult <= 0) {\n-                        return(forbiddenExp);\n-            }\n-            if (sub->exp_max == -1) {\n-                max = -1;\n-            if (exp->exp_max == -1) {\n-                if (exp->exp_min <= sub->exp_min * mult)\n-                    min = 0;\n-                else\n-                    min = exp->exp_min - sub->exp_min * mult;\n-            } else {\n-                            xmlExpFree(ctxt, tmp);\n-                return(forbiddenExp);\n-            }\n-            } else {\n-            if (exp->exp_max == -1) {\n-                if (exp->exp_min > sub->exp_min * mult) {\n-                max = -1;\n-                min = exp->exp_min - sub->exp_min * mult;\n-                } else {\n-                max = -1;\n-                min = 0;\n-                }\n-            } else {\n-                if (exp->exp_max < sub->exp_max * mult) {\n-                xmlExpFree(ctxt, tmp);\n-                return(forbiddenExp);\n-                }\n-                if (sub->exp_max * mult > exp->exp_min)\n-                min = 0;\n-                else\n-                min = exp->exp_min - sub->exp_max * mult;\n-                max = exp->exp_max - sub->exp_max * mult;\n-            }\n-            }\n-        } else if (!IS_NILLABLE(tmp)) {\n-            \/*\n-             * TODO: loop here to try to grow if working on finite\n-             *       blocks.\n-             *\/\n-            xmlExpFree(ctxt, tmp);\n-            return(forbiddenExp);\n-        } else if (sub->exp_max == -1) {\n-            if (exp->exp_max == -1) {\n-                if (exp->exp_min <= sub->exp_min) {\n-                            max = -1;\n-                min = 0;\n-            } else {\n-                            max = -1;\n-                min = exp->exp_min - sub->exp_min;\n-            }\n-            } else if (exp->exp_min > sub->exp_min) {\n-                xmlExpFree(ctxt, tmp);\n-                return(forbiddenExp);\n-            } else {\n-            max = -1;\n-            min = 0;\n-            }\n-        } else {\n-            if (exp->exp_max == -1) {\n-                if (exp->exp_min > sub->exp_min) {\n-                max = -1;\n-                min = exp->exp_min - sub->exp_min;\n-            } else {\n-                max = -1;\n-                min = 0;\n-            }\n-            } else {\n-                if (exp->exp_max < sub->exp_max) {\n-                xmlExpFree(ctxt, tmp);\n-                return(forbiddenExp);\n-            }\n-            if (sub->exp_max > exp->exp_min)\n-                min = 0;\n-            else\n-                min = exp->exp_min - sub->exp_max;\n-            max = exp->exp_max - sub->exp_max;\n-            }\n-        }\n-        exp->exp_left->ref++;\n-        tmp2 = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, exp->exp_left,\n-                                  NULL, NULL, min, max);\n-        if (tmp2 == NULL) {\n-            return(NULL);\n-        }\n-                ret = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, tmp, tmp2,\n-                                 NULL, 0, 0);\n-        return(ret);\n-        }\n-        tmp = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub);\n-        if (tmp == NULL)\n-        return(NULL);\n-        if (tmp == forbiddenExp) {\n-        return(forbiddenExp);\n-        }\n-        if (exp->exp_min > 0)\n-        min = exp->exp_min - 1;\n-        else\n-        min = 0;\n-        if (exp->exp_max < 0)\n-        max = -1;\n-        else\n-        max = exp->exp_max - 1;\n-\n-        exp->exp_left->ref++;\n-        tmp2 = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, exp->exp_left,\n-                      NULL, NULL, min, max);\n-        if (tmp2 == NULL)\n-        return(NULL);\n-        ret = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, tmp, tmp2,\n-                     NULL, 0, 0);\n-        return(ret);\n-    }\n-    }\n-\n-    if (IS_NILLABLE(sub)) {\n-        if (!(IS_NILLABLE(exp)))\n-        return(forbiddenExp);\n-    else\n-        ret = emptyExp;\n-    } else\n-    ret = NULL;\n-    \/*\n-     * here the structured derivation made no progress so\n-     * we use the default token based derivation to force one more step\n-     *\/\n-    if (ctxt->tabSize == 0)\n-        ctxt->tabSize = 40;\n-\n-    tab = (const xmlChar **) xmlMalloc(ctxt->tabSize *\n-                                   sizeof(const xmlChar *));\n-    if (tab == NULL) {\n-    return(NULL);\n-    }\n-\n-    \/*\n-     * collect all the strings accepted by the subexpression on input\n-     *\/\n-    len = xmlExpGetStartInt(ctxt, sub, tab, ctxt->tabSize, 0);\n-    while (len < 0) {\n-        const xmlChar **temp;\n-    temp = (const xmlChar **) xmlRealloc((xmlChar **) tab, ctxt->tabSize * 2 *\n-                                         sizeof(const xmlChar *));\n-    if (temp == NULL) {\n-        xmlFree((xmlChar **) tab);\n-        return(NULL);\n-    }\n-    tab = temp;\n-    ctxt->tabSize *= 2;\n-    len = xmlExpGetStartInt(ctxt, sub, tab, ctxt->tabSize, 0);\n-    }\n-    for (i = 0;i < len;i++) {\n-        tmp = xmlExpStringDeriveInt(ctxt, exp, tab[i]);\n-    if ((tmp == NULL) || (tmp == forbiddenExp)) {\n-        xmlExpFree(ctxt, ret);\n-        xmlFree((xmlChar **) tab);\n-        return(tmp);\n-    }\n-    tmp2 = xmlExpStringDeriveInt(ctxt, sub, tab[i]);\n-    if ((tmp2 == NULL) || (tmp2 == forbiddenExp)) {\n-        xmlExpFree(ctxt, tmp);\n-        xmlExpFree(ctxt, ret);\n-        xmlFree((xmlChar **) tab);\n-        return(tmp);\n-    }\n-    tmp3 = xmlExpExpDeriveInt(ctxt, tmp, tmp2);\n-    xmlExpFree(ctxt, tmp);\n-    xmlExpFree(ctxt, tmp2);\n-\n-    if ((tmp3 == NULL) || (tmp3 == forbiddenExp)) {\n-        xmlExpFree(ctxt, ret);\n-        xmlFree((xmlChar **) tab);\n-        return(tmp3);\n-    }\n-\n-    if (ret == NULL)\n-        ret = tmp3;\n-    else {\n-        ret = xmlExpHashGetEntry(ctxt, XML_EXP_OR, ret, tmp3, NULL, 0, 0);\n-        if (ret == NULL) {\n-        xmlFree((xmlChar **) tab);\n-            return(NULL);\n-        }\n-    }\n-    }\n-    xmlFree((xmlChar **) tab);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlExpExpDerive:\n- * @ctxt: the expressions context\n- * @exp: the englobing expression\n- * @sub: the subexpression\n- *\n- * Evaluates the expression resulting from @exp consuming a sub expression @sub\n- * Based on algebraic derivation and sometimes direct Brzozowski derivation\n- * it usually takes less than linear time and can handle expressions generating\n- * infinite languages.\n- *\n- * Returns the resulting expression or NULL in case of internal error, the\n- *         result must be freed\n- *\/\n-xmlExpNodePtr\n-xmlExpExpDerive(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp, xmlExpNodePtr sub) {\n-    if ((exp == NULL) || (ctxt == NULL) || (sub == NULL))\n-        return(NULL);\n-\n-    \/*\n-     * O(1) speedups\n-     *\/\n-    if (IS_NILLABLE(sub) && (!IS_NILLABLE(exp))) {\n-        return(forbiddenExp);\n-    }\n-    if (xmlExpCheckCard(exp, sub) == 0) {\n-        return(forbiddenExp);\n-    }\n-    return(xmlExpExpDeriveInt(ctxt, exp, sub));\n-}\n-\n-\/**\n- * xmlExpSubsume:\n- * @ctxt: the expressions context\n- * @exp: the englobing expression\n- * @sub: the subexpression\n- *\n- * Check whether @exp accepts all the languages accepted by @sub\n- * the input being a subexpression.\n- *\n- * Returns 1 if true 0 if false and -1 in case of failure.\n- *\/\n-int\n-xmlExpSubsume(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp, xmlExpNodePtr sub) {\n-    xmlExpNodePtr tmp;\n-\n-    if ((exp == NULL) || (ctxt == NULL) || (sub == NULL))\n-        return(-1);\n-\n-    \/*\n-     * TODO: speedup by checking the language of sub is a subset of the\n-     *       language of exp\n-     *\/\n-    \/*\n-     * O(1) speedups\n-     *\/\n-    if (IS_NILLABLE(sub) && (!IS_NILLABLE(exp))) {\n-        return(0);\n-    }\n-    if (xmlExpCheckCard(exp, sub) == 0) {\n-        return(0);\n-    }\n-    tmp = xmlExpExpDeriveInt(ctxt, exp, sub);\n-    if (tmp == NULL)\n-        return(-1);\n-    if (tmp == forbiddenExp)\n-    return(0);\n-    if (tmp == emptyExp)\n-    return(1);\n-    if ((tmp != NULL) && (IS_NILLABLE(tmp))) {\n-        xmlExpFree(ctxt, tmp);\n-        return(1);\n-    }\n-    xmlExpFree(ctxt, tmp);\n-    return(0);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Parsing expression                *\n- *                                    *\n- ************************************************************************\/\n-\n-static xmlExpNodePtr xmlExpParseExpr(xmlExpCtxtPtr ctxt);\n-\n-#undef CUR\n-#define CUR (*ctxt->cur)\n-#undef NEXT\n-#define NEXT ctxt->cur++;\n-#undef IS_BLANK\n-#define IS_BLANK(c) ((c == ' ') || (c == '\\n') || (c == '\\r') || (c == '\\t'))\n-#define SKIP_BLANKS while (IS_BLANK(*ctxt->cur)) ctxt->cur++;\n-\n-static int\n-xmlExpParseNumber(xmlExpCtxtPtr ctxt) {\n-    int ret = 0;\n-\n-    SKIP_BLANKS\n-    if (CUR == '*') {\n-    NEXT\n-    return(-1);\n-    }\n-    if ((CUR < '0') || (CUR > '9'))\n-        return(-1);\n-    while ((CUR >= '0') && (CUR <= '9')) {\n-        ret = ret * 10 + (CUR - '0');\n-    NEXT\n-    }\n-    return(ret);\n-}\n-\n-static xmlExpNodePtr\n-xmlExpParseOr(xmlExpCtxtPtr ctxt) {\n-    const char *base;\n-    xmlExpNodePtr ret;\n-    const xmlChar *val;\n-\n-    SKIP_BLANKS\n-    base = ctxt->cur;\n-    if (*ctxt->cur == '(') {\n-        NEXT\n-    ret = xmlExpParseExpr(ctxt);\n-    SKIP_BLANKS\n-    if (*ctxt->cur != ')') {\n-        fprintf(stderr, \"unbalanced '(' : %s\\n\", base);\n-        xmlExpFree(ctxt, ret);\n-        return(NULL);\n-    }\n-    NEXT;\n-    SKIP_BLANKS\n-    goto parse_quantifier;\n-    }\n-    while ((CUR != 0) && (!(IS_BLANK(CUR))) && (CUR != '(') &&\n-           (CUR != ')') && (CUR != '|') && (CUR != ',') && (CUR != '{') &&\n-       (CUR != '*') && (CUR != '+') && (CUR != '?') && (CUR != '}'))\n-    NEXT;\n-    val = xmlDictLookup(ctxt->dict, BAD_CAST base, ctxt->cur - base);\n-    if (val == NULL)\n-        return(NULL);\n-    ret = xmlExpHashGetEntry(ctxt, XML_EXP_ATOM, NULL, NULL, val, 0, 0);\n-    if (ret == NULL)\n-        return(NULL);\n-    SKIP_BLANKS\n-parse_quantifier:\n-    if (CUR == '{') {\n-        int min, max;\n-\n-        NEXT\n-    min = xmlExpParseNumber(ctxt);\n-    if (min < 0) {\n-        xmlExpFree(ctxt, ret);\n-        return(NULL);\n-    }\n-    SKIP_BLANKS\n-    if (CUR == ',') {\n-        NEXT\n-        max = xmlExpParseNumber(ctxt);\n-        SKIP_BLANKS\n-    } else\n-        max = min;\n-    if (CUR != '}') {\n-        xmlExpFree(ctxt, ret);\n-        return(NULL);\n-    }\n-        NEXT\n-    ret = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, ret, NULL, NULL,\n-                             min, max);\n-    SKIP_BLANKS\n-    } else if (CUR == '?') {\n-        NEXT\n-    ret = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, ret, NULL, NULL,\n-                             0, 1);\n-    SKIP_BLANKS\n-    } else if (CUR == '+') {\n-        NEXT\n-    ret = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, ret, NULL, NULL,\n-                             1, -1);\n-    SKIP_BLANKS\n-    } else if (CUR == '*') {\n-        NEXT\n-    ret = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, ret, NULL, NULL,\n-                             0, -1);\n-    SKIP_BLANKS\n-    }\n-    return(ret);\n-}\n-\n-\n-static xmlExpNodePtr\n-xmlExpParseSeq(xmlExpCtxtPtr ctxt) {\n-    xmlExpNodePtr ret, right;\n-\n-    ret = xmlExpParseOr(ctxt);\n-    SKIP_BLANKS\n-    while (CUR == '|') {\n-        NEXT\n-    right = xmlExpParseOr(ctxt);\n-    if (right == NULL) {\n-        xmlExpFree(ctxt, ret);\n-        return(NULL);\n-    }\n-    ret = xmlExpHashGetEntry(ctxt, XML_EXP_OR, ret, right, NULL, 0, 0);\n-    if (ret == NULL)\n-        return(NULL);\n-    }\n-    return(ret);\n-}\n-\n-static xmlExpNodePtr\n-xmlExpParseExpr(xmlExpCtxtPtr ctxt) {\n-    xmlExpNodePtr ret, right;\n-\n-    ret = xmlExpParseSeq(ctxt);\n-    SKIP_BLANKS\n-    while (CUR == ',') {\n-        NEXT\n-    right = xmlExpParseSeq(ctxt);\n-    if (right == NULL) {\n-        xmlExpFree(ctxt, ret);\n-        return(NULL);\n-    }\n-    ret = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret, right, NULL, 0, 0);\n-    if (ret == NULL)\n-        return(NULL);\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlExpParse:\n- * @ctxt: the expressions context\n- * @expr: the 0 terminated string\n- *\n- * Minimal parser for regexps, it understand the following constructs\n- *  - string terminals\n- *  - choice operator |\n- *  - sequence operator ,\n- *  - subexpressions (...)\n- *  - usual cardinality operators + * and ?\n- *  - finite sequences  { min, max }\n- *  - infinite sequences { min, * }\n- * There is minimal checkings made especially no checking on strings values\n- *\n- * Returns a new expression or NULL in case of failure\n- *\/\n-xmlExpNodePtr\n-xmlExpParse(xmlExpCtxtPtr ctxt, const char *expr) {\n-    xmlExpNodePtr ret;\n-\n-    ctxt->expr = expr;\n-    ctxt->cur = expr;\n-\n-    ret = xmlExpParseExpr(ctxt);\n-    SKIP_BLANKS\n-    if (*ctxt->cur != 0) {\n-        xmlExpFree(ctxt, ret);\n-        return(NULL);\n-    }\n-    return(ret);\n-}\n-\n-static void\n-xmlExpDumpInt(xmlBufferPtr buf, xmlExpNodePtr expr, int glob) {\n-    xmlExpNodePtr c;\n-\n-    if (expr == NULL) return;\n-    if (glob) xmlBufferWriteChar(buf, \"(\");\n-    switch (expr->type) {\n-        case XML_EXP_EMPTY:\n-        xmlBufferWriteChar(buf, \"empty\");\n-        break;\n-        case XML_EXP_FORBID:\n-        xmlBufferWriteChar(buf, \"forbidden\");\n-        break;\n-        case XML_EXP_ATOM:\n-        xmlBufferWriteCHAR(buf, expr->exp_str);\n-        break;\n-        case XML_EXP_SEQ:\n-        c = expr->exp_left;\n-        if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))\n-            xmlExpDumpInt(buf, c, 1);\n-        else\n-            xmlExpDumpInt(buf, c, 0);\n-        xmlBufferWriteChar(buf, \" , \");\n-        c = expr->exp_right;\n-        if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))\n-            xmlExpDumpInt(buf, c, 1);\n-        else\n-            xmlExpDumpInt(buf, c, 0);\n-            break;\n-        case XML_EXP_OR:\n-        c = expr->exp_left;\n-        if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))\n-            xmlExpDumpInt(buf, c, 1);\n-        else\n-            xmlExpDumpInt(buf, c, 0);\n-        xmlBufferWriteChar(buf, \" | \");\n-        c = expr->exp_right;\n-        if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))\n-            xmlExpDumpInt(buf, c, 1);\n-        else\n-            xmlExpDumpInt(buf, c, 0);\n-            break;\n-        case XML_EXP_COUNT: {\n-        char rep[40];\n-\n-        c = expr->exp_left;\n-        if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))\n-            xmlExpDumpInt(buf, c, 1);\n-        else\n-            xmlExpDumpInt(buf, c, 0);\n-        if ((expr->exp_min == 0) && (expr->exp_max == 1)) {\n-        rep[0] = '?';\n-        rep[1] = 0;\n-        } else if ((expr->exp_min == 0) && (expr->exp_max == -1)) {\n-        rep[0] = '*';\n-        rep[1] = 0;\n-        } else if ((expr->exp_min == 1) && (expr->exp_max == -1)) {\n-        rep[0] = '+';\n-        rep[1] = 0;\n-        } else if (expr->exp_max == expr->exp_min) {\n-            snprintf(rep, 39, \"{%d}\", expr->exp_min);\n-        } else if (expr->exp_max < 0) {\n-            snprintf(rep, 39, \"{%d,inf}\", expr->exp_min);\n-        } else {\n-            snprintf(rep, 39, \"{%d,%d}\", expr->exp_min, expr->exp_max);\n-        }\n-        rep[39] = 0;\n-        xmlBufferWriteChar(buf, rep);\n-        break;\n-    }\n-    default:\n-        fprintf(stderr, \"Error in tree\\n\");\n-    }\n-    if (glob)\n-        xmlBufferWriteChar(buf, \")\");\n-}\n-\/**\n- * xmlExpDump:\n- * @buf:  a buffer to receive the output\n- * @expr:  the compiled expression\n- *\n- * Serialize the expression as compiled to the buffer\n- *\/\n-void\n-xmlExpDump(xmlBufferPtr buf, xmlExpNodePtr expr) {\n-    if ((buf == NULL) || (expr == NULL))\n-        return;\n-    xmlExpDumpInt(buf, expr, 0);\n-}\n-\n-\/**\n- * xmlExpMaxToken:\n- * @expr: a compiled expression\n- *\n- * Indicate the maximum number of input a expression can accept\n- *\n- * Returns the maximum length or -1 in case of error\n- *\/\n-int\n-xmlExpMaxToken(xmlExpNodePtr expr) {\n-    if (expr == NULL)\n-        return(-1);\n-    return(expr->c_max);\n-}\n-\n-\/**\n- * xmlExpCtxtNbNodes:\n- * @ctxt: an expression context\n- *\n- * Debugging facility provides the number of allocated nodes at a that point\n- *\n- * Returns the number of nodes in use or -1 in case of error\n- *\/\n-int\n-xmlExpCtxtNbNodes(xmlExpCtxtPtr ctxt) {\n-    if (ctxt == NULL)\n-        return(-1);\n-    return(ctxt->nb_nodes);\n-}\n-\n-\/**\n- * xmlExpCtxtNbCons:\n- * @ctxt: an expression context\n- *\n- * Debugging facility provides the number of allocated nodes over lifetime\n- *\n- * Returns the number of nodes ever allocated or -1 in case of error\n- *\/\n-int\n-xmlExpCtxtNbCons(xmlExpCtxtPtr ctxt) {\n-    if (ctxt == NULL)\n-        return(-1);\n-    return(ctxt->nb_cons);\n-}\n-\n-#endif \/* LIBXML_EXPR_ENABLED *\/\n-\n-#endif \/* LIBXML_REGEXP_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlregexp.c","additions":0,"deletions":8015,"binary":false,"changes":8015,"status":"deleted"},{"patch":"@@ -1,28853 +0,0 @@\n-\/*\n- * schemas.c : implementation of the XML Schema handling and\n- *             schema validity checking\n- *\n- * See Copyright for the status of this software.\n- *\n- * Daniel Veillard <veillard@redhat.com>\n- *\/\n-\n-\/*\n- * TODO:\n- *   - when types are redefined in includes, check that all\n- *     types in the redef list are equal\n- *     -> need a type equality operation.\n- *   - if we don't intend to use the schema for schemas, we\n- *     need to validate all schema attributes (ref, type, name)\n- *     against their types.\n- *   - Eliminate item creation for: ??\n- *\n- * URGENT TODO:\n- *   - For xsi-driven schema acquisition, augment the IDCs after every\n- *     acquisition episode (xmlSchemaAugmentIDC).\n- *\n- * NOTES:\n- *   - Eliminated item creation for: <restriction>, <extension>,\n- *     <simpleContent>, <complexContent>, <list>, <union>\n- *\n- * PROBLEMS:\n- *   - http:\/\/lists.w3.org\/Archives\/Public\/www-xml-schema-comments\/2005JulSep\/0337.html\n- *     IDC XPath expression and chameleon includes: the targetNamespace is changed, so\n- *     XPath will have trouble to resolve to this namespace, since not known.\n- *\n- *\n- * CONSTRAINTS:\n- *\n- * Schema Component Constraint:\n- *   All Group Limited (cos-all-limited)\n- *   Status: complete\n- *   (1.2)\n- *     In xmlSchemaGroupDefReferenceTermFixup() and\n- *   (2)\n- *     In xmlSchemaParseModelGroup()\n- *     TODO: Actually this should go to component-level checks,\n- *     but is done here due to performance. Move it to an other layer\n- *     is schema construction via an API is implemented.\n- *\/\n-\n-\/* To avoid EBCDIC trouble when parsing on zOS *\/\n-#if defined(__MVS__)\n-#pragma convert(\"ISO8859-1\")\n-#endif\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-\n-#include <string.h>\n-#include <libxml\/xmlmemory.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/hash.h>\n-#include <libxml\/uri.h>\n-#include <libxml\/xmlschemas.h>\n-#include <libxml\/schemasInternals.h>\n-#include <libxml\/xmlschemastypes.h>\n-#include <libxml\/xmlautomata.h>\n-#include <libxml\/xmlregexp.h>\n-#include <libxml\/dict.h>\n-#include <libxml\/encoding.h>\n-#include <libxml\/xmlIO.h>\n-#ifdef LIBXML_PATTERN_ENABLED\n-#include <libxml\/pattern.h>\n-#endif\n-#ifdef LIBXML_READER_ENABLED\n-#include <libxml\/xmlreader.h>\n-#endif\n-\n-#include \"private\/error.h\"\n-#include \"private\/string.h\"\n-\n-\/* #define WXS_ELEM_DECL_CONS_ENABLED *\/\n-\n-\/* #define ENABLE_PARTICLE_RESTRICTION 1 *\/\n-\n-#define ENABLE_REDEFINE\n-\n-\/* #define ENABLE_NAMED_LOCALS *\/\n-\n-\/* #define ENABLE_IDC_NODE_TABLES_TEST *\/\n-\n-#define DUMP_CONTENT_MODEL\n-\n-#ifdef LIBXML_READER_ENABLED\n-\/* #define XML_SCHEMA_READER_ENABLED *\/\n-#endif\n-\n-#define UNBOUNDED (1 << 30)\n-\n-#define XML_SCHEMAS_NO_NAMESPACE (const xmlChar *) \"##\"\n-\n-\/*\n- * The XML Schemas namespaces\n- *\/\n-static const xmlChar *xmlSchemaNs = (const xmlChar *)\n-    \"http:\/\/www.w3.org\/2001\/XMLSchema\";\n-\n-static const xmlChar *xmlSchemaInstanceNs = (const xmlChar *)\n-    \"http:\/\/www.w3.org\/2001\/XMLSchema-instance\";\n-\n-static const xmlChar *xmlNamespaceNs = (const xmlChar *)\n-    \"http:\/\/www.w3.org\/2000\/xmlns\/\";\n-\n-\/*\n-* Come casting macros.\n-*\/\n-#define ACTXT_CAST (xmlSchemaAbstractCtxtPtr)\n-#define PCTXT_CAST (xmlSchemaParserCtxtPtr)\n-#define VCTXT_CAST (xmlSchemaValidCtxtPtr)\n-#define WXS_BASIC_CAST (xmlSchemaBasicItemPtr)\n-#define WXS_TREE_CAST (xmlSchemaTreeItemPtr)\n-#define WXS_PTC_CAST (xmlSchemaParticlePtr)\n-#define WXS_TYPE_CAST (xmlSchemaTypePtr)\n-#define WXS_ELEM_CAST (xmlSchemaElementPtr)\n-#define WXS_ATTR_GROUP_CAST (xmlSchemaAttributeGroupPtr)\n-#define WXS_ATTR_CAST (xmlSchemaAttributePtr)\n-#define WXS_ATTR_USE_CAST (xmlSchemaAttributeUsePtr)\n-#define WXS_ATTR_PROHIB_CAST (xmlSchemaAttributeUseProhibPtr)\n-#define WXS_MODEL_GROUPDEF_CAST (xmlSchemaModelGroupDefPtr)\n-#define WXS_MODEL_GROUP_CAST (xmlSchemaModelGroupPtr)\n-#define WXS_IDC_CAST (xmlSchemaIDCPtr)\n-#define WXS_QNAME_CAST (xmlSchemaQNameRefPtr)\n-#define WXS_LIST_CAST (xmlSchemaItemListPtr)\n-\n-\/*\n-* Macros to query common properties of components.\n-*\/\n-#define WXS_ITEM_NODE(i) xmlSchemaGetComponentNode(WXS_BASIC_CAST (i))\n-\n-#define WXS_ITEM_TYPE_NAME(i) xmlSchemaGetComponentTypeStr(WXS_BASIC_CAST (i))\n-\/*\n-* Macros for element declarations.\n-*\/\n-#define WXS_ELEM_TYPEDEF(e) (e)->subtypes\n-\n-#define WXS_SUBST_HEAD(item) (item)->refDecl\n-\/*\n-* Macros for attribute declarations.\n-*\/\n-#define WXS_ATTR_TYPEDEF(a) (a)->subtypes\n-\/*\n-* Macros for attribute uses.\n-*\/\n-#define WXS_ATTRUSE_DECL(au) (WXS_ATTR_USE_CAST (au))->attrDecl\n-\n-#define WXS_ATTRUSE_TYPEDEF(au) WXS_ATTR_TYPEDEF(WXS_ATTRUSE_DECL( WXS_ATTR_USE_CAST au))\n-\n-#define WXS_ATTRUSE_DECL_NAME(au) (WXS_ATTRUSE_DECL(au))->name\n-\n-#define WXS_ATTRUSE_DECL_TNS(au) (WXS_ATTRUSE_DECL(au))->targetNamespace\n-\/*\n-* Macros for attribute groups.\n-*\/\n-#define WXS_ATTR_GROUP_HAS_REFS(ag) ((WXS_ATTR_GROUP_CAST (ag))->flags & XML_SCHEMAS_ATTRGROUP_HAS_REFS)\n-#define WXS_ATTR_GROUP_EXPANDED(ag) ((WXS_ATTR_GROUP_CAST (ag))->flags & XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED)\n-\/*\n-* Macros for particles.\n-*\/\n-#define WXS_PARTICLE(p) WXS_PTC_CAST (p)\n-\n-#define WXS_PARTICLE_TERM(p) (WXS_PARTICLE(p))->children\n-\n-#define WXS_PARTICLE_TERM_AS_ELEM(p) (WXS_ELEM_CAST WXS_PARTICLE_TERM(p))\n-\n-#define WXS_PARTICLE_MODEL(p) WXS_MODEL_GROUP_CAST WXS_PARTICLE(p)->children\n-\/*\n-* Macros for model groups definitions.\n-*\/\n-#define WXS_MODELGROUPDEF_MODEL(mgd) (WXS_MODEL_GROUP_CAST (mgd))->children\n-\/*\n-* Macros for model groups.\n-*\/\n-#define WXS_IS_MODEL_GROUP(i) \\\n-    (((i)->type == XML_SCHEMA_TYPE_SEQUENCE) || \\\n-     ((i)->type == XML_SCHEMA_TYPE_CHOICE) || \\\n-     ((i)->type == XML_SCHEMA_TYPE_ALL))\n-\n-#define WXS_MODELGROUP_PARTICLE(mg) WXS_PTC_CAST (mg)->children\n-\/*\n-* Macros for schema buckets.\n-*\/\n-#define WXS_IS_BUCKET_INCREDEF(t) (((t) == XML_SCHEMA_SCHEMA_INCLUDE) || \\\n-    ((t) == XML_SCHEMA_SCHEMA_REDEFINE))\n-\n-#define WXS_IS_BUCKET_IMPMAIN(t) (((t) == XML_SCHEMA_SCHEMA_MAIN) || \\\n-    ((t) == XML_SCHEMA_SCHEMA_IMPORT))\n-\n-#define WXS_IMPBUCKET(b) ((xmlSchemaImportPtr) (b))\n-\n-#define WXS_INCBUCKET(b) ((xmlSchemaIncludePtr) (b))\n-\/*\n-* Macros for complex\/simple types.\n-*\/\n-#define WXS_IS_ANYTYPE(i) \\\n-     (( (i)->type == XML_SCHEMA_TYPE_BASIC) && \\\n-      ( (WXS_TYPE_CAST (i))->builtInType == XML_SCHEMAS_ANYTYPE))\n-\n-#define WXS_IS_COMPLEX(i) \\\n-    (((i)->type == XML_SCHEMA_TYPE_COMPLEX) || \\\n-     ((i)->builtInType == XML_SCHEMAS_ANYTYPE))\n-\n-#define WXS_IS_SIMPLE(item) \\\n-    ((item->type == XML_SCHEMA_TYPE_SIMPLE) || \\\n-     ((item->type == XML_SCHEMA_TYPE_BASIC) && \\\n-      (item->builtInType != XML_SCHEMAS_ANYTYPE)))\n-\n-#define WXS_IS_ANY_SIMPLE_TYPE(i) \\\n-    (((i)->type == XML_SCHEMA_TYPE_BASIC) && \\\n-      ((i)->builtInType == XML_SCHEMAS_ANYSIMPLETYPE))\n-\n-#define WXS_IS_RESTRICTION(t) \\\n-    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION)\n-\n-#define WXS_IS_EXTENSION(t) \\\n-    ((t)->flags & XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION)\n-\n-#define WXS_IS_TYPE_NOT_FIXED(i) \\\n-    (((i)->type != XML_SCHEMA_TYPE_BASIC) && \\\n-     (((i)->flags & XML_SCHEMAS_TYPE_INTERNAL_RESOLVED) == 0))\n-\n-#define WXS_IS_TYPE_NOT_FIXED_1(item) \\\n-    (((item)->type != XML_SCHEMA_TYPE_BASIC) && \\\n-     (((item)->flags & XML_SCHEMAS_TYPE_FIXUP_1) == 0))\n-\n-#define WXS_TYPE_IS_GLOBAL(t) ((t)->flags & XML_SCHEMAS_TYPE_GLOBAL)\n-\n-#define WXS_TYPE_IS_LOCAL(t) (((t)->flags & XML_SCHEMAS_TYPE_GLOBAL) == 0)\n-\/*\n-* Macros for exclusively for complex types.\n-*\/\n-#define WXS_HAS_COMPLEX_CONTENT(item) \\\n-    ((item->contentType == XML_SCHEMA_CONTENT_MIXED) || \\\n-     (item->contentType == XML_SCHEMA_CONTENT_EMPTY) || \\\n-     (item->contentType == XML_SCHEMA_CONTENT_ELEMENTS))\n-\n-#define WXS_HAS_SIMPLE_CONTENT(item) \\\n-    ((item->contentType == XML_SCHEMA_CONTENT_SIMPLE) || \\\n-     (item->contentType == XML_SCHEMA_CONTENT_BASIC))\n-\n-#define WXS_HAS_MIXED_CONTENT(item) \\\n-    (item->contentType == XML_SCHEMA_CONTENT_MIXED)\n-\n-#define WXS_EMPTIABLE(t) \\\n-    (xmlSchemaIsParticleEmptiable(WXS_PTC_CAST (t)->subtypes))\n-\n-#define WXS_TYPE_CONTENTTYPE(t) (t)->subtypes\n-\n-#define WXS_TYPE_PARTICLE(t) WXS_PTC_CAST (t)->subtypes\n-\n-#define WXS_TYPE_PARTICLE_TERM(t) WXS_PARTICLE_TERM(WXS_TYPE_PARTICLE(t))\n-\/*\n-* Macros for exclusively for simple types.\n-*\/\n-#define WXS_LIST_ITEMTYPE(t) (t)->subtypes\n-\n-#define WXS_IS_ATOMIC(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_ATOMIC)\n-\n-#define WXS_IS_LIST(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_LIST)\n-\n-#define WXS_IS_UNION(t) (t->flags & XML_SCHEMAS_TYPE_VARIETY_UNION)\n-\/*\n-* Misc parser context macros.\n-*\/\n-#define WXS_CONSTRUCTOR(ctx) (ctx)->constructor\n-\n-#define WXS_HAS_BUCKETS(ctx) \\\n-( (WXS_CONSTRUCTOR((ctx))->buckets != NULL) && \\\n-(WXS_CONSTRUCTOR((ctx))->buckets->nbItems > 0) )\n-\n-#define WXS_SUBST_GROUPS(ctx) WXS_CONSTRUCTOR((ctx))->substGroups\n-\n-#define WXS_BUCKET(ctx) WXS_CONSTRUCTOR((ctx))->bucket\n-\n-#define WXS_SCHEMA(ctx) (ctx)->schema\n-\n-#define WXS_ADD_LOCAL(ctx, item) \\\n-    do { \\\n-        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->locals), 10, item) < 0) { \\\n-            xmlFree(item); \\\n-            item = NULL; \\\n-        } \\\n-    } while (0)\n-\n-#define WXS_ADD_GLOBAL(ctx, item) \\\n-    do { \\\n-        if (xmlSchemaAddItemSize(&(WXS_BUCKET(ctx)->globals), 5, item) < 0) { \\\n-            xmlFree(item); \\\n-            item = NULL; \\\n-        } \\\n-    } while (0)\n-\n-#define WXS_ADD_PENDING(ctx, item) \\\n-    xmlSchemaAddItemSize(&((ctx)->constructor->pending), 10, item)\n-\/*\n-* xmlSchemaItemList macros.\n-*\/\n-#define WXS_ILIST_IS_EMPTY(l) ((l == NULL) || ((l)->nbItems == 0))\n-\/*\n-* Misc macros.\n-*\/\n-#define IS_SCHEMA(node, type) \\\n-   ((node != NULL) && (node->ns != NULL) && \\\n-    (xmlStrEqual(node->name, (const xmlChar *) type)) && \\\n-    (xmlStrEqual(node->ns->href, xmlSchemaNs)))\n-\n-#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }\n-\n-\/*\n-* Since we put the default\/fixed values into the dict, we can\n-* use pointer comparison for those values.\n-* REMOVED: (xmlStrEqual((v1), (v2)))\n-*\/\n-#define WXS_ARE_DEFAULT_STR_EQUAL(v1, v2) ((v1) == (v2))\n-\n-#define INODE_NILLED(item) (item->flags & XML_SCHEMA_ELEM_INFO_NILLED)\n-\n-#define CAN_PARSE_SCHEMA(b) (((b)->doc != NULL) && ((b)->parsed == 0))\n-\n-#define HFAILURE if (res == -1) goto exit_failure;\n-\n-#define HERROR if (res != 0) goto exit_error;\n-\n-#define HSTOP(ctx) if ((ctx)->stop) goto exit;\n-\/*\n-* Some flags used for various schema constraints.\n-*\/\n-#define SUBSET_RESTRICTION  1<<0\n-#define SUBSET_EXTENSION    1<<1\n-#define SUBSET_SUBSTITUTION 1<<2\n-#define SUBSET_LIST         1<<3\n-#define SUBSET_UNION        1<<4\n-\n-typedef struct _xmlSchemaNodeInfo xmlSchemaNodeInfo;\n-typedef xmlSchemaNodeInfo *xmlSchemaNodeInfoPtr;\n-\n-typedef struct _xmlSchemaItemList xmlSchemaItemList;\n-typedef xmlSchemaItemList *xmlSchemaItemListPtr;\n-struct _xmlSchemaItemList {\n-    void **items;  \/* used for dynamic addition of schemata *\/\n-    int nbItems; \/* used for dynamic addition of schemata *\/\n-    int sizeItems; \/* used for dynamic addition of schemata *\/\n-};\n-\n-#define XML_SCHEMA_CTXT_PARSER 1\n-#define XML_SCHEMA_CTXT_VALIDATOR 2\n-\n-typedef struct _xmlSchemaAbstractCtxt xmlSchemaAbstractCtxt;\n-typedef xmlSchemaAbstractCtxt *xmlSchemaAbstractCtxtPtr;\n-struct _xmlSchemaAbstractCtxt {\n-    int type; \/* E.g. XML_SCHEMA_CTXT_VALIDATOR *\/\n-    void *dummy; \/* Fix alignment issues *\/\n-};\n-\n-typedef struct _xmlSchemaBucket xmlSchemaBucket;\n-typedef xmlSchemaBucket *xmlSchemaBucketPtr;\n-\n-#define XML_SCHEMA_SCHEMA_MAIN 0\n-#define XML_SCHEMA_SCHEMA_IMPORT 1\n-#define XML_SCHEMA_SCHEMA_INCLUDE 2\n-#define XML_SCHEMA_SCHEMA_REDEFINE 3\n-\n-\/**\n- * xmlSchemaSchemaRelation:\n- *\n- * Used to create a graph of schema relationships.\n- *\/\n-typedef struct _xmlSchemaSchemaRelation xmlSchemaSchemaRelation;\n-typedef xmlSchemaSchemaRelation *xmlSchemaSchemaRelationPtr;\n-struct _xmlSchemaSchemaRelation {\n-    xmlSchemaSchemaRelationPtr next;\n-    int type; \/* E.g. XML_SCHEMA_SCHEMA_IMPORT *\/\n-    const xmlChar *importNamespace;\n-    xmlSchemaBucketPtr bucket;\n-};\n-\n-#define XML_SCHEMA_BUCKET_MARKED 1<<0\n-#define XML_SCHEMA_BUCKET_COMPS_ADDED 1<<1\n-\n-struct _xmlSchemaBucket {\n-    int type;\n-    int flags;\n-    const xmlChar *schemaLocation;\n-    const xmlChar *origTargetNamespace;\n-    const xmlChar *targetNamespace;\n-    xmlDocPtr doc;\n-    xmlSchemaSchemaRelationPtr relations;\n-    int located;\n-    int parsed;\n-    int imported;\n-    int preserveDoc;\n-    xmlSchemaItemListPtr globals; \/* Global components. *\/\n-    xmlSchemaItemListPtr locals; \/* Local components. *\/\n-};\n-\n-\/**\n- * xmlSchemaImport:\n- * (extends xmlSchemaBucket)\n- *\n- * Reflects a schema. Holds some information\n- * about the schema and its toplevel components. Duplicate\n- * toplevel components are not checked at this level.\n- *\/\n-typedef struct _xmlSchemaImport xmlSchemaImport;\n-typedef xmlSchemaImport *xmlSchemaImportPtr;\n-struct _xmlSchemaImport {\n-    int type; \/* Main OR import OR include. *\/\n-    int flags;\n-    const xmlChar *schemaLocation; \/* The URI of the schema document. *\/\n-    \/* For chameleon includes, @origTargetNamespace will be NULL *\/\n-    const xmlChar *origTargetNamespace;\n-    \/*\n-    * For chameleon includes, @targetNamespace will be the\n-    * targetNamespace of the including schema.\n-    *\/\n-    const xmlChar *targetNamespace;\n-    xmlDocPtr doc; \/* The schema node-tree. *\/\n-    \/* @relations will hold any included\/imported\/redefined schemas. *\/\n-    xmlSchemaSchemaRelationPtr relations;\n-    int located;\n-    int parsed;\n-    int imported;\n-    int preserveDoc;\n-    xmlSchemaItemListPtr globals;\n-    xmlSchemaItemListPtr locals;\n-    \/* The imported schema. *\/\n-    xmlSchemaPtr schema;\n-};\n-\n-\/*\n-* (extends xmlSchemaBucket)\n-*\/\n-typedef struct _xmlSchemaInclude xmlSchemaInclude;\n-typedef xmlSchemaInclude *xmlSchemaIncludePtr;\n-struct _xmlSchemaInclude {\n-    int type;\n-    int flags;\n-    const xmlChar *schemaLocation;\n-    const xmlChar *origTargetNamespace;\n-    const xmlChar *targetNamespace;\n-    xmlDocPtr doc;\n-    xmlSchemaSchemaRelationPtr relations;\n-    int located;\n-    int parsed;\n-    int imported;\n-    int preserveDoc;\n-    xmlSchemaItemListPtr globals; \/* Global components. *\/\n-    xmlSchemaItemListPtr locals; \/* Local components. *\/\n-\n-    \/* The owning main or import schema bucket. *\/\n-    xmlSchemaImportPtr ownerImport;\n-};\n-\n-\/**\n- * xmlSchemaBasicItem:\n- *\n- * The abstract base type for schema components.\n- *\/\n-typedef struct _xmlSchemaBasicItem xmlSchemaBasicItem;\n-typedef xmlSchemaBasicItem *xmlSchemaBasicItemPtr;\n-struct _xmlSchemaBasicItem {\n-    xmlSchemaTypeType type;\n-    void *dummy; \/* Fix alignment issues *\/\n-};\n-\n-\/**\n- * xmlSchemaAnnotItem:\n- *\n- * The abstract base type for annotated schema components.\n- * (Extends xmlSchemaBasicItem)\n- *\/\n-typedef struct _xmlSchemaAnnotItem xmlSchemaAnnotItem;\n-typedef xmlSchemaAnnotItem *xmlSchemaAnnotItemPtr;\n-struct _xmlSchemaAnnotItem {\n-    xmlSchemaTypeType type;\n-    xmlSchemaAnnotPtr annot;\n-};\n-\n-\/**\n- * xmlSchemaTreeItem:\n- *\n- * The abstract base type for tree-like structured schema components.\n- * (Extends xmlSchemaAnnotItem)\n- *\/\n-typedef struct _xmlSchemaTreeItem xmlSchemaTreeItem;\n-typedef xmlSchemaTreeItem *xmlSchemaTreeItemPtr;\n-struct _xmlSchemaTreeItem {\n-    xmlSchemaTypeType type;\n-    xmlSchemaAnnotPtr annot;\n-    xmlSchemaTreeItemPtr next;\n-    xmlSchemaTreeItemPtr children;\n-};\n-\n-\n-#define XML_SCHEMA_ATTR_USE_FIXED 1<<0\n-\/**\n- * xmlSchemaAttributeUsePtr:\n- *\n- * The abstract base type for tree-like structured schema components.\n- * (Extends xmlSchemaTreeItem)\n- *\/\n-typedef struct _xmlSchemaAttributeUse xmlSchemaAttributeUse;\n-typedef xmlSchemaAttributeUse *xmlSchemaAttributeUsePtr;\n-struct _xmlSchemaAttributeUse {\n-    xmlSchemaTypeType type;\n-    xmlSchemaAnnotPtr annot;\n-    xmlSchemaAttributeUsePtr next; \/* The next attr. use. *\/\n-    \/*\n-    * The attr. decl. OR a QName-ref. to an attr. decl. OR\n-    * a QName-ref. to an attribute group definition.\n-    *\/\n-    xmlSchemaAttributePtr attrDecl;\n-\n-    int flags;\n-    xmlNodePtr node;\n-    int occurs; \/* required, optional *\/\n-    const xmlChar * defValue;\n-    xmlSchemaValPtr defVal;\n-};\n-\n-\/**\n- * xmlSchemaAttributeUseProhibPtr:\n- *\n- * A helper component to reflect attribute prohibitions.\n- * (Extends xmlSchemaBasicItem)\n- *\/\n-typedef struct _xmlSchemaAttributeUseProhib xmlSchemaAttributeUseProhib;\n-typedef xmlSchemaAttributeUseProhib *xmlSchemaAttributeUseProhibPtr;\n-struct _xmlSchemaAttributeUseProhib {\n-    xmlSchemaTypeType type; \/* == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB *\/\n-    xmlNodePtr node;\n-    const xmlChar *name;\n-    const xmlChar *targetNamespace;\n-    int isRef;\n-};\n-\n-\/**\n- * xmlSchemaRedef:\n- *\/\n-typedef struct _xmlSchemaRedef xmlSchemaRedef;\n-typedef xmlSchemaRedef *xmlSchemaRedefPtr;\n-struct _xmlSchemaRedef {\n-    xmlSchemaRedefPtr next;\n-    xmlSchemaBasicItemPtr item; \/* The redefining component. *\/\n-    xmlSchemaBasicItemPtr reference; \/* The referencing component. *\/\n-    xmlSchemaBasicItemPtr target; \/* The to-be-redefined component. *\/\n-    const xmlChar *refName; \/* The name of the to-be-redefined component. *\/\n-    const xmlChar *refTargetNs; \/* The target namespace of the\n-                                   to-be-redefined comp. *\/\n-    xmlSchemaBucketPtr targetBucket; \/* The redefined schema. *\/\n-};\n-\n-\/**\n- * xmlSchemaConstructionCtxt:\n- *\/\n-typedef struct _xmlSchemaConstructionCtxt xmlSchemaConstructionCtxt;\n-typedef xmlSchemaConstructionCtxt *xmlSchemaConstructionCtxtPtr;\n-struct _xmlSchemaConstructionCtxt {\n-    xmlSchemaPtr mainSchema; \/* The main schema. *\/\n-    xmlSchemaBucketPtr mainBucket; \/* The main schema bucket *\/\n-    xmlDictPtr dict;\n-    xmlSchemaItemListPtr buckets; \/* List of schema buckets. *\/\n-    \/* xmlSchemaItemListPtr relations; *\/ \/* List of schema relations. *\/\n-    xmlSchemaBucketPtr bucket; \/* The current schema bucket *\/\n-    xmlSchemaItemListPtr pending; \/* All Components of all schemas that\n-                                     need to be fixed. *\/\n-    xmlHashTablePtr substGroups;\n-    xmlSchemaRedefPtr redefs;\n-    xmlSchemaRedefPtr lastRedef;\n-};\n-\n-#define XML_SCHEMAS_PARSE_ERROR        1\n-#define SCHEMAS_PARSE_OPTIONS XML_PARSE_NOENT\n-\n-struct _xmlSchemaParserCtxt {\n-    int type;\n-    void *errCtxt;             \/* user specific error context *\/\n-    xmlSchemaValidityErrorFunc error;   \/* the callback in case of errors *\/\n-    xmlSchemaValidityWarningFunc warning;       \/* the callback in case of warning *\/\n-    int err;\n-    int nberrors;\n-    xmlStructuredErrorFunc serror;\n-\n-    xmlSchemaConstructionCtxtPtr constructor;\n-    int ownsConstructor; \/* TODO: Move this to parser *flags*. *\/\n-\n-    \/* xmlSchemaPtr topschema;    *\/\n-    \/* xmlHashTablePtr namespaces;  *\/\n-\n-    xmlSchemaPtr schema;        \/* The main schema in use *\/\n-    int counter;\n-\n-    const xmlChar *URL;\n-    xmlDocPtr doc;\n-    int preserve;        \/* Whether the doc should be freed  *\/\n-\n-    const char *buffer;\n-    int size;\n-\n-    \/*\n-     * Used to build complex element content models\n-     *\/\n-    xmlAutomataPtr am;\n-    xmlAutomataStatePtr start;\n-    xmlAutomataStatePtr end;\n-    xmlAutomataStatePtr state;\n-\n-    xmlDictPtr dict;        \/* dictionary for interned string names *\/\n-    xmlSchemaTypePtr ctxtType; \/* The current context simple\/complex type *\/\n-    int options;\n-    xmlSchemaValidCtxtPtr vctxt;\n-    int isS4S;\n-    int isRedefine;\n-    int xsiAssemble;\n-    int stop; \/* If the parser should stop; i.e. a critical error. *\/\n-    const xmlChar *targetNamespace;\n-    xmlSchemaBucketPtr redefined; \/* The schema to be redefined. *\/\n-\n-    xmlSchemaRedefPtr redef; \/* Used for redefinitions. *\/\n-    int redefCounter; \/* Used for redefinitions. *\/\n-    xmlSchemaItemListPtr attrProhibs;\n-};\n-\n-\/**\n- * xmlSchemaQNameRef:\n- *\n- * A component reference item (not a schema component)\n- * (Extends xmlSchemaBasicItem)\n- *\/\n-typedef struct _xmlSchemaQNameRef xmlSchemaQNameRef;\n-typedef xmlSchemaQNameRef *xmlSchemaQNameRefPtr;\n-struct _xmlSchemaQNameRef {\n-    xmlSchemaTypeType type;\n-    xmlSchemaBasicItemPtr item; \/* The resolved referenced item. *\/\n-    xmlSchemaTypeType itemType;\n-    const xmlChar *name;\n-    const xmlChar *targetNamespace;\n-    xmlNodePtr node;\n-};\n-\n-\/**\n- * xmlSchemaParticle:\n- *\n- * A particle component.\n- * (Extends xmlSchemaTreeItem)\n- *\/\n-typedef struct _xmlSchemaParticle xmlSchemaParticle;\n-typedef xmlSchemaParticle *xmlSchemaParticlePtr;\n-struct _xmlSchemaParticle {\n-    xmlSchemaTypeType type;\n-    xmlSchemaAnnotPtr annot;\n-    xmlSchemaTreeItemPtr next; \/* next particle *\/\n-    xmlSchemaTreeItemPtr children; \/* the \"term\" (e.g. a model group,\n-    a group definition, a XML_SCHEMA_EXTRA_QNAMEREF (if a reference),\n-        etc.) *\/\n-    int minOccurs;\n-    int maxOccurs;\n-    xmlNodePtr node;\n-};\n-\n-\/**\n- * xmlSchemaModelGroup:\n- *\n- * A model group component.\n- * (Extends xmlSchemaTreeItem)\n- *\/\n-typedef struct _xmlSchemaModelGroup xmlSchemaModelGroup;\n-typedef xmlSchemaModelGroup *xmlSchemaModelGroupPtr;\n-struct _xmlSchemaModelGroup {\n-    xmlSchemaTypeType type; \/* XML_SCHEMA_TYPE_SEQUENCE, XML_SCHEMA_TYPE_CHOICE, XML_SCHEMA_TYPE_ALL *\/\n-    xmlSchemaAnnotPtr annot;\n-    xmlSchemaTreeItemPtr next; \/* not used *\/\n-    xmlSchemaTreeItemPtr children; \/* first particle (OR \"element decl\" OR \"wildcard\") *\/\n-    xmlNodePtr node;\n-};\n-\n-#define XML_SCHEMA_MODEL_GROUP_DEF_MARKED 1<<0\n-#define XML_SCHEMA_MODEL_GROUP_DEF_REDEFINED 1<<1\n-\/**\n- * xmlSchemaModelGroupDef:\n- *\n- * A model group definition component.\n- * (Extends xmlSchemaTreeItem)\n- *\/\n-typedef struct _xmlSchemaModelGroupDef xmlSchemaModelGroupDef;\n-typedef xmlSchemaModelGroupDef *xmlSchemaModelGroupDefPtr;\n-struct _xmlSchemaModelGroupDef {\n-    xmlSchemaTypeType type; \/* XML_SCHEMA_TYPE_GROUP *\/\n-    xmlSchemaAnnotPtr annot;\n-    xmlSchemaTreeItemPtr next; \/* not used *\/\n-    xmlSchemaTreeItemPtr children; \/* the \"model group\" *\/\n-    const xmlChar *name;\n-    const xmlChar *targetNamespace;\n-    xmlNodePtr node;\n-    int flags;\n-};\n-\n-typedef struct _xmlSchemaIDC xmlSchemaIDC;\n-typedef xmlSchemaIDC *xmlSchemaIDCPtr;\n-\n-\/**\n- * xmlSchemaIDCSelect:\n- *\n- * The identity-constraint \"field\" and \"selector\" item, holding the\n- * XPath expression.\n- *\/\n-typedef struct _xmlSchemaIDCSelect xmlSchemaIDCSelect;\n-typedef xmlSchemaIDCSelect *xmlSchemaIDCSelectPtr;\n-struct _xmlSchemaIDCSelect {\n-    xmlSchemaIDCSelectPtr next;\n-    xmlSchemaIDCPtr idc;\n-    int index; \/* an index position if significant for IDC key-sequences *\/\n-    const xmlChar *xpath; \/* the XPath expression *\/\n-    void *xpathComp; \/* the compiled XPath expression *\/\n-};\n-\n-\/**\n- * xmlSchemaIDC:\n- *\n- * The identity-constraint definition component.\n- * (Extends xmlSchemaAnnotItem)\n- *\/\n-\n-struct _xmlSchemaIDC {\n-    xmlSchemaTypeType type;\n-    xmlSchemaAnnotPtr annot;\n-    xmlSchemaIDCPtr next;\n-    xmlNodePtr node;\n-    const xmlChar *name;\n-    const xmlChar *targetNamespace;\n-    xmlSchemaIDCSelectPtr selector;\n-    xmlSchemaIDCSelectPtr fields;\n-    int nbFields;\n-    xmlSchemaQNameRefPtr ref;\n-};\n-\n-\/**\n- * xmlSchemaIDCAug:\n- *\n- * The augmented IDC information used for validation.\n- *\/\n-typedef struct _xmlSchemaIDCAug xmlSchemaIDCAug;\n-typedef xmlSchemaIDCAug *xmlSchemaIDCAugPtr;\n-struct _xmlSchemaIDCAug {\n-    xmlSchemaIDCAugPtr next; \/* next in a list *\/\n-    xmlSchemaIDCPtr def; \/* the IDC definition *\/\n-    int keyrefDepth; \/* the lowest tree level to which IDC\n-                        tables need to be bubbled upwards *\/\n-};\n-\n-\/**\n- * xmlSchemaPSVIIDCKeySequence:\n- *\n- * The key sequence of a node table item.\n- *\/\n-typedef struct _xmlSchemaPSVIIDCKey xmlSchemaPSVIIDCKey;\n-typedef xmlSchemaPSVIIDCKey *xmlSchemaPSVIIDCKeyPtr;\n-struct _xmlSchemaPSVIIDCKey {\n-    xmlSchemaTypePtr type;\n-    xmlSchemaValPtr val;\n-};\n-\n-\/**\n- * xmlSchemaPSVIIDCNode:\n- *\n- * The node table item of a node table.\n- *\/\n-typedef struct _xmlSchemaPSVIIDCNode xmlSchemaPSVIIDCNode;\n-typedef xmlSchemaPSVIIDCNode *xmlSchemaPSVIIDCNodePtr;\n-struct _xmlSchemaPSVIIDCNode {\n-    xmlNodePtr node;\n-    xmlSchemaPSVIIDCKeyPtr *keys;\n-    int nodeLine;\n-    int nodeQNameID;\n-\n-};\n-\n-\/**\n- * xmlSchemaPSVIIDCBinding:\n- *\n- * The identity-constraint binding item of the [identity-constraint table].\n- *\/\n-typedef struct _xmlSchemaPSVIIDCBinding xmlSchemaPSVIIDCBinding;\n-typedef xmlSchemaPSVIIDCBinding *xmlSchemaPSVIIDCBindingPtr;\n-struct _xmlSchemaPSVIIDCBinding {\n-    xmlSchemaPSVIIDCBindingPtr next; \/* next binding of a specific node *\/\n-    xmlSchemaIDCPtr definition; \/* the IDC definition *\/\n-    xmlSchemaPSVIIDCNodePtr *nodeTable; \/* array of key-sequences *\/\n-    int nbNodes; \/* number of entries in the node table *\/\n-    int sizeNodes; \/* size of the node table *\/\n-    xmlSchemaItemListPtr dupls;\n-};\n-\n-\n-#define XPATH_STATE_OBJ_TYPE_IDC_SELECTOR 1\n-#define XPATH_STATE_OBJ_TYPE_IDC_FIELD 2\n-\n-#define XPATH_STATE_OBJ_MATCHES -2\n-#define XPATH_STATE_OBJ_BLOCKED -3\n-\n-typedef struct _xmlSchemaIDCMatcher xmlSchemaIDCMatcher;\n-typedef xmlSchemaIDCMatcher *xmlSchemaIDCMatcherPtr;\n-\n-\/**\n- * xmlSchemaIDCStateObj:\n- *\n- * The state object used to evaluate XPath expressions.\n- *\/\n-typedef struct _xmlSchemaIDCStateObj xmlSchemaIDCStateObj;\n-typedef xmlSchemaIDCStateObj *xmlSchemaIDCStateObjPtr;\n-struct _xmlSchemaIDCStateObj {\n-    int type;\n-    xmlSchemaIDCStateObjPtr next; \/* next if in a list *\/\n-    int depth; \/* depth of creation *\/\n-    int *history; \/* list of (depth, state-id) tuples *\/\n-    int nbHistory;\n-    int sizeHistory;\n-    xmlSchemaIDCMatcherPtr matcher; \/* the correspondent field\/selector\n-                                       matcher *\/\n-    xmlSchemaIDCSelectPtr sel;\n-    void *xpathCtxt;\n-};\n-\n-#define IDC_MATCHER 0\n-\n-\/**\n- * xmlSchemaIDCMatcher:\n- *\n- * Used to evaluate IDC selectors (and fields).\n- *\/\n-struct _xmlSchemaIDCMatcher {\n-    int type;\n-    int depth; \/* the tree depth at creation time *\/\n-    xmlSchemaIDCMatcherPtr next; \/* next in the list *\/\n-    xmlSchemaIDCMatcherPtr nextCached; \/* next in the cache list *\/\n-    xmlSchemaIDCAugPtr aidc; \/* the augmented IDC item *\/\n-    int idcType;\n-    xmlSchemaPSVIIDCKeyPtr **keySeqs; \/* the key-sequences of the target\n-                                         elements *\/\n-    int sizeKeySeqs;\n-    xmlSchemaItemListPtr targets; \/* list of target-node\n-                                     (xmlSchemaPSVIIDCNodePtr) entries *\/\n-    xmlHashTablePtr htab;\n-};\n-\n-\/*\n-* Element info flags.\n-*\/\n-#define XML_SCHEMA_NODE_INFO_FLAG_OWNED_NAMES  1<<0\n-#define XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES 1<<1\n-#define XML_SCHEMA_ELEM_INFO_NILLED           1<<2\n-#define XML_SCHEMA_ELEM_INFO_LOCAL_TYPE           1<<3\n-\n-#define XML_SCHEMA_NODE_INFO_VALUE_NEEDED      1<<4\n-#define XML_SCHEMA_ELEM_INFO_EMPTY             1<<5\n-#define XML_SCHEMA_ELEM_INFO_HAS_CONTENT       1<<6\n-\n-#define XML_SCHEMA_ELEM_INFO_HAS_ELEM_CONTENT  1<<7\n-#define XML_SCHEMA_ELEM_INFO_ERR_BAD_CONTENT  1<<8\n-#define XML_SCHEMA_NODE_INFO_ERR_NOT_EXPECTED  1<<9\n-#define XML_SCHEMA_NODE_INFO_ERR_BAD_TYPE  1<<10\n-\n-\/**\n- * xmlSchemaNodeInfo:\n- *\n- * Holds information of an element node.\n- *\/\n-struct _xmlSchemaNodeInfo {\n-    int nodeType;\n-    xmlNodePtr node;\n-    int nodeLine;\n-    const xmlChar *localName;\n-    const xmlChar *nsName;\n-    const xmlChar *value;\n-    xmlSchemaValPtr val; \/* the pre-computed value if any *\/\n-    xmlSchemaTypePtr typeDef; \/* the complex\/simple type definition if any *\/\n-\n-    int flags; \/* combination of node info flags *\/\n-\n-    int valNeeded;\n-    int normVal;\n-\n-    xmlSchemaElementPtr decl; \/* the element\/attribute declaration *\/\n-    int depth;\n-    xmlSchemaPSVIIDCBindingPtr idcTable; \/* the table of PSVI IDC bindings\n-                                            for the scope element*\/\n-    xmlSchemaIDCMatcherPtr idcMatchers; \/* the IDC matchers for the scope\n-                                           element *\/\n-    xmlRegExecCtxtPtr regexCtxt;\n-\n-    const xmlChar **nsBindings; \/* Namespace bindings on this element *\/\n-    int nbNsBindings;\n-    int sizeNsBindings;\n-\n-    int hasKeyrefs;\n-    int appliedXPath; \/* Indicates that an XPath has been applied. *\/\n-};\n-\n-#define XML_SCHEMAS_ATTR_UNKNOWN 1\n-#define XML_SCHEMAS_ATTR_ASSESSED 2\n-#define XML_SCHEMAS_ATTR_PROHIBITED 3\n-#define XML_SCHEMAS_ATTR_ERR_MISSING 4\n-#define XML_SCHEMAS_ATTR_INVALID_VALUE 5\n-#define XML_SCHEMAS_ATTR_ERR_NO_TYPE 6\n-#define XML_SCHEMAS_ATTR_ERR_FIXED_VALUE 7\n-#define XML_SCHEMAS_ATTR_DEFAULT 8\n-#define XML_SCHEMAS_ATTR_VALIDATE_VALUE 9\n-#define XML_SCHEMAS_ATTR_ERR_WILD_STRICT_NO_DECL 10\n-#define XML_SCHEMAS_ATTR_HAS_ATTR_USE 11\n-#define XML_SCHEMAS_ATTR_HAS_ATTR_DECL 12\n-#define XML_SCHEMAS_ATTR_WILD_SKIP 13\n-#define XML_SCHEMAS_ATTR_WILD_LAX_NO_DECL 14\n-#define XML_SCHEMAS_ATTR_ERR_WILD_DUPLICATE_ID 15\n-#define XML_SCHEMAS_ATTR_ERR_WILD_AND_USE_ID 16\n-#define XML_SCHEMAS_ATTR_META 17\n-\/*\n-* @metaType values of xmlSchemaAttrInfo.\n-*\/\n-#define XML_SCHEMA_ATTR_INFO_META_XSI_TYPE 1\n-#define XML_SCHEMA_ATTR_INFO_META_XSI_NIL 2\n-#define XML_SCHEMA_ATTR_INFO_META_XSI_SCHEMA_LOC 3\n-#define XML_SCHEMA_ATTR_INFO_META_XSI_NO_NS_SCHEMA_LOC 4\n-#define XML_SCHEMA_ATTR_INFO_META_XMLNS 5\n-\n-typedef struct _xmlSchemaAttrInfo xmlSchemaAttrInfo;\n-typedef xmlSchemaAttrInfo *xmlSchemaAttrInfoPtr;\n-struct _xmlSchemaAttrInfo {\n-    int nodeType;\n-    xmlNodePtr node;\n-    int nodeLine;\n-    const xmlChar *localName;\n-    const xmlChar *nsName;\n-    const xmlChar *value;\n-    xmlSchemaValPtr val; \/* the pre-computed value if any *\/\n-    xmlSchemaTypePtr typeDef; \/* the complex\/simple type definition if any *\/\n-    int flags; \/* combination of node info flags *\/\n-\n-    xmlSchemaAttributePtr decl; \/* the attribute declaration *\/\n-    xmlSchemaAttributeUsePtr use;  \/* the attribute use *\/\n-    int state;\n-    int metaType;\n-    const xmlChar *vcValue; \/* the value constraint value *\/\n-    xmlSchemaNodeInfoPtr parent;\n-};\n-\n-\n-#define XML_SCHEMA_VALID_CTXT_FLAG_STREAM 1\n-\/**\n- * xmlSchemaValidCtxt:\n- *\n- * A Schemas validation context\n- *\/\n-struct _xmlSchemaValidCtxt {\n-    int type;\n-    void *errCtxt;             \/* user specific data block *\/\n-    xmlSchemaValidityErrorFunc error;   \/* the callback in case of errors *\/\n-    xmlSchemaValidityWarningFunc warning; \/* the callback in case of warning *\/\n-    xmlStructuredErrorFunc serror;\n-\n-    xmlSchemaPtr schema;        \/* The schema in use *\/\n-    xmlDocPtr doc;\n-    xmlParserInputBufferPtr input;\n-    xmlCharEncoding enc;\n-    xmlSAXHandlerPtr sax;\n-    xmlParserCtxtPtr parserCtxt;\n-    void *user_data; \/* TODO: What is this for? *\/\n-    char *filename;\n-\n-    int err;\n-    int nberrors;\n-\n-    xmlNodePtr node;\n-    xmlNodePtr cur;\n-    \/* xmlSchemaTypePtr type; *\/\n-\n-    xmlRegExecCtxtPtr regexp;\n-    xmlSchemaValPtr value;\n-\n-    int valueWS;\n-    int options;\n-    xmlNodePtr validationRoot;\n-    xmlSchemaParserCtxtPtr pctxt;\n-    int xsiAssemble;\n-\n-    int depth;\n-    xmlSchemaNodeInfoPtr *elemInfos; \/* array of element information *\/\n-    int sizeElemInfos;\n-    xmlSchemaNodeInfoPtr inode; \/* the current element information *\/\n-\n-    xmlSchemaIDCAugPtr aidcs; \/* a list of augmented IDC information *\/\n-\n-    xmlSchemaIDCStateObjPtr xpathStates; \/* first active state object. *\/\n-    xmlSchemaIDCStateObjPtr xpathStatePool; \/* first stored state object. *\/\n-    xmlSchemaIDCMatcherPtr idcMatcherCache; \/* Cache for IDC matcher objects. *\/\n-\n-    xmlSchemaPSVIIDCNodePtr *idcNodes; \/* list of all IDC node-table entries*\/\n-    int nbIdcNodes;\n-    int sizeIdcNodes;\n-\n-    xmlSchemaPSVIIDCKeyPtr *idcKeys; \/* list of all IDC node-table entries *\/\n-    int nbIdcKeys;\n-    int sizeIdcKeys;\n-\n-    int flags;\n-\n-    xmlDictPtr dict;\n-\n-#ifdef LIBXML_READER_ENABLED\n-    xmlTextReaderPtr reader;\n-#endif\n-\n-    xmlSchemaAttrInfoPtr *attrInfos;\n-    int nbAttrInfos;\n-    int sizeAttrInfos;\n-\n-    int skipDepth;\n-    xmlSchemaItemListPtr nodeQNames;\n-    int hasKeyrefs;\n-    int createIDCNodeTables;\n-    int psviExposeIDCNodeTables;\n-\n-    \/* Locator for error reporting in streaming mode *\/\n-    xmlSchemaValidityLocatorFunc locFunc;\n-    void *locCtxt;\n-};\n-\n-\/**\n- * xmlSchemaSubstGroup:\n- *\n- *\n- *\/\n-typedef struct _xmlSchemaSubstGroup xmlSchemaSubstGroup;\n-typedef xmlSchemaSubstGroup *xmlSchemaSubstGroupPtr;\n-struct _xmlSchemaSubstGroup {\n-    xmlSchemaElementPtr head;\n-    xmlSchemaItemListPtr members;\n-};\n-\n-\/**\n- * xmlIDCHashEntry:\n- *\n- * an entry in hash tables to quickly look up keys\/uniques\n- *\/\n-typedef struct _xmlIDCHashEntry xmlIDCHashEntry;\n-typedef xmlIDCHashEntry *xmlIDCHashEntryPtr;\n-struct _xmlIDCHashEntry {\n-    xmlIDCHashEntryPtr next; \/* next item with same hash *\/\n-    int index;               \/* index into associated item list *\/\n-};\n-\n-\/************************************************************************\n- *                                    *\n- *            Some predeclarations                *\n- *                                    *\n- ************************************************************************\/\n-\n-static int xmlSchemaParseInclude(xmlSchemaParserCtxtPtr ctxt,\n-                                 xmlSchemaPtr schema,\n-                                 xmlNodePtr node);\n-static int xmlSchemaParseRedefine(xmlSchemaParserCtxtPtr ctxt,\n-                                 xmlSchemaPtr schema,\n-                                 xmlNodePtr node);\n-static int\n-xmlSchemaTypeFixup(xmlSchemaTypePtr type,\n-                   xmlSchemaAbstractCtxtPtr ctxt);\n-static const xmlChar *\n-xmlSchemaFacetTypeToString(xmlSchemaTypeType type);\n-static int\n-xmlSchemaParseImport(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                     xmlNodePtr node);\n-static int\n-xmlSchemaCheckFacetValues(xmlSchemaTypePtr typeDecl,\n-                       xmlSchemaParserCtxtPtr ctxt);\n-static void\n-xmlSchemaClearValidCtxt(xmlSchemaValidCtxtPtr vctxt);\n-static xmlSchemaWhitespaceValueType\n-xmlSchemaGetWhiteSpaceFacetValue(xmlSchemaTypePtr type);\n-static xmlSchemaTreeItemPtr\n-xmlSchemaParseModelGroup(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-             xmlNodePtr node, xmlSchemaTypeType type,\n-             int withParticle);\n-static const xmlChar *\n-xmlSchemaGetComponentTypeStr(xmlSchemaBasicItemPtr item);\n-static xmlSchemaTypeLinkPtr\n-xmlSchemaGetUnionSimpleTypeMemberTypes(xmlSchemaTypePtr type);\n-static void\n-xmlSchemaInternalErr(xmlSchemaAbstractCtxtPtr actxt,\n-             const char *funcName,\n-             const char *message) LIBXML_ATTR_FORMAT(3,0);\n-static int\n-xmlSchemaCheckCOSSTDerivedOK(xmlSchemaAbstractCtxtPtr ctxt,\n-                 xmlSchemaTypePtr type,\n-                 xmlSchemaTypePtr baseType,\n-                 int subset);\n-static void\n-xmlSchemaCheckElementDeclComponent(xmlSchemaElementPtr elemDecl,\n-                   xmlSchemaParserCtxtPtr ctxt);\n-static void\n-xmlSchemaComponentListFree(xmlSchemaItemListPtr list);\n-static xmlSchemaQNameRefPtr\n-xmlSchemaParseAttributeGroupRef(xmlSchemaParserCtxtPtr pctxt,\n-                xmlSchemaPtr schema,\n-                xmlNodePtr node);\n-\n-\/************************************************************************\n- *                                    *\n- *            Helper functions                    *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlSchemaItemTypeToStr:\n- * @type: the type of the schema item\n- *\n- * Returns the component name of a schema item.\n- *\/\n-static const xmlChar *\n-xmlSchemaItemTypeToStr(xmlSchemaTypeType type)\n-{\n-    switch (type) {\n-    case XML_SCHEMA_TYPE_BASIC:\n-        return(BAD_CAST \"simple type definition\");\n-    case XML_SCHEMA_TYPE_SIMPLE:\n-        return(BAD_CAST \"simple type definition\");\n-    case XML_SCHEMA_TYPE_COMPLEX:\n-        return(BAD_CAST \"complex type definition\");\n-    case XML_SCHEMA_TYPE_ELEMENT:\n-        return(BAD_CAST \"element declaration\");\n-    case XML_SCHEMA_TYPE_ATTRIBUTE_USE:\n-        return(BAD_CAST \"attribute use\");\n-    case XML_SCHEMA_TYPE_ATTRIBUTE:\n-        return(BAD_CAST \"attribute declaration\");\n-    case XML_SCHEMA_TYPE_GROUP:\n-        return(BAD_CAST \"model group definition\");\n-    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:\n-        return(BAD_CAST \"attribute group definition\");\n-    case XML_SCHEMA_TYPE_NOTATION:\n-        return(BAD_CAST \"notation declaration\");\n-    case XML_SCHEMA_TYPE_SEQUENCE:\n-        return(BAD_CAST \"model group (sequence)\");\n-    case XML_SCHEMA_TYPE_CHOICE:\n-        return(BAD_CAST \"model group (choice)\");\n-    case XML_SCHEMA_TYPE_ALL:\n-        return(BAD_CAST \"model group (all)\");\n-    case XML_SCHEMA_TYPE_PARTICLE:\n-        return(BAD_CAST \"particle\");\n-    case XML_SCHEMA_TYPE_IDC_UNIQUE:\n-        return(BAD_CAST \"unique identity-constraint\");\n-        \/* return(BAD_CAST \"IDC (unique)\"); *\/\n-    case XML_SCHEMA_TYPE_IDC_KEY:\n-        return(BAD_CAST \"key identity-constraint\");\n-        \/* return(BAD_CAST \"IDC (key)\"); *\/\n-    case XML_SCHEMA_TYPE_IDC_KEYREF:\n-        return(BAD_CAST \"keyref identity-constraint\");\n-        \/* return(BAD_CAST \"IDC (keyref)\"); *\/\n-    case XML_SCHEMA_TYPE_ANY:\n-        return(BAD_CAST \"wildcard (any)\");\n-    case XML_SCHEMA_EXTRA_QNAMEREF:\n-        return(BAD_CAST \"[helper component] QName reference\");\n-    case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:\n-        return(BAD_CAST \"[helper component] attribute use prohibition\");\n-    default:\n-        return(BAD_CAST \"Not a schema component\");\n-    }\n-}\n-\n-\/**\n- * xmlSchemaGetComponentTypeStr:\n- * @type: the type of the schema item\n- *\n- * Returns the component name of a schema item.\n- *\/\n-static const xmlChar *\n-xmlSchemaGetComponentTypeStr(xmlSchemaBasicItemPtr item)\n-{\n-    switch (item->type) {\n-    case XML_SCHEMA_TYPE_BASIC:\n-        if (WXS_IS_COMPLEX(WXS_TYPE_CAST item))\n-        return(BAD_CAST \"complex type definition\");\n-        else\n-        return(BAD_CAST \"simple type definition\");\n-    default:\n-        return(xmlSchemaItemTypeToStr(item->type));\n-    }\n-}\n-\n-\/**\n- * xmlSchemaGetComponentNode:\n- * @item: a schema component\n- *\n- * Returns node associated with the schema component.\n- * NOTE that such a node need not be available; plus, a component's\n- * node need not to reflect the component directly, since there is no\n- * one-to-one relationship between the XML Schema representation and\n- * the component representation.\n- *\/\n-static xmlNodePtr\n-xmlSchemaGetComponentNode(xmlSchemaBasicItemPtr item)\n-{\n-    switch (item->type) {\n-    case XML_SCHEMA_TYPE_ELEMENT:\n-        return (((xmlSchemaElementPtr) item)->node);\n-    case XML_SCHEMA_TYPE_ATTRIBUTE:\n-        return (((xmlSchemaAttributePtr) item)->node);\n-    case XML_SCHEMA_TYPE_COMPLEX:\n-    case XML_SCHEMA_TYPE_SIMPLE:\n-        return (((xmlSchemaTypePtr) item)->node);\n-    case XML_SCHEMA_TYPE_ANY:\n-    case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:\n-        return (((xmlSchemaWildcardPtr) item)->node);\n-    case XML_SCHEMA_TYPE_PARTICLE:\n-        return (((xmlSchemaParticlePtr) item)->node);\n-    case XML_SCHEMA_TYPE_SEQUENCE:\n-    case XML_SCHEMA_TYPE_CHOICE:\n-    case XML_SCHEMA_TYPE_ALL:\n-        return (((xmlSchemaModelGroupPtr) item)->node);\n-    case XML_SCHEMA_TYPE_GROUP:\n-        return (((xmlSchemaModelGroupDefPtr) item)->node);\n-    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:\n-        return (((xmlSchemaAttributeGroupPtr) item)->node);\n-    case XML_SCHEMA_TYPE_IDC_UNIQUE:\n-    case XML_SCHEMA_TYPE_IDC_KEY:\n-    case XML_SCHEMA_TYPE_IDC_KEYREF:\n-        return (((xmlSchemaIDCPtr) item)->node);\n-    case XML_SCHEMA_EXTRA_QNAMEREF:\n-        return(((xmlSchemaQNameRefPtr) item)->node);\n-    \/* TODO: What to do with NOTATIONs?\n-    case XML_SCHEMA_TYPE_NOTATION:\n-        return (((xmlSchemaNotationPtr) item)->node);\n-    *\/\n-    case XML_SCHEMA_TYPE_ATTRIBUTE_USE:\n-        return (((xmlSchemaAttributeUsePtr) item)->node);\n-    default:\n-        return (NULL);\n-    }\n-}\n-\n-#if 0\n-\/**\n- * xmlSchemaGetNextComponent:\n- * @item: a schema component\n- *\n- * Returns the next sibling of the schema component.\n- *\/\n-static xmlSchemaBasicItemPtr\n-xmlSchemaGetNextComponent(xmlSchemaBasicItemPtr item)\n-{\n-    switch (item->type) {\n-    case XML_SCHEMA_TYPE_ELEMENT:\n-        return ((xmlSchemaBasicItemPtr) ((xmlSchemaElementPtr) item)->next);\n-    case XML_SCHEMA_TYPE_ATTRIBUTE:\n-        return ((xmlSchemaBasicItemPtr) ((xmlSchemaAttributePtr) item)->next);\n-    case XML_SCHEMA_TYPE_COMPLEX:\n-    case XML_SCHEMA_TYPE_SIMPLE:\n-        return ((xmlSchemaBasicItemPtr) ((xmlSchemaTypePtr) item)->next);\n-    case XML_SCHEMA_TYPE_ANY:\n-    case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:\n-        return (NULL);\n-    case XML_SCHEMA_TYPE_PARTICLE:\n-        return ((xmlSchemaBasicItemPtr) ((xmlSchemaParticlePtr) item)->next);\n-    case XML_SCHEMA_TYPE_SEQUENCE:\n-    case XML_SCHEMA_TYPE_CHOICE:\n-    case XML_SCHEMA_TYPE_ALL:\n-        return (NULL);\n-    case XML_SCHEMA_TYPE_GROUP:\n-        return (NULL);\n-    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:\n-        return ((xmlSchemaBasicItemPtr) ((xmlSchemaAttributeGroupPtr) item)->next);\n-    case XML_SCHEMA_TYPE_IDC_UNIQUE:\n-    case XML_SCHEMA_TYPE_IDC_KEY:\n-    case XML_SCHEMA_TYPE_IDC_KEYREF:\n-        return ((xmlSchemaBasicItemPtr) ((xmlSchemaIDCPtr) item)->next);\n-    default:\n-        return (NULL);\n-    }\n-}\n-#endif\n-\n-\n-\/**\n- * xmlSchemaFormatQName:\n- * @buf: the string buffer\n- * @namespaceName:  the namespace name\n- * @localName: the local name\n- *\n- * Returns the given QName in the format \"{namespaceName}localName\" or\n- * just \"localName\" if @namespaceName is NULL.\n- *\n- * Returns the localName if @namespaceName is NULL, a formatted\n- * string otherwise.\n- *\/\n-static const xmlChar*\n-xmlSchemaFormatQName(xmlChar **buf,\n-             const xmlChar *namespaceName,\n-             const xmlChar *localName)\n-{\n-    FREE_AND_NULL(*buf)\n-    if (namespaceName != NULL) {\n-    *buf = xmlStrdup(BAD_CAST \"{\");\n-    *buf = xmlStrcat(*buf, namespaceName);\n-    *buf = xmlStrcat(*buf, BAD_CAST \"}\");\n-    }\n-    if (localName != NULL) {\n-    if (namespaceName == NULL)\n-        return(localName);\n-    *buf = xmlStrcat(*buf, localName);\n-    } else {\n-    *buf = xmlStrcat(*buf, BAD_CAST \"(NULL)\");\n-    }\n-    return ((const xmlChar *) *buf);\n-}\n-\n-static const xmlChar*\n-xmlSchemaFormatQNameNs(xmlChar **buf, xmlNsPtr ns, const xmlChar *localName)\n-{\n-    if (ns != NULL)\n-    return (xmlSchemaFormatQName(buf, ns->href, localName));\n-    else\n-    return (xmlSchemaFormatQName(buf, NULL, localName));\n-}\n-\n-static const xmlChar *\n-xmlSchemaGetComponentName(xmlSchemaBasicItemPtr item)\n-{\n-    if (item == NULL) {\n-        return (NULL);\n-    }\n-    switch (item->type) {\n-    case XML_SCHEMA_TYPE_ELEMENT:\n-        return (((xmlSchemaElementPtr) item)->name);\n-    case XML_SCHEMA_TYPE_ATTRIBUTE:\n-        return (((xmlSchemaAttributePtr) item)->name);\n-    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:\n-        return (((xmlSchemaAttributeGroupPtr) item)->name);\n-    case XML_SCHEMA_TYPE_BASIC:\n-    case XML_SCHEMA_TYPE_SIMPLE:\n-    case XML_SCHEMA_TYPE_COMPLEX:\n-        return (((xmlSchemaTypePtr) item)->name);\n-    case XML_SCHEMA_TYPE_GROUP:\n-        return (((xmlSchemaModelGroupDefPtr) item)->name);\n-    case XML_SCHEMA_TYPE_IDC_KEY:\n-    case XML_SCHEMA_TYPE_IDC_UNIQUE:\n-    case XML_SCHEMA_TYPE_IDC_KEYREF:\n-        return (((xmlSchemaIDCPtr) item)->name);\n-    case XML_SCHEMA_TYPE_ATTRIBUTE_USE:\n-        if (WXS_ATTRUSE_DECL(item) != NULL) {\n-        return(xmlSchemaGetComponentName(\n-            WXS_BASIC_CAST WXS_ATTRUSE_DECL(item)));\n-        } else\n-        return(NULL);\n-    case XML_SCHEMA_EXTRA_QNAMEREF:\n-        return (((xmlSchemaQNameRefPtr) item)->name);\n-    case XML_SCHEMA_TYPE_NOTATION:\n-        return (((xmlSchemaNotationPtr) item)->name);\n-    default:\n-        \/*\n-        * Other components cannot have names.\n-        *\/\n-        break;\n-    }\n-    return (NULL);\n-}\n-\n-#define xmlSchemaGetQNameRefName(r) (WXS_QNAME_CAST (r))->name\n-#define xmlSchemaGetQNameRefTargetNs(r) (WXS_QNAME_CAST (r))->targetNamespace\n-\/*\n-static const xmlChar *\n-xmlSchemaGetQNameRefName(void *ref)\n-{\n-    return(((xmlSchemaQNameRefPtr) ref)->name);\n-}\n-\n-static const xmlChar *\n-xmlSchemaGetQNameRefTargetNs(void *ref)\n-{\n-    return(((xmlSchemaQNameRefPtr) ref)->targetNamespace);\n-}\n-*\/\n-\n-static const xmlChar *\n-xmlSchemaGetComponentTargetNs(xmlSchemaBasicItemPtr item)\n-{\n-    if (item == NULL) {\n-        return (NULL);\n-    }\n-    switch (item->type) {\n-    case XML_SCHEMA_TYPE_ELEMENT:\n-        return (((xmlSchemaElementPtr) item)->targetNamespace);\n-    case XML_SCHEMA_TYPE_ATTRIBUTE:\n-        return (((xmlSchemaAttributePtr) item)->targetNamespace);\n-    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:\n-        return (((xmlSchemaAttributeGroupPtr) item)->targetNamespace);\n-    case XML_SCHEMA_TYPE_BASIC:\n-        return (BAD_CAST \"http:\/\/www.w3.org\/2001\/XMLSchema\");\n-    case XML_SCHEMA_TYPE_SIMPLE:\n-    case XML_SCHEMA_TYPE_COMPLEX:\n-        return (((xmlSchemaTypePtr) item)->targetNamespace);\n-    case XML_SCHEMA_TYPE_GROUP:\n-        return (((xmlSchemaModelGroupDefPtr) item)->targetNamespace);\n-    case XML_SCHEMA_TYPE_IDC_KEY:\n-    case XML_SCHEMA_TYPE_IDC_UNIQUE:\n-    case XML_SCHEMA_TYPE_IDC_KEYREF:\n-        return (((xmlSchemaIDCPtr) item)->targetNamespace);\n-    case XML_SCHEMA_TYPE_ATTRIBUTE_USE:\n-        if (WXS_ATTRUSE_DECL(item) != NULL) {\n-        return(xmlSchemaGetComponentTargetNs(\n-            WXS_BASIC_CAST WXS_ATTRUSE_DECL(item)));\n-        }\n-        \/* TODO: Will returning NULL break something? *\/\n-        break;\n-    case XML_SCHEMA_EXTRA_QNAMEREF:\n-        return (((xmlSchemaQNameRefPtr) item)->targetNamespace);\n-    case XML_SCHEMA_TYPE_NOTATION:\n-        return (((xmlSchemaNotationPtr) item)->targetNamespace);\n-    default:\n-        \/*\n-        * Other components cannot have names.\n-        *\/\n-        break;\n-    }\n-    return (NULL);\n-}\n-\n-static const xmlChar*\n-xmlSchemaGetComponentQName(xmlChar **buf,\n-               void *item)\n-{\n-    return (xmlSchemaFormatQName(buf,\n-    xmlSchemaGetComponentTargetNs((xmlSchemaBasicItemPtr) item),\n-    xmlSchemaGetComponentName((xmlSchemaBasicItemPtr) item)));\n-}\n-\n-static const xmlChar*\n-xmlSchemaGetComponentDesignation(xmlChar **buf, void *item)\n-{\n-    xmlChar *str = NULL;\n-\n-    *buf = xmlStrcat(*buf, WXS_ITEM_TYPE_NAME(item));\n-    *buf = xmlStrcat(*buf, BAD_CAST \" '\");\n-    *buf = xmlStrcat(*buf, xmlSchemaGetComponentQName(&str,\n-    (xmlSchemaBasicItemPtr) item));\n-    *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-    FREE_AND_NULL(str);\n-    return(*buf);\n-}\n-\n-static const xmlChar*\n-xmlSchemaGetIDCDesignation(xmlChar **buf, xmlSchemaIDCPtr idc)\n-{\n-    return(xmlSchemaGetComponentDesignation(buf, idc));\n-}\n-\n-\/**\n- * xmlSchemaWildcardPCToString:\n- * @pc: the type of processContents\n- *\n- * Returns a string representation of the type of\n- * processContents.\n- *\/\n-static const xmlChar *\n-xmlSchemaWildcardPCToString(int pc)\n-{\n-    switch (pc) {\n-    case XML_SCHEMAS_ANY_SKIP:\n-        return (BAD_CAST \"skip\");\n-    case XML_SCHEMAS_ANY_LAX:\n-        return (BAD_CAST \"lax\");\n-    case XML_SCHEMAS_ANY_STRICT:\n-        return (BAD_CAST \"strict\");\n-    default:\n-        return (BAD_CAST \"invalid process contents\");\n-    }\n-}\n-\n-\/**\n- * xmlSchemaGetCanonValueWhtspExt:\n- * @val: the precomputed value\n- * @retValue: the returned value\n- * @ws: the whitespace type of the value\n- * @for_hash: non-zero if this is supposed to generate a string for hashing\n- *\n- * Get a the canonical representation of the value.\n- * The caller has to free the returned retValue.\n- *\n- * Returns 0 if the value could be built and -1 in case of\n- *         API errors or if the value type is not supported yet.\n- *\/\n-static int\n-xmlSchemaGetCanonValueWhtspExt_1(xmlSchemaValPtr val,\n-                     xmlSchemaWhitespaceValueType ws,\n-                     xmlChar **retValue,\n-                 int for_hash)\n-{\n-    int list;\n-    xmlSchemaValType valType;\n-    const xmlChar *value, *value2 = NULL;\n-\n-\n-    if ((retValue == NULL) || (val == NULL))\n-    return (-1);\n-    list = xmlSchemaValueGetNext(val) ? 1 : 0;\n-    *retValue = NULL;\n-    do {\n-    value = NULL;\n-    valType = xmlSchemaGetValType(val);\n-    switch (valType) {\n-        case XML_SCHEMAS_STRING:\n-        case XML_SCHEMAS_NORMSTRING:\n-        case XML_SCHEMAS_ANYSIMPLETYPE:\n-        value = xmlSchemaValueGetAsString(val);\n-        if (value != NULL) {\n-            if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)\n-            value2 = xmlSchemaCollapseString(value);\n-            else if (ws == XML_SCHEMA_WHITESPACE_REPLACE)\n-            value2 = xmlSchemaWhiteSpaceReplace(value);\n-            if (value2 != NULL)\n-            value = value2;\n-        }\n-        break;\n-        default:\n-        if (xmlSchemaGetCanonValue(val, &value2) == -1) {\n-            if (value2 != NULL)\n-            xmlFree((xmlChar *) value2);\n-            goto internal_error;\n-        }\n-        if (for_hash && valType == XML_SCHEMAS_DECIMAL) {\n-            \/* We can mostly use the canonical value for hashing,\n-               except in the case of decimal.  There the canonical\n-               representation requires a trailing '.0' even for\n-               non-fractional numbers, but for the derived integer\n-               types it forbids any decimal point.  Nevertheless they\n-               compare equal if the value is equal.  We need to generate\n-               the same hash value for this to work, and it's easiest\n-               to just cut off the useless '.0' suffix for the\n-               decimal type.  *\/\n-            int len = xmlStrlen(value2);\n-            if (len > 2 && value2[len-1] == '0' && value2[len-2] == '.')\n-              ((xmlChar*)value2)[len-2] = 0;\n-        }\n-        value = value2;\n-    }\n-    if (*retValue == NULL)\n-        if (value == NULL) {\n-        if (! list)\n-            *retValue = xmlStrdup(BAD_CAST \"\");\n-        } else\n-        *retValue = xmlStrdup(value);\n-    else if (value != NULL) {\n-        \/* List. *\/\n-        *retValue = xmlStrcat((xmlChar *) *retValue, BAD_CAST \" \");\n-        *retValue = xmlStrcat((xmlChar *) *retValue, value);\n-    }\n-    FREE_AND_NULL(value2)\n-    val = xmlSchemaValueGetNext(val);\n-    } while (val != NULL);\n-\n-    return (0);\n-internal_error:\n-    if (*retValue != NULL)\n-    xmlFree((xmlChar *) (*retValue));\n-    if (value2 != NULL)\n-    xmlFree((xmlChar *) value2);\n-    return (-1);\n-}\n-\n-static int\n-xmlSchemaGetCanonValueWhtspExt(xmlSchemaValPtr val,\n-                   xmlSchemaWhitespaceValueType ws,\n-                   xmlChar **retValue)\n-{\n-    return xmlSchemaGetCanonValueWhtspExt_1(val, ws, retValue, 0);\n-}\n-\n-static int\n-xmlSchemaGetCanonValueHash(xmlSchemaValPtr val,\n-               xmlChar **retValue)\n-{\n-    return xmlSchemaGetCanonValueWhtspExt_1(val, XML_SCHEMA_WHITESPACE_COLLAPSE,\n-                        retValue, 1);\n-}\n-\n-\/**\n- * xmlSchemaFormatItemForReport:\n- * @buf: the string buffer\n- * @itemDes: the designation of the item\n- * @itemName: the name of the item\n- * @item: the item as an object\n- * @itemNode: the node of the item\n- * @local: the local name\n- * @parsing: if the function is used during the parse\n- *\n- * Returns a representation of the given item used\n- * for error reports.\n- *\n- * The following order is used to build the resulting\n- * designation if the arguments are not NULL:\n- * 1a. If itemDes not NULL -> itemDes\n- * 1b. If (itemDes not NULL) and (itemName not NULL)\n- *     -> itemDes + itemName\n- * 2. If the preceding was NULL and (item not NULL) -> item\n- * 3. If the preceding was NULL and (itemNode not NULL) -> itemNode\n- *\n- * If the itemNode is an attribute node, the name of the attribute\n- * will be appended to the result.\n- *\n- * Returns the formatted string and sets @buf to the resulting value.\n- *\/\n-static xmlChar*\n-xmlSchemaFormatItemForReport(xmlChar **buf,\n-             const xmlChar *itemDes,\n-             xmlSchemaBasicItemPtr item,\n-             xmlNodePtr itemNode)\n-{\n-    xmlChar *str = NULL;\n-    int named = 1;\n-\n-    if (*buf != NULL) {\n-    xmlFree(*buf);\n-    *buf = NULL;\n-    }\n-\n-    if (itemDes != NULL) {\n-    *buf = xmlStrdup(itemDes);\n-    } else if (item != NULL) {\n-    switch (item->type) {\n-    case XML_SCHEMA_TYPE_BASIC: {\n-        xmlSchemaTypePtr type = WXS_TYPE_CAST item;\n-\n-        if (WXS_IS_ATOMIC(type))\n-        *buf = xmlStrdup(BAD_CAST \"atomic type 'xs:\");\n-        else if (WXS_IS_LIST(type))\n-        *buf = xmlStrdup(BAD_CAST \"list type 'xs:\");\n-        else if (WXS_IS_UNION(type))\n-        *buf = xmlStrdup(BAD_CAST \"union type 'xs:\");\n-        else\n-        *buf = xmlStrdup(BAD_CAST \"simple type 'xs:\");\n-        *buf = xmlStrcat(*buf, type->name);\n-        *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_SIMPLE: {\n-        xmlSchemaTypePtr type = WXS_TYPE_CAST item;\n-\n-        if (type->flags & XML_SCHEMAS_TYPE_GLOBAL) {\n-        *buf = xmlStrdup(BAD_CAST\"\");\n-        } else {\n-        *buf = xmlStrdup(BAD_CAST \"local \");\n-        }\n-        if (WXS_IS_ATOMIC(type))\n-        *buf = xmlStrcat(*buf, BAD_CAST \"atomic type\");\n-        else if (WXS_IS_LIST(type))\n-        *buf = xmlStrcat(*buf, BAD_CAST \"list type\");\n-        else if (WXS_IS_UNION(type))\n-        *buf = xmlStrcat(*buf, BAD_CAST \"union type\");\n-        else\n-        *buf = xmlStrcat(*buf, BAD_CAST \"simple type\");\n-        if (type->flags & XML_SCHEMAS_TYPE_GLOBAL) {\n-        *buf = xmlStrcat(*buf, BAD_CAST \" '\");\n-        *buf = xmlStrcat(*buf, type->name);\n-        *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-        }\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_COMPLEX: {\n-        xmlSchemaTypePtr type = WXS_TYPE_CAST item;\n-\n-        if (type->flags & XML_SCHEMAS_TYPE_GLOBAL)\n-        *buf = xmlStrdup(BAD_CAST \"\");\n-        else\n-        *buf = xmlStrdup(BAD_CAST \"local \");\n-        *buf = xmlStrcat(*buf, BAD_CAST \"complex type\");\n-        if (type->flags & XML_SCHEMAS_TYPE_GLOBAL) {\n-        *buf = xmlStrcat(*buf, BAD_CAST \" '\");\n-        *buf = xmlStrcat(*buf, type->name);\n-        *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-        }\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_ATTRIBUTE_USE: {\n-        xmlSchemaAttributeUsePtr ause;\n-\n-        ause = WXS_ATTR_USE_CAST item;\n-        *buf = xmlStrdup(BAD_CAST \"attribute use \");\n-        if (WXS_ATTRUSE_DECL(ause) != NULL) {\n-            *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-            *buf = xmlStrcat(*buf,\n-            xmlSchemaGetComponentQName(&str, WXS_ATTRUSE_DECL(ause)));\n-            FREE_AND_NULL(str)\n-            *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-        } else {\n-            *buf = xmlStrcat(*buf, BAD_CAST \"(unknown)\");\n-        }\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_ATTRIBUTE: {\n-        xmlSchemaAttributePtr attr;\n-\n-        attr = (xmlSchemaAttributePtr) item;\n-        *buf = xmlStrdup(BAD_CAST \"attribute decl.\");\n-        *buf = xmlStrcat(*buf, BAD_CAST \" '\");\n-        *buf = xmlStrcat(*buf, xmlSchemaFormatQName(&str,\n-            attr->targetNamespace, attr->name));\n-        FREE_AND_NULL(str)\n-            *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:\n-        xmlSchemaGetComponentDesignation(buf, item);\n-        break;\n-    case XML_SCHEMA_TYPE_ELEMENT: {\n-        xmlSchemaElementPtr elem;\n-\n-        elem = (xmlSchemaElementPtr) item;\n-        *buf = xmlStrdup(BAD_CAST \"element decl.\");\n-        *buf = xmlStrcat(*buf, BAD_CAST \" '\");\n-        *buf = xmlStrcat(*buf, xmlSchemaFormatQName(&str,\n-            elem->targetNamespace, elem->name));\n-        *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_IDC_UNIQUE:\n-    case XML_SCHEMA_TYPE_IDC_KEY:\n-    case XML_SCHEMA_TYPE_IDC_KEYREF:\n-        if (item->type == XML_SCHEMA_TYPE_IDC_UNIQUE)\n-        *buf = xmlStrdup(BAD_CAST \"unique '\");\n-        else if (item->type == XML_SCHEMA_TYPE_IDC_KEY)\n-        *buf = xmlStrdup(BAD_CAST \"key '\");\n-        else\n-        *buf = xmlStrdup(BAD_CAST \"keyRef '\");\n-        *buf = xmlStrcat(*buf, ((xmlSchemaIDCPtr) item)->name);\n-        *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-        break;\n-    case XML_SCHEMA_TYPE_ANY:\n-    case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:\n-        *buf = xmlStrdup(xmlSchemaWildcardPCToString(\n-            ((xmlSchemaWildcardPtr) item)->processContents));\n-        *buf = xmlStrcat(*buf, BAD_CAST \" wildcard\");\n-        break;\n-    case XML_SCHEMA_FACET_MININCLUSIVE:\n-    case XML_SCHEMA_FACET_MINEXCLUSIVE:\n-    case XML_SCHEMA_FACET_MAXINCLUSIVE:\n-    case XML_SCHEMA_FACET_MAXEXCLUSIVE:\n-    case XML_SCHEMA_FACET_TOTALDIGITS:\n-    case XML_SCHEMA_FACET_FRACTIONDIGITS:\n-    case XML_SCHEMA_FACET_PATTERN:\n-    case XML_SCHEMA_FACET_ENUMERATION:\n-    case XML_SCHEMA_FACET_WHITESPACE:\n-    case XML_SCHEMA_FACET_LENGTH:\n-    case XML_SCHEMA_FACET_MAXLENGTH:\n-    case XML_SCHEMA_FACET_MINLENGTH:\n-        *buf = xmlStrdup(BAD_CAST \"facet '\");\n-        *buf = xmlStrcat(*buf, xmlSchemaFacetTypeToString(item->type));\n-        *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-        break;\n-    case XML_SCHEMA_TYPE_GROUP: {\n-        *buf = xmlStrdup(BAD_CAST \"model group def.\");\n-        *buf = xmlStrcat(*buf, BAD_CAST \" '\");\n-        *buf = xmlStrcat(*buf, xmlSchemaGetComponentQName(&str, item));\n-        *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-        FREE_AND_NULL(str)\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_SEQUENCE:\n-    case XML_SCHEMA_TYPE_CHOICE:\n-    case XML_SCHEMA_TYPE_ALL:\n-    case XML_SCHEMA_TYPE_PARTICLE:\n-        *buf = xmlStrdup(WXS_ITEM_TYPE_NAME(item));\n-        break;\n-    case XML_SCHEMA_TYPE_NOTATION: {\n-        *buf = xmlStrdup(WXS_ITEM_TYPE_NAME(item));\n-        *buf = xmlStrcat(*buf, BAD_CAST \" '\");\n-        *buf = xmlStrcat(*buf, xmlSchemaGetComponentQName(&str, item));\n-        *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-        FREE_AND_NULL(str);\n-        }\n-            \/* Falls through. *\/\n-    default:\n-        named = 0;\n-    }\n-    } else\n-    named = 0;\n-\n-    if ((named == 0) && (itemNode != NULL)) {\n-    xmlNodePtr elem;\n-\n-    if (itemNode->type == XML_ATTRIBUTE_NODE)\n-        elem = itemNode->parent;\n-    else\n-        elem = itemNode;\n-    *buf = xmlStrdup(BAD_CAST \"Element '\");\n-    if (elem->ns != NULL) {\n-        *buf = xmlStrcat(*buf,\n-        xmlSchemaFormatQName(&str, elem->ns->href, elem->name));\n-        FREE_AND_NULL(str)\n-    } else\n-        *buf = xmlStrcat(*buf, elem->name);\n-    *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-\n-    }\n-    if ((itemNode != NULL) && (itemNode->type == XML_ATTRIBUTE_NODE)) {\n-    *buf = xmlStrcat(*buf, BAD_CAST \", attribute '\");\n-    if (itemNode->ns != NULL) {\n-        *buf = xmlStrcat(*buf, xmlSchemaFormatQName(&str,\n-        itemNode->ns->href, itemNode->name));\n-        FREE_AND_NULL(str)\n-    } else\n-        *buf = xmlStrcat(*buf, itemNode->name);\n-    *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-    }\n-    FREE_AND_NULL(str)\n-\n-    return (xmlEscapeFormatString(buf));\n-}\n-\n-\/**\n- * xmlSchemaFormatFacetEnumSet:\n- * @buf: the string buffer\n- * @type: the type holding the enumeration facets\n- *\n- * Builds a string consisting of all enumeration elements.\n- *\n- * Returns a string of all enumeration elements.\n- *\/\n-static const xmlChar *\n-xmlSchemaFormatFacetEnumSet(xmlSchemaAbstractCtxtPtr actxt,\n-                xmlChar **buf, xmlSchemaTypePtr type)\n-{\n-    xmlSchemaFacetPtr facet;\n-    xmlSchemaWhitespaceValueType ws;\n-    xmlChar *value = NULL;\n-    int res, found = 0;\n-\n-    if (*buf != NULL)\n-    xmlFree(*buf);\n-    *buf = NULL;\n-\n-    do {\n-    \/*\n-    * Use the whitespace type of the base type.\n-    *\/\n-    ws = xmlSchemaGetWhiteSpaceFacetValue(type->baseType);\n-    for (facet = type->facets; facet != NULL; facet = facet->next) {\n-        if (facet->type != XML_SCHEMA_FACET_ENUMERATION)\n-        continue;\n-        found = 1;\n-        res = xmlSchemaGetCanonValueWhtspExt(facet->val,\n-        ws, &value);\n-        if (res == -1) {\n-        xmlSchemaInternalErr(actxt,\n-            \"xmlSchemaFormatFacetEnumSet\",\n-            \"compute the canonical lexical representation\");\n-        if (*buf != NULL)\n-            xmlFree(*buf);\n-        *buf = NULL;\n-        return (NULL);\n-        }\n-        if (*buf == NULL)\n-        *buf = xmlStrdup(BAD_CAST \"'\");\n-        else\n-        *buf = xmlStrcat(*buf, BAD_CAST \", '\");\n-        *buf = xmlStrcat(*buf, BAD_CAST value);\n-        *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-        if (value != NULL) {\n-        xmlFree((xmlChar *)value);\n-        value = NULL;\n-        }\n-    }\n-    \/*\n-    * The enumeration facet of a type restricts the enumeration\n-    * facet of the ancestor type; i.e., such restricted enumerations\n-    * do not belong to the set of the given type. Thus we break\n-    * on the first found enumeration.\n-    *\/\n-    if (found)\n-        break;\n-    type = type->baseType;\n-    } while ((type != NULL) && (type->type != XML_SCHEMA_TYPE_BASIC));\n-\n-    return ((const xmlChar *) *buf);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Error functions                        *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlSchemaPErrMemory:\n- * @node: a context node\n- * @extra:  extra information\n- *\n- * Handle an out of memory condition\n- *\/\n-static void\n-xmlSchemaPErrMemory(xmlSchemaParserCtxtPtr ctxt)\n-{\n-    xmlGenericErrorFunc channel = NULL;\n-    xmlStructuredErrorFunc schannel = NULL;\n-    void *data = NULL;\n-\n-    if (ctxt != NULL) {\n-        ctxt->nberrors++;\n-        ctxt->err = XML_ERR_NO_MEMORY;\n-        channel = ctxt->error;\n-        schannel = ctxt->serror;\n-        data = ctxt->errCtxt;\n-    }\n-\n-    xmlRaiseMemoryError(schannel, channel, data, XML_FROM_SCHEMASP, NULL);\n-}\n-\n-static void LIBXML_ATTR_FORMAT(11,12)\n-xmlSchemaPErrFull(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node, int code,\n-                  xmlErrorLevel level, const char *file, int line,\n-                  const xmlChar *str1, const xmlChar *str2, const xmlChar *str3,\n-                  int col, const char *msg, ...) {\n-    xmlGenericErrorFunc channel = NULL;\n-    xmlStructuredErrorFunc schannel = NULL;\n-    void *data = NULL;\n-    int res;\n-    va_list ap;\n-\n-    if (ctxt != NULL) {\n-        \/* Don't overwrite memory errors *\/\n-        if (ctxt->err == XML_ERR_NO_MEMORY)\n-            return;\n-\n-        if (level == XML_ERR_WARNING) {\n-            channel = ctxt->warning;\n-        } else {\n-            ctxt->nberrors++;\n-            ctxt->err = code;\n-            channel = ctxt->error;\n-        }\n-        data = ctxt->errCtxt;\n-        schannel = ctxt->serror;\n-    }\n-\n-    if ((channel == NULL) && (schannel == NULL)) {\n-        channel = xmlGenericError;\n-        data = xmlGenericErrorContext;\n-    }\n-\n-    va_start(ap, msg);\n-    res = xmlVRaiseError(schannel, channel, data, ctxt, node,\n-                         XML_FROM_SCHEMASP, code, level, file, line,\n-                         (const char *) str1,\n-                         (const char *) str2,\n-                         (const char *) str3,\n-                         0, col, msg, ap);\n-    va_end(ap);\n-\n-    if (res < 0)\n-        xmlSchemaPErrMemory(ctxt);\n-}\n-\n-\/**\n- * xmlSchemaPErr:\n- * @ctxt: the parsing context\n- * @node: the context node\n- * @error: the error code\n- * @msg: the error message\n- * @str1: extra data\n- * @str2: extra data\n- *\n- * Handle a parser error\n- *\/\n-static void LIBXML_ATTR_FORMAT(4,0)\n-xmlSchemaPErr(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node, int code,\n-              const char *msg, const xmlChar * str1, const xmlChar * str2)\n-{\n-    xmlSchemaPErrFull(ctxt, node, code, XML_ERR_ERROR, NULL, 0,\n-                      str1, str2, NULL, 0, msg, str1, str2);\n-}\n-\n-\/**\n- * xmlSchemaPErr2:\n- * @ctxt: the parsing context\n- * @node: the context node\n- * @node: the current child\n- * @error: the error code\n- * @msg: the error message\n- * @str1: extra data\n- * @str2: extra data\n- *\n- * Handle a parser error\n- *\/\n-static void LIBXML_ATTR_FORMAT(5,0)\n-xmlSchemaPErr2(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node,\n-               xmlNodePtr child, int error,\n-               const char *msg, const xmlChar * str1, const xmlChar * str2)\n-{\n-    if (child != NULL)\n-        xmlSchemaPErr(ctxt, child, error, msg, str1, str2);\n-    else\n-        xmlSchemaPErr(ctxt, node, error, msg, str1, str2);\n-}\n-\n-\n-\/**\n- * xmlSchemaPErrExt:\n- * @ctxt: the parsing context\n- * @node: the context node\n- * @error: the error code\n- * @strData1: extra data\n- * @strData2: extra data\n- * @strData3: extra data\n- * @msg: the message\n- * @str1:  extra parameter for the message display\n- * @str2:  extra parameter for the message display\n- * @str3:  extra parameter for the message display\n- * @str4:  extra parameter for the message display\n- * @str5:  extra parameter for the message display\n- *\n- * Handle a parser error\n- *\/\n-static void LIBXML_ATTR_FORMAT(7,0)\n-xmlSchemaPErrExt(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node, int code,\n-        const xmlChar * strData1, const xmlChar * strData2,\n-        const xmlChar * strData3, const char *msg, const xmlChar * str1,\n-        const xmlChar * str2, const xmlChar * str3, const xmlChar * str4,\n-        const xmlChar * str5)\n-{\n-    xmlSchemaPErrFull(ctxt, node, code, XML_ERR_ERROR, NULL, 0,\n-                      strData1, strData2, strData3, 0,\n-                      msg, str1, str2, str3, str4, str5);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Allround error functions            *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlSchemaVTypeErrMemory:\n- * @node: a context node\n- * @extra:  extra information\n- *\n- * Handle an out of memory condition\n- *\/\n-static void\n-xmlSchemaVErrMemory(xmlSchemaValidCtxtPtr ctxt)\n-{\n-    xmlGenericErrorFunc channel = NULL;\n-    xmlStructuredErrorFunc schannel = NULL;\n-    void *data = NULL;\n-\n-    if (ctxt != NULL) {\n-        ctxt->nberrors++;\n-        ctxt->err = XML_ERR_NO_MEMORY;\n-        channel = ctxt->error;\n-        schannel = ctxt->serror;\n-        data = ctxt->errCtxt;\n-    }\n-\n-    xmlRaiseMemoryError(schannel, channel, data, XML_FROM_SCHEMASV, NULL);\n-}\n-\n-static void LIBXML_ATTR_FORMAT(11,12)\n-xmlSchemaVErrFull(xmlSchemaValidCtxtPtr ctxt, xmlNodePtr node, int code,\n-                  xmlErrorLevel level, const char *file, int line,\n-                  const xmlChar *str1, const xmlChar *str2, const xmlChar *str3,\n-                  int col, const char *msg, ...) {\n-    xmlGenericErrorFunc channel = NULL;\n-    xmlStructuredErrorFunc schannel = NULL;\n-    void *data = NULL;\n-    int res;\n-    va_list ap;\n-\n-    if (ctxt != NULL) {\n-        \/* Don't overwrite memory errors *\/\n-        if (ctxt->err == XML_ERR_NO_MEMORY)\n-            return;\n-\n-        if (level == XML_ERR_WARNING) {\n-            channel = ctxt->warning;\n-        } else {\n-            ctxt->nberrors++;\n-            ctxt->err = code;\n-            channel = ctxt->error;\n-        }\n-        data = ctxt->errCtxt;\n-        schannel = ctxt->serror;\n-    }\n-\n-    if ((channel == NULL) && (schannel == NULL)) {\n-        channel = xmlGenericError;\n-        data = xmlGenericErrorContext;\n-    }\n-\n-    va_start(ap, msg);\n-    res = xmlVRaiseError(schannel, channel, data, ctxt, node,\n-                         XML_FROM_SCHEMASV, code, level, file, line,\n-                         (const char *) str1,\n-                         (const char *) str2,\n-                         (const char *) str3,\n-                         0, col, msg, ap);\n-    va_end(ap);\n-\n-    if (res < 0)\n-        xmlSchemaVErrMemory(ctxt);\n-}\n-\n-#define WXS_ERROR_TYPE_ERROR 1\n-#define WXS_ERROR_TYPE_WARNING 2\n-\/**\n- * xmlSchemaErr4Line:\n- * @ctxt: the validation context\n- * @errorLevel: the error level\n- * @error: the error code\n- * @node: the context node\n- * @line: the line number\n- * @msg: the error message\n- * @str1: extra data\n- * @str2: extra data\n- * @str3: extra data\n- * @str4: extra data\n- *\n- * Handle a validation error\n- *\/\n-static void LIBXML_ATTR_FORMAT(6,0)\n-xmlSchemaErr4Line(xmlSchemaAbstractCtxtPtr ctxt,\n-          xmlErrorLevel errorLevel,\n-          int code, xmlNodePtr node, int line, const char *msg,\n-          const xmlChar *str1, const xmlChar *str2,\n-          const xmlChar *str3, const xmlChar *str4)\n-{\n-    if (ctxt != NULL) {\n-    if (ctxt->type == XML_SCHEMA_CTXT_VALIDATOR) {\n-        xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) ctxt;\n-        const char *file = NULL;\n-        int col = 0;\n-\n-        \/*\n-        * Error node. If we specify a line number, then\n-        * do not channel any node to the error function.\n-        *\/\n-        if (line == 0) {\n-        if ((node == NULL) &&\n-            (vctxt->depth >= 0) &&\n-            (vctxt->inode != NULL)) {\n-            node = vctxt->inode->node;\n-        }\n-        \/*\n-        * Get filename and line if no node-tree.\n-        *\/\n-        if ((node == NULL) &&\n-            (vctxt->parserCtxt != NULL) &&\n-            (vctxt->parserCtxt->input != NULL)) {\n-            file = vctxt->parserCtxt->input->filename;\n-                    if (vctxt->inode != NULL) {\n-                line = vctxt->inode->nodeLine;\n-                        col = 0;\n-                    } else {\n-                        \/* This is inaccurate. *\/\n-                line = vctxt->parserCtxt->input->line;\n-                col = vctxt->parserCtxt->input->col;\n-                    }\n-        }\n-        } else {\n-        \/*\n-        * Override the given node's (if any) position\n-        * and channel only the given line number.\n-        *\/\n-        node = NULL;\n-        \/*\n-        * Get filename.\n-        *\/\n-        if (vctxt->doc != NULL)\n-            file = (const char *) vctxt->doc->URL;\n-        else if ((vctxt->parserCtxt != NULL) &&\n-            (vctxt->parserCtxt->input != NULL))\n-            file = vctxt->parserCtxt->input->filename;\n-        }\n-        if (vctxt->locFunc != NULL) {\n-            if ((file == NULL) || (line == 0)) {\n-            unsigned long l;\n-            const char *f;\n-            vctxt->locFunc(vctxt->locCtxt, &f, &l);\n-            if (file == NULL)\n-                file = f;\n-            if (line == 0)\n-                line = (int) l;\n-        }\n-        }\n-        if ((file == NULL) && (vctxt->filename != NULL))\n-            file = vctxt->filename;\n-\n-            xmlSchemaVErrFull(vctxt, node, code, errorLevel,\n-                              file, line, str1, str2, str3, col,\n-                              msg, str1, str2, str3, str4);\n-    } else if (ctxt->type == XML_SCHEMA_CTXT_PARSER) {\n-        xmlSchemaParserCtxtPtr pctxt = (xmlSchemaParserCtxtPtr) ctxt;\n-\n-            xmlSchemaPErrFull(pctxt, node, code, errorLevel,\n-                              NULL, 0, str1, str2, str3, 0,\n-                              msg, str1, str2, str3, str4);\n-    }\n-    }\n-}\n-\n-\/**\n- * xmlSchemaErr3:\n- * @ctxt: the validation context\n- * @node: the context node\n- * @error: the error code\n- * @msg: the error message\n- * @str1: extra data\n- * @str2: extra data\n- * @str3: extra data\n- *\n- * Handle a validation error\n- *\/\n-static void LIBXML_ATTR_FORMAT(4,0)\n-xmlSchemaErr3(xmlSchemaAbstractCtxtPtr actxt,\n-          int error, xmlNodePtr node, const char *msg,\n-          const xmlChar *str1, const xmlChar *str2, const xmlChar *str3)\n-{\n-    xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,\n-    msg, str1, str2, str3, NULL);\n-}\n-\n-static void LIBXML_ATTR_FORMAT(4,0)\n-xmlSchemaErr4(xmlSchemaAbstractCtxtPtr actxt,\n-          int error, xmlNodePtr node, const char *msg,\n-          const xmlChar *str1, const xmlChar *str2,\n-          const xmlChar *str3, const xmlChar *str4)\n-{\n-    xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0,\n-    msg, str1, str2, str3, str4);\n-}\n-\n-static void LIBXML_ATTR_FORMAT(4,0)\n-xmlSchemaErr(xmlSchemaAbstractCtxtPtr actxt,\n-         int error, xmlNodePtr node, const char *msg,\n-         const xmlChar *str1, const xmlChar *str2)\n-{\n-    xmlSchemaErr4(actxt, error, node, msg, str1, str2, NULL, NULL);\n-}\n-\n-static xmlChar *\n-xmlSchemaFormatNodeForError(xmlChar ** msg,\n-                xmlSchemaAbstractCtxtPtr actxt,\n-                xmlNodePtr node)\n-{\n-    xmlChar *str = NULL;\n-\n-    *msg = NULL;\n-    if ((node != NULL) &&\n-    (node->type != XML_ELEMENT_NODE) &&\n-    (node->type != XML_ATTRIBUTE_NODE))\n-    {\n-    \/*\n-    * Don't try to format other nodes than element and\n-    * attribute nodes.\n-    * Play safe and return an empty string.\n-    *\/\n-    *msg = xmlStrdup(BAD_CAST \"\");\n-    return(*msg);\n-    }\n-    if (node != NULL) {\n-    \/*\n-    * Work on tree nodes.\n-    *\/\n-    if (node->type == XML_ATTRIBUTE_NODE) {\n-        xmlNodePtr elem = node->parent;\n-\n-        *msg = xmlStrdup(BAD_CAST \"Element '\");\n-        if (elem->ns != NULL)\n-        *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,\n-            elem->ns->href, elem->name));\n-        else\n-        *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,\n-            NULL, elem->name));\n-        FREE_AND_NULL(str);\n-        *msg = xmlStrcat(*msg, BAD_CAST \"', \");\n-        *msg = xmlStrcat(*msg, BAD_CAST \"attribute '\");\n-    } else {\n-        *msg = xmlStrdup(BAD_CAST \"Element '\");\n-    }\n-    if (node->ns != NULL)\n-        *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,\n-        node->ns->href, node->name));\n-    else\n-        *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,\n-        NULL, node->name));\n-    FREE_AND_NULL(str);\n-    *msg = xmlStrcat(*msg, BAD_CAST \"': \");\n-    } else if (actxt->type == XML_SCHEMA_CTXT_VALIDATOR) {\n-    xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) actxt;\n-    \/*\n-    * Work on node infos.\n-    *\/\n-    if (vctxt->inode->nodeType == XML_ATTRIBUTE_NODE) {\n-        xmlSchemaNodeInfoPtr ielem =\n-        vctxt->elemInfos[vctxt->depth];\n-\n-        *msg = xmlStrdup(BAD_CAST \"Element '\");\n-        *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,\n-        ielem->nsName, ielem->localName));\n-        FREE_AND_NULL(str);\n-        *msg = xmlStrcat(*msg, BAD_CAST \"', \");\n-        *msg = xmlStrcat(*msg, BAD_CAST \"attribute '\");\n-    } else {\n-        *msg = xmlStrdup(BAD_CAST \"Element '\");\n-    }\n-    *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,\n-        vctxt->inode->nsName, vctxt->inode->localName));\n-    FREE_AND_NULL(str);\n-    *msg = xmlStrcat(*msg, BAD_CAST \"': \");\n-    } else if (actxt->type == XML_SCHEMA_CTXT_PARSER) {\n-    \/*\n-    * Hmm, no node while parsing?\n-    * Return an empty string, in case NULL will break something.\n-    *\/\n-    *msg = xmlStrdup(BAD_CAST \"\");\n-    } else {\n-    \/* TODO *\/\n-    return (NULL);\n-    }\n-\n-    \/*\n-     * xmlSchemaFormatItemForReport() also returns an escaped format\n-     * string, so do this before calling it below (in the future).\n-     *\/\n-    xmlEscapeFormatString(msg);\n-\n-    \/*\n-    * VAL TODO: The output of the given schema component is currently\n-    * disabled.\n-    *\/\n-#if 0\n-    if ((type != NULL) && (xmlSchemaIsGlobalItem(type))) {\n-    *msg = xmlStrcat(*msg, BAD_CAST \" [\");\n-    *msg = xmlStrcat(*msg, xmlSchemaFormatItemForReport(&str,\n-        NULL, type, NULL, 0));\n-    FREE_AND_NULL(str)\n-    *msg = xmlStrcat(*msg, BAD_CAST \"]\");\n-    }\n-#endif\n-    return (*msg);\n-}\n-\n-static void LIBXML_ATTR_FORMAT(3,0)\n-xmlSchemaInternalErr2(xmlSchemaAbstractCtxtPtr actxt,\n-             const char *funcName,\n-             const char *message,\n-             const xmlChar *str1,\n-             const xmlChar *str2)\n-{\n-    xmlChar *msg = NULL;\n-\n-    if (actxt == NULL)\n-        return;\n-    msg = xmlStrdup(BAD_CAST \"Internal error: %s, \");\n-    msg = xmlStrcat(msg, BAD_CAST message);\n-    msg = xmlStrcat(msg, BAD_CAST \".\\n\");\n-\n-    if (actxt->type == XML_SCHEMA_CTXT_VALIDATOR)\n-    xmlSchemaErr3(actxt, XML_SCHEMAV_INTERNAL, NULL,\n-        (const char *) msg, (const xmlChar *) funcName, str1, str2);\n-    else if (actxt->type == XML_SCHEMA_CTXT_PARSER)\n-    xmlSchemaErr3(actxt, XML_SCHEMAP_INTERNAL, NULL,\n-        (const char *) msg, (const xmlChar *) funcName, str1, str2);\n-\n-    FREE_AND_NULL(msg)\n-}\n-\n-static void LIBXML_ATTR_FORMAT(3,0)\n-xmlSchemaInternalErr(xmlSchemaAbstractCtxtPtr actxt,\n-             const char *funcName,\n-             const char *message)\n-{\n-    xmlSchemaInternalErr2(actxt, funcName, message, NULL, NULL);\n-}\n-\n-#if 0\n-static void LIBXML_ATTR_FORMAT(3,0)\n-xmlSchemaPInternalErr(xmlSchemaParserCtxtPtr pctxt,\n-             const char *funcName,\n-             const char *message,\n-             const xmlChar *str1,\n-             const xmlChar *str2)\n-{\n-    xmlSchemaInternalErr2(ACTXT_CAST pctxt, funcName, message,\n-    str1, str2);\n-}\n-#endif\n-\n-static void LIBXML_ATTR_FORMAT(5,0)\n-xmlSchemaCustomErr4(xmlSchemaAbstractCtxtPtr actxt,\n-           xmlParserErrors error,\n-           xmlNodePtr node,\n-           xmlSchemaBasicItemPtr item,\n-           const char *message,\n-           const xmlChar *str1, const xmlChar *str2,\n-           const xmlChar *str3, const xmlChar *str4)\n-{\n-    xmlChar *msg = NULL;\n-\n-    if ((node == NULL) && (item != NULL) &&\n-    (actxt->type == XML_SCHEMA_CTXT_PARSER)) {\n-    node = WXS_ITEM_NODE(item);\n-    xmlSchemaFormatItemForReport(&msg, NULL, item, NULL);\n-    msg = xmlStrcat(msg, BAD_CAST \": \");\n-    } else\n-    xmlSchemaFormatNodeForError(&msg, actxt, node);\n-    msg = xmlStrcat(msg, (const xmlChar *) message);\n-    msg = xmlStrcat(msg, BAD_CAST \".\\n\");\n-    xmlSchemaErr4(actxt, error, node,\n-    (const char *) msg, str1, str2, str3, str4);\n-    FREE_AND_NULL(msg)\n-}\n-\n-static void LIBXML_ATTR_FORMAT(5,0)\n-xmlSchemaCustomErr(xmlSchemaAbstractCtxtPtr actxt,\n-           xmlParserErrors error,\n-           xmlNodePtr node,\n-           xmlSchemaBasicItemPtr item,\n-           const char *message,\n-           const xmlChar *str1,\n-           const xmlChar *str2)\n-{\n-    xmlSchemaCustomErr4(actxt, error, node, item,\n-    message, str1, str2, NULL, NULL);\n-}\n-\n-\n-\n-static void LIBXML_ATTR_FORMAT(5,0)\n-xmlSchemaCustomWarning(xmlSchemaAbstractCtxtPtr actxt,\n-           xmlParserErrors error,\n-           xmlNodePtr node,\n-           xmlSchemaTypePtr type ATTRIBUTE_UNUSED,\n-           const char *message,\n-           const xmlChar *str1,\n-           const xmlChar *str2,\n-           const xmlChar *str3)\n-{\n-    xmlChar *msg = NULL;\n-\n-    xmlSchemaFormatNodeForError(&msg, actxt, node);\n-    msg = xmlStrcat(msg, (const xmlChar *) message);\n-    msg = xmlStrcat(msg, BAD_CAST \".\\n\");\n-\n-    \/* URGENT TODO: Set the error code to something sane. *\/\n-    xmlSchemaErr4Line(actxt, XML_ERR_WARNING, error, node, 0,\n-    (const char *) msg, str1, str2, str3, NULL);\n-\n-    FREE_AND_NULL(msg)\n-}\n-\n-\n-\n-static void LIBXML_ATTR_FORMAT(5,0)\n-xmlSchemaKeyrefErr(xmlSchemaValidCtxtPtr vctxt,\n-           xmlParserErrors error,\n-           xmlSchemaPSVIIDCNodePtr idcNode,\n-           xmlSchemaTypePtr type ATTRIBUTE_UNUSED,\n-           const char *message,\n-           const xmlChar *str1,\n-           const xmlChar *str2)\n-{\n-    xmlChar *msg = NULL, *qname = NULL;\n-\n-    msg = xmlStrdup(BAD_CAST \"Element '%s': \");\n-    msg = xmlStrcat(msg, (const xmlChar *) message);\n-    msg = xmlStrcat(msg, BAD_CAST \".\\n\");\n-    xmlSchemaErr4Line(ACTXT_CAST vctxt, XML_ERR_ERROR,\n-    error, NULL, idcNode->nodeLine, (const char *) msg,\n-    xmlSchemaFormatQName(&qname,\n-        vctxt->nodeQNames->items[idcNode->nodeQNameID +1],\n-        vctxt->nodeQNames->items[idcNode->nodeQNameID]),\n-    str1, str2, NULL);\n-    FREE_AND_NULL(qname);\n-    FREE_AND_NULL(msg);\n-}\n-\n-static int\n-xmlSchemaEvalErrorNodeType(xmlSchemaAbstractCtxtPtr actxt,\n-               xmlNodePtr node)\n-{\n-    if (node != NULL)\n-    return (node->type);\n-    if ((actxt->type == XML_SCHEMA_CTXT_VALIDATOR) &&\n-    (((xmlSchemaValidCtxtPtr) actxt)->inode != NULL))\n-    return ( ((xmlSchemaValidCtxtPtr) actxt)->inode->nodeType);\n-    return (-1);\n-}\n-\n-static int\n-xmlSchemaIsGlobalItem(xmlSchemaTypePtr item)\n-{\n-    switch (item->type) {\n-    case XML_SCHEMA_TYPE_COMPLEX:\n-    case XML_SCHEMA_TYPE_SIMPLE:\n-        if (item->flags & XML_SCHEMAS_TYPE_GLOBAL)\n-        return(1);\n-        break;\n-    case XML_SCHEMA_TYPE_GROUP:\n-        return (1);\n-    case XML_SCHEMA_TYPE_ELEMENT:\n-        if ( ((xmlSchemaElementPtr) item)->flags &\n-        XML_SCHEMAS_ELEM_GLOBAL)\n-        return(1);\n-        break;\n-    case XML_SCHEMA_TYPE_ATTRIBUTE:\n-        if ( ((xmlSchemaAttributePtr) item)->flags &\n-        XML_SCHEMAS_ATTR_GLOBAL)\n-        return(1);\n-        break;\n-    \/* Note that attribute groups are always global. *\/\n-    default:\n-        return(1);\n-    }\n-    return (0);\n-}\n-\n-static void\n-xmlSchemaSimpleTypeErr(xmlSchemaAbstractCtxtPtr actxt,\n-               xmlParserErrors error,\n-               xmlNodePtr node,\n-               const xmlChar *value,\n-               xmlSchemaTypePtr type,\n-               int displayValue)\n-{\n-    xmlChar *msg = NULL;\n-\n-    xmlSchemaFormatNodeForError(&msg, actxt, node);\n-\n-    if (displayValue || (xmlSchemaEvalErrorNodeType(actxt, node) ==\n-        XML_ATTRIBUTE_NODE))\n-    msg = xmlStrcat(msg, BAD_CAST \"'%s' is not a valid value of \");\n-    else\n-    msg = xmlStrcat(msg, BAD_CAST \"The character content is not a valid \"\n-        \"value of \");\n-\n-    if (! xmlSchemaIsGlobalItem(type))\n-    msg = xmlStrcat(msg, BAD_CAST \"the local \");\n-    else\n-    msg = xmlStrcat(msg, BAD_CAST \"the \");\n-\n-    if (WXS_IS_ATOMIC(type))\n-    msg = xmlStrcat(msg, BAD_CAST \"atomic type\");\n-    else if (WXS_IS_LIST(type))\n-    msg = xmlStrcat(msg, BAD_CAST \"list type\");\n-    else if (WXS_IS_UNION(type))\n-    msg = xmlStrcat(msg, BAD_CAST \"union type\");\n-\n-    if (xmlSchemaIsGlobalItem(type)) {\n-    xmlChar *str = NULL;\n-    msg = xmlStrcat(msg, BAD_CAST \" '\");\n-    if (type->builtInType != 0) {\n-        msg = xmlStrcat(msg, BAD_CAST \"xs:\");\n-        str = xmlStrdup(type->name);\n-    } else {\n-        const xmlChar *qName = xmlSchemaFormatQName(&str, type->targetNamespace, type->name);\n-        if (!str)\n-        str = xmlStrdup(qName);\n-    }\n-    msg = xmlStrcat(msg, xmlEscapeFormatString(&str));\n-    msg = xmlStrcat(msg, BAD_CAST \"'\");\n-    FREE_AND_NULL(str);\n-    }\n-    msg = xmlStrcat(msg, BAD_CAST \".\\n\");\n-    if (displayValue || (xmlSchemaEvalErrorNodeType(actxt, node) ==\n-        XML_ATTRIBUTE_NODE))\n-    xmlSchemaErr(actxt, error, node, (const char *) msg, value, NULL);\n-    else\n-    xmlSchemaErr(actxt, error, node, (const char *) msg, NULL, NULL);\n-    FREE_AND_NULL(msg)\n-}\n-\n-static const xmlChar *\n-xmlSchemaFormatErrorNodeQName(xmlChar ** str,\n-                  xmlSchemaNodeInfoPtr ni,\n-                  xmlNodePtr node)\n-{\n-    if (node != NULL) {\n-    if (node->ns != NULL)\n-        return (xmlSchemaFormatQName(str, node->ns->href, node->name));\n-    else\n-        return (xmlSchemaFormatQName(str, NULL, node->name));\n-    } else if (ni != NULL)\n-    return (xmlSchemaFormatQName(str, ni->nsName, ni->localName));\n-    return (NULL);\n-}\n-\n-static void\n-xmlSchemaIllegalAttrErr(xmlSchemaAbstractCtxtPtr actxt,\n-            xmlParserErrors error,\n-            xmlSchemaAttrInfoPtr ni,\n-            xmlNodePtr node)\n-{\n-    xmlChar *msg = NULL, *str = NULL;\n-\n-    xmlSchemaFormatNodeForError(&msg, actxt, node);\n-    msg = xmlStrcat(msg, BAD_CAST \"The attribute '%s' is not allowed.\\n\");\n-    xmlSchemaErr(actxt, error, node, (const char *) msg,\n-    xmlSchemaFormatErrorNodeQName(&str, (xmlSchemaNodeInfoPtr) ni, node),\n-    NULL);\n-    FREE_AND_NULL(str)\n-    FREE_AND_NULL(msg)\n-}\n-\n-static void LIBXML_ATTR_FORMAT(5,0)\n-xmlSchemaComplexTypeErr(xmlSchemaAbstractCtxtPtr actxt,\n-                xmlParserErrors error,\n-                xmlNodePtr node,\n-            xmlSchemaTypePtr type ATTRIBUTE_UNUSED,\n-            const char *message,\n-            int nbval,\n-            int nbneg,\n-            xmlChar **values)\n-{\n-    xmlChar *str = NULL, *msg = NULL;\n-    xmlChar *localName, *nsName;\n-    const xmlChar *cur, *end;\n-    int i;\n-\n-    xmlSchemaFormatNodeForError(&msg, actxt, node);\n-    msg = xmlStrcat(msg, (const xmlChar *) message);\n-    msg = xmlStrcat(msg, BAD_CAST \".\");\n-    \/*\n-    * Note that is does not make sense to report that we have a\n-    * wildcard here, since the wildcard might be unfolded into\n-    * multiple transitions.\n-    *\/\n-    if (nbval + nbneg > 0) {\n-    if (nbval + nbneg > 1) {\n-        str = xmlStrdup(BAD_CAST \" Expected is one of ( \");\n-    } else\n-        str = xmlStrdup(BAD_CAST \" Expected is ( \");\n-    nsName = NULL;\n-\n-    for (i = 0; i < nbval + nbneg; i++) {\n-        cur = values[i];\n-        if (cur == NULL)\n-            continue;\n-        if ((cur[0] == 'n') && (cur[1] == 'o') && (cur[2] == 't') &&\n-            (cur[3] == ' ')) {\n-        cur += 4;\n-        str = xmlStrcat(str, BAD_CAST \"##other\");\n-        }\n-        \/*\n-        * Get the local name.\n-        *\/\n-        localName = NULL;\n-\n-        end = cur;\n-        if (*end == '*') {\n-        localName = xmlStrdup(BAD_CAST \"*\");\n-        end++;\n-        } else {\n-        while ((*end != 0) && (*end != '|'))\n-            end++;\n-        localName = xmlStrncat(localName, BAD_CAST cur, end - cur);\n-        }\n-        if (*end != 0) {\n-        end++;\n-        \/*\n-        * Skip \"*|*\" if they come with negated expressions, since\n-        * they represent the same negated wildcard.\n-        *\/\n-        if ((nbneg == 0) || (*end != '*') || (*localName != '*')) {\n-            \/*\n-            * Get the namespace name.\n-            *\/\n-            cur = end;\n-            if (*end == '*') {\n-            nsName = xmlStrdup(BAD_CAST \"{*}\");\n-            } else {\n-            while (*end != 0)\n-                end++;\n-\n-            if (i >= nbval)\n-                nsName = xmlStrdup(BAD_CAST \"{##other:\");\n-            else\n-                nsName = xmlStrdup(BAD_CAST \"{\");\n-\n-            nsName = xmlStrncat(nsName, BAD_CAST cur, end - cur);\n-            nsName = xmlStrcat(nsName, BAD_CAST \"}\");\n-            }\n-            str = xmlStrcat(str, BAD_CAST nsName);\n-            FREE_AND_NULL(nsName)\n-        } else {\n-            FREE_AND_NULL(localName);\n-            continue;\n-        }\n-        }\n-        str = xmlStrcat(str, BAD_CAST localName);\n-        FREE_AND_NULL(localName);\n-\n-        if (i < nbval + nbneg -1)\n-        str = xmlStrcat(str, BAD_CAST \", \");\n-    }\n-    str = xmlStrcat(str, BAD_CAST \" ).\\n\");\n-    msg = xmlStrcat(msg, xmlEscapeFormatString(&str));\n-    FREE_AND_NULL(str)\n-    } else\n-      msg = xmlStrcat(msg, BAD_CAST \"\\n\");\n-    xmlSchemaErr(actxt, error, node, (const char *) msg, NULL, NULL);\n-    xmlFree(msg);\n-}\n-\n-static void LIBXML_ATTR_FORMAT(8,0)\n-xmlSchemaFacetErr(xmlSchemaAbstractCtxtPtr actxt,\n-          xmlParserErrors error,\n-          xmlNodePtr node,\n-          const xmlChar *value,\n-          unsigned long length,\n-          xmlSchemaTypePtr type,\n-          xmlSchemaFacetPtr facet,\n-          const char *message,\n-          const xmlChar *str1,\n-          const xmlChar *str2)\n-{\n-    xmlChar *str = NULL, *msg = NULL;\n-    xmlSchemaTypeType facetType;\n-    int nodeType = xmlSchemaEvalErrorNodeType(actxt, node);\n-\n-    xmlSchemaFormatNodeForError(&msg, actxt, node);\n-    if (error == XML_SCHEMAV_CVC_ENUMERATION_VALID) {\n-    facetType = XML_SCHEMA_FACET_ENUMERATION;\n-    \/*\n-    * If enumerations are validated, one must not expect the\n-    * facet to be given.\n-    *\/\n-    } else\n-    facetType = facet->type;\n-    msg = xmlStrcat(msg, BAD_CAST \"[\");\n-    msg = xmlStrcat(msg, BAD_CAST \"facet '\");\n-    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facetType));\n-    msg = xmlStrcat(msg, BAD_CAST \"'] \");\n-    if (message == NULL) {\n-    \/*\n-    * Use a default message.\n-    *\/\n-    if ((facetType == XML_SCHEMA_FACET_LENGTH) ||\n-        (facetType == XML_SCHEMA_FACET_MINLENGTH) ||\n-        (facetType == XML_SCHEMA_FACET_MAXLENGTH)) {\n-\n-        char len[25], actLen[25];\n-\n-        \/* FIXME, TODO: What is the max expected string length of the\n-        * this value?\n-        *\/\n-        if (nodeType == XML_ATTRIBUTE_NODE)\n-        msg = xmlStrcat(msg, BAD_CAST \"The value '%s' has a length of '%s'; \");\n-        else\n-        msg = xmlStrcat(msg, BAD_CAST \"The value has a length of '%s'; \");\n-\n-        snprintf(len, 24, \"%lu\", xmlSchemaGetFacetValueAsULong(facet));\n-        snprintf(actLen, 24, \"%lu\", length);\n-\n-        if (facetType == XML_SCHEMA_FACET_LENGTH)\n-        msg = xmlStrcat(msg,\n-        BAD_CAST \"this differs from the allowed length of '%s'.\\n\");\n-        else if (facetType == XML_SCHEMA_FACET_MAXLENGTH)\n-        msg = xmlStrcat(msg,\n-        BAD_CAST \"this exceeds the allowed maximum length of '%s'.\\n\");\n-        else if (facetType == XML_SCHEMA_FACET_MINLENGTH)\n-        msg = xmlStrcat(msg,\n-        BAD_CAST \"this underruns the allowed minimum length of '%s'.\\n\");\n-\n-        if (nodeType == XML_ATTRIBUTE_NODE)\n-        xmlSchemaErr3(actxt, error, node, (const char *) msg,\n-            value, (const xmlChar *) actLen, (const xmlChar *) len);\n-        else\n-        xmlSchemaErr(actxt, error, node, (const char *) msg,\n-            (const xmlChar *) actLen, (const xmlChar *) len);\n-\n-    } else if (facetType == XML_SCHEMA_FACET_ENUMERATION) {\n-        msg = xmlStrcat(msg, BAD_CAST \"The value '%s' is not an element \"\n-        \"of the set {%s}.\\n\");\n-        xmlSchemaErr(actxt, error, node, (const char *) msg, value,\n-        xmlSchemaFormatFacetEnumSet(actxt, &str, type));\n-    } else if (facetType == XML_SCHEMA_FACET_PATTERN) {\n-        msg = xmlStrcat(msg, BAD_CAST \"The value '%s' is not accepted \"\n-        \"by the pattern '%s'.\\n\");\n-        xmlSchemaErr(actxt, error, node, (const char *) msg, value,\n-        facet->value);\n-    } else if (facetType == XML_SCHEMA_FACET_MININCLUSIVE) {\n-        msg = xmlStrcat(msg, BAD_CAST \"The value '%s' is less than the \"\n-        \"minimum value allowed ('%s').\\n\");\n-        xmlSchemaErr(actxt, error, node, (const char *) msg, value,\n-        facet->value);\n-    } else if (facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) {\n-        msg = xmlStrcat(msg, BAD_CAST \"The value '%s' is greater than the \"\n-        \"maximum value allowed ('%s').\\n\");\n-        xmlSchemaErr(actxt, error, node, (const char *) msg, value,\n-        facet->value);\n-    } else if (facetType == XML_SCHEMA_FACET_MINEXCLUSIVE) {\n-        msg = xmlStrcat(msg, BAD_CAST \"The value '%s' must be greater than \"\n-        \"'%s'.\\n\");\n-        xmlSchemaErr(actxt, error, node, (const char *) msg, value,\n-        facet->value);\n-    } else if (facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) {\n-        msg = xmlStrcat(msg, BAD_CAST \"The value '%s' must be less than \"\n-        \"'%s'.\\n\");\n-        xmlSchemaErr(actxt, error, node, (const char *) msg, value,\n-        facet->value);\n-    } else if (facetType == XML_SCHEMA_FACET_TOTALDIGITS) {\n-        msg = xmlStrcat(msg, BAD_CAST \"The value '%s' has more \"\n-        \"digits than are allowed ('%s').\\n\");\n-        xmlSchemaErr(actxt, error, node, (const char*) msg, value,\n-        facet->value);\n-    } else if (facetType == XML_SCHEMA_FACET_FRACTIONDIGITS) {\n-        msg = xmlStrcat(msg, BAD_CAST \"The value '%s' has more fractional \"\n-        \"digits than are allowed ('%s').\\n\");\n-        xmlSchemaErr(actxt, error, node, (const char*) msg, value,\n-        facet->value);\n-    } else if (nodeType == XML_ATTRIBUTE_NODE) {\n-        msg = xmlStrcat(msg, BAD_CAST \"The value '%s' is not facet-valid.\\n\");\n-        xmlSchemaErr(actxt, error, node, (const char *) msg, value, NULL);\n-    } else {\n-        msg = xmlStrcat(msg, BAD_CAST \"The value is not facet-valid.\\n\");\n-        xmlSchemaErr(actxt, error, node, (const char *) msg, NULL, NULL);\n-    }\n-    } else {\n-    msg = xmlStrcat(msg, (const xmlChar *) message);\n-    msg = xmlStrcat(msg, BAD_CAST \".\\n\");\n-    xmlSchemaErr(actxt, error, node, (const char *) msg, str1, str2);\n-    }\n-    FREE_AND_NULL(str)\n-    xmlFree(msg);\n-}\n-\n-#define VERROR(err, type, msg) \\\n-    xmlSchemaCustomErr(ACTXT_CAST vctxt, err, NULL, type, msg, NULL, NULL);\n-\n-#define VERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST vctxt, func, msg);\n-\n-#define PERROR_INT(func, msg) xmlSchemaInternalErr(ACTXT_CAST pctxt, func, msg);\n-#define PERROR_INT2(func, msg) xmlSchemaInternalErr(ACTXT_CAST ctxt, func, msg);\n-\n-#define AERROR_INT(func, msg) xmlSchemaInternalErr(actxt, func, msg);\n-\n-\n-\/**\n- * xmlSchemaPMissingAttrErr:\n- * @ctxt: the schema validation context\n- * @ownerItem: the owner as a schema object\n- * @ownerElem: the owner as an element node\n- * @node: the parent element node of the missing attribute node\n- * @type: the corresponding type of the attribute node\n- *\n- * Reports an illegal attribute.\n- *\/\n-static void\n-xmlSchemaPMissingAttrErr(xmlSchemaParserCtxtPtr ctxt,\n-             xmlParserErrors error,\n-             xmlSchemaBasicItemPtr ownerItem,\n-             xmlNodePtr ownerElem,\n-             const char *name,\n-             const char *message)\n-{\n-    xmlChar *des = NULL;\n-\n-    xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);\n-\n-    if (message != NULL)\n-    xmlSchemaPErr(ctxt, ownerElem, error, \"%s: %s.\\n\", BAD_CAST des, BAD_CAST message);\n-    else\n-    xmlSchemaPErr(ctxt, ownerElem, error,\n-        \"%s: The attribute '%s' is required but missing.\\n\",\n-        BAD_CAST des, BAD_CAST name);\n-    FREE_AND_NULL(des);\n-}\n-\n-\n-\/**\n- * xmlSchemaPResCompAttrErr:\n- * @ctxt: the schema validation context\n- * @error: the error code\n- * @ownerItem: the owner as a schema object\n- * @ownerElem: the owner as an element node\n- * @name: the name of the attribute holding the QName\n- * @refName: the referenced local name\n- * @refURI: the referenced namespace URI\n- * @message: optional message\n- *\n- * Used to report QName attribute values that failed to resolve\n- * to schema components.\n- *\/\n-static void\n-xmlSchemaPResCompAttrErr(xmlSchemaParserCtxtPtr ctxt,\n-             xmlParserErrors error,\n-             xmlSchemaBasicItemPtr ownerItem,\n-             xmlNodePtr ownerElem,\n-             const char *name,\n-             const xmlChar *refName,\n-             const xmlChar *refURI,\n-             xmlSchemaTypeType refType,\n-             const char *refTypeStr)\n-{\n-    xmlChar *des = NULL, *strA = NULL;\n-\n-    xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);\n-    if (refTypeStr == NULL)\n-    refTypeStr = (const char *) xmlSchemaItemTypeToStr(refType);\n-    xmlSchemaPErrExt(ctxt, ownerElem, error,\n-        NULL, NULL, NULL,\n-        \"%s, attribute '%s': The QName value '%s' does not resolve to a(n) \"\n-        \"%s.\\n\", BAD_CAST des, BAD_CAST name,\n-        xmlSchemaFormatQName(&strA, refURI, refName),\n-        BAD_CAST refTypeStr, NULL);\n-    FREE_AND_NULL(des)\n-    FREE_AND_NULL(strA)\n-}\n-\n-\/**\n- * xmlSchemaPCustomAttrErr:\n- * @ctxt: the schema parser context\n- * @error: the error code\n- * @ownerDes: the designation of the owner\n- * @ownerItem: the owner as a schema object\n- * @attr: the illegal attribute node\n- *\n- * Reports an illegal attribute during the parse.\n- *\/\n-static void\n-xmlSchemaPCustomAttrErr(xmlSchemaParserCtxtPtr ctxt,\n-            xmlParserErrors error,\n-            xmlChar **ownerDes,\n-            xmlSchemaBasicItemPtr ownerItem,\n-            xmlAttrPtr attr,\n-            const char *msg)\n-{\n-    xmlChar *des = NULL;\n-\n-    if (ownerDes == NULL)\n-    xmlSchemaFormatItemForReport(&des, NULL, ownerItem, attr->parent);\n-    else if (*ownerDes == NULL) {\n-    xmlSchemaFormatItemForReport(ownerDes, NULL, ownerItem, attr->parent);\n-    des = *ownerDes;\n-    } else\n-    des = *ownerDes;\n-    if (attr == NULL) {\n-    xmlSchemaPErrExt(ctxt, NULL, error, NULL, NULL, NULL,\n-        \"%s, attribute '%s': %s.\\n\",\n-        BAD_CAST des, (const xmlChar *) \"Unknown\",\n-        (const xmlChar *) msg, NULL, NULL);\n-    } else {\n-    xmlSchemaPErrExt(ctxt, (xmlNodePtr) attr, error, NULL, NULL, NULL,\n-        \"%s, attribute '%s': %s.\\n\",\n-        BAD_CAST des, attr->name, (const xmlChar *) msg, NULL, NULL);\n-    }\n-    if (ownerDes == NULL)\n-    FREE_AND_NULL(des);\n-}\n-\n-\/**\n- * xmlSchemaPIllegalAttrErr:\n- * @ctxt: the schema parser context\n- * @error: the error code\n- * @ownerItem: the attribute's owner item\n- * @attr: the illegal attribute node\n- *\n- * Reports an illegal attribute during the parse.\n- *\/\n-static void\n-xmlSchemaPIllegalAttrErr(xmlSchemaParserCtxtPtr ctxt,\n-             xmlParserErrors error,\n-             xmlSchemaBasicItemPtr ownerComp ATTRIBUTE_UNUSED,\n-             xmlAttrPtr attr)\n-{\n-    xmlChar *strA = NULL, *strB = NULL;\n-\n-    xmlSchemaFormatNodeForError(&strA, ACTXT_CAST ctxt, attr->parent);\n-    xmlSchemaErr4(ACTXT_CAST ctxt, error, (xmlNodePtr) attr,\n-    \"%sThe attribute '%s' is not allowed.\\n\", BAD_CAST strA,\n-    xmlSchemaFormatQNameNs(&strB, attr->ns, attr->name),\n-    NULL, NULL);\n-    FREE_AND_NULL(strA);\n-    FREE_AND_NULL(strB);\n-}\n-\n-\/**\n- * xmlSchemaPCustomErr:\n- * @ctxt: the schema parser context\n- * @error: the error code\n- * @itemDes: the designation of the schema item\n- * @item: the schema item\n- * @itemElem: the node of the schema item\n- * @message: the error message\n- * @str1: an optional param for the error message\n- * @str2: an optional param for the error message\n- * @str3: an optional param for the error message\n- *\n- * Reports an error during parsing.\n- *\/\n-static void LIBXML_ATTR_FORMAT(5,0)\n-xmlSchemaPCustomErrExt(xmlSchemaParserCtxtPtr ctxt,\n-            xmlParserErrors error,\n-            xmlSchemaBasicItemPtr item,\n-            xmlNodePtr itemElem,\n-            const char *message,\n-            const xmlChar *str1,\n-            const xmlChar *str2,\n-            const xmlChar *str3)\n-{\n-    xmlChar *des = NULL, *msg = NULL;\n-\n-    xmlSchemaFormatItemForReport(&des, NULL, item, itemElem);\n-    msg = xmlStrdup(BAD_CAST \"%s: \");\n-    msg = xmlStrcat(msg, (const xmlChar *) message);\n-    msg = xmlStrcat(msg, BAD_CAST \".\\n\");\n-    if ((itemElem == NULL) && (item != NULL))\n-    itemElem = WXS_ITEM_NODE(item);\n-    xmlSchemaPErrExt(ctxt, itemElem, error, NULL, NULL, NULL,\n-    (const char *) msg, BAD_CAST des, str1, str2, str3, NULL);\n-    FREE_AND_NULL(des);\n-    FREE_AND_NULL(msg);\n-}\n-\n-\/**\n- * xmlSchemaPCustomErr:\n- * @ctxt: the schema parser context\n- * @error: the error code\n- * @itemDes: the designation of the schema item\n- * @item: the schema item\n- * @itemElem: the node of the schema item\n- * @message: the error message\n- * @str1: the optional param for the error message\n- *\n- * Reports an error during parsing.\n- *\/\n-static void LIBXML_ATTR_FORMAT(5,0)\n-xmlSchemaPCustomErr(xmlSchemaParserCtxtPtr ctxt,\n-            xmlParserErrors error,\n-            xmlSchemaBasicItemPtr item,\n-            xmlNodePtr itemElem,\n-            const char *message,\n-            const xmlChar *str1)\n-{\n-    xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message,\n-    str1, NULL, NULL);\n-}\n-\n-\/**\n- * xmlSchemaPAttrUseErr:\n- * @ctxt: the schema parser context\n- * @error: the error code\n- * @itemDes: the designation of the schema type\n- * @item: the schema type\n- * @itemElem: the node of the schema type\n- * @attr: the invalid schema attribute\n- * @message: the error message\n- * @str1: the optional param for the error message\n- *\n- * Reports an attribute use error during parsing.\n- *\/\n-static void LIBXML_ATTR_FORMAT(6,0)\n-xmlSchemaPAttrUseErr4(xmlSchemaParserCtxtPtr ctxt,\n-            xmlParserErrors error,\n-            xmlNodePtr node,\n-            xmlSchemaBasicItemPtr ownerItem,\n-            const xmlSchemaAttributeUsePtr attruse,\n-            const char *message,\n-            const xmlChar *str1, const xmlChar *str2,\n-            const xmlChar *str3,const xmlChar *str4)\n-{\n-    xmlChar *str = NULL, *msg = NULL;\n-\n-    xmlSchemaFormatItemForReport(&msg, NULL, ownerItem, NULL);\n-    msg = xmlStrcat(msg, BAD_CAST \", \");\n-    msg = xmlStrcat(msg,\n-    BAD_CAST xmlSchemaFormatItemForReport(&str, NULL,\n-    WXS_BASIC_CAST attruse, NULL));\n-    FREE_AND_NULL(str);\n-    msg = xmlStrcat(msg, BAD_CAST \": \");\n-    msg = xmlStrcat(msg, (const xmlChar *) message);\n-    msg = xmlStrcat(msg, BAD_CAST \".\\n\");\n-    xmlSchemaErr4(ACTXT_CAST ctxt, error, node,\n-    (const char *) msg, str1, str2, str3, str4);\n-    xmlFree(msg);\n-}\n-\n-\/**\n- * xmlSchemaPIllegalFacetAtomicErr:\n- * @ctxt: the schema parser context\n- * @error: the error code\n- * @type: the schema type\n- * @baseType: the base type of type\n- * @facet: the illegal facet\n- *\n- * Reports an illegal facet for atomic simple types.\n- *\/\n-static void\n-xmlSchemaPIllegalFacetAtomicErr(xmlSchemaParserCtxtPtr ctxt,\n-              xmlParserErrors error,\n-              xmlSchemaTypePtr type,\n-              xmlSchemaTypePtr baseType,\n-              xmlSchemaFacetPtr facet)\n-{\n-    xmlChar *des = NULL, *strT = NULL;\n-\n-    xmlSchemaFormatItemForReport(&des, NULL, WXS_BASIC_CAST type, type->node);\n-    xmlSchemaPErrExt(ctxt, type->node, error, NULL, NULL, NULL,\n-    \"%s: The facet '%s' is not allowed on types derived from the \"\n-    \"type %s.\\n\",\n-    BAD_CAST des, xmlSchemaFacetTypeToString(facet->type),\n-    xmlSchemaFormatItemForReport(&strT, NULL, WXS_BASIC_CAST baseType, NULL),\n-    NULL, NULL);\n-    FREE_AND_NULL(des);\n-    FREE_AND_NULL(strT);\n-}\n-\n-\/**\n- * xmlSchemaPIllegalFacetListUnionErr:\n- * @ctxt: the schema parser context\n- * @error: the error code\n- * @itemDes: the designation of the schema item involved\n- * @item: the schema item involved\n- * @facet: the illegal facet\n- *\n- * Reports an illegal facet for <list> and <union>.\n- *\/\n-static void\n-xmlSchemaPIllegalFacetListUnionErr(xmlSchemaParserCtxtPtr ctxt,\n-              xmlParserErrors error,\n-              xmlSchemaTypePtr type,\n-              xmlSchemaFacetPtr facet)\n-{\n-    xmlChar *des = NULL;\n-\n-    xmlSchemaFormatItemForReport(&des, NULL, WXS_BASIC_CAST type,\n-    type->node);\n-    xmlSchemaPErr(ctxt, type->node, error,\n-    \"%s: The facet '%s' is not allowed.\\n\",\n-    BAD_CAST des, xmlSchemaFacetTypeToString(facet->type));\n-    FREE_AND_NULL(des);\n-}\n-\n-\/**\n- * xmlSchemaPMutualExclAttrErr:\n- * @ctxt: the schema validation context\n- * @error: the error code\n- * @elemDes: the designation of the parent element node\n- * @attr: the bad attribute node\n- * @type: the corresponding type of the attribute node\n- *\n- * Reports an illegal attribute.\n- *\/\n-static void\n-xmlSchemaPMutualExclAttrErr(xmlSchemaParserCtxtPtr ctxt,\n-             xmlParserErrors error,\n-             xmlSchemaBasicItemPtr ownerItem,\n-             xmlAttrPtr attr,\n-             const char *name1,\n-             const char *name2)\n-{\n-    xmlChar *des = NULL;\n-\n-    xmlSchemaFormatItemForReport(&des, NULL, WXS_BASIC_CAST ownerItem, attr->parent);\n-    xmlSchemaPErrExt(ctxt, (xmlNodePtr) attr, error, NULL, NULL, NULL,\n-    \"%s: The attributes '%s' and '%s' are mutually exclusive.\\n\",\n-    BAD_CAST des, BAD_CAST name1, BAD_CAST name2, NULL, NULL);\n-    FREE_AND_NULL(des);\n-}\n-\n-\/**\n- * xmlSchemaPSimpleTypeErr:\n- * @ctxt:  the schema validation context\n- * @error: the error code\n- * @type: the type specifier\n- * @ownerItem: the schema object if existent\n- * @node: the validated node\n- * @value: the validated value\n- *\n- * Reports a simple type validation error.\n- * TODO: Should this report the value of an element as well?\n- *\/\n-static void LIBXML_ATTR_FORMAT(8,0)\n-xmlSchemaPSimpleTypeErr(xmlSchemaParserCtxtPtr ctxt,\n-            xmlParserErrors error,\n-            xmlSchemaBasicItemPtr ownerItem ATTRIBUTE_UNUSED,\n-            xmlNodePtr node,\n-            xmlSchemaTypePtr type,\n-            const char *expected,\n-            const xmlChar *value,\n-            const char *message,\n-            const xmlChar *str1,\n-            const xmlChar *str2)\n-{\n-    xmlChar *msg = NULL;\n-\n-    xmlSchemaFormatNodeForError(&msg, ACTXT_CAST ctxt, node);\n-    if (message == NULL) {\n-    \/*\n-    * Use default messages.\n-    *\/\n-    if (type != NULL) {\n-        if (node->type == XML_ATTRIBUTE_NODE)\n-        msg = xmlStrcat(msg, BAD_CAST \"'%s' is not a valid value of \");\n-        else\n-        msg = xmlStrcat(msg, BAD_CAST \"The character content is not a \"\n-        \"valid value of \");\n-        if (! xmlSchemaIsGlobalItem(type))\n-        msg = xmlStrcat(msg, BAD_CAST \"the local \");\n-        else\n-        msg = xmlStrcat(msg, BAD_CAST \"the \");\n-\n-        if (WXS_IS_ATOMIC(type))\n-        msg = xmlStrcat(msg, BAD_CAST \"atomic type\");\n-        else if (WXS_IS_LIST(type))\n-        msg = xmlStrcat(msg, BAD_CAST \"list type\");\n-        else if (WXS_IS_UNION(type))\n-        msg = xmlStrcat(msg, BAD_CAST \"union type\");\n-\n-        if (xmlSchemaIsGlobalItem(type)) {\n-        xmlChar *str = NULL;\n-        msg = xmlStrcat(msg, BAD_CAST \" '\");\n-        if (type->builtInType != 0) {\n-            msg = xmlStrcat(msg, BAD_CAST \"xs:\");\n-            str = xmlStrdup(type->name);\n-        } else {\n-            const xmlChar *qName = xmlSchemaFormatQName(&str, type->targetNamespace, type->name);\n-            if (!str)\n-            str = xmlStrdup(qName);\n-        }\n-        msg = xmlStrcat(msg, xmlEscapeFormatString(&str));\n-        msg = xmlStrcat(msg, BAD_CAST \"'.\");\n-        FREE_AND_NULL(str);\n-        }\n-    } else {\n-        if (node->type == XML_ATTRIBUTE_NODE)\n-        msg = xmlStrcat(msg, BAD_CAST \"The value '%s' is not valid.\");\n-        else\n-        msg = xmlStrcat(msg, BAD_CAST \"The character content is not \"\n-        \"valid.\");\n-    }\n-    if (expected) {\n-        xmlChar *expectedEscaped = xmlCharStrdup(expected);\n-        msg = xmlStrcat(msg, BAD_CAST \" Expected is '\");\n-        msg = xmlStrcat(msg, xmlEscapeFormatString(&expectedEscaped));\n-        FREE_AND_NULL(expectedEscaped);\n-        msg = xmlStrcat(msg, BAD_CAST \"'.\\n\");\n-    } else\n-        msg = xmlStrcat(msg, BAD_CAST \"\\n\");\n-    if (node->type == XML_ATTRIBUTE_NODE)\n-        xmlSchemaPErr(ctxt, node, error, (const char *) msg, value, NULL);\n-    else\n-        xmlSchemaPErr(ctxt, node, error, (const char *) msg, NULL, NULL);\n-    } else {\n-    msg = xmlStrcat(msg, BAD_CAST message);\n-    msg = xmlStrcat(msg, BAD_CAST \".\\n\");\n-    xmlSchemaPErrExt(ctxt, node, error, NULL, NULL, NULL,\n-         (const char*) msg, str1, str2, NULL, NULL, NULL);\n-    }\n-    \/* Cleanup. *\/\n-    FREE_AND_NULL(msg)\n-}\n-\n-\/**\n- * xmlSchemaPContentErr:\n- * @ctxt: the schema parser context\n- * @error: the error code\n- * @ownerItem: the owner item of the holder of the content\n- * @ownerElem: the node of the holder of the content\n- * @child: the invalid child node\n- * @message: the optional error message\n- * @content: the optional string describing the correct content\n- *\n- * Reports an error concerning the content of a schema element.\n- *\/\n-static void\n-xmlSchemaPContentErr(xmlSchemaParserCtxtPtr ctxt,\n-             xmlParserErrors error,\n-             xmlSchemaBasicItemPtr ownerItem,\n-             xmlNodePtr ownerElem,\n-             xmlNodePtr child,\n-             const char *message,\n-             const char *content)\n-{\n-    xmlChar *des = NULL;\n-\n-    xmlSchemaFormatItemForReport(&des, NULL, ownerItem, ownerElem);\n-    if (message != NULL)\n-    xmlSchemaPErr2(ctxt, ownerElem, child, error,\n-        \"%s: %s.\\n\",\n-        BAD_CAST des, BAD_CAST message);\n-    else {\n-    if (content != NULL) {\n-        xmlSchemaPErr2(ctxt, ownerElem, child, error,\n-        \"%s: The content is not valid. Expected is %s.\\n\",\n-        BAD_CAST des, BAD_CAST content);\n-    } else {\n-        xmlSchemaPErr2(ctxt, ownerElem, child, error,\n-        \"%s: The content is not valid.\\n\",\n-        BAD_CAST des, NULL);\n-    }\n-    }\n-    FREE_AND_NULL(des)\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Streamable error functions                      *\n- *                                    *\n- ************************************************************************\/\n-\n-\n-\n-\n-\/************************************************************************\n- *                                    *\n- *            Validation helper functions            *\n- *                                    *\n- ************************************************************************\/\n-\n-\n-\/************************************************************************\n- *                                    *\n- *            Allocation functions                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlSchemaNewSchemaForParserCtxt:\n- * @ctxt:  a schema validation context\n- *\n- * Allocate a new Schema structure.\n- *\n- * Returns the newly allocated structure or NULL in case or error\n- *\/\n-static xmlSchemaPtr\n-xmlSchemaNewSchema(xmlSchemaParserCtxtPtr ctxt)\n-{\n-    xmlSchemaPtr ret;\n-\n-    ret = (xmlSchemaPtr) xmlMalloc(sizeof(xmlSchema));\n-    if (ret == NULL) {\n-        xmlSchemaPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchema));\n-    ret->dict = ctxt->dict;\n-    xmlDictReference(ret->dict);\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaNewFacet:\n- *\n- * Allocate a new Facet structure.\n- *\n- * Returns the newly allocated structure or NULL in case or error\n- *\/\n-xmlSchemaFacetPtr\n-xmlSchemaNewFacet(void)\n-{\n-    xmlSchemaFacetPtr ret;\n-\n-    ret = (xmlSchemaFacetPtr) xmlMalloc(sizeof(xmlSchemaFacet));\n-    if (ret == NULL) {\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaFacet));\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaNewAnnot:\n- * @ctxt:  a schema validation context\n- * @node:  a node\n- *\n- * Allocate a new annotation structure.\n- *\n- * Returns the newly allocated structure or NULL in case or error\n- *\/\n-static xmlSchemaAnnotPtr\n-xmlSchemaNewAnnot(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlSchemaAnnotPtr ret;\n-\n-    ret = (xmlSchemaAnnotPtr) xmlMalloc(sizeof(xmlSchemaAnnot));\n-    if (ret == NULL) {\n-        xmlSchemaPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaAnnot));\n-    ret->content = node;\n-    return (ret);\n-}\n-\n-static xmlSchemaItemListPtr\n-xmlSchemaItemListCreate(void)\n-{\n-    xmlSchemaItemListPtr ret;\n-\n-    ret = xmlMalloc(sizeof(xmlSchemaItemList));\n-    if (ret == NULL) {\n-    xmlSchemaPErrMemory(NULL);\n-    return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaItemList));\n-    return (ret);\n-}\n-\n-static void\n-xmlSchemaItemListClear(xmlSchemaItemListPtr list)\n-{\n-    if (list->items != NULL) {\n-    xmlFree(list->items);\n-    list->items = NULL;\n-    }\n-    list->nbItems = 0;\n-    list->sizeItems = 0;\n-}\n-\n-static int\n-xmlSchemaItemListAdd(xmlSchemaItemListPtr list, void *item)\n-{\n-    if (list->sizeItems <= list->nbItems) {\n-        void **tmp;\n-        size_t newSize = list->sizeItems == 0 ? 20 : list->sizeItems * 2;\n-\n-    tmp = (void **) xmlRealloc(list->items, newSize * sizeof(void *));\n-    if (tmp == NULL) {\n-        xmlSchemaPErrMemory(NULL);\n-        return(-1);\n-    }\n-        list->items = tmp;\n-    list->sizeItems = newSize;\n-    }\n-    list->items[list->nbItems++] = item;\n-    return(0);\n-}\n-\n-static int\n-xmlSchemaItemListAddSize(xmlSchemaItemListPtr list,\n-             int initialSize,\n-             void *item)\n-{\n-    if (list->items == NULL) {\n-    if (initialSize <= 0)\n-        initialSize = 1;\n-    list->items = (void **) xmlMalloc(\n-        initialSize * sizeof(void *));\n-    if (list->items == NULL) {\n-        xmlSchemaPErrMemory(NULL);\n-        return(-1);\n-    }\n-    list->sizeItems = initialSize;\n-    } else if (list->sizeItems <= list->nbItems) {\n-        void **tmp;\n-\n-    list->sizeItems *= 2;\n-    tmp = (void **) xmlRealloc(list->items,\n-        list->sizeItems * sizeof(void *));\n-    if (tmp == NULL) {\n-        xmlSchemaPErrMemory(NULL);\n-        list->sizeItems \/= 2;\n-        return(-1);\n-    }\n-        list->items = tmp;\n-    }\n-    list->items[list->nbItems++] = item;\n-    return(0);\n-}\n-\n-static int\n-xmlSchemaItemListInsert(xmlSchemaItemListPtr list, void *item, int idx)\n-{\n-    if (list->sizeItems <= list->nbItems) {\n-        void **tmp;\n-        size_t newSize = list->sizeItems == 0 ? 20 : list->sizeItems * 2;\n-\n-    tmp = (void **) xmlRealloc(list->items, newSize * sizeof(void *));\n-    if (tmp == NULL) {\n-        xmlSchemaPErrMemory(NULL);\n-        return(-1);\n-    }\n-        list->items = tmp;\n-    list->sizeItems = newSize;\n-    }\n-    \/*\n-    * Just append if the index is greater\/equal than the item count.\n-    *\/\n-    if (idx >= list->nbItems) {\n-    list->items[list->nbItems++] = item;\n-    } else {\n-    int i;\n-    for (i = list->nbItems; i > idx; i--)\n-        list->items[i] = list->items[i-1];\n-    list->items[idx] = item;\n-    list->nbItems++;\n-    }\n-    return(0);\n-}\n-\n-#if 0 \/* enable if ever needed *\/\n-static int\n-xmlSchemaItemListInsertSize(xmlSchemaItemListPtr list,\n-                int initialSize,\n-                void *item,\n-                int idx)\n-{\n-    if (list->items == NULL) {\n-    if (initialSize <= 0)\n-        initialSize = 1;\n-    list->items = (void **) xmlMalloc(\n-        initialSize * sizeof(void *));\n-    if (list->items == NULL) {\n-        xmlSchemaPErrMemory(NULL);\n-        return(-1);\n-    }\n-    list->sizeItems = initialSize;\n-    } else if (list->sizeItems <= list->nbItems) {\n-    list->sizeItems *= 2;\n-    list->items = (void **) xmlRealloc(list->items,\n-        list->sizeItems * sizeof(void *));\n-    if (list->items == NULL) {\n-        xmlSchemaPErrMemory(NULL);\n-        list->sizeItems = 0;\n-        return(-1);\n-    }\n-    }\n-    \/*\n-    * Just append if the index is greater\/equal than the item count.\n-    *\/\n-    if (idx >= list->nbItems) {\n-    list->items[list->nbItems++] = item;\n-    } else {\n-    int i;\n-    for (i = list->nbItems; i > idx; i--)\n-        list->items[i] = list->items[i-1];\n-    list->items[idx] = item;\n-    list->nbItems++;\n-    }\n-    return(0);\n-}\n-#endif\n-\n-static int\n-xmlSchemaItemListRemove(xmlSchemaItemListPtr list, int idx)\n-{\n-    int i;\n-    if ((list->items == NULL) || (idx >= list->nbItems))\n-    return(-1);\n-\n-    if (list->nbItems == 1) {\n-    \/* TODO: Really free the list? *\/\n-    xmlFree(list->items);\n-    list->items = NULL;\n-    list->nbItems = 0;\n-    list->sizeItems = 0;\n-    } else if (list->nbItems -1 == idx) {\n-    list->nbItems--;\n-    } else {\n-    for (i = idx; i < list->nbItems -1; i++)\n-        list->items[i] = list->items[i+1];\n-    list->nbItems--;\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaItemListFree:\n- * @annot:  a schema type structure\n- *\n- * Deallocate a annotation structure\n- *\/\n-static void\n-xmlSchemaItemListFree(xmlSchemaItemListPtr list)\n-{\n-    if (list == NULL)\n-    return;\n-    if (list->items != NULL)\n-    xmlFree(list->items);\n-    xmlFree(list);\n-}\n-\n-static void\n-xmlSchemaBucketFree(xmlSchemaBucketPtr bucket)\n-{\n-    if (bucket == NULL)\n-    return;\n-    if (bucket->globals != NULL) {\n-    xmlSchemaComponentListFree(bucket->globals);\n-    xmlSchemaItemListFree(bucket->globals);\n-    }\n-    if (bucket->locals != NULL) {\n-    xmlSchemaComponentListFree(bucket->locals);\n-    xmlSchemaItemListFree(bucket->locals);\n-    }\n-    if (bucket->relations != NULL) {\n-    xmlSchemaSchemaRelationPtr prev, cur = bucket->relations;\n-    do {\n-        prev = cur;\n-        cur = cur->next;\n-        xmlFree(prev);\n-    } while (cur != NULL);\n-    }\n-    if ((! bucket->preserveDoc) && (bucket->doc != NULL)) {\n-    xmlFreeDoc(bucket->doc);\n-    }\n-    if (bucket->type == XML_SCHEMA_SCHEMA_IMPORT) {\n-    if (WXS_IMPBUCKET(bucket)->schema != NULL)\n-        xmlSchemaFree(WXS_IMPBUCKET(bucket)->schema);\n-    }\n-    xmlFree(bucket);\n-}\n-\n-static void\n-xmlSchemaBucketFreeEntry(void *bucket, const xmlChar *name ATTRIBUTE_UNUSED)\n-{\n-    xmlSchemaBucketFree((xmlSchemaBucketPtr) bucket);\n-}\n-\n-static xmlSchemaBucketPtr\n-xmlSchemaBucketCreate(xmlSchemaParserCtxtPtr pctxt,\n-             int type, const xmlChar *targetNamespace)\n-{\n-    xmlSchemaBucketPtr ret;\n-    int size;\n-    xmlSchemaPtr mainSchema;\n-\n-    if (WXS_CONSTRUCTOR(pctxt)->mainSchema == NULL) {\n-    PERROR_INT(\"xmlSchemaBucketCreate\",\n-        \"no main schema on constructor\");\n-    return(NULL);\n-    }\n-    mainSchema = WXS_CONSTRUCTOR(pctxt)->mainSchema;\n-    \/* Create the schema bucket. *\/\n-    if (WXS_IS_BUCKET_INCREDEF(type))\n-    size = sizeof(xmlSchemaInclude);\n-    else\n-    size = sizeof(xmlSchemaImport);\n-    ret = (xmlSchemaBucketPtr) xmlMalloc(size);\n-    if (ret == NULL) {\n-    xmlSchemaPErrMemory(NULL);\n-    return(NULL);\n-    }\n-    memset(ret, 0, size);\n-    ret->targetNamespace = targetNamespace;\n-    ret->type = type;\n-    ret->globals = xmlSchemaItemListCreate();\n-    if (ret->globals == NULL) {\n-    xmlSchemaBucketFree(ret);\n-    return(NULL);\n-    }\n-    ret->locals = xmlSchemaItemListCreate();\n-    if (ret->locals == NULL) {\n-    xmlSchemaBucketFree(ret);\n-    return(NULL);\n-    }\n-    \/*\n-    * The following will assure that only the first bucket is marked as\n-    * XML_SCHEMA_SCHEMA_MAIN and it points to the *main* schema.\n-    * For each following import buckets an xmlSchema will be created.\n-    * An xmlSchema will be created for every distinct targetNamespace.\n-    * We assign the targetNamespace to the schemata here.\n-    *\/\n-    if (! WXS_HAS_BUCKETS(pctxt)) {\n-    if (WXS_IS_BUCKET_INCREDEF(type)) {\n-        PERROR_INT(\"xmlSchemaBucketCreate\",\n-        \"first bucket but it's an include or redefine\");\n-        xmlSchemaBucketFree(ret);\n-        return(NULL);\n-    }\n-    \/* Force the type to be XML_SCHEMA_SCHEMA_MAIN. *\/\n-    ret->type = XML_SCHEMA_SCHEMA_MAIN;\n-    \/* Point to the *main* schema. *\/\n-    WXS_CONSTRUCTOR(pctxt)->mainBucket = ret;\n-    WXS_IMPBUCKET(ret)->schema = mainSchema;\n-    \/*\n-    * Ensure that the main schema gets a targetNamespace.\n-    *\/\n-    mainSchema->targetNamespace = targetNamespace;\n-    } else {\n-    if (type == XML_SCHEMA_SCHEMA_MAIN) {\n-        PERROR_INT(\"xmlSchemaBucketCreate\",\n-        \"main bucket but it's not the first one\");\n-        xmlSchemaBucketFree(ret);\n-        return(NULL);\n-    } else if (type == XML_SCHEMA_SCHEMA_IMPORT) {\n-        \/*\n-        * Create a schema for imports and assign the\n-        * targetNamespace.\n-        *\/\n-        WXS_IMPBUCKET(ret)->schema = xmlSchemaNewSchema(pctxt);\n-        if (WXS_IMPBUCKET(ret)->schema == NULL) {\n-        xmlSchemaBucketFree(ret);\n-        return(NULL);\n-        }\n-        WXS_IMPBUCKET(ret)->schema->targetNamespace = targetNamespace;\n-    }\n-    }\n-    if (WXS_IS_BUCKET_IMPMAIN(type)) {\n-    int res;\n-    \/*\n-    * Imports go into the \"schemasImports\" slot of the main *schema*.\n-    * Note that we create an import entry for the main schema as well; i.e.,\n-    * even if there's only one schema, we'll get an import.\n-    *\/\n-    if (mainSchema->schemasImports == NULL) {\n-        mainSchema->schemasImports = xmlHashCreateDict(5,\n-        WXS_CONSTRUCTOR(pctxt)->dict);\n-        if (mainSchema->schemasImports == NULL) {\n-        xmlSchemaBucketFree(ret);\n-        return(NULL);\n-        }\n-    }\n-    if (targetNamespace == NULL)\n-        res = xmlHashAddEntry(mainSchema->schemasImports,\n-        XML_SCHEMAS_NO_NAMESPACE, ret);\n-    else\n-        res = xmlHashAddEntry(mainSchema->schemasImports,\n-        targetNamespace, ret);\n-    if (res != 0) {\n-        PERROR_INT(\"xmlSchemaBucketCreate\",\n-        \"failed to add the schema bucket to the hash\");\n-        xmlSchemaBucketFree(ret);\n-        return(NULL);\n-    }\n-    } else {\n-    \/* Set the @ownerImport of an include bucket. *\/\n-    if (WXS_IS_BUCKET_IMPMAIN(WXS_CONSTRUCTOR(pctxt)->bucket->type))\n-        WXS_INCBUCKET(ret)->ownerImport =\n-        WXS_IMPBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket);\n-    else\n-        WXS_INCBUCKET(ret)->ownerImport =\n-        WXS_INCBUCKET(WXS_CONSTRUCTOR(pctxt)->bucket)->ownerImport;\n-\n-    \/* Includes got into the \"includes\" slot of the *main* schema. *\/\n-    if (mainSchema->includes == NULL) {\n-        mainSchema->includes = xmlSchemaItemListCreate();\n-        if (mainSchema->includes == NULL) {\n-        xmlSchemaBucketFree(ret);\n-        return(NULL);\n-        }\n-    }\n-    if (xmlSchemaItemListAdd(mainSchema->includes, ret) < 0) {\n-        xmlSchemaBucketFree(ret);\n-        return(NULL);\n-        }\n-    }\n-    \/*\n-    * Add to list of all buckets; this is used for lookup\n-    * during schema construction time only.\n-    *\/\n-    if (xmlSchemaItemListAdd(WXS_CONSTRUCTOR(pctxt)->buckets, ret) == -1)\n-    return(NULL);\n-    return(ret);\n-}\n-\n-static int\n-xmlSchemaAddItemSize(xmlSchemaItemListPtr *list, int initialSize, void *item)\n-{\n-    if (*list == NULL) {\n-    *list = xmlSchemaItemListCreate();\n-    if (*list == NULL)\n-        return(-1);\n-    }\n-    return(xmlSchemaItemListAddSize(*list, initialSize, item));\n-}\n-\n-\/**\n- * xmlSchemaFreeAnnot:\n- * @annot:  a schema type structure\n- *\n- * Deallocate a annotation structure\n- *\/\n-static void\n-xmlSchemaFreeAnnot(xmlSchemaAnnotPtr annot)\n-{\n-    if (annot == NULL)\n-        return;\n-    if (annot->next == NULL) {\n-    xmlFree(annot);\n-    } else {\n-    xmlSchemaAnnotPtr prev;\n-\n-    do {\n-        prev = annot;\n-        annot = annot->next;\n-        xmlFree(prev);\n-    } while (annot != NULL);\n-    }\n-}\n-\n-\/**\n- * xmlSchemaFreeNotation:\n- * @schema:  a schema notation structure\n- *\n- * Deallocate a Schema Notation structure.\n- *\/\n-static void\n-xmlSchemaFreeNotation(xmlSchemaNotationPtr nota)\n-{\n-    if (nota == NULL)\n-        return;\n-    if (nota->annot != NULL)\n-    xmlSchemaFreeAnnot(nota->annot);\n-    xmlFree(nota);\n-}\n-\n-\/**\n- * xmlSchemaFreeAttribute:\n- * @attr:  an attribute declaration\n- *\n- * Deallocates an attribute declaration structure.\n- *\/\n-static void\n-xmlSchemaFreeAttribute(xmlSchemaAttributePtr attr)\n-{\n-    if (attr == NULL)\n-        return;\n-    if (attr->annot != NULL)\n-    xmlSchemaFreeAnnot(attr->annot);\n-    if (attr->defVal != NULL)\n-    xmlSchemaFreeValue(attr->defVal);\n-    xmlFree(attr);\n-}\n-\n-\/**\n- * xmlSchemaFreeAttributeUse:\n- * @use:  an attribute use\n- *\n- * Deallocates an attribute use structure.\n- *\/\n-static void\n-xmlSchemaFreeAttributeUse(xmlSchemaAttributeUsePtr use)\n-{\n-    if (use == NULL)\n-        return;\n-    if (use->annot != NULL)\n-    xmlSchemaFreeAnnot(use->annot);\n-    if (use->defVal != NULL)\n-    xmlSchemaFreeValue(use->defVal);\n-    xmlFree(use);\n-}\n-\n-\/**\n- * xmlSchemaFreeAttributeUseProhib:\n- * @prohib:  an attribute use prohibition\n- *\n- * Deallocates an attribute use structure.\n- *\/\n-static void\n-xmlSchemaFreeAttributeUseProhib(xmlSchemaAttributeUseProhibPtr prohib)\n-{\n-    if (prohib == NULL)\n-        return;\n-    xmlFree(prohib);\n-}\n-\n-\/**\n- * xmlSchemaFreeWildcardNsSet:\n- * set:  a schema wildcard namespace\n- *\n- * Deallocates a list of wildcard constraint structures.\n- *\/\n-static void\n-xmlSchemaFreeWildcardNsSet(xmlSchemaWildcardNsPtr set)\n-{\n-    xmlSchemaWildcardNsPtr next;\n-\n-    while (set != NULL) {\n-    next = set->next;\n-    xmlFree(set);\n-    set = next;\n-    }\n-}\n-\n-\/**\n- * xmlSchemaFreeWildcard:\n- * @wildcard:  a wildcard structure\n- *\n- * Deallocates a wildcard structure.\n- *\/\n-void\n-xmlSchemaFreeWildcard(xmlSchemaWildcardPtr wildcard)\n-{\n-    if (wildcard == NULL)\n-        return;\n-    if (wildcard->annot != NULL)\n-        xmlSchemaFreeAnnot(wildcard->annot);\n-    if (wildcard->nsSet != NULL)\n-    xmlSchemaFreeWildcardNsSet(wildcard->nsSet);\n-    if (wildcard->negNsSet != NULL)\n-    xmlFree(wildcard->negNsSet);\n-    xmlFree(wildcard);\n-}\n-\n-\/**\n- * xmlSchemaFreeAttributeGroup:\n- * @schema:  a schema attribute group structure\n- *\n- * Deallocate a Schema Attribute Group structure.\n- *\/\n-static void\n-xmlSchemaFreeAttributeGroup(xmlSchemaAttributeGroupPtr attrGr)\n-{\n-    if (attrGr == NULL)\n-        return;\n-    if (attrGr->annot != NULL)\n-        xmlSchemaFreeAnnot(attrGr->annot);\n-    if (attrGr->attrUses != NULL)\n-    xmlSchemaItemListFree(WXS_LIST_CAST attrGr->attrUses);\n-    xmlFree(attrGr);\n-}\n-\n-\/**\n- * xmlSchemaFreeQNameRef:\n- * @item: a QName reference structure\n- *\n- * Deallocatea a QName reference structure.\n- *\/\n-static void\n-xmlSchemaFreeQNameRef(xmlSchemaQNameRefPtr item)\n-{\n-    xmlFree(item);\n-}\n-\n-\/**\n- * xmlSchemaFreeTypeLinkList:\n- * @alink: a type link\n- *\n- * Deallocate a list of types.\n- *\/\n-static void\n-xmlSchemaFreeTypeLinkList(xmlSchemaTypeLinkPtr link)\n-{\n-    xmlSchemaTypeLinkPtr next;\n-\n-    while (link != NULL) {\n-    next = link->next;\n-    xmlFree(link);\n-    link = next;\n-    }\n-}\n-\n-static void\n-xmlSchemaFreeIDCStateObjList(xmlSchemaIDCStateObjPtr sto)\n-{\n-    xmlSchemaIDCStateObjPtr next;\n-    while (sto != NULL) {\n-    next = sto->next;\n-    if (sto->history != NULL)\n-        xmlFree(sto->history);\n-    if (sto->xpathCtxt != NULL)\n-        xmlFreeStreamCtxt((xmlStreamCtxtPtr) sto->xpathCtxt);\n-    xmlFree(sto);\n-    sto = next;\n-    }\n-}\n-\n-\/**\n- * xmlSchemaFreeIDC:\n- * @idc: a identity-constraint definition\n- *\n- * Deallocates an identity-constraint definition.\n- *\/\n-static void\n-xmlSchemaFreeIDC(xmlSchemaIDCPtr idcDef)\n-{\n-    xmlSchemaIDCSelectPtr cur, prev;\n-\n-    if (idcDef == NULL)\n-    return;\n-    if (idcDef->annot != NULL)\n-        xmlSchemaFreeAnnot(idcDef->annot);\n-    \/* Selector *\/\n-    if (idcDef->selector != NULL) {\n-    if (idcDef->selector->xpathComp != NULL)\n-        xmlFreePattern((xmlPatternPtr) idcDef->selector->xpathComp);\n-    xmlFree(idcDef->selector);\n-    }\n-    \/* Fields *\/\n-    if (idcDef->fields != NULL) {\n-    cur = idcDef->fields;\n-    do {\n-        prev = cur;\n-        cur = cur->next;\n-        if (prev->xpathComp != NULL)\n-        xmlFreePattern((xmlPatternPtr) prev->xpathComp);\n-        xmlFree(prev);\n-    } while (cur != NULL);\n-    }\n-    xmlFree(idcDef);\n-}\n-\n-\/**\n- * xmlSchemaFreeElement:\n- * @schema:  a schema element structure\n- *\n- * Deallocate a Schema Element structure.\n- *\/\n-static void\n-xmlSchemaFreeElement(xmlSchemaElementPtr elem)\n-{\n-    if (elem == NULL)\n-        return;\n-    if (elem->annot != NULL)\n-        xmlSchemaFreeAnnot(elem->annot);\n-    if (elem->contModel != NULL)\n-        xmlRegFreeRegexp(elem->contModel);\n-    if (elem->defVal != NULL)\n-    xmlSchemaFreeValue(elem->defVal);\n-    xmlFree(elem);\n-}\n-\n-\/**\n- * xmlSchemaFreeFacet:\n- * @facet:  a schema facet structure\n- *\n- * Deallocate a Schema Facet structure.\n- *\/\n-void\n-xmlSchemaFreeFacet(xmlSchemaFacetPtr facet)\n-{\n-    if (facet == NULL)\n-        return;\n-    if (facet->val != NULL)\n-        xmlSchemaFreeValue(facet->val);\n-    if (facet->regexp != NULL)\n-        xmlRegFreeRegexp(facet->regexp);\n-    if (facet->annot != NULL)\n-        xmlSchemaFreeAnnot(facet->annot);\n-    xmlFree(facet);\n-}\n-\n-\/**\n- * xmlSchemaFreeType:\n- * @type:  a schema type structure\n- *\n- * Deallocate a Schema Type structure.\n- *\/\n-void\n-xmlSchemaFreeType(xmlSchemaTypePtr type)\n-{\n-    if (type == NULL)\n-        return;\n-    if (type->annot != NULL)\n-        xmlSchemaFreeAnnot(type->annot);\n-    if (type->facets != NULL) {\n-        xmlSchemaFacetPtr facet, next;\n-\n-        facet = type->facets;\n-        while (facet != NULL) {\n-            next = facet->next;\n-            xmlSchemaFreeFacet(facet);\n-            facet = next;\n-        }\n-    }\n-    if (type->attrUses != NULL)\n-    xmlSchemaItemListFree((xmlSchemaItemListPtr) type->attrUses);\n-    if (type->memberTypes != NULL)\n-    xmlSchemaFreeTypeLinkList(type->memberTypes);\n-    if (type->facetSet != NULL) {\n-    xmlSchemaFacetLinkPtr next, link;\n-\n-    link = type->facetSet;\n-    do {\n-        next = link->next;\n-        xmlFree(link);\n-        link = next;\n-    } while (link != NULL);\n-    }\n-    if (type->contModel != NULL)\n-        xmlRegFreeRegexp(type->contModel);\n-    xmlFree(type);\n-}\n-\n-\/**\n- * xmlSchemaFreeModelGroupDef:\n- * @item:  a schema model group definition\n- *\n- * Deallocates a schema model group definition.\n- *\/\n-static void\n-xmlSchemaFreeModelGroupDef(xmlSchemaModelGroupDefPtr item)\n-{\n-    if (item->annot != NULL)\n-    xmlSchemaFreeAnnot(item->annot);\n-    xmlFree(item);\n-}\n-\n-\/**\n- * xmlSchemaFreeModelGroup:\n- * @item:  a schema model group\n- *\n- * Deallocates a schema model group structure.\n- *\/\n-static void\n-xmlSchemaFreeModelGroup(xmlSchemaModelGroupPtr item)\n-{\n-    if (item->annot != NULL)\n-    xmlSchemaFreeAnnot(item->annot);\n-    xmlFree(item);\n-}\n-\n-static void\n-xmlSchemaComponentListFree(xmlSchemaItemListPtr list)\n-{\n-    if ((list == NULL) || (list->nbItems == 0))\n-    return;\n-    {\n-    xmlSchemaTreeItemPtr item;\n-    xmlSchemaTreeItemPtr *items = (xmlSchemaTreeItemPtr *) list->items;\n-    int i;\n-\n-    for (i = 0; i < list->nbItems; i++) {\n-        item = items[i];\n-        if (item == NULL)\n-        continue;\n-        switch (item->type) {\n-        case XML_SCHEMA_TYPE_SIMPLE:\n-        case XML_SCHEMA_TYPE_COMPLEX:\n-            xmlSchemaFreeType((xmlSchemaTypePtr) item);\n-            break;\n-        case XML_SCHEMA_TYPE_ATTRIBUTE:\n-            xmlSchemaFreeAttribute((xmlSchemaAttributePtr) item);\n-            break;\n-        case XML_SCHEMA_TYPE_ATTRIBUTE_USE:\n-            xmlSchemaFreeAttributeUse((xmlSchemaAttributeUsePtr) item);\n-            break;\n-        case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:\n-            xmlSchemaFreeAttributeUseProhib(\n-            (xmlSchemaAttributeUseProhibPtr) item);\n-            break;\n-        case XML_SCHEMA_TYPE_ELEMENT:\n-            xmlSchemaFreeElement((xmlSchemaElementPtr) item);\n-            break;\n-        case XML_SCHEMA_TYPE_PARTICLE:\n-            if (item->annot != NULL)\n-            xmlSchemaFreeAnnot(item->annot);\n-            xmlFree(item);\n-            break;\n-        case XML_SCHEMA_TYPE_SEQUENCE:\n-        case XML_SCHEMA_TYPE_CHOICE:\n-        case XML_SCHEMA_TYPE_ALL:\n-            xmlSchemaFreeModelGroup((xmlSchemaModelGroupPtr) item);\n-            break;\n-        case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:\n-            xmlSchemaFreeAttributeGroup(\n-            (xmlSchemaAttributeGroupPtr) item);\n-            break;\n-        case XML_SCHEMA_TYPE_GROUP:\n-            xmlSchemaFreeModelGroupDef(\n-            (xmlSchemaModelGroupDefPtr) item);\n-            break;\n-        case XML_SCHEMA_TYPE_ANY:\n-        case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:\n-            xmlSchemaFreeWildcard((xmlSchemaWildcardPtr) item);\n-            break;\n-        case XML_SCHEMA_TYPE_IDC_KEY:\n-        case XML_SCHEMA_TYPE_IDC_UNIQUE:\n-        case XML_SCHEMA_TYPE_IDC_KEYREF:\n-            xmlSchemaFreeIDC((xmlSchemaIDCPtr) item);\n-            break;\n-        case XML_SCHEMA_TYPE_NOTATION:\n-            xmlSchemaFreeNotation((xmlSchemaNotationPtr) item);\n-            break;\n-        case XML_SCHEMA_EXTRA_QNAMEREF:\n-            xmlSchemaFreeQNameRef((xmlSchemaQNameRefPtr) item);\n-            break;\n-        default:\n-            \/* TODO: This should never be hit. *\/\n-            break;\n-        }\n-    }\n-    list->nbItems = 0;\n-    }\n-}\n-\n-\/**\n- * xmlSchemaFree:\n- * @schema:  a schema structure\n- *\n- * Deallocate a Schema structure.\n- *\/\n-void\n-xmlSchemaFree(xmlSchemaPtr schema)\n-{\n-    if (schema == NULL)\n-        return;\n-    \/*\n-    * Note that those slots are not responsible for freeing\n-    * schema components anymore; this will now be done by\n-    * the schema buckets.\n-    *\/\n-    if (schema->notaDecl != NULL)\n-        xmlHashFree(schema->notaDecl, NULL);\n-    if (schema->attrDecl != NULL)\n-        xmlHashFree(schema->attrDecl, NULL);\n-    if (schema->attrgrpDecl != NULL)\n-        xmlHashFree(schema->attrgrpDecl, NULL);\n-    if (schema->elemDecl != NULL)\n-        xmlHashFree(schema->elemDecl, NULL);\n-    if (schema->typeDecl != NULL)\n-        xmlHashFree(schema->typeDecl, NULL);\n-    if (schema->groupDecl != NULL)\n-        xmlHashFree(schema->groupDecl, NULL);\n-    if (schema->idcDef != NULL)\n-        xmlHashFree(schema->idcDef, NULL);\n-\n-    if (schema->schemasImports != NULL)\n-    xmlHashFree(schema->schemasImports, xmlSchemaBucketFreeEntry);\n-    if (schema->includes != NULL) {\n-    xmlSchemaItemListPtr list = (xmlSchemaItemListPtr) schema->includes;\n-    int i;\n-    for (i = 0; i < list->nbItems; i++) {\n-        xmlSchemaBucketFree((xmlSchemaBucketPtr) list->items[i]);\n-    }\n-    xmlSchemaItemListFree(list);\n-    }\n-    if (schema->annot != NULL)\n-        xmlSchemaFreeAnnot(schema->annot);\n-    \/* Never free the doc here, since this will be done by the buckets. *\/\n-\n-    xmlDictFree(schema->dict);\n-    xmlFree(schema);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Debug functions                    *\n- *                                    *\n- ************************************************************************\/\n-\n-#ifdef LIBXML_OUTPUT_ENABLED\n-\n-static void\n-xmlSchemaTypeDump(xmlSchemaTypePtr type, FILE * output); \/* forward *\/\n-\n-\/**\n- * xmlSchemaElementDump:\n- * @elem:  an element\n- * @output:  the file output\n- *\n- * Dump the element\n- *\/\n-static void\n-xmlSchemaElementDump(void *payload, void *data,\n-                     const xmlChar * name ATTRIBUTE_UNUSED,\n-             const xmlChar * namespace ATTRIBUTE_UNUSED,\n-                     const xmlChar * context ATTRIBUTE_UNUSED)\n-{\n-    xmlSchemaElementPtr elem = (xmlSchemaElementPtr) payload;\n-    FILE *output = (FILE *) data;\n-    if (elem == NULL)\n-        return;\n-\n-\n-    fprintf(output, \"Element\");\n-    if (elem->flags & XML_SCHEMAS_ELEM_GLOBAL)\n-    fprintf(output, \" (global)\");\n-    fprintf(output, \": '%s' \", elem->name);\n-    if (namespace != NULL)\n-    fprintf(output, \"ns '%s'\", namespace);\n-    fprintf(output, \"\\n\");\n-#if 0\n-    if ((elem->minOccurs != 1) || (elem->maxOccurs != 1)) {\n-    fprintf(output, \"  min %d \", elem->minOccurs);\n-        if (elem->maxOccurs >= UNBOUNDED)\n-            fprintf(output, \"max: unbounded\\n\");\n-        else if (elem->maxOccurs != 1)\n-            fprintf(output, \"max: %d\\n\", elem->maxOccurs);\n-        else\n-            fprintf(output, \"\\n\");\n-    }\n-#endif\n-    \/*\n-    * Misc other properties.\n-    *\/\n-    if ((elem->flags & XML_SCHEMAS_ELEM_NILLABLE) ||\n-    (elem->flags & XML_SCHEMAS_ELEM_ABSTRACT) ||\n-    (elem->flags & XML_SCHEMAS_ELEM_FIXED) ||\n-    (elem->flags & XML_SCHEMAS_ELEM_DEFAULT)) {\n-    fprintf(output, \"  props: \");\n-    if (elem->flags & XML_SCHEMAS_ELEM_FIXED)\n-        fprintf(output, \"[fixed] \");\n-    if (elem->flags & XML_SCHEMAS_ELEM_DEFAULT)\n-        fprintf(output, \"[default] \");\n-    if (elem->flags & XML_SCHEMAS_ELEM_ABSTRACT)\n-        fprintf(output, \"[abstract] \");\n-    if (elem->flags & XML_SCHEMAS_ELEM_NILLABLE)\n-        fprintf(output, \"[nillable] \");\n-    fprintf(output, \"\\n\");\n-    }\n-    \/*\n-    * Default\/fixed value.\n-    *\/\n-    if (elem->value != NULL)\n-    fprintf(output, \"  value: '%s'\\n\", elem->value);\n-    \/*\n-    * Type.\n-    *\/\n-    if (elem->namedType != NULL) {\n-    fprintf(output, \"  type: '%s' \", elem->namedType);\n-    if (elem->namedTypeNs != NULL)\n-        fprintf(output, \"ns '%s'\\n\", elem->namedTypeNs);\n-    else\n-        fprintf(output, \"\\n\");\n-    } else if (elem->subtypes != NULL) {\n-    \/*\n-    * Dump local types.\n-    *\/\n-    xmlSchemaTypeDump(elem->subtypes, output);\n-    }\n-    \/*\n-    * Substitution group.\n-    *\/\n-    if (elem->substGroup != NULL) {\n-    fprintf(output, \"  substitutionGroup: '%s' \", elem->substGroup);\n-    if (elem->substGroupNs != NULL)\n-        fprintf(output, \"ns '%s'\\n\", elem->substGroupNs);\n-    else\n-        fprintf(output, \"\\n\");\n-    }\n-}\n-\n-\/**\n- * xmlSchemaAnnotDump:\n- * @output:  the file output\n- * @annot:  a annotation\n- *\n- * Dump the annotation\n- *\/\n-static void\n-xmlSchemaAnnotDump(FILE * output, xmlSchemaAnnotPtr annot)\n-{\n-    xmlChar *content;\n-\n-    if (annot == NULL)\n-        return;\n-\n-    content = xmlNodeGetContent(annot->content);\n-    if (content != NULL) {\n-        fprintf(output, \"  Annot: %s\\n\", content);\n-        xmlFree(content);\n-    } else\n-        fprintf(output, \"  Annot: empty\\n\");\n-}\n-\n-\/**\n- * xmlSchemaContentModelDump:\n- * @particle: the schema particle\n- * @output: the file output\n- * @depth: the depth used for indentation\n- *\n- * Dump a SchemaType structure\n- *\/\n-static void\n-xmlSchemaContentModelDump(xmlSchemaParticlePtr particle, FILE * output, int depth)\n-{\n-    xmlChar *str = NULL;\n-    xmlSchemaTreeItemPtr term;\n-    char shift[100];\n-    int i;\n-\n-    if (particle == NULL)\n-    return;\n-    for (i = 0;((i < depth) && (i < 25));i++)\n-        shift[2 * i] = shift[2 * i + 1] = ' ';\n-    shift[2 * i] = shift[2 * i + 1] = 0;\n-    fprintf(output, \"%s\", shift);\n-    if (particle->children == NULL) {\n-    fprintf(output, \"MISSING particle term\\n\");\n-    return;\n-    }\n-    term = particle->children;\n-    if (term == NULL) {\n-    fprintf(output, \"(NULL)\");\n-    } else {\n-    switch (term->type) {\n-        case XML_SCHEMA_TYPE_ELEMENT:\n-        fprintf(output, \"ELEM '%s'\", xmlSchemaFormatQName(&str,\n-            ((xmlSchemaElementPtr)term)->targetNamespace,\n-            ((xmlSchemaElementPtr)term)->name));\n-        FREE_AND_NULL(str);\n-        break;\n-        case XML_SCHEMA_TYPE_SEQUENCE:\n-        fprintf(output, \"SEQUENCE\");\n-        break;\n-        case XML_SCHEMA_TYPE_CHOICE:\n-        fprintf(output, \"CHOICE\");\n-        break;\n-        case XML_SCHEMA_TYPE_ALL:\n-        fprintf(output, \"ALL\");\n-        break;\n-        case XML_SCHEMA_TYPE_ANY:\n-        fprintf(output, \"ANY\");\n-        break;\n-        default:\n-        fprintf(output, \"UNKNOWN\\n\");\n-        return;\n-    }\n-    }\n-    if (particle->minOccurs != 1)\n-    fprintf(output, \" min: %d\", particle->minOccurs);\n-    if (particle->maxOccurs >= UNBOUNDED)\n-    fprintf(output, \" max: unbounded\");\n-    else if (particle->maxOccurs != 1)\n-    fprintf(output, \" max: %d\", particle->maxOccurs);\n-    fprintf(output, \"\\n\");\n-    if (term &&\n-    ((term->type == XML_SCHEMA_TYPE_SEQUENCE) ||\n-     (term->type == XML_SCHEMA_TYPE_CHOICE) ||\n-     (term->type == XML_SCHEMA_TYPE_ALL)) &&\n-     (term->children != NULL)) {\n-    xmlSchemaContentModelDump((xmlSchemaParticlePtr) term->children,\n-        output, depth +1);\n-    }\n-    if (particle->next != NULL)\n-    xmlSchemaContentModelDump((xmlSchemaParticlePtr) particle->next,\n-        output, depth);\n-}\n-\n-\/**\n- * xmlSchemaAttrUsesDump:\n- * @uses:  attribute uses list\n- * @output:  the file output\n- *\n- * Dumps a list of attribute use components.\n- *\/\n-static void\n-xmlSchemaAttrUsesDump(xmlSchemaItemListPtr uses, FILE * output)\n-{\n-    xmlSchemaAttributeUsePtr use;\n-    xmlSchemaAttributeUseProhibPtr prohib;\n-    xmlSchemaQNameRefPtr ref;\n-    const xmlChar *name, *tns;\n-    xmlChar *str = NULL;\n-    int i;\n-\n-    if ((uses == NULL) || (uses->nbItems == 0))\n-        return;\n-\n-    fprintf(output, \"  attributes:\\n\");\n-    for (i = 0; i < uses->nbItems; i++) {\n-    use = uses->items[i];\n-    if (use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) {\n-        fprintf(output, \"  [prohibition] \");\n-        prohib = (xmlSchemaAttributeUseProhibPtr) use;\n-        name = prohib->name;\n-        tns = prohib->targetNamespace;\n-    } else if (use->type == XML_SCHEMA_EXTRA_QNAMEREF) {\n-        fprintf(output, \"  [reference] \");\n-        ref = (xmlSchemaQNameRefPtr) use;\n-        name = ref->name;\n-        tns = ref->targetNamespace;\n-    } else {\n-        fprintf(output, \"  [use] \");\n-        name = WXS_ATTRUSE_DECL_NAME(use);\n-        tns = WXS_ATTRUSE_DECL_TNS(use);\n-    }\n-    fprintf(output, \"'%s'\\n\",\n-        (const char *) xmlSchemaFormatQName(&str, tns, name));\n-    FREE_AND_NULL(str);\n-    }\n-}\n-\n-\/**\n- * xmlSchemaTypeDump:\n- * @output:  the file output\n- * @type:  a type structure\n- *\n- * Dump a SchemaType structure\n- *\/\n-static void\n-xmlSchemaTypeDump(xmlSchemaTypePtr type, FILE * output)\n-{\n-    if (type == NULL) {\n-        fprintf(output, \"Type: NULL\\n\");\n-        return;\n-    }\n-    fprintf(output, \"Type: \");\n-    if (type->name != NULL)\n-        fprintf(output, \"'%s' \", type->name);\n-    else\n-        fprintf(output, \"(no name) \");\n-    if (type->targetNamespace != NULL)\n-    fprintf(output, \"ns '%s' \", type->targetNamespace);\n-    switch (type->type) {\n-        case XML_SCHEMA_TYPE_BASIC:\n-            fprintf(output, \"[basic] \");\n-            break;\n-        case XML_SCHEMA_TYPE_SIMPLE:\n-            fprintf(output, \"[simple] \");\n-            break;\n-        case XML_SCHEMA_TYPE_COMPLEX:\n-            fprintf(output, \"[complex] \");\n-            break;\n-        case XML_SCHEMA_TYPE_SEQUENCE:\n-            fprintf(output, \"[sequence] \");\n-            break;\n-        case XML_SCHEMA_TYPE_CHOICE:\n-            fprintf(output, \"[choice] \");\n-            break;\n-        case XML_SCHEMA_TYPE_ALL:\n-            fprintf(output, \"[all] \");\n-            break;\n-        case XML_SCHEMA_TYPE_UR:\n-            fprintf(output, \"[ur] \");\n-            break;\n-        case XML_SCHEMA_TYPE_RESTRICTION:\n-            fprintf(output, \"[restriction] \");\n-            break;\n-        case XML_SCHEMA_TYPE_EXTENSION:\n-            fprintf(output, \"[extension] \");\n-            break;\n-        default:\n-            fprintf(output, \"[unknown type %d] \", type->type);\n-            break;\n-    }\n-    fprintf(output, \"content: \");\n-    switch (type->contentType) {\n-        case XML_SCHEMA_CONTENT_UNKNOWN:\n-            fprintf(output, \"[unknown] \");\n-            break;\n-        case XML_SCHEMA_CONTENT_EMPTY:\n-            fprintf(output, \"[empty] \");\n-            break;\n-        case XML_SCHEMA_CONTENT_ELEMENTS:\n-            fprintf(output, \"[element] \");\n-            break;\n-        case XML_SCHEMA_CONTENT_MIXED:\n-            fprintf(output, \"[mixed] \");\n-            break;\n-        case XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS:\n-    \/* not used. *\/\n-            break;\n-        case XML_SCHEMA_CONTENT_BASIC:\n-            fprintf(output, \"[basic] \");\n-            break;\n-        case XML_SCHEMA_CONTENT_SIMPLE:\n-            fprintf(output, \"[simple] \");\n-            break;\n-        case XML_SCHEMA_CONTENT_ANY:\n-            fprintf(output, \"[any] \");\n-            break;\n-    }\n-    fprintf(output, \"\\n\");\n-    if (type->base != NULL) {\n-        fprintf(output, \"  base type: '%s'\", type->base);\n-    if (type->baseNs != NULL)\n-        fprintf(output, \" ns '%s'\\n\", type->baseNs);\n-    else\n-        fprintf(output, \"\\n\");\n-    }\n-    if (type->attrUses != NULL)\n-    xmlSchemaAttrUsesDump(type->attrUses, output);\n-    if (type->annot != NULL)\n-        xmlSchemaAnnotDump(output, type->annot);\n-#ifdef DUMP_CONTENT_MODEL\n-    if ((type->type == XML_SCHEMA_TYPE_COMPLEX) &&\n-    (type->subtypes != NULL)) {\n-    xmlSchemaContentModelDump((xmlSchemaParticlePtr) type->subtypes,\n-        output, 1);\n-    }\n-#endif\n-}\n-\n-static void\n-xmlSchemaTypeDumpEntry(void *type, void *output,\n-                       const xmlChar *name ATTRIBUTE_UNUSED)\n-{\n-    xmlSchemaTypeDump((xmlSchemaTypePtr) type, (FILE *) output);\n-}\n-\n-\/**\n- * xmlSchemaDump:\n- * @output:  the file output\n- * @schema:  a schema structure\n- *\n- * Dump a Schema structure.\n- *\/\n-void\n-xmlSchemaDump(FILE * output, xmlSchemaPtr schema)\n-{\n-    if (output == NULL)\n-        return;\n-    if (schema == NULL) {\n-        fprintf(output, \"Schemas: NULL\\n\");\n-        return;\n-    }\n-    fprintf(output, \"Schemas: \");\n-    if (schema->name != NULL)\n-        fprintf(output, \"%s, \", schema->name);\n-    else\n-        fprintf(output, \"no name, \");\n-    if (schema->targetNamespace != NULL)\n-        fprintf(output, \"%s\", (const char *) schema->targetNamespace);\n-    else\n-        fprintf(output, \"no target namespace\");\n-    fprintf(output, \"\\n\");\n-    if (schema->annot != NULL)\n-        xmlSchemaAnnotDump(output, schema->annot);\n-    xmlHashScan(schema->typeDecl, xmlSchemaTypeDumpEntry, output);\n-    xmlHashScanFull(schema->elemDecl, xmlSchemaElementDump, output);\n-}\n-\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-\n-\/************************************************************************\n- *                                    *\n- *            Utilities                    *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlSchemaGetPropNode:\n- * @node: the element node\n- * @name: the name of the attribute\n- *\n- * Seeks an attribute with a name of @name in\n- * no namespace.\n- *\n- * Returns the attribute or NULL if not present.\n- *\/\n-static xmlAttrPtr\n-xmlSchemaGetPropNode(xmlNodePtr node, const char *name)\n-{\n-    xmlAttrPtr prop;\n-\n-    if ((node == NULL) || (name == NULL))\n-    return(NULL);\n-    prop = node->properties;\n-    while (prop != NULL) {\n-        if ((prop->ns == NULL) && xmlStrEqual(prop->name, BAD_CAST name))\n-        return(prop);\n-    prop = prop->next;\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlSchemaGetPropNodeNs:\n- * @node: the element node\n- * @uri: the uri\n- * @name: the name of the attribute\n- *\n- * Seeks an attribute with a local name of @name and\n- * a namespace URI of @uri.\n- *\n- * Returns the attribute or NULL if not present.\n- *\/\n-static xmlAttrPtr\n-xmlSchemaGetPropNodeNs(xmlNodePtr node, const char *uri, const char *name)\n-{\n-    xmlAttrPtr prop;\n-\n-    if ((node == NULL) || (name == NULL))\n-    return(NULL);\n-    prop = node->properties;\n-    while (prop != NULL) {\n-    if ((prop->ns != NULL) &&\n-        xmlStrEqual(prop->name, BAD_CAST name) &&\n-        xmlStrEqual(prop->ns->href, BAD_CAST uri))\n-        return(prop);\n-    prop = prop->next;\n-    }\n-    return (NULL);\n-}\n-\n-static const xmlChar *\n-xmlSchemaGetNodeContent(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node)\n-{\n-    xmlChar *val;\n-    const xmlChar *ret;\n-\n-    val = xmlNodeGetContent(node);\n-    if (val == NULL)\n-    val = xmlStrdup((xmlChar *)\"\");\n-    ret = xmlDictLookup(ctxt->dict, val, -1);\n-    xmlFree(val);\n-    if (ret == NULL)\n-        xmlSchemaPErrMemory(ctxt);\n-    return(ret);\n-}\n-\n-static const xmlChar *\n-xmlSchemaGetNodeContentNoDict(xmlNodePtr node)\n-{\n-    return((const xmlChar*) xmlNodeGetContent(node));\n-}\n-\n-\/**\n- * xmlSchemaGetProp:\n- * @ctxt: the parser context\n- * @node: the node\n- * @name: the property name\n- *\n- * Read a attribute value and internalize the string\n- *\n- * Returns the string or NULL if not present.\n- *\/\n-static const xmlChar *\n-xmlSchemaGetProp(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node,\n-                 const char *name)\n-{\n-    xmlChar *val;\n-    const xmlChar *ret;\n-\n-    val = xmlGetNoNsProp(node, BAD_CAST name);\n-    if (val == NULL)\n-        return(NULL);\n-    ret = xmlDictLookup(ctxt->dict, val, -1);\n-    xmlFree(val);\n-    return(ret);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Parsing functions                *\n- *                                    *\n- ************************************************************************\/\n-\n-#define WXS_FIND_GLOBAL_ITEM(slot)            \\\n-    if (xmlStrEqual(nsName, schema->targetNamespace)) { \\\n-    ret = xmlHashLookup(schema->slot, name); \\\n-    if (ret != NULL) goto exit; \\\n-    } \\\n-    if (xmlHashSize(schema->schemasImports) > 1) { \\\n-    xmlSchemaImportPtr import; \\\n-    if (nsName == NULL) \\\n-        import = xmlHashLookup(schema->schemasImports, \\\n-        XML_SCHEMAS_NO_NAMESPACE); \\\n-    else \\\n-        import = xmlHashLookup(schema->schemasImports, nsName); \\\n-    if (import == NULL) \\\n-        goto exit; \\\n-    ret = xmlHashLookup(import->schema->slot, name); \\\n-    }\n-\n-\/**\n- * xmlSchemaGetElem:\n- * @schema:  the schema context\n- * @name:  the element name\n- * @ns:  the element namespace\n- *\n- * Lookup a global element declaration in the schema.\n- *\n- * Returns the element declaration or NULL if not found.\n- *\/\n-static xmlSchemaElementPtr\n-xmlSchemaGetElem(xmlSchemaPtr schema, const xmlChar * name,\n-                 const xmlChar * nsName)\n-{\n-    xmlSchemaElementPtr ret = NULL;\n-\n-    if ((name == NULL) || (schema == NULL))\n-        return(NULL);\n-    if (schema != NULL) {\n-    WXS_FIND_GLOBAL_ITEM(elemDecl)\n-    }\n-exit:\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaGetType:\n- * @schema:  the main schema\n- * @name:  the type's name\n- * nsName:  the type's namespace\n- *\n- * Lookup a type in the schemas or the predefined types\n- *\n- * Returns the group definition or NULL if not found.\n- *\/\n-static xmlSchemaTypePtr\n-xmlSchemaGetType(xmlSchemaPtr schema, const xmlChar * name,\n-                 const xmlChar * nsName)\n-{\n-    xmlSchemaTypePtr ret = NULL;\n-\n-    if (name == NULL)\n-        return (NULL);\n-    \/* First try the built-in types. *\/\n-    if ((nsName != NULL) && xmlStrEqual(nsName, xmlSchemaNs)) {\n-    ret = xmlSchemaGetPredefinedType(name, nsName);\n-    if (ret != NULL)\n-        goto exit;\n-    \/*\n-    * Note that we try the parsed schemas as well here\n-    * since one might have parsed the S4S, which contain more\n-    * than the built-in types.\n-    * TODO: Can we optimize this?\n-    *\/\n-    }\n-    if (schema != NULL) {\n-    WXS_FIND_GLOBAL_ITEM(typeDecl)\n-    }\n-exit:\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaGetAttributeDecl:\n- * @schema:  the context of the schema\n- * @name:  the name of the attribute\n- * @ns:  the target namespace of the attribute\n- *\n- * Lookup a an attribute in the schema or imported schemas\n- *\n- * Returns the attribute declaration or NULL if not found.\n- *\/\n-static xmlSchemaAttributePtr\n-xmlSchemaGetAttributeDecl(xmlSchemaPtr schema, const xmlChar * name,\n-                 const xmlChar * nsName)\n-{\n-    xmlSchemaAttributePtr ret = NULL;\n-\n-    if ((name == NULL) || (schema == NULL))\n-        return (NULL);\n-    if (schema != NULL) {\n-    WXS_FIND_GLOBAL_ITEM(attrDecl)\n-    }\n-exit:\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaGetAttributeGroup:\n- * @schema:  the context of the schema\n- * @name:  the name of the attribute group\n- * @ns:  the target namespace of the attribute group\n- *\n- * Lookup a an attribute group in the schema or imported schemas\n- *\n- * Returns the attribute group definition or NULL if not found.\n- *\/\n-static xmlSchemaAttributeGroupPtr\n-xmlSchemaGetAttributeGroup(xmlSchemaPtr schema, const xmlChar * name,\n-                 const xmlChar * nsName)\n-{\n-    xmlSchemaAttributeGroupPtr ret = NULL;\n-\n-    if ((name == NULL) || (schema == NULL))\n-        return (NULL);\n-    if (schema != NULL) {\n-    WXS_FIND_GLOBAL_ITEM(attrgrpDecl)\n-    }\n-exit:\n-    \/* TODO:\n-    if ((ret != NULL) && (ret->redef != NULL)) {\n-    * Return the last redefinition. *\n-    ret = ret->redef;\n-    }\n-    *\/\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaGetGroup:\n- * @schema:  the context of the schema\n- * @name:  the name of the group\n- * @ns:  the target namespace of the group\n- *\n- * Lookup a group in the schema or imported schemas\n- *\n- * Returns the group definition or NULL if not found.\n- *\/\n-static xmlSchemaModelGroupDefPtr\n-xmlSchemaGetGroup(xmlSchemaPtr schema, const xmlChar * name,\n-                 const xmlChar * nsName)\n-{\n-    xmlSchemaModelGroupDefPtr ret = NULL;\n-\n-    if ((name == NULL) || (schema == NULL))\n-        return (NULL);\n-    if (schema != NULL) {\n-    WXS_FIND_GLOBAL_ITEM(groupDecl)\n-    }\n-exit:\n-\n-    return (ret);\n-}\n-\n-static xmlSchemaNotationPtr\n-xmlSchemaGetNotation(xmlSchemaPtr schema,\n-             const xmlChar *name,\n-             const xmlChar *nsName)\n-{\n-    xmlSchemaNotationPtr ret = NULL;\n-\n-    if ((name == NULL) || (schema == NULL))\n-        return (NULL);\n-    if (schema != NULL) {\n-    WXS_FIND_GLOBAL_ITEM(notaDecl)\n-    }\n-exit:\n-    return (ret);\n-}\n-\n-static xmlSchemaIDCPtr\n-xmlSchemaGetIDC(xmlSchemaPtr schema,\n-        const xmlChar *name,\n-        const xmlChar *nsName)\n-{\n-    xmlSchemaIDCPtr ret = NULL;\n-\n-    if ((name == NULL) || (schema == NULL))\n-        return (NULL);\n-    if (schema != NULL) {\n-    WXS_FIND_GLOBAL_ITEM(idcDef)\n-    }\n-exit:\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaGetNamedComponent:\n- * @schema:  the schema\n- * @name:  the name of the group\n- * @ns:  the target namespace of the group\n- *\n- * Lookup a group in the schema or imported schemas\n- *\n- * Returns the group definition or NULL if not found.\n- *\/\n-static xmlSchemaBasicItemPtr\n-xmlSchemaGetNamedComponent(xmlSchemaPtr schema,\n-               xmlSchemaTypeType itemType,\n-               const xmlChar *name,\n-               const xmlChar *targetNs)\n-{\n-    switch (itemType) {\n-    case XML_SCHEMA_TYPE_GROUP:\n-        return ((xmlSchemaBasicItemPtr) xmlSchemaGetGroup(schema,\n-        name, targetNs));\n-    case XML_SCHEMA_TYPE_ELEMENT:\n-        return ((xmlSchemaBasicItemPtr) xmlSchemaGetElem(schema,\n-        name, targetNs));\n-    default:\n-        \/* TODO *\/\n-        return (NULL);\n-    }\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Parsing functions                *\n- *                                    *\n- ************************************************************************\/\n-\n-#define IS_BLANK_NODE(n)                        \\\n-    (((n)->type == XML_TEXT_NODE) && (xmlSchemaIsBlank((n)->content, -1)))\n-\n-\/**\n- * xmlSchemaIsBlank:\n- * @str:  a string\n- * @len: the length of the string or -1\n- *\n- * Check if a string is ignorable\n- *\n- * Returns 1 if the string is NULL or made of blanks chars, 0 otherwise\n- *\/\n-static int\n-xmlSchemaIsBlank(xmlChar * str, int len)\n-{\n-    if (str == NULL)\n-        return (1);\n-    if (len < 0) {\n-    while (*str != 0) {\n-        if (!(IS_BLANK_CH(*str)))\n-        return (0);\n-        str++;\n-    }\n-    } else while ((*str != 0) && (len != 0)) {\n-    if (!(IS_BLANK_CH(*str)))\n-        return (0);\n-    str++;\n-    len--;\n-    }\n-\n-    return (1);\n-}\n-\n-#define WXS_COMP_NAME(c, t) ((t) (c))->name\n-#define WXS_COMP_TNS(c, t) ((t) (c))->targetNamespace\n-\/*\n-* xmlSchemaFindRedefCompInGraph:\n-* ATTENTION TODO: This uses pointer comp. for strings.\n-*\/\n-static xmlSchemaBasicItemPtr\n-xmlSchemaFindRedefCompInGraph(xmlSchemaBucketPtr bucket,\n-                  xmlSchemaTypeType type,\n-                  const xmlChar *name,\n-                  const xmlChar *nsName)\n-{\n-    xmlSchemaBasicItemPtr ret;\n-    int i;\n-\n-    if ((bucket == NULL) || (name == NULL))\n-    return(NULL);\n-    if ((bucket->globals == NULL) ||\n-    (bucket->globals->nbItems == 0))\n-    goto subschemas;\n-    \/*\n-    * Search in global components.\n-    *\/\n-    for (i = 0; i < bucket->globals->nbItems; i++) {\n-    ret = bucket->globals->items[i];\n-    if (ret->type == type) {\n-        switch (type) {\n-        case XML_SCHEMA_TYPE_COMPLEX:\n-        case XML_SCHEMA_TYPE_SIMPLE:\n-            if ((WXS_COMP_NAME(ret, xmlSchemaTypePtr) == name) &&\n-            (WXS_COMP_TNS(ret, xmlSchemaTypePtr) ==\n-            nsName))\n-            {\n-            return(ret);\n-            }\n-            break;\n-        case XML_SCHEMA_TYPE_GROUP:\n-            if ((WXS_COMP_NAME(ret,\n-                xmlSchemaModelGroupDefPtr) == name) &&\n-            (WXS_COMP_TNS(ret,\n-                xmlSchemaModelGroupDefPtr) == nsName))\n-            {\n-            return(ret);\n-            }\n-            break;\n-        case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:\n-            if ((WXS_COMP_NAME(ret,\n-                xmlSchemaAttributeGroupPtr) == name) &&\n-            (WXS_COMP_TNS(ret,\n-                xmlSchemaAttributeGroupPtr) == nsName))\n-            {\n-            return(ret);\n-            }\n-            break;\n-        default:\n-            \/* Should not be hit. *\/\n-            return(NULL);\n-        }\n-    }\n-    }\n-subschemas:\n-    \/*\n-    * Process imported\/included schemas.\n-    *\/\n-    if (bucket->relations != NULL) {\n-    xmlSchemaSchemaRelationPtr rel = bucket->relations;\n-\n-    \/*\n-    * TODO: Marking the bucket will not avoid multiple searches\n-    * in the same schema, but avoids at least circularity.\n-    *\/\n-    bucket->flags |= XML_SCHEMA_BUCKET_MARKED;\n-    do {\n-        if ((rel->bucket != NULL) &&\n-        ((rel->bucket->flags & XML_SCHEMA_BUCKET_MARKED) == 0)) {\n-        ret = xmlSchemaFindRedefCompInGraph(rel->bucket,\n-            type, name, nsName);\n-        if (ret != NULL)\n-            return(ret);\n-        }\n-        rel = rel->next;\n-    } while (rel != NULL);\n-     bucket->flags ^= XML_SCHEMA_BUCKET_MARKED;\n-    }\n-    return(NULL);\n-}\n-\n-\/**\n- * xmlSchemaAddNotation:\n- * @ctxt:  a schema parser context\n- * @schema:  the schema being built\n- * @name:  the item name\n- *\n- * Add an XML schema annotation declaration\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the new structure or NULL in case of error\n- *\/\n-static xmlSchemaNotationPtr\n-xmlSchemaAddNotation(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                     const xmlChar *name, const xmlChar *nsName,\n-             xmlNodePtr node ATTRIBUTE_UNUSED)\n-{\n-    xmlSchemaNotationPtr ret = NULL;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (name == NULL))\n-        return (NULL);\n-\n-    ret = (xmlSchemaNotationPtr) xmlMalloc(sizeof(xmlSchemaNotation));\n-    if (ret == NULL) {\n-        xmlSchemaPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaNotation));\n-    ret->type = XML_SCHEMA_TYPE_NOTATION;\n-    ret->name = name;\n-    ret->targetNamespace = nsName;\n-    \/* TODO: do we need the node to be set?\n-    * ret->node = node;*\/\n-    WXS_ADD_GLOBAL(ctxt, ret);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaAddAttribute:\n- * @ctxt:  a schema parser context\n- * @schema:  the schema being built\n- * @name:  the item name\n- * @namespace:  the namespace\n- *\n- * Add an XML schema Attribute declaration\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the new structure or NULL in case of error\n- *\/\n-static xmlSchemaAttributePtr\n-xmlSchemaAddAttribute(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                      const xmlChar * name, const xmlChar * nsName,\n-              xmlNodePtr node, int topLevel)\n-{\n-    xmlSchemaAttributePtr ret = NULL;\n-\n-    if ((ctxt == NULL) || (schema == NULL))\n-        return (NULL);\n-\n-    ret = (xmlSchemaAttributePtr) xmlMalloc(sizeof(xmlSchemaAttribute));\n-    if (ret == NULL) {\n-        xmlSchemaPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaAttribute));\n-    ret->type = XML_SCHEMA_TYPE_ATTRIBUTE;\n-    ret->node = node;\n-    ret->name = name;\n-    ret->targetNamespace = nsName;\n-\n-    if (topLevel)\n-    WXS_ADD_GLOBAL(ctxt, ret);\n-    else\n-    WXS_ADD_LOCAL(ctxt, ret);\n-    WXS_ADD_PENDING(ctxt, ret);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaAddAttributeUse:\n- * @ctxt:  a schema parser context\n- * @schema:  the schema being built\n- * @name:  the item name\n- * @namespace:  the namespace\n- *\n- * Add an XML schema Attribute declaration\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the new structure or NULL in case of error\n- *\/\n-static xmlSchemaAttributeUsePtr\n-xmlSchemaAddAttributeUse(xmlSchemaParserCtxtPtr pctxt,\n-             xmlNodePtr node)\n-{\n-    xmlSchemaAttributeUsePtr ret = NULL;\n-\n-    if (pctxt == NULL)\n-        return (NULL);\n-\n-    ret = (xmlSchemaAttributeUsePtr) xmlMalloc(sizeof(xmlSchemaAttributeUse));\n-    if (ret == NULL) {\n-        xmlSchemaPErrMemory(pctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaAttributeUse));\n-    ret->type = XML_SCHEMA_TYPE_ATTRIBUTE_USE;\n-    ret->node = node;\n-\n-    WXS_ADD_LOCAL(pctxt, ret);\n-    return (ret);\n-}\n-\n-\/*\n-* xmlSchemaAddRedef:\n-*\n-* Adds a redefinition information. This is used at a later stage to:\n-* resolve references to the redefined components and to check constraints.\n-*\/\n-static xmlSchemaRedefPtr\n-xmlSchemaAddRedef(xmlSchemaParserCtxtPtr pctxt,\n-          xmlSchemaBucketPtr targetBucket,\n-          void *item,\n-          const xmlChar *refName,\n-          const xmlChar *refTargetNs)\n-{\n-    xmlSchemaRedefPtr ret;\n-\n-    ret = (xmlSchemaRedefPtr)\n-    xmlMalloc(sizeof(xmlSchemaRedef));\n-    if (ret == NULL) {\n-    xmlSchemaPErrMemory(pctxt);\n-    return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaRedef));\n-    ret->item = item;\n-    ret->targetBucket = targetBucket;\n-    ret->refName = refName;\n-    ret->refTargetNs = refTargetNs;\n-    if (WXS_CONSTRUCTOR(pctxt)->redefs == NULL)\n-    WXS_CONSTRUCTOR(pctxt)->redefs = ret;\n-    else\n-    WXS_CONSTRUCTOR(pctxt)->lastRedef->next = ret;\n-    WXS_CONSTRUCTOR(pctxt)->lastRedef = ret;\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaAddAttributeGroupDefinition:\n- * @ctxt:  a schema parser context\n- * @schema:  the schema being built\n- * @name:  the item name\n- * @nsName:  the target namespace\n- * @node: the corresponding node\n- *\n- * Add an XML schema Attribute Group definition.\n- *\n- * Returns the new structure or NULL in case of error\n- *\/\n-static xmlSchemaAttributeGroupPtr\n-xmlSchemaAddAttributeGroupDefinition(xmlSchemaParserCtxtPtr pctxt,\n-                           xmlSchemaPtr schema ATTRIBUTE_UNUSED,\n-               const xmlChar *name,\n-               const xmlChar *nsName,\n-               xmlNodePtr node)\n-{\n-    xmlSchemaAttributeGroupPtr ret = NULL;\n-\n-    if ((pctxt == NULL) || (name == NULL))\n-        return (NULL);\n-\n-    ret = (xmlSchemaAttributeGroupPtr)\n-        xmlMalloc(sizeof(xmlSchemaAttributeGroup));\n-    if (ret == NULL) {\n-    xmlSchemaPErrMemory(pctxt);\n-    return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaAttributeGroup));\n-    ret->type = XML_SCHEMA_TYPE_ATTRIBUTEGROUP;\n-    ret->name = name;\n-    ret->targetNamespace = nsName;\n-    ret->node = node;\n-\n-    \/* TODO: Remove the flag. *\/\n-    ret->flags |= XML_SCHEMAS_ATTRGROUP_GLOBAL;\n-    if (pctxt->isRedefine) {\n-    pctxt->redef = xmlSchemaAddRedef(pctxt, pctxt->redefined,\n-        ret, name, nsName);\n-    if (pctxt->redef == NULL) {\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n-    pctxt->redefCounter = 0;\n-    }\n-    WXS_ADD_GLOBAL(pctxt, ret);\n-    WXS_ADD_PENDING(pctxt, ret);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaAddElement:\n- * @ctxt:  a schema parser context\n- * @schema:  the schema being built\n- * @name:  the type name\n- * @namespace:  the type namespace\n- *\n- * Add an XML schema Element declaration\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the new structure or NULL in case of error\n- *\/\n-static xmlSchemaElementPtr\n-xmlSchemaAddElement(xmlSchemaParserCtxtPtr ctxt,\n-                    const xmlChar * name, const xmlChar * nsName,\n-            xmlNodePtr node, int topLevel)\n-{\n-    xmlSchemaElementPtr ret = NULL;\n-\n-    if ((ctxt == NULL) || (name == NULL))\n-        return (NULL);\n-\n-    ret = (xmlSchemaElementPtr) xmlMalloc(sizeof(xmlSchemaElement));\n-    if (ret == NULL) {\n-        xmlSchemaPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaElement));\n-    ret->type = XML_SCHEMA_TYPE_ELEMENT;\n-    ret->name = name;\n-    ret->targetNamespace = nsName;\n-    ret->node = node;\n-\n-    if (topLevel)\n-    WXS_ADD_GLOBAL(ctxt, ret);\n-    else\n-    WXS_ADD_LOCAL(ctxt, ret);\n-    WXS_ADD_PENDING(ctxt, ret);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaAddType:\n- * @ctxt:  a schema parser context\n- * @schema:  the schema being built\n- * @name:  the item name\n- * @namespace:  the namespace\n- *\n- * Add an XML schema item\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the new structure or NULL in case of error\n- *\/\n-static xmlSchemaTypePtr\n-xmlSchemaAddType(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-         xmlSchemaTypeType type,\n-                 const xmlChar * name, const xmlChar * nsName,\n-         xmlNodePtr node, int topLevel)\n-{\n-    xmlSchemaTypePtr ret = NULL;\n-\n-    if ((ctxt == NULL) || (schema == NULL))\n-        return (NULL);\n-\n-    ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));\n-    if (ret == NULL) {\n-        xmlSchemaPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaType));\n-    ret->type = type;\n-    ret->name = name;\n-    ret->targetNamespace = nsName;\n-    ret->node = node;\n-    if (topLevel) {\n-    if (ctxt->isRedefine) {\n-        ctxt->redef = xmlSchemaAddRedef(ctxt, ctxt->redefined,\n-        ret, name, nsName);\n-        if (ctxt->redef == NULL) {\n-        xmlFree(ret);\n-        return(NULL);\n-        }\n-        ctxt->redefCounter = 0;\n-    }\n-    WXS_ADD_GLOBAL(ctxt, ret);\n-    } else\n-    WXS_ADD_LOCAL(ctxt, ret);\n-    WXS_ADD_PENDING(ctxt, ret);\n-    return (ret);\n-}\n-\n-static xmlSchemaQNameRefPtr\n-xmlSchemaNewQNameRef(xmlSchemaParserCtxtPtr pctxt,\n-             xmlSchemaTypeType refType,\n-             const xmlChar *refName,\n-             const xmlChar *refNs)\n-{\n-    xmlSchemaQNameRefPtr ret;\n-\n-    ret = (xmlSchemaQNameRefPtr)\n-    xmlMalloc(sizeof(xmlSchemaQNameRef));\n-    if (ret == NULL) {\n-    xmlSchemaPErrMemory(pctxt);\n-    return (NULL);\n-    }\n-    ret->node = NULL;\n-    ret->type = XML_SCHEMA_EXTRA_QNAMEREF;\n-    ret->name = refName;\n-    ret->targetNamespace = refNs;\n-    ret->item = NULL;\n-    ret->itemType = refType;\n-    \/*\n-    * Store the reference item in the schema.\n-    *\/\n-    WXS_ADD_LOCAL(pctxt, ret);\n-    return (ret);\n-}\n-\n-static xmlSchemaAttributeUseProhibPtr\n-xmlSchemaAddAttributeUseProhib(xmlSchemaParserCtxtPtr pctxt)\n-{\n-    xmlSchemaAttributeUseProhibPtr ret;\n-\n-    ret = (xmlSchemaAttributeUseProhibPtr)\n-    xmlMalloc(sizeof(xmlSchemaAttributeUseProhib));\n-    if (ret == NULL) {\n-    xmlSchemaPErrMemory(pctxt);\n-    return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaAttributeUseProhib));\n-    ret->type = XML_SCHEMA_EXTRA_ATTR_USE_PROHIB;\n-    WXS_ADD_LOCAL(pctxt, ret);\n-    return (ret);\n-}\n-\n-\n-\/**\n- * xmlSchemaAddModelGroup:\n- * @ctxt:  a schema parser context\n- * @schema:  the schema being built\n- * @type: the \"compositor\" type of the model group\n- * @node: the node in the schema doc\n- *\n- * Adds a schema model group\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the new structure or NULL in case of error\n- *\/\n-static xmlSchemaModelGroupPtr\n-xmlSchemaAddModelGroup(xmlSchemaParserCtxtPtr ctxt,\n-               xmlSchemaPtr schema,\n-               xmlSchemaTypeType type,\n-               xmlNodePtr node)\n-{\n-    xmlSchemaModelGroupPtr ret = NULL;\n-\n-    if ((ctxt == NULL) || (schema == NULL))\n-        return (NULL);\n-\n-    ret = (xmlSchemaModelGroupPtr)\n-    xmlMalloc(sizeof(xmlSchemaModelGroup));\n-    if (ret == NULL) {\n-    xmlSchemaPErrMemory(ctxt);\n-    return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaModelGroup));\n-    ret->type = type;\n-    ret->node = node;\n-    WXS_ADD_LOCAL(ctxt, ret);\n-    if ((type == XML_SCHEMA_TYPE_SEQUENCE) ||\n-    (type == XML_SCHEMA_TYPE_CHOICE))\n-    WXS_ADD_PENDING(ctxt, ret);\n-    return (ret);\n-}\n-\n-\n-\/**\n- * xmlSchemaAddParticle:\n- * @ctxt:  a schema parser context\n- * @schema:  the schema being built\n- * @node: the corresponding node in the schema doc\n- * @min: the minOccurs\n- * @max: the maxOccurs\n- *\n- * Adds an XML schema particle component.\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the new structure or NULL in case of error\n- *\/\n-static xmlSchemaParticlePtr\n-xmlSchemaAddParticle(xmlSchemaParserCtxtPtr ctxt,\n-             xmlNodePtr node, int min, int max)\n-{\n-    xmlSchemaParticlePtr ret = NULL;\n-    if (ctxt == NULL)\n-        return (NULL);\n-\n-    ret = (xmlSchemaParticlePtr)\n-    xmlMalloc(sizeof(xmlSchemaParticle));\n-    if (ret == NULL) {\n-    xmlSchemaPErrMemory(ctxt);\n-    return (NULL);\n-    }\n-    ret->type = XML_SCHEMA_TYPE_PARTICLE;\n-    ret->annot = NULL;\n-    ret->node = node;\n-    ret->minOccurs = min;\n-    ret->maxOccurs = max;\n-    ret->next = NULL;\n-    ret->children = NULL;\n-\n-    WXS_ADD_LOCAL(ctxt, ret);\n-    \/*\n-    * Note that addition to pending components will be done locally\n-    * to the specific parsing function, since the most particles\n-    * need not to be fixed up (i.e. the reference to be resolved).\n-    * REMOVED: WXS_ADD_PENDING(ctxt, ret);\n-    *\/\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaAddModelGroupDefinition:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @name:  the group name\n- *\n- * Add an XML schema Group definition\n- *\n- * Returns the new structure or NULL in case of error\n- *\/\n-static xmlSchemaModelGroupDefPtr\n-xmlSchemaAddModelGroupDefinition(xmlSchemaParserCtxtPtr ctxt,\n-                 xmlSchemaPtr schema,\n-                 const xmlChar *name,\n-                 const xmlChar *nsName,\n-                 xmlNodePtr node)\n-{\n-    xmlSchemaModelGroupDefPtr ret = NULL;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (name == NULL))\n-        return (NULL);\n-\n-    ret = (xmlSchemaModelGroupDefPtr)\n-    xmlMalloc(sizeof(xmlSchemaModelGroupDef));\n-    if (ret == NULL) {\n-        xmlSchemaPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaModelGroupDef));\n-    ret->name = name;\n-    ret->type = XML_SCHEMA_TYPE_GROUP;\n-    ret->node = node;\n-    ret->targetNamespace = nsName;\n-\n-    if (ctxt->isRedefine) {\n-    ctxt->redef = xmlSchemaAddRedef(ctxt, ctxt->redefined,\n-        ret, name, nsName);\n-    if (ctxt->redef == NULL) {\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n-    ctxt->redefCounter = 0;\n-    }\n-    WXS_ADD_GLOBAL(ctxt, ret);\n-    WXS_ADD_PENDING(ctxt, ret);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaNewWildcardNs:\n- * @ctxt:  a schema validation context\n- *\n- * Creates a new wildcard namespace constraint.\n- *\n- * Returns the new structure or NULL in case of error\n- *\/\n-static xmlSchemaWildcardNsPtr\n-xmlSchemaNewWildcardNsConstraint(xmlSchemaParserCtxtPtr ctxt)\n-{\n-    xmlSchemaWildcardNsPtr ret;\n-\n-    ret = (xmlSchemaWildcardNsPtr)\n-    xmlMalloc(sizeof(xmlSchemaWildcardNs));\n-    if (ret == NULL) {\n-    xmlSchemaPErrMemory(ctxt);\n-    return (NULL);\n-    }\n-    ret->value = NULL;\n-    ret->next = NULL;\n-    return (ret);\n-}\n-\n-static xmlSchemaIDCPtr\n-xmlSchemaAddIDC(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                  const xmlChar *name, const xmlChar *nsName,\n-          int category, xmlNodePtr node)\n-{\n-    xmlSchemaIDCPtr ret = NULL;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (name == NULL))\n-        return (NULL);\n-\n-    ret = (xmlSchemaIDCPtr) xmlMalloc(sizeof(xmlSchemaIDC));\n-    if (ret == NULL) {\n-        xmlSchemaPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaIDC));\n-    \/* The target namespace of the parent element declaration. *\/\n-    ret->targetNamespace = nsName;\n-    ret->name = name;\n-    ret->type = category;\n-    ret->node = node;\n-\n-    WXS_ADD_GLOBAL(ctxt, ret);\n-    \/*\n-    * Only keyrefs need to be fixup up.\n-    *\/\n-    if (category == XML_SCHEMA_TYPE_IDC_KEYREF)\n-    WXS_ADD_PENDING(ctxt, ret);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaAddWildcard:\n- * @ctxt:  a schema validation context\n- * @schema: a schema\n- *\n- * Adds a wildcard.\n- * It corresponds to a xsd:anyAttribute and xsd:any.\n- *\n- * Returns the new structure or NULL in case of error\n- *\/\n-static xmlSchemaWildcardPtr\n-xmlSchemaAddWildcard(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-             xmlSchemaTypeType type, xmlNodePtr node)\n-{\n-    xmlSchemaWildcardPtr ret = NULL;\n-\n-    if ((ctxt == NULL) || (schema == NULL))\n-        return (NULL);\n-\n-    ret = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));\n-    if (ret == NULL) {\n-        xmlSchemaPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaWildcard));\n-    ret->type = type;\n-    ret->node = node;\n-    WXS_ADD_LOCAL(ctxt, ret);\n-    return (ret);\n-}\n-\n-static void\n-xmlSchemaSubstGroupFree(xmlSchemaSubstGroupPtr group)\n-{\n-    if (group == NULL)\n-    return;\n-    if (group->members != NULL)\n-    xmlSchemaItemListFree(group->members);\n-    xmlFree(group);\n-}\n-\n-static void\n-xmlSchemaSubstGroupFreeEntry(void *group, const xmlChar *name ATTRIBUTE_UNUSED)\n-{\n-    xmlSchemaSubstGroupFree((xmlSchemaSubstGroupPtr) group);\n-}\n-\n-static xmlSchemaSubstGroupPtr\n-xmlSchemaSubstGroupAdd(xmlSchemaParserCtxtPtr pctxt,\n-               xmlSchemaElementPtr head)\n-{\n-    xmlSchemaSubstGroupPtr ret;\n-\n-    \/* Init subst group hash. *\/\n-    if (WXS_SUBST_GROUPS(pctxt) == NULL) {\n-    WXS_SUBST_GROUPS(pctxt) = xmlHashCreateDict(10, pctxt->dict);\n-    if (WXS_SUBST_GROUPS(pctxt) == NULL)\n-        return(NULL);\n-    }\n-    \/* Create a new substitution group. *\/\n-    ret = (xmlSchemaSubstGroupPtr) xmlMalloc(sizeof(xmlSchemaSubstGroup));\n-    if (ret == NULL) {\n-    xmlSchemaPErrMemory(NULL);\n-    return(NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaSubstGroup));\n-    ret->head = head;\n-    \/* Create list of members. *\/\n-    ret->members = xmlSchemaItemListCreate();\n-    if (ret->members == NULL) {\n-    xmlSchemaSubstGroupFree(ret);\n-    return(NULL);\n-    }\n-    \/* Add subst group to hash. *\/\n-    if (xmlHashAddEntry2(WXS_SUBST_GROUPS(pctxt),\n-    head->name, head->targetNamespace, ret) != 0) {\n-    PERROR_INT(\"xmlSchemaSubstGroupAdd\",\n-        \"failed to add a new substitution container\");\n-    xmlSchemaSubstGroupFree(ret);\n-    return(NULL);\n-    }\n-    return(ret);\n-}\n-\n-static xmlSchemaSubstGroupPtr\n-xmlSchemaSubstGroupGet(xmlSchemaParserCtxtPtr pctxt,\n-               xmlSchemaElementPtr head)\n-{\n-    if (WXS_SUBST_GROUPS(pctxt) == NULL)\n-    return(NULL);\n-    return(xmlHashLookup2(WXS_SUBST_GROUPS(pctxt),\n-    head->name, head->targetNamespace));\n-\n-}\n-\n-\/**\n- * xmlSchemaAddElementSubstitutionMember:\n- * @pctxt:  a schema parser context\n- * @head:  the head of the substitution group\n- * @member: the new member of the substitution group\n- *\n- * Allocate a new annotation structure.\n- *\n- * Returns the newly allocated structure or NULL in case or error\n- *\/\n-static int\n-xmlSchemaAddElementSubstitutionMember(xmlSchemaParserCtxtPtr pctxt,\n-                      xmlSchemaElementPtr head,\n-                      xmlSchemaElementPtr member)\n-{\n-    xmlSchemaSubstGroupPtr substGroup = NULL;\n-\n-    if ((pctxt == NULL) || (head == NULL) || (member == NULL))\n-    return (-1);\n-\n-    substGroup = xmlSchemaSubstGroupGet(pctxt, head);\n-    if (substGroup == NULL)\n-    substGroup = xmlSchemaSubstGroupAdd(pctxt, head);\n-    if (substGroup == NULL)\n-    return(-1);\n-    if (xmlSchemaItemListAdd(substGroup->members, member) == -1)\n-    return(-1);\n-    return(0);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Utilities for parsing                    *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlSchemaPValAttrNodeQNameValue:\n- * @ctxt:  a schema parser context\n- * @schema: the schema context\n- * @ownerItem: the parent as a schema object\n- * @value:  the QName value\n- * @uri:  the resulting namespace URI if found\n- * @local: the resulting local part if found, the attribute value otherwise\n- *\n- * Extracts the local name and the URI of a QName value and validates it.\n- * This one is intended to be used on attribute values that\n- * should resolve to schema components.\n- *\n- * Returns 0, in case the QName is valid, a positive error code\n- * if not valid and -1 if an internal error occurs.\n- *\/\n-static int\n-xmlSchemaPValAttrNodeQNameValue(xmlSchemaParserCtxtPtr ctxt,\n-                       xmlSchemaPtr schema,\n-                       xmlSchemaBasicItemPtr ownerItem,\n-                       xmlAttrPtr attr,\n-                       const xmlChar *value,\n-                       const xmlChar **uri,\n-                       const xmlChar **local)\n-{\n-    const xmlChar *pref;\n-    xmlNsPtr ns;\n-    int len, ret;\n-\n-    *uri = NULL;\n-    *local = NULL;\n-    ret = xmlValidateQName(value, 1);\n-    if (ret > 0) {\n-    xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        ownerItem, (xmlNodePtr) attr,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),\n-        NULL, value, NULL, NULL, NULL);\n-    *local = value;\n-    return (ctxt->err);\n-    } else if (ret < 0)\n-    return (-1);\n-\n-    if (!strchr((char *) value, ':')) {\n-    ns = xmlSearchNs(attr->doc, attr->parent, NULL);\n-    if (ns && ns->href && ns->href[0])\n-        *uri = xmlDictLookup(ctxt->dict, ns->href, -1);\n-    else if (schema->flags & XML_SCHEMAS_INCLUDING_CONVERT_NS) {\n-        \/* TODO: move XML_SCHEMAS_INCLUDING_CONVERT_NS to the\n-        * parser context. *\/\n-        \/*\n-        * This one takes care of included schemas with no\n-        * target namespace.\n-        *\/\n-        *uri = ctxt->targetNamespace;\n-    }\n-    *local = xmlDictLookup(ctxt->dict, value, -1);\n-    return (0);\n-    }\n-    \/*\n-    * At this point xmlSplitQName3 has to return a local name.\n-    *\/\n-    *local = xmlSplitQName3(value, &len);\n-    *local = xmlDictLookup(ctxt->dict, *local, -1);\n-    pref = xmlDictLookup(ctxt->dict, value, len);\n-    ns = xmlSearchNs(attr->doc, attr->parent, pref);\n-    if (ns == NULL) {\n-    xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        ownerItem, (xmlNodePtr) attr,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME), NULL, value,\n-        \"The value '%s' of simple type 'xs:QName' has no \"\n-        \"corresponding namespace declaration in scope\", value, NULL);\n-    return (ctxt->err);\n-    } else {\n-        *uri = xmlDictLookup(ctxt->dict, ns->href, -1);\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaPValAttrNodeQName:\n- * @ctxt:  a schema parser context\n- * @schema: the schema context\n- * @ownerItem: the owner as a schema object\n- * @attr:  the attribute node\n- * @uri:  the resulting namespace URI if found\n- * @local: the resulting local part if found, the attribute value otherwise\n- *\n- * Extracts and validates the QName of an attribute value.\n- * This one is intended to be used on attribute values that\n- * should resolve to schema components.\n- *\n- * Returns 0, in case the QName is valid, a positive error code\n- * if not valid and -1 if an internal error occurs.\n- *\/\n-static int\n-xmlSchemaPValAttrNodeQName(xmlSchemaParserCtxtPtr ctxt,\n-                       xmlSchemaPtr schema,\n-                       xmlSchemaBasicItemPtr ownerItem,\n-                       xmlAttrPtr attr,\n-                       const xmlChar **uri,\n-                       const xmlChar **local)\n-{\n-    const xmlChar *value;\n-\n-    value = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-    return (xmlSchemaPValAttrNodeQNameValue(ctxt, schema,\n-    ownerItem, attr, value, uri, local));\n-}\n-\n-\/**\n- * xmlSchemaPValAttrQName:\n- * @ctxt:  a schema parser context\n- * @schema: the schema context\n- * @ownerItem: the owner as a schema object\n- * @ownerElem:  the parent node of the attribute\n- * @name:  the name of the attribute\n- * @uri:  the resulting namespace URI if found\n- * @local: the resulting local part if found, the attribute value otherwise\n- *\n- * Extracts and validates the QName of an attribute value.\n- *\n- * Returns 0, in case the QName is valid, a positive error code\n- * if not valid and -1 if an internal error occurs.\n- *\/\n-static int\n-xmlSchemaPValAttrQName(xmlSchemaParserCtxtPtr ctxt,\n-                   xmlSchemaPtr schema,\n-                   xmlSchemaBasicItemPtr ownerItem,\n-                   xmlNodePtr ownerElem,\n-                   const char *name,\n-                   const xmlChar **uri,\n-                   const xmlChar **local)\n-{\n-    xmlAttrPtr attr;\n-\n-    attr = xmlSchemaGetPropNode(ownerElem, name);\n-    if (attr == NULL) {\n-    *local = NULL;\n-    *uri = NULL;\n-    return (0);\n-    }\n-    return (xmlSchemaPValAttrNodeQName(ctxt, schema,\n-    ownerItem, attr, uri, local));\n-}\n-\n-\/**\n- * xmlSchemaPValAttrID:\n- * @ctxt:  a schema parser context\n- *\n- * Extracts and validates the ID of an attribute value.\n- *\n- * Returns 0, in case the ID is valid, a positive error code\n- * if not valid and -1 if an internal error occurs.\n- *\/\n-static int\n-xmlSchemaPValAttrNodeID(xmlSchemaParserCtxtPtr ctxt, xmlAttrPtr attr)\n-{\n-    int ret;\n-    const xmlChar *value;\n-\n-    if (attr == NULL)\n-    return(0);\n-    value = xmlSchemaGetNodeContentNoDict((xmlNodePtr) attr);\n-    ret = xmlValidateNCName(value, 1);\n-    if (ret == 0) {\n-    \/*\n-    * NOTE: the IDness might have already be declared in the DTD\n-    *\/\n-    if (attr->atype != XML_ATTRIBUTE_ID) {\n-        xmlChar *strip;\n-            int res;\n-\n-        \/*\n-        * TODO: Use xmlSchemaStrip here; it's not exported at this\n-        * moment.\n-        *\/\n-        strip = xmlSchemaCollapseString(value);\n-        if (strip != NULL) {\n-        xmlFree((xmlChar *) value);\n-        value = strip;\n-        }\n-        res = xmlAddIDSafe(attr, value);\n-            if (res < 0) {\n-                xmlSchemaPErrMemory(ctxt);\n-        } else if (res == 0) {\n-        ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE;\n-        xmlSchemaPSimpleTypeErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-            NULL, (xmlNodePtr) attr,\n-            xmlSchemaGetBuiltInType(XML_SCHEMAS_ID),\n-            NULL, NULL, \"Duplicate value '%s' of simple \"\n-            \"type 'xs:ID'\", value, NULL);\n-        }\n-    }\n-    } else if (ret > 0) {\n-    ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE;\n-    xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        NULL, (xmlNodePtr) attr,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_ID),\n-        NULL, NULL, \"The value '%s' of simple type 'xs:ID' is \"\n-        \"not a valid 'xs:NCName'\",\n-        value, NULL);\n-    }\n-    if (value != NULL)\n-    xmlFree((xmlChar *)value);\n-\n-    return (ret);\n-}\n-\n-static int\n-xmlSchemaPValAttrID(xmlSchemaParserCtxtPtr ctxt,\n-            xmlNodePtr ownerElem,\n-            const xmlChar *name)\n-{\n-    xmlAttrPtr attr;\n-\n-    attr = xmlSchemaGetPropNode(ownerElem, (const char *) name);\n-    if (attr == NULL)\n-    return(0);\n-    return(xmlSchemaPValAttrNodeID(ctxt, attr));\n-\n-}\n-\n-\/**\n- * xmlGetMaxOccurs:\n- * @ctxt:  a schema validation context\n- * @node:  a subtree containing XML Schema information\n- *\n- * Get the maxOccurs property\n- *\n- * Returns the default if not found, or the value\n- *\/\n-static int\n-xmlGetMaxOccurs(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node,\n-        int min, int max, int def, const char *expected)\n-{\n-    const xmlChar *val, *cur;\n-    int ret = 0;\n-    xmlAttrPtr attr;\n-\n-    attr = xmlSchemaGetPropNode(node, \"maxOccurs\");\n-    if (attr == NULL)\n-    return (def);\n-    val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-    if (val == NULL)\n-        return (def);\n-\n-    if (xmlStrEqual(val, (const xmlChar *) \"unbounded\")) {\n-    if (max != UNBOUNDED) {\n-        xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        \/* XML_SCHEMAP_INVALID_MINOCCURS, *\/\n-        NULL, (xmlNodePtr) attr, NULL, expected,\n-        val, NULL, NULL, NULL);\n-        return (def);\n-    } else\n-        return (UNBOUNDED);  \/* encoding it with -1 might be another option *\/\n-    }\n-\n-    cur = val;\n-    while (IS_BLANK_CH(*cur))\n-        cur++;\n-    if (*cur == 0) {\n-        xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        \/* XML_SCHEMAP_INVALID_MINOCCURS, *\/\n-        NULL, (xmlNodePtr) attr, NULL, expected,\n-        val, NULL, NULL, NULL);\n-    return (def);\n-    }\n-    while ((*cur >= '0') && (*cur <= '9')) {\n-        if (ret > INT_MAX \/ 10) {\n-            ret = INT_MAX;\n-        } else {\n-            int digit = *cur - '0';\n-            ret *= 10;\n-            if (ret > INT_MAX - digit)\n-                ret = INT_MAX;\n-            else\n-                ret += digit;\n-        }\n-        cur++;\n-    }\n-    while (IS_BLANK_CH(*cur))\n-        cur++;\n-    \/*\n-    * TODO: Restrict the maximal value to Integer.\n-    *\/\n-    if ((*cur != 0) || (ret < min) || ((max != -1) && (ret > max))) {\n-    xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        \/* XML_SCHEMAP_INVALID_MINOCCURS, *\/\n-        NULL, (xmlNodePtr) attr, NULL, expected,\n-        val, NULL, NULL, NULL);\n-        return (def);\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlGetMinOccurs:\n- * @ctxt:  a schema validation context\n- * @node:  a subtree containing XML Schema information\n- *\n- * Get the minOccurs property\n- *\n- * Returns the default if not found, or the value\n- *\/\n-static int\n-xmlGetMinOccurs(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node,\n-        int min, int max, int def, const char *expected)\n-{\n-    const xmlChar *val, *cur;\n-    int ret = 0;\n-    xmlAttrPtr attr;\n-\n-    attr = xmlSchemaGetPropNode(node, \"minOccurs\");\n-    if (attr == NULL)\n-    return (def);\n-    val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-    if (val == NULL)\n-    return (def);\n-    cur = val;\n-    while (IS_BLANK_CH(*cur))\n-        cur++;\n-    if (*cur == 0) {\n-        xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        \/* XML_SCHEMAP_INVALID_MINOCCURS, *\/\n-        NULL, (xmlNodePtr) attr, NULL, expected,\n-        val, NULL, NULL, NULL);\n-        return (def);\n-    }\n-    while ((*cur >= '0') && (*cur <= '9')) {\n-        if (ret > INT_MAX \/ 10) {\n-            ret = INT_MAX;\n-        } else {\n-            int digit = *cur - '0';\n-            ret *= 10;\n-            if (ret > INT_MAX - digit)\n-                ret = INT_MAX;\n-            else\n-                ret += digit;\n-        }\n-        cur++;\n-    }\n-    while (IS_BLANK_CH(*cur))\n-        cur++;\n-    \/*\n-    * TODO: Restrict the maximal value to Integer.\n-    *\/\n-    if ((*cur != 0) || (ret < min) || ((max != -1) && (ret > max))) {\n-    xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        \/* XML_SCHEMAP_INVALID_MINOCCURS, *\/\n-        NULL, (xmlNodePtr) attr, NULL, expected,\n-        val, NULL, NULL, NULL);\n-        return (def);\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaPGetBoolNodeValue:\n- * @ctxt:  a schema validation context\n- * @ownerItem:  the owner as a schema item\n- * @node: the node holding the value\n- *\n- * Converts a boolean string value into 1 or 0.\n- *\n- * Returns 0 or 1.\n- *\/\n-static int\n-xmlSchemaPGetBoolNodeValue(xmlSchemaParserCtxtPtr ctxt,\n-               xmlSchemaBasicItemPtr ownerItem,\n-               xmlNodePtr node)\n-{\n-    xmlChar *value = NULL;\n-    int res = 0;\n-\n-    value = xmlNodeGetContent(node);\n-    \/*\n-    * 3.2.2.1 Lexical representation\n-    * An instance of a datatype that is defined as `boolean`\n-    * can have the following legal literals {true, false, 1, 0}.\n-    *\/\n-    if (xmlStrEqual(BAD_CAST value, BAD_CAST \"true\"))\n-        res = 1;\n-    else if (xmlStrEqual(BAD_CAST value, BAD_CAST \"false\"))\n-        res = 0;\n-    else if (xmlStrEqual(BAD_CAST value, BAD_CAST \"1\"))\n-    res = 1;\n-    else if (xmlStrEqual(BAD_CAST value, BAD_CAST \"0\"))\n-        res = 0;\n-    else {\n-        xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_INVALID_BOOLEAN,\n-        ownerItem, node,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),\n-        NULL, BAD_CAST value,\n-        NULL, NULL, NULL);\n-    }\n-    if (value != NULL)\n-    xmlFree(value);\n-    return (res);\n-}\n-\n-\/**\n- * xmlGetBooleanProp:\n- * @ctxt:  a schema validation context\n- * @node:  a subtree containing XML Schema information\n- * @name:  the attribute name\n- * @def:  the default value\n- *\n- * Evaluate if a boolean property is set\n- *\n- * Returns the default if not found, 0 if found to be false,\n- * 1 if found to be true\n- *\/\n-static int\n-xmlGetBooleanProp(xmlSchemaParserCtxtPtr ctxt,\n-          xmlNodePtr node,\n-                  const char *name, int def)\n-{\n-    const xmlChar *val;\n-\n-    val = xmlSchemaGetProp(ctxt, node, name);\n-    if (val == NULL)\n-        return (def);\n-    \/*\n-    * 3.2.2.1 Lexical representation\n-    * An instance of a datatype that is defined as `boolean`\n-    * can have the following legal literals {true, false, 1, 0}.\n-    *\/\n-    if (xmlStrEqual(val, BAD_CAST \"true\"))\n-        def = 1;\n-    else if (xmlStrEqual(val, BAD_CAST \"false\"))\n-        def = 0;\n-    else if (xmlStrEqual(val, BAD_CAST \"1\"))\n-    def = 1;\n-    else if (xmlStrEqual(val, BAD_CAST \"0\"))\n-        def = 0;\n-    else {\n-        xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_INVALID_BOOLEAN,\n-        NULL,\n-        (xmlNodePtr) xmlSchemaGetPropNode(node, name),\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),\n-        NULL, val, NULL, NULL, NULL);\n-    }\n-    return (def);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Schema extraction from an Infoset            *\n- *                                    *\n- ************************************************************************\/\n-static xmlSchemaTypePtr xmlSchemaParseSimpleType(xmlSchemaParserCtxtPtr\n-                                                 ctxt, xmlSchemaPtr schema,\n-                                                 xmlNodePtr node,\n-                         int topLevel);\n-static xmlSchemaTypePtr xmlSchemaParseComplexType(xmlSchemaParserCtxtPtr\n-                                                  ctxt,\n-                                                  xmlSchemaPtr schema,\n-                                                  xmlNodePtr node,\n-                          int topLevel);\n-static xmlSchemaTypePtr xmlSchemaParseRestriction(xmlSchemaParserCtxtPtr\n-                                                  ctxt,\n-                                                  xmlSchemaPtr schema,\n-                                                  xmlNodePtr node,\n-                          xmlSchemaTypeType parentType);\n-static xmlSchemaBasicItemPtr\n-xmlSchemaParseLocalAttribute(xmlSchemaParserCtxtPtr pctxt,\n-                 xmlSchemaPtr schema,\n-                 xmlNodePtr node,\n-                 xmlSchemaItemListPtr uses,\n-                 int parentType);\n-static xmlSchemaTypePtr xmlSchemaParseList(xmlSchemaParserCtxtPtr ctxt,\n-                                           xmlSchemaPtr schema,\n-                                           xmlNodePtr node);\n-static xmlSchemaWildcardPtr\n-xmlSchemaParseAnyAttribute(xmlSchemaParserCtxtPtr ctxt,\n-                           xmlSchemaPtr schema, xmlNodePtr node);\n-\n-\/**\n- * xmlSchemaPValAttrNodeValue:\n- *\n- * @pctxt:  a schema parser context\n- * @ownerItem: the schema object owner if existent\n- * @attr:  the schema attribute node being validated\n- * @value: the value\n- * @type: the built-in type to be validated against\n- *\n- * Validates a value against the given built-in type.\n- * This one is intended to be used internally for validation\n- * of schema attribute values during parsing of the schema.\n- *\n- * Returns 0 if the value is valid, a positive error code\n- * number otherwise and -1 in case of an internal or API error.\n- *\/\n-static int\n-xmlSchemaPValAttrNodeValue(xmlSchemaParserCtxtPtr pctxt,\n-               xmlSchemaBasicItemPtr ownerItem,\n-               xmlAttrPtr attr,\n-               const xmlChar *value,\n-               xmlSchemaTypePtr type)\n-{\n-\n-    int ret = 0;\n-\n-    \/*\n-    * NOTE: Should we move this to xmlschematypes.c? Hmm, but this\n-    * one is really meant to be used internally, so better not.\n-    *\/\n-    if ((pctxt == NULL) || (type == NULL) || (attr == NULL))\n-    return (-1);\n-    if (type->type != XML_SCHEMA_TYPE_BASIC) {\n-    PERROR_INT(\"xmlSchemaPValAttrNodeValue\",\n-        \"the given type is not a built-in type\");\n-    return (-1);\n-    }\n-    switch (type->builtInType) {\n-    case XML_SCHEMAS_NCNAME:\n-    case XML_SCHEMAS_QNAME:\n-    case XML_SCHEMAS_ANYURI:\n-    case XML_SCHEMAS_TOKEN:\n-    case XML_SCHEMAS_LANGUAGE:\n-        ret = xmlSchemaValPredefTypeNode(type, value, NULL,\n-        (xmlNodePtr) attr);\n-        break;\n-    default: {\n-        PERROR_INT(\"xmlSchemaPValAttrNodeValue\",\n-        \"validation using the given type is not supported while \"\n-        \"parsing a schema\");\n-        return (-1);\n-    }\n-    }\n-    \/*\n-    * TODO: Should we use the S4S error codes instead?\n-    *\/\n-    if (ret < 0) {\n-    PERROR_INT(\"xmlSchemaPValAttrNodeValue\",\n-        \"failed to validate a schema attribute value\");\n-    return (-1);\n-    } else if (ret > 0) {\n-    if (WXS_IS_LIST(type))\n-        ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;\n-    else\n-        ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1;\n-    xmlSchemaPSimpleTypeErr(pctxt,\n-        ret, ownerItem, (xmlNodePtr) attr,\n-        type, NULL, value, NULL, NULL, NULL);\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaPValAttrNode:\n- *\n- * @ctxt:  a schema parser context\n- * @ownerItem: the schema object owner if existent\n- * @attr:  the schema attribute node being validated\n- * @type: the built-in type to be validated against\n- * @value: the resulting value if any\n- *\n- * Extracts and validates a value against the given built-in type.\n- * This one is intended to be used internally for validation\n- * of schema attribute values during parsing of the schema.\n- *\n- * Returns 0 if the value is valid, a positive error code\n- * number otherwise and -1 in case of an internal or API error.\n- *\/\n-static int\n-xmlSchemaPValAttrNode(xmlSchemaParserCtxtPtr ctxt,\n-               xmlSchemaBasicItemPtr ownerItem,\n-               xmlAttrPtr attr,\n-               xmlSchemaTypePtr type,\n-               const xmlChar **value)\n-{\n-    const xmlChar *val;\n-\n-    if ((ctxt == NULL) || (type == NULL) || (attr == NULL))\n-    return (-1);\n-\n-    val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-    if (value != NULL)\n-    *value = val;\n-\n-    return (xmlSchemaPValAttrNodeValue(ctxt, ownerItem, attr,\n-    val, type));\n-}\n-\n-\/**\n- * xmlSchemaPValAttr:\n- *\n- * @ctxt:  a schema parser context\n- * @node: the element node of the attribute\n- * @ownerItem: the schema object owner if existent\n- * @ownerElem: the owner element node\n- * @name:  the name of the schema attribute node\n- * @type: the built-in type to be validated against\n- * @value: the resulting value if any\n- *\n- * Extracts and validates a value against the given built-in type.\n- * This one is intended to be used internally for validation\n- * of schema attribute values during parsing of the schema.\n- *\n- * Returns 0 if the value is valid, a positive error code\n- * number otherwise and -1 in case of an internal or API error.\n- *\/\n-static int\n-xmlSchemaPValAttr(xmlSchemaParserCtxtPtr ctxt,\n-               xmlSchemaBasicItemPtr ownerItem,\n-               xmlNodePtr ownerElem,\n-               const char *name,\n-               xmlSchemaTypePtr type,\n-               const xmlChar **value)\n-{\n-    xmlAttrPtr attr;\n-\n-    if ((ctxt == NULL) || (type == NULL)) {\n-    if (value != NULL)\n-        *value = NULL;\n-    return (-1);\n-    }\n-    if (type->type != XML_SCHEMA_TYPE_BASIC) {\n-    if (value != NULL)\n-        *value = NULL;\n-    xmlSchemaPErr(ctxt, ownerElem,\n-        XML_SCHEMAP_INTERNAL,\n-        \"Internal error: xmlSchemaPValAttr, the given \"\n-        \"type '%s' is not a built-in type.\\n\",\n-        type->name, NULL);\n-    return (-1);\n-    }\n-    attr = xmlSchemaGetPropNode(ownerElem, name);\n-    if (attr == NULL) {\n-    if (value != NULL)\n-        *value = NULL;\n-    return (0);\n-    }\n-    return (xmlSchemaPValAttrNode(ctxt, ownerItem, attr,\n-    type, value));\n-}\n-\n-static int\n-xmlSchemaCheckReference(xmlSchemaParserCtxtPtr pctxt,\n-          xmlSchemaPtr schema ATTRIBUTE_UNUSED,\n-          xmlNodePtr node,\n-          xmlAttrPtr attr,\n-          const xmlChar *namespaceName)\n-{\n-    \/* TODO: Pointer comparison instead? *\/\n-    if (xmlStrEqual(pctxt->targetNamespace, namespaceName))\n-    return (0);\n-    if (xmlStrEqual(xmlSchemaNs, namespaceName))\n-    return (0);\n-    \/*\n-    * Check if the referenced namespace was <import>ed.\n-    *\/\n-    if (WXS_BUCKET(pctxt)->relations != NULL) {\n-    xmlSchemaSchemaRelationPtr rel;\n-\n-    rel = WXS_BUCKET(pctxt)->relations;\n-    do {\n-        if (WXS_IS_BUCKET_IMPMAIN(rel->type) &&\n-        xmlStrEqual(namespaceName, rel->importNamespace))\n-        return (0);\n-        rel = rel->next;\n-    } while (rel != NULL);\n-    }\n-    \/*\n-    * No matching <import>ed namespace found.\n-    *\/\n-    {\n-    xmlNodePtr n = (attr != NULL) ? (xmlNodePtr) attr : node;\n-\n-    if (namespaceName == NULL)\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_SRC_RESOLVE, n, NULL,\n-        \"References from this schema to components in no \"\n-        \"namespace are not allowed, since not indicated by an \"\n-        \"import statement\", NULL, NULL);\n-    else\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_SRC_RESOLVE, n, NULL,\n-        \"References from this schema to components in the \"\n-        \"namespace '%s' are not allowed, since not indicated by an \"\n-        \"import statement\", namespaceName, NULL);\n-    }\n-    return (XML_SCHEMAP_SRC_RESOLVE);\n-}\n-\n-\/**\n- * xmlSchemaParseLocalAttributes:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- * @type:  the hosting type where the attributes will be anchored\n- *\n- * Parses attribute uses and attribute declarations and\n- * attribute group references.\n- *\/\n-static int\n-xmlSchemaParseLocalAttributes(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                        xmlNodePtr *child, xmlSchemaItemListPtr *list,\n-            int parentType, int *hasRefs)\n-{\n-    void *item;\n-\n-    while ((IS_SCHEMA((*child), \"attribute\")) ||\n-           (IS_SCHEMA((*child), \"attributeGroup\"))) {\n-        if (IS_SCHEMA((*child), \"attribute\")) {\n-        item = xmlSchemaParseLocalAttribute(ctxt, schema, *child,\n-        *list, parentType);\n-        } else {\n-            item = xmlSchemaParseAttributeGroupRef(ctxt, schema, *child);\n-        if ((item != NULL) && (hasRefs != NULL))\n-        *hasRefs = 1;\n-        }\n-    if (item != NULL) {\n-        if (*list == NULL) {\n-        \/* TODO: Customize grow factor. *\/\n-        *list = xmlSchemaItemListCreate();\n-        if (*list == NULL)\n-            return(-1);\n-        }\n-        if (xmlSchemaItemListAddSize(*list, 2, item) == -1)\n-        return(-1);\n-    }\n-        *child = (*child)->next;\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaParseAnnotation:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * parse a XML schema Attribute declaration\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns -1 in case of error, 0 if the declaration is improper and\n- *         1 in case of success.\n- *\/\n-static xmlSchemaAnnotPtr\n-xmlSchemaParseAnnotation(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node, int needed)\n-{\n-    xmlSchemaAnnotPtr ret;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-    int barked = 0;\n-\n-    \/*\n-    * INFO: S4S completed.\n-    *\/\n-    \/*\n-    * id = ID\n-    * {any attributes with non-schema namespace . . .}>\n-    * Content: (appinfo | documentation)*\n-    *\/\n-    if ((ctxt == NULL) || (node == NULL))\n-        return (NULL);\n-    if (needed)\n-    ret = xmlSchemaNewAnnot(ctxt, node);\n-    else\n-    ret = NULL;\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (((attr->ns == NULL) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"id\"))) ||\n-        ((attr->ns != NULL) &&\n-        xmlStrEqual(attr->ns->href, xmlSchemaNs))) {\n-\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    while (child != NULL) {\n-    if (IS_SCHEMA(child, \"appinfo\")) {\n-        \/* TODO: make available the content of \"appinfo\". *\/\n-        \/*\n-        * source = anyURI\n-        * {any attributes with non-schema namespace . . .}>\n-        * Content: ({any})*\n-        *\/\n-        attr = child->properties;\n-        while (attr != NULL) {\n-        if (((attr->ns == NULL) &&\n-             (!xmlStrEqual(attr->name, BAD_CAST \"source\"))) ||\n-             ((attr->ns != NULL) &&\n-              xmlStrEqual(attr->ns->href, xmlSchemaNs))) {\n-\n-            xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-        attr = attr->next;\n-        }\n-        xmlSchemaPValAttr(ctxt, NULL, child, \"source\",\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI), NULL);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"documentation\")) {\n-        \/* TODO: make available the content of \"documentation\". *\/\n-        \/*\n-        * source = anyURI\n-        * {any attributes with non-schema namespace . . .}>\n-        * Content: ({any})*\n-        *\/\n-        attr = child->properties;\n-        while (attr != NULL) {\n-        if (attr->ns == NULL) {\n-            if (!xmlStrEqual(attr->name, BAD_CAST \"source\")) {\n-            xmlSchemaPIllegalAttrErr(ctxt,\n-                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-            }\n-        } else {\n-            if (xmlStrEqual(attr->ns->href, xmlSchemaNs) ||\n-            (xmlStrEqual(attr->name, BAD_CAST \"lang\") &&\n-            (!xmlStrEqual(attr->ns->href, XML_XML_NAMESPACE)))) {\n-\n-            xmlSchemaPIllegalAttrErr(ctxt,\n-                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-            }\n-        }\n-        attr = attr->next;\n-        }\n-        \/*\n-        * Attribute \"xml:lang\".\n-        *\/\n-        attr = xmlSchemaGetPropNodeNs(child, (const char *) XML_XML_NAMESPACE, \"lang\");\n-        if (attr != NULL)\n-        xmlSchemaPValAttrNode(ctxt, NULL, attr,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_LANGUAGE), NULL);\n-        child = child->next;\n-    } else {\n-        if (!barked)\n-        xmlSchemaPContentErr(ctxt,\n-            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-            NULL, node, child, NULL, \"(appinfo | documentation)*\");\n-        barked = 1;\n-        child = child->next;\n-    }\n-    }\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaParseFacet:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * parse a XML schema Facet declaration\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the new type structure or NULL in case of error\n- *\/\n-static xmlSchemaFacetPtr\n-xmlSchemaParseFacet(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                    xmlNodePtr node)\n-{\n-    xmlSchemaFacetPtr facet;\n-    xmlNodePtr child = NULL;\n-    const xmlChar *value;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-\n-    facet = xmlSchemaNewFacet();\n-    if (facet == NULL) {\n-        xmlSchemaPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    facet->node = node;\n-    value = xmlSchemaGetProp(ctxt, node, \"value\");\n-    if (value == NULL) {\n-        xmlSchemaPErr2(ctxt, node, child, XML_SCHEMAP_FACET_NO_VALUE,\n-                       \"Facet %s has no value\\n\", node->name, NULL);\n-        xmlSchemaFreeFacet(facet);\n-        return (NULL);\n-    }\n-    if (IS_SCHEMA(node, \"minInclusive\")) {\n-        facet->type = XML_SCHEMA_FACET_MININCLUSIVE;\n-    } else if (IS_SCHEMA(node, \"minExclusive\")) {\n-        facet->type = XML_SCHEMA_FACET_MINEXCLUSIVE;\n-    } else if (IS_SCHEMA(node, \"maxInclusive\")) {\n-        facet->type = XML_SCHEMA_FACET_MAXINCLUSIVE;\n-    } else if (IS_SCHEMA(node, \"maxExclusive\")) {\n-        facet->type = XML_SCHEMA_FACET_MAXEXCLUSIVE;\n-    } else if (IS_SCHEMA(node, \"totalDigits\")) {\n-        facet->type = XML_SCHEMA_FACET_TOTALDIGITS;\n-    } else if (IS_SCHEMA(node, \"fractionDigits\")) {\n-        facet->type = XML_SCHEMA_FACET_FRACTIONDIGITS;\n-    } else if (IS_SCHEMA(node, \"pattern\")) {\n-        facet->type = XML_SCHEMA_FACET_PATTERN;\n-    } else if (IS_SCHEMA(node, \"enumeration\")) {\n-        facet->type = XML_SCHEMA_FACET_ENUMERATION;\n-    } else if (IS_SCHEMA(node, \"whiteSpace\")) {\n-        facet->type = XML_SCHEMA_FACET_WHITESPACE;\n-    } else if (IS_SCHEMA(node, \"length\")) {\n-        facet->type = XML_SCHEMA_FACET_LENGTH;\n-    } else if (IS_SCHEMA(node, \"maxLength\")) {\n-        facet->type = XML_SCHEMA_FACET_MAXLENGTH;\n-    } else if (IS_SCHEMA(node, \"minLength\")) {\n-        facet->type = XML_SCHEMA_FACET_MINLENGTH;\n-    } else {\n-        xmlSchemaPErr2(ctxt, node, child, XML_SCHEMAP_UNKNOWN_FACET_TYPE,\n-                       \"Unknown facet type %s\\n\", node->name, NULL);\n-        xmlSchemaFreeFacet(facet);\n-        return (NULL);\n-    }\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-    facet->value = value;\n-    if ((facet->type != XML_SCHEMA_FACET_PATTERN) &&\n-    (facet->type != XML_SCHEMA_FACET_ENUMERATION)) {\n-    const xmlChar *fixed;\n-\n-    fixed = xmlSchemaGetProp(ctxt, node, \"fixed\");\n-    if (fixed != NULL) {\n-        if (xmlStrEqual(fixed, BAD_CAST \"true\"))\n-        facet->fixed = 1;\n-    }\n-    }\n-    child = node->children;\n-\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-        facet->annot = xmlSchemaParseAnnotation(ctxt, child, 1);\n-        child = child->next;\n-    }\n-    if (child != NULL) {\n-        xmlSchemaPErr2(ctxt, node, child, XML_SCHEMAP_UNKNOWN_FACET_CHILD,\n-                       \"Facet %s has unexpected child content\\n\",\n-                       node->name, NULL);\n-    }\n-    return (facet);\n-}\n-\n-\/**\n- * xmlSchemaParseWildcardNs:\n- * @ctxt:  a schema parser context\n- * @wildc:  the wildcard, already created\n- * @node:  a subtree containing XML Schema information\n- *\n- * Parses the attribute \"processContents\" and \"namespace\"\n- * of a xsd:anyAttribute and xsd:any.\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns 0 if everything goes fine, a positive error code\n- * if something is not valid and -1 if an internal error occurs.\n- *\/\n-static int\n-xmlSchemaParseWildcardNs(xmlSchemaParserCtxtPtr ctxt,\n-             xmlSchemaPtr schema ATTRIBUTE_UNUSED,\n-             xmlSchemaWildcardPtr wildc,\n-             xmlNodePtr node)\n-{\n-    const xmlChar *pc, *ns, *dictnsItem;\n-    int ret = 0;\n-    xmlChar *nsItem;\n-    xmlSchemaWildcardNsPtr tmp, lastNs = NULL;\n-    xmlAttrPtr attr;\n-\n-    pc = xmlSchemaGetProp(ctxt, node, \"processContents\");\n-    if ((pc == NULL)\n-        || (xmlStrEqual(pc, (const xmlChar *) \"strict\"))) {\n-        wildc->processContents = XML_SCHEMAS_ANY_STRICT;\n-    } else if (xmlStrEqual(pc, (const xmlChar *) \"skip\")) {\n-        wildc->processContents = XML_SCHEMAS_ANY_SKIP;\n-    } else if (xmlStrEqual(pc, (const xmlChar *) \"lax\")) {\n-        wildc->processContents = XML_SCHEMAS_ANY_LAX;\n-    } else {\n-        xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        NULL, node,\n-        NULL, \"(strict | skip | lax)\", pc,\n-        NULL, NULL, NULL);\n-        wildc->processContents = XML_SCHEMAS_ANY_STRICT;\n-    ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE;\n-    }\n-    \/*\n-     * Build the namespace constraints.\n-     *\/\n-    attr = xmlSchemaGetPropNode(node, \"namespace\");\n-    ns = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-    if (ns == NULL)\n-        return (-1);\n-    if ((attr == NULL) || (xmlStrEqual(ns, BAD_CAST \"##any\")))\n-    wildc->any = 1;\n-    else if (xmlStrEqual(ns, BAD_CAST \"##other\")) {\n-    wildc->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);\n-    if (wildc->negNsSet == NULL) {\n-        return (-1);\n-    }\n-    wildc->negNsSet->value = ctxt->targetNamespace;\n-    } else {\n-    const xmlChar *end, *cur;\n-\n-    cur = ns;\n-    do {\n-        while (IS_BLANK_CH(*cur))\n-        cur++;\n-        end = cur;\n-        while ((*end != 0) && (!(IS_BLANK_CH(*end))))\n-        end++;\n-        if (end == cur)\n-        break;\n-        nsItem = xmlStrndup(cur, end - cur);\n-        if ((xmlStrEqual(nsItem, BAD_CAST \"##other\")) ||\n-            (xmlStrEqual(nsItem, BAD_CAST \"##any\"))) {\n-        xmlSchemaPSimpleTypeErr(ctxt,\n-            XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER,\n-            NULL, (xmlNodePtr) attr,\n-            NULL,\n-            \"((##any | ##other) | List of (xs:anyURI | \"\n-            \"(##targetNamespace | ##local)))\",\n-            nsItem, NULL, NULL, NULL);\n-        ret = XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER;\n-        } else {\n-        if (xmlStrEqual(nsItem, BAD_CAST \"##targetNamespace\")) {\n-            dictnsItem = ctxt->targetNamespace;\n-        } else if (xmlStrEqual(nsItem, BAD_CAST \"##local\")) {\n-            dictnsItem = NULL;\n-        } else {\n-            \/*\n-            * Validate the item (anyURI).\n-            *\/\n-            xmlSchemaPValAttrNodeValue(ctxt, NULL, attr,\n-            nsItem, xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI));\n-            dictnsItem = xmlDictLookup(ctxt->dict, nsItem, -1);\n-        }\n-        \/*\n-        * Avoid duplicate namespaces.\n-        *\/\n-        tmp = wildc->nsSet;\n-        while (tmp != NULL) {\n-            if (dictnsItem == tmp->value)\n-            break;\n-            tmp = tmp->next;\n-        }\n-        if (tmp == NULL) {\n-            tmp = xmlSchemaNewWildcardNsConstraint(ctxt);\n-            if (tmp == NULL) {\n-            xmlFree(nsItem);\n-            return (-1);\n-            }\n-            tmp->value = dictnsItem;\n-            tmp->next = NULL;\n-            if (wildc->nsSet == NULL)\n-            wildc->nsSet = tmp;\n-            else if (lastNs != NULL)\n-            lastNs->next = tmp;\n-            lastNs = tmp;\n-        }\n-\n-        }\n-        xmlFree(nsItem);\n-        cur = end;\n-    } while (*cur != 0);\n-    }\n-    return (ret);\n-}\n-\n-static int\n-xmlSchemaPCheckParticleCorrect_2(xmlSchemaParserCtxtPtr ctxt,\n-                 xmlSchemaParticlePtr item ATTRIBUTE_UNUSED,\n-                 xmlNodePtr node,\n-                 int minOccurs,\n-                 int maxOccurs) {\n-\n-    if ((maxOccurs == 0) && ( minOccurs == 0))\n-    return (0);\n-    if (maxOccurs != UNBOUNDED) {\n-    \/*\n-    * TODO: Maybe we should better not create the particle,\n-    * if min\/max is invalid, since it could confuse the build of the\n-    * content model.\n-    *\/\n-    \/*\n-    * 3.9.6 Schema Component Constraint: Particle Correct\n-    *\n-    *\/\n-    if (maxOccurs < 1) {\n-        \/*\n-        * 2.2 {max occurs} must be greater than or equal to 1.\n-        *\/\n-        xmlSchemaPCustomAttrErr(ctxt,\n-        XML_SCHEMAP_P_PROPS_CORRECT_2_2,\n-        NULL, NULL,\n-        xmlSchemaGetPropNode(node, \"maxOccurs\"),\n-        \"The value must be greater than or equal to 1\");\n-        return (XML_SCHEMAP_P_PROPS_CORRECT_2_2);\n-    } else if (minOccurs > maxOccurs) {\n-        \/*\n-        * 2.1 {min occurs} must not be greater than {max occurs}.\n-        *\/\n-        xmlSchemaPCustomAttrErr(ctxt,\n-        XML_SCHEMAP_P_PROPS_CORRECT_2_1,\n-        NULL, NULL,\n-        xmlSchemaGetPropNode(node, \"minOccurs\"),\n-        \"The value must not be greater than the value of 'maxOccurs'\");\n-        return (XML_SCHEMAP_P_PROPS_CORRECT_2_1);\n-    }\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaParseAny:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * Parsea a XML schema <any> element. A particle and wildcard\n- * will be created (except if minOccurs==maxOccurs==0, in this case\n- * nothing will be created).\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the particle or NULL in case of error or if minOccurs==maxOccurs==0\n- *\/\n-static xmlSchemaParticlePtr\n-xmlSchemaParseAny(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                  xmlNodePtr node)\n-{\n-    xmlSchemaParticlePtr particle;\n-    xmlNodePtr child = NULL;\n-    xmlSchemaWildcardPtr wild;\n-    int min, max;\n-    xmlAttrPtr attr;\n-    xmlSchemaAnnotPtr annot = NULL;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"minOccurs\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"maxOccurs\")) &&\n-            (!xmlStrEqual(attr->name, BAD_CAST \"namespace\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"processContents\"))) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-    \/*\n-    * minOccurs\/maxOccurs.\n-    *\/\n-    max = xmlGetMaxOccurs(ctxt, node, 0, UNBOUNDED, 1,\n-    \"(xs:nonNegativeInteger | unbounded)\");\n-    min = xmlGetMinOccurs(ctxt, node, 0, -1, 1,\n-    \"xs:nonNegativeInteger\");\n-    xmlSchemaPCheckParticleCorrect_2(ctxt, NULL, node, min, max);\n-    \/*\n-    * Create & parse the wildcard.\n-    *\/\n-    wild = xmlSchemaAddWildcard(ctxt, schema, XML_SCHEMA_TYPE_ANY, node);\n-    if (wild == NULL)\n-    return (NULL);\n-    xmlSchemaParseWildcardNs(ctxt, schema, wild, node);\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-        annot = xmlSchemaParseAnnotation(ctxt, child, 1);\n-        child = child->next;\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child,\n-        NULL, \"(annotation?)\");\n-    }\n-    \/*\n-    * No component if minOccurs==maxOccurs==0.\n-    *\/\n-    if ((min == 0) && (max == 0)) {\n-    \/* Don't free the wildcard, since it's already on the list. *\/\n-    return (NULL);\n-    }\n-    \/*\n-    * Create the particle.\n-    *\/\n-    particle = xmlSchemaAddParticle(ctxt, node, min, max);\n-    if (particle == NULL)\n-        return (NULL);\n-    particle->annot = annot;\n-    particle->children = (xmlSchemaTreeItemPtr) wild;\n-\n-    return (particle);\n-}\n-\n-\/**\n- * xmlSchemaParseNotation:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * parse a XML schema Notation declaration\n- *\n- * Returns the new structure or NULL in case of error\n- *\/\n-static xmlSchemaNotationPtr\n-xmlSchemaParseNotation(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                       xmlNodePtr node)\n-{\n-    const xmlChar *name;\n-    xmlSchemaNotationPtr ret;\n-    xmlNodePtr child = NULL;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-    name = xmlSchemaGetProp(ctxt, node, \"name\");\n-    if (name == NULL) {\n-        xmlSchemaPErr2(ctxt, node, child, XML_SCHEMAP_NOTATION_NO_NAME,\n-                       \"Notation has no name\\n\", NULL, NULL);\n-        return (NULL);\n-    }\n-    ret = xmlSchemaAddNotation(ctxt, schema, name,\n-    ctxt->targetNamespace, node);\n-    if (ret == NULL)\n-        return (NULL);\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-        ret->annot = xmlSchemaParseAnnotation(ctxt, child, 1);\n-        child = child->next;\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child,\n-        NULL, \"(annotation?)\");\n-    }\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaParseAnyAttribute:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * parse a XML schema AnyAttribute declaration\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns a wildcard or NULL.\n- *\/\n-static xmlSchemaWildcardPtr\n-xmlSchemaParseAnyAttribute(xmlSchemaParserCtxtPtr ctxt,\n-                           xmlSchemaPtr schema, xmlNodePtr node)\n-{\n-    xmlSchemaWildcardPtr ret;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-\n-    ret = xmlSchemaAddWildcard(ctxt, schema, XML_SCHEMA_TYPE_ANY_ATTRIBUTE,\n-    node);\n-    if (ret == NULL) {\n-        return (NULL);\n-    }\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-            (!xmlStrEqual(attr->name, BAD_CAST \"namespace\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"processContents\"))) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-    \/*\n-    * Parse the namespace list.\n-    *\/\n-    if (xmlSchemaParseWildcardNs(ctxt, schema, ret, node) != 0)\n-    return (NULL);\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-        ret->annot = xmlSchemaParseAnnotation(ctxt, child, 1);\n-        child = child->next;\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child,\n-        NULL, \"(annotation?)\");\n-    }\n-\n-    return (ret);\n-}\n-\n-\n-\/**\n- * xmlSchemaParseAttribute:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * parse a XML schema Attribute declaration\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the attribute declaration.\n- *\/\n-static xmlSchemaBasicItemPtr\n-xmlSchemaParseLocalAttribute(xmlSchemaParserCtxtPtr pctxt,\n-                 xmlSchemaPtr schema,\n-                 xmlNodePtr node,\n-                 xmlSchemaItemListPtr uses,\n-                 int parentType)\n-{\n-    const xmlChar *attrValue, *name = NULL, *ns = NULL;\n-    xmlSchemaAttributeUsePtr use = NULL;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-    const xmlChar *tmpNs = NULL, *tmpName = NULL, *defValue = NULL;\n-    int isRef = 0, occurs = XML_SCHEMAS_ATTR_USE_OPTIONAL;\n-    int    nberrors, hasForm = 0, defValueType = 0;\n-\n-#define WXS_ATTR_DEF_VAL_DEFAULT 1\n-#define WXS_ATTR_DEF_VAL_FIXED 2\n-\n-    \/*\n-     * 3.2.3 Constraints on XML Representations of Attribute Declarations\n-     *\/\n-\n-    if ((pctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-    attr = xmlSchemaGetPropNode(node, \"ref\");\n-    if (attr != NULL) {\n-    if (xmlSchemaPValAttrNodeQName(pctxt, schema,\n-        NULL, attr, &tmpNs, &tmpName) != 0) {\n-        return (NULL);\n-    }\n-    if (xmlSchemaCheckReference(pctxt, schema, node, attr, tmpNs) != 0)\n-        return(NULL);\n-    isRef = 1;\n-    }\n-    nberrors = pctxt->nberrors;\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if (isRef) {\n-        if (xmlStrEqual(attr->name, BAD_CAST \"id\")) {\n-            xmlSchemaPValAttrNodeID(pctxt, attr);\n-            goto attr_next;\n-        } else if (xmlStrEqual(attr->name, BAD_CAST \"ref\")) {\n-            goto attr_next;\n-        }\n-        } else {\n-        if (xmlStrEqual(attr->name, BAD_CAST \"name\")) {\n-            goto attr_next;\n-        } else if (xmlStrEqual(attr->name, BAD_CAST \"id\")) {\n-            xmlSchemaPValAttrNodeID(pctxt, attr);\n-            goto attr_next;\n-        } else if (xmlStrEqual(attr->name, BAD_CAST \"type\")) {\n-            xmlSchemaPValAttrNodeQName(pctxt, schema, NULL,\n-            attr, &tmpNs, &tmpName);\n-            goto attr_next;\n-        } else if (xmlStrEqual(attr->name, BAD_CAST \"form\")) {\n-            \/*\n-            * Evaluate the target namespace\n-            *\/\n-            hasForm = 1;\n-            attrValue = xmlSchemaGetNodeContent(pctxt,\n-            (xmlNodePtr) attr);\n-            if (xmlStrEqual(attrValue, BAD_CAST \"qualified\")) {\n-            ns = pctxt->targetNamespace;\n-            } else if (!xmlStrEqual(attrValue, BAD_CAST \"unqualified\"))\n-            {\n-            xmlSchemaPSimpleTypeErr(pctxt,\n-                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-                NULL, (xmlNodePtr) attr,\n-                NULL, \"(qualified | unqualified)\",\n-                attrValue, NULL, NULL, NULL);\n-            }\n-            goto attr_next;\n-        }\n-        }\n-        if (xmlStrEqual(attr->name, BAD_CAST \"use\")) {\n-\n-        attrValue = xmlSchemaGetNodeContent(pctxt, (xmlNodePtr) attr);\n-        \/* TODO: Maybe we need to normalize the value beforehand. *\/\n-        if (xmlStrEqual(attrValue, BAD_CAST \"optional\"))\n-            occurs = XML_SCHEMAS_ATTR_USE_OPTIONAL;\n-        else if (xmlStrEqual(attrValue, BAD_CAST \"prohibited\"))\n-            occurs = XML_SCHEMAS_ATTR_USE_PROHIBITED;\n-        else if (xmlStrEqual(attrValue, BAD_CAST \"required\"))\n-            occurs = XML_SCHEMAS_ATTR_USE_REQUIRED;\n-        else {\n-            xmlSchemaPSimpleTypeErr(pctxt,\n-            XML_SCHEMAP_INVALID_ATTR_USE,\n-            NULL, (xmlNodePtr) attr,\n-            NULL, \"(optional | prohibited | required)\",\n-            attrValue, NULL, NULL, NULL);\n-        }\n-        goto attr_next;\n-        } else if (xmlStrEqual(attr->name, BAD_CAST \"default\")) {\n-        \/*\n-        * 3.2.3 : 1\n-        * default and fixed must not both be present.\n-        *\/\n-        if (defValue) {\n-            xmlSchemaPMutualExclAttrErr(pctxt,\n-            XML_SCHEMAP_SRC_ATTRIBUTE_1,\n-            NULL, attr, \"default\", \"fixed\");\n-        } else {\n-            defValue = xmlSchemaGetNodeContent(pctxt, (xmlNodePtr) attr);\n-            defValueType = WXS_ATTR_DEF_VAL_DEFAULT;\n-        }\n-        goto attr_next;\n-        } else if (xmlStrEqual(attr->name, BAD_CAST \"fixed\")) {\n-        \/*\n-        * 3.2.3 : 1\n-        * default and fixed must not both be present.\n-        *\/\n-        if (defValue) {\n-            xmlSchemaPMutualExclAttrErr(pctxt,\n-            XML_SCHEMAP_SRC_ATTRIBUTE_1,\n-            NULL, attr, \"default\", \"fixed\");\n-        } else {\n-            defValue = xmlSchemaGetNodeContent(pctxt, (xmlNodePtr) attr);\n-            defValueType = WXS_ATTR_DEF_VAL_FIXED;\n-        }\n-        goto attr_next;\n-        }\n-    } else if (! xmlStrEqual(attr->ns->href, xmlSchemaNs))\n-        goto attr_next;\n-\n-    xmlSchemaPIllegalAttrErr(pctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-\n-attr_next:\n-    attr = attr->next;\n-    }\n-    \/*\n-    * 3.2.3 : 2\n-    * If default and use are both present, use must have\n-    * the actual value optional.\n-    *\/\n-    if ((defValueType == WXS_ATTR_DEF_VAL_DEFAULT) &&\n-    (occurs != XML_SCHEMAS_ATTR_USE_OPTIONAL)) {\n-    xmlSchemaPSimpleTypeErr(pctxt,\n-        XML_SCHEMAP_SRC_ATTRIBUTE_2,\n-        NULL, node, NULL,\n-        \"(optional | prohibited | required)\", NULL,\n-        \"The value of the attribute 'use' must be 'optional' \"\n-        \"if the attribute 'default' is present\",\n-        NULL, NULL);\n-    }\n-    \/*\n-    * We want correct attributes.\n-    *\/\n-    if (nberrors != pctxt->nberrors)\n-    return(NULL);\n-    if (! isRef) {\n-    xmlSchemaAttributePtr attrDecl;\n-\n-    \/* TODO: move XML_SCHEMAS_QUALIF_ATTR to the parser. *\/\n-    if ((! hasForm) && (schema->flags & XML_SCHEMAS_QUALIF_ATTR))\n-        ns = pctxt->targetNamespace;\n-    \/*\n-    * 3.2.6 Schema Component Constraint: xsi: Not Allowed\n-    * TODO: Move this to the component layer.\n-    *\/\n-    if (xmlStrEqual(ns, xmlSchemaInstanceNs)) {\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_NO_XSI,\n-        node, NULL,\n-        \"The target namespace must not match '%s'\",\n-        xmlSchemaInstanceNs, NULL);\n-    }\n-    attr = xmlSchemaGetPropNode(node, \"name\");\n-    if (attr == NULL) {\n-        xmlSchemaPMissingAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_MISSING,\n-        NULL, node, \"name\", NULL);\n-        return (NULL);\n-    }\n-    if (xmlSchemaPValAttrNode(pctxt, NULL, attr,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {\n-        return (NULL);\n-    }\n-    \/*\n-    * 3.2.6 Schema Component Constraint: xmlns Not Allowed\n-    * TODO: Move this to the component layer.\n-    *\/\n-    if (xmlStrEqual(name, BAD_CAST \"xmlns\")) {\n-        xmlSchemaPSimpleTypeErr(pctxt,\n-        XML_SCHEMAP_NO_XMLNS,\n-        NULL, (xmlNodePtr) attr,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), NULL, NULL,\n-        \"The value of the attribute must not match 'xmlns'\",\n-        NULL, NULL);\n-        return (NULL);\n-    }\n-    if (occurs == XML_SCHEMAS_ATTR_USE_PROHIBITED)\n-        goto check_children;\n-    \/*\n-    * Create the attribute use component.\n-    *\/\n-    use = xmlSchemaAddAttributeUse(pctxt, node);\n-    if (use == NULL)\n-        return(NULL);\n-    use->occurs = occurs;\n-    \/*\n-    * Create the attribute declaration.\n-    *\/\n-    attrDecl = xmlSchemaAddAttribute(pctxt, schema, name, ns, node, 0);\n-    if (attrDecl == NULL)\n-        return (NULL);\n-    if (tmpName != NULL) {\n-        attrDecl->typeName = tmpName;\n-        attrDecl->typeNs = tmpNs;\n-    }\n-    use->attrDecl = attrDecl;\n-    \/*\n-    * Value constraint.\n-    *\/\n-    if (defValue != NULL) {\n-        attrDecl->defValue = defValue;\n-        if (defValueType == WXS_ATTR_DEF_VAL_FIXED)\n-        attrDecl->flags |= XML_SCHEMAS_ATTR_FIXED;\n-    }\n-    } else if (occurs != XML_SCHEMAS_ATTR_USE_PROHIBITED) {\n-    xmlSchemaQNameRefPtr ref;\n-\n-    \/*\n-    * Create the attribute use component.\n-    *\/\n-    use = xmlSchemaAddAttributeUse(pctxt, node);\n-    if (use == NULL)\n-        return(NULL);\n-    \/*\n-    * We need to resolve the reference at later stage.\n-    *\/\n-    WXS_ADD_PENDING(pctxt, use);\n-    use->occurs = occurs;\n-    \/*\n-    * Create a QName reference to the attribute declaration.\n-    *\/\n-    ref = xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTE,\n-        tmpName, tmpNs);\n-    if (ref == NULL)\n-        return(NULL);\n-    \/*\n-    * Assign the reference. This will be substituted for the\n-    * referenced attribute declaration when the QName is resolved.\n-    *\/\n-    use->attrDecl = WXS_ATTR_CAST ref;\n-    \/*\n-    * Value constraint.\n-    *\/\n-    if (defValue != NULL)\n-        use->defValue = defValue;\n-    if (defValueType == WXS_ATTR_DEF_VAL_FIXED)\n-        use->flags |= XML_SCHEMA_ATTR_USE_FIXED;\n-    }\n-\n-check_children:\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (occurs == XML_SCHEMAS_ATTR_USE_PROHIBITED) {\n-    xmlSchemaAttributeUseProhibPtr prohib;\n-\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-        xmlSchemaParseAnnotation(pctxt, child, 0);\n-        child = child->next;\n-    }\n-    if (child != NULL) {\n-        xmlSchemaPContentErr(pctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?)\");\n-    }\n-    \/*\n-    * Check for pointlessness of attribute prohibitions.\n-    *\/\n-    if (parentType == XML_SCHEMA_TYPE_ATTRIBUTEGROUP) {\n-        xmlSchemaCustomWarning(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,\n-        node, NULL,\n-        \"Skipping attribute use prohibition, since it is \"\n-        \"pointless inside an <attributeGroup>\",\n-        NULL, NULL, NULL);\n-        return(NULL);\n-    } else if (parentType == XML_SCHEMA_TYPE_EXTENSION) {\n-        xmlSchemaCustomWarning(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,\n-        node, NULL,\n-        \"Skipping attribute use prohibition, since it is \"\n-        \"pointless when extending a type\",\n-        NULL, NULL, NULL);\n-        return(NULL);\n-    }\n-    if (! isRef) {\n-        tmpName = name;\n-        tmpNs = ns;\n-    }\n-    \/*\n-    * Check for duplicate attribute prohibitions.\n-    *\/\n-    if (uses) {\n-        int i;\n-\n-        for (i = 0; i < uses->nbItems; i++) {\n-        use = uses->items[i];\n-        if ((use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) &&\n-            (tmpName == (WXS_ATTR_PROHIB_CAST use)->name) &&\n-            (tmpNs == (WXS_ATTR_PROHIB_CAST use)->targetNamespace))\n-        {\n-            xmlChar *str = NULL;\n-\n-            xmlSchemaCustomWarning(ACTXT_CAST pctxt,\n-            XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,\n-            node, NULL,\n-            \"Skipping duplicate attribute use prohibition '%s'\",\n-            xmlSchemaFormatQName(&str, tmpNs, tmpName),\n-            NULL, NULL);\n-            FREE_AND_NULL(str)\n-            return(NULL);\n-        }\n-        }\n-    }\n-    \/*\n-    * Create the attribute prohibition helper component.\n-    *\/\n-    prohib = xmlSchemaAddAttributeUseProhib(pctxt);\n-    if (prohib == NULL)\n-        return(NULL);\n-    prohib->node = node;\n-    prohib->name = tmpName;\n-    prohib->targetNamespace = tmpNs;\n-    if (isRef) {\n-        \/*\n-        * We need at least to resolve to the attribute declaration.\n-        *\/\n-        WXS_ADD_PENDING(pctxt, prohib);\n-    }\n-    return(WXS_BASIC_CAST prohib);\n-    } else {\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-        \/*\n-        * TODO: Should this go into the attr decl?\n-        *\/\n-        use->annot = xmlSchemaParseAnnotation(pctxt, child, 1);\n-        child = child->next;\n-    }\n-    if (isRef) {\n-        if (child != NULL) {\n-        if (IS_SCHEMA(child, \"simpleType\"))\n-            \/*\n-            * 3.2.3 : 3.2\n-            * If ref is present, then all of <simpleType>,\n-            * form and type must be absent.\n-            *\/\n-            xmlSchemaPContentErr(pctxt,\n-            XML_SCHEMAP_SRC_ATTRIBUTE_3_2,\n-            NULL, node, child, NULL,\n-            \"(annotation?)\");\n-        else\n-            xmlSchemaPContentErr(pctxt,\n-            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-            NULL, node, child, NULL,\n-            \"(annotation?)\");\n-        }\n-    } else {\n-        if (IS_SCHEMA(child, \"simpleType\")) {\n-        if (WXS_ATTRUSE_DECL(use)->typeName != NULL) {\n-            \/*\n-            * 3.2.3 : 4\n-            * type and <simpleType> must not both be present.\n-            *\/\n-            xmlSchemaPContentErr(pctxt, XML_SCHEMAP_SRC_ATTRIBUTE_4,\n-            NULL, node, child,\n-            \"The attribute 'type' and the <simpleType> child \"\n-            \"are mutually exclusive\", NULL);\n-        } else\n-            WXS_ATTRUSE_TYPEDEF(use) =\n-            xmlSchemaParseSimpleType(pctxt, schema, child, 0);\n-        child = child->next;\n-        }\n-        if (child != NULL)\n-        xmlSchemaPContentErr(pctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?, simpleType?)\");\n-    }\n-    }\n-    return (WXS_BASIC_CAST use);\n-}\n-\n-\n-static xmlSchemaAttributePtr\n-xmlSchemaParseGlobalAttribute(xmlSchemaParserCtxtPtr pctxt,\n-                  xmlSchemaPtr schema,\n-                  xmlNodePtr node)\n-{\n-    const xmlChar *attrValue;\n-    xmlSchemaAttributePtr ret;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-\n-    \/*\n-     * Note that the w3c spec assumes the schema to be validated with schema\n-     * for schemas beforehand.\n-     *\n-     * 3.2.3 Constraints on XML Representations of Attribute Declarations\n-     *\/\n-    if ((pctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-    \/*\n-    * 3.2.3 : 3.1\n-    * One of ref or name must be present, but not both\n-    *\/\n-    attr = xmlSchemaGetPropNode(node, \"name\");\n-    if (attr == NULL) {\n-    xmlSchemaPMissingAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_MISSING,\n-        NULL, node, \"name\", NULL);\n-    return (NULL);\n-    }\n-    if (xmlSchemaPValAttrNode(pctxt, NULL, attr,\n-    xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &attrValue) != 0) {\n-    return (NULL);\n-    }\n-    \/*\n-    * 3.2.6 Schema Component Constraint: xmlns Not Allowed\n-    * TODO: Move this to the component layer.\n-    *\/\n-    if (xmlStrEqual(attrValue, BAD_CAST \"xmlns\")) {\n-    xmlSchemaPSimpleTypeErr(pctxt,\n-        XML_SCHEMAP_NO_XMLNS,\n-        NULL, (xmlNodePtr) attr,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), NULL, NULL,\n-        \"The value of the attribute must not match 'xmlns'\",\n-        NULL, NULL);\n-    return (NULL);\n-    }\n-    \/*\n-    * 3.2.6 Schema Component Constraint: xsi: Not Allowed\n-    * TODO: Move this to the component layer.\n-    *       Or better leave it here and add it to the component layer\n-    *       if we have a schema construction API.\n-    *\/\n-    if (xmlStrEqual(pctxt->targetNamespace, xmlSchemaInstanceNs)) {\n-    xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_NO_XSI, node, NULL,\n-        \"The target namespace must not match '%s'\",\n-        xmlSchemaInstanceNs, NULL);\n-    }\n-\n-    ret = xmlSchemaAddAttribute(pctxt, schema, attrValue,\n-    pctxt->targetNamespace, node, 1);\n-    if (ret == NULL)\n-    return (NULL);\n-    ret->flags |= XML_SCHEMAS_ATTR_GLOBAL;\n-\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"default\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"fixed\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"name\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"type\")))\n-        {\n-        xmlSchemaPIllegalAttrErr(pctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(pctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    xmlSchemaPValAttrQName(pctxt, schema, NULL,\n-    node, \"type\", &ret->typeNs, &ret->typeName);\n-\n-    xmlSchemaPValAttrID(pctxt, node, BAD_CAST \"id\");\n-    \/*\n-    * Attribute \"fixed\".\n-    *\/\n-    ret->defValue = xmlSchemaGetProp(pctxt, node, \"fixed\");\n-    if (ret->defValue != NULL)\n-    ret->flags |= XML_SCHEMAS_ATTR_FIXED;\n-    \/*\n-    * Attribute \"default\".\n-    *\/\n-    attr = xmlSchemaGetPropNode(node, \"default\");\n-    if (attr != NULL) {\n-    \/*\n-    * 3.2.3 : 1\n-    * default and fixed must not both be present.\n-    *\/\n-    if (ret->flags & XML_SCHEMAS_ATTR_FIXED) {\n-        xmlSchemaPMutualExclAttrErr(pctxt, XML_SCHEMAP_SRC_ATTRIBUTE_1,\n-        WXS_BASIC_CAST ret, attr, \"default\", \"fixed\");\n-    } else\n-        ret->defValue = xmlSchemaGetNodeContent(pctxt, (xmlNodePtr) attr);\n-    }\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-        ret->annot = xmlSchemaParseAnnotation(pctxt, child, 1);\n-        child = child->next;\n-    }\n-    if (IS_SCHEMA(child, \"simpleType\")) {\n-    if (ret->typeName != NULL) {\n-        \/*\n-        * 3.2.3 : 4\n-        * type and <simpleType> must not both be present.\n-        *\/\n-        xmlSchemaPContentErr(pctxt, XML_SCHEMAP_SRC_ATTRIBUTE_4,\n-        NULL, node, child,\n-        \"The attribute 'type' and the <simpleType> child \"\n-        \"are mutually exclusive\", NULL);\n-    } else\n-        ret->subtypes = xmlSchemaParseSimpleType(pctxt, schema, child, 0);\n-    child = child->next;\n-    }\n-    if (child != NULL)\n-    xmlSchemaPContentErr(pctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?, simpleType?)\");\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaParseAttributeGroupRef:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * Parse an attribute group definition reference.\n- * Note that a reference to an attribute group does not\n- * correspond to any component at all.\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the attribute group or NULL in case of error.\n- *\/\n-static xmlSchemaQNameRefPtr\n-xmlSchemaParseAttributeGroupRef(xmlSchemaParserCtxtPtr pctxt,\n-                xmlSchemaPtr schema,\n-                xmlNodePtr node)\n-{\n-    xmlSchemaQNameRefPtr ret;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-    const xmlChar *refNs = NULL, *ref = NULL;\n-\n-    if ((pctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-\n-    attr = xmlSchemaGetPropNode(node, \"ref\");\n-    if (attr == NULL) {\n-    xmlSchemaPMissingAttrErr(pctxt,\n-        XML_SCHEMAP_S4S_ATTR_MISSING,\n-        NULL, node, \"ref\", NULL);\n-    return (NULL);\n-    }\n-    xmlSchemaPValAttrNodeQName(pctxt, schema,\n-    NULL, attr, &refNs, &ref);\n-    if (xmlSchemaCheckReference(pctxt, schema, node, attr, refNs) != 0)\n-    return(NULL);\n-\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"ref\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"id\")))\n-        {\n-        xmlSchemaPIllegalAttrErr(pctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(pctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    \/* Attribute ID *\/\n-    xmlSchemaPValAttrID(pctxt, node, BAD_CAST \"id\");\n-\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-    \/*\n-    * TODO: We do not have a place to store the annotation, do we?\n-    *\/\n-        xmlSchemaParseAnnotation(pctxt, child, 0);\n-        child = child->next;\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(pctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?)\");\n-    }\n-\n-    \/*\n-    * Handle attribute group redefinitions.\n-    *\/\n-    if (pctxt->isRedefine && pctxt->redef &&\n-    (pctxt->redef->item->type ==\n-        XML_SCHEMA_TYPE_ATTRIBUTEGROUP) &&\n-    (ref == pctxt->redef->refName) &&\n-    (refNs == pctxt->redef->refTargetNs))\n-    {\n-    \/*\n-    * SPEC src-redefine:\n-    * (7.1) \"If it has an <attributeGroup> among its contents\n-    * the `actual value` of whose ref [attribute] is the same\n-    * as the `actual value` of its own name attribute plus\n-    * target namespace, then it must have exactly one such group.\"\n-    *\/\n-    if (pctxt->redefCounter != 0) {\n-        xmlChar *str = NULL;\n-\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_SRC_REDEFINE, node, NULL,\n-        \"The redefining attribute group definition \"\n-        \"'%s' must not contain more than one \"\n-        \"reference to the redefined definition\",\n-        xmlSchemaFormatQName(&str, refNs, ref), NULL);\n-        FREE_AND_NULL(str);\n-        return(NULL);\n-    }\n-    pctxt->redefCounter++;\n-    \/*\n-    * URGENT TODO: How to ensure that the reference will not be\n-    * handled by the normal component resolution mechanism?\n-    *\/\n-    ret = xmlSchemaNewQNameRef(pctxt,\n-        XML_SCHEMA_TYPE_ATTRIBUTEGROUP, ref, refNs);\n-    if (ret == NULL)\n-        return(NULL);\n-    ret->node = node;\n-    pctxt->redef->reference = WXS_BASIC_CAST ret;\n-    } else {\n-    \/*\n-    * Create a QName-reference helper component. We will substitute this\n-    * component for the attribute uses of the referenced attribute group\n-    * definition.\n-    *\/\n-    ret = xmlSchemaNewQNameRef(pctxt,\n-        XML_SCHEMA_TYPE_ATTRIBUTEGROUP, ref, refNs);\n-    if (ret == NULL)\n-        return(NULL);\n-    ret->node = node;\n-    \/* Add to pending items, to be able to resolve the reference. *\/\n-    WXS_ADD_PENDING(pctxt, ret);\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaParseAttributeGroupDefinition:\n- * @pctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * parse a XML schema Attribute Group declaration\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the attribute group definition or NULL in case of error.\n- *\/\n-static xmlSchemaAttributeGroupPtr\n-xmlSchemaParseAttributeGroupDefinition(xmlSchemaParserCtxtPtr pctxt,\n-                       xmlSchemaPtr schema,\n-                       xmlNodePtr node)\n-{\n-    const xmlChar *name;\n-    xmlSchemaAttributeGroupPtr ret;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-    int hasRefs = 0;\n-\n-    if ((pctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-\n-    attr = xmlSchemaGetPropNode(node, \"name\");\n-    if (attr == NULL) {\n-    xmlSchemaPMissingAttrErr(pctxt,\n-        XML_SCHEMAP_S4S_ATTR_MISSING,\n-        NULL, node, \"name\", NULL);\n-    return (NULL);\n-    }\n-    \/*\n-    * The name is crucial, exit if invalid.\n-    *\/\n-    if (xmlSchemaPValAttrNode(pctxt,\n-    NULL, attr,\n-    xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {\n-    return (NULL);\n-    }\n-    ret = xmlSchemaAddAttributeGroupDefinition(pctxt, schema,\n-    name, pctxt->targetNamespace, node);\n-    if (ret == NULL)\n-    return (NULL);\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"name\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"id\")))\n-        {\n-        xmlSchemaPIllegalAttrErr(pctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(pctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    \/* Attribute ID *\/\n-    xmlSchemaPValAttrID(pctxt, node, BAD_CAST \"id\");\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-        ret->annot = xmlSchemaParseAnnotation(pctxt, child, 1);\n-        child = child->next;\n-    }\n-    \/*\n-    * Parse contained attribute decls\/refs.\n-    *\/\n-    if (xmlSchemaParseLocalAttributes(pctxt, schema, &child,\n-    (xmlSchemaItemListPtr *) &(ret->attrUses),\n-    XML_SCHEMA_TYPE_ATTRIBUTEGROUP, &hasRefs) == -1)\n-    return(NULL);\n-    if (hasRefs)\n-    ret->flags |= XML_SCHEMAS_ATTRGROUP_HAS_REFS;\n-    \/*\n-    * Parse the attribute wildcard.\n-    *\/\n-    if (IS_SCHEMA(child, \"anyAttribute\")) {\n-    ret->attributeWildcard = xmlSchemaParseAnyAttribute(pctxt,\n-        schema, child);\n-    child = child->next;\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(pctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?, ((attribute | attributeGroup)*, anyAttribute?))\");\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaPValAttrFormDefault:\n- * @value:  the value\n- * @flags: the flags to be modified\n- * @flagQualified: the specific flag for \"qualified\"\n- *\n- * Returns 0 if the value is valid, 1 otherwise.\n- *\/\n-static int\n-xmlSchemaPValAttrFormDefault(const xmlChar *value,\n-                 int *flags,\n-                 int flagQualified)\n-{\n-    if (xmlStrEqual(value, BAD_CAST \"qualified\")) {\n-    if  ((*flags & flagQualified) == 0)\n-        *flags |= flagQualified;\n-    } else if (!xmlStrEqual(value, BAD_CAST \"unqualified\"))\n-    return (1);\n-\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaPValAttrBlockFinal:\n- * @value:  the value\n- * @flags: the flags to be modified\n- * @flagAll: the specific flag for \"#all\"\n- * @flagExtension: the specific flag for \"extension\"\n- * @flagRestriction: the specific flag for \"restriction\"\n- * @flagSubstitution: the specific flag for \"substitution\"\n- * @flagList: the specific flag for \"list\"\n- * @flagUnion: the specific flag for \"union\"\n- *\n- * Validates the value of the attribute \"final\" and \"block\". The value\n- * is converted into the specified flag values and returned in @flags.\n- *\n- * Returns 0 if the value is valid, 1 otherwise.\n- *\/\n-\n-static int\n-xmlSchemaPValAttrBlockFinal(const xmlChar *value,\n-                int *flags,\n-                int flagAll,\n-                int flagExtension,\n-                int flagRestriction,\n-                int flagSubstitution,\n-                int flagList,\n-                int flagUnion)\n-{\n-    int ret = 0;\n-\n-    \/*\n-    * TODO: This does not check for duplicate entries.\n-    *\/\n-    if ((flags == NULL) || (value == NULL))\n-    return (-1);\n-    if (value[0] == 0)\n-    return (0);\n-    if (xmlStrEqual(value, BAD_CAST \"#all\")) {\n-    if (flagAll != -1)\n-        *flags |= flagAll;\n-    else {\n-        if (flagExtension != -1)\n-        *flags |= flagExtension;\n-        if (flagRestriction != -1)\n-        *flags |= flagRestriction;\n-        if (flagSubstitution != -1)\n-        *flags |= flagSubstitution;\n-        if (flagList != -1)\n-        *flags |= flagList;\n-        if (flagUnion != -1)\n-        *flags |= flagUnion;\n-    }\n-    } else {\n-    const xmlChar *end, *cur = value;\n-    xmlChar *item;\n-\n-    do {\n-        while (IS_BLANK_CH(*cur))\n-        cur++;\n-        end = cur;\n-        while ((*end != 0) && (!(IS_BLANK_CH(*end))))\n-        end++;\n-        if (end == cur)\n-        break;\n-        item = xmlStrndup(cur, end - cur);\n-        if (xmlStrEqual(item, BAD_CAST \"extension\")) {\n-        if (flagExtension != -1) {\n-            if ((*flags & flagExtension) == 0)\n-            *flags |= flagExtension;\n-        } else\n-            ret = 1;\n-        } else if (xmlStrEqual(item, BAD_CAST \"restriction\")) {\n-        if (flagRestriction != -1) {\n-            if ((*flags & flagRestriction) == 0)\n-            *flags |= flagRestriction;\n-        } else\n-            ret = 1;\n-        } else if (xmlStrEqual(item, BAD_CAST \"substitution\")) {\n-        if (flagSubstitution != -1) {\n-            if ((*flags & flagSubstitution) == 0)\n-            *flags |= flagSubstitution;\n-        } else\n-            ret = 1;\n-        } else if (xmlStrEqual(item, BAD_CAST \"list\")) {\n-        if (flagList != -1) {\n-            if ((*flags & flagList) == 0)\n-            *flags |= flagList;\n-        } else\n-            ret = 1;\n-        } else if (xmlStrEqual(item, BAD_CAST \"union\")) {\n-        if (flagUnion != -1) {\n-            if ((*flags & flagUnion) == 0)\n-            *flags |= flagUnion;\n-        } else\n-            ret = 1;\n-        } else\n-        ret = 1;\n-        if (item != NULL)\n-        xmlFree(item);\n-        cur = end;\n-    } while ((ret == 0) && (*cur != 0));\n-    }\n-\n-    return (ret);\n-}\n-\n-static int\n-xmlSchemaCheckCSelectorXPath(xmlSchemaParserCtxtPtr ctxt,\n-                 xmlSchemaIDCPtr idc,\n-                 xmlSchemaIDCSelectPtr selector,\n-                 xmlAttrPtr attr,\n-                 int isField)\n-{\n-    xmlNodePtr node;\n-\n-    \/*\n-    * c-selector-xpath:\n-    * Schema Component Constraint: Selector Value OK\n-    *\n-    * TODO: 1 The {selector} must be a valid XPath expression, as defined\n-    * in [XPath].\n-    *\/\n-    if (selector == NULL) {\n-    xmlSchemaPErr(ctxt, idc->node,\n-        XML_SCHEMAP_INTERNAL,\n-        \"Internal error: xmlSchemaCheckCSelectorXPath, \"\n-        \"the selector is not specified.\\n\", NULL, NULL);\n-    return (-1);\n-    }\n-    if (attr == NULL)\n-    node = idc->node;\n-    else\n-    node = (xmlNodePtr) attr;\n-    if (selector->xpath == NULL) {\n-    xmlSchemaPCustomErr(ctxt,\n-        \/* TODO: Adjust error code. *\/\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        NULL, node,\n-        \"The XPath expression of the selector is not valid\", NULL);\n-    return (XML_SCHEMAP_S4S_ATTR_INVALID_VALUE);\n-    } else {\n-    const xmlChar **nsArray = NULL;\n-    xmlNsPtr *nsList = NULL;\n-    \/*\n-    * Compile the XPath expression.\n-    *\/\n-    \/*\n-    * TODO: We need the array of in-scope namespaces for compilation.\n-    * TODO: Call xmlPatterncompile with different options for selector\/\n-    * field.\n-    *\/\n-    if (attr == NULL)\n-        nsList = NULL;\n-    else\n-        nsList = xmlGetNsList(attr->doc, attr->parent);\n-    \/*\n-    * Build an array of prefixes and namespaces.\n-    *\/\n-    if (nsList != NULL) {\n-        int i, count = 0;\n-\n-        for (i = 0; nsList[i] != NULL; i++)\n-        count++;\n-\n-        nsArray = (const xmlChar **) xmlMalloc(\n-        (count * 2 + 1) * sizeof(const xmlChar *));\n-        if (nsArray == NULL) {\n-        xmlSchemaPErrMemory(ctxt);\n-        xmlFree(nsList);\n-        return (-1);\n-        }\n-        for (i = 0; i < count; i++) {\n-        nsArray[2 * i] = nsList[i]->href;\n-        nsArray[2 * i + 1] = nsList[i]->prefix;\n-        }\n-        nsArray[count * 2] = NULL;\n-        xmlFree(nsList);\n-    }\n-    \/*\n-    * TODO: Differentiate between \"selector\" and \"field\".\n-    *\/\n-    if (isField)\n-        selector->xpathComp = (void *) xmlPatterncompile(selector->xpath,\n-        NULL, XML_PATTERN_XSFIELD, nsArray);\n-    else\n-        selector->xpathComp = (void *) xmlPatterncompile(selector->xpath,\n-        NULL, XML_PATTERN_XSSEL, nsArray);\n-    if (nsArray != NULL)\n-        xmlFree((xmlChar **) nsArray);\n-\n-    if (selector->xpathComp == NULL) {\n-        xmlSchemaPCustomErr(ctxt,\n-        \/* TODO: Adjust error code? *\/\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        NULL, node,\n-        \"The XPath expression '%s' could not be \"\n-        \"compiled\", selector->xpath);\n-        return (XML_SCHEMAP_S4S_ATTR_INVALID_VALUE);\n-    }\n-    }\n-    return (0);\n-}\n-\n-#define ADD_ANNOTATION(annot)   \\\n-    xmlSchemaAnnotPtr cur = item->annot; \\\n-    if (item->annot == NULL) {  \\\n-    item->annot = annot;    \\\n-    return (annot);         \\\n-    }                           \\\n-    cur = item->annot;          \\\n-    while (cur->next != NULL) { \\\n-    cur = cur->next;    \\\n-    }                           \\\n-    cur->next = annot;\n-\n-\/**\n- * xmlSchemaAssignAnnotation:\n- * @item: the schema component\n- * @annot: the annotation\n- *\n- * Adds the annotation to the given schema component.\n- *\n- * Returns the given annotation.\n- *\/\n-static xmlSchemaAnnotPtr\n-xmlSchemaAddAnnotation(xmlSchemaAnnotItemPtr annItem,\n-               xmlSchemaAnnotPtr annot)\n-{\n-    if ((annItem == NULL) || (annot == NULL))\n-    return (NULL);\n-    switch (annItem->type) {\n-    case XML_SCHEMA_TYPE_ELEMENT: {\n-        xmlSchemaElementPtr item = (xmlSchemaElementPtr) annItem;\n-        ADD_ANNOTATION(annot)\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_ATTRIBUTE: {\n-        xmlSchemaAttributePtr item = (xmlSchemaAttributePtr) annItem;\n-        ADD_ANNOTATION(annot)\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_ANY_ATTRIBUTE:\n-    case XML_SCHEMA_TYPE_ANY: {\n-        xmlSchemaWildcardPtr item = (xmlSchemaWildcardPtr) annItem;\n-        ADD_ANNOTATION(annot)\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_PARTICLE:\n-    case XML_SCHEMA_TYPE_IDC_KEY:\n-    case XML_SCHEMA_TYPE_IDC_KEYREF:\n-    case XML_SCHEMA_TYPE_IDC_UNIQUE: {\n-        xmlSchemaAnnotItemPtr item = (xmlSchemaAnnotItemPtr) annItem;\n-        ADD_ANNOTATION(annot)\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP: {\n-        xmlSchemaAttributeGroupPtr item =\n-            (xmlSchemaAttributeGroupPtr) annItem;\n-        ADD_ANNOTATION(annot)\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_NOTATION: {\n-        xmlSchemaNotationPtr item = (xmlSchemaNotationPtr) annItem;\n-        ADD_ANNOTATION(annot)\n-        }\n-        break;\n-    case XML_SCHEMA_FACET_MININCLUSIVE:\n-    case XML_SCHEMA_FACET_MINEXCLUSIVE:\n-    case XML_SCHEMA_FACET_MAXINCLUSIVE:\n-    case XML_SCHEMA_FACET_MAXEXCLUSIVE:\n-    case XML_SCHEMA_FACET_TOTALDIGITS:\n-    case XML_SCHEMA_FACET_FRACTIONDIGITS:\n-    case XML_SCHEMA_FACET_PATTERN:\n-    case XML_SCHEMA_FACET_ENUMERATION:\n-    case XML_SCHEMA_FACET_WHITESPACE:\n-    case XML_SCHEMA_FACET_LENGTH:\n-    case XML_SCHEMA_FACET_MAXLENGTH:\n-    case XML_SCHEMA_FACET_MINLENGTH: {\n-        xmlSchemaFacetPtr item = (xmlSchemaFacetPtr) annItem;\n-        ADD_ANNOTATION(annot)\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_SIMPLE:\n-    case XML_SCHEMA_TYPE_COMPLEX: {\n-        xmlSchemaTypePtr item = (xmlSchemaTypePtr) annItem;\n-        ADD_ANNOTATION(annot)\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_GROUP: {\n-        xmlSchemaModelGroupDefPtr item = (xmlSchemaModelGroupDefPtr) annItem;\n-        ADD_ANNOTATION(annot)\n-        }\n-        break;\n-    case XML_SCHEMA_TYPE_SEQUENCE:\n-    case XML_SCHEMA_TYPE_CHOICE:\n-    case XML_SCHEMA_TYPE_ALL: {\n-        xmlSchemaModelGroupPtr item = (xmlSchemaModelGroupPtr) annItem;\n-        ADD_ANNOTATION(annot)\n-        }\n-        break;\n-    default:\n-         xmlSchemaPCustomErr(NULL,\n-        XML_SCHEMAP_INTERNAL,\n-        NULL, NULL,\n-        \"Internal error: xmlSchemaAddAnnotation, \"\n-        \"The item is not a annotated schema component\", NULL);\n-         break;\n-    }\n-    return (annot);\n-}\n-\n-\/**\n- * xmlSchemaParseIDCSelectorAndField:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * Parses a XML Schema identity-constraint definition's\n- * <selector> and <field> elements.\n- *\n- * Returns the parsed identity-constraint definition.\n- *\/\n-static xmlSchemaIDCSelectPtr\n-xmlSchemaParseIDCSelectorAndField(xmlSchemaParserCtxtPtr ctxt,\n-              xmlSchemaIDCPtr idc,\n-              xmlNodePtr node,\n-              int isField)\n-{\n-    xmlSchemaIDCSelectPtr item;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"xpath\"))) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    \/*\n-    * Create the item.\n-    *\/\n-    item = (xmlSchemaIDCSelectPtr) xmlMalloc(sizeof(xmlSchemaIDCSelect));\n-    if (item == NULL) {\n-        xmlSchemaPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(item, 0, sizeof(xmlSchemaIDCSelect));\n-    \/*\n-    * Attribute \"xpath\" (mandatory).\n-    *\/\n-    attr = xmlSchemaGetPropNode(node, \"xpath\");\n-    if (attr == NULL) {\n-    xmlSchemaPMissingAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_MISSING,\n-        NULL, node,\n-        \"name\", NULL);\n-    } else {\n-    item->xpath = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-    \/*\n-    * URGENT TODO: \"field\"s have an other syntax than \"selector\"s.\n-    *\/\n-\n-    if (xmlSchemaCheckCSelectorXPath(ctxt, idc, item, attr,\n-        isField) == -1) {\n-        xmlSchemaPErr(ctxt,\n-        (xmlNodePtr) attr,\n-        XML_SCHEMAP_INTERNAL,\n-        \"Internal error: xmlSchemaParseIDCSelectorAndField, \"\n-        \"validating the XPath expression of a IDC selector.\\n\",\n-        NULL, NULL);\n-    }\n-\n-    }\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-    \/*\n-    * Add the annotation to the parent IDC.\n-    *\/\n-    xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) idc,\n-        xmlSchemaParseAnnotation(ctxt, child, 1));\n-    child = child->next;\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child,\n-        NULL, \"(annotation?)\");\n-    }\n-\n-    return (item);\n-}\n-\n-\/**\n- * xmlSchemaParseIDC:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * Parses a XML Schema identity-constraint definition.\n- *\n- * Returns the parsed identity-constraint definition.\n- *\/\n-static xmlSchemaIDCPtr\n-xmlSchemaParseIDC(xmlSchemaParserCtxtPtr ctxt,\n-          xmlSchemaPtr schema,\n-          xmlNodePtr node,\n-          xmlSchemaTypeType idcCategory,\n-          const xmlChar *targetNamespace)\n-{\n-    xmlSchemaIDCPtr item = NULL;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-    const xmlChar *name = NULL;\n-    xmlSchemaIDCSelectPtr field = NULL, lastField = NULL;\n-\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"name\")) &&\n-        ((idcCategory != XML_SCHEMA_TYPE_IDC_KEYREF) ||\n-         (!xmlStrEqual(attr->name, BAD_CAST \"refer\")))) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    \/*\n-    * Attribute \"name\" (mandatory).\n-    *\/\n-    attr = xmlSchemaGetPropNode(node, \"name\");\n-    if (attr == NULL) {\n-    xmlSchemaPMissingAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_MISSING,\n-        NULL, node,\n-        \"name\", NULL);\n-    return (NULL);\n-    } else if (xmlSchemaPValAttrNode(ctxt,\n-    NULL, attr,\n-    xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {\n-    return (NULL);\n-    }\n-    \/* Create the component. *\/\n-    item = xmlSchemaAddIDC(ctxt, schema, name, targetNamespace,\n-    idcCategory, node);\n-    if (item == NULL)\n-    return(NULL);\n-\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-    if (idcCategory == XML_SCHEMA_TYPE_IDC_KEYREF) {\n-    \/*\n-    * Attribute \"refer\" (mandatory).\n-    *\/\n-    attr = xmlSchemaGetPropNode(node, \"refer\");\n-    if (attr == NULL) {\n-        xmlSchemaPMissingAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_MISSING,\n-        NULL, node,\n-        \"refer\", NULL);\n-    } else {\n-        \/*\n-        * Create a reference item.\n-        *\/\n-        item->ref = xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_IDC_KEY,\n-        NULL, NULL);\n-        if (item->ref == NULL)\n-        return (NULL);\n-        xmlSchemaPValAttrNodeQName(ctxt, schema,\n-        NULL, attr,\n-        &(item->ref->targetNamespace),\n-        &(item->ref->name));\n-        xmlSchemaCheckReference(ctxt, schema, node, attr,\n-        item->ref->targetNamespace);\n-    }\n-    }\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-    item->annot = xmlSchemaParseAnnotation(ctxt, child, 1);\n-    child = child->next;\n-    }\n-    if (child == NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_MISSING,\n-        NULL, node, child,\n-        \"A child element is missing\",\n-        \"(annotation?, (selector, field+))\");\n-    }\n-    \/*\n-    * Child element <selector>.\n-    *\/\n-    if (IS_SCHEMA(child, \"selector\")) {\n-    item->selector = xmlSchemaParseIDCSelectorAndField(ctxt,\n-        item, child, 0);\n-    child = child->next;\n-    \/*\n-    * Child elements <field>.\n-    *\/\n-    if (IS_SCHEMA(child, \"field\")) {\n-        do {\n-        field = xmlSchemaParseIDCSelectorAndField(ctxt,\n-            item, child, 1);\n-        if (field != NULL) {\n-            field->index = item->nbFields;\n-            item->nbFields++;\n-            if (lastField != NULL)\n-            lastField->next = field;\n-            else\n-            item->fields = field;\n-            lastField = field;\n-        }\n-        child = child->next;\n-        } while (IS_SCHEMA(child, \"field\"));\n-    } else {\n-        xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child,\n-        NULL, \"(annotation?, (selector, field+))\");\n-    }\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child,\n-        NULL, \"(annotation?, (selector, field+))\");\n-    }\n-\n-    return (item);\n-}\n-\n-\/**\n- * xmlSchemaParseElement:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- * @topLevel: indicates if this is global declaration\n- *\n- * Parses a XML schema element declaration.\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the element declaration or a particle; NULL in case\n- * of an error or if the particle has minOccurs==maxOccurs==0.\n- *\/\n-static xmlSchemaBasicItemPtr\n-xmlSchemaParseElement(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                      xmlNodePtr node, int *isElemRef, int topLevel)\n-{\n-    xmlSchemaElementPtr decl = NULL;\n-    xmlSchemaParticlePtr particle = NULL;\n-    xmlSchemaAnnotPtr annot = NULL;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr, nameAttr;\n-    int min, max, isRef = 0;\n-    xmlChar *des = NULL;\n-\n-    \/* 3.3.3 Constraints on XML Representations of Element Declarations *\/\n-    \/* TODO: Complete implementation of 3.3.6 *\/\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-\n-    if (isElemRef != NULL)\n-    *isElemRef = 0;\n-    \/*\n-    * If we get a \"ref\" attribute on a local <element> we will assume it's\n-    * a reference - even if there's a \"name\" attribute; this seems to be more\n-    * robust.\n-    *\/\n-    nameAttr = xmlSchemaGetPropNode(node, \"name\");\n-    attr = xmlSchemaGetPropNode(node, \"ref\");\n-    if ((topLevel) || (attr == NULL)) {\n-    if (nameAttr == NULL) {\n-        xmlSchemaPMissingAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_MISSING,\n-        NULL, node, \"name\", NULL);\n-        return (NULL);\n-    }\n-    } else\n-    isRef = 1;\n-\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-    annot = xmlSchemaParseAnnotation(ctxt, child, 1);\n-    child = child->next;\n-    }\n-    \/*\n-    * Skip particle part if a global declaration.\n-    *\/\n-    if (topLevel)\n-    goto declaration_part;\n-    \/*\n-    * The particle part ==================================================\n-    *\/\n-    min = xmlGetMinOccurs(ctxt, node, 0, -1, 1, \"xs:nonNegativeInteger\");\n-    max = xmlGetMaxOccurs(ctxt, node, 0, UNBOUNDED, 1, \"(xs:nonNegativeInteger | unbounded)\");\n-    xmlSchemaPCheckParticleCorrect_2(ctxt, NULL, node, min, max);\n-    particle = xmlSchemaAddParticle(ctxt, node, min, max);\n-    if (particle == NULL)\n-    goto return_null;\n-\n-    \/* ret->flags |= XML_SCHEMAS_ELEM_REF; *\/\n-\n-    if (isRef) {\n-    const xmlChar *refNs = NULL, *ref = NULL;\n-    xmlSchemaQNameRefPtr refer = NULL;\n-    \/*\n-    * The reference part =============================================\n-    *\/\n-    if (isElemRef != NULL)\n-        *isElemRef = 1;\n-\n-    xmlSchemaPValAttrNodeQName(ctxt, schema,\n-        NULL, attr, &refNs, &ref);\n-    xmlSchemaCheckReference(ctxt, schema, node, attr, refNs);\n-    \/*\n-    * SPEC (3.3.3 : 2.1) \"One of ref or name must be present, but not both\"\n-    *\/\n-    if (nameAttr != NULL) {\n-        xmlSchemaPMutualExclAttrErr(ctxt,\n-        XML_SCHEMAP_SRC_ELEMENT_2_1, NULL, nameAttr, \"ref\", \"name\");\n-    }\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-        if (attr->ns == NULL) {\n-        if (xmlStrEqual(attr->name, BAD_CAST \"ref\") ||\n-            xmlStrEqual(attr->name, BAD_CAST \"name\") ||\n-            xmlStrEqual(attr->name, BAD_CAST \"id\") ||\n-            xmlStrEqual(attr->name, BAD_CAST \"maxOccurs\") ||\n-            xmlStrEqual(attr->name, BAD_CAST \"minOccurs\"))\n-        {\n-            attr = attr->next;\n-            continue;\n-        } else {\n-            \/* SPEC (3.3.3 : 2.2) *\/\n-            xmlSchemaPCustomAttrErr(ctxt,\n-            XML_SCHEMAP_SRC_ELEMENT_2_2,\n-            NULL, NULL, attr,\n-            \"Only the attributes 'minOccurs', 'maxOccurs' and \"\n-            \"'id' are allowed in addition to 'ref'\");\n-            break;\n-        }\n-        } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-        attr = attr->next;\n-    }\n-    \/*\n-    * No children except <annotation> expected.\n-    *\/\n-    if (child != NULL) {\n-        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL, \"(annotation?)\");\n-    }\n-    if ((min == 0) && (max == 0))\n-        goto return_null;\n-    \/*\n-    * Create the reference item and attach it to the particle.\n-    *\/\n-    refer = xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_ELEMENT,\n-        ref, refNs);\n-    if (refer == NULL)\n-        goto return_null;\n-    particle->children = (xmlSchemaTreeItemPtr) refer;\n-    particle->annot = annot;\n-    \/*\n-    * Add the particle to pending components, since the reference\n-    * need to be resolved.\n-    *\/\n-    WXS_ADD_PENDING(ctxt, particle);\n-    return ((xmlSchemaBasicItemPtr) particle);\n-    }\n-    \/*\n-    * The declaration part ===============================================\n-    *\/\n-declaration_part:\n-    {\n-    const xmlChar *ns = NULL, *fixed, *name, *attrValue;\n-    xmlSchemaIDCPtr curIDC = NULL, lastIDC = NULL;\n-\n-    if (xmlSchemaPValAttrNode(ctxt, NULL, nameAttr,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0)\n-        goto return_null;\n-    \/*\n-    * Evaluate the target namespace.\n-    *\/\n-    if (topLevel) {\n-        ns = ctxt->targetNamespace;\n-    } else {\n-        attr = xmlSchemaGetPropNode(node, \"form\");\n-        if (attr != NULL) {\n-        attrValue = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-        if (xmlStrEqual(attrValue, BAD_CAST \"qualified\")) {\n-            ns = ctxt->targetNamespace;\n-        } else if (!xmlStrEqual(attrValue, BAD_CAST \"unqualified\")) {\n-            xmlSchemaPSimpleTypeErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-            NULL, (xmlNodePtr) attr,\n-            NULL, \"(qualified | unqualified)\",\n-            attrValue, NULL, NULL, NULL);\n-        }\n-        } else if (schema->flags & XML_SCHEMAS_QUALIF_ELEM)\n-        ns = ctxt->targetNamespace;\n-    }\n-    decl = xmlSchemaAddElement(ctxt, name, ns, node, topLevel);\n-    if (decl == NULL) {\n-        goto return_null;\n-    }\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-        if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"name\")) &&\n-            (!xmlStrEqual(attr->name, BAD_CAST \"type\")) &&\n-            (!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-            (!xmlStrEqual(attr->name, BAD_CAST \"default\")) &&\n-            (!xmlStrEqual(attr->name, BAD_CAST \"fixed\")) &&\n-            (!xmlStrEqual(attr->name, BAD_CAST \"block\")) &&\n-            (!xmlStrEqual(attr->name, BAD_CAST \"nillable\")))\n-        {\n-            if (topLevel == 0) {\n-            if ((!xmlStrEqual(attr->name, BAD_CAST \"maxOccurs\")) &&\n-                (!xmlStrEqual(attr->name, BAD_CAST \"minOccurs\")) &&\n-                (!xmlStrEqual(attr->name, BAD_CAST \"form\")))\n-            {\n-                xmlSchemaPIllegalAttrErr(ctxt,\n-                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-            }\n-            } else if ((!xmlStrEqual(attr->name, BAD_CAST \"final\")) &&\n-            (!xmlStrEqual(attr->name, BAD_CAST \"abstract\")) &&\n-            (!xmlStrEqual(attr->name, BAD_CAST \"substitutionGroup\"))) {\n-\n-            xmlSchemaPIllegalAttrErr(ctxt,\n-                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-            }\n-        }\n-        } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-        attr = attr->next;\n-    }\n-    \/*\n-    * Extract\/validate attributes.\n-    *\/\n-    if (topLevel) {\n-        \/*\n-        * Process top attributes of global element declarations here.\n-        *\/\n-        decl->flags |= XML_SCHEMAS_ELEM_GLOBAL;\n-        decl->flags |= XML_SCHEMAS_ELEM_TOPLEVEL;\n-        xmlSchemaPValAttrQName(ctxt, schema,\n-        NULL, node, \"substitutionGroup\",\n-        &(decl->substGroupNs), &(decl->substGroup));\n-        if (xmlGetBooleanProp(ctxt, node, \"abstract\", 0))\n-        decl->flags |= XML_SCHEMAS_ELEM_ABSTRACT;\n-        \/*\n-        * Attribute \"final\".\n-        *\/\n-        attr = xmlSchemaGetPropNode(node, \"final\");\n-        if (attr == NULL) {\n-        if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_EXTENSION)\n-            decl->flags |= XML_SCHEMAS_ELEM_FINAL_EXTENSION;\n-        if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION)\n-            decl->flags |= XML_SCHEMAS_ELEM_FINAL_RESTRICTION;\n-        } else {\n-        attrValue = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-        if (xmlSchemaPValAttrBlockFinal(attrValue, &(decl->flags),\n-            -1,\n-            XML_SCHEMAS_ELEM_FINAL_EXTENSION,\n-            XML_SCHEMAS_ELEM_FINAL_RESTRICTION, -1, -1, -1) != 0) {\n-            xmlSchemaPSimpleTypeErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-            NULL, (xmlNodePtr) attr,\n-            NULL, \"(#all | List of (extension | restriction))\",\n-            attrValue, NULL, NULL, NULL);\n-        }\n-        }\n-    }\n-    \/*\n-    * Attribute \"block\".\n-    *\/\n-    attr = xmlSchemaGetPropNode(node, \"block\");\n-    if (attr == NULL) {\n-        \/*\n-        * Apply default \"block\" values.\n-        *\/\n-        if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION)\n-        decl->flags |= XML_SCHEMAS_ELEM_BLOCK_RESTRICTION;\n-        if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION)\n-        decl->flags |= XML_SCHEMAS_ELEM_BLOCK_EXTENSION;\n-        if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION)\n-        decl->flags |= XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION;\n-    } else {\n-        attrValue = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-        if (xmlSchemaPValAttrBlockFinal(attrValue, &(decl->flags),\n-        -1,\n-        XML_SCHEMAS_ELEM_BLOCK_EXTENSION,\n-        XML_SCHEMAS_ELEM_BLOCK_RESTRICTION,\n-        XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION, -1, -1) != 0) {\n-        xmlSchemaPSimpleTypeErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-            NULL, (xmlNodePtr) attr,\n-            NULL, \"(#all | List of (extension | \"\n-            \"restriction | substitution))\", attrValue,\n-            NULL, NULL, NULL);\n-        }\n-    }\n-    if (xmlGetBooleanProp(ctxt, node, \"nillable\", 0))\n-        decl->flags |= XML_SCHEMAS_ELEM_NILLABLE;\n-\n-    attr = xmlSchemaGetPropNode(node, \"type\");\n-    if (attr != NULL) {\n-        xmlSchemaPValAttrNodeQName(ctxt, schema,\n-        NULL, attr,\n-        &(decl->namedTypeNs), &(decl->namedType));\n-        xmlSchemaCheckReference(ctxt, schema, node,\n-        attr, decl->namedTypeNs);\n-    }\n-    decl->value = xmlSchemaGetProp(ctxt, node, \"default\");\n-    attr = xmlSchemaGetPropNode(node, \"fixed\");\n-    if (attr != NULL) {\n-        fixed = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-        if (decl->value != NULL) {\n-        \/*\n-        * 3.3.3 : 1\n-        * default and fixed must not both be present.\n-        *\/\n-        xmlSchemaPMutualExclAttrErr(ctxt,\n-            XML_SCHEMAP_SRC_ELEMENT_1,\n-            NULL, attr, \"default\", \"fixed\");\n-        } else {\n-        decl->flags |= XML_SCHEMAS_ELEM_FIXED;\n-        decl->value = fixed;\n-        }\n-    }\n-    \/*\n-    * And now for the children...\n-    *\/\n-    if (IS_SCHEMA(child, \"complexType\")) {\n-        \/*\n-        * 3.3.3 : 3\n-        * \"type\" and either <simpleType> or <complexType> are mutually\n-        * exclusive\n-        *\/\n-        if (decl->namedType != NULL) {\n-        xmlSchemaPContentErr(ctxt,\n-            XML_SCHEMAP_SRC_ELEMENT_3,\n-            NULL, node, child,\n-            \"The attribute 'type' and the <complexType> child are \"\n-            \"mutually exclusive\", NULL);\n-        } else\n-        WXS_ELEM_TYPEDEF(decl) = xmlSchemaParseComplexType(ctxt, schema, child, 0);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"simpleType\")) {\n-        \/*\n-        * 3.3.3 : 3\n-        * \"type\" and either <simpleType> or <complexType> are\n-        * mutually exclusive\n-        *\/\n-        if (decl->namedType != NULL) {\n-        xmlSchemaPContentErr(ctxt,\n-            XML_SCHEMAP_SRC_ELEMENT_3,\n-            NULL, node, child,\n-            \"The attribute 'type' and the <simpleType> child are \"\n-            \"mutually exclusive\", NULL);\n-        } else\n-        WXS_ELEM_TYPEDEF(decl) = xmlSchemaParseSimpleType(ctxt, schema, child, 0);\n-        child = child->next;\n-    }\n-    while ((IS_SCHEMA(child, \"unique\")) ||\n-        (IS_SCHEMA(child, \"key\")) || (IS_SCHEMA(child, \"keyref\"))) {\n-        if (IS_SCHEMA(child, \"unique\")) {\n-        curIDC = xmlSchemaParseIDC(ctxt, schema, child,\n-            XML_SCHEMA_TYPE_IDC_UNIQUE, decl->targetNamespace);\n-        } else if (IS_SCHEMA(child, \"key\")) {\n-        curIDC = xmlSchemaParseIDC(ctxt, schema, child,\n-            XML_SCHEMA_TYPE_IDC_KEY, decl->targetNamespace);\n-        } else if (IS_SCHEMA(child, \"keyref\")) {\n-        curIDC = xmlSchemaParseIDC(ctxt, schema, child,\n-            XML_SCHEMA_TYPE_IDC_KEYREF, decl->targetNamespace);\n-        }\n-        if (lastIDC != NULL)\n-        lastIDC->next = curIDC;\n-        else\n-        decl->idcs = (void *) curIDC;\n-        lastIDC = curIDC;\n-        child = child->next;\n-    }\n-    if (child != NULL) {\n-        xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child,\n-        NULL, \"(annotation?, ((simpleType | complexType)?, \"\n-        \"(unique | key | keyref)*))\");\n-    }\n-    decl->annot = annot;\n-    }\n-    \/*\n-    * NOTE: Element Declaration Representation OK 4. will be checked at a\n-    * different layer.\n-    *\/\n-    FREE_AND_NULL(des)\n-    if (topLevel)\n-    return ((xmlSchemaBasicItemPtr) decl);\n-    else {\n-    particle->children = (xmlSchemaTreeItemPtr) decl;\n-    return ((xmlSchemaBasicItemPtr) particle);\n-    }\n-\n-return_null:\n-    FREE_AND_NULL(des);\n-    if (annot != NULL) {\n-    if (particle != NULL)\n-        particle->annot = NULL;\n-    if (decl != NULL)\n-        decl->annot = NULL;\n-    xmlSchemaFreeAnnot(annot);\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlSchemaParseUnion:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * parse a XML schema Union definition\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns -1 in case of internal error, 0 in case of success and a positive\n- * error code otherwise.\n- *\/\n-static int\n-xmlSchemaParseUnion(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                    xmlNodePtr node)\n-{\n-    xmlSchemaTypePtr type;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-    const xmlChar *cur = NULL;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (-1);\n-    \/* Not a component, don't create it. *\/\n-    type = ctxt->ctxtType;\n-    \/*\n-    * Mark the simple type as being of variety \"union\".\n-    *\/\n-    type->flags |= XML_SCHEMAS_TYPE_VARIETY_UNION;\n-    \/*\n-    * SPEC (Base type) (2) \"If the <list> or <union> alternative is chosen,\n-    * then the `simple ur-type definition`.\"\n-    *\/\n-    type->baseType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"memberTypes\"))) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-    \/*\n-    * Attribute \"memberTypes\". This is a list of QNames.\n-    * TODO: Check the value to contain anything.\n-    *\/\n-    attr = xmlSchemaGetPropNode(node, \"memberTypes\");\n-    if (attr != NULL) {\n-    const xmlChar *end;\n-    xmlChar *tmp;\n-    const xmlChar *localName, *nsName;\n-    xmlSchemaTypeLinkPtr link, lastLink = NULL;\n-    xmlSchemaQNameRefPtr ref;\n-\n-    cur = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-        if (cur == NULL)\n-            return (-1);\n-    type->base = cur;\n-    do {\n-        while (IS_BLANK_CH(*cur))\n-        cur++;\n-        end = cur;\n-        while ((*end != 0) && (!(IS_BLANK_CH(*end))))\n-        end++;\n-        if (end == cur)\n-        break;\n-        tmp = xmlStrndup(cur, end - cur);\n-            if (tmp == NULL) {\n-                xmlSchemaPErrMemory(ctxt);\n-                return (-1);\n-            }\n-        if (xmlSchemaPValAttrNodeQNameValue(ctxt, schema,\n-        NULL, attr, BAD_CAST tmp, &nsName, &localName) == 0) {\n-        \/*\n-        * Create the member type link.\n-        *\/\n-        link = (xmlSchemaTypeLinkPtr)\n-            xmlMalloc(sizeof(xmlSchemaTypeLink));\n-        if (link == NULL) {\n-            xmlSchemaPErrMemory(ctxt);\n-                FREE_AND_NULL(tmp)\n-            return (-1);\n-        }\n-        link->type = NULL;\n-        link->next = NULL;\n-        if (lastLink == NULL)\n-            type->memberTypes = link;\n-        else\n-            lastLink->next = link;\n-        lastLink = link;\n-        \/*\n-        * Create a reference item.\n-        *\/\n-        ref = xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_SIMPLE,\n-            localName, nsName);\n-        if (ref == NULL) {\n-            FREE_AND_NULL(tmp)\n-            return (-1);\n-        }\n-        \/*\n-        * Assign the reference to the link, it will be resolved\n-        * later during fixup of the union simple type.\n-        *\/\n-        link->type = (xmlSchemaTypePtr) ref;\n-        }\n-        FREE_AND_NULL(tmp)\n-        cur = end;\n-    } while (*cur != 0);\n-\n-    }\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-    \/*\n-    * Add the annotation to the simple type ancestor.\n-    *\/\n-    xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,\n-        xmlSchemaParseAnnotation(ctxt, child, 1));\n-        child = child->next;\n-    }\n-    if (IS_SCHEMA(child, \"simpleType\")) {\n-    xmlSchemaTypePtr subtype, last = NULL;\n-\n-    \/*\n-    * Anchor the member types in the \"subtypes\" field of the\n-    * simple type.\n-    *\/\n-    while (IS_SCHEMA(child, \"simpleType\")) {\n-        subtype = (xmlSchemaTypePtr)\n-        xmlSchemaParseSimpleType(ctxt, schema, child, 0);\n-        if (subtype != NULL) {\n-        if (last == NULL) {\n-            type->subtypes = subtype;\n-            last = subtype;\n-        } else {\n-            last->next = subtype;\n-            last = subtype;\n-        }\n-        last->next = NULL;\n-        }\n-        child = child->next;\n-    }\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL, \"(annotation?, simpleType*)\");\n-    }\n-    if ((attr == NULL) && (type->subtypes == NULL)) {\n-     \/*\n-    * src-union-memberTypes-or-simpleTypes\n-    * Either the memberTypes [attribute] of the <union> element must\n-    * be non-empty or there must be at least one simpleType [child].\n-    *\/\n-    xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES,\n-        NULL, node,\n-        \"Either the attribute 'memberTypes' or \"\n-        \"at least one <simpleType> child must be present\", NULL);\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaParseList:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * parse a XML schema List definition\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns -1 in case of error, 0 if the declaration is improper and\n- *         1 in case of success.\n- *\/\n-static xmlSchemaTypePtr\n-xmlSchemaParseList(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                   xmlNodePtr node)\n-{\n-    xmlSchemaTypePtr type;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-    \/* Not a component, don't create it. *\/\n-    type = ctxt->ctxtType;\n-    \/*\n-    * Mark the type as being of variety \"list\".\n-    *\/\n-    type->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;\n-    \/*\n-    * SPEC (Base type) (2) \"If the <list> or <union> alternative is chosen,\n-    * then the `simple ur-type definition`.\"\n-    *\/\n-    type->baseType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"itemType\"))) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-\n-    \/*\n-    * Attribute \"itemType\". NOTE that we will use the \"ref\" and \"refNs\"\n-    * fields for holding the reference to the itemType.\n-    *\n-    * REVAMP TODO: Use the \"base\" and \"baseNs\" fields, since we will remove\n-    * the \"ref\" fields.\n-    *\/\n-    xmlSchemaPValAttrQName(ctxt, schema, NULL,\n-    node, \"itemType\", &(type->baseNs), &(type->base));\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-    xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,\n-        xmlSchemaParseAnnotation(ctxt, child, 1));\n-        child = child->next;\n-    }\n-    if (IS_SCHEMA(child, \"simpleType\")) {\n-    \/*\n-    * src-list-itemType-or-simpleType\n-    * Either the itemType [attribute] or the <simpleType> [child] of\n-    * the <list> element must be present, but not both.\n-    *\/\n-    if (type->base != NULL) {\n-        xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_SRC_SIMPLE_TYPE_1,\n-        NULL, node,\n-        \"The attribute 'itemType' and the <simpleType> child \"\n-        \"are mutually exclusive\", NULL);\n-    } else {\n-        type->subtypes = xmlSchemaParseSimpleType(ctxt, schema, child, 0);\n-    }\n-        child = child->next;\n-    } else if (type->base == NULL) {\n-    xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_SRC_SIMPLE_TYPE_1,\n-        NULL, node,\n-        \"Either the attribute 'itemType' or the <simpleType> child \"\n-        \"must be present\", NULL);\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL, \"(annotation?, simpleType?)\");\n-    }\n-    if ((type->base == NULL) &&\n-    (type->subtypes == NULL) &&\n-    (xmlSchemaGetPropNode(node, \"itemType\") == NULL)) {\n-    xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_SRC_SIMPLE_TYPE_1,\n-        NULL, node,\n-        \"Either the attribute 'itemType' or the <simpleType> child \"\n-        \"must be present\", NULL);\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlSchemaParseSimpleType:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * parse a XML schema Simple Type definition\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns -1 in case of error, 0 if the declaration is improper and\n- * 1 in case of success.\n- *\/\n-static xmlSchemaTypePtr\n-xmlSchemaParseSimpleType(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                         xmlNodePtr node, int topLevel)\n-{\n-    xmlSchemaTypePtr type, oldCtxtType;\n-    xmlNodePtr child = NULL;\n-    const xmlChar *attrValue = NULL;\n-    xmlAttrPtr attr;\n-    int hasRestriction = 0;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-\n-    if (topLevel) {\n-    attr = xmlSchemaGetPropNode(node, \"name\");\n-    if (attr == NULL) {\n-        xmlSchemaPMissingAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_MISSING,\n-        NULL, node,\n-        \"name\", NULL);\n-        return (NULL);\n-    } else {\n-        if (xmlSchemaPValAttrNode(ctxt,\n-        NULL, attr,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &attrValue) != 0)\n-        return (NULL);\n-        \/*\n-        * Skip built-in types.\n-        *\/\n-        if (ctxt->isS4S) {\n-        xmlSchemaTypePtr biType;\n-\n-        if (ctxt->isRedefine) {\n-            \/*\n-            * REDEFINE: Disallow redefinition of built-in-types.\n-            * TODO: It seems that the spec does not say anything\n-            * about this case.\n-            *\/\n-            xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_REDEFINE,\n-            NULL, node,\n-            \"Redefinition of built-in simple types is not \"\n-            \"supported\", NULL);\n-            return(NULL);\n-        }\n-        biType = xmlSchemaGetPredefinedType(attrValue, xmlSchemaNs);\n-        if (biType != NULL)\n-            return (biType);\n-        }\n-    }\n-    }\n-    \/*\n-    * TargetNamespace:\n-    * SPEC \"The `actual value` of the targetNamespace [attribute]\n-    * of the <schema> ancestor element information item if present,\n-    * otherwise `absent`.\n-    *\/\n-    if (topLevel == 0) {\n-#ifdef ENABLE_NAMED_LOCALS\n-        char buf[40];\n-#endif\n-    \/*\n-    * Parse as local simple type definition.\n-    *\/\n-#ifdef ENABLE_NAMED_LOCALS\n-        snprintf(buf, 39, \"#ST%d\", ctxt->counter++ + 1);\n-    type = xmlSchemaAddType(ctxt, schema,\n-        XML_SCHEMA_TYPE_SIMPLE,\n-        xmlDictLookup(ctxt->dict, (const xmlChar *)buf, -1),\n-        ctxt->targetNamespace, node, 0);\n-#else\n-    type = xmlSchemaAddType(ctxt, schema,\n-        XML_SCHEMA_TYPE_SIMPLE,\n-        NULL, ctxt->targetNamespace, node, 0);\n-#endif\n-    if (type == NULL)\n-        return (NULL);\n-    type->type = XML_SCHEMA_TYPE_SIMPLE;\n-    type->contentType = XML_SCHEMA_CONTENT_SIMPLE;\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-        if (attr->ns == NULL) {\n-        if (!xmlStrEqual(attr->name, BAD_CAST \"id\")) {\n-            xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-        } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-            xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-        attr = attr->next;\n-    }\n-    } else {\n-    \/*\n-    * Parse as global simple type definition.\n-    *\n-    * Note that attrValue is the value of the attribute \"name\" here.\n-    *\/\n-    type = xmlSchemaAddType(ctxt, schema, XML_SCHEMA_TYPE_SIMPLE,\n-        attrValue, ctxt->targetNamespace, node, 1);\n-    if (type == NULL)\n-        return (NULL);\n-    type->type = XML_SCHEMA_TYPE_SIMPLE;\n-    type->contentType = XML_SCHEMA_CONTENT_SIMPLE;\n-    type->flags |= XML_SCHEMAS_TYPE_GLOBAL;\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-        if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-            (!xmlStrEqual(attr->name, BAD_CAST \"name\")) &&\n-            (!xmlStrEqual(attr->name, BAD_CAST \"final\"))) {\n-            xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-        } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-        attr = attr->next;\n-    }\n-    \/*\n-    * Attribute \"final\".\n-    *\/\n-    attr = xmlSchemaGetPropNode(node, \"final\");\n-    if (attr == NULL) {\n-        if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION)\n-        type->flags |= XML_SCHEMAS_TYPE_FINAL_RESTRICTION;\n-        if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_LIST)\n-        type->flags |= XML_SCHEMAS_TYPE_FINAL_LIST;\n-        if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_UNION)\n-        type->flags |= XML_SCHEMAS_TYPE_FINAL_UNION;\n-    } else {\n-        attrValue = xmlSchemaGetProp(ctxt, node, \"final\");\n-        if (xmlSchemaPValAttrBlockFinal(attrValue, &(type->flags),\n-        -1, -1, XML_SCHEMAS_TYPE_FINAL_RESTRICTION, -1,\n-        XML_SCHEMAS_TYPE_FINAL_LIST,\n-        XML_SCHEMAS_TYPE_FINAL_UNION) != 0) {\n-\n-        xmlSchemaPSimpleTypeErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-            WXS_BASIC_CAST type, (xmlNodePtr) attr,\n-            NULL, \"(#all | List of (list | union | restriction)\",\n-            attrValue, NULL, NULL, NULL);\n-        }\n-    }\n-    }\n-    type->targetNamespace = ctxt->targetNamespace;\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-    \/*\n-    * And now for the children...\n-    *\/\n-    oldCtxtType = ctxt->ctxtType;\n-\n-    ctxt->ctxtType = type;\n-\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-        type->annot = xmlSchemaParseAnnotation(ctxt, child, 1);\n-        child = child->next;\n-    }\n-    if (child == NULL) {\n-    xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_MISSING,\n-        NULL, node, child, NULL,\n-        \"(annotation?, (restriction | list | union))\");\n-    } else if (IS_SCHEMA(child, \"restriction\")) {\n-        xmlSchemaParseRestriction(ctxt, schema, child,\n-        XML_SCHEMA_TYPE_SIMPLE);\n-    hasRestriction = 1;\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"list\")) {\n-        xmlSchemaParseList(ctxt, schema, child);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"union\")) {\n-        xmlSchemaParseUnion(ctxt, schema, child);\n-        child = child->next;\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?, (restriction | list | union))\");\n-    }\n-    \/*\n-    * REDEFINE: SPEC src-redefine (5)\n-    * \"Within the [children], each <simpleType> must have a\n-    * <restriction> among its [children] ... the `actual value` of whose\n-    * base [attribute] must be the same as the `actual value` of its own\n-    * name attribute plus target namespace;\"\n-    *\/\n-    if (topLevel && ctxt->isRedefine && (! hasRestriction)) {\n-    xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_REDEFINE,\n-        NULL, node, \"This is a redefinition, thus the \"\n-        \"<simpleType> must have a <restriction> child\", NULL);\n-    }\n-\n-    ctxt->ctxtType = oldCtxtType;\n-    return (type);\n-}\n-\n-\/**\n- * xmlSchemaParseModelGroupDefRef:\n- * @ctxt:  the parser context\n- * @schema: the schema being built\n- * @node:  the node\n- *\n- * Parses a reference to a model group definition.\n- *\n- * We will return a particle component with a qname-component or\n- * NULL in case of an error.\n- *\/\n-static xmlSchemaTreeItemPtr\n-xmlSchemaParseModelGroupDefRef(xmlSchemaParserCtxtPtr ctxt,\n-                   xmlSchemaPtr schema,\n-                   xmlNodePtr node)\n-{\n-    xmlSchemaParticlePtr item;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-    const xmlChar *ref = NULL, *refNs = NULL;\n-    int min, max;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-\n-    attr = xmlSchemaGetPropNode(node, \"ref\");\n-    if (attr == NULL) {\n-    xmlSchemaPMissingAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_MISSING,\n-        NULL, node, \"ref\", NULL);\n-    return (NULL);\n-    } else if (xmlSchemaPValAttrNodeQName(ctxt, schema, NULL,\n-    attr, &refNs, &ref) != 0) {\n-    return (NULL);\n-    }\n-    xmlSchemaCheckReference(ctxt, schema, node, attr, refNs);\n-    min = xmlGetMinOccurs(ctxt, node, 0, -1, 1, \"xs:nonNegativeInteger\");\n-    max = xmlGetMaxOccurs(ctxt, node, 0, UNBOUNDED, 1,\n-    \"(xs:nonNegativeInteger | unbounded)\");\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"ref\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"minOccurs\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"maxOccurs\"))) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-    item = xmlSchemaAddParticle(ctxt, node, min, max);\n-    if (item == NULL)\n-    return (NULL);\n-    \/*\n-    * Create a qname-reference and set as the term; it will be substituted\n-    * for the model group after the reference has been resolved.\n-    *\/\n-    item->children = (xmlSchemaTreeItemPtr)\n-    xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_GROUP, ref, refNs);\n-    xmlSchemaPCheckParticleCorrect_2(ctxt, item, node, min, max);\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    \/* TODO: Is annotation even allowed for a model group reference? *\/\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-    \/*\n-    * TODO: What to do exactly with the annotation?\n-    *\/\n-    item->annot = xmlSchemaParseAnnotation(ctxt, child, 1);\n-    child = child->next;\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?)\");\n-    }\n-    \/*\n-    * Corresponds to no component at all if minOccurs==maxOccurs==0.\n-    *\/\n-    if ((min == 0) && (max == 0))\n-    return (NULL);\n-\n-    return ((xmlSchemaTreeItemPtr) item);\n-}\n-\n-\/**\n- * xmlSchemaParseModelGroupDefinition:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * Parses a XML schema model group definition.\n- *\n- * Note that the constraint src-redefine (6.2) can't be applied until\n- * references have been resolved. So we will do this at the\n- * component fixup level.\n- *\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns -1 in case of error, 0 if the declaration is improper and\n- *         1 in case of success.\n- *\/\n-static xmlSchemaModelGroupDefPtr\n-xmlSchemaParseModelGroupDefinition(xmlSchemaParserCtxtPtr ctxt,\n-                   xmlSchemaPtr schema,\n-                   xmlNodePtr node)\n-{\n-    xmlSchemaModelGroupDefPtr item;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-    const xmlChar *name;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-\n-    attr = xmlSchemaGetPropNode(node, \"name\");\n-    if (attr == NULL) {\n-    xmlSchemaPMissingAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_MISSING,\n-        NULL, node,\n-        \"name\", NULL);\n-    return (NULL);\n-    } else if (xmlSchemaPValAttrNode(ctxt, NULL, attr,\n-    xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {\n-    return (NULL);\n-    }\n-    item = xmlSchemaAddModelGroupDefinition(ctxt, schema, name,\n-    ctxt->targetNamespace, node);\n-    if (item == NULL)\n-    return (NULL);\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"name\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"id\"))) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-    item->annot = xmlSchemaParseAnnotation(ctxt, child, 1);\n-    child = child->next;\n-    }\n-    if (IS_SCHEMA(child, \"all\")) {\n-    item->children = xmlSchemaParseModelGroup(ctxt, schema, child,\n-        XML_SCHEMA_TYPE_ALL, 0);\n-    child = child->next;\n-    } else if (IS_SCHEMA(child, \"choice\")) {\n-    item->children = xmlSchemaParseModelGroup(ctxt, schema, child,\n-        XML_SCHEMA_TYPE_CHOICE, 0);\n-    child = child->next;\n-    } else if (IS_SCHEMA(child, \"sequence\")) {\n-    item->children = xmlSchemaParseModelGroup(ctxt, schema, child,\n-        XML_SCHEMA_TYPE_SEQUENCE, 0);\n-    child = child->next;\n-    }\n-\n-\n-\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?, (all | choice | sequence)?)\");\n-    }\n-    return (item);\n-}\n-\n-\/**\n- * xmlSchemaCleanupDoc:\n- * @ctxt:  a schema validation context\n- * @node:  the root of the document.\n- *\n- * removes unwanted nodes in a schemas document tree\n- *\/\n-static void\n-xmlSchemaCleanupDoc(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr root)\n-{\n-    xmlNodePtr delete, cur;\n-\n-    if ((ctxt == NULL) || (root == NULL)) return;\n-\n-    \/*\n-     * Remove all the blank text nodes\n-     *\/\n-    delete = NULL;\n-    cur = root;\n-    while (cur != NULL) {\n-        if (delete != NULL) {\n-            xmlUnlinkNode(delete);\n-            xmlFreeNode(delete);\n-            delete = NULL;\n-        }\n-        if (cur->type == XML_TEXT_NODE) {\n-            if (IS_BLANK_NODE(cur)) {\n-                if (xmlNodeGetSpacePreserve(cur) != 1) {\n-                    delete = cur;\n-                }\n-            }\n-        } else if ((cur->type != XML_ELEMENT_NODE) &&\n-                   (cur->type != XML_CDATA_SECTION_NODE)) {\n-            delete = cur;\n-            goto skip_children;\n-        }\n-\n-        \/*\n-         * Skip to next node\n-         *\/\n-        if (cur->children != NULL) {\n-            if ((cur->children->type != XML_ENTITY_DECL) &&\n-                (cur->children->type != XML_ENTITY_REF_NODE) &&\n-                (cur->children->type != XML_ENTITY_NODE)) {\n-                cur = cur->children;\n-                continue;\n-            }\n-        }\n-      skip_children:\n-        if (cur->next != NULL) {\n-            cur = cur->next;\n-            continue;\n-        }\n-\n-        do {\n-            cur = cur->parent;\n-            if (cur == NULL)\n-                break;\n-            if (cur == root) {\n-                cur = NULL;\n-                break;\n-            }\n-            if (cur->next != NULL) {\n-                cur = cur->next;\n-                break;\n-            }\n-        } while (cur != NULL);\n-    }\n-    if (delete != NULL) {\n-        xmlUnlinkNode(delete);\n-        xmlFreeNode(delete);\n-        delete = NULL;\n-    }\n-}\n-\n-\n-static void\n-xmlSchemaClearSchemaDefaults(xmlSchemaPtr schema)\n-{\n-    if (schema->flags & XML_SCHEMAS_QUALIF_ELEM)\n-    schema->flags ^= XML_SCHEMAS_QUALIF_ELEM;\n-\n-    if (schema->flags & XML_SCHEMAS_QUALIF_ATTR)\n-    schema->flags ^= XML_SCHEMAS_QUALIF_ATTR;\n-\n-    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_EXTENSION)\n-    schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_EXTENSION;\n-    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION)\n-    schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION;\n-    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_LIST)\n-    schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_LIST;\n-    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_UNION)\n-    schema->flags ^= XML_SCHEMAS_FINAL_DEFAULT_UNION;\n-\n-    if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION)\n-    schema->flags ^= XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION;\n-    if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION)\n-    schema->flags ^= XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION;\n-    if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION)\n-    schema->flags ^= XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION;\n-}\n-\n-static int\n-xmlSchemaParseSchemaElement(xmlSchemaParserCtxtPtr ctxt,\n-                 xmlSchemaPtr schema,\n-                 xmlNodePtr node)\n-{\n-    xmlAttrPtr attr;\n-    const xmlChar *val;\n-    int res = 0, oldErrs = ctxt->nberrors;\n-\n-    \/*\n-    * Those flags should be moved to the parser context flags,\n-    * since they are not visible at the component level. I.e.\n-    * they are used if processing schema *documents* only.\n-    *\/\n-    res = xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-    HFAILURE;\n-\n-    \/*\n-    * Since the version is of type xs:token, we won't bother to\n-    * check it.\n-    *\/\n-    \/* REMOVED:\n-    attr = xmlSchemaGetPropNode(node, \"version\");\n-    if (attr != NULL) {\n-    res = xmlSchemaPValAttrNode(ctxt, NULL, NULL, attr,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_TOKEN), &val);\n-    HFAILURE;\n-    }\n-    *\/\n-    attr = xmlSchemaGetPropNode(node, \"targetNamespace\");\n-    if (attr != NULL) {\n-    res = xmlSchemaPValAttrNode(ctxt, NULL, attr,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI), NULL);\n-    HFAILURE;\n-    if (res != 0) {\n-        ctxt->stop = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE;\n-        goto exit;\n-    }\n-    }\n-    attr = xmlSchemaGetPropNode(node, \"elementFormDefault\");\n-    if (attr != NULL) {\n-    val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-    res = xmlSchemaPValAttrFormDefault(val, &schema->flags,\n-        XML_SCHEMAS_QUALIF_ELEM);\n-    HFAILURE;\n-    if (res != 0) {\n-        xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_ELEMFORMDEFAULT_VALUE,\n-        NULL, (xmlNodePtr) attr, NULL,\n-        \"(qualified | unqualified)\", val, NULL, NULL, NULL);\n-    }\n-    }\n-    attr = xmlSchemaGetPropNode(node, \"attributeFormDefault\");\n-    if (attr != NULL) {\n-    val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-    res = xmlSchemaPValAttrFormDefault(val, &schema->flags,\n-        XML_SCHEMAS_QUALIF_ATTR);\n-    HFAILURE;\n-    if (res != 0) {\n-        xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_ATTRFORMDEFAULT_VALUE,\n-        NULL, (xmlNodePtr) attr, NULL,\n-        \"(qualified | unqualified)\", val, NULL, NULL, NULL);\n-    }\n-    }\n-    attr = xmlSchemaGetPropNode(node, \"finalDefault\");\n-    if (attr != NULL) {\n-    val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-    res = xmlSchemaPValAttrBlockFinal(val, &(schema->flags), -1,\n-        XML_SCHEMAS_FINAL_DEFAULT_EXTENSION,\n-        XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION,\n-        -1,\n-        XML_SCHEMAS_FINAL_DEFAULT_LIST,\n-        XML_SCHEMAS_FINAL_DEFAULT_UNION);\n-    HFAILURE;\n-    if (res != 0) {\n-        xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        NULL, (xmlNodePtr) attr, NULL,\n-        \"(#all | List of (extension | restriction | list | union))\",\n-        val, NULL, NULL, NULL);\n-    }\n-    }\n-    attr = xmlSchemaGetPropNode(node, \"blockDefault\");\n-    if (attr != NULL) {\n-    val = xmlSchemaGetNodeContent(ctxt, (xmlNodePtr) attr);\n-    res = xmlSchemaPValAttrBlockFinal(val, &(schema->flags), -1,\n-        XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION,\n-        XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION,\n-        XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION, -1, -1);\n-    HFAILURE;\n-    if (res != 0) {\n-        xmlSchemaPSimpleTypeErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        NULL, (xmlNodePtr) attr, NULL,\n-        \"(#all | List of (extension | restriction | substitution))\",\n-        val, NULL, NULL, NULL);\n-    }\n-    }\n-\n-exit:\n-    if (oldErrs != ctxt->nberrors)\n-    res = ctxt->err;\n-    return(res);\n-exit_failure:\n-    return(-1);\n-}\n-\n-\/**\n- * xmlSchemaParseSchemaTopLevel:\n- * @ctxt:  a schema validation context\n- * @schema:  the schemas\n- * @nodes:  the list of top level nodes\n- *\n- * Returns the internal XML Schema structure built from the resource or\n- *         NULL in case of error\n- *\/\n-static int\n-xmlSchemaParseSchemaTopLevel(xmlSchemaParserCtxtPtr ctxt,\n-                             xmlSchemaPtr schema, xmlNodePtr nodes)\n-{\n-    xmlNodePtr child;\n-    xmlSchemaAnnotPtr annot;\n-    int res = 0, oldErrs, tmpOldErrs;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (nodes == NULL))\n-        return(-1);\n-\n-    oldErrs = ctxt->nberrors;\n-    child = nodes;\n-    while ((IS_SCHEMA(child, \"include\")) ||\n-       (IS_SCHEMA(child, \"import\")) ||\n-       (IS_SCHEMA(child, \"redefine\")) ||\n-       (IS_SCHEMA(child, \"annotation\"))) {\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-        annot = xmlSchemaParseAnnotation(ctxt, child, 1);\n-        if (schema->annot == NULL)\n-        schema->annot = annot;\n-        else\n-        xmlSchemaFreeAnnot(annot);\n-    } else if (IS_SCHEMA(child, \"import\")) {\n-        tmpOldErrs = ctxt->nberrors;\n-        res = xmlSchemaParseImport(ctxt, schema, child);\n-        HFAILURE;\n-        HSTOP(ctxt);\n-        if (tmpOldErrs != ctxt->nberrors)\n-        goto exit;\n-    } else if (IS_SCHEMA(child, \"include\")) {\n-        tmpOldErrs = ctxt->nberrors;\n-        res = xmlSchemaParseInclude(ctxt, schema, child);\n-        HFAILURE;\n-        HSTOP(ctxt);\n-        if (tmpOldErrs != ctxt->nberrors)\n-        goto exit;\n-    } else if (IS_SCHEMA(child, \"redefine\")) {\n-        tmpOldErrs = ctxt->nberrors;\n-        res = xmlSchemaParseRedefine(ctxt, schema, child);\n-        HFAILURE;\n-        HSTOP(ctxt);\n-        if (tmpOldErrs != ctxt->nberrors)\n-        goto exit;\n-    }\n-    child = child->next;\n-    }\n-    \/*\n-    * URGENT TODO: Change the functions to return int results.\n-    * We need especially to catch internal errors.\n-    *\/\n-    while (child != NULL) {\n-    if (IS_SCHEMA(child, \"complexType\")) {\n-        xmlSchemaParseComplexType(ctxt, schema, child, 1);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"simpleType\")) {\n-        xmlSchemaParseSimpleType(ctxt, schema, child, 1);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"element\")) {\n-        xmlSchemaParseElement(ctxt, schema, child, NULL, 1);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"attribute\")) {\n-        xmlSchemaParseGlobalAttribute(ctxt, schema, child);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"attributeGroup\")) {\n-        xmlSchemaParseAttributeGroupDefinition(ctxt, schema, child);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"group\")) {\n-        xmlSchemaParseModelGroupDefinition(ctxt, schema, child);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"notation\")) {\n-        xmlSchemaParseNotation(ctxt, schema, child);\n-        child = child->next;\n-    } else {\n-        xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, child->parent, child,\n-        NULL, \"((include | import | redefine | annotation)*, \"\n-        \"(((simpleType | complexType | group | attributeGroup) \"\n-        \"| element | attribute | notation), annotation*)*)\");\n-        child = child->next;\n-    }\n-    while (IS_SCHEMA(child, \"annotation\")) {\n-        \/*\n-        * TODO: We should add all annotations.\n-        *\/\n-        annot = xmlSchemaParseAnnotation(ctxt, child, 1);\n-        if (schema->annot == NULL)\n-        schema->annot = annot;\n-        else\n-        xmlSchemaFreeAnnot(annot);\n-        child = child->next;\n-    }\n-    }\n-exit:\n-    ctxt->ctxtType = NULL;\n-    if (oldErrs != ctxt->nberrors)\n-    res = ctxt->err;\n-    return(res);\n-exit_failure:\n-    return(-1);\n-}\n-\n-static xmlSchemaSchemaRelationPtr\n-xmlSchemaSchemaRelationCreate(void)\n-{\n-    xmlSchemaSchemaRelationPtr ret;\n-\n-    ret = (xmlSchemaSchemaRelationPtr)\n-    xmlMalloc(sizeof(xmlSchemaSchemaRelation));\n-    if (ret == NULL) {\n-    xmlSchemaPErrMemory(NULL);\n-    return(NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaSchemaRelation));\n-    return(ret);\n-}\n-\n-#if 0\n-static void\n-xmlSchemaSchemaRelationFree(xmlSchemaSchemaRelationPtr rel)\n-{\n-    xmlFree(rel);\n-}\n-#endif\n-\n-static void\n-xmlSchemaRedefListFree(xmlSchemaRedefPtr redef)\n-{\n-    xmlSchemaRedefPtr prev;\n-\n-    while (redef != NULL) {\n-    prev = redef;\n-    redef = redef->next;\n-    xmlFree(prev);\n-    }\n-}\n-\n-static void\n-xmlSchemaConstructionCtxtFree(xmlSchemaConstructionCtxtPtr con)\n-{\n-    \/*\n-    * After the construction context has been freed, there will be\n-    * no schema graph available any more. Only the schema buckets\n-    * will stay alive, which are put into the \"schemasImports\" and\n-    * \"includes\" slots of the xmlSchema.\n-    *\/\n-    if (con->buckets != NULL)\n-    xmlSchemaItemListFree(con->buckets);\n-    if (con->pending != NULL)\n-    xmlSchemaItemListFree(con->pending);\n-    if (con->substGroups != NULL)\n-    xmlHashFree(con->substGroups, xmlSchemaSubstGroupFreeEntry);\n-    if (con->redefs != NULL)\n-    xmlSchemaRedefListFree(con->redefs);\n-    if (con->dict != NULL)\n-    xmlDictFree(con->dict);\n-    xmlFree(con);\n-}\n-\n-static xmlSchemaConstructionCtxtPtr\n-xmlSchemaConstructionCtxtCreate(xmlDictPtr dict)\n-{\n-    xmlSchemaConstructionCtxtPtr ret;\n-\n-    ret = (xmlSchemaConstructionCtxtPtr)\n-    xmlMalloc(sizeof(xmlSchemaConstructionCtxt));\n-    if (ret == NULL) {\n-        xmlSchemaPErrMemory(NULL);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaConstructionCtxt));\n-\n-    ret->buckets = xmlSchemaItemListCreate();\n-    if (ret->buckets == NULL) {\n-    xmlSchemaPErrMemory(NULL);\n-    xmlFree(ret);\n-        return (NULL);\n-    }\n-    ret->pending = xmlSchemaItemListCreate();\n-    if (ret->pending == NULL) {\n-    xmlSchemaPErrMemory(NULL);\n-    xmlSchemaConstructionCtxtFree(ret);\n-        return (NULL);\n-    }\n-    ret->dict = dict;\n-    xmlDictReference(dict);\n-    return(ret);\n-}\n-\n-static xmlSchemaParserCtxtPtr\n-xmlSchemaParserCtxtCreate(void)\n-{\n-    xmlSchemaParserCtxtPtr ret;\n-\n-    ret = (xmlSchemaParserCtxtPtr) xmlMalloc(sizeof(xmlSchemaParserCtxt));\n-    if (ret == NULL) {\n-        xmlSchemaPErrMemory(NULL);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaParserCtxt));\n-    ret->type = XML_SCHEMA_CTXT_PARSER;\n-    ret->attrProhibs = xmlSchemaItemListCreate();\n-    if (ret->attrProhibs == NULL) {\n-    xmlFree(ret);\n-    return(NULL);\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlSchemaNewParserCtxtUseDict:\n- * @URL:  the location of the schema\n- * @dict: the dictionary to be used\n- *\n- * Create an XML Schemas parse context for that file\/resource expected\n- * to contain an XML Schemas file.\n- *\n- * Returns the parser context or NULL in case of error\n- *\/\n-static xmlSchemaParserCtxtPtr\n-xmlSchemaNewParserCtxtUseDict(const char *URL, xmlDictPtr dict)\n-{\n-    xmlSchemaParserCtxtPtr ret;\n-\n-    ret = xmlSchemaParserCtxtCreate();\n-    if (ret == NULL)\n-        return (NULL);\n-    ret->dict = dict;\n-    xmlDictReference(dict);\n-    if (URL != NULL)\n-    ret->URL = xmlDictLookup(dict, (const xmlChar *) URL, -1);\n-    return (ret);\n-}\n-\n-static int\n-xmlSchemaCreatePCtxtOnVCtxt(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    if (vctxt->pctxt == NULL) {\n-        if (vctxt->schema != NULL)\n-        vctxt->pctxt =\n-        xmlSchemaNewParserCtxtUseDict(\"*\", vctxt->schema->dict);\n-    else\n-        vctxt->pctxt = xmlSchemaNewParserCtxt(\"*\");\n-    if (vctxt->pctxt == NULL) {\n-        VERROR_INT(\"xmlSchemaCreatePCtxtOnVCtxt\",\n-        \"failed to create a temp. parser context\");\n-        return (-1);\n-    }\n-    \/* TODO: Pass user data. *\/\n-    xmlSchemaSetParserErrors(vctxt->pctxt, vctxt->error,\n-        vctxt->warning, vctxt->errCtxt);\n-    xmlSchemaSetParserStructuredErrors(vctxt->pctxt, vctxt->serror,\n-        vctxt->errCtxt);\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaGetSchemaBucket:\n- * @pctxt: the schema parser context\n- * @schemaLocation: the URI of the schema document\n- *\n- * Returns a schema bucket if it was already parsed.\n- *\n- * Returns a schema bucket if it was already parsed from\n- *         @schemaLocation, NULL otherwise.\n- *\/\n-static xmlSchemaBucketPtr\n-xmlSchemaGetSchemaBucket(xmlSchemaParserCtxtPtr pctxt,\n-                const xmlChar *schemaLocation)\n-{\n-    xmlSchemaBucketPtr cur;\n-    xmlSchemaItemListPtr list;\n-\n-    list = pctxt->constructor->buckets;\n-    if (list->nbItems == 0)\n-    return(NULL);\n-    else {\n-    int i;\n-    for (i = 0; i < list->nbItems; i++) {\n-        cur = (xmlSchemaBucketPtr) list->items[i];\n-        \/* Pointer comparison! *\/\n-        if (cur->schemaLocation == schemaLocation)\n-        return(cur);\n-    }\n-    }\n-    return(NULL);\n-}\n-\n-static xmlSchemaBucketPtr\n-xmlSchemaGetChameleonSchemaBucket(xmlSchemaParserCtxtPtr pctxt,\n-                     const xmlChar *schemaLocation,\n-                     const xmlChar *targetNamespace)\n-{\n-    xmlSchemaBucketPtr cur;\n-    xmlSchemaItemListPtr list;\n-\n-    list = pctxt->constructor->buckets;\n-    if (list->nbItems == 0)\n-    return(NULL);\n-    else {\n-    int i;\n-    for (i = 0; i < list->nbItems; i++) {\n-        cur = (xmlSchemaBucketPtr) list->items[i];\n-        \/* Pointer comparison! *\/\n-        if ((cur->origTargetNamespace == NULL) &&\n-        (cur->schemaLocation == schemaLocation) &&\n-        (cur->targetNamespace == targetNamespace))\n-        return(cur);\n-    }\n-    }\n-    return(NULL);\n-}\n-\n-\n-#define IS_BAD_SCHEMA_DOC(b) \\\n-    (((b)->doc == NULL) && ((b)->schemaLocation != NULL))\n-\n-static xmlSchemaBucketPtr\n-xmlSchemaGetSchemaBucketByTNS(xmlSchemaParserCtxtPtr pctxt,\n-                 const xmlChar *targetNamespace,\n-                 int imported)\n-{\n-    xmlSchemaBucketPtr cur;\n-    xmlSchemaItemListPtr list;\n-\n-    list = pctxt->constructor->buckets;\n-    if (list->nbItems == 0)\n-    return(NULL);\n-    else {\n-    int i;\n-    for (i = 0; i < list->nbItems; i++) {\n-        cur = (xmlSchemaBucketPtr) list->items[i];\n-        if ((! IS_BAD_SCHEMA_DOC(cur)) &&\n-        (cur->origTargetNamespace == targetNamespace) &&\n-        ((imported && cur->imported) ||\n-         ((!imported) && (!cur->imported))))\n-        return(cur);\n-    }\n-    }\n-    return(NULL);\n-}\n-\n-static int\n-xmlSchemaParseNewDocWithContext(xmlSchemaParserCtxtPtr pctxt,\n-             xmlSchemaPtr schema,\n-             xmlSchemaBucketPtr bucket)\n-{\n-    int oldFlags;\n-    xmlDocPtr oldDoc;\n-    xmlNodePtr node;\n-    int ret, oldErrs;\n-    xmlSchemaBucketPtr oldbucket = pctxt->constructor->bucket;\n-\n-    \/*\n-    * Save old values; reset the *main* schema.\n-    * URGENT TODO: This is not good; move the per-document information\n-    * to the parser. Get rid of passing the main schema to the\n-    * parsing functions.\n-    *\/\n-    oldFlags = schema->flags;\n-    oldDoc = schema->doc;\n-    if (schema->flags != 0)\n-    xmlSchemaClearSchemaDefaults(schema);\n-    schema->doc = bucket->doc;\n-    pctxt->schema = schema;\n-    \/*\n-    * Keep the current target namespace on the parser *not* on the\n-    * main schema.\n-    *\/\n-    pctxt->targetNamespace = bucket->targetNamespace;\n-    WXS_CONSTRUCTOR(pctxt)->bucket = bucket;\n-\n-    if ((bucket->targetNamespace != NULL) &&\n-    xmlStrEqual(bucket->targetNamespace, xmlSchemaNs)) {\n-    \/*\n-    * We are parsing the schema for schemas!\n-    *\/\n-    pctxt->isS4S = 1;\n-    }\n-    \/* Mark it as parsed, even if parsing fails. *\/\n-    bucket->parsed++;\n-    \/* Compile the schema doc. *\/\n-    node = xmlDocGetRootElement(bucket->doc);\n-    ret = xmlSchemaParseSchemaElement(pctxt, schema, node);\n-    if (ret != 0)\n-    goto exit;\n-    \/* An empty schema; just get out. *\/\n-    if (node->children == NULL)\n-    goto exit;\n-    oldErrs = pctxt->nberrors;\n-    ret = xmlSchemaParseSchemaTopLevel(pctxt, schema, node->children);\n-    if (ret != 0)\n-    goto exit;\n-    \/*\n-    * TODO: Not nice, but I'm not 100% sure we will get always an error\n-    * as a result of the above functions; so better rely on pctxt->err\n-    * as well.\n-    *\/\n-    if ((ret == 0) && (oldErrs != pctxt->nberrors)) {\n-    ret = pctxt->err;\n-    goto exit;\n-    }\n-\n-exit:\n-    WXS_CONSTRUCTOR(pctxt)->bucket = oldbucket;\n-    \/* Restore schema values. *\/\n-    schema->doc = oldDoc;\n-    schema->flags = oldFlags;\n-    return(ret);\n-}\n-\n-static int\n-xmlSchemaParseNewDoc(xmlSchemaParserCtxtPtr pctxt,\n-             xmlSchemaPtr schema,\n-             xmlSchemaBucketPtr bucket)\n-{\n-    xmlSchemaParserCtxtPtr newpctxt;\n-    int res = 0;\n-\n-    if (bucket == NULL)\n-    return(0);\n-    if (bucket->parsed) {\n-    PERROR_INT(\"xmlSchemaParseNewDoc\",\n-        \"reparsing a schema doc\");\n-    return(-1);\n-    }\n-    if (bucket->doc == NULL) {\n-    PERROR_INT(\"xmlSchemaParseNewDoc\",\n-        \"parsing a schema doc, but there's no doc\");\n-    return(-1);\n-    }\n-    if (pctxt->constructor == NULL) {\n-    PERROR_INT(\"xmlSchemaParseNewDoc\",\n-        \"no constructor\");\n-    return(-1);\n-    }\n-    \/* Create and init the temporary parser context. *\/\n-    newpctxt = xmlSchemaNewParserCtxtUseDict(\n-    (const char *) bucket->schemaLocation, pctxt->dict);\n-    if (newpctxt == NULL)\n-    return(-1);\n-    newpctxt->constructor = pctxt->constructor;\n-    \/*\n-    * TODO: Can we avoid that the parser knows about the main schema?\n-    * It would be better if he knows about the current schema bucket\n-    * only.\n-    *\/\n-    newpctxt->schema = schema;\n-    xmlSchemaSetParserErrors(newpctxt, pctxt->error, pctxt->warning,\n-    pctxt->errCtxt);\n-    xmlSchemaSetParserStructuredErrors(newpctxt, pctxt->serror,\n-    pctxt->errCtxt);\n-    newpctxt->counter = pctxt->counter;\n-\n-\n-    res = xmlSchemaParseNewDocWithContext(newpctxt, schema, bucket);\n-\n-    \/* Channel back errors and cleanup the temporary parser context. *\/\n-    if (res != 0)\n-    pctxt->err = res;\n-    pctxt->nberrors += newpctxt->nberrors;\n-    pctxt->counter = newpctxt->counter;\n-    newpctxt->constructor = NULL;\n-    \/* Free the parser context. *\/\n-    xmlSchemaFreeParserCtxt(newpctxt);\n-    return(res);\n-}\n-\n-static void\n-xmlSchemaSchemaRelationAddChild(xmlSchemaBucketPtr bucket,\n-                xmlSchemaSchemaRelationPtr rel)\n-{\n-    xmlSchemaSchemaRelationPtr cur = bucket->relations;\n-\n-    if (cur == NULL) {\n-    bucket->relations = rel;\n-    return;\n-    }\n-    while (cur->next != NULL)\n-    cur = cur->next;\n-    cur->next = rel;\n-}\n-\n-\n-static const xmlChar *\n-xmlSchemaBuildAbsoluteURI(xmlDictPtr dict, const xmlChar* location,\n-              xmlNodePtr ctxtNode)\n-{\n-    \/*\n-    * Build an absolute location URI.\n-    *\/\n-    if (location != NULL) {\n-    if (ctxtNode == NULL)\n-        return(location);\n-    else {\n-        xmlChar *base, *URI;\n-        const xmlChar *ret = NULL;\n-\n-        base = xmlNodeGetBase(ctxtNode->doc, ctxtNode);\n-        if (base == NULL) {\n-        URI = xmlBuildURI(location, ctxtNode->doc->URL);\n-        } else {\n-        URI = xmlBuildURI(location, base);\n-        xmlFree(base);\n-        }\n-        if (URI != NULL) {\n-        ret = xmlDictLookup(dict, URI, -1);\n-        xmlFree(URI);\n-        return(ret);\n-        }\n-    }\n-    }\n-    return(NULL);\n-}\n-\n-\n-\n-\/**\n- * xmlSchemaAddSchemaDoc:\n- * @pctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * Parse an included (and to-be-redefined) XML schema document.\n- *\n- * Returns 0 on success, a positive error code on errors and\n- *         -1 in case of an internal or API error.\n- *\/\n-\n-static int\n-xmlSchemaAddSchemaDoc(xmlSchemaParserCtxtPtr pctxt,\n-        int type, \/* import or include or redefine *\/\n-        const xmlChar *schemaLocation,\n-        xmlDocPtr schemaDoc,\n-        const char *schemaBuffer,\n-        int schemaBufferLen,\n-        xmlNodePtr invokingNode,\n-        const xmlChar *sourceTargetNamespace,\n-        const xmlChar *importNamespace,\n-        xmlSchemaBucketPtr *bucket)\n-{\n-    const xmlChar *targetNamespace = NULL;\n-    xmlSchemaSchemaRelationPtr relation = NULL;\n-    xmlDocPtr doc = NULL;\n-    int res = 0, err = 0, located = 0, preserveDoc = 0;\n-    xmlSchemaBucketPtr bkt = NULL;\n-\n-    if (bucket != NULL)\n-    *bucket = NULL;\n-\n-    switch (type) {\n-    case XML_SCHEMA_SCHEMA_IMPORT:\n-    case XML_SCHEMA_SCHEMA_MAIN:\n-        err = XML_SCHEMAP_SRC_IMPORT;\n-        break;\n-    case XML_SCHEMA_SCHEMA_INCLUDE:\n-        err = XML_SCHEMAP_SRC_INCLUDE;\n-        break;\n-    case XML_SCHEMA_SCHEMA_REDEFINE:\n-        err = XML_SCHEMAP_SRC_REDEFINE;\n-        break;\n-    }\n-\n-\n-    \/* Special handling for the main schema:\n-    * skip the location and relation logic and just parse the doc.\n-    * We need just a bucket to be returned in this case.\n-    *\/\n-    if ((type == XML_SCHEMA_SCHEMA_MAIN) || (! WXS_HAS_BUCKETS(pctxt)))\n-    goto doc_load;\n-\n-    \/* Note that we expect the location to be an absolute URI. *\/\n-    if (schemaLocation != NULL) {\n-    bkt = xmlSchemaGetSchemaBucket(pctxt, schemaLocation);\n-    if ((bkt != NULL) &&\n-        (pctxt->constructor->bucket == bkt)) {\n-        \/* Report self-imports\/inclusions\/redefinitions. *\/\n-\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt, err,\n-        invokingNode, NULL,\n-        \"The schema must not import\/include\/redefine itself\",\n-        NULL, NULL);\n-        goto exit;\n-    }\n-    }\n-    \/*\n-    * Create a relation for the graph of schemas.\n-    *\/\n-    relation = xmlSchemaSchemaRelationCreate();\n-    if (relation == NULL)\n-    return(-1);\n-    xmlSchemaSchemaRelationAddChild(pctxt->constructor->bucket,\n-    relation);\n-    relation->type = type;\n-\n-    \/*\n-    * Save the namespace import information.\n-    *\/\n-    if (WXS_IS_BUCKET_IMPMAIN(type)) {\n-    relation->importNamespace = importNamespace;\n-    if (schemaLocation == NULL) {\n-        \/*\n-        * No location; this is just an import of the namespace.\n-        * Note that we don't assign a bucket to the relation\n-        * in this case.\n-        *\/\n-        goto exit;\n-    }\n-    targetNamespace = importNamespace;\n-    }\n-\n-    \/* Did we already fetch the doc? *\/\n-    if (bkt != NULL) {\n-    if ((WXS_IS_BUCKET_IMPMAIN(type)) && (! bkt->imported)) {\n-        \/*\n-        * We included\/redefined and then try to import a schema,\n-        * but the new location provided for import was different.\n-        *\/\n-        if (schemaLocation == NULL)\n-        schemaLocation = BAD_CAST \"in_memory_buffer\";\n-        if (!xmlStrEqual(schemaLocation,\n-        bkt->schemaLocation)) {\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt, err,\n-            invokingNode, NULL,\n-            \"The schema document '%s' cannot be imported, since \"\n-            \"it was already included or redefined\",\n-            schemaLocation, NULL);\n-        goto exit;\n-        }\n-    } else if ((! WXS_IS_BUCKET_IMPMAIN(type)) && (bkt->imported)) {\n-        \/*\n-        * We imported and then try to include\/redefine a schema,\n-        * but the new location provided for the include\/redefine\n-        * was different.\n-        *\/\n-        if (schemaLocation == NULL)\n-        schemaLocation = BAD_CAST \"in_memory_buffer\";\n-        if (!xmlStrEqual(schemaLocation,\n-        bkt->schemaLocation)) {\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt, err,\n-            invokingNode, NULL,\n-            \"The schema document '%s' cannot be included or \"\n-            \"redefined, since it was already imported\",\n-            schemaLocation, NULL);\n-        goto exit;\n-        }\n-    }\n-    }\n-\n-    if (WXS_IS_BUCKET_IMPMAIN(type)) {\n-    \/*\n-    * Given that the schemaLocation [attribute] is only a hint, it is open\n-    * to applications to ignore all but the first <import> for a given\n-    * namespace, regardless of the `actual value` of schemaLocation, but\n-    * such a strategy risks missing useful information when new\n-    * schemaLocations are offered.\n-    *\n-    * We will use the first <import> that comes with a location.\n-    * Further <import>s *with* a location, will result in an error.\n-    * TODO: Better would be to just report a warning here, but\n-    * we'll try it this way until someone complains.\n-    *\n-    * Schema Document Location Strategy:\n-    * 3 Based on the namespace name, identify an existing schema document,\n-    * either as a resource which is an XML document or a <schema> element\n-    * information item, in some local schema repository;\n-    * 5 Attempt to resolve the namespace name to locate such a resource.\n-    *\n-    * NOTE: (3) and (5) are not supported.\n-    *\/\n-    if (bkt != NULL) {\n-        relation->bucket = bkt;\n-        goto exit;\n-    }\n-    bkt = xmlSchemaGetSchemaBucketByTNS(pctxt,\n-        importNamespace, 1);\n-\n-    if (bkt != NULL) {\n-        relation->bucket = bkt;\n-        if (bkt->schemaLocation == NULL) {\n-        \/* First given location of the schema; load the doc. *\/\n-        bkt->schemaLocation = schemaLocation;\n-        } else {\n-        if (!xmlStrEqual(schemaLocation,\n-            bkt->schemaLocation)) {\n-            \/*\n-            * Additional location given; just skip it.\n-            * URGENT TODO: We should report a warning here.\n-            * res = XML_SCHEMAP_SRC_IMPORT;\n-            *\/\n-            if (schemaLocation == NULL)\n-            schemaLocation = BAD_CAST \"in_memory_buffer\";\n-\n-            xmlSchemaCustomWarning(ACTXT_CAST pctxt,\n-            XML_SCHEMAP_WARN_SKIP_SCHEMA,\n-            invokingNode, NULL,\n-            \"Skipping import of schema located at '%s' for the \"\n-            \"namespace '%s', since this namespace was already \"\n-            \"imported with the schema located at '%s'\",\n-            schemaLocation, importNamespace, bkt->schemaLocation);\n-        }\n-        goto exit;\n-        }\n-    }\n-    \/*\n-    * No bucket + first location: load the doc and create a\n-    * bucket.\n-    *\/\n-    } else {\n-    \/* <include> and <redefine> *\/\n-    if (bkt != NULL) {\n-\n-        if ((bkt->origTargetNamespace == NULL) &&\n-        (bkt->targetNamespace != sourceTargetNamespace)) {\n-        xmlSchemaBucketPtr chamel;\n-\n-        \/*\n-        * Chameleon include\/redefine: skip loading only if it was\n-        * already build for the targetNamespace of the including\n-        * schema.\n-        *\/\n-        \/*\n-        * URGENT TODO: If the schema is a chameleon-include then copy\n-        * the components into the including schema and modify the\n-        * targetNamespace of those components, do nothing otherwise.\n-        * NOTE: This is currently worked-around by compiling the\n-        * chameleon for every distinct including targetNamespace; thus\n-        * not performant at the moment.\n-        * TODO: Check when the namespace in wildcards for chameleons\n-        * needs to be converted: before we built wildcard intersections\n-        * or after.\n-        *   Answer: after!\n-        *\/\n-        chamel = xmlSchemaGetChameleonSchemaBucket(pctxt,\n-            schemaLocation, sourceTargetNamespace);\n-        if (chamel != NULL) {\n-            \/* A fitting chameleon was already parsed; NOP. *\/\n-            relation->bucket = chamel;\n-            goto exit;\n-        }\n-        \/*\n-        * We need to parse the chameleon again for a different\n-        * targetNamespace.\n-        * CHAMELEON TODO: Optimize this by only parsing the\n-        * chameleon once, and then copying the components to\n-        * the new targetNamespace.\n-        *\/\n-        bkt = NULL;\n-        } else {\n-        relation->bucket = bkt;\n-        goto exit;\n-        }\n-    }\n-    }\n-    if ((bkt != NULL) && (bkt->doc != NULL)) {\n-    PERROR_INT(\"xmlSchemaAddSchemaDoc\",\n-        \"trying to load a schema doc, but a doc is already \"\n-        \"assigned to the schema bucket\");\n-    goto exit_failure;\n-    }\n-\n-doc_load:\n-    \/*\n-    * Load the document.\n-    *\/\n-    if (schemaDoc != NULL) {\n-    doc = schemaDoc;\n-    \/* Don' free this one, since it was provided by the caller. *\/\n-    preserveDoc = 1;\n-    \/* TODO: Does the context or the doc hold the location? *\/\n-    if (schemaDoc->URL != NULL)\n-        schemaLocation = xmlDictLookup(pctxt->dict,\n-        schemaDoc->URL, -1);\n-        else\n-        schemaLocation = BAD_CAST \"in_memory_buffer\";\n-    } else if ((schemaLocation != NULL) || (schemaBuffer != NULL)) {\n-    xmlParserCtxtPtr parserCtxt;\n-\n-    parserCtxt = xmlNewParserCtxt();\n-    if (parserCtxt == NULL) {\n-        xmlSchemaPErrMemory(NULL);\n-        goto exit_failure;\n-    }\n-\n-        if (pctxt->serror != NULL)\n-            xmlCtxtSetErrorHandler(parserCtxt, pctxt->serror, pctxt->errCtxt);\n-\n-    if ((pctxt->dict != NULL) && (parserCtxt->dict != NULL)) {\n-        \/*\n-        * TODO: Do we have to burden the schema parser dict with all\n-        * the content of the schema doc?\n-        *\/\n-        xmlDictFree(parserCtxt->dict);\n-        parserCtxt->dict = pctxt->dict;\n-        xmlDictReference(parserCtxt->dict);\n-    }\n-    if (schemaLocation != NULL) {\n-        \/* Parse from file. *\/\n-        doc = xmlCtxtReadFile(parserCtxt, (const char *) schemaLocation,\n-        NULL, SCHEMAS_PARSE_OPTIONS);\n-    } else if (schemaBuffer != NULL) {\n-        \/* Parse from memory buffer. *\/\n-        doc = xmlCtxtReadMemory(parserCtxt, schemaBuffer, schemaBufferLen,\n-        NULL, NULL, SCHEMAS_PARSE_OPTIONS);\n-        schemaLocation = BAD_CAST \"in_memory_buffer\";\n-        if (doc != NULL)\n-        doc->URL = xmlStrdup(schemaLocation);\n-    }\n-    \/*\n-    * For <import>:\n-    * 2.1 The referent is (a fragment of) a resource which is an\n-    * XML document (see clause 1.1), which in turn corresponds to\n-    * a <schema> element information item in a well-formed information\n-    * set, which in turn corresponds to a valid schema.\n-    * TODO: (2.1) fragments of XML documents are not supported.\n-    *\n-    * 2.2 The referent is a <schema> element information item in\n-    * a well-formed information set, which in turn corresponds\n-    * to a valid schema.\n-    * TODO: (2.2) is not supported.\n-    *\/\n-    if (doc == NULL) {\n-        const xmlError *lerr;\n-        lerr = xmlGetLastError();\n-        \/*\n-        * Check if this a parser error, or if the document could\n-        * just not be located.\n-        * TODO: Try to find specific error codes to react only on\n-        * localisation failures.\n-        *\/\n-        if ((lerr == NULL) || (lerr->domain != XML_FROM_IO)) {\n-        \/*\n-        * We assume a parser error here.\n-        *\/\n-        located = 1;\n-        \/* TODO: Error code ?? *\/\n-        res = XML_SCHEMAP_SRC_IMPORT_2_1;\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt, res,\n-            invokingNode, NULL,\n-            \"Failed to parse the XML resource '%s'\",\n-            schemaLocation, NULL);\n-        }\n-    }\n-    xmlFreeParserCtxt(parserCtxt);\n-    if ((doc == NULL) && located)\n-        goto exit_error;\n-    } else {\n-    xmlSchemaPErr(pctxt, NULL,\n-        XML_SCHEMAP_NOTHING_TO_PARSE,\n-        \"No information for parsing was provided with the \"\n-        \"given schema parser context.\\n\",\n-        NULL, NULL);\n-    goto exit_failure;\n-    }\n-    \/*\n-    * Preprocess the document.\n-    *\/\n-    if (doc != NULL) {\n-    xmlNodePtr docElem = NULL;\n-\n-    located = 1;\n-    docElem = xmlDocGetRootElement(doc);\n-    if (docElem == NULL) {\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt, XML_SCHEMAP_NOROOT,\n-        invokingNode, NULL,\n-        \"The document '%s' has no document element\",\n-        schemaLocation, NULL);\n-        goto exit_error;\n-    }\n-    \/*\n-    * Remove all the blank text nodes.\n-    *\/\n-    xmlSchemaCleanupDoc(pctxt, docElem);\n-    \/*\n-    * Check the schema's top level element.\n-    *\/\n-    if (!IS_SCHEMA(docElem, \"schema\")) {\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt, XML_SCHEMAP_NOT_SCHEMA,\n-        invokingNode, NULL,\n-        \"The XML document '%s' is not a schema document\",\n-        schemaLocation, NULL);\n-        goto exit_error;\n-    }\n-    \/*\n-    * Note that we don't apply a type check for the\n-    * targetNamespace value here.\n-    *\/\n-    targetNamespace = xmlSchemaGetProp(pctxt, docElem,\n-        \"targetNamespace\");\n-    }\n-\n-\/* after_doc_loading: *\/\n-    if ((bkt == NULL) && located) {\n-    \/* Only create a bucket if the schema was located. *\/\n-        bkt = xmlSchemaBucketCreate(pctxt, type,\n-        targetNamespace);\n-    if (bkt == NULL)\n-        goto exit_failure;\n-    }\n-    if (bkt != NULL) {\n-    bkt->schemaLocation = schemaLocation;\n-    bkt->located = located;\n-    if (doc != NULL) {\n-        bkt->doc = doc;\n-        bkt->targetNamespace = targetNamespace;\n-        bkt->origTargetNamespace = targetNamespace;\n-        if (preserveDoc)\n-        bkt->preserveDoc = 1;\n-    }\n-    if (WXS_IS_BUCKET_IMPMAIN(type))\n-        bkt->imported++;\n-        \/*\n-        * Add it to the graph of schemas.\n-        *\/\n-    if (relation != NULL)\n-        relation->bucket = bkt;\n-    }\n-\n-exit:\n-    \/*\n-    * Return the bucket explicitly; this is needed for the\n-    * main schema.\n-    *\/\n-    if (bucket != NULL)\n-    *bucket = bkt;\n-    return (0);\n-\n-exit_error:\n-    if ((doc != NULL) && (! preserveDoc)) {\n-    xmlFreeDoc(doc);\n-    if (bkt != NULL)\n-        bkt->doc = NULL;\n-    }\n-    return(pctxt->err);\n-\n-exit_failure:\n-    if ((doc != NULL) && (! preserveDoc)) {\n-    xmlFreeDoc(doc);\n-    if (bkt != NULL)\n-        bkt->doc = NULL;\n-    }\n-    return (-1);\n-}\n-\n-\/**\n- * xmlSchemaParseImport:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * parse a XML schema Import definition\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns 0 in case of success, a positive error code if\n- * not valid and -1 in case of an internal error.\n- *\/\n-static int\n-xmlSchemaParseImport(xmlSchemaParserCtxtPtr pctxt, xmlSchemaPtr schema,\n-                     xmlNodePtr node)\n-{\n-    xmlNodePtr child;\n-    const xmlChar *namespaceName = NULL, *schemaLocation = NULL;\n-    const xmlChar *thisTargetNamespace;\n-    xmlAttrPtr attr;\n-    int ret = 0;\n-    xmlSchemaBucketPtr bucket = NULL;\n-\n-    if ((pctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (-1);\n-\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"namespace\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"schemaLocation\"))) {\n-        xmlSchemaPIllegalAttrErr(pctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(pctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    \/*\n-    * Extract and validate attributes.\n-    *\/\n-    if (xmlSchemaPValAttr(pctxt, NULL, node,\n-    \"namespace\", xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),\n-    &namespaceName) != 0) {\n-    xmlSchemaPSimpleTypeErr(pctxt,\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        NULL, node,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),\n-        NULL, namespaceName, NULL, NULL, NULL);\n-    return (pctxt->err);\n-    }\n-\n-    if (xmlSchemaPValAttr(pctxt, NULL, node,\n-    \"schemaLocation\", xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),\n-    &schemaLocation) != 0) {\n-    xmlSchemaPSimpleTypeErr(pctxt,\n-        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-        NULL, node,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),\n-        NULL, schemaLocation, NULL, NULL, NULL);\n-    return (pctxt->err);\n-    }\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-        \/*\n-         * the annotation here is simply discarded ...\n-     * TODO: really?\n-         *\/\n-        child = child->next;\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(pctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?)\");\n-    }\n-    \/*\n-    * Apply additional constraints.\n-    *\n-    * Note that it is important to use the original @targetNamespace\n-    * (or none at all), to rule out imports of schemas _with_ a\n-    * @targetNamespace if the importing schema is a chameleon schema\n-    * (with no @targetNamespace).\n-    *\/\n-    thisTargetNamespace = WXS_BUCKET(pctxt)->origTargetNamespace;\n-    if (namespaceName != NULL) {\n-    \/*\n-    * 1.1 If the namespace [attribute] is present, then its `actual value`\n-    * must not match the `actual value` of the enclosing <schema>'s\n-    * targetNamespace [attribute].\n-    *\/\n-    if (xmlStrEqual(thisTargetNamespace, namespaceName)) {\n-        xmlSchemaPCustomErr(pctxt,\n-        XML_SCHEMAP_SRC_IMPORT_1_1,\n-        NULL, node,\n-        \"The value of the attribute 'namespace' must not match \"\n-        \"the target namespace '%s' of the importing schema\",\n-        thisTargetNamespace);\n-        return (pctxt->err);\n-    }\n-    } else {\n-    \/*\n-    * 1.2 If the namespace [attribute] is not present, then the enclosing\n-    * <schema> must have a targetNamespace [attribute].\n-    *\/\n-    if (thisTargetNamespace == NULL) {\n-        xmlSchemaPCustomErr(pctxt,\n-        XML_SCHEMAP_SRC_IMPORT_1_2,\n-        NULL, node,\n-        \"The attribute 'namespace' must be existent if \"\n-        \"the importing schema has no target namespace\",\n-        NULL);\n-        return (pctxt->err);\n-    }\n-    }\n-    \/*\n-    * Locate and acquire the schema document.\n-    *\/\n-    if (schemaLocation != NULL)\n-    schemaLocation = xmlSchemaBuildAbsoluteURI(pctxt->dict,\n-        schemaLocation, node);\n-    ret = xmlSchemaAddSchemaDoc(pctxt, XML_SCHEMA_SCHEMA_IMPORT,\n-    schemaLocation, NULL, NULL, 0, node, thisTargetNamespace,\n-    namespaceName, &bucket);\n-\n-    if (ret != 0)\n-    return(ret);\n-\n-    \/*\n-    * For <import>: \"It is *not* an error for the application\n-    * schema reference strategy to fail.\"\n-    * So just don't parse if no schema document was found.\n-    * Note that we will get no bucket if the schema could not be\n-    * located or if there was no schemaLocation.\n-    *\/\n-    if ((bucket == NULL) && (schemaLocation != NULL)) {\n-    xmlSchemaCustomWarning(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_WARN_UNLOCATED_SCHEMA,\n-        node, NULL,\n-        \"Failed to locate a schema at location '%s'. \"\n-        \"Skipping the import\", schemaLocation, NULL, NULL);\n-    }\n-\n-    if ((bucket != NULL) && CAN_PARSE_SCHEMA(bucket)) {\n-    ret = xmlSchemaParseNewDoc(pctxt, schema, bucket);\n-    }\n-\n-    return (ret);\n-}\n-\n-static int\n-xmlSchemaParseIncludeOrRedefineAttrs(xmlSchemaParserCtxtPtr pctxt,\n-                     xmlSchemaPtr schema,\n-                     xmlNodePtr node,\n-                     xmlChar **schemaLocation,\n-                     int type)\n-{\n-    xmlAttrPtr attr;\n-\n-    if ((pctxt == NULL) || (schema == NULL) || (node == NULL) ||\n-    (schemaLocation == NULL))\n-        return (-1);\n-\n-    *schemaLocation = NULL;\n-    \/*\n-    * Check for illegal attributes.\n-    * Applies for both <include> and <redefine>.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"schemaLocation\"))) {\n-        xmlSchemaPIllegalAttrErr(pctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(pctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    xmlSchemaPValAttrID(pctxt, node, BAD_CAST \"id\");\n-    \/*\n-    * Preliminary step, extract the URI-Reference and make an URI\n-    * from the base.\n-    *\/\n-    \/*\n-    * Attribute \"schemaLocation\" is mandatory.\n-    *\/\n-    attr = xmlSchemaGetPropNode(node, \"schemaLocation\");\n-    if (attr != NULL) {\n-        xmlChar *base = NULL;\n-        xmlChar *uri = NULL;\n-\n-    if (xmlSchemaPValAttrNode(pctxt, NULL, attr,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),\n-        (const xmlChar **) schemaLocation) != 0)\n-        goto exit_error;\n-    base = xmlNodeGetBase(node->doc, node);\n-    if (base == NULL) {\n-        uri = xmlBuildURI(*schemaLocation, node->doc->URL);\n-    } else {\n-        uri = xmlBuildURI(*schemaLocation, base);\n-        xmlFree(base);\n-    }\n-    if (uri == NULL) {\n-        PERROR_INT(\"xmlSchemaParseIncludeOrRedefine\",\n-        \"could not build an URI from the schemaLocation\")\n-        goto exit_failure;\n-    }\n-    (*schemaLocation) = (xmlChar *) xmlDictLookup(pctxt->dict, uri, -1);\n-    xmlFree(uri);\n-    } else {\n-    xmlSchemaPMissingAttrErr(pctxt,\n-        XML_SCHEMAP_S4S_ATTR_MISSING,\n-        NULL, node, \"schemaLocation\", NULL);\n-    goto exit_error;\n-    }\n-    \/*\n-    * Report self-inclusion and self-redefinition.\n-    *\/\n-    if (xmlStrEqual(*schemaLocation, pctxt->URL)) {\n-    if (type == XML_SCHEMA_SCHEMA_REDEFINE) {\n-        xmlSchemaPCustomErr(pctxt,\n-        XML_SCHEMAP_SRC_REDEFINE,\n-        NULL, node,\n-        \"The schema document '%s' cannot redefine itself.\",\n-        *schemaLocation);\n-    } else {\n-        xmlSchemaPCustomErr(pctxt,\n-        XML_SCHEMAP_SRC_INCLUDE,\n-        NULL, node,\n-        \"The schema document '%s' cannot include itself.\",\n-        *schemaLocation);\n-    }\n-    goto exit_error;\n-    }\n-\n-    return(0);\n-exit_error:\n-    return(pctxt->err);\n-exit_failure:\n-    return(-1);\n-}\n-\n-static int\n-xmlSchemaParseIncludeOrRedefine(xmlSchemaParserCtxtPtr pctxt,\n-                xmlSchemaPtr schema,\n-                xmlNodePtr node,\n-                int type)\n-{\n-    xmlNodePtr child = NULL;\n-    const xmlChar *schemaLocation = NULL;\n-    int res = 0; \/* hasRedefinitions = 0 *\/\n-    int isChameleon = 0, wasChameleon = 0;\n-    xmlSchemaBucketPtr bucket = NULL;\n-\n-    if ((pctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (-1);\n-\n-    \/*\n-    * Parse attributes. Note that the returned schemaLocation will\n-    * be already converted to an absolute URI.\n-    *\/\n-    res = xmlSchemaParseIncludeOrRedefineAttrs(pctxt, schema,\n-    node, (xmlChar **) (&schemaLocation), type);\n-    if (res != 0)\n-    return(res);\n-    \/*\n-    * Load and add the schema document.\n-    *\/\n-    res = xmlSchemaAddSchemaDoc(pctxt, type, schemaLocation, NULL,\n-    NULL, 0, node, pctxt->targetNamespace, NULL, &bucket);\n-    if (res != 0)\n-    return(res);\n-    \/*\n-    * If we get no schema bucket back, then this means that the schema\n-    * document could not be located or was broken XML or was not\n-    * a schema document.\n-    *\/\n-    if ((bucket == NULL) || (bucket->doc == NULL)) {\n-    if (type == XML_SCHEMA_SCHEMA_INCLUDE) {\n-        \/*\n-        * WARNING for <include>:\n-        * We will raise an error if the schema cannot be located\n-        * for inclusions, since the that was the feedback from the\n-        * schema people. I.e. the following spec piece will *not* be\n-        * satisfied:\n-        * SPEC src-include: \"It is not an error for the `actual value` of the\n-        * schemaLocation [attribute] to fail to resolve it all, in which\n-        * case no corresponding inclusion is performed.\n-        * So do we need a warning report here?\"\n-        *\/\n-        res = XML_SCHEMAP_SRC_INCLUDE;\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt, res,\n-        node, NULL,\n-        \"Failed to load the document '%s' for inclusion\",\n-        schemaLocation, NULL);\n-    } else {\n-        \/*\n-        * NOTE: This was changed to raise an error even if no redefinitions\n-        * are specified.\n-        *\n-        * SPEC src-redefine (1)\n-        * \"If there are any element information items among the [children]\n-        * other than <annotation> then the `actual value` of the\n-        * schemaLocation [attribute] must successfully resolve.\"\n-        * TODO: Ask the WG if a the location has always to resolve\n-        * here as well!\n-        *\/\n-        res = XML_SCHEMAP_SRC_REDEFINE;\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt, res,\n-        node, NULL,\n-        \"Failed to load the document '%s' for redefinition\",\n-        schemaLocation, NULL);\n-    }\n-    } else {\n-    \/*\n-    * Check targetNamespace sanity before parsing the new schema.\n-    * TODO: Note that we won't check further content if the\n-    * targetNamespace was bad.\n-    *\/\n-    if (bucket->origTargetNamespace != NULL) {\n-        \/*\n-        * SPEC src-include (2.1)\n-        * \"SII has a targetNamespace [attribute], and its `actual\n-        * value` is identical to the `actual value` of the targetNamespace\n-        * [attribute] of SII' (which must have such an [attribute]).\"\n-        *\/\n-        if (pctxt->targetNamespace == NULL) {\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-            XML_SCHEMAP_SRC_INCLUDE,\n-            node, NULL,\n-            \"The target namespace of the included\/redefined schema \"\n-            \"'%s' has to be absent, since the including\/redefining \"\n-            \"schema has no target namespace\",\n-            schemaLocation, NULL);\n-        goto exit_error;\n-        } else if (!xmlStrEqual(bucket->origTargetNamespace,\n-        pctxt->targetNamespace)) {\n-        \/* TODO: Change error function. *\/\n-        xmlSchemaPCustomErrExt(pctxt,\n-            XML_SCHEMAP_SRC_INCLUDE,\n-            NULL, node,\n-            \"The target namespace '%s' of the included\/redefined \"\n-            \"schema '%s' differs from '%s' of the \"\n-            \"including\/redefining schema\",\n-            bucket->origTargetNamespace, schemaLocation,\n-            pctxt->targetNamespace);\n-        goto exit_error;\n-        }\n-    } else if (pctxt->targetNamespace != NULL) {\n-        \/*\n-        * Chameleons: the original target namespace will\n-        * differ from the resulting namespace.\n-        *\/\n-        isChameleon = 1;\n-        bucket->targetNamespace = pctxt->targetNamespace;\n-    }\n-    }\n-    \/*\n-    * Parse the schema.\n-    *\/\n-    if (bucket && (!bucket->parsed) && (bucket->doc != NULL)) {\n-    if (isChameleon) {\n-        \/* TODO: Get rid of this flag on the schema itself. *\/\n-        if ((schema->flags & XML_SCHEMAS_INCLUDING_CONVERT_NS) == 0) {\n-        schema->flags |= XML_SCHEMAS_INCLUDING_CONVERT_NS;\n-        } else\n-        wasChameleon = 1;\n-    }\n-    xmlSchemaParseNewDoc(pctxt, schema, bucket);\n-    \/* Restore chameleon flag. *\/\n-    if (isChameleon && (!wasChameleon))\n-        schema->flags ^= XML_SCHEMAS_INCLUDING_CONVERT_NS;\n-    }\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (type == XML_SCHEMA_SCHEMA_REDEFINE) {\n-    \/*\n-    * Parse (simpleType | complexType | group | attributeGroup))*\n-    *\/\n-    pctxt->redefined = bucket;\n-    \/*\n-    * How to proceed if the redefined schema was not located?\n-    *\/\n-    pctxt->isRedefine = 1;\n-    while (IS_SCHEMA(child, \"annotation\") ||\n-        IS_SCHEMA(child, \"simpleType\") ||\n-        IS_SCHEMA(child, \"complexType\") ||\n-        IS_SCHEMA(child, \"group\") ||\n-        IS_SCHEMA(child, \"attributeGroup\")) {\n-        if (IS_SCHEMA(child, \"annotation\")) {\n-        \/*\n-        * TODO: discard or not?\n-        *\/\n-        } else if (IS_SCHEMA(child, \"simpleType\")) {\n-        xmlSchemaParseSimpleType(pctxt, schema, child, 1);\n-        } else if (IS_SCHEMA(child, \"complexType\")) {\n-        xmlSchemaParseComplexType(pctxt, schema, child, 1);\n-        \/* hasRedefinitions = 1; *\/\n-        } else if (IS_SCHEMA(child, \"group\")) {\n-        \/* hasRedefinitions = 1; *\/\n-        xmlSchemaParseModelGroupDefinition(pctxt,\n-            schema, child);\n-        } else if (IS_SCHEMA(child, \"attributeGroup\")) {\n-        \/* hasRedefinitions = 1; *\/\n-        xmlSchemaParseAttributeGroupDefinition(pctxt, schema,\n-            child);\n-        }\n-        child = child->next;\n-    }\n-    pctxt->redefined = NULL;\n-    pctxt->isRedefine = 0;\n-    } else {\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-        \/*\n-        * TODO: discard or not?\n-        *\/\n-        child = child->next;\n-    }\n-    }\n-    if (child != NULL) {\n-    res = XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED;\n-    if (type == XML_SCHEMA_SCHEMA_REDEFINE) {\n-        xmlSchemaPContentErr(pctxt, res,\n-        NULL, node, child, NULL,\n-        \"(annotation | (simpleType | complexType | group | attributeGroup))*\");\n-    } else {\n-         xmlSchemaPContentErr(pctxt, res,\n-        NULL, node, child, NULL,\n-        \"(annotation?)\");\n-    }\n-    }\n-    return(res);\n-\n-exit_error:\n-    return(pctxt->err);\n-}\n-\n-static int\n-xmlSchemaParseRedefine(xmlSchemaParserCtxtPtr pctxt, xmlSchemaPtr schema,\n-                       xmlNodePtr node)\n-{\n-    int res;\n-#ifndef ENABLE_REDEFINE\n-    TODO\n-    return(0);\n-#endif\n-    res = xmlSchemaParseIncludeOrRedefine(pctxt, schema, node,\n-    XML_SCHEMA_SCHEMA_REDEFINE);\n-    if (res != 0)\n-    return(res);\n-    return(0);\n-}\n-\n-static int\n-xmlSchemaParseInclude(xmlSchemaParserCtxtPtr pctxt, xmlSchemaPtr schema,\n-                       xmlNodePtr node)\n-{\n-    int res;\n-\n-    res = xmlSchemaParseIncludeOrRedefine(pctxt, schema, node,\n-    XML_SCHEMA_SCHEMA_INCLUDE);\n-    if (res != 0)\n-    return(res);\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaParseModelGroup:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- * @type: the \"compositor\" type\n- * @particleNeeded: if a a model group with a particle\n- *\n- * parse a XML schema Sequence definition.\n- * Applies parts of:\n- *   Schema Representation Constraint:\n- *     Redefinition Constraints and Semantics (src-redefine)\n- *     (6.1), (6.1.1), (6.1.2)\n- *\n- *   Schema Component Constraint:\n- *     All Group Limited (cos-all-limited) (2)\n- *     TODO: Actually this should go to component-level checks,\n- *     but is done here due to performance. Move it to an other layer\n- *     is schema construction via an API is implemented.\n- *\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns -1 in case of error, 0 if the declaration is improper and\n- *         1 in case of success.\n- *\/\n-static xmlSchemaTreeItemPtr\n-xmlSchemaParseModelGroup(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-             xmlNodePtr node, xmlSchemaTypeType type,\n-             int withParticle)\n-{\n-    xmlSchemaModelGroupPtr item;\n-    xmlSchemaParticlePtr particle = NULL;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-    int min = 1, max = 1, isElemRef, hasRefs = 0;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-    \/*\n-    * Create a model group with the given compositor.\n-    *\/\n-    item = xmlSchemaAddModelGroup(ctxt, schema, type, node);\n-    if (item == NULL)\n-    return (NULL);\n-\n-    if (withParticle) {\n-    if (type == XML_SCHEMA_TYPE_ALL) {\n-        min = xmlGetMinOccurs(ctxt, node, 0, 1, 1, \"(0 | 1)\");\n-        max = xmlGetMaxOccurs(ctxt, node, 1, 1, 1, \"1\");\n-    } else {\n-        \/* choice + sequence *\/\n-        min = xmlGetMinOccurs(ctxt, node, 0, -1, 1, \"xs:nonNegativeInteger\");\n-        max = xmlGetMaxOccurs(ctxt, node, 0, UNBOUNDED, 1,\n-        \"(xs:nonNegativeInteger | unbounded)\");\n-    }\n-    xmlSchemaPCheckParticleCorrect_2(ctxt, NULL, node, min, max);\n-    \/*\n-    * Create a particle\n-    *\/\n-    particle = xmlSchemaAddParticle(ctxt, node, min, max);\n-    if (particle == NULL)\n-        return (NULL);\n-    particle->children = (xmlSchemaTreeItemPtr) item;\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-        if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-            (!xmlStrEqual(attr->name, BAD_CAST \"maxOccurs\")) &&\n-            (!xmlStrEqual(attr->name, BAD_CAST \"minOccurs\"))) {\n-            xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-        } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-        attr = attr->next;\n-    }\n-    } else {\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-        if (attr->ns == NULL) {\n-        if (!xmlStrEqual(attr->name, BAD_CAST \"id\")) {\n-            xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-        } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-        attr = attr->next;\n-    }\n-    }\n-\n-    \/*\n-    * Extract and validate attributes.\n-    *\/\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-        item->annot = xmlSchemaParseAnnotation(ctxt, child, 1);\n-        child = child->next;\n-    }\n-    if (type == XML_SCHEMA_TYPE_ALL) {\n-    xmlSchemaParticlePtr part, last = NULL;\n-\n-    while (IS_SCHEMA(child, \"element\")) {\n-        part = (xmlSchemaParticlePtr) xmlSchemaParseElement(ctxt,\n-        schema, child, &isElemRef, 0);\n-        \/*\n-        * SPEC cos-all-limited (2)\n-        * \"The {max occurs} of all the particles in the {particles}\n-        * of the ('all') group must be 0 or 1.\n-        *\/\n-        if (part != NULL) {\n-        if (isElemRef)\n-            hasRefs++;\n-        if (part->minOccurs > 1) {\n-            xmlSchemaPCustomErr(ctxt,\n-            XML_SCHEMAP_COS_ALL_LIMITED,\n-            NULL, child,\n-            \"Invalid value for minOccurs (must be 0 or 1)\",\n-            NULL);\n-            \/* Reset to 1. *\/\n-            part->minOccurs = 1;\n-        }\n-        if (part->maxOccurs > 1) {\n-            xmlSchemaPCustomErr(ctxt,\n-            XML_SCHEMAP_COS_ALL_LIMITED,\n-            NULL, child,\n-            \"Invalid value for maxOccurs (must be 0 or 1)\",\n-            NULL);\n-            \/* Reset to 1. *\/\n-            part->maxOccurs = 1;\n-        }\n-        if (last == NULL)\n-            item->children = (xmlSchemaTreeItemPtr) part;\n-        else\n-            last->next = (xmlSchemaTreeItemPtr) part;\n-        last = part;\n-        }\n-        child = child->next;\n-    }\n-    if (child != NULL) {\n-        xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?, (annotation?, element*)\");\n-    }\n-    } else {\n-    \/* choice + sequence *\/\n-    xmlSchemaTreeItemPtr part = NULL, last = NULL;\n-\n-    while ((IS_SCHEMA(child, \"element\")) ||\n-        (IS_SCHEMA(child, \"group\")) ||\n-        (IS_SCHEMA(child, \"any\")) ||\n-        (IS_SCHEMA(child, \"choice\")) ||\n-        (IS_SCHEMA(child, \"sequence\"))) {\n-\n-        if (IS_SCHEMA(child, \"element\")) {\n-        part = (xmlSchemaTreeItemPtr)\n-            xmlSchemaParseElement(ctxt, schema, child, &isElemRef, 0);\n-        if (part && isElemRef)\n-            hasRefs++;\n-        } else if (IS_SCHEMA(child, \"group\")) {\n-        part =\n-            xmlSchemaParseModelGroupDefRef(ctxt, schema, child);\n-        if (part != NULL)\n-            hasRefs++;\n-        \/*\n-        * Handle redefinitions.\n-        *\/\n-        if (ctxt->isRedefine && ctxt->redef &&\n-            (ctxt->redef->item->type == XML_SCHEMA_TYPE_GROUP) &&\n-            part && part->children)\n-        {\n-            if ((xmlSchemaGetQNameRefName(part->children) ==\n-                ctxt->redef->refName) &&\n-            (xmlSchemaGetQNameRefTargetNs(part->children) ==\n-                ctxt->redef->refTargetNs))\n-            {\n-            \/*\n-            * SPEC src-redefine:\n-            * (6.1) \"If it has a <group> among its contents at\n-            * some level the `actual value` of whose ref\n-            * [attribute] is the same as the `actual value` of\n-            * its own name attribute plus target namespace, then\n-            * all of the following must be true:\"\n-            * (6.1.1) \"It must have exactly one such group.\"\n-            *\/\n-            if (ctxt->redefCounter != 0) {\n-                xmlChar *str = NULL;\n-\n-                xmlSchemaCustomErr(ACTXT_CAST ctxt,\n-                XML_SCHEMAP_SRC_REDEFINE, child, NULL,\n-                \"The redefining model group definition \"\n-                \"'%s' must not contain more than one \"\n-                \"reference to the redefined definition\",\n-                xmlSchemaFormatQName(&str,\n-                    ctxt->redef->refTargetNs,\n-                    ctxt->redef->refName),\n-                NULL);\n-                FREE_AND_NULL(str)\n-                part = NULL;\n-            } else if (((WXS_PARTICLE(part))->minOccurs != 1) ||\n-                ((WXS_PARTICLE(part))->maxOccurs != 1))\n-            {\n-                xmlChar *str = NULL;\n-                \/*\n-                * SPEC src-redefine:\n-                * (6.1.2) \"The `actual value` of both that\n-                * group's minOccurs and maxOccurs [attribute]\n-                * must be 1 (or `absent`).\n-                *\/\n-                xmlSchemaCustomErr(ACTXT_CAST ctxt,\n-                XML_SCHEMAP_SRC_REDEFINE, child, NULL,\n-                \"The redefining model group definition \"\n-                \"'%s' must not contain a reference to the \"\n-                \"redefined definition with a \"\n-                \"maxOccurs\/minOccurs other than 1\",\n-                xmlSchemaFormatQName(&str,\n-                    ctxt->redef->refTargetNs,\n-                    ctxt->redef->refName),\n-                NULL);\n-                FREE_AND_NULL(str)\n-                part = NULL;\n-            }\n-            ctxt->redef->reference = WXS_BASIC_CAST part;\n-            ctxt->redefCounter++;\n-            }\n-        }\n-        } else if (IS_SCHEMA(child, \"any\")) {\n-        part = (xmlSchemaTreeItemPtr)\n-            xmlSchemaParseAny(ctxt, schema, child);\n-        } else if (IS_SCHEMA(child, \"choice\")) {\n-        part = xmlSchemaParseModelGroup(ctxt, schema, child,\n-            XML_SCHEMA_TYPE_CHOICE, 1);\n-        } else if (IS_SCHEMA(child, \"sequence\")) {\n-        part = xmlSchemaParseModelGroup(ctxt, schema, child,\n-            XML_SCHEMA_TYPE_SEQUENCE, 1);\n-        }\n-        if (part != NULL) {\n-        if (last == NULL)\n-            item->children = part;\n-        else\n-            last->next = part;\n-        last = part;\n-        }\n-        child = child->next;\n-    }\n-    if (child != NULL) {\n-        xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?, (element | group | choice | sequence | any)*)\");\n-    }\n-    }\n-    if ((max == 0) && (min == 0))\n-    return (NULL);\n-    if (hasRefs) {\n-    \/*\n-    * We need to resolve references.\n-    *\/\n-    WXS_ADD_PENDING(ctxt, item);\n-    }\n-    if (withParticle)\n-    return ((xmlSchemaTreeItemPtr) particle);\n-    else\n-    return ((xmlSchemaTreeItemPtr) item);\n-}\n-\n-\/**\n- * xmlSchemaParseRestriction:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * parse a XML schema Restriction definition\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the type definition or NULL in case of error\n- *\/\n-static xmlSchemaTypePtr\n-xmlSchemaParseRestriction(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                          xmlNodePtr node, xmlSchemaTypeType parentType)\n-{\n-    xmlSchemaTypePtr type;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-    \/* Not a component, don't create it. *\/\n-    type = ctxt->ctxtType;\n-    type->flags |= XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION;\n-\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"base\"))) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    \/*\n-    * Extract and validate attributes.\n-    *\/\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-    \/*\n-    * Attribute\n-    *\/\n-    \/*\n-    * Extract the base type. The \"base\" attribute is mandatory if inside\n-    * a complex type or if redefining.\n-    *\n-    * SPEC (1.2) \"...otherwise (<restriction> has no <simpleType> \"\n-    * among its [children]), the simple type definition which is\n-    * the {content type} of the type definition `resolved` to by\n-    * the `actual value` of the base [attribute]\"\n-    *\/\n-    if (xmlSchemaPValAttrQName(ctxt, schema, NULL, node, \"base\",\n-    &(type->baseNs), &(type->base)) == 0)\n-    {\n-    if ((type->base == NULL) && (type->type == XML_SCHEMA_TYPE_COMPLEX)) {\n-        xmlSchemaPMissingAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_MISSING,\n-        NULL, node, \"base\", NULL);\n-    } else if ((ctxt->isRedefine) &&\n-        (type->flags & XML_SCHEMAS_TYPE_GLOBAL))\n-    {\n-        if (type->base == NULL) {\n-        xmlSchemaPMissingAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_MISSING,\n-            NULL, node, \"base\", NULL);\n-        } else if ((! xmlStrEqual(type->base, type->name)) ||\n-        (! xmlStrEqual(type->baseNs, type->targetNamespace)))\n-        {\n-        xmlChar *str1 = NULL, *str2 = NULL;\n-        \/*\n-        * REDEFINE: SPEC src-redefine (5)\n-        * \"Within the [children], each <simpleType> must have a\n-        * <restriction> among its [children] ... the `actual value` of\n-        * whose base [attribute] must be the same as the `actual value`\n-        * of its own name attribute plus target namespace;\"\n-        *\/\n-        xmlSchemaPCustomErrExt(ctxt, XML_SCHEMAP_SRC_REDEFINE,\n-            NULL, node, \"This is a redefinition, but the QName \"\n-            \"value '%s' of the 'base' attribute does not match the \"\n-            \"type's designation '%s'\",\n-            xmlSchemaFormatQName(&str1, type->baseNs, type->base),\n-            xmlSchemaFormatQName(&str2, type->targetNamespace,\n-            type->name), NULL);\n-        FREE_AND_NULL(str1);\n-        FREE_AND_NULL(str2);\n-        \/* Avoid confusion and erase the values. *\/\n-        type->base = NULL;\n-        type->baseNs = NULL;\n-        }\n-    }\n-    }\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-    \/*\n-    * Add the annotation to the simple type ancestor.\n-    *\/\n-    xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,\n-        xmlSchemaParseAnnotation(ctxt, child, 1));\n-        child = child->next;\n-    }\n-    if (parentType == XML_SCHEMA_TYPE_SIMPLE) {\n-    \/*\n-    * Corresponds to <simpleType><restriction><simpleType>.\n-    *\/\n-    if (IS_SCHEMA(child, \"simpleType\")) {\n-        if (type->base != NULL) {\n-        \/*\n-        * src-restriction-base-or-simpleType\n-        * Either the base [attribute] or the simpleType [child] of the\n-        * <restriction> element must be present, but not both.\n-        *\/\n-        xmlSchemaPContentErr(ctxt,\n-            XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,\n-            NULL, node, child,\n-            \"The attribute 'base' and the <simpleType> child are \"\n-            \"mutually exclusive\", NULL);\n-        } else {\n-        type->baseType = (xmlSchemaTypePtr)\n-            xmlSchemaParseSimpleType(ctxt, schema, child, 0);\n-        }\n-        child = child->next;\n-    } else if (type->base == NULL) {\n-        xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,\n-        NULL, node, child,\n-        \"Either the attribute 'base' or a <simpleType> child \"\n-        \"must be present\", NULL);\n-    }\n-    } else if (parentType == XML_SCHEMA_TYPE_COMPLEX_CONTENT) {\n-    \/*\n-    * Corresponds to <complexType><complexContent><restriction>...\n-    * followed by:\n-    *\n-    * Model groups <all>, <choice> and <sequence>.\n-    *\/\n-    if (IS_SCHEMA(child, \"all\")) {\n-        type->subtypes = (xmlSchemaTypePtr)\n-        xmlSchemaParseModelGroup(ctxt, schema, child,\n-            XML_SCHEMA_TYPE_ALL, 1);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"choice\")) {\n-        type->subtypes = (xmlSchemaTypePtr)\n-        xmlSchemaParseModelGroup(ctxt,\n-            schema, child, XML_SCHEMA_TYPE_CHOICE, 1);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"sequence\")) {\n-        type->subtypes = (xmlSchemaTypePtr)\n-        xmlSchemaParseModelGroup(ctxt, schema, child,\n-            XML_SCHEMA_TYPE_SEQUENCE, 1);\n-        child = child->next;\n-    \/*\n-    * Model group reference <group>.\n-    *\/\n-    } else if (IS_SCHEMA(child, \"group\")) {\n-        type->subtypes = (xmlSchemaTypePtr)\n-        xmlSchemaParseModelGroupDefRef(ctxt, schema, child);\n-        \/*\n-        * Note that the reference will be resolved in\n-        * xmlSchemaResolveTypeReferences();\n-        *\/\n-        child = child->next;\n-    }\n-    } else if (parentType == XML_SCHEMA_TYPE_SIMPLE_CONTENT) {\n-    \/*\n-    * Corresponds to <complexType><simpleContent><restriction>...\n-    *\n-    * \"1.1 the simple type definition corresponding to the <simpleType>\n-    * among the [children] of <restriction> if there is one;\"\n-    *\/\n-    if (IS_SCHEMA(child, \"simpleType\")) {\n-        \/*\n-        * We will store the to-be-restricted simple type in\n-        * type->contentTypeDef *temporarily*.\n-        *\/\n-        type->contentTypeDef = (xmlSchemaTypePtr)\n-        xmlSchemaParseSimpleType(ctxt, schema, child, 0);\n-        if ( type->contentTypeDef == NULL)\n-        return (NULL);\n-        child = child->next;\n-    }\n-    }\n-\n-    if ((parentType == XML_SCHEMA_TYPE_SIMPLE) ||\n-    (parentType == XML_SCHEMA_TYPE_SIMPLE_CONTENT)) {\n-    xmlSchemaFacetPtr facet, lastfacet = NULL;\n-    \/*\n-    * Corresponds to <complexType><simpleContent><restriction>...\n-    * <simpleType><restriction>...\n-    *\/\n-\n-    \/*\n-    * Add the facets to the simple type ancestor.\n-    *\/\n-    \/*\n-    * TODO: Datatypes: 4.1.3 Constraints on XML Representation of\n-    * Simple Type Definition Schema Representation Constraint:\n-    * *Single Facet Value*\n-    *\/\n-    while ((IS_SCHEMA(child, \"minInclusive\")) ||\n-        (IS_SCHEMA(child, \"minExclusive\")) ||\n-        (IS_SCHEMA(child, \"maxInclusive\")) ||\n-        (IS_SCHEMA(child, \"maxExclusive\")) ||\n-        (IS_SCHEMA(child, \"totalDigits\")) ||\n-        (IS_SCHEMA(child, \"fractionDigits\")) ||\n-        (IS_SCHEMA(child, \"pattern\")) ||\n-        (IS_SCHEMA(child, \"enumeration\")) ||\n-        (IS_SCHEMA(child, \"whiteSpace\")) ||\n-        (IS_SCHEMA(child, \"length\")) ||\n-        (IS_SCHEMA(child, \"maxLength\")) ||\n-        (IS_SCHEMA(child, \"minLength\"))) {\n-        facet = xmlSchemaParseFacet(ctxt, schema, child);\n-        if (facet != NULL) {\n-        if (lastfacet == NULL)\n-            type->facets = facet;\n-        else\n-            lastfacet->next = facet;\n-        lastfacet = facet;\n-        lastfacet->next = NULL;\n-        }\n-        child = child->next;\n-    }\n-    \/*\n-    * Create links for derivation and validation.\n-    *\/\n-    if (type->facets != NULL) {\n-        xmlSchemaFacetLinkPtr facetLink, lastFacetLink = NULL;\n-\n-        facet = type->facets;\n-        do {\n-        facetLink = (xmlSchemaFacetLinkPtr)\n-            xmlMalloc(sizeof(xmlSchemaFacetLink));\n-        if (facetLink == NULL) {\n-            xmlSchemaPErrMemory(ctxt);\n-            xmlFree(facetLink);\n-            return (NULL);\n-        }\n-        facetLink->facet = facet;\n-        facetLink->next = NULL;\n-        if (lastFacetLink == NULL)\n-            type->facetSet = facetLink;\n-        else\n-            lastFacetLink->next = facetLink;\n-        lastFacetLink = facetLink;\n-        facet = facet->next;\n-        } while (facet != NULL);\n-    }\n-    }\n-    if (type->type == XML_SCHEMA_TYPE_COMPLEX) {\n-    \/*\n-    * Attribute uses\/declarations.\n-    *\/\n-    if (xmlSchemaParseLocalAttributes(ctxt, schema, &child,\n-        (xmlSchemaItemListPtr *) &(type->attrUses),\n-        XML_SCHEMA_TYPE_RESTRICTION, NULL) == -1)\n-        return(NULL);\n-    \/*\n-    * Attribute wildcard.\n-    *\/\n-    if (IS_SCHEMA(child, \"anyAttribute\")) {\n-        type->attributeWildcard =\n-        xmlSchemaParseAnyAttribute(ctxt, schema, child);\n-        child = child->next;\n-    }\n-    }\n-    if (child != NULL) {\n-    if (parentType == XML_SCHEMA_TYPE_COMPLEX_CONTENT) {\n-        xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"annotation?, (group | all | choice | sequence)?, \"\n-        \"((attribute | attributeGroup)*, anyAttribute?))\");\n-    } else if (parentType == XML_SCHEMA_TYPE_SIMPLE_CONTENT) {\n-         xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?, (simpleType?, (minExclusive | minInclusive | \"\n-        \"maxExclusive | maxInclusive | totalDigits | fractionDigits | \"\n-        \"length | minLength | maxLength | enumeration | whiteSpace | \"\n-        \"pattern)*)?, ((attribute | attributeGroup)*, anyAttribute?))\");\n-    } else {\n-        \/* Simple type *\/\n-        xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?, (simpleType?, (minExclusive | minInclusive | \"\n-        \"maxExclusive | maxInclusive | totalDigits | fractionDigits | \"\n-        \"length | minLength | maxLength | enumeration | whiteSpace | \"\n-        \"pattern)*))\");\n-    }\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlSchemaParseExtension:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * Parses an <extension>, which is found inside a\n- * <simpleContent> or <complexContent>.\n- * *WARNING* this interface is highly subject to change.\n- *\n- * TODO: Returns the type definition or NULL in case of error\n- *\/\n-static xmlSchemaTypePtr\n-xmlSchemaParseExtension(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                        xmlNodePtr node, xmlSchemaTypeType parentType)\n-{\n-    xmlSchemaTypePtr type;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-    \/* Not a component, don't create it. *\/\n-    type = ctxt->ctxtType;\n-    type->flags |= XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION;\n-\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"base\"))) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-\n-    \/*\n-    * Attribute \"base\" - mandatory.\n-    *\/\n-    if ((xmlSchemaPValAttrQName(ctxt, schema, NULL, node,\n-    \"base\", &(type->baseNs), &(type->base)) == 0) &&\n-    (type->base == NULL)) {\n-    xmlSchemaPMissingAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_MISSING,\n-        NULL, node, \"base\", NULL);\n-    }\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-    \/*\n-    * Add the annotation to the type ancestor.\n-    *\/\n-    xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,\n-        xmlSchemaParseAnnotation(ctxt, child, 1));\n-        child = child->next;\n-    }\n-    if (parentType == XML_SCHEMA_TYPE_COMPLEX_CONTENT) {\n-    \/*\n-    * Corresponds to <complexType><complexContent><extension>... and:\n-    *\n-    * Model groups <all>, <choice>, <sequence> and <group>.\n-    *\/\n-    if (IS_SCHEMA(child, \"all\")) {\n-        type->subtypes = (xmlSchemaTypePtr)\n-        xmlSchemaParseModelGroup(ctxt, schema,\n-            child, XML_SCHEMA_TYPE_ALL, 1);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"choice\")) {\n-        type->subtypes = (xmlSchemaTypePtr)\n-        xmlSchemaParseModelGroup(ctxt, schema,\n-            child, XML_SCHEMA_TYPE_CHOICE, 1);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"sequence\")) {\n-        type->subtypes = (xmlSchemaTypePtr)\n-        xmlSchemaParseModelGroup(ctxt, schema,\n-        child, XML_SCHEMA_TYPE_SEQUENCE, 1);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"group\")) {\n-        type->subtypes = (xmlSchemaTypePtr)\n-        xmlSchemaParseModelGroupDefRef(ctxt, schema, child);\n-        \/*\n-        * Note that the reference will be resolved in\n-        * xmlSchemaResolveTypeReferences();\n-        *\/\n-        child = child->next;\n-    }\n-    }\n-    if (child != NULL) {\n-    \/*\n-    * Attribute uses\/declarations.\n-    *\/\n-    if (xmlSchemaParseLocalAttributes(ctxt, schema, &child,\n-        (xmlSchemaItemListPtr *) &(type->attrUses),\n-        XML_SCHEMA_TYPE_EXTENSION, NULL) == -1)\n-        return(NULL);\n-    \/*\n-    * Attribute wildcard.\n-    *\/\n-    if (IS_SCHEMA(child, \"anyAttribute\")) {\n-        ctxt->ctxtType->attributeWildcard =\n-        xmlSchemaParseAnyAttribute(ctxt, schema, child);\n-        child = child->next;\n-    }\n-    }\n-    if (child != NULL) {\n-    if (parentType == XML_SCHEMA_TYPE_COMPLEX_CONTENT) {\n-        \/* Complex content extension. *\/\n-        xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?, ((group | all | choice | sequence)?, \"\n-        \"((attribute | attributeGroup)*, anyAttribute?)))\");\n-    } else {\n-        \/* Simple content extension. *\/\n-        xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?, ((attribute | attributeGroup)*, \"\n-        \"anyAttribute?))\");\n-    }\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlSchemaParseSimpleContent:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * parse a XML schema SimpleContent definition\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the type definition or NULL in case of error\n- *\/\n-static int\n-xmlSchemaParseSimpleContent(xmlSchemaParserCtxtPtr ctxt,\n-                            xmlSchemaPtr schema, xmlNodePtr node,\n-                int *hasRestrictionOrExtension)\n-{\n-    xmlSchemaTypePtr type;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL) ||\n-    (hasRestrictionOrExtension == NULL))\n-        return (-1);\n-    *hasRestrictionOrExtension = 0;\n-    \/* Not a component, don't create it. *\/\n-    type = ctxt->ctxtType;\n-    type->contentType = XML_SCHEMA_CONTENT_SIMPLE;\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\"))) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-    \/*\n-    * Add the annotation to the complex type ancestor.\n-    *\/\n-    xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,\n-        xmlSchemaParseAnnotation(ctxt, child, 1));\n-        child = child->next;\n-    }\n-    if (child == NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_MISSING,\n-        NULL, node, NULL, NULL,\n-        \"(annotation?, (restriction | extension))\");\n-    }\n-    if (child == NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_MISSING,\n-        NULL, node, NULL, NULL,\n-        \"(annotation?, (restriction | extension))\");\n-    }\n-    if (IS_SCHEMA(child, \"restriction\")) {\n-        xmlSchemaParseRestriction(ctxt, schema, child,\n-        XML_SCHEMA_TYPE_SIMPLE_CONTENT);\n-    (*hasRestrictionOrExtension) = 1;\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"extension\")) {\n-        xmlSchemaParseExtension(ctxt, schema, child,\n-        XML_SCHEMA_TYPE_SIMPLE_CONTENT);\n-    (*hasRestrictionOrExtension) = 1;\n-        child = child->next;\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child, NULL,\n-        \"(annotation?, (restriction | extension))\");\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaParseComplexContent:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * parse a XML schema ComplexContent definition\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the type definition or NULL in case of error\n- *\/\n-static int\n-xmlSchemaParseComplexContent(xmlSchemaParserCtxtPtr ctxt,\n-                             xmlSchemaPtr schema, xmlNodePtr node,\n-                 int *hasRestrictionOrExtension)\n-{\n-    xmlSchemaTypePtr type;\n-    xmlNodePtr child = NULL;\n-    xmlAttrPtr attr;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL) ||\n-    (hasRestrictionOrExtension == NULL))\n-        return (-1);\n-    *hasRestrictionOrExtension = 0;\n-    \/* Not a component, don't create it. *\/\n-    type = ctxt->ctxtType;\n-    \/*\n-    * Check for illegal attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if ((!xmlStrEqual(attr->name, BAD_CAST \"id\")) &&\n-        (!xmlStrEqual(attr->name, BAD_CAST \"mixed\")))\n-        {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-\n-    xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-\n-    \/*\n-    * Set the 'mixed' on the complex type ancestor.\n-    *\/\n-    if (xmlGetBooleanProp(ctxt, node, \"mixed\", 0))  {\n-    if ((type->flags & XML_SCHEMAS_TYPE_MIXED) == 0)\n-        type->flags |= XML_SCHEMAS_TYPE_MIXED;\n-    }\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-    \/*\n-    * Add the annotation to the complex type ancestor.\n-    *\/\n-    xmlSchemaAddAnnotation((xmlSchemaAnnotItemPtr) type,\n-        xmlSchemaParseAnnotation(ctxt, child, 1));\n-        child = child->next;\n-    }\n-    if (child == NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_MISSING,\n-        NULL, node, NULL,\n-        NULL, \"(annotation?, (restriction | extension))\");\n-    }\n-    if (child == NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_MISSING,\n-        NULL, node, NULL,\n-        NULL, \"(annotation?, (restriction | extension))\");\n-    }\n-    if (IS_SCHEMA(child, \"restriction\")) {\n-        xmlSchemaParseRestriction(ctxt, schema, child,\n-        XML_SCHEMA_TYPE_COMPLEX_CONTENT);\n-    (*hasRestrictionOrExtension) = 1;\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"extension\")) {\n-        xmlSchemaParseExtension(ctxt, schema, child,\n-        XML_SCHEMA_TYPE_COMPLEX_CONTENT);\n-    (*hasRestrictionOrExtension) = 1;\n-        child = child->next;\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child,\n-        NULL, \"(annotation?, (restriction | extension))\");\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaParseComplexType:\n- * @ctxt:  a schema validation context\n- * @schema:  the schema being built\n- * @node:  a subtree containing XML Schema information\n- *\n- * parse a XML schema Complex Type definition\n- * *WARNING* this interface is highly subject to change\n- *\n- * Returns the type definition or NULL in case of error\n- *\/\n-static xmlSchemaTypePtr\n-xmlSchemaParseComplexType(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,\n-                          xmlNodePtr node, int topLevel)\n-{\n-    xmlSchemaTypePtr type, ctxtType;\n-    xmlNodePtr child = NULL;\n-    const xmlChar *name = NULL;\n-    xmlAttrPtr attr;\n-    const xmlChar *attrValue;\n-#ifdef ENABLE_NAMED_LOCALS\n-    char buf[40];\n-#endif\n-    int final = 0, block = 0, hasRestrictionOrExtension = 0;\n-\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL))\n-        return (NULL);\n-\n-    ctxtType = ctxt->ctxtType;\n-\n-    if (topLevel) {\n-    attr = xmlSchemaGetPropNode(node, \"name\");\n-    if (attr == NULL) {\n-        xmlSchemaPMissingAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_MISSING, NULL, node, \"name\", NULL);\n-        return (NULL);\n-    } else if (xmlSchemaPValAttrNode(ctxt, NULL, attr,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME), &name) != 0) {\n-        return (NULL);\n-    }\n-    }\n-\n-    if (topLevel == 0) {\n-    \/*\n-    * Parse as local complex type definition.\n-    *\/\n-#ifdef ENABLE_NAMED_LOCALS\n-        snprintf(buf, 39, \"#CT%d\", ctxt->counter++ + 1);\n-    type = xmlSchemaAddType(ctxt, schema,\n-        XML_SCHEMA_TYPE_COMPLEX,\n-        xmlDictLookup(ctxt->dict, (const xmlChar *)buf, -1),\n-        ctxt->targetNamespace, node, 0);\n-#else\n-    type = xmlSchemaAddType(ctxt, schema,\n-        XML_SCHEMA_TYPE_COMPLEX,\n-        NULL, ctxt->targetNamespace, node, 0);\n-#endif\n-    if (type == NULL)\n-        return (NULL);\n-    name = type->name;\n-    type->node = node;\n-    type->type = XML_SCHEMA_TYPE_COMPLEX;\n-    \/*\n-    * TODO: We need the target namespace.\n-    *\/\n-    } else {\n-    \/*\n-    * Parse as global complex type definition.\n-    *\/\n-    type = xmlSchemaAddType(ctxt, schema,\n-        XML_SCHEMA_TYPE_COMPLEX,\n-        name, ctxt->targetNamespace, node, 1);\n-    if (type == NULL)\n-        return (NULL);\n-    type->node = node;\n-    type->type = XML_SCHEMA_TYPE_COMPLEX;\n-    type->flags |= XML_SCHEMAS_TYPE_GLOBAL;\n-    }\n-    type->targetNamespace = ctxt->targetNamespace;\n-    \/*\n-    * Handle attributes.\n-    *\/\n-    attr = node->properties;\n-    while (attr != NULL) {\n-    if (attr->ns == NULL) {\n-        if (xmlStrEqual(attr->name, BAD_CAST \"id\")) {\n-        \/*\n-        * Attribute \"id\".\n-        *\/\n-        xmlSchemaPValAttrID(ctxt, node, BAD_CAST \"id\");\n-        } else if (xmlStrEqual(attr->name, BAD_CAST \"mixed\")) {\n-        \/*\n-        * Attribute \"mixed\".\n-        *\/\n-        if (xmlSchemaPGetBoolNodeValue(ctxt,\n-            NULL, (xmlNodePtr) attr))\n-            type->flags |= XML_SCHEMAS_TYPE_MIXED;\n-        } else if (topLevel) {\n-        \/*\n-        * Attributes of global complex type definitions.\n-        *\/\n-        if (xmlStrEqual(attr->name, BAD_CAST \"name\")) {\n-            \/* Pass. *\/\n-        } else if (xmlStrEqual(attr->name, BAD_CAST \"abstract\")) {\n-            \/*\n-            * Attribute \"abstract\".\n-            *\/\n-            if (xmlSchemaPGetBoolNodeValue(ctxt,\n-                NULL, (xmlNodePtr) attr))\n-            type->flags |= XML_SCHEMAS_TYPE_ABSTRACT;\n-        } else if (xmlStrEqual(attr->name, BAD_CAST \"final\")) {\n-            \/*\n-            * Attribute \"final\".\n-            *\/\n-            attrValue = xmlSchemaGetNodeContent(ctxt,\n-            (xmlNodePtr) attr);\n-            if (xmlSchemaPValAttrBlockFinal(attrValue,\n-            &(type->flags),\n-            -1,\n-            XML_SCHEMAS_TYPE_FINAL_EXTENSION,\n-            XML_SCHEMAS_TYPE_FINAL_RESTRICTION,\n-            -1, -1, -1) != 0)\n-            {\n-            xmlSchemaPSimpleTypeErr(ctxt,\n-                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-                NULL, (xmlNodePtr) attr, NULL,\n-                \"(#all | List of (extension | restriction))\",\n-                attrValue, NULL, NULL, NULL);\n-            } else\n-            final = 1;\n-        } else if (xmlStrEqual(attr->name, BAD_CAST \"block\")) {\n-            \/*\n-            * Attribute \"block\".\n-            *\/\n-            attrValue = xmlSchemaGetNodeContent(ctxt,\n-            (xmlNodePtr) attr);\n-            if (xmlSchemaPValAttrBlockFinal(attrValue, &(type->flags),\n-            -1,\n-            XML_SCHEMAS_TYPE_BLOCK_EXTENSION,\n-            XML_SCHEMAS_TYPE_BLOCK_RESTRICTION,\n-            -1, -1, -1) != 0) {\n-            xmlSchemaPSimpleTypeErr(ctxt,\n-                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,\n-                NULL, (xmlNodePtr) attr, NULL,\n-                \"(#all | List of (extension | restriction)) \",\n-                attrValue, NULL, NULL, NULL);\n-            } else\n-            block = 1;\n-        } else {\n-            xmlSchemaPIllegalAttrErr(ctxt,\n-                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-        } else {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-        }\n-    } else if (xmlStrEqual(attr->ns->href, xmlSchemaNs)) {\n-        xmlSchemaPIllegalAttrErr(ctxt,\n-        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, NULL, attr);\n-    }\n-    attr = attr->next;\n-    }\n-    if (! block) {\n-    \/*\n-    * Apply default \"block\" values.\n-    *\/\n-    if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION)\n-        type->flags |= XML_SCHEMAS_TYPE_BLOCK_RESTRICTION;\n-    if (schema->flags & XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION)\n-        type->flags |= XML_SCHEMAS_TYPE_BLOCK_EXTENSION;\n-    }\n-    if (! final) {\n-    \/*\n-    * Apply default \"block\" values.\n-    *\/\n-    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION)\n-        type->flags |= XML_SCHEMAS_TYPE_FINAL_RESTRICTION;\n-    if (schema->flags & XML_SCHEMAS_FINAL_DEFAULT_EXTENSION)\n-        type->flags |= XML_SCHEMAS_TYPE_FINAL_EXTENSION;\n-    }\n-    \/*\n-    * And now for the children...\n-    *\/\n-    child = node->children;\n-    if (IS_SCHEMA(child, \"annotation\")) {\n-        type->annot = xmlSchemaParseAnnotation(ctxt, child, 1);\n-        child = child->next;\n-    }\n-    ctxt->ctxtType = type;\n-    if (IS_SCHEMA(child, \"simpleContent\")) {\n-    \/*\n-    * <complexType><simpleContent>...\n-    * 3.4.3 : 2.2\n-    * Specifying mixed='true' when the <simpleContent>\n-    * alternative is chosen has no effect\n-    *\/\n-    if (type->flags & XML_SCHEMAS_TYPE_MIXED)\n-        type->flags ^= XML_SCHEMAS_TYPE_MIXED;\n-        xmlSchemaParseSimpleContent(ctxt, schema, child,\n-        &hasRestrictionOrExtension);\n-        child = child->next;\n-    } else if (IS_SCHEMA(child, \"complexContent\")) {\n-    \/*\n-    * <complexType><complexContent>...\n-    *\/\n-    type->contentType = XML_SCHEMA_CONTENT_EMPTY;\n-        xmlSchemaParseComplexContent(ctxt, schema, child,\n-        &hasRestrictionOrExtension);\n-        child = child->next;\n-    } else {\n-    \/*\n-    * E.g <complexType><sequence>... or <complexType><attribute>... etc.\n-    *\n-    * SPEC\n-    * \"...the third alternative (neither <simpleContent> nor\n-    * <complexContent>) is chosen. This case is understood as shorthand\n-    * for complex content restricting the `ur-type definition`, and the\n-    * details of the mappings should be modified as necessary.\n-    *\/\n-    type->baseType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);\n-    type->flags |= XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION;\n-    \/*\n-    * Parse model groups.\n-    *\/\n-        if (IS_SCHEMA(child, \"all\")) {\n-            type->subtypes = (xmlSchemaTypePtr)\n-        xmlSchemaParseModelGroup(ctxt, schema, child,\n-            XML_SCHEMA_TYPE_ALL, 1);\n-            child = child->next;\n-        } else if (IS_SCHEMA(child, \"choice\")) {\n-            type->subtypes = (xmlSchemaTypePtr)\n-        xmlSchemaParseModelGroup(ctxt, schema, child,\n-            XML_SCHEMA_TYPE_CHOICE, 1);\n-            child = child->next;\n-        } else if (IS_SCHEMA(child, \"sequence\")) {\n-            type->subtypes = (xmlSchemaTypePtr)\n-        xmlSchemaParseModelGroup(ctxt, schema, child,\n-            XML_SCHEMA_TYPE_SEQUENCE, 1);\n-            child = child->next;\n-        } else if (IS_SCHEMA(child, \"group\")) {\n-            type->subtypes = (xmlSchemaTypePtr)\n-        xmlSchemaParseModelGroupDefRef(ctxt, schema, child);\n-        \/*\n-        * Note that the reference will be resolved in\n-        * xmlSchemaResolveTypeReferences();\n-        *\/\n-            child = child->next;\n-        }\n-    \/*\n-    * Parse attribute decls\/refs.\n-    *\/\n-        if (xmlSchemaParseLocalAttributes(ctxt, schema, &child,\n-        (xmlSchemaItemListPtr *) &(type->attrUses),\n-        XML_SCHEMA_TYPE_RESTRICTION, NULL) == -1)\n-        return(NULL);\n-    \/*\n-    * Parse attribute wildcard.\n-    *\/\n-    if (IS_SCHEMA(child, \"anyAttribute\")) {\n-        type->attributeWildcard = xmlSchemaParseAnyAttribute(ctxt, schema, child);\n-        child = child->next;\n-    }\n-    }\n-    if (child != NULL) {\n-    xmlSchemaPContentErr(ctxt,\n-        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,\n-        NULL, node, child,\n-        NULL, \"(annotation?, (simpleContent | complexContent | \"\n-        \"((group | all | choice | sequence)?, ((attribute | \"\n-        \"attributeGroup)*, anyAttribute?))))\");\n-    }\n-    \/*\n-    * REDEFINE: SPEC src-redefine (5)\n-    *\/\n-    if (topLevel && ctxt->isRedefine && (! hasRestrictionOrExtension)) {\n-    xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_REDEFINE,\n-        NULL, node, \"This is a redefinition, thus the \"\n-        \"<complexType> must have a <restriction> or <extension> \"\n-        \"grand-child\", NULL);\n-    }\n-    ctxt->ctxtType = ctxtType;\n-    return (type);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Validating using Schemas            *\n- *                                    *\n- ************************************************************************\/\n-\n-\/************************************************************************\n- *                                    *\n- *            Reading\/Writing Schemas                *\n- *                                    *\n- ************************************************************************\/\n-\n-#if 0 \/* Will be enabled if it is clear what options are needed. *\/\n-\/**\n- * xmlSchemaParserCtxtSetOptions:\n- * @ctxt:    a schema parser context\n- * @options: a combination of xmlSchemaParserOption\n- *\n- * Sets the options to be used during the parse.\n- *\n- * Returns 0 in case of success, -1 in case of an\n- * API error.\n- *\/\n-static int\n-xmlSchemaParserCtxtSetOptions(xmlSchemaParserCtxtPtr ctxt,\n-                  int options)\n-\n-{\n-    int i;\n-\n-    if (ctxt == NULL)\n-    return (-1);\n-    \/*\n-    * WARNING: Change the start value if adding to the\n-    * xmlSchemaParseOption.\n-    *\/\n-    for (i = 1; i < (int) sizeof(int) * 8; i++) {\n-        if (options & 1<<i) {\n-        return (-1);\n-        }\n-    }\n-    ctxt->options = options;\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaValidCtxtGetOptions:\n- * @ctxt: a schema parser context\n- *\n- * Returns the option combination of the parser context.\n- *\/\n-static int\n-xmlSchemaParserCtxtGetOptions(xmlSchemaParserCtxtPtr ctxt)\n-\n-{\n-    if (ctxt == NULL)\n-    return (-1);\n-    else\n-    return (ctxt->options);\n-}\n-#endif\n-\n-\/**\n- * xmlSchemaNewParserCtxt:\n- * @URL:  the location of the schema\n- *\n- * Create an XML Schemas parse context for that file\/resource expected\n- * to contain an XML Schemas file.\n- *\n- * Returns the parser context or NULL in case of error\n- *\/\n-xmlSchemaParserCtxtPtr\n-xmlSchemaNewParserCtxt(const char *URL)\n-{\n-    xmlSchemaParserCtxtPtr ret;\n-\n-    if (URL == NULL)\n-        return (NULL);\n-\n-    ret = xmlSchemaParserCtxtCreate();\n-    if (ret == NULL)\n-    return(NULL);\n-    ret->dict = xmlDictCreate();\n-    ret->URL = xmlDictLookup(ret->dict, (const xmlChar *) URL, -1);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaNewMemParserCtxt:\n- * @buffer:  a pointer to a char array containing the schemas\n- * @size:  the size of the array\n- *\n- * Create an XML Schemas parse context for that memory buffer expected\n- * to contain an XML Schemas file.\n- *\n- * Returns the parser context or NULL in case of error\n- *\/\n-xmlSchemaParserCtxtPtr\n-xmlSchemaNewMemParserCtxt(const char *buffer, int size)\n-{\n-    xmlSchemaParserCtxtPtr ret;\n-\n-    if ((buffer == NULL) || (size <= 0))\n-        return (NULL);\n-    ret = xmlSchemaParserCtxtCreate();\n-    if (ret == NULL)\n-    return(NULL);\n-    ret->buffer = buffer;\n-    ret->size = size;\n-    ret->dict = xmlDictCreate();\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaNewDocParserCtxt:\n- * @doc:  a preparsed document tree\n- *\n- * Create an XML Schemas parse context for that document.\n- * NB. The document may be modified during the parsing process.\n- *\n- * Returns the parser context or NULL in case of error\n- *\/\n-xmlSchemaParserCtxtPtr\n-xmlSchemaNewDocParserCtxt(xmlDocPtr doc)\n-{\n-    xmlSchemaParserCtxtPtr ret;\n-\n-    if (doc == NULL)\n-      return (NULL);\n-    ret = xmlSchemaParserCtxtCreate();\n-    if (ret == NULL)\n-    return(NULL);\n-    ret->doc = doc;\n-    ret->dict = xmlDictCreate();\n-    \/* The application has responsibility for the document *\/\n-    ret->preserve = 1;\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaFreeParserCtxt:\n- * @ctxt:  the schema parser context\n- *\n- * Free the resources associated to the schema parser context\n- *\/\n-void\n-xmlSchemaFreeParserCtxt(xmlSchemaParserCtxtPtr ctxt)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    if (ctxt->doc != NULL && !ctxt->preserve)\n-        xmlFreeDoc(ctxt->doc);\n-    if (ctxt->vctxt != NULL) {\n-    xmlSchemaFreeValidCtxt(ctxt->vctxt);\n-    }\n-    if (ctxt->ownsConstructor && (ctxt->constructor != NULL)) {\n-    xmlSchemaConstructionCtxtFree(ctxt->constructor);\n-    ctxt->constructor = NULL;\n-    ctxt->ownsConstructor = 0;\n-    }\n-    if (ctxt->attrProhibs != NULL)\n-    xmlSchemaItemListFree(ctxt->attrProhibs);\n-    xmlDictFree(ctxt->dict);\n-    xmlFree(ctxt);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Building the content models            *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlSchemaBuildContentModelForSubstGroup:\n- *\n- * Returns 1 if nillable, 0 otherwise\n- *\/\n-static int\n-xmlSchemaBuildContentModelForSubstGroup(xmlSchemaParserCtxtPtr pctxt,\n-    xmlSchemaParticlePtr particle, int counter, xmlAutomataStatePtr end)\n-{\n-    xmlAutomataStatePtr start, tmp;\n-    xmlSchemaElementPtr elemDecl, member;\n-    xmlSchemaSubstGroupPtr substGroup;\n-    int i;\n-    int ret = 0;\n-\n-    elemDecl = (xmlSchemaElementPtr) particle->children;\n-    \/*\n-    * Wrap the substitution group with a CHOICE.\n-    *\/\n-    start = pctxt->state;\n-    if (end == NULL)\n-    end = xmlAutomataNewState(pctxt->am);\n-    substGroup = xmlSchemaSubstGroupGet(pctxt, elemDecl);\n-    if (substGroup == NULL) {\n-    xmlSchemaPErr(pctxt, WXS_ITEM_NODE(particle),\n-        XML_SCHEMAP_INTERNAL,\n-        \"Internal error: xmlSchemaBuildContentModelForSubstGroup, \"\n-        \"declaration is marked having a subst. group but none \"\n-        \"available.\\n\", elemDecl->name, NULL);\n-    return(0);\n-    }\n-    if (counter >= 0) {\n-    \/*\n-    * NOTE that we put the declaration in, even if it's abstract.\n-    * However, an error will be raised during *validation* if an element\n-    * information item shall be validated against an abstract element\n-    * declaration.\n-    *\/\n-    tmp = xmlAutomataNewCountedTrans(pctxt->am, start, NULL, counter);\n-        xmlAutomataNewTransition2(pctxt->am, tmp, end,\n-                elemDecl->name, elemDecl->targetNamespace, elemDecl);\n-    \/*\n-    * Add subst. group members.\n-    *\/\n-    for (i = 0; i < substGroup->members->nbItems; i++) {\n-        member = (xmlSchemaElementPtr) substGroup->members->items[i];\n-            xmlAutomataNewTransition2(pctxt->am, tmp, end,\n-                       member->name, member->targetNamespace, member);\n-    }\n-    } else if (particle->maxOccurs == 1) {\n-    \/*\n-    * NOTE that we put the declaration in, even if it's abstract,\n-    *\/\n-    xmlAutomataNewEpsilon(pctxt->am,\n-        xmlAutomataNewTransition2(pctxt->am,\n-        start, NULL,\n-        elemDecl->name, elemDecl->targetNamespace, elemDecl), end);\n-    \/*\n-    * Add subst. group members.\n-    *\/\n-    for (i = 0; i < substGroup->members->nbItems; i++) {\n-        member = (xmlSchemaElementPtr) substGroup->members->items[i];\n-        \/*\n-        * NOTE: This fixes bug #341150. xmlAutomataNewOnceTrans2()\n-        *  was incorrectly used instead of xmlAutomataNewTransition2()\n-        *  (seems like a copy&paste bug from the XML_SCHEMA_TYPE_ALL\n-        *  section in xmlSchemaBuildAContentModel() ).\n-        * TODO: Check if xmlAutomataNewOnceTrans2() was instead\n-        *  intended for the above \"counter\" section originally. I.e.,\n-        *  check xs:all with subst-groups.\n-        *\n-        * tmp = xmlAutomataNewOnceTrans2(pctxt->am, start, NULL,\n-        *                   member->name, member->targetNamespace,\n-        *               1, 1, member);\n-        *\/\n-        tmp = xmlAutomataNewTransition2(pctxt->am, start, NULL,\n-        member->name, member->targetNamespace, member);\n-        xmlAutomataNewEpsilon(pctxt->am, tmp, end);\n-    }\n-    } else {\n-    xmlAutomataStatePtr hop;\n-    int maxOccurs = particle->maxOccurs == UNBOUNDED ?\n-        UNBOUNDED : particle->maxOccurs - 1;\n-    int minOccurs = particle->minOccurs < 1 ? 0 : particle->minOccurs - 1;\n-\n-    counter =\n-        xmlAutomataNewCounter(pctxt->am, minOccurs,\n-        maxOccurs);\n-    hop = xmlAutomataNewState(pctxt->am);\n-\n-    xmlAutomataNewEpsilon(pctxt->am,\n-        xmlAutomataNewTransition2(pctxt->am,\n-        start, NULL,\n-        elemDecl->name, elemDecl->targetNamespace, elemDecl),\n-        hop);\n-    \/*\n-     * Add subst. group members.\n-     *\/\n-    for (i = 0; i < substGroup->members->nbItems; i++) {\n-        member = (xmlSchemaElementPtr) substGroup->members->items[i];\n-        xmlAutomataNewEpsilon(pctxt->am,\n-        xmlAutomataNewTransition2(pctxt->am,\n-        start, NULL,\n-        member->name, member->targetNamespace, member),\n-        hop);\n-    }\n-    xmlAutomataNewCountedTrans(pctxt->am, hop, start, counter);\n-    xmlAutomataNewCounterTrans(pctxt->am, hop, end, counter);\n-    }\n-    if (particle->minOccurs == 0) {\n-    xmlAutomataNewEpsilon(pctxt->am, start, end);\n-        ret = 1;\n-    }\n-    pctxt->state = end;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlSchemaBuildContentModelForElement:\n- *\n- * Returns 1 if nillable, 0 otherwise\n- *\/\n-static int\n-xmlSchemaBuildContentModelForElement(xmlSchemaParserCtxtPtr ctxt,\n-                     xmlSchemaParticlePtr particle)\n-{\n-    int ret = 0;\n-\n-    if (((xmlSchemaElementPtr) particle->children)->flags &\n-    XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD) {\n-    \/*\n-    * Substitution groups.\n-    *\/\n-    ret = xmlSchemaBuildContentModelForSubstGroup(ctxt, particle, -1, NULL);\n-    } else {\n-    xmlSchemaElementPtr elemDecl;\n-    xmlAutomataStatePtr start;\n-\n-    elemDecl = (xmlSchemaElementPtr) particle->children;\n-\n-    if (elemDecl->flags & XML_SCHEMAS_ELEM_ABSTRACT)\n-        return(0);\n-    if (particle->maxOccurs == 1) {\n-        start = ctxt->state;\n-        ctxt->state = xmlAutomataNewTransition2(ctxt->am, start, NULL,\n-            elemDecl->name, elemDecl->targetNamespace, elemDecl);\n-    } else if ((particle->maxOccurs >= UNBOUNDED) &&\n-               (particle->minOccurs < 2)) {\n-        \/* Special case. *\/\n-        start = ctxt->state;\n-        ctxt->state = xmlAutomataNewTransition2(ctxt->am, start, NULL,\n-        elemDecl->name, elemDecl->targetNamespace, elemDecl);\n-        ctxt->state = xmlAutomataNewTransition2(ctxt->am, ctxt->state, ctxt->state,\n-        elemDecl->name, elemDecl->targetNamespace, elemDecl);\n-    } else {\n-        int counter;\n-        int maxOccurs = particle->maxOccurs == UNBOUNDED ?\n-                UNBOUNDED : particle->maxOccurs - 1;\n-        int minOccurs = particle->minOccurs < 1 ?\n-                0 : particle->minOccurs - 1;\n-\n-        start = xmlAutomataNewEpsilon(ctxt->am, ctxt->state, NULL);\n-        counter = xmlAutomataNewCounter(ctxt->am, minOccurs, maxOccurs);\n-        ctxt->state = xmlAutomataNewTransition2(ctxt->am, start, NULL,\n-        elemDecl->name, elemDecl->targetNamespace, elemDecl);\n-        xmlAutomataNewCountedTrans(ctxt->am, ctxt->state, start, counter);\n-        ctxt->state = xmlAutomataNewCounterTrans(ctxt->am, ctxt->state,\n-        NULL, counter);\n-    }\n-    if (particle->minOccurs == 0) {\n-        xmlAutomataNewEpsilon(ctxt->am, start, ctxt->state);\n-            ret = 1;\n-        }\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlSchemaBuildAContentModel:\n- * @ctxt:  the schema parser context\n- * @particle:  the particle component\n- * @name:  the complex type's name whose content is being built\n- *\n- * Create the automaton for the {content type} of a complex type.\n- *\n- * Returns 1 if the content is nillable, 0 otherwise\n- *\/\n-static int\n-xmlSchemaBuildAContentModel(xmlSchemaParserCtxtPtr pctxt,\n-                xmlSchemaParticlePtr particle)\n-{\n-    int ret = 0, tmp2;\n-\n-    if (particle == NULL) {\n-    PERROR_INT(\"xmlSchemaBuildAContentModel\", \"particle is NULL\");\n-    return(1);\n-    }\n-    if (particle->children == NULL) {\n-    \/*\n-    * Just return in this case. A missing \"term\" of the particle\n-    * might arise due to an invalid \"term\" component.\n-    *\/\n-    return(1);\n-    }\n-\n-    switch (particle->children->type) {\n-    case XML_SCHEMA_TYPE_ANY: {\n-        xmlAutomataStatePtr start, end;\n-        xmlSchemaWildcardPtr wild;\n-        xmlSchemaWildcardNsPtr ns;\n-\n-        wild = (xmlSchemaWildcardPtr) particle->children;\n-\n-        start = pctxt->state;\n-        end = xmlAutomataNewState(pctxt->am);\n-\n-        if (particle->maxOccurs == 1) {\n-        if (wild->any == 1) {\n-            \/*\n-            * We need to add both transitions:\n-            *\n-            * 1. the {\"*\", \"*\"} for elements in a namespace.\n-            *\/\n-            pctxt->state =\n-            xmlAutomataNewTransition2(pctxt->am,\n-            start, NULL, BAD_CAST \"*\", BAD_CAST \"*\", wild);\n-            xmlAutomataNewEpsilon(pctxt->am, pctxt->state, end);\n-            \/*\n-            * 2. the {\"*\"} for elements in no namespace.\n-            *\/\n-            pctxt->state =\n-            xmlAutomataNewTransition2(pctxt->am,\n-            start, NULL, BAD_CAST \"*\", NULL, wild);\n-            xmlAutomataNewEpsilon(pctxt->am, pctxt->state, end);\n-\n-        } else if (wild->nsSet != NULL) {\n-            ns = wild->nsSet;\n-            do {\n-            pctxt->state = start;\n-            pctxt->state = xmlAutomataNewTransition2(pctxt->am,\n-                pctxt->state, NULL, BAD_CAST \"*\", ns->value, wild);\n-            xmlAutomataNewEpsilon(pctxt->am, pctxt->state, end);\n-            ns = ns->next;\n-            } while (ns != NULL);\n-\n-        } else if (wild->negNsSet != NULL) {\n-            pctxt->state = xmlAutomataNewNegTrans(pctxt->am,\n-            start, end, BAD_CAST \"*\", wild->negNsSet->value,\n-            wild);\n-        }\n-        } else {\n-        int counter;\n-        xmlAutomataStatePtr hop;\n-        int maxOccurs =\n-            particle->maxOccurs == UNBOUNDED ? UNBOUNDED :\n-                                           particle->maxOccurs - 1;\n-        int minOccurs =\n-            particle->minOccurs < 1 ? 0 : particle->minOccurs - 1;\n-\n-        counter = xmlAutomataNewCounter(pctxt->am, minOccurs, maxOccurs);\n-        hop = xmlAutomataNewState(pctxt->am);\n-        if (wild->any == 1) {\n-            pctxt->state =\n-            xmlAutomataNewTransition2(pctxt->am,\n-            start, NULL, BAD_CAST \"*\", BAD_CAST \"*\", wild);\n-            xmlAutomataNewEpsilon(pctxt->am, pctxt->state, hop);\n-            pctxt->state =\n-            xmlAutomataNewTransition2(pctxt->am,\n-            start, NULL, BAD_CAST \"*\", NULL, wild);\n-            xmlAutomataNewEpsilon(pctxt->am, pctxt->state, hop);\n-        } else if (wild->nsSet != NULL) {\n-            ns = wild->nsSet;\n-            do {\n-            pctxt->state =\n-                xmlAutomataNewTransition2(pctxt->am,\n-                start, NULL, BAD_CAST \"*\", ns->value, wild);\n-            xmlAutomataNewEpsilon(pctxt->am, pctxt->state, hop);\n-            ns = ns->next;\n-            } while (ns != NULL);\n-\n-        } else if (wild->negNsSet != NULL) {\n-            pctxt->state = xmlAutomataNewNegTrans(pctxt->am,\n-            start, hop, BAD_CAST \"*\", wild->negNsSet->value,\n-            wild);\n-        }\n-        xmlAutomataNewCountedTrans(pctxt->am, hop, start, counter);\n-        xmlAutomataNewCounterTrans(pctxt->am, hop, end, counter);\n-        }\n-        if (particle->minOccurs == 0) {\n-        xmlAutomataNewEpsilon(pctxt->am, start, end);\n-                ret = 1;\n-        }\n-        pctxt->state = end;\n-            break;\n-    }\n-        case XML_SCHEMA_TYPE_ELEMENT:\n-        ret = xmlSchemaBuildContentModelForElement(pctxt, particle);\n-        break;\n-        case XML_SCHEMA_TYPE_SEQUENCE:{\n-            xmlSchemaTreeItemPtr sub;\n-\n-            ret = 1;\n-            \/*\n-             * If max and min occurrences are default (1) then\n-             * simply iterate over the particles of the <sequence>.\n-             *\/\n-            if ((particle->minOccurs == 1) && (particle->maxOccurs == 1)) {\n-                sub = particle->children->children;\n-\n-                while (sub != NULL) {\n-                    tmp2 = xmlSchemaBuildAContentModel(pctxt,\n-                                        (xmlSchemaParticlePtr) sub);\n-                    if (tmp2 != 1) ret = 0;\n-                    sub = sub->next;\n-                }\n-            } else {\n-                xmlAutomataStatePtr oldstate = pctxt->state;\n-\n-                if (particle->maxOccurs >= UNBOUNDED) {\n-                    if (particle->minOccurs > 1) {\n-                        xmlAutomataStatePtr tmp;\n-                        int counter;\n-\n-                        pctxt->state = xmlAutomataNewEpsilon(pctxt->am,\n-                            oldstate, NULL);\n-                        oldstate = pctxt->state;\n-\n-                        counter = xmlAutomataNewCounter(pctxt->am,\n-                            particle->minOccurs - 1, UNBOUNDED);\n-\n-                        sub = particle->children->children;\n-                        while (sub != NULL) {\n-                            tmp2 = xmlSchemaBuildAContentModel(pctxt,\n-                                            (xmlSchemaParticlePtr) sub);\n-                            if (tmp2 != 1) ret = 0;\n-                            sub = sub->next;\n-                        }\n-                        tmp = pctxt->state;\n-                        xmlAutomataNewCountedTrans(pctxt->am, tmp,\n-                                                   oldstate, counter);\n-                        pctxt->state =\n-                            xmlAutomataNewCounterTrans(pctxt->am, tmp,\n-                                                       NULL, counter);\n-                        if (ret == 1)\n-                            xmlAutomataNewEpsilon(pctxt->am,\n-                                                oldstate, pctxt->state);\n-\n-                    } else {\n-                        pctxt->state = xmlAutomataNewEpsilon(pctxt->am,\n-                            oldstate, NULL);\n-                        oldstate = pctxt->state;\n-\n-                        sub = particle->children->children;\n-                        while (sub != NULL) {\n-                            tmp2 = xmlSchemaBuildAContentModel(pctxt,\n-                                        (xmlSchemaParticlePtr) sub);\n-                            if (tmp2 != 1) ret = 0;\n-                            sub = sub->next;\n-                        }\n-                        xmlAutomataNewEpsilon(pctxt->am, pctxt->state,\n-                                              oldstate);\n-                        \/*\n-                         * epsilon needed to block previous trans from\n-                         * being allowed to enter back from another\n-                         * construct\n-                         *\/\n-                        pctxt->state = xmlAutomataNewEpsilon(pctxt->am,\n-                                            pctxt->state, NULL);\n-                        if (particle->minOccurs == 0) {\n-                            xmlAutomataNewEpsilon(pctxt->am,\n-                                oldstate, pctxt->state);\n-                            ret = 1;\n-                        }\n-                    }\n-                } else if ((particle->maxOccurs > 1)\n-                           || (particle->minOccurs > 1)) {\n-                    xmlAutomataStatePtr tmp;\n-                    int counter;\n-\n-                    pctxt->state = xmlAutomataNewEpsilon(pctxt->am,\n-                        oldstate, NULL);\n-                    oldstate = pctxt->state;\n-\n-                    counter = xmlAutomataNewCounter(pctxt->am,\n-                        particle->minOccurs - 1,\n-                        particle->maxOccurs - 1);\n-\n-                    sub = particle->children->children;\n-                    while (sub != NULL) {\n-                        tmp2 = xmlSchemaBuildAContentModel(pctxt,\n-                                        (xmlSchemaParticlePtr) sub);\n-                        if (tmp2 != 1) ret = 0;\n-                        sub = sub->next;\n-                    }\n-                    tmp = pctxt->state;\n-                    xmlAutomataNewCountedTrans(pctxt->am,\n-                        tmp, oldstate, counter);\n-                    pctxt->state =\n-                        xmlAutomataNewCounterTrans(pctxt->am, tmp, NULL,\n-                                                   counter);\n-                    if ((particle->minOccurs == 0) || (ret == 1)) {\n-                        xmlAutomataNewEpsilon(pctxt->am,\n-                                            oldstate, pctxt->state);\n-                        ret = 1;\n-                    }\n-                } else {\n-                    sub = particle->children->children;\n-                    while (sub != NULL) {\n-                        tmp2 = xmlSchemaBuildAContentModel(pctxt,\n-                                        (xmlSchemaParticlePtr) sub);\n-                        if (tmp2 != 1) ret = 0;\n-                        sub = sub->next;\n-                    }\n-\n-            \/*\n-             * epsilon needed to block previous trans from\n-             * being allowed to enter back from another\n-             * construct\n-             *\/\n-            pctxt->state = xmlAutomataNewEpsilon(pctxt->am,\n-                    pctxt->state, NULL);\n-\n-                    if (particle->minOccurs == 0) {\n-                        xmlAutomataNewEpsilon(pctxt->am, oldstate,\n-                                              pctxt->state);\n-                        ret = 1;\n-                    }\n-                }\n-            }\n-            break;\n-        }\n-        case XML_SCHEMA_TYPE_CHOICE:{\n-            xmlSchemaTreeItemPtr sub;\n-            xmlAutomataStatePtr start, end;\n-\n-            ret = 0;\n-            start = pctxt->state;\n-            end = xmlAutomataNewState(pctxt->am);\n-\n-            \/*\n-             * iterate over the subtypes and remerge the end with an\n-             * epsilon transition\n-             *\/\n-            if (particle->maxOccurs == 1) {\n-                sub = particle->children->children;\n-                while (sub != NULL) {\n-                    pctxt->state = start;\n-                    tmp2 = xmlSchemaBuildAContentModel(pctxt,\n-                                        (xmlSchemaParticlePtr) sub);\n-                    if (tmp2 == 1) ret = 1;\n-                    xmlAutomataNewEpsilon(pctxt->am, pctxt->state, end);\n-                    sub = sub->next;\n-                }\n-            } else {\n-                int counter;\n-                xmlAutomataStatePtr hop, base;\n-                int maxOccurs = particle->maxOccurs == UNBOUNDED ?\n-                    UNBOUNDED : particle->maxOccurs - 1;\n-                int minOccurs =\n-                    particle->minOccurs < 1 ? 0 : particle->minOccurs - 1;\n-\n-                \/*\n-                 * use a counter to keep track of the number of transitions\n-                 * which went through the choice.\n-                 *\/\n-                counter =\n-                    xmlAutomataNewCounter(pctxt->am, minOccurs, maxOccurs);\n-                hop = xmlAutomataNewState(pctxt->am);\n-                base = xmlAutomataNewState(pctxt->am);\n-\n-                sub = particle->children->children;\n-                while (sub != NULL) {\n-                    pctxt->state = base;\n-                    tmp2 = xmlSchemaBuildAContentModel(pctxt,\n-                                        (xmlSchemaParticlePtr) sub);\n-                    if (tmp2 == 1) ret = 1;\n-                    xmlAutomataNewEpsilon(pctxt->am, pctxt->state, hop);\n-                    sub = sub->next;\n-                }\n-                xmlAutomataNewEpsilon(pctxt->am, start, base);\n-                xmlAutomataNewCountedTrans(pctxt->am, hop, base, counter);\n-                xmlAutomataNewCounterTrans(pctxt->am, hop, end, counter);\n-                if (ret == 1)\n-                    xmlAutomataNewEpsilon(pctxt->am, base, end);\n-            }\n-            if (particle->minOccurs == 0) {\n-                xmlAutomataNewEpsilon(pctxt->am, start, end);\n-                ret = 1;\n-            }\n-            pctxt->state = end;\n-            break;\n-        }\n-        case XML_SCHEMA_TYPE_ALL:{\n-            xmlAutomataStatePtr start, tmp;\n-            xmlSchemaParticlePtr sub;\n-            xmlSchemaElementPtr elemDecl;\n-\n-            ret = 1;\n-\n-            sub = (xmlSchemaParticlePtr) particle->children->children;\n-            if (sub == NULL)\n-                break;\n-\n-            ret = 0;\n-\n-            start = pctxt->state;\n-            tmp = xmlAutomataNewState(pctxt->am);\n-            xmlAutomataNewEpsilon(pctxt->am, pctxt->state, tmp);\n-            pctxt->state = tmp;\n-            while (sub != NULL) {\n-                pctxt->state = tmp;\n-\n-                elemDecl = (xmlSchemaElementPtr) sub->children;\n-                if (elemDecl == NULL) {\n-                    PERROR_INT(\"xmlSchemaBuildAContentModel\",\n-                        \"<element> particle has no term\");\n-                    return(ret);\n-                };\n-                \/*\n-                * NOTE: The {max occurs} of all the particles in the\n-                * {particles} of the group must be 0 or 1; this is\n-                * already ensured during the parse of the content of\n-                * <all>.\n-                *\/\n-                if (elemDecl->flags & XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD) {\n-                    int counter;\n-\n-                    \/*\n-                     * This is an abstract group, we need to share\n-                     * the same counter for all the element transitions\n-                     * derived from the group\n-                     *\/\n-                    counter = xmlAutomataNewCounter(pctxt->am,\n-                                       sub->minOccurs, sub->maxOccurs);\n-                    xmlSchemaBuildContentModelForSubstGroup(pctxt,\n-                                       sub, counter, pctxt->state);\n-                } else {\n-                    if ((sub->minOccurs == 1) &&\n-                        (sub->maxOccurs == 1)) {\n-                        xmlAutomataNewOnceTrans2(pctxt->am, pctxt->state,\n-                                                pctxt->state,\n-                                                elemDecl->name,\n-                                                elemDecl->targetNamespace,\n-                                                1, 1, elemDecl);\n-                    } else if ((sub->minOccurs == 0) &&\n-                        (sub->maxOccurs == 1)) {\n-\n-                        xmlAutomataNewCountTrans2(pctxt->am, pctxt->state,\n-                                                 pctxt->state,\n-                                                 elemDecl->name,\n-                                                 elemDecl->targetNamespace,\n-                                                 0,\n-                                                 1,\n-                                                 elemDecl);\n-                    }\n-                }\n-                sub = (xmlSchemaParticlePtr) sub->next;\n-            }\n-            pctxt->state =\n-                xmlAutomataNewAllTrans(pctxt->am, pctxt->state, NULL, 0);\n-            if (particle->minOccurs == 0) {\n-                xmlAutomataNewEpsilon(pctxt->am, start, pctxt->state);\n-                ret = 1;\n-            }\n-            break;\n-        }\n-    case XML_SCHEMA_TYPE_GROUP:\n-        \/*\n-        * If we hit a model group definition, then this means that\n-        * it was empty, thus was not substituted for the containing\n-        * model group. Just do nothing in this case.\n-        * TODO: But the group should be substituted and not occur at\n-        * all in the content model at this point. Fix this.\n-        *\/\n-            ret = 1;\n-        break;\n-        default:\n-        xmlSchemaInternalErr2(ACTXT_CAST pctxt,\n-        \"xmlSchemaBuildAContentModel\",\n-        \"found unexpected term of type '%s' in content model\",\n-        WXS_ITEM_TYPE_NAME(particle->children), NULL);\n-            return(ret);\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlSchemaBuildContentModel:\n- * @ctxt:  the schema parser context\n- * @type:  the complex type definition\n- * @name:  the element name\n- *\n- * Builds the content model of the complex type.\n- *\/\n-static void\n-xmlSchemaBuildContentModel(xmlSchemaTypePtr type,\n-               xmlSchemaParserCtxtPtr ctxt)\n-{\n-    if ((type->type != XML_SCHEMA_TYPE_COMPLEX) ||\n-    (type->contModel != NULL) ||\n-    ((type->contentType != XML_SCHEMA_CONTENT_ELEMENTS) &&\n-    (type->contentType != XML_SCHEMA_CONTENT_MIXED)))\n-    return;\n-\n-    ctxt->am = NULL;\n-    ctxt->am = xmlNewAutomata();\n-    if (ctxt->am == NULL) {\n-    xmlSchemaPErrMemory(ctxt);\n-        return;\n-    }\n-    ctxt->state = xmlAutomataGetInitState(ctxt->am);\n-    \/*\n-    * Build the automaton.\n-    *\/\n-    xmlSchemaBuildAContentModel(ctxt, WXS_TYPE_PARTICLE(type));\n-    xmlAutomataSetFinalState(ctxt->am, ctxt->state);\n-    type->contModel = xmlAutomataCompile(ctxt->am);\n-    if (type->contModel == NULL) {\n-        xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_INTERNAL,\n-        WXS_BASIC_CAST type, type->node,\n-        \"Failed to compile the content model\", NULL);\n-    } else if (xmlRegexpIsDeterminist(type->contModel) != 1) {\n-        xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_NOT_DETERMINISTIC,\n-        \/* XML_SCHEMAS_ERR_NOTDETERMINIST, *\/\n-        WXS_BASIC_CAST type, type->node,\n-        \"The content model is not determinist\", NULL);\n-    } else {\n-    }\n-    ctxt->state = NULL;\n-    xmlFreeAutomata(ctxt->am);\n-    ctxt->am = NULL;\n-}\n-\n-\/**\n- * xmlSchemaResolveElementReferences:\n- * @elem:  the schema element context\n- * @ctxt:  the schema parser context\n- *\n- * Resolves the references of an element declaration\n- * or particle, which has an element declaration as it's\n- * term.\n- *\/\n-static void\n-xmlSchemaResolveElementReferences(xmlSchemaElementPtr elemDecl,\n-                  xmlSchemaParserCtxtPtr ctxt)\n-{\n-    if ((ctxt == NULL) || (elemDecl == NULL) ||\n-    ((elemDecl != NULL) &&\n-    (elemDecl->flags & XML_SCHEMAS_ELEM_INTERNAL_RESOLVED)))\n-        return;\n-    elemDecl->flags |= XML_SCHEMAS_ELEM_INTERNAL_RESOLVED;\n-\n-    if ((elemDecl->subtypes == NULL) && (elemDecl->namedType != NULL)) {\n-    xmlSchemaTypePtr type;\n-\n-    \/* (type definition) ... otherwise the type definition `resolved`\n-    * to by the `actual value` of the type [attribute] ...\n-    *\/\n-    type = xmlSchemaGetType(ctxt->schema, elemDecl->namedType,\n-        elemDecl->namedTypeNs);\n-    if (type == NULL) {\n-        xmlSchemaPResCompAttrErr(ctxt,\n-        XML_SCHEMAP_SRC_RESOLVE,\n-        WXS_BASIC_CAST elemDecl, elemDecl->node,\n-        \"type\", elemDecl->namedType, elemDecl->namedTypeNs,\n-        XML_SCHEMA_TYPE_BASIC, \"type definition\");\n-    } else\n-        elemDecl->subtypes = type;\n-    }\n-    if (elemDecl->substGroup != NULL) {\n-    xmlSchemaElementPtr substHead;\n-\n-    \/*\n-    * FIXME TODO: Do we need a new field in _xmlSchemaElement for\n-    * substitutionGroup?\n-    *\/\n-    substHead = xmlSchemaGetElem(ctxt->schema, elemDecl->substGroup,\n-        elemDecl->substGroupNs);\n-    if (substHead == NULL) {\n-        xmlSchemaPResCompAttrErr(ctxt,\n-        XML_SCHEMAP_SRC_RESOLVE,\n-        WXS_BASIC_CAST elemDecl, NULL,\n-        \"substitutionGroup\", elemDecl->substGroup,\n-        elemDecl->substGroupNs, XML_SCHEMA_TYPE_ELEMENT, NULL);\n-    } else {\n-        xmlSchemaResolveElementReferences(substHead, ctxt);\n-        \/*\n-        * Set the \"substitution group affiliation\".\n-        * NOTE that now we use the \"refDecl\" field for this.\n-        *\/\n-        WXS_SUBST_HEAD(elemDecl) = substHead;\n-        \/*\n-        * The type definitions is set to:\n-        * SPEC \"...the {type definition} of the element\n-        * declaration `resolved` to by the `actual value`\n-        * of the substitutionGroup [attribute], if present\"\n-        *\/\n-        if (elemDecl->subtypes == NULL) {\n-                if (substHead->subtypes == NULL) {\n-                    \/*\n-                     * This can happen with self-referencing substitution\n-                     * groups. The cycle will be detected later, but we have\n-                     * to set subtypes to avoid null-pointer dereferences.\n-                     *\/\n-                elemDecl->subtypes = xmlSchemaGetBuiltInType(\n-                            XML_SCHEMAS_ANYTYPE);\n-                } else {\n-            elemDecl->subtypes = substHead->subtypes;\n-                }\n-            }\n-    }\n-    }\n-    \/*\n-    * SPEC \"The definition of anyType serves as the default type definition\n-    * for element declarations whose XML representation does not specify one.\"\n-    *\/\n-    if ((elemDecl->subtypes == NULL) &&\n-    (elemDecl->namedType == NULL) &&\n-    (elemDecl->substGroup == NULL))\n-    elemDecl->subtypes = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);\n-}\n-\n-\/**\n- * xmlSchemaResolveUnionMemberTypes:\n- * @ctxt:  the schema parser context\n- * @type:  the schema simple type definition\n- *\n- * Checks and builds the \"member type definitions\" property of the union\n- * simple type. This handles part (1), part (2) is done in\n- * xmlSchemaFinishMemberTypeDefinitionsProperty()\n- *\n- * Returns -1 in case of an internal error, 0 otherwise.\n- *\/\n-static int\n-xmlSchemaResolveUnionMemberTypes(xmlSchemaParserCtxtPtr ctxt,\n-                 xmlSchemaTypePtr type)\n-{\n-\n-    xmlSchemaTypeLinkPtr link, lastLink, newLink;\n-    xmlSchemaTypePtr memberType;\n-\n-    \/*\n-    * SPEC (1) \"If the <union> alternative is chosen, then [Definition:]\n-    * define the explicit members as the type definitions `resolved`\n-    * to by the items in the `actual value` of the memberTypes [attribute],\n-    * if any, followed by the type definitions corresponding to the\n-    * <simpleType>s among the [children] of <union>, if any.\"\n-    *\/\n-    \/*\n-    * Resolve references.\n-    *\/\n-    link = type->memberTypes;\n-    lastLink = NULL;\n-    while (link != NULL) {\n-    const xmlChar *name, *nsName;\n-\n-    name = ((xmlSchemaQNameRefPtr) link->type)->name;\n-    nsName = ((xmlSchemaQNameRefPtr) link->type)->targetNamespace;\n-\n-    memberType = xmlSchemaGetType(ctxt->schema, name, nsName);\n-    if ((memberType == NULL) || (! WXS_IS_SIMPLE(memberType))) {\n-        xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,\n-        WXS_BASIC_CAST type, type->node, \"memberTypes\",\n-        name, nsName, XML_SCHEMA_TYPE_SIMPLE, NULL);\n-        \/*\n-        * Remove the member type link.\n-        *\/\n-        if (lastLink == NULL)\n-        type->memberTypes = link->next;\n-        else\n-        lastLink->next = link->next;\n-        newLink = link;\n-        link = link->next;\n-        xmlFree(newLink);\n-    } else {\n-        link->type = memberType;\n-        lastLink = link;\n-        link = link->next;\n-    }\n-    }\n-    \/*\n-    * Add local simple types,\n-    *\/\n-    memberType = type->subtypes;\n-    while (memberType != NULL) {\n-    link = (xmlSchemaTypeLinkPtr) xmlMalloc(sizeof(xmlSchemaTypeLink));\n-    if (link == NULL) {\n-        xmlSchemaPErrMemory(ctxt);\n-        return (-1);\n-    }\n-    link->type = memberType;\n-    link->next = NULL;\n-    if (lastLink == NULL)\n-        type->memberTypes = link;\n-    else\n-        lastLink->next = link;\n-    lastLink = link;\n-    memberType = memberType->next;\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaIsDerivedFromBuiltInType:\n- * @ctxt:  the schema parser context\n- * @type:  the type definition\n- * @valType: the value type\n- *\n- *\n- * Returns 1 if the type has the given value type, or\n- * is derived from such a type.\n- *\/\n-static int\n-xmlSchemaIsDerivedFromBuiltInType(xmlSchemaTypePtr type, int valType)\n-{\n-    if (type == NULL)\n-    return (0);\n-    if (WXS_IS_COMPLEX(type))\n-    return (0);\n-    if (type->type == XML_SCHEMA_TYPE_BASIC) {\n-    if (type->builtInType == valType)\n-        return(1);\n-    if ((type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) ||\n-        (type->builtInType == XML_SCHEMAS_ANYTYPE))\n-        return (0);\n-    return(xmlSchemaIsDerivedFromBuiltInType(type->subtypes, valType));\n-    }\n-    return(xmlSchemaIsDerivedFromBuiltInType(type->subtypes, valType));\n-}\n-\n-#if 0\n-\/**\n- * xmlSchemaIsDerivedFromBuiltInType:\n- * @ctxt:  the schema parser context\n- * @type:  the type definition\n- * @valType: the value type\n- *\n- *\n- * Returns 1 if the type has the given value type, or\n- * is derived from such a type.\n- *\/\n-static int\n-xmlSchemaIsUserDerivedFromBuiltInType(xmlSchemaTypePtr type, int valType)\n-{\n-    if (type == NULL)\n-    return (0);\n-    if (WXS_IS_COMPLEX(type))\n-    return (0);\n-    if (type->type == XML_SCHEMA_TYPE_BASIC) {\n-    if (type->builtInType == valType)\n-        return(1);\n-    return (0);\n-    } else\n-    return(xmlSchemaIsDerivedFromBuiltInType(type->subtypes, valType));\n-\n-    return (0);\n-}\n-\n-static xmlSchemaTypePtr\n-xmlSchemaQueryBuiltInType(xmlSchemaTypePtr type)\n-{\n-    if (type == NULL)\n-    return (NULL);\n-    if (WXS_IS_COMPLEX(type))\n-    return (NULL);\n-    if (type->type == XML_SCHEMA_TYPE_BASIC)\n-    return(type);\n-    return(xmlSchemaQueryBuiltInType(type->subtypes));\n-}\n-#endif\n-\n-\/**\n- * xmlSchemaGetPrimitiveType:\n- * @type:  the simpleType definition\n- *\n- * Returns the primitive type of the given type or\n- * NULL in case of error.\n- *\/\n-static xmlSchemaTypePtr\n-xmlSchemaGetPrimitiveType(xmlSchemaTypePtr type)\n-{\n-\n-    while (type != NULL) {\n-    \/*\n-    * Note that anySimpleType is actually not a primitive type\n-    * but we need that here.\n-    *\/\n-    if ((type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) ||\n-       (type->flags & XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE))\n-        return (type);\n-    type = type->baseType;\n-    }\n-\n-    return (NULL);\n-}\n-\n-#if 0\n-\/**\n- * xmlSchemaGetBuiltInTypeAncestor:\n- * @type:  the simpleType definition\n- *\n- * Returns the primitive type of the given type or\n- * NULL in case of error.\n- *\/\n-static xmlSchemaTypePtr\n-xmlSchemaGetBuiltInTypeAncestor(xmlSchemaTypePtr type)\n-{\n-    if (WXS_IS_LIST(type) || WXS_IS_UNION(type))\n-    return (0);\n-    while (type != NULL) {\n-    if (type->type == XML_SCHEMA_TYPE_BASIC)\n-        return (type);\n-    type = type->baseType;\n-    }\n-\n-    return (NULL);\n-}\n-#endif\n-\n-\/**\n- * xmlSchemaCloneWildcardNsConstraints:\n- * @ctxt:  the schema parser context\n- * @dest:  the destination wildcard\n- * @source: the source wildcard\n- *\n- * Clones the namespace constraints of source\n- * and assigns them to dest.\n- * Returns -1 on internal error, 0 otherwise.\n- *\/\n-static int\n-xmlSchemaCloneWildcardNsConstraints(xmlSchemaParserCtxtPtr ctxt,\n-                    xmlSchemaWildcardPtr dest,\n-                    xmlSchemaWildcardPtr source)\n-{\n-    xmlSchemaWildcardNsPtr cur, tmp, last;\n-\n-    if ((source == NULL) || (dest == NULL))\n-    return(-1);\n-    dest->any = source->any;\n-    cur = source->nsSet;\n-    last = NULL;\n-    while (cur != NULL) {\n-    tmp = xmlSchemaNewWildcardNsConstraint(ctxt);\n-    if (tmp == NULL)\n-        return(-1);\n-    tmp->value = cur->value;\n-    if (last == NULL)\n-        dest->nsSet = tmp;\n-    else\n-        last->next = tmp;\n-    last = tmp;\n-    cur = cur->next;\n-    }\n-    if (dest->negNsSet != NULL)\n-    xmlSchemaFreeWildcardNsSet(dest->negNsSet);\n-    if (source->negNsSet != NULL) {\n-    dest->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);\n-    if (dest->negNsSet == NULL)\n-        return(-1);\n-    dest->negNsSet->value = source->negNsSet->value;\n-    } else\n-    dest->negNsSet = NULL;\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaUnionWildcards:\n- * @ctxt:  the schema parser context\n- * @completeWild:  the first wildcard\n- * @curWild: the second wildcard\n- *\n- * Unions the namespace constraints of the given wildcards.\n- * @completeWild will hold the resulting union.\n- * Returns a positive error code on failure, -1 in case of an\n- * internal error, 0 otherwise.\n- *\/\n-static int\n-xmlSchemaUnionWildcards(xmlSchemaParserCtxtPtr ctxt,\n-                xmlSchemaWildcardPtr completeWild,\n-                xmlSchemaWildcardPtr curWild)\n-{\n-    xmlSchemaWildcardNsPtr cur, curB, tmp;\n-\n-    \/*\n-    * 1 If O1 and O2 are the same value, then that value must be the\n-    * value.\n-    *\/\n-    if ((completeWild->any == curWild->any) &&\n-    ((completeWild->nsSet == NULL) == (curWild->nsSet == NULL)) &&\n-    ((completeWild->negNsSet == NULL) == (curWild->negNsSet == NULL))) {\n-\n-    if ((completeWild->negNsSet == NULL) ||\n-        (completeWild->negNsSet->value == curWild->negNsSet->value)) {\n-\n-        if (completeWild->nsSet != NULL) {\n-        int found = 0;\n-\n-        \/*\n-        * Check equality of sets.\n-        *\/\n-        cur = completeWild->nsSet;\n-        while (cur != NULL) {\n-            found = 0;\n-            curB = curWild->nsSet;\n-            while (curB != NULL) {\n-            if (cur->value == curB->value) {\n-                found = 1;\n-                break;\n-            }\n-            curB = curB->next;\n-            }\n-            if (!found)\n-            break;\n-            cur = cur->next;\n-        }\n-        if (found)\n-            return(0);\n-        } else\n-        return(0);\n-    }\n-    }\n-    \/*\n-    * 2 If either O1 or O2 is any, then any must be the value\n-    *\/\n-    if (completeWild->any != curWild->any) {\n-    if (completeWild->any == 0) {\n-        completeWild->any = 1;\n-        if (completeWild->nsSet != NULL) {\n-        xmlSchemaFreeWildcardNsSet(completeWild->nsSet);\n-        completeWild->nsSet = NULL;\n-        }\n-        if (completeWild->negNsSet != NULL) {\n-        xmlFree(completeWild->negNsSet);\n-        completeWild->negNsSet = NULL;\n-        }\n-    }\n-    return (0);\n-    }\n-    \/*\n-    * 3 If both O1 and O2 are sets of (namespace names or `absent`),\n-    * then the union of those sets must be the value.\n-    *\/\n-    if ((completeWild->nsSet != NULL) && (curWild->nsSet != NULL)) {\n-    int found;\n-    xmlSchemaWildcardNsPtr start;\n-\n-    cur = curWild->nsSet;\n-    start = completeWild->nsSet;\n-    while (cur != NULL) {\n-        found = 0;\n-        curB = start;\n-        while (curB != NULL) {\n-        if (cur->value == curB->value) {\n-            found = 1;\n-            break;\n-        }\n-        curB = curB->next;\n-        }\n-        if (!found) {\n-        tmp = xmlSchemaNewWildcardNsConstraint(ctxt);\n-        if (tmp == NULL)\n-            return (-1);\n-        tmp->value = cur->value;\n-        tmp->next = completeWild->nsSet;\n-        completeWild->nsSet = tmp;\n-        }\n-        cur = cur->next;\n-    }\n-\n-    return(0);\n-    }\n-    \/*\n-    * 4 If the two are negations of different values (namespace names\n-    * or `absent`), then a pair of not and `absent` must be the value.\n-    *\/\n-    if ((completeWild->negNsSet != NULL) &&\n-    (curWild->negNsSet != NULL) &&\n-    (completeWild->negNsSet->value != curWild->negNsSet->value)) {\n-    completeWild->negNsSet->value = NULL;\n-\n-    return(0);\n-    }\n-    \/*\n-     * 5.\n-     *\/\n-    if (((completeWild->negNsSet != NULL) &&\n-    (completeWild->negNsSet->value != NULL) &&\n-    (curWild->nsSet != NULL)) ||\n-    ((curWild->negNsSet != NULL) &&\n-    (curWild->negNsSet->value != NULL) &&\n-    (completeWild->nsSet != NULL))) {\n-\n-    int nsFound, absentFound = 0;\n-\n-    if (completeWild->nsSet != NULL) {\n-        cur = completeWild->nsSet;\n-        curB = curWild->negNsSet;\n-    } else {\n-        cur = curWild->nsSet;\n-        curB = completeWild->negNsSet;\n-    }\n-    nsFound = 0;\n-    while (cur != NULL) {\n-        if (cur->value == NULL)\n-        absentFound = 1;\n-        else if (cur->value == curB->value)\n-        nsFound = 1;\n-        if (nsFound && absentFound)\n-        break;\n-        cur = cur->next;\n-    }\n-\n-    if (nsFound && absentFound) {\n-        \/*\n-        * 5.1 If the set S includes both the negated namespace\n-        * name and `absent`, then any must be the value.\n-        *\/\n-        completeWild->any = 1;\n-        if (completeWild->nsSet != NULL) {\n-        xmlSchemaFreeWildcardNsSet(completeWild->nsSet);\n-        completeWild->nsSet = NULL;\n-        }\n-        if (completeWild->negNsSet != NULL) {\n-        xmlFree(completeWild->negNsSet);\n-        completeWild->negNsSet = NULL;\n-        }\n-    } else if (nsFound && (!absentFound)) {\n-        \/*\n-        * 5.2 If the set S includes the negated namespace name\n-        * but not `absent`, then a pair of not and `absent` must\n-        * be the value.\n-        *\/\n-        if (completeWild->nsSet != NULL) {\n-        xmlSchemaFreeWildcardNsSet(completeWild->nsSet);\n-        completeWild->nsSet = NULL;\n-        }\n-        if (completeWild->negNsSet == NULL) {\n-        completeWild->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);\n-        if (completeWild->negNsSet == NULL)\n-            return (-1);\n-        }\n-        completeWild->negNsSet->value = NULL;\n-    } else if ((!nsFound) && absentFound) {\n-        \/*\n-        * 5.3 If the set S includes `absent` but not the negated\n-        * namespace name, then the union is not expressible.\n-        *\/\n-        xmlSchemaPErr(ctxt, completeWild->node,\n-        XML_SCHEMAP_UNION_NOT_EXPRESSIBLE,\n-        \"The union of the wildcard is not expressible.\\n\",\n-        NULL, NULL);\n-        return(XML_SCHEMAP_UNION_NOT_EXPRESSIBLE);\n-    } else if ((!nsFound) && (!absentFound)) {\n-        \/*\n-        * 5.4 If the set S does not include either the negated namespace\n-        * name or `absent`, then whichever of O1 or O2 is a pair of not\n-        * and a namespace name must be the value.\n-        *\/\n-        if (completeWild->negNsSet == NULL) {\n-        if (completeWild->nsSet != NULL) {\n-            xmlSchemaFreeWildcardNsSet(completeWild->nsSet);\n-            completeWild->nsSet = NULL;\n-        }\n-        completeWild->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);\n-        if (completeWild->negNsSet == NULL)\n-            return (-1);\n-        completeWild->negNsSet->value = curWild->negNsSet->value;\n-        }\n-    }\n-    return (0);\n-    }\n-    \/*\n-     * 6.\n-     *\/\n-    if (((completeWild->negNsSet != NULL) &&\n-    (completeWild->negNsSet->value == NULL) &&\n-    (curWild->nsSet != NULL)) ||\n-    ((curWild->negNsSet != NULL) &&\n-    (curWild->negNsSet->value == NULL) &&\n-    (completeWild->nsSet != NULL))) {\n-\n-    if (completeWild->nsSet != NULL) {\n-        cur = completeWild->nsSet;\n-    } else {\n-        cur = curWild->nsSet;\n-    }\n-    while (cur != NULL) {\n-        if (cur->value == NULL) {\n-        \/*\n-        * 6.1 If the set S includes `absent`, then any must be the\n-        * value.\n-        *\/\n-        completeWild->any = 1;\n-        if (completeWild->nsSet != NULL) {\n-            xmlSchemaFreeWildcardNsSet(completeWild->nsSet);\n-            completeWild->nsSet = NULL;\n-        }\n-        if (completeWild->negNsSet != NULL) {\n-            xmlFree(completeWild->negNsSet);\n-            completeWild->negNsSet = NULL;\n-        }\n-        return (0);\n-        }\n-        cur = cur->next;\n-    }\n-    if (completeWild->negNsSet == NULL) {\n-        \/*\n-        * 6.2 If the set S does not include `absent`, then a pair of not\n-        * and `absent` must be the value.\n-        *\/\n-        if (completeWild->nsSet != NULL) {\n-        xmlSchemaFreeWildcardNsSet(completeWild->nsSet);\n-        completeWild->nsSet = NULL;\n-        }\n-        completeWild->negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);\n-        if (completeWild->negNsSet == NULL)\n-        return (-1);\n-        completeWild->negNsSet->value = NULL;\n-    }\n-    return (0);\n-    }\n-    return (0);\n-\n-}\n-\n-\/**\n- * xmlSchemaIntersectWildcards:\n- * @ctxt:  the schema parser context\n- * @completeWild:  the first wildcard\n- * @curWild: the second wildcard\n- *\n- * Intersects the namespace constraints of the given wildcards.\n- * @completeWild will hold the resulting intersection.\n- * Returns a positive error code on failure, -1 in case of an\n- * internal error, 0 otherwise.\n- *\/\n-static int\n-xmlSchemaIntersectWildcards(xmlSchemaParserCtxtPtr ctxt,\n-                xmlSchemaWildcardPtr completeWild,\n-                xmlSchemaWildcardPtr curWild)\n-{\n-    xmlSchemaWildcardNsPtr cur, curB, prev,  tmp;\n-\n-    \/*\n-    * 1 If O1 and O2 are the same value, then that value must be the\n-    * value.\n-    *\/\n-    if ((completeWild->any == curWild->any) &&\n-    ((completeWild->nsSet == NULL) == (curWild->nsSet == NULL)) &&\n-    ((completeWild->negNsSet == NULL) == (curWild->negNsSet == NULL))) {\n-\n-    if ((completeWild->negNsSet == NULL) ||\n-        (completeWild->negNsSet->value == curWild->negNsSet->value)) {\n-\n-        if (completeWild->nsSet != NULL) {\n-        int found = 0;\n-\n-        \/*\n-        * Check equality of sets.\n-        *\/\n-        cur = completeWild->nsSet;\n-        while (cur != NULL) {\n-            found = 0;\n-            curB = curWild->nsSet;\n-            while (curB != NULL) {\n-            if (cur->value == curB->value) {\n-                found = 1;\n-                break;\n-            }\n-            curB = curB->next;\n-            }\n-            if (!found)\n-            break;\n-            cur = cur->next;\n-        }\n-        if (found)\n-            return(0);\n-        } else\n-        return(0);\n-    }\n-    }\n-    \/*\n-    * 2 If either O1 or O2 is any, then the other must be the value.\n-    *\/\n-    if ((completeWild->any != curWild->any) && (completeWild->any)) {\n-    if (xmlSchemaCloneWildcardNsConstraints(ctxt, completeWild, curWild) == -1)\n-        return(-1);\n-    return(0);\n-    }\n-    \/*\n-    * 3 If either O1 or O2 is a pair of not and a value (a namespace\n-    * name or `absent`) and the other is a set of (namespace names or\n-    * `absent`), then that set, minus the negated value if it was in\n-    * the set, minus `absent` if it was in the set, must be the value.\n-    *\/\n-    if (((completeWild->negNsSet != NULL) && (curWild->nsSet != NULL)) ||\n-    ((curWild->negNsSet != NULL) && (completeWild->nsSet != NULL))) {\n-    const xmlChar *neg;\n-\n-    if (completeWild->nsSet == NULL) {\n-        neg = completeWild->negNsSet->value;\n-        if (xmlSchemaCloneWildcardNsConstraints(ctxt, completeWild, curWild) == -1)\n-        return(-1);\n-    } else\n-        neg = curWild->negNsSet->value;\n-    \/*\n-    * Remove absent and negated.\n-    *\/\n-    prev = NULL;\n-    cur = completeWild->nsSet;\n-    while (cur != NULL) {\n-        if (cur->value == NULL) {\n-        if (prev == NULL)\n-            completeWild->nsSet = cur->next;\n-        else\n-            prev->next = cur->next;\n-        xmlFree(cur);\n-        break;\n-        }\n-        prev = cur;\n-        cur = cur->next;\n-    }\n-    if (neg != NULL) {\n-        prev = NULL;\n-        cur = completeWild->nsSet;\n-        while (cur != NULL) {\n-        if (cur->value == neg) {\n-            if (prev == NULL)\n-            completeWild->nsSet = cur->next;\n-            else\n-            prev->next = cur->next;\n-            xmlFree(cur);\n-            break;\n-        }\n-        prev = cur;\n-        cur = cur->next;\n-        }\n-    }\n-\n-    return(0);\n-    }\n-    \/*\n-    * 4 If both O1 and O2 are sets of (namespace names or `absent`),\n-    * then the intersection of those sets must be the value.\n-    *\/\n-    if ((completeWild->nsSet != NULL) && (curWild->nsSet != NULL)) {\n-    int found;\n-\n-    cur = completeWild->nsSet;\n-    prev = NULL;\n-    while (cur != NULL) {\n-        found = 0;\n-        curB = curWild->nsSet;\n-        while (curB != NULL) {\n-        if (cur->value == curB->value) {\n-            found = 1;\n-            break;\n-        }\n-        curB = curB->next;\n-        }\n-        if (!found) {\n-        if (prev == NULL)\n-            completeWild->nsSet = cur->next;\n-        else\n-            prev->next = cur->next;\n-        tmp = cur->next;\n-        xmlFree(cur);\n-        cur = tmp;\n-        continue;\n-        }\n-        prev = cur;\n-        cur = cur->next;\n-    }\n-\n-    return(0);\n-    }\n-    \/* 5 If the two are negations of different namespace names,\n-    * then the intersection is not expressible\n-    *\/\n-    if ((completeWild->negNsSet != NULL) &&\n-    (curWild->negNsSet != NULL) &&\n-    (completeWild->negNsSet->value != curWild->negNsSet->value) &&\n-    (completeWild->negNsSet->value != NULL) &&\n-    (curWild->negNsSet->value != NULL)) {\n-\n-    xmlSchemaPErr(ctxt, completeWild->node, XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE,\n-        \"The intersection of the wildcard is not expressible.\\n\",\n-        NULL, NULL);\n-    return(XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE);\n-    }\n-    \/*\n-    * 6 If the one is a negation of a namespace name and the other\n-    * is a negation of `absent`, then the one which is the negation\n-    * of a namespace name must be the value.\n-    *\/\n-    if ((completeWild->negNsSet != NULL) && (curWild->negNsSet != NULL) &&\n-    (completeWild->negNsSet->value != curWild->negNsSet->value) &&\n-    (completeWild->negNsSet->value == NULL)) {\n-    completeWild->negNsSet->value =  curWild->negNsSet->value;\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaIsWildcardNsConstraintSubset:\n- * @ctxt:  the schema parser context\n- * @sub:  the first wildcard\n- * @super: the second wildcard\n- *\n- * Schema Component Constraint: Wildcard Subset (cos-ns-subset)\n- *\n- * Returns 0 if the namespace constraint of @sub is an intensional\n- * subset of @super, 1 otherwise.\n- *\/\n-static int\n-xmlSchemaCheckCOSNSSubset(xmlSchemaWildcardPtr sub,\n-              xmlSchemaWildcardPtr super)\n-{\n-    \/*\n-    * 1 super must be any.\n-    *\/\n-    if (super->any)\n-    return (0);\n-    \/*\n-    * 2.1 sub must be a pair of not and a namespace name or `absent`.\n-    * 2.2 super must be a pair of not and the same value.\n-    *\/\n-    if ((sub->negNsSet != NULL) &&\n-    (super->negNsSet != NULL) &&\n-    (sub->negNsSet->value == super->negNsSet->value))\n-    return (0);\n-    \/*\n-    * 3.1 sub must be a set whose members are either namespace names or `absent`.\n-    *\/\n-    if (sub->nsSet != NULL) {\n-    \/*\n-    * 3.2.1 super must be the same set or a superset thereof.\n-    *\/\n-    if (super->nsSet != NULL) {\n-        xmlSchemaWildcardNsPtr cur, curB;\n-        int found = 0;\n-\n-        cur = sub->nsSet;\n-        while (cur != NULL) {\n-        found = 0;\n-        curB = super->nsSet;\n-        while (curB != NULL) {\n-            if (cur->value == curB->value) {\n-            found = 1;\n-            break;\n-            }\n-            curB = curB->next;\n-        }\n-        if (!found)\n-            return (1);\n-        cur = cur->next;\n-        }\n-        if (found)\n-        return (0);\n-    } else if (super->negNsSet != NULL) {\n-        xmlSchemaWildcardNsPtr cur;\n-        \/*\n-        * 3.2.2 super must be a pair of not and a namespace name or\n-        * `absent` and that value must not be in sub's set.\n-        *\/\n-        cur = sub->nsSet;\n-        while (cur != NULL) {\n-        if (cur->value == super->negNsSet->value)\n-            return (1);\n-        cur = cur->next;\n-        }\n-        return (0);\n-    }\n-    }\n-    return (1);\n-}\n-\n-static int\n-xmlSchemaGetEffectiveValueConstraint(xmlSchemaAttributeUsePtr attruse,\n-                     int *fixed,\n-                     const xmlChar **value,\n-                     xmlSchemaValPtr *val)\n-{\n-    *fixed = 0;\n-    *value = NULL;\n-    if (val != 0)\n-    *val = NULL;\n-\n-    if (attruse->defValue != NULL) {\n-    *value = attruse->defValue;\n-    if (val != NULL)\n-        *val = attruse->defVal;\n-    if (attruse->flags & XML_SCHEMA_ATTR_USE_FIXED)\n-        *fixed = 1;\n-    return(1);\n-    } else if ((attruse->attrDecl != NULL) &&\n-    (attruse->attrDecl->defValue != NULL)) {\n-    *value = attruse->attrDecl->defValue;\n-    if (val != NULL)\n-        *val = attruse->attrDecl->defVal;\n-    if (attruse->attrDecl->flags & XML_SCHEMAS_ATTR_FIXED)\n-        *fixed = 1;\n-    return(1);\n-    }\n-    return(0);\n-}\n-\/**\n- * xmlSchemaCheckCVCWildcardNamespace:\n- * @wild:  the wildcard\n- * @ns:  the namespace\n- *\n- * Validation Rule: Wildcard allows Namespace Name\n- * (cvc-wildcard-namespace)\n- *\n- * Returns 0 if the given namespace matches the wildcard,\n- * 1 otherwise and -1 on API errors.\n- *\/\n-static int\n-xmlSchemaCheckCVCWildcardNamespace(xmlSchemaWildcardPtr wild,\n-                   const xmlChar* ns)\n-{\n-    if (wild == NULL)\n-    return(-1);\n-\n-    if (wild->any)\n-    return(0);\n-    else if (wild->nsSet != NULL) {\n-    xmlSchemaWildcardNsPtr cur;\n-\n-    cur = wild->nsSet;\n-    while (cur != NULL) {\n-        if (xmlStrEqual(cur->value, ns))\n-        return(0);\n-        cur = cur->next;\n-    }\n-    } else if ((wild->negNsSet != NULL) && (ns != NULL) &&\n-    (!xmlStrEqual(wild->negNsSet->value, ns)))\n-    return(0);\n-\n-    return(1);\n-}\n-\n-#define XML_SCHEMA_ACTION_DERIVE 0\n-#define XML_SCHEMA_ACTION_REDEFINE 1\n-\n-#define WXS_ACTION_STR(a) \\\n-((a) == XML_SCHEMA_ACTION_DERIVE) ? (const xmlChar *) \"base\" : (const xmlChar *) \"redefined\"\n-\n-\/*\n-* Schema Component Constraint:\n-*   Derivation Valid (Restriction, Complex)\n-*   derivation-ok-restriction (2) - (4)\n-*\n-* ATTENTION:\n-* In XML Schema 1.1 this will be:\n-* Validation Rule:\n-*     Checking complex type subsumption (practicalSubsumption) (1, 2 and 3)\n-*\n-*\/\n-static int\n-xmlSchemaCheckDerivationOKRestriction2to4(xmlSchemaParserCtxtPtr pctxt,\n-                       int action,\n-                       xmlSchemaBasicItemPtr item,\n-                       xmlSchemaBasicItemPtr baseItem,\n-                       xmlSchemaItemListPtr uses,\n-                       xmlSchemaItemListPtr baseUses,\n-                       xmlSchemaWildcardPtr wild,\n-                       xmlSchemaWildcardPtr baseWild)\n-{\n-    xmlSchemaAttributeUsePtr cur = NULL, bcur;\n-    int i, j, found; \/* err = 0; *\/\n-    const xmlChar *bEffValue;\n-    int effFixed;\n-\n-    if (uses != NULL) {\n-    for (i = 0; i < uses->nbItems; i++) {\n-        cur = uses->items[i];\n-        found = 0;\n-        if (baseUses == NULL)\n-        goto not_found;\n-        for (j = 0; j < baseUses->nbItems; j++) {\n-        bcur = baseUses->items[j];\n-        if ((WXS_ATTRUSE_DECL_NAME(cur) ==\n-            WXS_ATTRUSE_DECL_NAME(bcur)) &&\n-            (WXS_ATTRUSE_DECL_TNS(cur) ==\n-            WXS_ATTRUSE_DECL_TNS(bcur)))\n-        {\n-            \/*\n-            * (2.1) \"If there is an attribute use in the {attribute\n-            * uses} of the {base type definition} (call this B) whose\n-            * {attribute declaration} has the same {name} and {target\n-            * namespace}, then  all of the following must be true:\"\n-            *\/\n-            found = 1;\n-\n-            if ((cur->occurs == XML_SCHEMAS_ATTR_USE_OPTIONAL) &&\n-            (bcur->occurs == XML_SCHEMAS_ATTR_USE_REQUIRED))\n-            {\n-            xmlChar *str = NULL;\n-            \/*\n-            * (2.1.1) \"one of the following must be true:\"\n-            * (2.1.1.1) \"B's {required} is false.\"\n-            * (2.1.1.2) \"R's {required} is true.\"\n-            *\/\n-            xmlSchemaPAttrUseErr4(pctxt,\n-                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1,\n-                WXS_ITEM_NODE(item), item, cur,\n-                \"The 'optional' attribute use is inconsistent \"\n-                \"with the corresponding 'required' attribute use of \"\n-                \"the %s %s\",\n-                WXS_ACTION_STR(action),\n-                xmlSchemaGetComponentDesignation(&str, baseItem),\n-                NULL, NULL);\n-            FREE_AND_NULL(str);\n-            \/* err = pctxt->err; *\/\n-            } else if (xmlSchemaCheckCOSSTDerivedOK(ACTXT_CAST pctxt,\n-            WXS_ATTRUSE_TYPEDEF(cur),\n-            WXS_ATTRUSE_TYPEDEF(bcur), 0) != 0)\n-            {\n-            xmlChar *strA = NULL, *strB = NULL, *strC = NULL;\n-\n-            \/*\n-            * SPEC (2.1.2) \"R's {attribute declaration}'s\n-            * {type definition} must be validly derived from\n-            * B's {type definition} given the empty set as\n-            * defined in Type Derivation OK (Simple) ($3.14.6).\"\n-            *\/\n-            xmlSchemaPAttrUseErr4(pctxt,\n-                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2,\n-                WXS_ITEM_NODE(item), item, cur,\n-                \"The attribute declaration's %s \"\n-                \"is not validly derived from \"\n-                \"the corresponding %s of the \"\n-                \"attribute declaration in the %s %s\",\n-                xmlSchemaGetComponentDesignation(&strA,\n-                WXS_ATTRUSE_TYPEDEF(cur)),\n-                xmlSchemaGetComponentDesignation(&strB,\n-                WXS_ATTRUSE_TYPEDEF(bcur)),\n-                WXS_ACTION_STR(action),\n-                xmlSchemaGetComponentDesignation(&strC, baseItem));\n-                \/* xmlSchemaGetComponentDesignation(&str, baseItem), *\/\n-            FREE_AND_NULL(strA);\n-            FREE_AND_NULL(strB);\n-            FREE_AND_NULL(strC);\n-            \/* err = pctxt->err; *\/\n-            } else {\n-            \/*\n-            * 2.1.3 [Definition:]  Let the effective value\n-            * constraint of an attribute use be its {value\n-            * constraint}, if present, otherwise its {attribute\n-            * declaration}'s {value constraint} .\n-            *\/\n-            xmlSchemaGetEffectiveValueConstraint(bcur,\n-                &effFixed, &bEffValue, NULL);\n-            \/*\n-            * 2.1.3 ... one of the following must be true\n-            *\n-            * 2.1.3.1 B's `effective value constraint` is\n-            * `absent` or default.\n-            *\/\n-            if ((bEffValue != NULL) &&\n-                (effFixed == 1)) {\n-                const xmlChar *rEffValue = NULL;\n-\n-                xmlSchemaGetEffectiveValueConstraint(bcur,\n-                &effFixed, &rEffValue, NULL);\n-                \/*\n-                * 2.1.3.2 R's `effective value constraint` is\n-                * fixed with the same string as B's.\n-                * MAYBE TODO: Compare the computed values.\n-                *       Hmm, it says \"same string\" so\n-                *       string-equality might really be sufficient.\n-                *\/\n-                if ((effFixed == 0) ||\n-                (! WXS_ARE_DEFAULT_STR_EQUAL(rEffValue, bEffValue)))\n-                {\n-                xmlChar *str = NULL;\n-\n-                xmlSchemaPAttrUseErr4(pctxt,\n-                    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3,\n-                    WXS_ITEM_NODE(item), item, cur,\n-                    \"The effective value constraint of the \"\n-                    \"attribute use is inconsistent with \"\n-                    \"its correspondent in the %s %s\",\n-                    WXS_ACTION_STR(action),\n-                    xmlSchemaGetComponentDesignation(&str,\n-                    baseItem),\n-                    NULL, NULL);\n-                FREE_AND_NULL(str);\n-                \/* err = pctxt->err; *\/\n-                }\n-            }\n-            }\n-            break;\n-        }\n-        }\n-not_found:\n-        if (!found) {\n-        \/*\n-        * (2.2) \"otherwise the {base type definition} must have an\n-        * {attribute wildcard} and the {target namespace} of the\n-        * R's {attribute declaration} must be `valid` with respect\n-        * to that wildcard, as defined in Wildcard allows Namespace\n-        * Name ($3.10.4).\"\n-        *\/\n-        if ((baseWild == NULL) ||\n-            (xmlSchemaCheckCVCWildcardNamespace(baseWild,\n-            (WXS_ATTRUSE_DECL(cur))->targetNamespace) != 0))\n-        {\n-            xmlChar *str = NULL;\n-\n-            xmlSchemaPAttrUseErr4(pctxt,\n-            XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2,\n-            WXS_ITEM_NODE(item), item, cur,\n-            \"Neither a matching attribute use, \"\n-            \"nor a matching wildcard exists in the %s %s\",\n-            WXS_ACTION_STR(action),\n-            xmlSchemaGetComponentDesignation(&str, baseItem),\n-            NULL, NULL);\n-            FREE_AND_NULL(str);\n-            \/* err = pctxt->err; *\/\n-        }\n-        }\n-    }\n-    }\n-    \/*\n-    * SPEC derivation-ok-restriction (3):\n-    * (3) \"For each attribute use in the {attribute uses} of the {base type\n-    * definition} whose {required} is true, there must be an attribute\n-    * use with an {attribute declaration} with the same {name} and\n-    * {target namespace} as its {attribute declaration} in the {attribute\n-    * uses} of the complex type definition itself whose {required} is true.\n-    *\/\n-    if (baseUses != NULL) {\n-    for (j = 0; j < baseUses->nbItems; j++) {\n-        bcur = baseUses->items[j];\n-        if (bcur->occurs != XML_SCHEMAS_ATTR_USE_REQUIRED)\n-        continue;\n-        found = 0;\n-        if (uses != NULL) {\n-        for (i = 0; i < uses->nbItems; i++) {\n-            cur = uses->items[i];\n-            if ((WXS_ATTRUSE_DECL_NAME(cur) ==\n-            WXS_ATTRUSE_DECL_NAME(bcur)) &&\n-            (WXS_ATTRUSE_DECL_TNS(cur) ==\n-            WXS_ATTRUSE_DECL_TNS(bcur))) {\n-            found = 1;\n-            break;\n-            }\n-        }\n-        }\n-        if (!found) {\n-        xmlChar *strA = NULL, *strB = NULL;\n-\n-        xmlSchemaCustomErr4(ACTXT_CAST pctxt,\n-            XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3,\n-            NULL, item,\n-            \"A matching attribute use for the \"\n-            \"'required' %s of the %s %s is missing\",\n-            xmlSchemaGetComponentDesignation(&strA, bcur),\n-            WXS_ACTION_STR(action),\n-            xmlSchemaGetComponentDesignation(&strB, baseItem),\n-            NULL);\n-        FREE_AND_NULL(strA);\n-        FREE_AND_NULL(strB);\n-        }\n-    }\n-    }\n-    \/*\n-    * derivation-ok-restriction (4)\n-    *\/\n-    if (wild != NULL) {\n-    \/*\n-    * (4) \"If there is an {attribute wildcard}, all of the\n-    * following must be true:\"\n-    *\/\n-    if (baseWild == NULL) {\n-        xmlChar *str = NULL;\n-\n-        \/*\n-        * (4.1) \"The {base type definition} must also have one.\"\n-        *\/\n-        xmlSchemaCustomErr4(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1,\n-        NULL, item,\n-        \"The %s has an attribute wildcard, \"\n-        \"but the %s %s '%s' does not have one\",\n-        WXS_ITEM_TYPE_NAME(item),\n-        WXS_ACTION_STR(action),\n-        WXS_ITEM_TYPE_NAME(baseItem),\n-        xmlSchemaGetComponentQName(&str, baseItem));\n-        FREE_AND_NULL(str);\n-        return(pctxt->err);\n-    } else if ((baseWild->any == 0) &&\n-        xmlSchemaCheckCOSNSSubset(wild, baseWild))\n-    {\n-        xmlChar *str = NULL;\n-        \/*\n-        * (4.2) \"The complex type definition's {attribute wildcard}'s\n-        * {namespace constraint} must be a subset of the {base type\n-        * definition}'s {attribute wildcard}'s {namespace constraint},\n-        * as defined by Wildcard Subset ($3.10.6).\"\n-        *\/\n-        xmlSchemaCustomErr4(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2,\n-        NULL, item,\n-        \"The attribute wildcard is not a valid \"\n-        \"subset of the wildcard in the %s %s '%s'\",\n-        WXS_ACTION_STR(action),\n-        WXS_ITEM_TYPE_NAME(baseItem),\n-        xmlSchemaGetComponentQName(&str, baseItem),\n-        NULL);\n-        FREE_AND_NULL(str);\n-        return(pctxt->err);\n-    }\n-    \/* 4.3 Unless the {base type definition} is the `ur-type\n-    * definition`, the complex type definition's {attribute\n-    * wildcard}'s {process contents} must be identical to or\n-    * stronger than the {base type definition}'s {attribute\n-    * wildcard}'s {process contents}, where strict is stronger\n-    * than lax is stronger than skip.\n-    *\/\n-    if ((! WXS_IS_ANYTYPE(baseItem)) &&\n-        (wild->processContents < baseWild->processContents)) {\n-        xmlChar *str = NULL;\n-        xmlSchemaCustomErr4(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3,\n-        NULL, baseItem,\n-        \"The {process contents} of the attribute wildcard is \"\n-        \"weaker than the one in the %s %s '%s'\",\n-        WXS_ACTION_STR(action),\n-        WXS_ITEM_TYPE_NAME(baseItem),\n-        xmlSchemaGetComponentQName(&str, baseItem),\n-        NULL);\n-        FREE_AND_NULL(str)\n-        return(pctxt->err);\n-    }\n-    }\n-    return(0);\n-}\n-\n-\n-static int\n-xmlSchemaExpandAttributeGroupRefs(xmlSchemaParserCtxtPtr pctxt,\n-                  xmlSchemaBasicItemPtr item,\n-                  xmlSchemaWildcardPtr *completeWild,\n-                  xmlSchemaItemListPtr list,\n-                  xmlSchemaItemListPtr prohibs);\n-\/**\n- * xmlSchemaFixupTypeAttributeUses:\n- * @ctxt:  the schema parser context\n- * @type:  the complex type definition\n- *\n- *\n- * Builds the wildcard and the attribute uses on the given complex type.\n- * Returns -1 if an internal error occurs, 0 otherwise.\n- *\n- * ATTENTION TODO: Experimentally this uses pointer comparisons for\n- * strings, so recheck this if we start to hardcode some schemata, since\n- * they might not be in the same dict.\n- * NOTE: It is allowed to \"extend\" the xs:anyType type.\n- *\/\n-static int\n-xmlSchemaFixupTypeAttributeUses(xmlSchemaParserCtxtPtr pctxt,\n-                  xmlSchemaTypePtr type)\n-{\n-    xmlSchemaTypePtr baseType = NULL;\n-    xmlSchemaAttributeUsePtr use;\n-    xmlSchemaItemListPtr uses, baseUses, prohibs = NULL;\n-\n-    if (type->baseType == NULL) {\n-    PERROR_INT(\"xmlSchemaFixupTypeAttributeUses\",\n-        \"no base type\");\n-        return (-1);\n-    }\n-    baseType = type->baseType;\n-    if (WXS_IS_TYPE_NOT_FIXED(baseType))\n-    if (xmlSchemaTypeFixup(baseType, ACTXT_CAST pctxt) == -1)\n-        return(-1);\n-\n-    uses = type->attrUses;\n-    baseUses = baseType->attrUses;\n-    \/*\n-    * Expand attribute group references. And build the 'complete'\n-    * wildcard, i.e. intersect multiple wildcards.\n-    * Move attribute prohibitions into a separate list.\n-    *\/\n-    if (uses != NULL) {\n-    if (WXS_IS_RESTRICTION(type)) {\n-        \/*\n-        * This one will transfer all attr. prohibitions\n-        * into pctxt->attrProhibs.\n-        *\/\n-        if (xmlSchemaExpandAttributeGroupRefs(pctxt,\n-        WXS_BASIC_CAST type, &(type->attributeWildcard), uses,\n-        pctxt->attrProhibs) == -1)\n-        {\n-        PERROR_INT(\"xmlSchemaFixupTypeAttributeUses\",\n-        \"failed to expand attributes\");\n-                return(-1);\n-        }\n-        if (pctxt->attrProhibs->nbItems != 0)\n-        prohibs = pctxt->attrProhibs;\n-    } else {\n-        if (xmlSchemaExpandAttributeGroupRefs(pctxt,\n-        WXS_BASIC_CAST type, &(type->attributeWildcard), uses,\n-        NULL) == -1)\n-        {\n-        PERROR_INT(\"xmlSchemaFixupTypeAttributeUses\",\n-        \"failed to expand attributes\");\n-                return(-1);\n-        }\n-    }\n-    }\n-    \/*\n-    * Inherit the attribute uses of the base type.\n-    *\/\n-    if (baseUses != NULL) {\n-    int i, j;\n-    xmlSchemaAttributeUseProhibPtr pro;\n-\n-    if (WXS_IS_RESTRICTION(type)) {\n-        int usesCount;\n-        xmlSchemaAttributeUsePtr tmp;\n-\n-        if (uses != NULL)\n-        usesCount = uses->nbItems;\n-        else\n-        usesCount = 0;\n-\n-        \/* Restriction. *\/\n-        for (i = 0; i < baseUses->nbItems; i++) {\n-        use = baseUses->items[i];\n-        if (prohibs) {\n-            \/*\n-            * Filter out prohibited uses.\n-            *\/\n-            for (j = 0; j < prohibs->nbItems; j++) {\n-            pro = prohibs->items[j];\n-            if ((WXS_ATTRUSE_DECL_NAME(use) == pro->name) &&\n-                (WXS_ATTRUSE_DECL_TNS(use) ==\n-                pro->targetNamespace))\n-            {\n-                goto inherit_next;\n-            }\n-            }\n-        }\n-        if (usesCount) {\n-            \/*\n-            * Filter out existing uses.\n-            *\/\n-            for (j = 0; j < usesCount; j++) {\n-            tmp = uses->items[j];\n-            if ((WXS_ATTRUSE_DECL_NAME(use) ==\n-                WXS_ATTRUSE_DECL_NAME(tmp)) &&\n-                (WXS_ATTRUSE_DECL_TNS(use) ==\n-                WXS_ATTRUSE_DECL_TNS(tmp)))\n-            {\n-                goto inherit_next;\n-            }\n-            }\n-        }\n-        if (uses == NULL) {\n-            type->attrUses = xmlSchemaItemListCreate();\n-            if (type->attrUses == NULL)\n-            goto exit_failure;\n-            uses = type->attrUses;\n-        }\n-        xmlSchemaItemListAddSize(uses, 2, use);\n-inherit_next: {}\n-        }\n-    } else {\n-        \/* Extension. *\/\n-        for (i = 0; i < baseUses->nbItems; i++) {\n-        use = baseUses->items[i];\n-        if (uses == NULL) {\n-            type->attrUses = xmlSchemaItemListCreate();\n-            if (type->attrUses == NULL)\n-            goto exit_failure;\n-            uses = type->attrUses;\n-        }\n-        xmlSchemaItemListAddSize(uses, baseUses->nbItems, use);\n-        }\n-    }\n-    }\n-    \/*\n-    * Shrink attr. uses.\n-    *\/\n-    if (uses) {\n-    if (uses->nbItems == 0) {\n-        xmlSchemaItemListFree(uses);\n-        type->attrUses = NULL;\n-    }\n-    \/*\n-    * TODO: We could shrink the size of the array\n-    * to fit the actual number of items.\n-    *\/\n-    }\n-    \/*\n-    * Compute the complete wildcard.\n-    *\/\n-    if (WXS_IS_EXTENSION(type)) {\n-    if (baseType->attributeWildcard != NULL) {\n-        \/*\n-        * (3.2.2.1) \"If the `base wildcard` is non-`absent`, then\n-        * the appropriate case among the following:\"\n-        *\/\n-        if (type->attributeWildcard != NULL) {\n-        \/*\n-        * Union the complete wildcard with the base wildcard.\n-        * SPEC {attribute wildcard}\n-        * (3.2.2.1.2) \"otherwise a wildcard whose {process contents}\n-        * and {annotation} are those of the `complete wildcard`,\n-        * and whose {namespace constraint} is the intensional union\n-        * of the {namespace constraint} of the `complete wildcard`\n-        * and of the `base wildcard`, as defined in Attribute\n-        * Wildcard Union ($3.10.6).\"\n-        *\/\n-        if (xmlSchemaUnionWildcards(pctxt, type->attributeWildcard,\n-            baseType->attributeWildcard) == -1)\n-            goto exit_failure;\n-        } else {\n-        \/*\n-        * (3.2.2.1.1) \"If the `complete wildcard` is `absent`,\n-        * then the `base wildcard`.\"\n-        *\/\n-        type->attributeWildcard = baseType->attributeWildcard;\n-        }\n-    } else {\n-        \/*\n-        * (3.2.2.2) \"otherwise (the `base wildcard` is `absent`) the\n-        * `complete wildcard`\"\n-        * NOOP\n-        *\/\n-    }\n-    } else {\n-    \/*\n-    * SPEC {attribute wildcard}\n-    * (3.1) \"If the <restriction> alternative is chosen, then the\n-    * `complete wildcard`;\"\n-    * NOOP\n-    *\/\n-    }\n-\n-    return (0);\n-\n-exit_failure:\n-    return(-1);\n-}\n-\n-\/**\n- * xmlSchemaTypeFinalContains:\n- * @schema:  the schema\n- * @type:  the type definition\n- * @final: the final\n- *\n- * Evaluates if a type definition contains the given \"final\".\n- * This does take \"finalDefault\" into account as well.\n- *\n- * Returns 1 if the type does contain the given \"final\",\n- * 0 otherwise.\n- *\/\n-static int\n-xmlSchemaTypeFinalContains(xmlSchemaTypePtr type, int final)\n-{\n-    if (type == NULL)\n-    return (0);\n-    if (type->flags & final)\n-    return (1);\n-    else\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaGetUnionSimpleTypeMemberTypes:\n- * @type:  the Union Simple Type\n- *\n- * Returns a list of member types of @type if existing,\n- * returns NULL otherwise.\n- *\/\n-static xmlSchemaTypeLinkPtr\n-xmlSchemaGetUnionSimpleTypeMemberTypes(xmlSchemaTypePtr type)\n-{\n-    while ((type != NULL) && (type->type == XML_SCHEMA_TYPE_SIMPLE)) {\n-    if (type->memberTypes != NULL)\n-        return (type->memberTypes);\n-    else\n-        type = type->baseType;\n-    }\n-    return (NULL);\n-}\n-\n-#if 0\n-\/**\n- * xmlSchemaGetParticleTotalRangeMin:\n- * @particle: the particle\n- *\n- * Schema Component Constraint: Effective Total Range\n- * (all and sequence) + (choice)\n- *\n- * Returns the minimum Effective Total Range.\n- *\/\n-static int\n-xmlSchemaGetParticleTotalRangeMin(xmlSchemaParticlePtr particle)\n-{\n-    if ((particle->children == NULL) ||\n-    (particle->minOccurs == 0))\n-    return (0);\n-    if (particle->children->type == XML_SCHEMA_TYPE_CHOICE) {\n-    int min = -1, cur;\n-    xmlSchemaParticlePtr part =\n-        (xmlSchemaParticlePtr) particle->children->children;\n-\n-    if (part == NULL)\n-        return (0);\n-    while (part != NULL) {\n-        if ((part->children->type == XML_SCHEMA_TYPE_ELEMENT) ||\n-        (part->children->type == XML_SCHEMA_TYPE_ANY))\n-        cur = part->minOccurs;\n-        else\n-        cur = xmlSchemaGetParticleTotalRangeMin(part);\n-        if (cur == 0)\n-        return (0);\n-        if ((min > cur) || (min == -1))\n-        min = cur;\n-        part = (xmlSchemaParticlePtr) part->next;\n-    }\n-    return (particle->minOccurs * min);\n-    } else {\n-    \/* <all> and <sequence> *\/\n-    int sum = 0;\n-    xmlSchemaParticlePtr part =\n-        (xmlSchemaParticlePtr) particle->children->children;\n-\n-    if (part == NULL)\n-        return (0);\n-    do {\n-        if ((part->children->type == XML_SCHEMA_TYPE_ELEMENT) ||\n-        (part->children->type == XML_SCHEMA_TYPE_ANY))\n-        sum += part->minOccurs;\n-        else\n-        sum += xmlSchemaGetParticleTotalRangeMin(part);\n-        part = (xmlSchemaParticlePtr) part->next;\n-    } while (part != NULL);\n-    return (particle->minOccurs * sum);\n-    }\n-}\n-\n-\/**\n- * xmlSchemaGetParticleTotalRangeMax:\n- * @particle: the particle\n- *\n- * Schema Component Constraint: Effective Total Range\n- * (all and sequence) + (choice)\n- *\n- * Returns the maximum Effective Total Range.\n- *\/\n-static int\n-xmlSchemaGetParticleTotalRangeMax(xmlSchemaParticlePtr particle)\n-{\n-    if ((particle->children == NULL) ||\n-    (particle->children->children == NULL))\n-    return (0);\n-    if (particle->children->type == XML_SCHEMA_TYPE_CHOICE) {\n-    int max = -1, cur;\n-    xmlSchemaParticlePtr part =\n-        (xmlSchemaParticlePtr) particle->children->children;\n-\n-    for (; part != NULL; part = (xmlSchemaParticlePtr) part->next) {\n-        if (part->children == NULL)\n-        continue;\n-        if ((part->children->type == XML_SCHEMA_TYPE_ELEMENT) ||\n-        (part->children->type == XML_SCHEMA_TYPE_ANY))\n-        cur = part->maxOccurs;\n-        else\n-        cur = xmlSchemaGetParticleTotalRangeMax(part);\n-        if (cur == UNBOUNDED)\n-        return (UNBOUNDED);\n-        if ((max < cur) || (max == -1))\n-        max = cur;\n-    }\n-    \/* TODO: Handle overflows? *\/\n-    return (particle->maxOccurs * max);\n-    } else {\n-    \/* <all> and <sequence> *\/\n-    int sum = 0, cur;\n-    xmlSchemaParticlePtr part =\n-        (xmlSchemaParticlePtr) particle->children->children;\n-\n-    for (; part != NULL; part = (xmlSchemaParticlePtr) part->next) {\n-        if (part->children == NULL)\n-        continue;\n-        if ((part->children->type == XML_SCHEMA_TYPE_ELEMENT) ||\n-        (part->children->type == XML_SCHEMA_TYPE_ANY))\n-        cur = part->maxOccurs;\n-        else\n-        cur = xmlSchemaGetParticleTotalRangeMax(part);\n-        if (cur == UNBOUNDED)\n-        return (UNBOUNDED);\n-        if ((cur > 0) && (particle->maxOccurs == UNBOUNDED))\n-        return (UNBOUNDED);\n-        sum += cur;\n-    }\n-    \/* TODO: Handle overflows? *\/\n-    return (particle->maxOccurs * sum);\n-    }\n-}\n-#endif\n-\n-\/**\n- * xmlSchemaGetParticleEmptiable:\n- * @particle: the particle\n- *\n- * Returns 1 if emptiable, 0 otherwise.\n- *\/\n-static int\n-xmlSchemaGetParticleEmptiable(xmlSchemaParticlePtr particle)\n-{\n-    xmlSchemaParticlePtr part;\n-    int emptiable;\n-\n-    if ((particle->children == NULL) || (particle->minOccurs == 0))\n-    return (1);\n-\n-    part = (xmlSchemaParticlePtr) particle->children->children;\n-    if (part == NULL)\n-        return (1);\n-\n-    while (part != NULL) {\n-        if ((part->children->type == XML_SCHEMA_TYPE_ELEMENT) ||\n-            (part->children->type == XML_SCHEMA_TYPE_ANY))\n-            emptiable = (part->minOccurs == 0);\n-        else\n-            emptiable = xmlSchemaGetParticleEmptiable(part);\n-        if (particle->children->type == XML_SCHEMA_TYPE_CHOICE) {\n-            if (emptiable)\n-                return (1);\n-        } else {\n-        \/* <all> and <sequence> *\/\n-            if (!emptiable)\n-                return (0);\n-        }\n-        part = (xmlSchemaParticlePtr) part->next;\n-    }\n-\n-    if (particle->children->type == XML_SCHEMA_TYPE_CHOICE)\n-        return (0);\n-    else\n-        return (1);\n-}\n-\n-\/**\n- * xmlSchemaIsParticleEmptiable:\n- * @particle: the particle\n- *\n- * Schema Component Constraint: Particle Emptiable\n- * Checks whether the given particle is emptiable.\n- *\n- * Returns 1 if emptiable, 0 otherwise.\n- *\/\n-static int\n-xmlSchemaIsParticleEmptiable(xmlSchemaParticlePtr particle)\n-{\n-    \/*\n-    * SPEC (1) \"Its {min occurs} is 0.\"\n-    *\/\n-    if ((particle == NULL) || (particle->minOccurs == 0) ||\n-    (particle->children == NULL))\n-    return (1);\n-    \/*\n-    * SPEC (2) \"Its {term} is a group and the minimum part of the\n-    * effective total range of that group, [...] is 0.\"\n-    *\/\n-    if (WXS_IS_MODEL_GROUP(particle->children))\n-    return (xmlSchemaGetParticleEmptiable(particle));\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaCheckCOSSTDerivedOK:\n- * @actxt: a context\n- * @type:  the derived simple type definition\n- * @baseType:  the base type definition\n- * @subset: the subset of ('restriction', etc.)\n- *\n- * Schema Component Constraint:\n- * Type Derivation OK (Simple) (cos-st-derived-OK)\n- *\n- * Checks whether @type can be validly\n- * derived from @baseType.\n- *\n- * Returns 0 on success, an positive error code otherwise.\n- *\/\n-static int\n-xmlSchemaCheckCOSSTDerivedOK(xmlSchemaAbstractCtxtPtr actxt,\n-                 xmlSchemaTypePtr type,\n-                 xmlSchemaTypePtr baseType,\n-                 int subset)\n-{\n-    \/*\n-    * 1 They are the same type definition.\n-    * TODO: The identity check might have to be more complex than this.\n-    *\/\n-    if (type == baseType)\n-    return (0);\n-    \/*\n-    * 2.1 restriction is not in the subset, or in the {final}\n-    * of its own {base type definition};\n-    *\n-    * NOTE that this will be used also via \"xsi:type\".\n-    *\n-    * TODO: Revise this, it looks strange. How can the \"type\"\n-    * not be fixed or *in* fixing?\n-    *\/\n-    if (WXS_IS_TYPE_NOT_FIXED(type))\n-    if (xmlSchemaTypeFixup(type, actxt) == -1)\n-        return(-1);\n-    if (WXS_IS_TYPE_NOT_FIXED(baseType))\n-    if (xmlSchemaTypeFixup(baseType, actxt) == -1)\n-        return(-1);\n-    if ((subset & SUBSET_RESTRICTION) ||\n-    (xmlSchemaTypeFinalContains(type->baseType,\n-        XML_SCHEMAS_TYPE_FINAL_RESTRICTION))) {\n-    return (XML_SCHEMAP_COS_ST_DERIVED_OK_2_1);\n-    }\n-    \/* 2.2 *\/\n-    if (type->baseType == baseType) {\n-    \/*\n-    * 2.2.1 D's `base type definition` is B.\n-    *\/\n-    return (0);\n-    }\n-    \/*\n-    * 2.2.2 D's `base type definition` is not the `ur-type definition`\n-    * and is validly derived from B given the subset, as defined by this\n-    * constraint.\n-    *\/\n-    if ((! WXS_IS_ANYTYPE(type->baseType)) &&\n-    (xmlSchemaCheckCOSSTDerivedOK(actxt, type->baseType,\n-        baseType, subset) == 0)) {\n-    return (0);\n-    }\n-    \/*\n-    * 2.2.3 D's {variety} is list or union and B is the `simple ur-type\n-    * definition`.\n-    *\/\n-    if (WXS_IS_ANY_SIMPLE_TYPE(baseType) &&\n-    (WXS_IS_LIST(type) || WXS_IS_UNION(type))) {\n-    return (0);\n-    }\n-    \/*\n-    * 2.2.4 B's {variety} is union and D is validly derived from a type\n-    * definition in B's {member type definitions} given the subset, as\n-    * defined by this constraint.\n-    *\n-    * NOTE: This seems not to involve built-in types, since there is no\n-    * built-in Union Simple Type.\n-    *\/\n-    if (WXS_IS_UNION(baseType)) {\n-    xmlSchemaTypeLinkPtr cur;\n-\n-    cur = baseType->memberTypes;\n-    while (cur != NULL) {\n-        if (WXS_IS_TYPE_NOT_FIXED(cur->type))\n-        if (xmlSchemaTypeFixup(cur->type, actxt) == -1)\n-            return(-1);\n-        if (xmlSchemaCheckCOSSTDerivedOK(actxt,\n-            type, cur->type, subset) == 0)\n-        {\n-        \/*\n-        * It just has to be validly derived from at least one\n-        * member-type.\n-        *\/\n-        return (0);\n-        }\n-        cur = cur->next;\n-    }\n-    }\n-    return (XML_SCHEMAP_COS_ST_DERIVED_OK_2_2);\n-}\n-\n-\/**\n- * xmlSchemaCheckTypeDefCircularInternal:\n- * @pctxt:  the schema parser context\n- * @ctxtType:  the type definition\n- * @ancestor: an ancestor of @ctxtType\n- *\n- * Checks st-props-correct (2) + ct-props-correct (3).\n- * Circular type definitions are not allowed.\n- *\n- * Returns XML_SCHEMAP_ST_PROPS_CORRECT_2 if the given type is\n- * circular, 0 otherwise.\n- *\/\n-static int\n-xmlSchemaCheckTypeDefCircularInternal(xmlSchemaParserCtxtPtr pctxt,\n-               xmlSchemaTypePtr ctxtType,\n-               xmlSchemaTypePtr ancestor)\n-{\n-    int ret;\n-\n-    if ((ancestor == NULL) || (ancestor->type == XML_SCHEMA_TYPE_BASIC))\n-    return (0);\n-\n-    if (ctxtType == ancestor) {\n-    xmlSchemaPCustomErr(pctxt,\n-        XML_SCHEMAP_ST_PROPS_CORRECT_2,\n-        WXS_BASIC_CAST ctxtType, WXS_ITEM_NODE(ctxtType),\n-        \"The definition is circular\", NULL);\n-    return (XML_SCHEMAP_ST_PROPS_CORRECT_2);\n-    }\n-    if (ancestor->flags & XML_SCHEMAS_TYPE_MARKED) {\n-    \/*\n-    * Avoid infinite recursion on circular types not yet checked.\n-    *\/\n-    return (0);\n-    }\n-    ancestor->flags |= XML_SCHEMAS_TYPE_MARKED;\n-    ret = xmlSchemaCheckTypeDefCircularInternal(pctxt, ctxtType,\n-    ancestor->baseType);\n-    ancestor->flags ^= XML_SCHEMAS_TYPE_MARKED;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaCheckTypeDefCircular:\n- * @item:  the complex\/simple type definition\n- * @ctxt:  the parser context\n- * @name:  the name\n- *\n- * Checks for circular type definitions.\n- *\/\n-static void\n-xmlSchemaCheckTypeDefCircular(xmlSchemaTypePtr item,\n-                  xmlSchemaParserCtxtPtr ctxt)\n-{\n-    if ((item == NULL) ||\n-    (item->type == XML_SCHEMA_TYPE_BASIC) ||\n-    (item->baseType == NULL))\n-    return;\n-    xmlSchemaCheckTypeDefCircularInternal(ctxt, item,\n-    item->baseType);\n-}\n-\n-\/*\n-* Simple Type Definition Representation OK (src-simple-type) 4\n-*\n-* \"4 Circular union type definition is disallowed. That is, if the\n-* <union> alternative is chosen, there must not be any entries in the\n-* memberTypes [attribute] at any depth which resolve to the component\n-* corresponding to the <simpleType>.\"\n-*\n-* Note that this should work on the *representation* of a component,\n-* thus assumes any union types in the member types not being yet\n-* substituted. At this stage we need the variety of the types\n-* to be already computed.\n-*\/\n-static int\n-xmlSchemaCheckUnionTypeDefCircularRecur(xmlSchemaParserCtxtPtr pctxt,\n-                    xmlSchemaTypePtr ctxType,\n-                    xmlSchemaTypeLinkPtr members)\n-{\n-    xmlSchemaTypeLinkPtr member;\n-    xmlSchemaTypePtr memberType;\n-\n-    member = members;\n-    while (member != NULL) {\n-    memberType = member->type;\n-    while ((memberType != NULL) &&\n-        (memberType->type != XML_SCHEMA_TYPE_BASIC)) {\n-        if (memberType == ctxType) {\n-        xmlSchemaPCustomErr(pctxt,\n-            XML_SCHEMAP_SRC_SIMPLE_TYPE_4,\n-            WXS_BASIC_CAST ctxType, NULL,\n-            \"The union type definition is circular\", NULL);\n-        return (XML_SCHEMAP_SRC_SIMPLE_TYPE_4);\n-        }\n-        if ((WXS_IS_UNION(memberType)) &&\n-        ((memberType->flags & XML_SCHEMAS_TYPE_MARKED) == 0))\n-        {\n-        int res;\n-        memberType->flags |= XML_SCHEMAS_TYPE_MARKED;\n-        res = xmlSchemaCheckUnionTypeDefCircularRecur(pctxt,\n-            ctxType,\n-            xmlSchemaGetUnionSimpleTypeMemberTypes(memberType));\n-        memberType->flags ^= XML_SCHEMAS_TYPE_MARKED;\n-        if (res != 0)\n-            return(res);\n-        }\n-        memberType = memberType->baseType;\n-    }\n-    member = member->next;\n-    }\n-    return(0);\n-}\n-\n-static int\n-xmlSchemaCheckUnionTypeDefCircular(xmlSchemaParserCtxtPtr pctxt,\n-                   xmlSchemaTypePtr type)\n-{\n-    if (! WXS_IS_UNION(type))\n-    return(0);\n-    return(xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type,\n-    type->memberTypes));\n-}\n-\n-\/**\n- * xmlSchemaResolveTypeReferences:\n- * @item:  the complex\/simple type definition\n- * @ctxt:  the parser context\n- * @name:  the name\n- *\n- * Resolves type definition references\n- *\/\n-static void\n-xmlSchemaResolveTypeReferences(xmlSchemaTypePtr typeDef,\n-             xmlSchemaParserCtxtPtr ctxt)\n-{\n-    if (typeDef == NULL)\n-    return;\n-\n-    \/*\n-    * Resolve the base type.\n-    *\/\n-    if (typeDef->baseType == NULL) {\n-    typeDef->baseType = xmlSchemaGetType(ctxt->schema,\n-        typeDef->base, typeDef->baseNs);\n-    if (typeDef->baseType == NULL) {\n-        xmlSchemaPResCompAttrErr(ctxt,\n-        XML_SCHEMAP_SRC_RESOLVE,\n-        WXS_BASIC_CAST typeDef, typeDef->node,\n-        \"base\", typeDef->base, typeDef->baseNs,\n-        XML_SCHEMA_TYPE_SIMPLE, NULL);\n-        return;\n-    }\n-    }\n-    if (WXS_IS_SIMPLE(typeDef)) {\n-    if (WXS_IS_UNION(typeDef)) {\n-        \/*\n-        * Resolve the memberTypes.\n-        *\/\n-        xmlSchemaResolveUnionMemberTypes(ctxt, typeDef);\n-        return;\n-    } else if (WXS_IS_LIST(typeDef)) {\n-        \/*\n-        * Resolve the itemType.\n-        *\/\n-        if ((typeDef->subtypes == NULL) && (typeDef->base != NULL)) {\n-\n-        typeDef->subtypes = xmlSchemaGetType(ctxt->schema,\n-            typeDef->base, typeDef->baseNs);\n-\n-        if ((typeDef->subtypes == NULL) ||\n-            (! WXS_IS_SIMPLE(typeDef->subtypes)))\n-        {\n-            typeDef->subtypes = NULL;\n-            xmlSchemaPResCompAttrErr(ctxt,\n-            XML_SCHEMAP_SRC_RESOLVE,\n-            WXS_BASIC_CAST typeDef, typeDef->node,\n-            \"itemType\", typeDef->base, typeDef->baseNs,\n-            XML_SCHEMA_TYPE_SIMPLE, NULL);\n-        }\n-        }\n-        return;\n-    }\n-    }\n-    \/*\n-    * The ball of letters below means, that if we have a particle\n-    * which has a QName-helper component as its {term}, we want\n-    * to resolve it...\n-    *\/\n-    else if ((WXS_TYPE_CONTENTTYPE(typeDef) != NULL) &&\n-    ((WXS_TYPE_CONTENTTYPE(typeDef))->type ==\n-        XML_SCHEMA_TYPE_PARTICLE) &&\n-    (WXS_TYPE_PARTICLE_TERM(typeDef) != NULL) &&\n-    ((WXS_TYPE_PARTICLE_TERM(typeDef))->type ==\n-        XML_SCHEMA_EXTRA_QNAMEREF))\n-    {\n-    xmlSchemaQNameRefPtr ref =\n-        WXS_QNAME_CAST WXS_TYPE_PARTICLE_TERM(typeDef);\n-    xmlSchemaModelGroupDefPtr groupDef;\n-\n-    \/*\n-    * URGENT TODO: Test this.\n-    *\/\n-    WXS_TYPE_PARTICLE_TERM(typeDef) = NULL;\n-    \/*\n-    * Resolve the MG definition reference.\n-    *\/\n-    groupDef =\n-        WXS_MODEL_GROUPDEF_CAST xmlSchemaGetNamedComponent(ctxt->schema,\n-        ref->itemType, ref->name, ref->targetNamespace);\n-    if (groupDef == NULL) {\n-        xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,\n-        NULL, WXS_ITEM_NODE(WXS_TYPE_PARTICLE(typeDef)),\n-        \"ref\", ref->name, ref->targetNamespace, ref->itemType,\n-        NULL);\n-        \/* Remove the particle. *\/\n-        WXS_TYPE_CONTENTTYPE(typeDef) = NULL;\n-    } else if (WXS_MODELGROUPDEF_MODEL(groupDef) == NULL)\n-        \/* Remove the particle. *\/\n-        WXS_TYPE_CONTENTTYPE(typeDef) = NULL;\n-    else {\n-        \/*\n-        * Assign the MG definition's {model group} to the\n-        * particle's {term}.\n-        *\/\n-        WXS_TYPE_PARTICLE_TERM(typeDef) = WXS_MODELGROUPDEF_MODEL(groupDef);\n-\n-        if (WXS_MODELGROUPDEF_MODEL(groupDef)->type == XML_SCHEMA_TYPE_ALL) {\n-        \/*\n-        * SPEC cos-all-limited (1.2)\n-        * \"1.2 the {term} property of a particle with\n-        * {max occurs}=1 which is part of a pair which constitutes\n-        * the {content type} of a complex type definition.\"\n-        *\/\n-        if ((WXS_TYPE_PARTICLE(typeDef))->maxOccurs != 1) {\n-            xmlSchemaCustomErr(ACTXT_CAST ctxt,\n-            \/* TODO: error code *\/\n-            XML_SCHEMAP_COS_ALL_LIMITED,\n-            WXS_ITEM_NODE(WXS_TYPE_PARTICLE(typeDef)), NULL,\n-            \"The particle's {max occurs} must be 1, since the \"\n-            \"reference resolves to an 'all' model group\",\n-            NULL, NULL);\n-        }\n-        }\n-    }\n-    }\n-}\n-\n-\n-\n-\/**\n- * xmlSchemaCheckSTPropsCorrect:\n- * @ctxt:  the schema parser context\n- * @type:  the simple type definition\n- *\n- * Checks st-props-correct.\n- *\n- * Returns 0 if the properties are correct,\n- * if not, a positive error code and -1 on internal\n- * errors.\n- *\/\n-static int\n-xmlSchemaCheckSTPropsCorrect(xmlSchemaParserCtxtPtr ctxt,\n-                 xmlSchemaTypePtr type)\n-{\n-    xmlSchemaTypePtr baseType = type->baseType;\n-    xmlChar *str = NULL;\n-\n-    \/* STATE: error funcs converted. *\/\n-    \/*\n-    * Schema Component Constraint: Simple Type Definition Properties Correct\n-    *\n-    * NOTE: This is somehow redundant, since we actually built a simple type\n-    * to have all the needed information; this acts as an self test.\n-    *\/\n-    \/* Base type: If the datatype has been `derived` by `restriction`\n-    * then the Simple Type Definition component from which it is `derived`,\n-    * otherwise the Simple Type Definition for anySimpleType ($4.1.6).\n-    *\/\n-    if (baseType == NULL) {\n-    \/*\n-    * TODO: Think about: \"modulo the impact of Missing\n-    * Sub-components ($5.3).\"\n-    *\/\n-    xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_ST_PROPS_CORRECT_1,\n-        WXS_BASIC_CAST type, NULL,\n-        \"No base type existent\", NULL);\n-    return (XML_SCHEMAP_ST_PROPS_CORRECT_1);\n-\n-    }\n-    if (! WXS_IS_SIMPLE(baseType)) {\n-    xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_ST_PROPS_CORRECT_1,\n-        WXS_BASIC_CAST type, NULL,\n-        \"The base type '%s' is not a simple type\",\n-        xmlSchemaGetComponentQName(&str, baseType));\n-    FREE_AND_NULL(str)\n-    return (XML_SCHEMAP_ST_PROPS_CORRECT_1);\n-    }\n-    if ((WXS_IS_LIST(type) || WXS_IS_UNION(type)) &&\n-    (WXS_IS_RESTRICTION(type) == 0) &&\n-    ((! WXS_IS_ANY_SIMPLE_TYPE(baseType)) &&\n-         (baseType->type != XML_SCHEMA_TYPE_SIMPLE))) {\n-    xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_ST_PROPS_CORRECT_1,\n-        WXS_BASIC_CAST type, NULL,\n-        \"A type, derived by list or union, must have \"\n-        \"the simple ur-type definition as base type, not '%s'\",\n-        xmlSchemaGetComponentQName(&str, baseType));\n-    FREE_AND_NULL(str)\n-    return (XML_SCHEMAP_ST_PROPS_CORRECT_1);\n-    }\n-    \/*\n-    * Variety: One of {atomic, list, union}.\n-    *\/\n-    if ((! WXS_IS_ATOMIC(type)) && (! WXS_IS_UNION(type)) &&\n-    (! WXS_IS_LIST(type))) {\n-    xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_ST_PROPS_CORRECT_1,\n-        WXS_BASIC_CAST type, NULL,\n-        \"The variety is absent\", NULL);\n-    return (XML_SCHEMAP_ST_PROPS_CORRECT_1);\n-    }\n-    \/* TODO: Finish this. Hmm, is this finished? *\/\n-\n-    \/*\n-    * 3 The {final} of the {base type definition} must not contain restriction.\n-    *\/\n-    if (xmlSchemaTypeFinalContains(baseType,\n-    XML_SCHEMAS_TYPE_FINAL_RESTRICTION)) {\n-    xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_ST_PROPS_CORRECT_3,\n-        WXS_BASIC_CAST type, NULL,\n-        \"The 'final' of its base type '%s' must not contain \"\n-        \"'restriction'\",\n-        xmlSchemaGetComponentQName(&str, baseType));\n-    FREE_AND_NULL(str)\n-    return (XML_SCHEMAP_ST_PROPS_CORRECT_3);\n-    }\n-\n-    \/*\n-    * 2 All simple type definitions must be derived ultimately from the `simple\n-    * ur-type definition` (so circular definitions are disallowed). That is, it\n-    * must be possible to reach a built-in primitive datatype or the `simple\n-    * ur-type definition` by repeatedly following the {base type definition}.\n-    *\n-    * NOTE: this is done in xmlSchemaCheckTypeDefCircular().\n-    *\/\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaCheckCOSSTRestricts:\n- * @ctxt:  the schema parser context\n- * @type:  the simple type definition\n- *\n- * Schema Component Constraint:\n- * Derivation Valid (Restriction, Simple) (cos-st-restricts)\n-\n- * Checks if the given @type (simpleType) is derived validly by restriction.\n- * STATUS:\n- *\n- * Returns -1 on internal errors, 0 if the type is validly derived,\n- * a positive error code otherwise.\n- *\/\n-static int\n-xmlSchemaCheckCOSSTRestricts(xmlSchemaParserCtxtPtr pctxt,\n-                 xmlSchemaTypePtr type)\n-{\n-    xmlChar *str = NULL;\n-\n-    if (type->type != XML_SCHEMA_TYPE_SIMPLE) {\n-    PERROR_INT(\"xmlSchemaCheckCOSSTRestricts\",\n-        \"given type is not a user-derived simpleType\");\n-    return (-1);\n-    }\n-\n-    if (WXS_IS_ATOMIC(type)) {\n-    xmlSchemaTypePtr primitive;\n-    \/*\n-    * 1.1 The {base type definition} must be an atomic simple\n-    * type definition or a built-in primitive datatype.\n-    *\/\n-    if (! WXS_IS_ATOMIC(type->baseType)) {\n-        xmlSchemaPCustomErr(pctxt,\n-        XML_SCHEMAP_COS_ST_RESTRICTS_1_1,\n-        WXS_BASIC_CAST type, NULL,\n-        \"The base type '%s' is not an atomic simple type\",\n-        xmlSchemaGetComponentQName(&str, type->baseType));\n-        FREE_AND_NULL(str)\n-        return (XML_SCHEMAP_COS_ST_RESTRICTS_1_1);\n-    }\n-    \/* 1.2 The {final} of the {base type definition} must not contain\n-    * restriction.\n-    *\/\n-    \/* OPTIMIZE TODO : This is already done in xmlSchemaCheckStPropsCorrect *\/\n-    if (xmlSchemaTypeFinalContains(type->baseType,\n-        XML_SCHEMAS_TYPE_FINAL_RESTRICTION)) {\n-        xmlSchemaPCustomErr(pctxt,\n-        XML_SCHEMAP_COS_ST_RESTRICTS_1_2,\n-        WXS_BASIC_CAST type, NULL,\n-        \"The final of its base type '%s' must not contain 'restriction'\",\n-        xmlSchemaGetComponentQName(&str, type->baseType));\n-        FREE_AND_NULL(str)\n-        return (XML_SCHEMAP_COS_ST_RESTRICTS_1_2);\n-    }\n-\n-    \/*\n-    * 1.3.1 DF must be an allowed constraining facet for the {primitive\n-    * type definition}, as specified in the appropriate subsection of 3.2\n-    * Primitive datatypes.\n-    *\/\n-    if (type->facets != NULL) {\n-        xmlSchemaFacetPtr facet;\n-        int ok = 1;\n-\n-        primitive = xmlSchemaGetPrimitiveType(type);\n-        if (primitive == NULL) {\n-        PERROR_INT(\"xmlSchemaCheckCOSSTRestricts\",\n-            \"failed to get primitive type\");\n-        return (-1);\n-        }\n-        facet = type->facets;\n-        do {\n-        if (xmlSchemaIsBuiltInTypeFacet(primitive, facet->type) == 0) {\n-            ok = 0;\n-            xmlSchemaPIllegalFacetAtomicErr(pctxt,\n-            XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1,\n-            type, primitive, facet);\n-        }\n-        facet = facet->next;\n-        } while (facet != NULL);\n-        if (ok == 0)\n-        return (XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1);\n-    }\n-    \/*\n-    * SPEC (1.3.2) \"If there is a facet of the same kind in the {facets}\n-    * of the {base type definition} (call this BF),then the DF's {value}\n-    * must be a valid restriction of BF's {value} as defined in\n-    * [XML Schemas: Datatypes].\"\n-    *\n-    * NOTE (1.3.2) Facet derivation constraints are currently handled in\n-    * xmlSchemaDeriveAndValidateFacets()\n-    *\/\n-    } else if (WXS_IS_LIST(type)) {\n-    xmlSchemaTypePtr itemType = NULL;\n-\n-    itemType = type->subtypes;\n-    if ((itemType == NULL) || (! WXS_IS_SIMPLE(itemType))) {\n-        PERROR_INT(\"xmlSchemaCheckCOSSTRestricts\",\n-        \"failed to evaluate the item type\");\n-        return (-1);\n-    }\n-    if (WXS_IS_TYPE_NOT_FIXED(itemType))\n-        xmlSchemaTypeFixup(itemType, ACTXT_CAST pctxt);\n-    \/*\n-    * 2.1 The {item type definition} must have a {variety} of atomic or\n-    * union (in which case all the {member type definitions}\n-    * must be atomic).\n-    *\/\n-    if ((! WXS_IS_ATOMIC(itemType)) &&\n-        (! WXS_IS_UNION(itemType))) {\n-        xmlSchemaPCustomErr(pctxt,\n-        XML_SCHEMAP_COS_ST_RESTRICTS_2_1,\n-        WXS_BASIC_CAST type, NULL,\n-        \"The item type '%s' does not have a variety of atomic or union\",\n-        xmlSchemaGetComponentQName(&str, itemType));\n-        FREE_AND_NULL(str)\n-        return (XML_SCHEMAP_COS_ST_RESTRICTS_2_1);\n-    } else if (WXS_IS_UNION(itemType)) {\n-        xmlSchemaTypeLinkPtr member;\n-\n-        member = itemType->memberTypes;\n-        while (member != NULL) {\n-        if (! WXS_IS_ATOMIC(member->type)) {\n-            xmlSchemaPCustomErr(pctxt,\n-            XML_SCHEMAP_COS_ST_RESTRICTS_2_1,\n-            WXS_BASIC_CAST type, NULL,\n-            \"The item type is a union type, but the \"\n-            \"member type '%s' of this item type is not atomic\",\n-            xmlSchemaGetComponentQName(&str, member->type));\n-            FREE_AND_NULL(str)\n-            return (XML_SCHEMAP_COS_ST_RESTRICTS_2_1);\n-        }\n-        member = member->next;\n-        }\n-    }\n-\n-    if (WXS_IS_ANY_SIMPLE_TYPE(type->baseType)) {\n-        xmlSchemaFacetPtr facet;\n-        \/*\n-        * This is the case if we have: <simpleType><list ..\n-        *\/\n-        \/*\n-        * 2.3.1\n-        * 2.3.1.1 The {final} of the {item type definition} must not\n-        * contain list.\n-        *\/\n-        if (xmlSchemaTypeFinalContains(itemType,\n-        XML_SCHEMAS_TYPE_FINAL_LIST)) {\n-        xmlSchemaPCustomErr(pctxt,\n-            XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1,\n-            WXS_BASIC_CAST type, NULL,\n-            \"The final of its item type '%s' must not contain 'list'\",\n-            xmlSchemaGetComponentQName(&str, itemType));\n-        FREE_AND_NULL(str)\n-        return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1);\n-        }\n-        \/*\n-        * 2.3.1.2 The {facets} must only contain the whiteSpace\n-        * facet component.\n-        * OPTIMIZE TODO: the S4S already disallows any facet\n-        * to be specified.\n-        *\/\n-        if (type->facets != NULL) {\n-        facet = type->facets;\n-        do {\n-            if (facet->type != XML_SCHEMA_FACET_WHITESPACE) {\n-            xmlSchemaPIllegalFacetListUnionErr(pctxt,\n-                XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2,\n-                type, facet);\n-            return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2);\n-            }\n-            facet = facet->next;\n-        } while (facet != NULL);\n-        }\n-        \/*\n-        * MAYBE TODO: (Hmm, not really) Datatypes states:\n-        * A `list` datatype can be `derived` from an `atomic` datatype\n-        * whose `lexical space` allows space (such as string or anyURI)or\n-        * a `union` datatype any of whose {member type definitions}'s\n-        * `lexical space` allows space.\n-        *\/\n-    } else {\n-        \/*\n-        * This is the case if we have: <simpleType><restriction ...\n-        * I.e. the variety of \"list\" is inherited.\n-        *\/\n-        \/*\n-        * 2.3.2\n-        * 2.3.2.1 The {base type definition} must have a {variety} of list.\n-        *\/\n-        if (! WXS_IS_LIST(type->baseType)) {\n-        xmlSchemaPCustomErr(pctxt,\n-            XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1,\n-            WXS_BASIC_CAST type, NULL,\n-            \"The base type '%s' must be a list type\",\n-            xmlSchemaGetComponentQName(&str, type->baseType));\n-        FREE_AND_NULL(str)\n-        return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1);\n-        }\n-        \/*\n-        * 2.3.2.2 The {final} of the {base type definition} must not\n-        * contain restriction.\n-        *\/\n-        if (xmlSchemaTypeFinalContains(type->baseType,\n-        XML_SCHEMAS_TYPE_FINAL_RESTRICTION)) {\n-        xmlSchemaPCustomErr(pctxt,\n-            XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2,\n-            WXS_BASIC_CAST type, NULL,\n-            \"The 'final' of the base type '%s' must not contain 'restriction'\",\n-            xmlSchemaGetComponentQName(&str, type->baseType));\n-        FREE_AND_NULL(str)\n-        return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2);\n-        }\n-        \/*\n-        * 2.3.2.3 The {item type definition} must be validly derived\n-        * from the {base type definition}'s {item type definition} given\n-        * the empty set, as defined in Type Derivation OK (Simple) ($3.14.6).\n-        *\/\n-        {\n-        xmlSchemaTypePtr baseItemType;\n-\n-        baseItemType = type->baseType->subtypes;\n-        if ((baseItemType == NULL) || (! WXS_IS_SIMPLE(baseItemType))) {\n-            PERROR_INT(\"xmlSchemaCheckCOSSTRestricts\",\n-            \"failed to eval the item type of a base type\");\n-            return (-1);\n-        }\n-        if ((itemType != baseItemType) &&\n-            (xmlSchemaCheckCOSSTDerivedOK(ACTXT_CAST pctxt, itemType,\n-            baseItemType, 0) != 0)) {\n-            xmlChar *strBIT = NULL, *strBT = NULL;\n-            xmlSchemaPCustomErrExt(pctxt,\n-            XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3,\n-            WXS_BASIC_CAST type, NULL,\n-            \"The item type '%s' is not validly derived from \"\n-            \"the item type '%s' of the base type '%s'\",\n-            xmlSchemaGetComponentQName(&str, itemType),\n-            xmlSchemaGetComponentQName(&strBIT, baseItemType),\n-            xmlSchemaGetComponentQName(&strBT, type->baseType));\n-\n-            FREE_AND_NULL(str)\n-            FREE_AND_NULL(strBIT)\n-            FREE_AND_NULL(strBT)\n-            return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3);\n-        }\n-        }\n-\n-        if (type->facets != NULL) {\n-        xmlSchemaFacetPtr facet;\n-        int ok = 1;\n-        \/*\n-        * 2.3.2.4 Only length, minLength, maxLength, whiteSpace, pattern\n-        * and enumeration facet components are allowed among the {facets}.\n-        *\/\n-        facet = type->facets;\n-        do {\n-            switch (facet->type) {\n-            case XML_SCHEMA_FACET_LENGTH:\n-            case XML_SCHEMA_FACET_MINLENGTH:\n-            case XML_SCHEMA_FACET_MAXLENGTH:\n-            case XML_SCHEMA_FACET_WHITESPACE:\n-                \/*\n-                * TODO: 2.5.1.2 List datatypes\n-                * The value of `whiteSpace` is fixed to the value collapse.\n-                *\/\n-            case XML_SCHEMA_FACET_PATTERN:\n-            case XML_SCHEMA_FACET_ENUMERATION:\n-                break;\n-            default: {\n-                xmlSchemaPIllegalFacetListUnionErr(pctxt,\n-                XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4,\n-                type, facet);\n-                \/*\n-                * We could return, but it's nicer to report all\n-                * invalid facets.\n-                *\/\n-                ok = 0;\n-            }\n-            }\n-            facet = facet->next;\n-        } while (facet != NULL);\n-        if (ok == 0)\n-            return (XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4);\n-        \/*\n-        * SPEC (2.3.2.5) (same as 1.3.2)\n-        *\n-        * NOTE (2.3.2.5) This is currently done in\n-        * xmlSchemaDeriveAndValidateFacets()\n-        *\/\n-        }\n-    }\n-    } else if (WXS_IS_UNION(type)) {\n-    \/*\n-    * 3.1 The {member type definitions} must all have {variety} of\n-    * atomic or list.\n-    *\/\n-    xmlSchemaTypeLinkPtr member;\n-\n-    member = type->memberTypes;\n-    while (member != NULL) {\n-        if (WXS_IS_TYPE_NOT_FIXED(member->type))\n-        xmlSchemaTypeFixup(member->type, ACTXT_CAST pctxt);\n-\n-        if ((! WXS_IS_ATOMIC(member->type)) &&\n-        (! WXS_IS_LIST(member->type))) {\n-        xmlSchemaPCustomErr(pctxt,\n-            XML_SCHEMAP_COS_ST_RESTRICTS_3_1,\n-            WXS_BASIC_CAST type, NULL,\n-            \"The member type '%s' is neither an atomic, nor a list type\",\n-            xmlSchemaGetComponentQName(&str, member->type));\n-        FREE_AND_NULL(str)\n-        return (XML_SCHEMAP_COS_ST_RESTRICTS_3_1);\n-        }\n-        member = member->next;\n-    }\n-    \/*\n-    * 3.3.1 If the {base type definition} is the `simple ur-type\n-    * definition`\n-    *\/\n-    if (type->baseType->builtInType == XML_SCHEMAS_ANYSIMPLETYPE) {\n-        \/*\n-        * 3.3.1.1 All of the {member type definitions} must have a\n-        * {final} which does not contain union.\n-        *\/\n-        member = type->memberTypes;\n-        while (member != NULL) {\n-        if (xmlSchemaTypeFinalContains(member->type,\n-            XML_SCHEMAS_TYPE_FINAL_UNION)) {\n-            xmlSchemaPCustomErr(pctxt,\n-            XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1,\n-            WXS_BASIC_CAST type, NULL,\n-            \"The 'final' of member type '%s' contains 'union'\",\n-            xmlSchemaGetComponentQName(&str, member->type));\n-            FREE_AND_NULL(str)\n-            return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1);\n-        }\n-        member = member->next;\n-        }\n-        \/*\n-        * 3.3.1.2 The {facets} must be empty.\n-        *\/\n-        if (type->facetSet != NULL) {\n-        xmlSchemaPCustomErr(pctxt,\n-            XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2,\n-            WXS_BASIC_CAST type, NULL,\n-            \"No facets allowed\", NULL);\n-        return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2);\n-        }\n-    } else {\n-        \/*\n-        * 3.3.2.1 The {base type definition} must have a {variety} of union.\n-        * I.e. the variety of \"list\" is inherited.\n-        *\/\n-        if (! WXS_IS_UNION(type->baseType)) {\n-        xmlSchemaPCustomErr(pctxt,\n-            XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1,\n-            WXS_BASIC_CAST type, NULL,\n-            \"The base type '%s' is not a union type\",\n-            xmlSchemaGetComponentQName(&str, type->baseType));\n-        FREE_AND_NULL(str)\n-        return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1);\n-        }\n-        \/*\n-        * 3.3.2.2 The {final} of the {base type definition} must not contain restriction.\n-        *\/\n-        if (xmlSchemaTypeFinalContains(type->baseType,\n-        XML_SCHEMAS_TYPE_FINAL_RESTRICTION)) {\n-        xmlSchemaPCustomErr(pctxt,\n-            XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2,\n-            WXS_BASIC_CAST type, NULL,\n-            \"The 'final' of its base type '%s' must not contain 'restriction'\",\n-            xmlSchemaGetComponentQName(&str, type->baseType));\n-        FREE_AND_NULL(str)\n-        return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2);\n-        }\n-        \/*\n-        * 3.3.2.3 The {member type definitions}, in order, must be validly\n-        * derived from the corresponding type definitions in the {base\n-        * type definition}'s {member type definitions} given the empty set,\n-        * as defined in Type Derivation OK (Simple) ($3.14.6).\n-        *\/\n-        {\n-        xmlSchemaTypeLinkPtr baseMember;\n-\n-        \/*\n-        * OPTIMIZE: if the type is restricting, it has no local defined\n-        * member types and inherits the member types of the base type;\n-        * thus a check for equality can be skipped.\n-        *\/\n-        \/*\n-        * Even worse: I cannot see a scenario where a restricting\n-        * union simple type can have other member types as the member\n-        * types of it's base type. This check seems not necessary with\n-        * respect to the derivation process in libxml2.\n-        * But necessary if constructing types with an API.\n-        *\/\n-        if (type->memberTypes != NULL) {\n-            member = type->memberTypes;\n-            baseMember = xmlSchemaGetUnionSimpleTypeMemberTypes(type->baseType);\n-            if ((member == NULL) && (baseMember != NULL)) {\n-            PERROR_INT(\"xmlSchemaCheckCOSSTRestricts\",\n-                \"different number of member types in base\");\n-            }\n-            while (member != NULL) {\n-            if (baseMember == NULL) {\n-                PERROR_INT(\"xmlSchemaCheckCOSSTRestricts\",\n-                \"different number of member types in base\");\n-            } else if ((member->type != baseMember->type) &&\n-                (xmlSchemaCheckCOSSTDerivedOK(ACTXT_CAST pctxt,\n-                member->type, baseMember->type, 0) != 0)) {\n-                xmlChar *strBMT = NULL, *strBT = NULL;\n-\n-                xmlSchemaPCustomErrExt(pctxt,\n-                XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3,\n-                WXS_BASIC_CAST type, NULL,\n-                \"The member type %s is not validly \"\n-                \"derived from its corresponding member \"\n-                \"type %s of the base type %s\",\n-                xmlSchemaGetComponentQName(&str, member->type),\n-                xmlSchemaGetComponentQName(&strBMT, baseMember->type),\n-                xmlSchemaGetComponentQName(&strBT, type->baseType));\n-                FREE_AND_NULL(str)\n-                FREE_AND_NULL(strBMT)\n-                FREE_AND_NULL(strBT)\n-                return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3);\n-            }\n-            member = member->next;\n-                        if (baseMember != NULL)\n-                            baseMember = baseMember->next;\n-            }\n-        }\n-        }\n-        \/*\n-        * 3.3.2.4 Only pattern and enumeration facet components are\n-        * allowed among the {facets}.\n-        *\/\n-        if (type->facets != NULL) {\n-        xmlSchemaFacetPtr facet;\n-        int ok = 1;\n-\n-        facet = type->facets;\n-        do {\n-            if ((facet->type != XML_SCHEMA_FACET_PATTERN) &&\n-            (facet->type != XML_SCHEMA_FACET_ENUMERATION)) {\n-            xmlSchemaPIllegalFacetListUnionErr(pctxt,\n-                XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4,\n-                type, facet);\n-            ok = 0;\n-            }\n-            facet = facet->next;\n-        } while (facet != NULL);\n-        if (ok == 0)\n-            return (XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4);\n-\n-        }\n-        \/*\n-        * SPEC (3.3.2.5) (same as 1.3.2)\n-        *\n-        * NOTE (3.3.2.5) This is currently done in\n-        * xmlSchemaDeriveAndValidateFacets()\n-        *\/\n-    }\n-    }\n-\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaCheckSRCSimpleType:\n- * @ctxt:  the schema parser context\n- * @type:  the simple type definition\n- *\n- * Checks crc-simple-type constraints.\n- *\n- * Returns 0 if the constraints are satisfied,\n- * if not a positive error code and -1 on internal\n- * errors.\n- *\/\n-#if 0\n-static int\n-xmlSchemaCheckSRCSimpleType(xmlSchemaParserCtxtPtr ctxt,\n-                xmlSchemaTypePtr type)\n-{\n-    \/*\n-    * src-simple-type.1 The corresponding simple type definition, if any,\n-    * must satisfy the conditions set out in Constraints on Simple Type\n-    * Definition Schema Components ($3.14.6).\n-    *\/\n-    if (WXS_IS_RESTRICTION(type)) {\n-    \/*\n-    * src-simple-type.2 \"If the <restriction> alternative is chosen,\n-    * either it must have a base [attribute] or a <simpleType> among its\n-    * [children], but not both.\"\n-    * NOTE: This is checked in the parse function of <restriction>.\n-    *\/\n-    \/*\n-    *\n-    *\/\n-    } else if (WXS_IS_LIST(type)) {\n-    \/* src-simple-type.3 \"If the <list> alternative is chosen, either it must have\n-    * an itemType [attribute] or a <simpleType> among its [children],\n-    * but not both.\"\n-    *\n-    * NOTE: This is checked in the parse function of <list>.\n-    *\/\n-    } else if (WXS_IS_UNION(type)) {\n-    \/*\n-    * src-simple-type.4 is checked in xmlSchemaCheckUnionTypeDefCircular().\n-    *\/\n-    }\n-    return (0);\n-}\n-#endif\n-\n-static int\n-xmlSchemaCreateVCtxtOnPCtxt(xmlSchemaParserCtxtPtr ctxt)\n-{\n-   if (ctxt->vctxt == NULL) {\n-    ctxt->vctxt = xmlSchemaNewValidCtxt(NULL);\n-    if (ctxt->vctxt == NULL) {\n-        xmlSchemaPErr(ctxt, NULL,\n-        XML_SCHEMAP_INTERNAL,\n-        \"Internal error: xmlSchemaCreateVCtxtOnPCtxt, \"\n-        \"failed to create a temp. validation context.\\n\",\n-        NULL, NULL);\n-        return (-1);\n-    }\n-    \/* TODO: Pass user data. *\/\n-    xmlSchemaSetValidErrors(ctxt->vctxt,\n-        ctxt->error, ctxt->warning, ctxt->errCtxt);\n-    xmlSchemaSetValidStructuredErrors(ctxt->vctxt,\n-        ctxt->serror, ctxt->errCtxt);\n-    }\n-    return (0);\n-}\n-\n-static int\n-xmlSchemaVCheckCVCSimpleType(xmlSchemaAbstractCtxtPtr actxt,\n-                 xmlNodePtr node,\n-                 xmlSchemaTypePtr type,\n-                 const xmlChar *value,\n-                 xmlSchemaValPtr *retVal,\n-                 int fireErrors,\n-                 int normalize,\n-                 int isNormalized);\n-\n-\/**\n- * xmlSchemaParseCheckCOSValidDefault:\n- * @pctxt:  the schema parser context\n- * @type:  the simple type definition\n- * @value: the default value\n- * @node: an optional node (the holder of the value)\n- *\n- * Schema Component Constraint: Element Default Valid (Immediate)\n- * (cos-valid-default)\n- * This will be used by the parser only. For the validator there's\n- * an other version.\n- *\n- * Returns 0 if the constraints are satisfied,\n- * if not, a positive error code and -1 on internal\n- * errors.\n- *\/\n-static int\n-xmlSchemaParseCheckCOSValidDefault(xmlSchemaParserCtxtPtr pctxt,\n-                   xmlNodePtr node,\n-                   xmlSchemaTypePtr type,\n-                   const xmlChar *value,\n-                   xmlSchemaValPtr *val)\n-{\n-    int ret = 0;\n-\n-    \/*\n-    * cos-valid-default:\n-    * Schema Component Constraint: Element Default Valid (Immediate)\n-    * For a string to be a valid default with respect to a type\n-    * definition the appropriate case among the following must be true:\n-    *\/\n-    if WXS_IS_COMPLEX(type) {\n-    \/*\n-    * Complex type.\n-    *\n-    * SPEC (2.1) \"its {content type} must be a simple type definition\n-    * or mixed.\"\n-    * SPEC (2.2.2) \"If the {content type} is mixed, then the {content\n-    * type}'s particle must be `emptiable` as defined by\n-    * Particle Emptiable ($3.9.6).\"\n-    *\/\n-    if ((! WXS_HAS_SIMPLE_CONTENT(type)) &&\n-        ((! WXS_HAS_MIXED_CONTENT(type)) || (! WXS_EMPTIABLE(type)))) {\n-        \/* NOTE that this covers (2.2.2) as well. *\/\n-        xmlSchemaPCustomErr(pctxt,\n-        XML_SCHEMAP_COS_VALID_DEFAULT_2_1,\n-        WXS_BASIC_CAST type, type->node,\n-        \"For a string to be a valid default, the type definition \"\n-        \"must be a simple type or a complex type with mixed content \"\n-        \"and a particle emptiable\", NULL);\n-        return(XML_SCHEMAP_COS_VALID_DEFAULT_2_1);\n-    }\n-    }\n-    \/*\n-    * 1 If the type definition is a simple type definition, then the string\n-    * must be `valid` with respect to that definition as defined by String\n-    * Valid ($3.14.4).\n-    *\n-    * AND\n-    *\n-    * 2.2.1 If the {content type} is a simple type definition, then the\n-    * string must be `valid` with respect to that simple type definition\n-    * as defined by String Valid ($3.14.4).\n-    *\/\n-    if (WXS_IS_SIMPLE(type))\n-    ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST pctxt, node,\n-        type, value, val, 1, 1, 0);\n-    else if (WXS_HAS_SIMPLE_CONTENT(type))\n-    ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST pctxt, node,\n-        type->contentTypeDef, value, val, 1, 1, 0);\n-    else\n-    return (ret);\n-\n-    if (ret < 0) {\n-    PERROR_INT(\"xmlSchemaParseCheckCOSValidDefault\",\n-        \"calling xmlSchemaVCheckCVCSimpleType()\");\n-    }\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaCheckCTPropsCorrect:\n- * @ctxt:  the schema parser context\n- * @type:  the complex type definition\n- *\n- *.(4.6) Constraints on Complex Type Definition Schema Components\n- * Schema Component Constraint:\n- * Complex Type Definition Properties Correct (ct-props-correct)\n- * STATUS: (seems) complete\n- *\n- * Returns 0 if the constraints are satisfied, a positive\n- * error code if not and -1 if an internal error occurred.\n- *\/\n-static int\n-xmlSchemaCheckCTPropsCorrect(xmlSchemaParserCtxtPtr pctxt,\n-                 xmlSchemaTypePtr type)\n-{\n-    \/*\n-    * TODO: Correct the error code; XML_SCHEMAP_SRC_CT_1 is used temporarily.\n-    *\n-    * SPEC (1) \"The values of the properties of a complex type definition must\n-    * be as described in the property tableau in The Complex Type Definition\n-    * Schema Component ($3.4.1), modulo the impact of Missing\n-    * Sub-components ($5.3).\"\n-    *\/\n-    if ((type->baseType != NULL) &&\n-    (WXS_IS_SIMPLE(type->baseType)) &&\n-    (WXS_IS_EXTENSION(type) == 0)) {\n-    \/*\n-    * SPEC (2) \"If the {base type definition} is a simple type definition,\n-    * the {derivation method} must be extension.\"\n-    *\/\n-    xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_SRC_CT_1,\n-        NULL, WXS_BASIC_CAST type,\n-        \"If the base type is a simple type, the derivation method must be \"\n-        \"'extension'\", NULL, NULL);\n-    return (XML_SCHEMAP_SRC_CT_1);\n-    }\n-    \/*\n-    * SPEC (3) \"Circular definitions are disallowed, except for the `ur-type\n-    * definition`. That is, it must be possible to reach the `ur-type\n-    * definition` by repeatedly following the {base type definition}.\"\n-    *\n-    * NOTE (3) is done in xmlSchemaCheckTypeDefCircular().\n-    *\/\n-    \/*\n-    * NOTE that (4) and (5) need the following:\n-    *   - attribute uses need to be already inherited (apply attr. prohibitions)\n-    *   - attribute group references need to be expanded already\n-    *   - simple types need to be typefixed already\n-    *\/\n-    if (type->attrUses &&\n-    (((xmlSchemaItemListPtr) type->attrUses)->nbItems > 1))\n-    {\n-    xmlSchemaItemListPtr uses = (xmlSchemaItemListPtr) type->attrUses;\n-    xmlSchemaAttributeUsePtr use, tmp;\n-    int i, j, hasId = 0;\n-\n-    for (i = uses->nbItems -1; i >= 0; i--) {\n-        use = uses->items[i];\n-\n-        \/*\n-        * SPEC ct-props-correct\n-        * (4) \"Two distinct attribute declarations in the\n-        * {attribute uses} must not have identical {name}s and\n-        * {target namespace}s.\"\n-        *\/\n-        if (i > 0) {\n-        for (j = i -1; j >= 0; j--) {\n-            tmp = uses->items[j];\n-            if ((WXS_ATTRUSE_DECL_NAME(use) ==\n-            WXS_ATTRUSE_DECL_NAME(tmp)) &&\n-            (WXS_ATTRUSE_DECL_TNS(use) ==\n-            WXS_ATTRUSE_DECL_TNS(tmp)))\n-            {\n-            xmlChar *str = NULL;\n-\n-            xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-                XML_SCHEMAP_AG_PROPS_CORRECT,\n-                NULL, WXS_BASIC_CAST type,\n-                \"Duplicate %s\",\n-                xmlSchemaGetComponentDesignation(&str, use),\n-                NULL);\n-            FREE_AND_NULL(str);\n-            \/*\n-            * Remove the duplicate.\n-            *\/\n-            if (xmlSchemaItemListRemove(uses, i) == -1)\n-                goto exit_failure;\n-            goto next_use;\n-            }\n-        }\n-        }\n-        \/*\n-        * SPEC ct-props-correct\n-        * (5) \"Two distinct attribute declarations in the\n-        * {attribute uses} must not have {type definition}s which\n-        * are or are derived from ID.\"\n-        *\/\n-        if (WXS_ATTRUSE_TYPEDEF(use) != NULL) {\n-        if (xmlSchemaIsDerivedFromBuiltInType(\n-            WXS_ATTRUSE_TYPEDEF(use), XML_SCHEMAS_ID))\n-        {\n-            if (hasId) {\n-            xmlChar *str = NULL;\n-\n-            xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-                XML_SCHEMAP_AG_PROPS_CORRECT,\n-                NULL, WXS_BASIC_CAST type,\n-                \"There must not exist more than one attribute \"\n-                \"declaration of type 'xs:ID' \"\n-                \"(or derived from 'xs:ID'). The %s violates this \"\n-                \"constraint\",\n-                xmlSchemaGetComponentDesignation(&str, use),\n-                NULL);\n-            FREE_AND_NULL(str);\n-            if (xmlSchemaItemListRemove(uses, i) == -1)\n-                goto exit_failure;\n-            }\n-\n-            hasId = 1;\n-        }\n-        }\n-next_use: {}\n-    }\n-    }\n-    return (0);\n-exit_failure:\n-    return(-1);\n-}\n-\n-static int\n-xmlSchemaAreEqualTypes(xmlSchemaTypePtr typeA,\n-               xmlSchemaTypePtr typeB)\n-{\n-    \/*\n-    * TODO: This should implement component-identity\n-    * in the future.\n-    *\/\n-    if ((typeA == NULL) || (typeB == NULL))\n-    return (0);\n-    return (typeA == typeB);\n-}\n-\n-\/**\n- * xmlSchemaCheckCOSCTDerivedOK:\n- * @ctxt:  the schema parser context\n- * @type:  the to-be derived complex type definition\n- * @baseType:  the base complex type definition\n- * @set: the given set\n- *\n- * Schema Component Constraint:\n- * Type Derivation OK (Complex) (cos-ct-derived-ok)\n- *\n- * STATUS: completed\n- *\n- * Returns 0 if the constraints are satisfied, or 1\n- * if not.\n- *\/\n-static int\n-xmlSchemaCheckCOSCTDerivedOK(xmlSchemaAbstractCtxtPtr actxt,\n-                 xmlSchemaTypePtr type,\n-                 xmlSchemaTypePtr baseType,\n-                 int set)\n-{\n-    int equal = xmlSchemaAreEqualTypes(type, baseType);\n-    \/* TODO: Error codes. *\/\n-    \/*\n-    * SPEC \"For a complex type definition (call it D, for derived)\n-    * to be validly derived from a type definition (call this\n-    * B, for base) given a subset of {extension, restriction}\n-    * all of the following must be true:\"\n-    *\/\n-    if (! equal) {\n-    \/*\n-    * SPEC (1) \"If B and D are not the same type definition, then the\n-    * {derivation method} of D must not be in the subset.\"\n-    *\/\n-    if (((set & SUBSET_EXTENSION) && (WXS_IS_EXTENSION(type))) ||\n-        ((set & SUBSET_RESTRICTION) && (WXS_IS_RESTRICTION(type))))\n-        return (1);\n-    } else {\n-    \/*\n-    * SPEC (2.1) \"B and D must be the same type definition.\"\n-    *\/\n-    return (0);\n-    }\n-    \/*\n-    * SPEC (2.2) \"B must be D's {base type definition}.\"\n-    *\/\n-    if (type->baseType == baseType)\n-    return (0);\n-    \/*\n-    * SPEC (2.3.1) \"D's {base type definition} must not be the `ur-type\n-    * definition`.\"\n-    *\/\n-    if (WXS_IS_ANYTYPE(type->baseType))\n-    return (1);\n-\n-    if (WXS_IS_COMPLEX(type->baseType)) {\n-    \/*\n-    * SPEC (2.3.2.1) \"If D's {base type definition} is complex, then it\n-    * must be validly derived from B given the subset as defined by this\n-    * constraint.\"\n-    *\/\n-    return (xmlSchemaCheckCOSCTDerivedOK(actxt, type->baseType,\n-        baseType, set));\n-    } else {\n-    \/*\n-    * SPEC (2.3.2.2) \"If D's {base type definition} is simple, then it\n-    * must be validly derived from B given the subset as defined in Type\n-    * Derivation OK (Simple) ($3.14.6).\n-    *\/\n-    return (xmlSchemaCheckCOSSTDerivedOK(actxt, type->baseType,\n-        baseType, set));\n-    }\n-}\n-\n-\/**\n- * xmlSchemaCheckCOSDerivedOK:\n- * @type:  the derived simple type definition\n- * @baseType:  the base type definition\n- *\n- * Calls:\n- * Type Derivation OK (Simple) AND Type Derivation OK (Complex)\n- *\n- * Checks whether @type can be validly derived from @baseType.\n- *\n- * Returns 0 on success, an positive error code otherwise.\n- *\/\n-static int\n-xmlSchemaCheckCOSDerivedOK(xmlSchemaAbstractCtxtPtr actxt,\n-               xmlSchemaTypePtr type,\n-               xmlSchemaTypePtr baseType,\n-               int set)\n-{\n-    if (WXS_IS_SIMPLE(type))\n-    return (xmlSchemaCheckCOSSTDerivedOK(actxt, type, baseType, set));\n-    else\n-    return (xmlSchemaCheckCOSCTDerivedOK(actxt, type, baseType, set));\n-}\n-\n-\/**\n- * xmlSchemaCheckCOSCTExtends:\n- * @ctxt:  the schema parser context\n- * @type:  the complex type definition\n- *\n- * (3.4.6) Constraints on Complex Type Definition Schema Components\n- * Schema Component Constraint:\n- * Derivation Valid (Extension) (cos-ct-extends)\n- *\n- * STATUS:\n- *   missing:\n- *     (1.5)\n- *     (1.4.3.2.2.2) \"Particle Valid (Extension)\"\n- *\n- * Returns 0 if the constraints are satisfied, a positive\n- * error code if not and -1 if an internal error occurred.\n- *\/\n-static int\n-xmlSchemaCheckCOSCTExtends(xmlSchemaParserCtxtPtr ctxt,\n-               xmlSchemaTypePtr type)\n-{\n-    xmlSchemaTypePtr base = type->baseType;\n-    \/*\n-    * TODO: Correct the error code; XML_SCHEMAP_COS_CT_EXTENDS_1_1 is used\n-    * temporarily only.\n-    *\/\n-    \/*\n-    * SPEC (1) \"If the {base type definition} is a complex type definition,\n-    * then all of the following must be true:\"\n-    *\/\n-    if (WXS_IS_COMPLEX(base)) {\n-    \/*\n-    * SPEC (1.1) \"The {final} of the {base type definition} must not\n-    * contain extension.\"\n-    *\/\n-    if (base->flags & XML_SCHEMAS_TYPE_FINAL_EXTENSION) {\n-        xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_COS_CT_EXTENDS_1_1,\n-        WXS_BASIC_CAST type, NULL,\n-        \"The 'final' of the base type definition \"\n-        \"contains 'extension'\", NULL);\n-        return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);\n-    }\n-\n-    \/*\n-    * ATTENTION: The constrains (1.2) and (1.3) are not applied,\n-    * since they are automatically satisfied through the\n-    * inheriting mechanism.\n-    * Note that even if redefining components, the inheriting mechanism\n-    * is used.\n-    *\/\n-#if 0\n-    \/*\n-    * SPEC (1.2) \"Its {attribute uses} must be a subset of the {attribute\n-    * uses}\n-    * of the complex type definition itself, that is, for every attribute\n-    * use in the {attribute uses} of the {base type definition}, there\n-    * must be an attribute use in the {attribute uses} of the complex\n-    * type definition itself whose {attribute declaration} has the same\n-    * {name}, {target namespace} and {type definition} as its attribute\n-    * declaration\"\n-    *\/\n-    if (base->attrUses != NULL) {\n-        int i, j, found;\n-        xmlSchemaAttributeUsePtr use, buse;\n-\n-        for (i = 0; i < (WXS_LIST_CAST base->attrUses)->nbItems; i ++) {\n-        buse = (WXS_LIST_CAST base->attrUses)->items[i];\n-        found = 0;\n-        if (type->attrUses != NULL) {\n-            use = (WXS_LIST_CAST type->attrUses)->items[j];\n-            for (j = 0; j < (WXS_LIST_CAST type->attrUses)->nbItems; j ++)\n-            {\n-            if ((WXS_ATTRUSE_DECL_NAME(use) ==\n-                WXS_ATTRUSE_DECL_NAME(buse)) &&\n-                (WXS_ATTRUSE_DECL_TNS(use) ==\n-                WXS_ATTRUSE_DECL_TNS(buse)) &&\n-                (WXS_ATTRUSE_TYPEDEF(use) ==\n-                WXS_ATTRUSE_TYPEDEF(buse))\n-            {\n-                found = 1;\n-                break;\n-            }\n-            }\n-        }\n-        if (! found) {\n-            xmlChar *str = NULL;\n-\n-            xmlSchemaCustomErr(ACTXT_CAST ctxt,\n-            XML_SCHEMAP_COS_CT_EXTENDS_1_2,\n-            NULL, WXS_BASIC_CAST type,\n-            \/*\n-            * TODO: The report does not indicate that also the\n-            * type needs to be the same.\n-            *\/\n-            \"This type is missing a matching correspondent \"\n-            \"for its {base type}'s %s in its {attribute uses}\",\n-            xmlSchemaGetComponentDesignation(&str,\n-                buse->children),\n-            NULL);\n-            FREE_AND_NULL(str)\n-        }\n-        }\n-    }\n-    \/*\n-    * SPEC (1.3) \"If it has an {attribute wildcard}, the complex type\n-    * definition must also have one, and the base type definition's\n-    * {attribute  wildcard}'s {namespace constraint} must be a subset\n-    * of the complex  type definition's {attribute wildcard}'s {namespace\n-    * constraint}, as defined by Wildcard Subset ($3.10.6).\"\n-    *\/\n-\n-    \/*\n-    * MAYBE TODO: Enable if ever needed. But this will be needed only\n-    * if created the type via a schema construction API.\n-    *\/\n-    if (base->attributeWildcard != NULL) {\n-        if (type->attributeWildcard == NULL) {\n-        xmlChar *str = NULL;\n-\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-            XML_SCHEMAP_COS_CT_EXTENDS_1_3,\n-            NULL, type,\n-            \"The base %s has an attribute wildcard, \"\n-            \"but this type is missing an attribute wildcard\",\n-            xmlSchemaGetComponentDesignation(&str, base));\n-        FREE_AND_NULL(str)\n-\n-        } else if (xmlSchemaCheckCOSNSSubset(\n-        base->attributeWildcard, type->attributeWildcard))\n-        {\n-        xmlChar *str = NULL;\n-\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-            XML_SCHEMAP_COS_CT_EXTENDS_1_3,\n-            NULL, type,\n-            \"The attribute wildcard is not a valid \"\n-            \"superset of the one in the base %s\",\n-            xmlSchemaGetComponentDesignation(&str, base));\n-        FREE_AND_NULL(str)\n-        }\n-    }\n-#endif\n-    \/*\n-    * SPEC (1.4) \"One of the following must be true:\"\n-    *\/\n-    if ((type->contentTypeDef != NULL) &&\n-        (type->contentTypeDef == base->contentTypeDef)) {\n-        \/*\n-        * SPEC (1.4.1) \"The {content type} of the {base type definition}\n-        * and the {content type} of the complex type definition itself\n-        * must be the same simple type definition\"\n-        * PASS\n-        *\/\n-    } else if ((type->contentType == XML_SCHEMA_CONTENT_EMPTY) &&\n-        (base->contentType == XML_SCHEMA_CONTENT_EMPTY) ) {\n-        \/*\n-        * SPEC (1.4.2) \"The {content type} of both the {base type\n-        * definition} and the complex type definition itself must\n-        * be empty.\"\n-        * PASS\n-        *\/\n-    } else {\n-        \/*\n-        * SPEC (1.4.3) \"All of the following must be true:\"\n-        *\/\n-        if (type->subtypes == NULL) {\n-        \/*\n-        * SPEC 1.4.3.1 The {content type} of the complex type\n-        * definition itself must specify a particle.\n-        *\/\n-        xmlSchemaPCustomErr(ctxt,\n-            XML_SCHEMAP_COS_CT_EXTENDS_1_1,\n-            WXS_BASIC_CAST type, NULL,\n-            \"The content type must specify a particle\", NULL);\n-        return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);\n-        }\n-        \/*\n-        * SPEC (1.4.3.2) \"One of the following must be true:\"\n-        *\/\n-        if (base->contentType == XML_SCHEMA_CONTENT_EMPTY) {\n-        \/*\n-        * SPEC (1.4.3.2.1) \"The {content type} of the {base type\n-        * definition} must be empty.\n-        * PASS\n-        *\/\n-        } else {\n-        \/*\n-        * SPEC (1.4.3.2.2) \"All of the following must be true:\"\n-        *\/\n-        if ((type->contentType != base->contentType) ||\n-            ((type->contentType != XML_SCHEMA_CONTENT_MIXED) &&\n-            (type->contentType != XML_SCHEMA_CONTENT_ELEMENTS))) {\n-            \/*\n-            * SPEC (1.4.3.2.2.1) \"Both {content type}s must be mixed\n-            * or both must be element-only.\"\n-            *\/\n-            xmlSchemaPCustomErr(ctxt,\n-            XML_SCHEMAP_COS_CT_EXTENDS_1_1,\n-            WXS_BASIC_CAST type, NULL,\n-            \"The content type of both, the type and its base \"\n-            \"type, must either 'mixed' or 'element-only'\", NULL);\n-            return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);\n-        }\n-        \/*\n-        * URGENT TODO SPEC (1.4.3.2.2.2) \"The particle of the\n-        * complex type definition must be a `valid extension`\n-        * of the {base type definition}'s particle, as defined\n-        * in Particle Valid (Extension) ($3.9.6).\"\n-        *\n-        * NOTE that we won't check \"Particle Valid (Extension)\",\n-        * since it is ensured by the derivation process in\n-        * xmlSchemaTypeFixup(). We need to implement this when heading\n-        * for a construction API\n-        * TODO: !! This is needed to be checked if redefining a type !!\n-        *\/\n-        }\n-        \/*\n-        * URGENT TODO (1.5)\n-        *\/\n-    }\n-    } else {\n-    \/*\n-    * SPEC (2) \"If the {base type definition} is a simple type definition,\n-    * then all of the following must be true:\"\n-    *\/\n-    if (type->contentTypeDef != base) {\n-        \/*\n-        * SPEC (2.1) \"The {content type} must be the same simple type\n-        * definition.\"\n-        *\/\n-        xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_COS_CT_EXTENDS_1_1,\n-        WXS_BASIC_CAST type, NULL,\n-        \"The content type must be the simple base type\", NULL);\n-        return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);\n-    }\n-    if (base->flags & XML_SCHEMAS_TYPE_FINAL_EXTENSION) {\n-        \/*\n-        * SPEC (2.2) \"The {final} of the {base type definition} must not\n-        * contain extension\"\n-        * NOTE that this is the same as (1.1).\n-        *\/\n-        xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_COS_CT_EXTENDS_1_1,\n-        WXS_BASIC_CAST type, NULL,\n-        \"The 'final' of the base type definition \"\n-        \"contains 'extension'\", NULL);\n-        return (XML_SCHEMAP_COS_CT_EXTENDS_1_1);\n-    }\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaCheckDerivationOKRestriction:\n- * @ctxt:  the schema parser context\n- * @type:  the complex type definition\n- *\n- * (3.4.6) Constraints on Complex Type Definition Schema Components\n- * Schema Component Constraint:\n- * Derivation Valid (Restriction, Complex) (derivation-ok-restriction)\n- *\n- * STATUS:\n- *   missing:\n- *     (5.4.2) ???\n- *\n- * ATTENTION:\n- * In XML Schema 1.1 this will be:\n- * Validation Rule: Checking complex type subsumption\n- *\n- * Returns 0 if the constraints are satisfied, a positive\n- * error code if not and -1 if an internal error occurred.\n- *\/\n-static int\n-xmlSchemaCheckDerivationOKRestriction(xmlSchemaParserCtxtPtr ctxt,\n-                      xmlSchemaTypePtr type)\n-{\n-    xmlSchemaTypePtr base;\n-\n-    \/*\n-    * TODO: Correct the error code; XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1 is used\n-    * temporarily only.\n-    *\/\n-    base = type->baseType;\n-    if (! WXS_IS_COMPLEX(base)) {\n-    xmlSchemaCustomErr(ACTXT_CAST ctxt,\n-        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,\n-        type->node, WXS_BASIC_CAST type,\n-        \"The base type must be a complex type\", NULL, NULL);\n-    return(ctxt->err);\n-    }\n-    if (base->flags & XML_SCHEMAS_TYPE_FINAL_RESTRICTION) {\n-    \/*\n-    * SPEC (1) \"The {base type definition} must be a complex type\n-    * definition whose {final} does not contain restriction.\"\n-    *\/\n-    xmlSchemaCustomErr(ACTXT_CAST ctxt,\n-        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,\n-        type->node, WXS_BASIC_CAST type,\n-        \"The 'final' of the base type definition \"\n-        \"contains 'restriction'\", NULL, NULL);\n-    return (ctxt->err);\n-    }\n-    \/*\n-    * SPEC (2), (3) and (4)\n-    * Those are handled in a separate function, since the\n-    * same constraints are needed for redefinition of\n-    * attribute groups as well.\n-    *\/\n-    if (xmlSchemaCheckDerivationOKRestriction2to4(ctxt,\n-    XML_SCHEMA_ACTION_DERIVE,\n-    WXS_BASIC_CAST type, WXS_BASIC_CAST base,\n-    type->attrUses, base->attrUses,\n-    type->attributeWildcard,\n-    base->attributeWildcard) == -1)\n-    {\n-    return(-1);\n-    }\n-    \/*\n-    * SPEC (5) \"One of the following must be true:\"\n-    *\/\n-    if (base->builtInType == XML_SCHEMAS_ANYTYPE) {\n-    \/*\n-    * SPEC (5.1) \"The {base type definition} must be the\n-    * `ur-type definition`.\"\n-    * PASS\n-    *\/\n-    } else if ((type->contentType == XML_SCHEMA_CONTENT_SIMPLE) ||\n-        (type->contentType == XML_SCHEMA_CONTENT_BASIC)) {\n-    \/*\n-    * SPEC (5.2.1) \"The {content type} of the complex type definition\n-    * must be a simple type definition\"\n-    *\n-    * SPEC (5.2.2) \"One of the following must be true:\"\n-    *\/\n-    if ((base->contentType == XML_SCHEMA_CONTENT_SIMPLE) ||\n-        (base->contentType == XML_SCHEMA_CONTENT_BASIC))\n-    {\n-        int err;\n-        \/*\n-        * SPEC (5.2.2.1) \"The {content type} of the {base type\n-        * definition} must be a simple type definition from which\n-        * the {content type} is validly derived given the empty\n-        * set as defined in Type Derivation OK (Simple) ($3.14.6).\"\n-        *\n-        * ATTENTION TODO: This seems not needed if the type implicitly\n-        * derived from the base type.\n-        *\n-        *\/\n-        err = xmlSchemaCheckCOSSTDerivedOK(ACTXT_CAST ctxt,\n-        type->contentTypeDef, base->contentTypeDef, 0);\n-        if (err != 0) {\n-        xmlChar *strA = NULL, *strB = NULL;\n-\n-        if (err == -1)\n-            return(-1);\n-        xmlSchemaCustomErr(ACTXT_CAST ctxt,\n-            XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,\n-            NULL, WXS_BASIC_CAST type,\n-            \"The {content type} %s is not validly derived from the \"\n-            \"base type's {content type} %s\",\n-            xmlSchemaGetComponentDesignation(&strA,\n-            type->contentTypeDef),\n-            xmlSchemaGetComponentDesignation(&strB,\n-            base->contentTypeDef));\n-        FREE_AND_NULL(strA);\n-        FREE_AND_NULL(strB);\n-        return(ctxt->err);\n-        }\n-    } else if ((base->contentType == XML_SCHEMA_CONTENT_MIXED) &&\n-        (xmlSchemaIsParticleEmptiable(\n-        (xmlSchemaParticlePtr) base->subtypes))) {\n-        \/*\n-        * SPEC (5.2.2.2) \"The {base type definition} must be mixed\n-        * and have a particle which is `emptiable` as defined in\n-        * Particle Emptiable ($3.9.6).\"\n-        * PASS\n-        *\/\n-    } else {\n-        xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,\n-        WXS_BASIC_CAST type, NULL,\n-        \"The content type of the base type must be either \"\n-        \"a simple type or 'mixed' and an emptiable particle\", NULL);\n-        return (ctxt->err);\n-    }\n-    } else if (type->contentType == XML_SCHEMA_CONTENT_EMPTY) {\n-    \/*\n-    * SPEC (5.3.1) \"The {content type} of the complex type itself must\n-    * be empty\"\n-    *\/\n-    if (base->contentType == XML_SCHEMA_CONTENT_EMPTY) {\n-        \/*\n-        * SPEC (5.3.2.1) \"The {content type} of the {base type\n-        * definition} must also be empty.\"\n-        * PASS\n-        *\/\n-    } else if (((base->contentType == XML_SCHEMA_CONTENT_ELEMENTS) ||\n-        (base->contentType == XML_SCHEMA_CONTENT_MIXED)) &&\n-        xmlSchemaIsParticleEmptiable(\n-        (xmlSchemaParticlePtr) base->subtypes)) {\n-        \/*\n-        * SPEC (5.3.2.2) \"The {content type} of the {base type\n-        * definition} must be elementOnly or mixed and have a particle\n-        * which is `emptiable` as defined in Particle Emptiable ($3.9.6).\"\n-        * PASS\n-        *\/\n-    } else {\n-        xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,\n-        WXS_BASIC_CAST type, NULL,\n-        \"The content type of the base type must be either \"\n-        \"empty or 'mixed' (or 'elements-only') and an emptiable \"\n-        \"particle\", NULL);\n-        return (ctxt->err);\n-    }\n-    } else if ((type->contentType == XML_SCHEMA_CONTENT_ELEMENTS) ||\n-    WXS_HAS_MIXED_CONTENT(type)) {\n-    \/*\n-    * SPEC (5.4.1.1) \"The {content type} of the complex type definition\n-    * itself must be element-only\"\n-    *\/\n-    if (WXS_HAS_MIXED_CONTENT(type) && (! WXS_HAS_MIXED_CONTENT(base))) {\n-        \/*\n-        * SPEC (5.4.1.2) \"The {content type} of the complex type\n-        * definition itself and of the {base type definition} must be\n-        * mixed\"\n-        *\/\n-        xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,\n-        WXS_BASIC_CAST type, NULL,\n-        \"If the content type is 'mixed', then the content type of the \"\n-        \"base type must also be 'mixed'\", NULL);\n-        return (ctxt->err);\n-    }\n-    \/*\n-    * SPEC (5.4.2) \"The particle of the complex type definition itself\n-    * must be a `valid restriction` of the particle of the {content\n-    * type} of the {base type definition} as defined in Particle Valid\n-    * (Restriction) ($3.9.6).\n-    *\n-    * URGENT TODO: (5.4.2)\n-    *\/\n-    } else {\n-    xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,\n-        WXS_BASIC_CAST type, NULL,\n-        \"The type is not a valid restriction of its base type\", NULL);\n-    return (ctxt->err);\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaCheckCTComponent:\n- * @ctxt:  the schema parser context\n- * @type:  the complex type definition\n- *\n- * (3.4.6) Constraints on Complex Type Definition Schema Components\n- *\n- * Returns 0 if the constraints are satisfied, a positive\n- * error code if not and -1 if an internal error occurred.\n- *\/\n-static int\n-xmlSchemaCheckCTComponent(xmlSchemaParserCtxtPtr ctxt,\n-              xmlSchemaTypePtr type)\n-{\n-    int ret;\n-    \/*\n-    * Complex Type Definition Properties Correct\n-    *\/\n-    ret = xmlSchemaCheckCTPropsCorrect(ctxt, type);\n-    if (ret != 0)\n-    return (ret);\n-    if (WXS_IS_EXTENSION(type))\n-    ret = xmlSchemaCheckCOSCTExtends(ctxt, type);\n-    else\n-    ret = xmlSchemaCheckDerivationOKRestriction(ctxt, type);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaCheckSRCCT:\n- * @ctxt:  the schema parser context\n- * @type:  the complex type definition\n- *\n- * (3.4.3) Constraints on XML Representations of Complex Type Definitions:\n- * Schema Representation Constraint:\n- * Complex Type Definition Representation OK (src-ct)\n- *\n- * Returns 0 if the constraints are satisfied, a positive\n- * error code if not and -1 if an internal error occurred.\n- *\/\n-static int\n-xmlSchemaCheckSRCCT(xmlSchemaParserCtxtPtr ctxt,\n-            xmlSchemaTypePtr type)\n-{\n-    xmlSchemaTypePtr base;\n-    int ret = 0;\n-\n-    \/*\n-    * TODO: Adjust the error codes here, as I used\n-    * XML_SCHEMAP_SRC_CT_1 only yet.\n-    *\/\n-    base = type->baseType;\n-    if (! WXS_HAS_SIMPLE_CONTENT(type)) {\n-    \/*\n-    * 1 If the <complexContent> alternative is chosen, the type definition\n-    * `resolved` to by the `actual value` of the base [attribute]\n-    * must be a complex type definition;\n-    *\/\n-    if (! WXS_IS_COMPLEX(base)) {\n-        xmlChar *str = NULL;\n-        xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_SRC_CT_1,\n-        WXS_BASIC_CAST type, type->node,\n-        \"If using <complexContent>, the base type is expected to be \"\n-        \"a complex type. The base type '%s' is a simple type\",\n-        xmlSchemaFormatQName(&str, base->targetNamespace,\n-        base->name));\n-        FREE_AND_NULL(str)\n-        return (XML_SCHEMAP_SRC_CT_1);\n-    }\n-    } else {\n-    \/*\n-    * SPEC\n-    * 2 If the <simpleContent> alternative is chosen, all of the\n-    * following must be true:\n-    * 2.1 The type definition `resolved` to by the `actual value` of the\n-    * base [attribute] must be one of the following:\n-    *\/\n-    if (WXS_IS_SIMPLE(base)) {\n-        if (WXS_IS_EXTENSION(type) == 0) {\n-        xmlChar *str = NULL;\n-        \/*\n-        * 2.1.3 only if the <extension> alternative is also\n-        * chosen, a simple type definition.\n-        *\/\n-        \/* TODO: Change error code to ..._SRC_CT_2_1_3. *\/\n-        xmlSchemaPCustomErr(ctxt,\n-            XML_SCHEMAP_SRC_CT_1,\n-            WXS_BASIC_CAST type, NULL,\n-            \"If using <simpleContent> and <restriction>, the base \"\n-            \"type must be a complex type. The base type '%s' is \"\n-            \"a simple type\",\n-            xmlSchemaFormatQName(&str, base->targetNamespace,\n-            base->name));\n-        FREE_AND_NULL(str)\n-        return (XML_SCHEMAP_SRC_CT_1);\n-        }\n-    } else {\n-        \/* Base type is a complex type. *\/\n-        if ((base->contentType == XML_SCHEMA_CONTENT_SIMPLE) ||\n-        (base->contentType == XML_SCHEMA_CONTENT_BASIC)) {\n-        \/*\n-        * 2.1.1 a complex type definition whose {content type} is a\n-        * simple type definition;\n-        * PASS\n-        *\/\n-        if (base->contentTypeDef == NULL) {\n-            xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_INTERNAL,\n-            WXS_BASIC_CAST type, NULL,\n-            \"Internal error: xmlSchemaCheckSRCCT, \"\n-            \"'%s', base type has no content type\",\n-            type->name);\n-            return (-1);\n-        }\n-        } else if ((base->contentType == XML_SCHEMA_CONTENT_MIXED) &&\n-        (WXS_IS_RESTRICTION(type))) {\n-\n-        \/*\n-        * 2.1.2 only if the <restriction> alternative is also\n-        * chosen, a complex type definition whose {content type}\n-        * is mixed and a particle emptiable.\n-        *\/\n-        if (! xmlSchemaIsParticleEmptiable(\n-            (xmlSchemaParticlePtr) base->subtypes)) {\n-            ret = XML_SCHEMAP_SRC_CT_1;\n-        } else\n-            \/*\n-            * Attention: at this point the <simpleType> child is in\n-            * ->contentTypeDef (put there during parsing).\n-            *\/\n-            if (type->contentTypeDef == NULL) {\n-            xmlChar *str = NULL;\n-            \/*\n-            * 2.2 If clause 2.1.2 above is satisfied, then there\n-            * must be a <simpleType> among the [children] of\n-            * <restriction>.\n-            *\/\n-            \/* TODO: Change error code to ..._SRC_CT_2_2. *\/\n-            xmlSchemaPCustomErr(ctxt,\n-            XML_SCHEMAP_SRC_CT_1,\n-            WXS_BASIC_CAST type, NULL,\n-            \"A <simpleType> is expected among the children \"\n-            \"of <restriction>, if <simpleContent> is used and \"\n-            \"the base type '%s' is a complex type\",\n-            xmlSchemaFormatQName(&str, base->targetNamespace,\n-            base->name));\n-            FREE_AND_NULL(str)\n-            return (XML_SCHEMAP_SRC_CT_1);\n-        }\n-        } else {\n-        ret = XML_SCHEMAP_SRC_CT_1;\n-        }\n-    }\n-    if (ret > 0) {\n-        xmlChar *str = NULL;\n-        if (WXS_IS_RESTRICTION(type)) {\n-        xmlSchemaPCustomErr(ctxt,\n-            XML_SCHEMAP_SRC_CT_1,\n-            WXS_BASIC_CAST type, NULL,\n-            \"If <simpleContent> and <restriction> is used, the \"\n-            \"base type must be a simple type or a complex type with \"\n-            \"mixed content and particle emptiable. The base type \"\n-            \"'%s' is none of those\",\n-            xmlSchemaFormatQName(&str, base->targetNamespace,\n-            base->name));\n-        } else {\n-        xmlSchemaPCustomErr(ctxt,\n-            XML_SCHEMAP_SRC_CT_1,\n-            WXS_BASIC_CAST type, NULL,\n-            \"If <simpleContent> and <extension> is used, the \"\n-            \"base type must be a simple type. The base type '%s' \"\n-            \"is a complex type\",\n-            xmlSchemaFormatQName(&str, base->targetNamespace,\n-            base->name));\n-        }\n-        FREE_AND_NULL(str)\n-    }\n-    }\n-    \/*\n-    * SPEC (3) \"The corresponding complex type definition component must\n-    * satisfy the conditions set out in Constraints on Complex Type\n-    * Definition Schema Components ($3.4.6);\"\n-    * NOTE (3) will be done in xmlSchemaTypeFixup().\n-    *\/\n-    \/*\n-    * SPEC (4) If clause 2.2.1 or clause 2.2.2 in the correspondence specification\n-    * above for {attribute wildcard} is satisfied, the intensional\n-    * intersection must be expressible, as defined in Attribute Wildcard\n-    * Intersection ($3.10.6).\n-    * NOTE (4) is done in xmlSchemaFixupTypeAttributeUses().\n-    *\/\n-    return (ret);\n-}\n-\n-#ifdef ENABLE_PARTICLE_RESTRICTION\n-\/**\n- * xmlSchemaCheckParticleRangeOK:\n- * @ctxt:  the schema parser context\n- * @type:  the complex type definition\n- *\n- * (3.9.6) Constraints on Particle Schema Components\n- * Schema Component Constraint:\n- * Occurrence Range OK (range-ok)\n- *\n- * STATUS: complete\n- *\n- * Returns 0 if the constraints are satisfied, a positive\n- * error code if not and -1 if an internal error occurred.\n- *\/\n-static int\n-xmlSchemaCheckParticleRangeOK(int rmin, int rmax,\n-                  int bmin, int bmax)\n-{\n-    if (rmin < bmin)\n-    return (1);\n-    if ((bmax != UNBOUNDED) &&\n-    (rmax > bmax))\n-    return (1);\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaCheckRCaseNameAndTypeOK:\n- * @ctxt:  the schema parser context\n- * @r: the restricting element declaration particle\n- * @b: the base element declaration particle\n- *\n- * (3.9.6) Constraints on Particle Schema Components\n- * Schema Component Constraint:\n- * Particle Restriction OK (Elt:Elt -- NameAndTypeOK)\n- * (rcase-NameAndTypeOK)\n- *\n- * STATUS:\n- *   MISSING (3.2.3)\n- *   CLARIFY: (3.2.2)\n- *\n- * Returns 0 if the constraints are satisfied, a positive\n- * error code if not and -1 if an internal error occurred.\n- *\/\n-static int\n-xmlSchemaCheckRCaseNameAndTypeOK(xmlSchemaParserCtxtPtr ctxt,\n-                 xmlSchemaParticlePtr r,\n-                 xmlSchemaParticlePtr b)\n-{\n-    xmlSchemaElementPtr elemR, elemB;\n-\n-    \/* TODO: Error codes (rcase-NameAndTypeOK). *\/\n-    elemR = (xmlSchemaElementPtr) r->children;\n-    elemB = (xmlSchemaElementPtr) b->children;\n-    \/*\n-    * SPEC (1) \"The declarations' {name}s and {target namespace}s are\n-    * the same.\"\n-    *\/\n-    if ((elemR != elemB) &&\n-    ((! xmlStrEqual(elemR->name, elemB->name)) ||\n-    (! xmlStrEqual(elemR->targetNamespace, elemB->targetNamespace))))\n-    return (1);\n-    \/*\n-    * SPEC (2) \"R's occurrence range is a valid restriction of B's\n-    * occurrence range as defined by Occurrence Range OK ($3.9.6).\"\n-    *\/\n-    if (xmlSchemaCheckParticleRangeOK(r->minOccurs, r->maxOccurs,\n-        b->minOccurs, b->maxOccurs) != 0)\n-    return (1);\n-    \/*\n-    * SPEC (3.1) \"Both B's declaration's {scope} and R's declaration's\n-    * {scope} are global.\"\n-    *\/\n-    if (elemR == elemB)\n-    return (0);\n-    \/*\n-    * SPEC (3.2.1) \"Either B's {nillable} is true or R's {nillable} is false.\"\n-    *\/\n-    if (((elemB->flags & XML_SCHEMAS_ELEM_NILLABLE) == 0) &&\n-    (elemR->flags & XML_SCHEMAS_ELEM_NILLABLE))\n-     return (1);\n-    \/*\n-    * SPEC (3.2.2) \"either B's declaration's {value constraint} is absent,\n-    * or is not fixed, or R's declaration's {value constraint} is fixed\n-    * with the same value.\"\n-    *\/\n-    if ((elemB->value != NULL) && (elemB->flags & XML_SCHEMAS_ELEM_FIXED) &&\n-    ((elemR->value == NULL) ||\n-     ((elemR->flags & XML_SCHEMAS_ELEM_FIXED) == 0) ||\n-     \/* TODO: Equality of the initial value or normalized or canonical? *\/\n-     (! xmlStrEqual(elemR->value, elemB->value))))\n-     return (1);\n-    \/*\n-    * TODO: SPEC (3.2.3) \"R's declaration's {identity-constraint\n-    * definitions} is a subset of B's declaration's {identity-constraint\n-    * definitions}, if any.\"\n-    *\/\n-    if (elemB->idcs != NULL) {\n-    \/* TODO *\/\n-    }\n-    \/*\n-    * SPEC (3.2.4) \"R's declaration's {disallowed substitutions} is a\n-    * superset of B's declaration's {disallowed substitutions}.\"\n-    *\/\n-    if (((elemB->flags & XML_SCHEMAS_ELEM_BLOCK_EXTENSION) &&\n-     ((elemR->flags & XML_SCHEMAS_ELEM_BLOCK_EXTENSION) == 0)) ||\n-    ((elemB->flags & XML_SCHEMAS_ELEM_BLOCK_RESTRICTION) &&\n-     ((elemR->flags & XML_SCHEMAS_ELEM_BLOCK_RESTRICTION) == 0)) ||\n-    ((elemB->flags & XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION) &&\n-     ((elemR->flags & XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION) == 0)))\n-     return (1);\n-    \/*\n-    * SPEC (3.2.5) \"R's {type definition} is validly derived given\n-    * {extension, list, union} from B's {type definition}\"\n-    *\n-    * BADSPEC TODO: What's the point of adding \"list\" and \"union\" to the\n-    * set, if the corresponding constraints handle \"restriction\" and\n-    * \"extension\" only?\n-    *\n-    *\/\n-    {\n-    int set = 0;\n-\n-    set |= SUBSET_EXTENSION;\n-    set |= SUBSET_LIST;\n-    set |= SUBSET_UNION;\n-    if (xmlSchemaCheckCOSDerivedOK(ACTXT_CAST ctxt, elemR->subtypes,\n-        elemB->subtypes, set) != 0)\n-        return (1);\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaCheckRCaseNSCompat:\n- * @ctxt:  the schema parser context\n- * @r: the restricting element declaration particle\n- * @b: the base wildcard particle\n- *\n- * (3.9.6) Constraints on Particle Schema Components\n- * Schema Component Constraint:\n- * Particle Derivation OK (Elt:Any -- NSCompat)\n- * (rcase-NSCompat)\n- *\n- * STATUS: complete\n- *\n- * Returns 0 if the constraints are satisfied, a positive\n- * error code if not and -1 if an internal error occurred.\n- *\/\n-static int\n-xmlSchemaCheckRCaseNSCompat(xmlSchemaParserCtxtPtr ctxt,\n-                xmlSchemaParticlePtr r,\n-                xmlSchemaParticlePtr b)\n-{\n-    \/* TODO:Error codes (rcase-NSCompat). *\/\n-    \/*\n-    * SPEC \"For an element declaration particle to be a `valid restriction`\n-    * of a wildcard particle all of the following must be true:\"\n-    *\n-    * SPEC (1) \"The element declaration's {target namespace} is `valid`\n-    * with respect to the wildcard's {namespace constraint} as defined by\n-    * Wildcard allows Namespace Name ($3.10.4).\"\n-    *\/\n-    if (xmlSchemaCheckCVCWildcardNamespace((xmlSchemaWildcardPtr) b->children,\n-    ((xmlSchemaElementPtr) r->children)->targetNamespace) != 0)\n-    return (1);\n-    \/*\n-    * SPEC (2) \"R's occurrence range is a valid restriction of B's\n-    * occurrence range as defined by Occurrence Range OK ($3.9.6).\"\n-    *\/\n-    if (xmlSchemaCheckParticleRangeOK(r->minOccurs, r->maxOccurs,\n-        b->minOccurs, b->maxOccurs) != 0)\n-    return (1);\n-\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaCheckRCaseRecurseAsIfGroup:\n- * @ctxt:  the schema parser context\n- * @r: the restricting element declaration particle\n- * @b: the base model group particle\n- *\n- * (3.9.6) Constraints on Particle Schema Components\n- * Schema Component Constraint:\n- * Particle Derivation OK (Elt:All\/Choice\/Sequence -- RecurseAsIfGroup)\n- * (rcase-RecurseAsIfGroup)\n- *\n- * STATUS: TODO\n- *\n- * Returns 0 if the constraints are satisfied, a positive\n- * error code if not and -1 if an internal error occurred.\n- *\/\n-static int\n-xmlSchemaCheckRCaseRecurseAsIfGroup(xmlSchemaParserCtxtPtr ctxt,\n-                    xmlSchemaParticlePtr r,\n-                    xmlSchemaParticlePtr b)\n-{\n-    \/* TODO: Error codes (rcase-RecurseAsIfGroup). *\/\n-    TODO\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaCheckRCaseNSSubset:\n- * @ctxt:  the schema parser context\n- * @r: the restricting wildcard particle\n- * @b: the base wildcard particle\n- *\n- * (3.9.6) Constraints on Particle Schema Components\n- * Schema Component Constraint:\n- * Particle Derivation OK (Any:Any -- NSSubset)\n- * (rcase-NSSubset)\n- *\n- * STATUS: complete\n- *\n- * Returns 0 if the constraints are satisfied, a positive\n- * error code if not and -1 if an internal error occurred.\n- *\/\n-static int\n-xmlSchemaCheckRCaseNSSubset(xmlSchemaParserCtxtPtr ctxt,\n-                    xmlSchemaParticlePtr r,\n-                    xmlSchemaParticlePtr b,\n-                    int isAnyTypeBase)\n-{\n-    \/* TODO: Error codes (rcase-NSSubset). *\/\n-    \/*\n-    * SPEC (1) \"R's occurrence range is a valid restriction of B's\n-    * occurrence range as defined by Occurrence Range OK ($3.9.6).\"\n-    *\/\n-    if (xmlSchemaCheckParticleRangeOK(r->minOccurs, r->maxOccurs,\n-        b->minOccurs, b->maxOccurs))\n-    return (1);\n-    \/*\n-    * SPEC (2) \"R's {namespace constraint} must be an intensional subset\n-    * of B's {namespace constraint} as defined by Wildcard Subset ($3.10.6).\"\n-    *\/\n-    if (xmlSchemaCheckCOSNSSubset((xmlSchemaWildcardPtr) r->children,\n-    (xmlSchemaWildcardPtr) b->children))\n-    return (1);\n-    \/*\n-    * SPEC (3) \"Unless B is the content model wildcard of the `ur-type\n-    * definition`, R's {process contents} must be identical to or stronger\n-    * than B's {process contents}, where strict is stronger than lax is\n-    * stronger than skip.\"\n-    *\/\n-    if (! isAnyTypeBase) {\n-    if ( ((xmlSchemaWildcardPtr) r->children)->processContents <\n-        ((xmlSchemaWildcardPtr) b->children)->processContents)\n-        return (1);\n-    }\n-\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaCheckCOSParticleRestrict:\n- * @ctxt:  the schema parser context\n- * @type:  the complex type definition\n- *\n- * (3.9.6) Constraints on Particle Schema Components\n- * Schema Component Constraint:\n- * Particle Valid (Restriction) (cos-particle-restrict)\n- *\n- * STATUS: TODO\n- *\n- * Returns 0 if the constraints are satisfied, a positive\n- * error code if not and -1 if an internal error occurred.\n- *\/\n-static int\n-xmlSchemaCheckCOSParticleRestrict(xmlSchemaParserCtxtPtr ctxt,\n-                  xmlSchemaParticlePtr r,\n-                  xmlSchemaParticlePtr b)\n-{\n-    int ret = 0;\n-\n-    \/*part = WXS_TYPE_PARTICLE(type);\n-    basePart = WXS_TYPE_PARTICLE(base);\n-    *\/\n-\n-    TODO\n-\n-    \/*\n-    * SPEC (1) \"They are the same particle.\"\n-    *\/\n-    if (r == b)\n-    return (0);\n-\n-\n-    return (0);\n-}\n-\n-#if 0\n-\/**\n- * xmlSchemaCheckRCaseNSRecurseCheckCardinality:\n- * @ctxt:  the schema parser context\n- * @r: the model group particle\n- * @b: the base wildcard particle\n- *\n- * (3.9.6) Constraints on Particle Schema Components\n- * Schema Component Constraint:\n- * Particle Derivation OK (All\/Choice\/Sequence:Any --\n- *                         NSRecurseCheckCardinality)\n- * (rcase-NSRecurseCheckCardinality)\n- *\n- * STATUS: TODO: subst-groups\n- *\n- * Returns 0 if the constraints are satisfied, a positive\n- * error code if not and -1 if an internal error occurred.\n- *\/\n-static int\n-xmlSchemaCheckRCaseNSRecurseCheckCardinality(xmlSchemaParserCtxtPtr ctxt,\n-                         xmlSchemaParticlePtr r,\n-                         xmlSchemaParticlePtr b)\n-{\n-    xmlSchemaParticlePtr part;\n-    \/* TODO: Error codes (rcase-NSRecurseCheckCardinality). *\/\n-    if ((r->children == NULL) || (r->children->children == NULL))\n-    return (-1);\n-    \/*\n-    * SPEC \"For a group particle to be a `valid restriction` of a\n-    * wildcard particle...\"\n-    *\n-    * SPEC (1) \"Every member of the {particles} of the group is a `valid\n-    * restriction` of the wildcard as defined by\n-    * Particle Valid (Restriction) ($3.9.6).\"\n-    *\/\n-    part = (xmlSchemaParticlePtr) r->children->children;\n-    do {\n-    if (xmlSchemaCheckCOSParticleRestrict(ctxt, part, b))\n-        return (1);\n-    part = (xmlSchemaParticlePtr) part->next;\n-    } while (part != NULL);\n-    \/*\n-    * SPEC (2) \"The effective total range of the group [...] is a\n-    * valid restriction of B's occurrence range as defined by\n-    * Occurrence Range OK ($3.9.6).\"\n-    *\/\n-    if (xmlSchemaCheckParticleRangeOK(\n-        xmlSchemaGetParticleTotalRangeMin(r),\n-        xmlSchemaGetParticleTotalRangeMax(r),\n-        b->minOccurs, b->maxOccurs) != 0)\n-    return (1);\n-    return (0);\n-}\n-#endif\n-\n-\/**\n- * xmlSchemaCheckRCaseRecurse:\n- * @ctxt:  the schema parser context\n- * @r: the <all> or <sequence> model group particle\n- * @b: the base <all> or <sequence> model group particle\n- *\n- * (3.9.6) Constraints on Particle Schema Components\n- * Schema Component Constraint:\n- * Particle Derivation OK (All:All,Sequence:Sequence --\n-                           Recurse)\n- * (rcase-Recurse)\n- *\n- * STATUS:  ?\n- * TODO: subst-groups\n- *\n- * Returns 0 if the constraints are satisfied, a positive\n- * error code if not and -1 if an internal error occurred.\n- *\/\n-static int\n-xmlSchemaCheckRCaseRecurse(xmlSchemaParserCtxtPtr ctxt,\n-               xmlSchemaParticlePtr r,\n-               xmlSchemaParticlePtr b)\n-{\n-    \/* xmlSchemaParticlePtr part; *\/\n-    \/* TODO: Error codes (rcase-Recurse). *\/\n-    if ((r->children == NULL) || (b->children == NULL) ||\n-    (r->children->type != b->children->type))\n-    return (-1);\n-    \/*\n-    * SPEC \"For an all or sequence group particle to be a `valid\n-    * restriction` of another group particle with the same {compositor}...\"\n-    *\n-    * SPEC (1) \"R's occurrence range is a valid restriction of B's\n-    * occurrence range as defined by Occurrence Range OK ($3.9.6).\"\n-    *\/\n-    if (xmlSchemaCheckParticleRangeOK(r->minOccurs, r->maxOccurs,\n-        b->minOccurs, b->maxOccurs))\n-    return (1);\n-\n-\n-    return (0);\n-}\n-\n-#endif\n-\n-#define FACET_RESTR_MUTUAL_ERR(fac1, fac2) \\\n-    xmlSchemaPCustomErrExt(pctxt,      \\\n-    XML_SCHEMAP_INVALID_FACET_VALUE, \\\n-    WXS_BASIC_CAST fac1, fac1->node, \\\n-    \"It is an error for both '%s' and '%s' to be specified on the \"\\\n-    \"same type definition\", \\\n-    BAD_CAST xmlSchemaFacetTypeToString(fac1->type), \\\n-    BAD_CAST xmlSchemaFacetTypeToString(fac2->type), NULL);\n-\n-#define FACET_RESTR_ERR(fac1, msg) \\\n-    xmlSchemaPCustomErr(pctxt,      \\\n-    XML_SCHEMAP_INVALID_FACET_VALUE, \\\n-    WXS_BASIC_CAST fac1, fac1->node, \\\n-    msg, NULL);\n-\n-#define FACET_RESTR_FIXED_ERR(fac) \\\n-    xmlSchemaPCustomErr(pctxt, \\\n-    XML_SCHEMAP_INVALID_FACET_VALUE, \\\n-    WXS_BASIC_CAST fac, fac->node, \\\n-    \"The base type's facet is 'fixed', thus the value must not \" \\\n-    \"differ\", NULL);\n-\n-static void\n-xmlSchemaDeriveFacetErr(xmlSchemaParserCtxtPtr pctxt,\n-            xmlSchemaFacetPtr facet1,\n-            xmlSchemaFacetPtr facet2,\n-            int lessGreater,\n-            int orEqual,\n-            int ofBase)\n-{\n-    xmlChar *msg = NULL;\n-\n-    msg = xmlStrdup(BAD_CAST \"'\");\n-    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet1->type));\n-    msg = xmlStrcat(msg, BAD_CAST \"' has to be\");\n-    if (lessGreater == 0)\n-    msg = xmlStrcat(msg, BAD_CAST \" equal to\");\n-    if (lessGreater == 1)\n-    msg = xmlStrcat(msg, BAD_CAST \" greater than\");\n-    else\n-    msg = xmlStrcat(msg, BAD_CAST \" less than\");\n-\n-    if (orEqual)\n-    msg = xmlStrcat(msg, BAD_CAST \" or equal to\");\n-    msg = xmlStrcat(msg, BAD_CAST \" '\");\n-    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facet2->type));\n-    if (ofBase)\n-    msg = xmlStrcat(msg, BAD_CAST \"' of the base type\");\n-    else\n-    msg = xmlStrcat(msg, BAD_CAST \"'\");\n-\n-    xmlSchemaPCustomErr(pctxt,\n-    XML_SCHEMAP_INVALID_FACET_VALUE,\n-    WXS_BASIC_CAST facet1, NULL,\n-    (const char *) msg, NULL);\n-\n-    if (msg != NULL)\n-    xmlFree(msg);\n-}\n-\n-\/*\n-* xmlSchemaDeriveAndValidateFacets:\n-*\n-* Schema Component Constraint: Simple Type Restriction (Facets)\n-* (st-restrict-facets)\n-*\/\n-static int\n-xmlSchemaDeriveAndValidateFacets(xmlSchemaParserCtxtPtr pctxt,\n-                 xmlSchemaTypePtr type)\n-{\n-    xmlSchemaTypePtr base = type->baseType;\n-    xmlSchemaFacetLinkPtr link, cur, last = NULL;\n-    xmlSchemaFacetPtr facet, bfacet,\n-    flength = NULL, ftotdig = NULL, ffracdig = NULL,\n-    fmaxlen = NULL, fminlen = NULL, \/* facets of the current type *\/\n-    fmininc = NULL, fmaxinc = NULL,\n-    fminexc = NULL, fmaxexc = NULL,\n-    bflength = NULL, bftotdig = NULL, bffracdig = NULL,\n-    bfmaxlen = NULL, bfminlen = NULL, \/* facets of the base type *\/\n-    bfmininc = NULL, bfmaxinc = NULL,\n-    bfminexc = NULL, bfmaxexc = NULL;\n-    int res; \/* err = 0, fixedErr; *\/\n-\n-    \/*\n-    * SPEC st-restrict-facets 1:\n-    * \"The {variety} of R is the same as that of B.\"\n-    *\/\n-    \/*\n-    * SPEC st-restrict-facets 2:\n-    * \"If {variety} is atomic, the {primitive type definition}\n-    * of R is the same as that of B.\"\n-    *\n-    * NOTE: we leave 1 & 2 out for now, since this will be\n-    * satisfied by the derivation process.\n-    * CONSTRUCTION TODO: Maybe needed if using a construction API.\n-    *\/\n-    \/*\n-    * SPEC st-restrict-facets 3:\n-    * \"The {facets} of R are the union of S and the {facets}\n-    * of B, eliminating duplicates. To eliminate duplicates,\n-    * when a facet of the same kind occurs in both S and the\n-    * {facets} of B, the one in the {facets} of B is not\n-    * included, with the exception of enumeration and pattern\n-    * facets, for which multiple occurrences with distinct values\n-    * are allowed.\"\n-    *\/\n-\n-    if ((type->facetSet == NULL) && (base->facetSet == NULL))\n-    return (0);\n-\n-    last = type->facetSet;\n-    if (last != NULL)\n-    while (last->next != NULL)\n-        last = last->next;\n-\n-    for (cur = type->facetSet; cur != NULL; cur = cur->next) {\n-    facet = cur->facet;\n-    switch (facet->type) {\n-        case XML_SCHEMA_FACET_LENGTH:\n-        flength = facet; break;\n-        case XML_SCHEMA_FACET_MINLENGTH:\n-        fminlen = facet; break;\n-        case XML_SCHEMA_FACET_MININCLUSIVE:\n-        fmininc = facet; break;\n-        case XML_SCHEMA_FACET_MINEXCLUSIVE:\n-        fminexc = facet; break;\n-        case XML_SCHEMA_FACET_MAXLENGTH:\n-        fmaxlen = facet; break;\n-        case XML_SCHEMA_FACET_MAXINCLUSIVE:\n-        fmaxinc = facet; break;\n-        case XML_SCHEMA_FACET_MAXEXCLUSIVE:\n-        fmaxexc = facet; break;\n-        case XML_SCHEMA_FACET_TOTALDIGITS:\n-        ftotdig = facet; break;\n-        case XML_SCHEMA_FACET_FRACTIONDIGITS:\n-        ffracdig = facet; break;\n-        default:\n-        break;\n-    }\n-    }\n-    for (cur = base->facetSet; cur != NULL; cur = cur->next) {\n-    facet = cur->facet;\n-    switch (facet->type) {\n-        case XML_SCHEMA_FACET_LENGTH:\n-        bflength = facet; break;\n-        case XML_SCHEMA_FACET_MINLENGTH:\n-        bfminlen = facet; break;\n-        case XML_SCHEMA_FACET_MININCLUSIVE:\n-        bfmininc = facet; break;\n-        case XML_SCHEMA_FACET_MINEXCLUSIVE:\n-        bfminexc = facet; break;\n-        case XML_SCHEMA_FACET_MAXLENGTH:\n-        bfmaxlen = facet; break;\n-        case XML_SCHEMA_FACET_MAXINCLUSIVE:\n-        bfmaxinc = facet; break;\n-        case XML_SCHEMA_FACET_MAXEXCLUSIVE:\n-        bfmaxexc = facet; break;\n-        case XML_SCHEMA_FACET_TOTALDIGITS:\n-        bftotdig = facet; break;\n-        case XML_SCHEMA_FACET_FRACTIONDIGITS:\n-        bffracdig = facet; break;\n-        default:\n-        break;\n-    }\n-    }\n-    \/*\n-    * length and minLength or maxLength (2.2) + (3.2)\n-    *\/\n-    if (flength && (fminlen || fmaxlen)) {\n-    FACET_RESTR_ERR(flength, \"It is an error for both 'length' and \"\n-        \"either of 'minLength' or 'maxLength' to be specified on \"\n-        \"the same type definition\")\n-    }\n-    \/*\n-    * Mutual exclusions in the same derivation step.\n-    *\/\n-    if ((fmaxinc) && (fmaxexc)) {\n-    \/*\n-    * SCC \"maxInclusive and maxExclusive\"\n-    *\/\n-    FACET_RESTR_MUTUAL_ERR(fmaxinc, fmaxexc)\n-    }\n-    if ((fmininc) && (fminexc)) {\n-    \/*\n-    * SCC \"minInclusive and minExclusive\"\n-    *\/\n-    FACET_RESTR_MUTUAL_ERR(fmininc, fminexc)\n-    }\n-\n-    if (flength && bflength) {\n-    \/*\n-    * SCC \"length valid restriction\"\n-    * The values have to be equal.\n-    *\/\n-    res = xmlSchemaCompareValues(flength->val, bflength->val);\n-    if (res == -2)\n-        goto internal_error;\n-    if (res != 0)\n-        xmlSchemaDeriveFacetErr(pctxt, flength, bflength, 0, 0, 1);\n-    if ((res != 0) && (bflength->fixed)) {\n-        FACET_RESTR_FIXED_ERR(flength)\n-    }\n-\n-    }\n-    if (fminlen && bfminlen) {\n-    \/*\n-    * SCC \"minLength valid restriction\"\n-    * minLength >= BASE minLength\n-    *\/\n-    res = xmlSchemaCompareValues(fminlen->val, bfminlen->val);\n-    if (res == -2)\n-        goto internal_error;\n-    if (res == -1)\n-        xmlSchemaDeriveFacetErr(pctxt, fminlen, bfminlen, 1, 1, 1);\n-    if ((res != 0) && (bfminlen->fixed)) {\n-        FACET_RESTR_FIXED_ERR(fminlen)\n-    }\n-    }\n-    if (fmaxlen && bfmaxlen) {\n-    \/*\n-    * SCC \"maxLength valid restriction\"\n-    * maxLength <= BASE minLength\n-    *\/\n-    res = xmlSchemaCompareValues(fmaxlen->val, bfmaxlen->val);\n-    if (res == -2)\n-        goto internal_error;\n-    if (res == 1)\n-        xmlSchemaDeriveFacetErr(pctxt, fmaxlen, bfmaxlen, -1, 1, 1);\n-    if ((res != 0) && (bfmaxlen->fixed)) {\n-        FACET_RESTR_FIXED_ERR(fmaxlen)\n-    }\n-    }\n-    \/*\n-    * SCC \"length and minLength or maxLength\"\n-    *\/\n-    if (! flength)\n-    flength = bflength;\n-    if (flength) {\n-    if (! fminlen)\n-        fminlen = bfminlen;\n-    if (fminlen) {\n-        \/* (1.1) length >= minLength *\/\n-        res = xmlSchemaCompareValues(flength->val, fminlen->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res == -1)\n-        xmlSchemaDeriveFacetErr(pctxt, flength, fminlen, 1, 1, 0);\n-    }\n-    if (! fmaxlen)\n-        fmaxlen = bfmaxlen;\n-    if (fmaxlen) {\n-        \/* (2.1) length <= maxLength *\/\n-        res = xmlSchemaCompareValues(flength->val, fmaxlen->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res == 1)\n-        xmlSchemaDeriveFacetErr(pctxt, flength, fmaxlen, -1, 1, 0);\n-    }\n-    }\n-    if (fmaxinc) {\n-    \/*\n-    * \"maxInclusive\"\n-    *\/\n-    if (fmininc) {\n-        \/* SCC \"maxInclusive >= minInclusive\" *\/\n-        res = xmlSchemaCompareValues(fmaxinc->val, fmininc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res == -1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fmaxinc, fmininc, 1, 1, 0);\n-        }\n-    }\n-    \/*\n-    * SCC \"maxInclusive valid restriction\"\n-    *\/\n-    if (bfmaxinc) {\n-        \/* maxInclusive <= BASE maxInclusive *\/\n-        res = xmlSchemaCompareValues(fmaxinc->val, bfmaxinc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res == 1)\n-        xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfmaxinc, -1, 1, 1);\n-        if ((res != 0) && (bfmaxinc->fixed)) {\n-        FACET_RESTR_FIXED_ERR(fmaxinc)\n-        }\n-    }\n-    if (bfmaxexc) {\n-        \/* maxInclusive < BASE maxExclusive *\/\n-        res = xmlSchemaCompareValues(fmaxinc->val, bfmaxexc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res != -1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfmaxexc, -1, 0, 1);\n-        }\n-    }\n-    if (bfmininc) {\n-        \/* maxInclusive >= BASE minInclusive *\/\n-        res = xmlSchemaCompareValues(fmaxinc->val, bfmininc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res == -1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfmininc, 1, 1, 1);\n-        }\n-    }\n-    if (bfminexc) {\n-        \/* maxInclusive > BASE minExclusive *\/\n-        res = xmlSchemaCompareValues(fmaxinc->val, bfminexc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res != 1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fmaxinc, bfminexc, 1, 0, 1);\n-        }\n-    }\n-    }\n-    if (fmaxexc) {\n-    \/*\n-    * \"maxExclusive >= minExclusive\"\n-    *\/\n-    if (fminexc) {\n-        res = xmlSchemaCompareValues(fmaxexc->val, fminexc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res == -1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fmaxexc, fminexc, 1, 1, 0);\n-        }\n-    }\n-    \/*\n-    * \"maxExclusive valid restriction\"\n-    *\/\n-    if (bfmaxexc) {\n-        \/* maxExclusive <= BASE maxExclusive *\/\n-        res = xmlSchemaCompareValues(fmaxexc->val, bfmaxexc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res == 1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfmaxexc, -1, 1, 1);\n-        }\n-        if ((res != 0) && (bfmaxexc->fixed)) {\n-        FACET_RESTR_FIXED_ERR(fmaxexc)\n-        }\n-    }\n-    if (bfmaxinc) {\n-        \/* maxExclusive <= BASE maxInclusive *\/\n-        res = xmlSchemaCompareValues(fmaxexc->val, bfmaxinc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res == 1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfmaxinc, -1, 1, 1);\n-        }\n-    }\n-    if (bfmininc) {\n-        \/* maxExclusive > BASE minInclusive *\/\n-        res = xmlSchemaCompareValues(fmaxexc->val, bfmininc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res != 1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfmininc, 1, 0, 1);\n-        }\n-    }\n-    if (bfminexc) {\n-        \/* maxExclusive > BASE minExclusive *\/\n-        res = xmlSchemaCompareValues(fmaxexc->val, bfminexc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res != 1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fmaxexc, bfminexc, 1, 0, 1);\n-        }\n-    }\n-    }\n-    if (fminexc) {\n-    \/*\n-    * \"minExclusive < maxInclusive\"\n-    *\/\n-    if (fmaxinc) {\n-        res = xmlSchemaCompareValues(fminexc->val, fmaxinc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res != -1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fminexc, fmaxinc, -1, 0, 0);\n-        }\n-    }\n-    \/*\n-    * \"minExclusive valid restriction\"\n-    *\/\n-    if (bfminexc) {\n-        \/* minExclusive >= BASE minExclusive *\/\n-        res = xmlSchemaCompareValues(fminexc->val, bfminexc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res == -1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fminexc, bfminexc, 1, 1, 1);\n-        }\n-        if ((res != 0) && (bfminexc->fixed)) {\n-        FACET_RESTR_FIXED_ERR(fminexc)\n-        }\n-    }\n-    if (bfmaxinc) {\n-        \/* minExclusive <= BASE maxInclusive *\/\n-        res = xmlSchemaCompareValues(fminexc->val, bfmaxinc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res == 1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fminexc, bfmaxinc, -1, 1, 1);\n-        }\n-    }\n-    if (bfmininc) {\n-        \/* minExclusive >= BASE minInclusive *\/\n-        res = xmlSchemaCompareValues(fminexc->val, bfmininc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res == -1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fminexc, bfmininc, 1, 1, 1);\n-        }\n-    }\n-    if (bfmaxexc) {\n-        \/* minExclusive < BASE maxExclusive *\/\n-        res = xmlSchemaCompareValues(fminexc->val, bfmaxexc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res != -1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fminexc, bfmaxexc, -1, 0, 1);\n-        }\n-    }\n-    }\n-    if (fmininc) {\n-    \/*\n-    * \"minInclusive < maxExclusive\"\n-    *\/\n-    if (fmaxexc) {\n-        res = xmlSchemaCompareValues(fmininc->val, fmaxexc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res != -1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fmininc, fmaxexc, -1, 0, 0);\n-        }\n-    }\n-    \/*\n-    * \"minExclusive valid restriction\"\n-    *\/\n-    if (bfmininc) {\n-        \/* minInclusive >= BASE minInclusive *\/\n-        res = xmlSchemaCompareValues(fmininc->val, bfmininc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res == -1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fmininc, bfmininc, 1, 1, 1);\n-        }\n-        if ((res != 0) && (bfmininc->fixed)) {\n-        FACET_RESTR_FIXED_ERR(fmininc)\n-        }\n-    }\n-    if (bfmaxinc) {\n-        \/* minInclusive <= BASE maxInclusive *\/\n-        res = xmlSchemaCompareValues(fmininc->val, bfmaxinc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res == 1) {\n-        xmlSchemaDeriveFacetErr(pctxt, fmininc, bfmaxinc, -1, 1, 1);\n-        }\n-    }\n-    if (bfminexc) {\n-        \/* minInclusive > BASE minExclusive *\/\n-        res = xmlSchemaCompareValues(fmininc->val, bfminexc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res != 1)\n-        xmlSchemaDeriveFacetErr(pctxt, fmininc, bfminexc, 1, 0, 1);\n-    }\n-    if (bfmaxexc) {\n-        \/* minInclusive < BASE maxExclusive *\/\n-        res = xmlSchemaCompareValues(fmininc->val, bfmaxexc->val);\n-        if (res == -2)\n-        goto internal_error;\n-        if (res != -1)\n-        xmlSchemaDeriveFacetErr(pctxt, fmininc, bfmaxexc, -1, 0, 1);\n-    }\n-    }\n-    if (ftotdig && bftotdig) {\n-    \/*\n-    * SCC \" totalDigits valid restriction\"\n-    * totalDigits <= BASE totalDigits\n-    *\/\n-    res = xmlSchemaCompareValues(ftotdig->val, bftotdig->val);\n-    if (res == -2)\n-        goto internal_error;\n-    if (res == 1)\n-        xmlSchemaDeriveFacetErr(pctxt, ftotdig, bftotdig,\n-        -1, 1, 1);\n-    if ((res != 0) && (bftotdig->fixed)) {\n-        FACET_RESTR_FIXED_ERR(ftotdig)\n-    }\n-    }\n-    if (ffracdig && bffracdig) {\n-    \/*\n-    * SCC  \"fractionDigits valid restriction\"\n-    * fractionDigits <= BASE fractionDigits\n-    *\/\n-    res = xmlSchemaCompareValues(ffracdig->val, bffracdig->val);\n-    if (res == -2)\n-        goto internal_error;\n-    if (res == 1)\n-        xmlSchemaDeriveFacetErr(pctxt, ffracdig, bffracdig,\n-        -1, 1, 1);\n-    if ((res != 0) && (bffracdig->fixed)) {\n-        FACET_RESTR_FIXED_ERR(ffracdig)\n-    }\n-    }\n-    \/*\n-    * SCC \"fractionDigits less than or equal to totalDigits\"\n-    *\/\n-    if (! ftotdig)\n-    ftotdig = bftotdig;\n-    if (! ffracdig)\n-    ffracdig = bffracdig;\n-    if (ftotdig && ffracdig) {\n-    res = xmlSchemaCompareValues(ffracdig->val, ftotdig->val);\n-    if (res == -2)\n-        goto internal_error;\n-    if (res == 1)\n-        xmlSchemaDeriveFacetErr(pctxt, ffracdig, ftotdig,\n-        -1, 1, 0);\n-    }\n-    \/*\n-    * *Enumerations* won' be added here, since only the first set\n-    * of enumerations in the ancestor-or-self axis is used\n-    * for validation, plus we need to use the base type of those\n-    * enumerations for whitespace.\n-    *\n-    * *Patterns*: won't be add here, since they are ORed at\n-    * type level and ANDed at ancestor level. This will\n-    * happen during validation by walking the base axis\n-    * of the type.\n-    *\/\n-    for (cur = base->facetSet; cur != NULL; cur = cur->next) {\n-    bfacet = cur->facet;\n-    \/*\n-    * Special handling of enumerations and patterns.\n-    * TODO: hmm, they should not appear in the set, so remove this.\n-    *\/\n-    if ((bfacet->type == XML_SCHEMA_FACET_PATTERN) ||\n-        (bfacet->type == XML_SCHEMA_FACET_ENUMERATION))\n-        continue;\n-    \/*\n-    * Search for a duplicate facet in the current type.\n-    *\/\n-    link = type->facetSet;\n-    \/* err = 0; *\/\n-    \/* fixedErr = 0; *\/\n-    while (link != NULL) {\n-        facet = link->facet;\n-        if (facet->type == bfacet->type) {\n-        switch (facet->type) {\n-            case XML_SCHEMA_FACET_WHITESPACE:\n-            \/*\n-            * The whitespace must be stronger.\n-            *\/\n-            if (facet->whitespace < bfacet->whitespace) {\n-                FACET_RESTR_ERR(facet,\n-                \"The 'whitespace' value has to be equal to \"\n-                \"or stronger than the 'whitespace' value of \"\n-                \"the base type\")\n-            }\n-            if ((bfacet->fixed) &&\n-                (facet->whitespace != bfacet->whitespace)) {\n-                FACET_RESTR_FIXED_ERR(facet)\n-            }\n-            break;\n-            default:\n-            break;\n-        }\n-        \/* Duplicate found. *\/\n-        break;\n-        }\n-        link = link->next;\n-    }\n-    \/*\n-    * If no duplicate was found: add the base types's facet\n-    * to the set.\n-    *\/\n-    if (link == NULL) {\n-        link = (xmlSchemaFacetLinkPtr)\n-        xmlMalloc(sizeof(xmlSchemaFacetLink));\n-        if (link == NULL) {\n-        xmlSchemaPErrMemory(pctxt);\n-        return (-1);\n-        }\n-        link->facet = cur->facet;\n-        link->next = NULL;\n-        if (last == NULL)\n-        type->facetSet = link;\n-        else\n-        last->next = link;\n-        last = link;\n-    }\n-\n-    }\n-\n-    return (0);\n-internal_error:\n-    PERROR_INT(\"xmlSchemaDeriveAndValidateFacets\",\n-    \"an error occurred\");\n-    return (-1);\n-}\n-\n-static int\n-xmlSchemaFinishMemberTypeDefinitionsProperty(xmlSchemaParserCtxtPtr pctxt,\n-                         xmlSchemaTypePtr type)\n-{\n-    xmlSchemaTypeLinkPtr link, lastLink, prevLink, subLink, newLink;\n-    \/*\n-    * The actual value is then formed by replacing any union type\n-    * definition in the `explicit members` with the members of their\n-    * {member type definitions}, in order.\n-    *\n-    * TODO: There's a bug entry at\n-    * \"http:\/\/lists.w3.org\/Archives\/Public\/www-xml-schema-comments\/2005JulSep\/0287.html\"\n-    * which indicates that we'll keep the union types the future.\n-    *\/\n-    link = type->memberTypes;\n-    while (link != NULL) {\n-\n-    if (WXS_IS_TYPE_NOT_FIXED(link->type))\n-        xmlSchemaTypeFixup(link->type, ACTXT_CAST pctxt);\n-\n-    if (WXS_IS_UNION(link->type)) {\n-        subLink = xmlSchemaGetUnionSimpleTypeMemberTypes(link->type);\n-        if (subLink != NULL) {\n-        link->type = subLink->type;\n-        if (subLink->next != NULL) {\n-            lastLink = link->next;\n-            subLink = subLink->next;\n-            prevLink = link;\n-            while (subLink != NULL) {\n-            newLink = (xmlSchemaTypeLinkPtr)\n-                xmlMalloc(sizeof(xmlSchemaTypeLink));\n-            if (newLink == NULL) {\n-                xmlSchemaPErrMemory(pctxt);\n-                return (-1);\n-            }\n-            newLink->type = subLink->type;\n-            prevLink->next = newLink;\n-            prevLink = newLink;\n-            newLink->next = lastLink;\n-\n-            subLink = subLink->next;\n-            }\n-        }\n-        }\n-    }\n-    link = link->next;\n-    }\n-    return (0);\n-}\n-\n-static void\n-xmlSchemaTypeFixupOptimFacets(xmlSchemaTypePtr type)\n-{\n-    int has = 0, needVal = 0, normVal = 0;\n-\n-    has    = (type->baseType->flags & XML_SCHEMAS_TYPE_HAS_FACETS) ? 1 : 0;\n-    if (has) {\n-    needVal = (type->baseType->flags &\n-        XML_SCHEMAS_TYPE_FACETSNEEDVALUE) ? 1 : 0;\n-    normVal = (type->baseType->flags &\n-        XML_SCHEMAS_TYPE_NORMVALUENEEDED) ? 1 : 0;\n-    }\n-    if (type->facets != NULL) {\n-    xmlSchemaFacetPtr fac;\n-\n-    for (fac = type->facets; fac != NULL; fac = fac->next) {\n-        switch (fac->type) {\n-        case XML_SCHEMA_FACET_WHITESPACE:\n-            break;\n-        case XML_SCHEMA_FACET_PATTERN:\n-            normVal = 1;\n-            has = 1;\n-            break;\n-        case XML_SCHEMA_FACET_ENUMERATION:\n-            needVal = 1;\n-            normVal = 1;\n-            has = 1;\n-            break;\n-        default:\n-            has = 1;\n-            break;\n-        }\n-    }\n-    }\n-    if (normVal)\n-    type->flags |= XML_SCHEMAS_TYPE_NORMVALUENEEDED;\n-    if (needVal)\n-    type->flags |= XML_SCHEMAS_TYPE_FACETSNEEDVALUE;\n-    if (has)\n-    type->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;\n-\n-    if (has && (! needVal) && WXS_IS_ATOMIC(type)) {\n-    xmlSchemaTypePtr prim = xmlSchemaGetPrimitiveType(type);\n-    \/*\n-    * OPTIMIZE VAL TODO: Some facets need a computed value.\n-    *\/\n-    if ((prim->builtInType != XML_SCHEMAS_ANYSIMPLETYPE) &&\n-        (prim->builtInType != XML_SCHEMAS_STRING)) {\n-        type->flags |= XML_SCHEMAS_TYPE_FACETSNEEDVALUE;\n-    }\n-    }\n-}\n-\n-static int\n-xmlSchemaTypeFixupWhitespace(xmlSchemaTypePtr type)\n-{\n-\n-\n-    \/*\n-    * Evaluate the whitespace-facet value.\n-    *\/\n-    if (WXS_IS_LIST(type)) {\n-    type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;\n-    return (0);\n-    } else if (WXS_IS_UNION(type))\n-    return (0);\n-\n-    if (type->facetSet != NULL) {\n-    xmlSchemaFacetLinkPtr lin;\n-\n-    for (lin = type->facetSet; lin != NULL; lin = lin->next) {\n-        if (lin->facet->type == XML_SCHEMA_FACET_WHITESPACE) {\n-        switch (lin->facet->whitespace) {\n-        case XML_SCHEMAS_FACET_PRESERVE:\n-            type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE;\n-            break;\n-        case XML_SCHEMAS_FACET_REPLACE:\n-            type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_REPLACE;\n-            break;\n-        case XML_SCHEMAS_FACET_COLLAPSE:\n-            type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;\n-            break;\n-        default:\n-            return (-1);\n-        }\n-        return (0);\n-        }\n-    }\n-    }\n-    \/*\n-    * For all `atomic` datatypes other than string (and types `derived`\n-    * by `restriction` from it) the value of whiteSpace is fixed to\n-    * collapse\n-    *\/\n-    {\n-    xmlSchemaTypePtr anc;\n-\n-    for (anc = type->baseType; anc != NULL &&\n-        anc->builtInType != XML_SCHEMAS_ANYTYPE;\n-        anc = anc->baseType) {\n-\n-        if (anc->type == XML_SCHEMA_TYPE_BASIC) {\n-        if (anc->builtInType == XML_SCHEMAS_NORMSTRING) {\n-            type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_REPLACE;\n-\n-        } else if ((anc->builtInType == XML_SCHEMAS_STRING) ||\n-            (anc->builtInType == XML_SCHEMAS_ANYSIMPLETYPE)) {\n-            type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE;\n-\n-        } else\n-            type->flags |= XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE;\n-        break;\n-        }\n-    }\n-    }\n-    return (0);\n-}\n-\n-static int\n-xmlSchemaFixupSimpleTypeStageOne(xmlSchemaParserCtxtPtr pctxt,\n-              xmlSchemaTypePtr type)\n-{\n-    if (type->type != XML_SCHEMA_TYPE_SIMPLE)\n-    return(0);\n-    if (! WXS_IS_TYPE_NOT_FIXED_1(type))\n-    return(0);\n-    type->flags |= XML_SCHEMAS_TYPE_FIXUP_1;\n-\n-    if (WXS_IS_LIST(type)) {\n-    \/*\n-    * Corresponds to <simpleType><list>...\n-    *\/\n-    if (type->subtypes == NULL) {\n-        \/*\n-        * This one is really needed, so get out.\n-        *\/\n-        PERROR_INT(\"xmlSchemaFixupSimpleTypeStageOne\",\n-        \"list type has no item-type assigned\");\n-        return(-1);\n-    }\n-    } else if (WXS_IS_UNION(type)) {\n-    \/*\n-    * Corresponds to <simpleType><union>...\n-    *\/\n-    if (type->memberTypes == NULL) {\n-        \/*\n-        * This one is really needed, so get out.\n-        *\/\n-        PERROR_INT(\"xmlSchemaFixupSimpleTypeStageOne\",\n-        \"union type has no member-types assigned\");\n-        return(-1);\n-    }\n-    } else {\n-    \/*\n-    * Corresponds to <simpleType><restriction>...\n-    *\/\n-    if (type->baseType == NULL) {\n-        PERROR_INT(\"xmlSchemaFixupSimpleTypeStageOne\",\n-        \"type has no base-type assigned\");\n-        return(-1);\n-    }\n-    if (WXS_IS_TYPE_NOT_FIXED_1(type->baseType))\n-        if (xmlSchemaFixupSimpleTypeStageOne(pctxt, type->baseType) == -1)\n-        return(-1);\n-    \/*\n-    * Variety\n-    * If the <restriction> alternative is chosen, then the\n-    * {variety} of the {base type definition}.\n-    *\/\n-    if (WXS_IS_ATOMIC(type->baseType))\n-        type->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;\n-    else if (WXS_IS_LIST(type->baseType)) {\n-        type->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;\n-        \/*\n-        * Inherit the itemType.\n-        *\/\n-        type->subtypes = type->baseType->subtypes;\n-    } else if (WXS_IS_UNION(type->baseType)) {\n-        type->flags |= XML_SCHEMAS_TYPE_VARIETY_UNION;\n-        \/*\n-        * NOTE that we won't assign the memberTypes of the base,\n-        * since this will make trouble when freeing them; we will\n-        * use a lookup function to access them instead.\n-        *\/\n-    }\n-    }\n-    return(0);\n-}\n-\n-\/*\n-* 3.14.6 Constraints on Simple Type Definition Schema Components\n-*\/\n-static int\n-xmlSchemaFixupSimpleTypeStageTwo(xmlSchemaParserCtxtPtr pctxt,\n-                 xmlSchemaTypePtr type)\n-{\n-    int res, olderrs = pctxt->nberrors;\n-\n-    if (type->type != XML_SCHEMA_TYPE_SIMPLE)\n-    return(-1);\n-\n-    if (! WXS_IS_TYPE_NOT_FIXED(type))\n-    return(0);\n-\n-    type->flags |= XML_SCHEMAS_TYPE_INTERNAL_RESOLVED;\n-    type->contentType = XML_SCHEMA_CONTENT_SIMPLE;\n-\n-    if (type->baseType == NULL) {\n-    PERROR_INT(\"xmlSchemaFixupSimpleTypeStageTwo\",\n-        \"missing baseType\");\n-    goto exit_failure;\n-    }\n-    if (WXS_IS_TYPE_NOT_FIXED(type->baseType))\n-    xmlSchemaTypeFixup(type->baseType, ACTXT_CAST pctxt);\n-    \/*\n-    * If a member type of a union is a union itself, we need to substitute\n-    * that member type for its member types.\n-    * NOTE that this might change in WXS 1.1; i.e. we will keep the union\n-    * types in WXS 1.1.\n-    *\/\n-    if ((type->memberTypes != NULL) &&\n-    (xmlSchemaFinishMemberTypeDefinitionsProperty(pctxt, type) == -1))\n-    return(-1);\n-    \/*\n-    * SPEC src-simple-type 1\n-    * \"The corresponding simple type definition, if any, must satisfy\n-    * the conditions set out in Constraints on Simple Type Definition\n-    * Schema Components ($3.14.6).\"\n-    *\/\n-    \/*\n-    * Schema Component Constraint: Simple Type Definition Properties Correct\n-    * (st-props-correct)\n-    *\/\n-    res = xmlSchemaCheckSTPropsCorrect(pctxt, type);\n-    HFAILURE HERROR\n-    \/*\n-    * Schema Component Constraint: Derivation Valid (Restriction, Simple)\n-    * (cos-st-restricts)\n-    *\/\n-    res = xmlSchemaCheckCOSSTRestricts(pctxt, type);\n-    HFAILURE HERROR\n-    \/*\n-    * TODO: Removed the error report, since it got annoying to get an\n-    * extra error report, if anything failed until now.\n-    * Enable this if needed.\n-    *\n-    * xmlSchemaPErr(ctxt, type->node,\n-    *    XML_SCHEMAP_SRC_SIMPLE_TYPE_1,\n-    *    \"Simple type '%s' does not satisfy the constraints \"\n-    *    \"on simple type definitions.\\n\",\n-    *    type->name, NULL);\n-    *\/\n-    \/*\n-    * Schema Component Constraint: Simple Type Restriction (Facets)\n-    * (st-restrict-facets)\n-    *\/\n-    res = xmlSchemaCheckFacetValues(type, pctxt);\n-    HFAILURE HERROR\n-    if ((type->facetSet != NULL) ||\n-    (type->baseType->facetSet != NULL)) {\n-    res = xmlSchemaDeriveAndValidateFacets(pctxt, type);\n-    HFAILURE HERROR\n-    }\n-    \/*\n-    * Whitespace value.\n-    *\/\n-    res = xmlSchemaTypeFixupWhitespace(type);\n-    HFAILURE HERROR\n-    xmlSchemaTypeFixupOptimFacets(type);\n-\n-exit_error:\n-    if (olderrs != pctxt->nberrors)\n-    return(pctxt->err);\n-    return(0);\n-\n-exit_failure:\n-    return(-1);\n-}\n-\n-static int\n-xmlSchemaFixupComplexType(xmlSchemaParserCtxtPtr pctxt,\n-              xmlSchemaTypePtr type)\n-{\n-    int res = 0, olderrs = pctxt->nberrors;\n-    xmlSchemaTypePtr baseType = type->baseType;\n-\n-    if (! WXS_IS_TYPE_NOT_FIXED(type))\n-    return(0);\n-    type->flags |= XML_SCHEMAS_TYPE_INTERNAL_RESOLVED;\n-    if (baseType == NULL) {\n-    PERROR_INT(\"xmlSchemaFixupComplexType\",\n-        \"missing baseType\");\n-    goto exit_failure;\n-    }\n-    \/*\n-    * Fixup the base type.\n-    *\/\n-    if (WXS_IS_TYPE_NOT_FIXED(baseType))\n-    xmlSchemaTypeFixup(baseType, ACTXT_CAST pctxt);\n-    if (baseType->flags & XML_SCHEMAS_TYPE_INTERNAL_INVALID) {\n-    \/*\n-    * Skip fixup if the base type is invalid.\n-    * TODO: Generate a warning!\n-    *\/\n-    return(0);\n-    }\n-    \/*\n-    * This basically checks if the base type can be derived.\n-    *\/\n-    res = xmlSchemaCheckSRCCT(pctxt, type);\n-    HFAILURE HERROR\n-    \/*\n-    * Fixup the content type.\n-    *\/\n-    if (type->contentType == XML_SCHEMA_CONTENT_SIMPLE) {\n-    \/*\n-    * Corresponds to <complexType><simpleContent>...\n-    *\/\n-    if ((WXS_IS_COMPLEX(baseType)) &&\n-        (baseType->contentTypeDef != NULL) &&\n-        (WXS_IS_RESTRICTION(type))) {\n-        xmlSchemaTypePtr contentBase, content;\n-#ifdef ENABLE_NAMED_LOCALS\n-        char buf[30];\n-        const xmlChar *tmpname;\n-#endif\n-        \/*\n-        * SPEC (1) If <restriction> + base type is <complexType>,\n-        * \"whose own {content type} is a simple type...\"\n-        *\/\n-        if (type->contentTypeDef != NULL) {\n-        \/*\n-        * SPEC (1.1) \"the simple type definition corresponding to the\n-        * <simpleType> among the [children] of <restriction> if there\n-        * is one;\"\n-        * Note that this \"<simpleType> among the [children]\" was put\n-        * into ->contentTypeDef during parsing.\n-        *\/\n-        contentBase = type->contentTypeDef;\n-        type->contentTypeDef = NULL;\n-        } else {\n-        \/*\n-        * (1.2) \"...otherwise (<restriction> has no <simpleType>\n-        * among its [children]), the simple type definition which\n-        * is the {content type} of the ... base type.\"\n-        *\/\n-        contentBase = baseType->contentTypeDef;\n-        }\n-        \/*\n-        * SPEC\n-        * \"... a simple type definition which restricts the simple\n-        * type definition identified in clause 1.1 or clause 1.2\n-        * with a set of facet components\"\n-        *\n-        * Create the anonymous simple type, which will be the content\n-        * type of the complex type.\n-        *\/\n-#ifdef ENABLE_NAMED_LOCALS\n-        snprintf(buf, 29, \"#scST%d\", ++(pctxt->counter));\n-        tmpname = xmlDictLookup(pctxt->dict, BAD_CAST buf, -1);\n-        content = xmlSchemaAddType(pctxt, pctxt->schema,\n-        XML_SCHEMA_TYPE_SIMPLE, tmpname, type->targetNamespace,\n-        type->node, 0);\n-#else\n-        content = xmlSchemaAddType(pctxt, pctxt->schema,\n-        XML_SCHEMA_TYPE_SIMPLE, NULL, type->targetNamespace,\n-        type->node, 0);\n-#endif\n-        if (content == NULL)\n-        goto exit_failure;\n-        \/*\n-        * We will use the same node as for the <complexType>\n-        * to have it somehow anchored in the schema doc.\n-        *\/\n-        content->type = XML_SCHEMA_TYPE_SIMPLE;\n-        content->baseType = contentBase;\n-        \/*\n-        * Move the facets, previously anchored on the\n-        * complexType during parsing.\n-        *\/\n-        content->facets = type->facets;\n-        type->facets = NULL;\n-        content->facetSet = type->facetSet;\n-        type->facetSet = NULL;\n-\n-        type->contentTypeDef = content;\n-        if (WXS_IS_TYPE_NOT_FIXED(contentBase))\n-        xmlSchemaTypeFixup(contentBase, ACTXT_CAST pctxt);\n-        \/*\n-        * Fixup the newly created type. We don't need to check\n-        * for circularity here.\n-        *\/\n-        res = xmlSchemaFixupSimpleTypeStageOne(pctxt, content);\n-        HFAILURE HERROR\n-        res = xmlSchemaFixupSimpleTypeStageTwo(pctxt, content);\n-        HFAILURE HERROR\n-\n-    } else if ((WXS_IS_COMPLEX(baseType)) &&\n-        (baseType->contentType == XML_SCHEMA_CONTENT_MIXED) &&\n-        (WXS_IS_RESTRICTION(type))) {\n-        \/*\n-        * SPEC (2) If <restriction> + base is a mixed <complexType> with\n-        * an emptiable particle, then a simple type definition which\n-        * restricts the <restriction>'s <simpleType> child.\n-        *\/\n-        if ((type->contentTypeDef == NULL) ||\n-        (type->contentTypeDef->baseType == NULL)) {\n-        \/*\n-        * TODO: Check if this ever happens.\n-        *\/\n-        xmlSchemaPCustomErr(pctxt,\n-            XML_SCHEMAP_INTERNAL,\n-            WXS_BASIC_CAST type, NULL,\n-            \"Internal error: xmlSchemaTypeFixup, \"\n-            \"complex type '%s': the <simpleContent><restriction> \"\n-            \"is missing a <simpleType> child, but was not caught \"\n-            \"by xmlSchemaCheckSRCCT()\", type->name);\n-        goto exit_failure;\n-        }\n-    } else if ((WXS_IS_COMPLEX(baseType)) && WXS_IS_EXTENSION(type)) {\n-        \/*\n-        * SPEC (3) If <extension> + base is <complexType> with\n-        * <simpleType> content, \"...then the {content type} of that\n-        * complex type definition\"\n-        *\/\n-        if (baseType->contentTypeDef == NULL) {\n-        \/*\n-        * TODO: Check if this ever happens. xmlSchemaCheckSRCCT\n-        * should have caught this already.\n-        *\/\n-        xmlSchemaPCustomErr(pctxt,\n-            XML_SCHEMAP_INTERNAL,\n-            WXS_BASIC_CAST type, NULL,\n-            \"Internal error: xmlSchemaTypeFixup, \"\n-            \"complex type '%s': the <extension>ed base type is \"\n-            \"a complex type with no simple content type\",\n-            type->name);\n-        goto exit_failure;\n-        }\n-        type->contentTypeDef = baseType->contentTypeDef;\n-    } else if ((WXS_IS_SIMPLE(baseType)) && WXS_IS_EXTENSION(type)) {\n-        \/*\n-        * SPEC (4) <extension> + base is <simpleType>\n-        * \"... then that simple type definition\"\n-        *\/\n-        type->contentTypeDef = baseType;\n-    } else {\n-        \/*\n-        * TODO: Check if this ever happens.\n-        *\/\n-        xmlSchemaPCustomErr(pctxt,\n-        XML_SCHEMAP_INTERNAL,\n-        WXS_BASIC_CAST type, NULL,\n-        \"Internal error: xmlSchemaTypeFixup, \"\n-        \"complex type '%s' with <simpleContent>: unhandled \"\n-        \"derivation case\", type->name);\n-        goto exit_failure;\n-    }\n-    } else {\n-    int dummySequence = 0;\n-    xmlSchemaParticlePtr particle =\n-        (xmlSchemaParticlePtr) type->subtypes;\n-    \/*\n-    * Corresponds to <complexType><complexContent>...\n-    *\n-    * NOTE that the effective mixed was already set during parsing of\n-    * <complexType> and <complexContent>; its flag value is\n-    * XML_SCHEMAS_TYPE_MIXED.\n-    *\n-    * Compute the \"effective content\":\n-    * (2.1.1) + (2.1.2) + (2.1.3)\n-    *\/\n-    if ((particle == NULL) ||\n-        ((particle->type == XML_SCHEMA_TYPE_PARTICLE) &&\n-        ((particle->children->type == XML_SCHEMA_TYPE_ALL) ||\n-        (particle->children->type == XML_SCHEMA_TYPE_SEQUENCE) ||\n-        ((particle->children->type == XML_SCHEMA_TYPE_CHOICE) &&\n-        (particle->minOccurs == 0))) &&\n-        ( ((xmlSchemaTreeItemPtr) particle->children)->children == NULL))) {\n-        if (type->flags & XML_SCHEMAS_TYPE_MIXED) {\n-        \/*\n-        * SPEC (2.1.4) \"If the `effective mixed` is true, then\n-        * a particle whose properties are as follows:...\"\n-        *\n-        * Empty sequence model group with\n-        * minOccurs\/maxOccurs = 1 (i.e. a \"particle emptiable\").\n-        * NOTE that we sill assign it the <complexType> node to\n-        * somehow anchor it in the doc.\n-        *\/\n-        if ((particle == NULL) ||\n-            (particle->children->type != XML_SCHEMA_TYPE_SEQUENCE)) {\n-            \/*\n-            * Create the particle.\n-            *\/\n-            particle = xmlSchemaAddParticle(pctxt,\n-            type->node, 1, 1);\n-            if (particle == NULL)\n-            goto exit_failure;\n-            \/*\n-            * Create the model group.\n-            *\/ \/* URGENT TODO: avoid adding to pending items. *\/\n-            particle->children = (xmlSchemaTreeItemPtr)\n-            xmlSchemaAddModelGroup(pctxt, pctxt->schema,\n-            XML_SCHEMA_TYPE_SEQUENCE, type->node);\n-            if (particle->children == NULL)\n-            goto exit_failure;\n-\n-            type->subtypes = (xmlSchemaTypePtr) particle;\n-        }\n-        dummySequence = 1;\n-        type->contentType = XML_SCHEMA_CONTENT_ELEMENTS;\n-        } else {\n-        \/*\n-        * SPEC (2.1.5) \"otherwise empty\"\n-        *\/\n-        type->contentType = XML_SCHEMA_CONTENT_EMPTY;\n-        }\n-    } else {\n-        \/*\n-        * SPEC (2.2) \"otherwise the particle corresponding to the\n-        * <all>, <choice>, <group> or <sequence> among the\n-        * [children].\"\n-        *\/\n-        type->contentType = XML_SCHEMA_CONTENT_ELEMENTS;\n-    }\n-    \/*\n-    * Compute the \"content type\".\n-    *\/\n-    if (WXS_IS_RESTRICTION(type)) {\n-        \/*\n-        * SPEC (3.1) \"If <restriction>...\"\n-        * (3.1.1) + (3.1.2) *\/\n-        if (type->contentType != XML_SCHEMA_CONTENT_EMPTY) {\n-        if (type->flags & XML_SCHEMAS_TYPE_MIXED)\n-            type->contentType = XML_SCHEMA_CONTENT_MIXED;\n-        }\n-    } else {\n-        \/*\n-        * SPEC (3.2) \"If <extension>...\"\n-        *\/\n-        if (type->contentType == XML_SCHEMA_CONTENT_EMPTY) {\n-        \/*\n-        * SPEC (3.2.1)\n-        * \"If the `effective content` is empty, then the\n-        *  {content type} of the [...] base ...\"\n-        *\/\n-        type->contentType = baseType->contentType;\n-        type->subtypes = baseType->subtypes;\n-        \/*\n-        * Fixes bug #347316:\n-        * This is the case when the base type has a simple\n-        * type definition as content.\n-        *\/\n-        type->contentTypeDef = baseType->contentTypeDef;\n-        \/*\n-        * NOTE that the effective mixed is ignored here.\n-        *\/\n-        } else if (baseType->contentType == XML_SCHEMA_CONTENT_EMPTY) {\n-        \/*\n-        * SPEC (3.2.2)\n-        *\/\n-        if (type->flags & XML_SCHEMAS_TYPE_MIXED)\n-            type->contentType = XML_SCHEMA_CONTENT_MIXED;\n-        } else {\n-        \/*\n-        * SPEC (3.2.3)\n-        *\/\n-        if (type->flags & XML_SCHEMAS_TYPE_MIXED)\n-            type->contentType = XML_SCHEMA_CONTENT_MIXED;\n-            \/*\n-            * \"A model group whose {compositor} is sequence and whose\n-            * {particles} are...\"\n-            *\/\n-        if ((WXS_TYPE_PARTICLE(type) != NULL) &&\n-            (WXS_TYPE_PARTICLE_TERM(type) != NULL) &&\n-            ((WXS_TYPE_PARTICLE_TERM(type))->type ==\n-            XML_SCHEMA_TYPE_ALL))\n-        {\n-            \/*\n-            * SPEC cos-all-limited (1)\n-            *\/\n-            xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-            \/* TODO: error code *\/\n-            XML_SCHEMAP_COS_ALL_LIMITED,\n-            WXS_ITEM_NODE(type), NULL,\n-            \"The type has an 'all' model group in its \"\n-            \"{content type} and thus cannot be derived from \"\n-            \"a non-empty type, since this would produce a \"\n-            \"'sequence' model group containing the 'all' \"\n-            \"model group; 'all' model groups are not \"\n-            \"allowed to appear inside other model groups\",\n-            NULL, NULL);\n-\n-        } else if ((WXS_TYPE_PARTICLE(baseType) != NULL) &&\n-            (WXS_TYPE_PARTICLE_TERM(baseType) != NULL) &&\n-            ((WXS_TYPE_PARTICLE_TERM(baseType))->type ==\n-            XML_SCHEMA_TYPE_ALL))\n-        {\n-            \/*\n-            * SPEC cos-all-limited (1)\n-            *\/\n-            xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-            \/* TODO: error code *\/\n-            XML_SCHEMAP_COS_ALL_LIMITED,\n-            WXS_ITEM_NODE(type), NULL,\n-            \"A type cannot be derived by extension from a type \"\n-            \"which has an 'all' model group in its \"\n-            \"{content type}, since this would produce a \"\n-            \"'sequence' model group containing the 'all' \"\n-            \"model group; 'all' model groups are not \"\n-            \"allowed to appear inside other model groups\",\n-            NULL, NULL);\n-\n-        } else if ((!dummySequence) && (baseType->subtypes != NULL)) {\n-            xmlSchemaTreeItemPtr effectiveContent =\n-            (xmlSchemaTreeItemPtr) type->subtypes;\n-            \/*\n-            * Create the particle.\n-            *\/\n-            particle = xmlSchemaAddParticle(pctxt,\n-            type->node, 1, 1);\n-            if (particle == NULL)\n-            goto exit_failure;\n-            \/*\n-            * Create the \"sequence\" model group.\n-            *\/\n-            particle->children = (xmlSchemaTreeItemPtr)\n-            xmlSchemaAddModelGroup(pctxt, pctxt->schema,\n-            XML_SCHEMA_TYPE_SEQUENCE, type->node);\n-            if (particle->children == NULL)\n-            goto exit_failure;\n-            WXS_TYPE_CONTENTTYPE(type) = (xmlSchemaTypePtr) particle;\n-            \/*\n-            * SPEC \"the particle of the {content type} of\n-            * the ... base ...\"\n-            * Create a duplicate of the base type's particle\n-            * and assign its \"term\" to it.\n-            *\/\n-            particle->children->children =\n-            (xmlSchemaTreeItemPtr) xmlSchemaAddParticle(pctxt,\n-            type->node,\n-            ((xmlSchemaParticlePtr) baseType->subtypes)->minOccurs,\n-            ((xmlSchemaParticlePtr) baseType->subtypes)->maxOccurs);\n-            if (particle->children->children == NULL)\n-            goto exit_failure;\n-            particle = (xmlSchemaParticlePtr)\n-            particle->children->children;\n-            particle->children =\n-            ((xmlSchemaParticlePtr) baseType->subtypes)->children;\n-            \/*\n-            * SPEC \"followed by the `effective content`.\"\n-            *\/\n-            particle->next = effectiveContent;\n-            \/*\n-            * This all will result in:\n-            * new-particle\n-            *   --> new-sequence(\n-            *         new-particle\n-            *           --> base-model,\n-            *         this-particle\n-            *            --> this-model\n-            *        )\n-            *\/\n-        } else {\n-            \/*\n-            * This is the case when there is already an empty\n-            * <sequence> with minOccurs==maxOccurs==1.\n-            * Just add the base types's content type.\n-            * NOTE that, although we miss to add an intermediate\n-            * <sequence>, this should produce no difference to\n-            * neither the regex compilation of the content model,\n-            * nor to the complex type constraints.\n-            *\/\n-            particle->children->children =\n-            (xmlSchemaTreeItemPtr) baseType->subtypes;\n-        }\n-        }\n-    }\n-    }\n-    \/*\n-    * Now fixup attribute uses:\n-    *   - expand attr. group references\n-    *     - intersect attribute wildcards\n-    *   - inherit attribute uses of the base type\n-    *   - inherit or union attr. wildcards if extending\n-    *   - apply attr. use prohibitions if restricting\n-    *\/\n-    res = xmlSchemaFixupTypeAttributeUses(pctxt, type);\n-    HFAILURE HERROR\n-    \/*\n-    * Apply the complex type component constraints; this will not\n-    * check attributes, since this is done in\n-    * xmlSchemaFixupTypeAttributeUses().\n-    *\/\n-    res = xmlSchemaCheckCTComponent(pctxt, type);\n-    HFAILURE HERROR\n-\n-    if (olderrs != pctxt->nberrors)\n-    return(pctxt->err);\n-    else\n-    return(0);\n-\n-exit_error:\n-    type->flags |= XML_SCHEMAS_TYPE_INTERNAL_INVALID;\n-    return(pctxt->err);\n-\n-exit_failure:\n-    type->flags |= XML_SCHEMAS_TYPE_INTERNAL_INVALID;\n-    return(-1);\n-}\n-\n-\n-\/**\n- * xmlSchemaTypeFixup:\n- * @typeDecl:  the schema type definition\n- * @ctxt:  the schema parser context\n- *\n- * Fixes the content model of the type.\n- * URGENT TODO: We need an int result!\n- *\/\n-static int\n-xmlSchemaTypeFixup(xmlSchemaTypePtr type,\n-                   xmlSchemaAbstractCtxtPtr actxt)\n-{\n-    if (type == NULL)\n-        return(0);\n-    if (actxt->type != XML_SCHEMA_CTXT_PARSER) {\n-    AERROR_INT(\"xmlSchemaTypeFixup\",\n-        \"this function needs a parser context\");\n-    return(-1);\n-    }\n-    if (! WXS_IS_TYPE_NOT_FIXED(type))\n-    return(0);\n-    if (type->type == XML_SCHEMA_TYPE_COMPLEX)\n-    return(xmlSchemaFixupComplexType(PCTXT_CAST actxt, type));\n-    else if (type->type == XML_SCHEMA_TYPE_SIMPLE)\n-    return(xmlSchemaFixupSimpleTypeStageTwo(PCTXT_CAST actxt, type));\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaCheckFacet:\n- * @facet:  the facet\n- * @typeDecl:  the schema type definition\n- * @pctxt:  the schema parser context or NULL\n- * @name: the optional name of the type\n- *\n- * Checks and computes the values of facets.\n- *\n- * Returns 0 if valid, a positive error code if not valid and\n- *         -1 in case of an internal or API error.\n- *\/\n-int\n-xmlSchemaCheckFacet(xmlSchemaFacetPtr facet,\n-                    xmlSchemaTypePtr typeDecl,\n-                    xmlSchemaParserCtxtPtr pctxt,\n-            const xmlChar * name ATTRIBUTE_UNUSED)\n-{\n-    int ret = 0, ctxtGiven;\n-\n-    if ((facet == NULL) || (typeDecl == NULL))\n-        return(-1);\n-    \/*\n-    * TODO: will the parser context be given if used from\n-    * the relaxNG module?\n-    *\/\n-    if (pctxt == NULL)\n-    ctxtGiven = 0;\n-    else\n-    ctxtGiven = 1;\n-\n-    switch (facet->type) {\n-        case XML_SCHEMA_FACET_MININCLUSIVE:\n-        case XML_SCHEMA_FACET_MINEXCLUSIVE:\n-        case XML_SCHEMA_FACET_MAXINCLUSIVE:\n-        case XML_SCHEMA_FACET_MAXEXCLUSIVE:\n-    case XML_SCHEMA_FACET_ENUMERATION: {\n-                \/*\n-                 * Okay we need to validate the value\n-                 * at that point.\n-                 *\/\n-        xmlSchemaTypePtr base;\n-\n-        \/* 4.3.5.5 Constraints on enumeration Schema Components\n-        * Schema Component Constraint: enumeration valid restriction\n-        * It is an `error` if any member of {value} is not in the\n-        * `value space` of {base type definition}.\n-        *\n-        * minInclusive, maxInclusive, minExclusive, maxExclusive:\n-        * The value `must` be in the\n-        * `value space` of the `base type`.\n-        *\/\n-        \/*\n-        * This function is intended to deliver a compiled value\n-        * on the facet. In this implementation of XML Schemata the\n-        * type holding a facet, won't be a built-in type.\n-        * Thus to ensure that other API\n-        * calls (relaxng) do work, if the given type is a built-in\n-        * type, we will assume that the given built-in type *is\n-        * already* the base type.\n-        *\/\n-        if (typeDecl->type != XML_SCHEMA_TYPE_BASIC) {\n-            base = typeDecl->baseType;\n-            if (base == NULL) {\n-            PERROR_INT(\"xmlSchemaCheckFacet\",\n-                \"a type user derived type has no base type\");\n-            return (-1);\n-            }\n-        } else\n-            base = typeDecl;\n-\n-        if (! ctxtGiven) {\n-            \/*\n-            * A context is needed if called from RelaxNG.\n-            *\/\n-            pctxt = xmlSchemaNewParserCtxt(\"*\");\n-            if (pctxt == NULL)\n-            return (-1);\n-        }\n-        \/*\n-        * NOTE: This call does not check the content nodes,\n-        * since they are not available:\n-        * facet->node is just the node holding the facet\n-        * definition, *not* the attribute holding the *value*\n-        * of the facet.\n-        *\/\n-        ret = xmlSchemaVCheckCVCSimpleType(\n-            ACTXT_CAST pctxt, facet->node, base,\n-            facet->value, &(facet->val), 1, 1, 0);\n-                if (ret != 0) {\n-            if (ret < 0) {\n-            \/* No error message for RelaxNG. *\/\n-            if (ctxtGiven) {\n-                xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-                XML_SCHEMAP_INTERNAL, facet->node, NULL,\n-                \"Internal error: xmlSchemaCheckFacet, \"\n-                \"failed to validate the value '%s' of the \"\n-                \"facet '%s' against the base type\",\n-                facet->value, xmlSchemaFacetTypeToString(facet->type));\n-            }\n-            goto internal_error;\n-            }\n-            ret = XML_SCHEMAP_INVALID_FACET_VALUE;\n-            \/* No error message for RelaxNG. *\/\n-            if (ctxtGiven) {\n-            xmlChar *str = NULL;\n-\n-            xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-                ret, facet->node, WXS_BASIC_CAST facet,\n-                \"The value '%s' of the facet does not validate \"\n-                \"against the base type '%s'\",\n-                facet->value,\n-                xmlSchemaFormatQName(&str,\n-                base->targetNamespace, base->name));\n-            FREE_AND_NULL(str);\n-            }\n-            goto exit;\n-                } else if (facet->val == NULL) {\n-            if (ctxtGiven) {\n-            PERROR_INT(\"xmlSchemaCheckFacet\",\n-                \"value was not computed\");\n-            }\n-            \/* TODO *\/\n-        }\n-                break;\n-            }\n-        case XML_SCHEMA_FACET_PATTERN:\n-            facet->regexp = xmlRegexpCompile(facet->value);\n-            if (facet->regexp == NULL) {\n-        ret = XML_SCHEMAP_REGEXP_INVALID;\n-        \/* No error message for RelaxNG. *\/\n-        if (ctxtGiven) {\n-            xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-            ret, facet->node, WXS_BASIC_CAST typeDecl,\n-            \"The value '%s' of the facet 'pattern' is not a \"\n-            \"valid regular expression\",\n-            facet->value, NULL);\n-        }\n-            }\n-            break;\n-        case XML_SCHEMA_FACET_TOTALDIGITS:\n-        case XML_SCHEMA_FACET_FRACTIONDIGITS:\n-        case XML_SCHEMA_FACET_LENGTH:\n-        case XML_SCHEMA_FACET_MAXLENGTH:\n-        case XML_SCHEMA_FACET_MINLENGTH:\n-\n-        if (facet->type == XML_SCHEMA_FACET_TOTALDIGITS) {\n-        ret = xmlSchemaValidatePredefinedType(\n-            xmlSchemaGetBuiltInType(XML_SCHEMAS_PINTEGER),\n-            facet->value, &(facet->val));\n-        } else {\n-        ret = xmlSchemaValidatePredefinedType(\n-            xmlSchemaGetBuiltInType(XML_SCHEMAS_NNINTEGER),\n-            facet->value, &(facet->val));\n-        }\n-        if (ret != 0) {\n-        if (ret < 0) {\n-            \/* No error message for RelaxNG. *\/\n-            if (ctxtGiven) {\n-            PERROR_INT(\"xmlSchemaCheckFacet\",\n-                \"validating facet value\");\n-            }\n-            goto internal_error;\n-        }\n-        ret = XML_SCHEMAP_INVALID_FACET_VALUE;\n-        \/* No error message for RelaxNG. *\/\n-        if (ctxtGiven) {\n-            \/* error code *\/\n-            xmlSchemaCustomErr4(ACTXT_CAST pctxt,\n-            ret, facet->node, WXS_BASIC_CAST typeDecl,\n-            \"The value '%s' of the facet '%s' is not a valid '%s'\",\n-            facet->value,\n-            xmlSchemaFacetTypeToString(facet->type),\n-            (facet->type != XML_SCHEMA_FACET_TOTALDIGITS) ?\n-                BAD_CAST \"nonNegativeInteger\" :\n-                BAD_CAST \"positiveInteger\",\n-            NULL);\n-        }\n-        }\n-        break;\n-\n-        case XML_SCHEMA_FACET_WHITESPACE:{\n-                if (xmlStrEqual(facet->value, BAD_CAST \"preserve\")) {\n-                    facet->whitespace = XML_SCHEMAS_FACET_PRESERVE;\n-                } else if (xmlStrEqual(facet->value, BAD_CAST \"replace\")) {\n-                    facet->whitespace = XML_SCHEMAS_FACET_REPLACE;\n-                } else if (xmlStrEqual(facet->value, BAD_CAST \"collapse\")) {\n-                    facet->whitespace = XML_SCHEMAS_FACET_COLLAPSE;\n-                } else {\n-            ret = XML_SCHEMAP_INVALID_FACET_VALUE;\n-                    \/* No error message for RelaxNG. *\/\n-            if (ctxtGiven) {\n-            \/* error was previously: XML_SCHEMAP_INVALID_WHITE_SPACE *\/\n-            xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-                ret, facet->node, WXS_BASIC_CAST typeDecl,\n-                \"The value '%s' of the facet 'whitespace' is not \"\n-                \"valid\", facet->value, NULL);\n-                    }\n-                }\n-            }\n-        default:\n-            break;\n-    }\n-exit:\n-    if ((! ctxtGiven) && (pctxt != NULL))\n-    xmlSchemaFreeParserCtxt(pctxt);\n-    return (ret);\n-internal_error:\n-    if ((! ctxtGiven) && (pctxt != NULL))\n-    xmlSchemaFreeParserCtxt(pctxt);\n-    return (-1);\n-}\n-\n-\/**\n- * xmlSchemaCheckFacetValues:\n- * @typeDecl:  the schema type definition\n- * @ctxt:  the schema parser context\n- *\n- * Checks the default values types, especially for facets\n- *\/\n-static int\n-xmlSchemaCheckFacetValues(xmlSchemaTypePtr typeDecl,\n-              xmlSchemaParserCtxtPtr pctxt)\n-{\n-    int res, olderrs = pctxt->nberrors;\n-    const xmlChar *name = typeDecl->name;\n-    \/*\n-    * NOTE: It is intended to use the facets list, instead\n-    * of facetSet.\n-    *\/\n-    if (typeDecl->facets != NULL) {\n-    xmlSchemaFacetPtr facet = typeDecl->facets;\n-\n-    \/*\n-    * Temporarily assign the \"schema\" to the validation context\n-    * of the parser context. This is needed for NOTATION validation.\n-    *\/\n-    if (pctxt->vctxt == NULL) {\n-        if (xmlSchemaCreateVCtxtOnPCtxt(pctxt) == -1)\n-        return(-1);\n-    }\n-    pctxt->vctxt->schema = pctxt->schema;\n-    while (facet != NULL) {\n-        res = xmlSchemaCheckFacet(facet, typeDecl, pctxt, name);\n-        HFAILURE\n-        facet = facet->next;\n-    }\n-    pctxt->vctxt->schema = NULL;\n-    }\n-    if (olderrs != pctxt->nberrors)\n-    return(pctxt->err);\n-    return(0);\n-exit_failure:\n-    return(-1);\n-}\n-\n-\/**\n- * xmlSchemaGetCircModelGrDefRef:\n- * @ctxtMGroup: the searched model group\n- * @selfMGroup: the second searched model group\n- * @particle: the first particle\n- *\n- * This one is intended to be used by\n- * xmlSchemaCheckGroupDefCircular only.\n- *\n- * Returns the particle with the circular model group definition reference,\n- * otherwise NULL.\n- *\/\n-static xmlSchemaTreeItemPtr\n-xmlSchemaGetCircModelGrDefRef(xmlSchemaModelGroupDefPtr groupDef,\n-                  xmlSchemaTreeItemPtr particle)\n-{\n-    xmlSchemaTreeItemPtr circ = NULL;\n-    xmlSchemaTreeItemPtr term;\n-    xmlSchemaModelGroupDefPtr gdef;\n-\n-    for (; particle != NULL; particle = particle->next) {\n-    term = particle->children;\n-    if (term == NULL)\n-        continue;\n-    switch (term->type) {\n-        case XML_SCHEMA_TYPE_GROUP:\n-        gdef = (xmlSchemaModelGroupDefPtr) term;\n-        if (gdef == groupDef)\n-            return (particle);\n-        \/*\n-        * Mark this model group definition to avoid infinite\n-        * recursion on circular references not yet examined.\n-        *\/\n-        if (gdef->flags & XML_SCHEMA_MODEL_GROUP_DEF_MARKED)\n-            continue;\n-        if (gdef->children != NULL) {\n-            gdef->flags |= XML_SCHEMA_MODEL_GROUP_DEF_MARKED;\n-            circ = xmlSchemaGetCircModelGrDefRef(groupDef,\n-            gdef->children->children);\n-            gdef->flags ^= XML_SCHEMA_MODEL_GROUP_DEF_MARKED;\n-            if (circ != NULL)\n-            return (circ);\n-        }\n-        break;\n-        case XML_SCHEMA_TYPE_SEQUENCE:\n-        case XML_SCHEMA_TYPE_CHOICE:\n-        case XML_SCHEMA_TYPE_ALL:\n-        circ = xmlSchemaGetCircModelGrDefRef(groupDef, term->children);\n-        if (circ != NULL)\n-            return (circ);\n-        break;\n-        default:\n-        break;\n-    }\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlSchemaCheckGroupDefCircular:\n- * @item:  the model group definition\n- * @ctxt:  the parser context\n- * @name:  the name\n- *\n- * Checks for circular references to model group definitions.\n- *\/\n-static void\n-xmlSchemaCheckGroupDefCircular(xmlSchemaModelGroupDefPtr item,\n-                   xmlSchemaParserCtxtPtr ctxt)\n-{\n-    \/*\n-    * Schema Component Constraint: Model Group Correct\n-    * 2 Circular groups are disallowed. That is, within the {particles}\n-    * of a group there must not be at any depth a particle whose {term}\n-    * is the group itself.\n-    *\/\n-    if ((item == NULL) ||\n-    (item->type != XML_SCHEMA_TYPE_GROUP) ||\n-    (item->children == NULL))\n-    return;\n-    {\n-    xmlSchemaTreeItemPtr circ;\n-\n-    circ = xmlSchemaGetCircModelGrDefRef(item, item->children->children);\n-    if (circ != NULL) {\n-        xmlChar *str = NULL;\n-        \/*\n-        * TODO: The error report is not adequate: this constraint\n-        * is defined for model groups but not definitions, but since\n-        * there cannot be any circular model groups without a model group\n-        * definition (if not using a construction API), we check those\n-        * definitions only.\n-        *\/\n-        xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_MG_PROPS_CORRECT_2,\n-        NULL, WXS_ITEM_NODE(circ),\n-        \"Circular reference to the model group definition '%s' \"\n-        \"defined\", xmlSchemaFormatQName(&str,\n-            item->targetNamespace, item->name));\n-        FREE_AND_NULL(str)\n-        \/*\n-        * NOTE: We will cut the reference to avoid further\n-        * confusion of the processor. This is a fatal error.\n-        *\/\n-        circ->children = NULL;\n-    }\n-    }\n-}\n-\n-\/**\n- * xmlSchemaModelGroupToModelGroupDefFixup:\n- * @ctxt:  the parser context\n- * @mg:  the model group\n- *\n- * Assigns the model group of model group definitions to the \"term\"\n- * of the referencing particle.\n- * In xmlSchemaResolveModelGroupParticleReferences the model group\n- * definitions were assigned to the \"term\", since needed for the\n- * circularity check.\n- *\n- * Schema Component Constraint:\n- *     All Group Limited (cos-all-limited) (1.2)\n- *\/\n-static void\n-xmlSchemaModelGroupToModelGroupDefFixup(\n-    xmlSchemaParserCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-    xmlSchemaModelGroupPtr mg)\n-{\n-    xmlSchemaParticlePtr particle = WXS_MODELGROUP_PARTICLE(mg);\n-\n-    while (particle != NULL) {\n-    if ((WXS_PARTICLE_TERM(particle) == NULL) ||\n-        ((WXS_PARTICLE_TERM(particle))->type !=\n-        XML_SCHEMA_TYPE_GROUP))\n-    {\n-        particle = WXS_PTC_CAST particle->next;\n-        continue;\n-    }\n-    if (WXS_MODELGROUPDEF_MODEL(WXS_PARTICLE_TERM(particle)) == NULL) {\n-        \/*\n-        * TODO: Remove the particle.\n-        *\/\n-        WXS_PARTICLE_TERM(particle) = NULL;\n-        particle = WXS_PTC_CAST particle->next;\n-        continue;\n-    }\n-    \/*\n-    * Assign the model group to the {term} of the particle.\n-    *\/\n-    WXS_PARTICLE_TERM(particle) =\n-        WXS_TREE_CAST WXS_MODELGROUPDEF_MODEL(WXS_PARTICLE_TERM(particle));\n-\n-    particle = WXS_PTC_CAST particle->next;\n-    }\n-}\n-\n-\/**\n- * xmlSchemaCheckAttrGroupCircularRecur:\n- * @ctxtGr: the searched attribute group\n- * @attr: the current attribute list to be processed\n- *\n- * This one is intended to be used by\n- * xmlSchemaCheckAttrGroupCircular only.\n- *\n- * Returns the circular attribute group reference, otherwise NULL.\n- *\/\n-static xmlSchemaQNameRefPtr\n-xmlSchemaCheckAttrGroupCircularRecur(xmlSchemaAttributeGroupPtr ctxtGr,\n-                     xmlSchemaItemListPtr list)\n-{\n-    xmlSchemaAttributeGroupPtr gr;\n-    xmlSchemaQNameRefPtr ref, circ;\n-    int i;\n-    \/*\n-    * We will search for an attribute group reference which\n-    * references the context attribute group.\n-    *\/\n-    for (i = 0; i < list->nbItems; i++) {\n-    ref = list->items[i];\n-    if ((ref->type == XML_SCHEMA_EXTRA_QNAMEREF) &&\n-        (ref->itemType == XML_SCHEMA_TYPE_ATTRIBUTEGROUP) &&\n-        (ref->item != NULL))\n-    {\n-        gr = WXS_ATTR_GROUP_CAST ref->item;\n-        if (gr == ctxtGr)\n-        return(ref);\n-        if (gr->flags & XML_SCHEMAS_ATTRGROUP_MARKED)\n-        continue;\n-        \/*\n-        * Mark as visited to avoid infinite recursion on\n-        * circular references not yet examined.\n-        *\/\n-        if ((gr->attrUses) &&\n-        (gr->flags & XML_SCHEMAS_ATTRGROUP_HAS_REFS))\n-        {\n-        gr->flags |= XML_SCHEMAS_ATTRGROUP_MARKED;\n-        circ = xmlSchemaCheckAttrGroupCircularRecur(ctxtGr,\n-            (xmlSchemaItemListPtr) gr->attrUses);\n-        gr->flags ^= XML_SCHEMAS_ATTRGROUP_MARKED;\n-        if (circ != NULL)\n-            return (circ);\n-        }\n-\n-    }\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlSchemaCheckAttrGroupCircular:\n- * attrGr:  the attribute group definition\n- * @ctxt:  the parser context\n- * @name:  the name\n- *\n- * Checks for circular references of attribute groups.\n- *\/\n-static int\n-xmlSchemaCheckAttrGroupCircular(xmlSchemaAttributeGroupPtr attrGr,\n-                xmlSchemaParserCtxtPtr ctxt)\n-{\n-    \/*\n-    * Schema Representation Constraint:\n-    * Attribute Group Definition Representation OK\n-    * 3 Circular group reference is disallowed outside <redefine>.\n-    * That is, unless this element information item's parent is\n-    * <redefine>, then among the [children], if any, there must\n-    * not be an <attributeGroup> with ref [attribute] which resolves\n-    * to the component corresponding to this <attributeGroup>. Indirect\n-    * circularity is also ruled out. That is, when QName resolution\n-    * (Schema Document) ($3.15.3) is applied to a `QName` arising from\n-    * any <attributeGroup>s with a ref [attribute] among the [children],\n-    * it must not be the case that a `QName` is encountered at any depth\n-    * which resolves to the component corresponding to this <attributeGroup>.\n-    *\/\n-    if (attrGr->attrUses == NULL)\n-    return(0);\n-    else if ((attrGr->flags & XML_SCHEMAS_ATTRGROUP_HAS_REFS) == 0)\n-    return(0);\n-    else {\n-    xmlSchemaQNameRefPtr circ;\n-\n-    circ = xmlSchemaCheckAttrGroupCircularRecur(attrGr,\n-        (xmlSchemaItemListPtr) attrGr->attrUses);\n-    if (circ != NULL) {\n-        xmlChar *str = NULL;\n-        \/*\n-        * TODO: Report the referenced attr group as QName.\n-        *\/\n-        xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3,\n-        NULL, WXS_ITEM_NODE(WXS_BASIC_CAST circ),\n-        \"Circular reference to the attribute group '%s' \"\n-        \"defined\", xmlSchemaGetComponentQName(&str, attrGr));\n-        FREE_AND_NULL(str);\n-        \/*\n-        * NOTE: We will cut the reference to avoid further\n-        * confusion of the processor.\n-        * BADSPEC TODO: The spec should define how to process in this case.\n-        *\/\n-        circ->item = NULL;\n-        return(ctxt->err);\n-    }\n-    }\n-    return(0);\n-}\n-\n-static int\n-xmlSchemaAttributeGroupExpandRefs(xmlSchemaParserCtxtPtr pctxt,\n-                  xmlSchemaAttributeGroupPtr attrGr);\n-\n-\/**\n- * xmlSchemaExpandAttributeGroupRefs:\n- * @pctxt: the parser context\n- * @node: the node of the component holding the attribute uses\n- * @completeWild: the intersected wildcard to be returned\n- * @list: the attribute uses\n- *\n- * Substitutes contained attribute group references\n- * for their attribute uses. Wildcards are intersected.\n- * Attribute use prohibitions are removed from the list\n- * and returned via the @prohibs list.\n- * Pointlessness of attr. prohibs, if a matching attr. decl\n- * is existent a well, are checked.\n- *\/\n-static int\n-xmlSchemaExpandAttributeGroupRefs(xmlSchemaParserCtxtPtr pctxt,\n-                  xmlSchemaBasicItemPtr item,\n-                  xmlSchemaWildcardPtr *completeWild,\n-                  xmlSchemaItemListPtr list,\n-                  xmlSchemaItemListPtr prohibs)\n-{\n-    xmlSchemaAttributeGroupPtr gr;\n-    xmlSchemaAttributeUsePtr use;\n-    xmlSchemaItemListPtr sublist;\n-    int i, j;\n-    int created = (*completeWild == NULL) ? 0 : 1;\n-\n-    if (prohibs)\n-    prohibs->nbItems = 0;\n-\n-    for (i = 0; i < list->nbItems; i++) {\n-    use = list->items[i];\n-\n-    if (use->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) {\n-        if (prohibs == NULL) {\n-        PERROR_INT(\"xmlSchemaExpandAttributeGroupRefs\",\n-            \"unexpected attr prohibition found\");\n-        return(-1);\n-        }\n-        \/*\n-        * Remove from attribute uses.\n-        *\/\n-        if (xmlSchemaItemListRemove(list, i) == -1)\n-        return(-1);\n-        i--;\n-        \/*\n-        * Note that duplicate prohibitions were already\n-        * handled at parsing time.\n-        *\/\n-        \/*\n-        * Add to list of prohibitions.\n-        *\/\n-        xmlSchemaItemListAddSize(prohibs, 2, use);\n-        continue;\n-    }\n-    if ((use->type == XML_SCHEMA_EXTRA_QNAMEREF) &&\n-        ((WXS_QNAME_CAST use)->itemType == XML_SCHEMA_TYPE_ATTRIBUTEGROUP))\n-    {\n-        if ((WXS_QNAME_CAST use)->item == NULL)\n-        return(-1);\n-        gr = WXS_ATTR_GROUP_CAST (WXS_QNAME_CAST use)->item;\n-        \/*\n-        * Expand the referenced attr. group.\n-        * TODO: remove this, this is done in a previous step, so\n-        * already done here.\n-        *\/\n-        if ((gr->flags & XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED) == 0) {\n-        if (xmlSchemaAttributeGroupExpandRefs(pctxt, gr) == -1)\n-            return(-1);\n-        }\n-        \/*\n-        * Build the 'complete' wildcard; i.e. intersect multiple\n-        * wildcards.\n-        *\/\n-        if (gr->attributeWildcard != NULL) {\n-        if (*completeWild == NULL) {\n-            *completeWild = gr->attributeWildcard;\n-        } else {\n-            if (! created) {\n-            xmlSchemaWildcardPtr tmpWild;\n-\n-             \/*\n-            * Copy the first encountered wildcard as context,\n-            * except for the annotation.\n-            *\n-            * Although the complete wildcard might not correspond\n-            * to any node in the schema, we will anchor it on\n-            * the node of the owner component.\n-            *\/\n-            tmpWild =  xmlSchemaAddWildcard(pctxt, pctxt->schema,\n-                XML_SCHEMA_TYPE_ANY_ATTRIBUTE,\n-                WXS_ITEM_NODE(item));\n-            if (tmpWild == NULL)\n-                return(-1);\n-            if (xmlSchemaCloneWildcardNsConstraints(pctxt,\n-                tmpWild, *completeWild) == -1)\n-                return (-1);\n-            tmpWild->processContents = (*completeWild)->processContents;\n-            *completeWild = tmpWild;\n-            created = 1;\n-            }\n-\n-            if (xmlSchemaIntersectWildcards(pctxt, *completeWild,\n-            gr->attributeWildcard) == -1)\n-            return(-1);\n-        }\n-        }\n-        \/*\n-        * Just remove the reference if the referenced group does not\n-        * contain any attribute uses.\n-        *\/\n-        sublist = ((xmlSchemaItemListPtr) gr->attrUses);\n-        if ((sublist == NULL) || sublist->nbItems == 0) {\n-        if (xmlSchemaItemListRemove(list, i) == -1)\n-            return(-1);\n-        i--;\n-        continue;\n-        }\n-        \/*\n-        * Add the attribute uses.\n-        *\/\n-        list->items[i] = sublist->items[0];\n-        if (sublist->nbItems != 1) {\n-        for (j = 1; j < sublist->nbItems; j++) {\n-            i++;\n-            if (xmlSchemaItemListInsert(list,\n-                sublist->items[j], i) == -1)\n-            return(-1);\n-        }\n-        }\n-    }\n-\n-    }\n-    \/*\n-    * Handle pointless prohibitions of declared attributes.\n-    *\/\n-    if (prohibs && (prohibs->nbItems != 0) && (list->nbItems != 0)) {\n-    xmlSchemaAttributeUseProhibPtr prohib;\n-\n-    for (i = prohibs->nbItems -1; i >= 0; i--) {\n-        prohib = prohibs->items[i];\n-        for (j = 0; j < list->nbItems; j++) {\n-        use = list->items[j];\n-\n-        if ((prohib->name == WXS_ATTRUSE_DECL_NAME(use)) &&\n-            (prohib->targetNamespace == WXS_ATTRUSE_DECL_TNS(use)))\n-        {\n-            xmlChar *str = NULL;\n-\n-            xmlSchemaCustomWarning(ACTXT_CAST pctxt,\n-            XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,\n-            prohib->node, NULL,\n-            \"Skipping pointless attribute use prohibition \"\n-            \"'%s', since a corresponding attribute use \"\n-            \"exists already in the type definition\",\n-            xmlSchemaFormatQName(&str,\n-                prohib->targetNamespace, prohib->name),\n-            NULL, NULL);\n-            FREE_AND_NULL(str);\n-            \/*\n-            * Remove the prohibition.\n-            *\/\n-            if (xmlSchemaItemListRemove(prohibs, i) == -1)\n-            return(-1);\n-            break;\n-        }\n-        }\n-    }\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaAttributeGroupExpandRefs:\n- * @pctxt:  the parser context\n- * @attrGr:  the attribute group definition\n- *\n- * Computation of:\n- * {attribute uses} property\n- * {attribute wildcard} property\n- *\n- * Substitutes contained attribute group references\n- * for their attribute uses. Wildcards are intersected.\n- *\/\n-static int\n-xmlSchemaAttributeGroupExpandRefs(xmlSchemaParserCtxtPtr pctxt,\n-                  xmlSchemaAttributeGroupPtr attrGr)\n-{\n-    if ((attrGr->attrUses == NULL) ||\n-    (attrGr->flags & XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED))\n-    return(0);\n-\n-    attrGr->flags |= XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED;\n-    if (xmlSchemaExpandAttributeGroupRefs(pctxt, WXS_BASIC_CAST attrGr,\n-    &(attrGr->attributeWildcard), attrGr->attrUses, NULL) == -1)\n-    return(-1);\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaAttributeGroupExpandRefs:\n- * @pctxt:  the parser context\n- * @attrGr:  the attribute group definition\n- *\n- * Substitutes contained attribute group references\n- * for their attribute uses. Wildcards are intersected.\n- *\n- * Schema Component Constraint:\n- *    Attribute Group Definition Properties Correct (ag-props-correct)\n- *\/\n-static int\n-xmlSchemaCheckAGPropsCorrect(xmlSchemaParserCtxtPtr pctxt,\n-                  xmlSchemaAttributeGroupPtr attrGr)\n-{\n-    \/*\n-    * SPEC ag-props-correct\n-    * (1) \"The values of the properties of an attribute group definition\n-    * must be as described in the property tableau in The Attribute\n-    * Group Definition Schema Component ($3.6.1), modulo the impact of\n-    * Missing Sub-components ($5.3);\"\n-    *\/\n-\n-    if ((attrGr->attrUses != NULL) &&\n-    (WXS_LIST_CAST attrGr->attrUses)->nbItems > 1)\n-    {\n-    xmlSchemaItemListPtr uses = WXS_LIST_CAST attrGr->attrUses;\n-    xmlSchemaAttributeUsePtr use, tmp;\n-    int i, j, hasId = 0;\n-\n-    for (i = uses->nbItems -1; i >= 0; i--) {\n-        use = uses->items[i];\n-        \/*\n-        * SPEC ag-props-correct\n-        * (2) \"Two distinct members of the {attribute uses} must not have\n-        * {attribute declaration}s both of whose {name}s match and whose\n-        * {target namespace}s are identical.\"\n-        *\/\n-        if (i > 0) {\n-        for (j = i -1; j >= 0; j--) {\n-            tmp = uses->items[j];\n-            if ((WXS_ATTRUSE_DECL_NAME(use) ==\n-            WXS_ATTRUSE_DECL_NAME(tmp)) &&\n-            (WXS_ATTRUSE_DECL_TNS(use) ==\n-            WXS_ATTRUSE_DECL_TNS(tmp)))\n-            {\n-            xmlChar *str = NULL;\n-\n-            xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-                XML_SCHEMAP_AG_PROPS_CORRECT,\n-                attrGr->node, WXS_BASIC_CAST attrGr,\n-                \"Duplicate %s\",\n-                xmlSchemaGetComponentDesignation(&str, use),\n-                NULL);\n-            FREE_AND_NULL(str);\n-            \/*\n-            * Remove the duplicate.\n-            *\/\n-            if (xmlSchemaItemListRemove(uses, i) == -1)\n-                return(-1);\n-            goto next_use;\n-            }\n-        }\n-        }\n-        \/*\n-        * SPEC ag-props-correct\n-        * (3) \"Two distinct members of the {attribute uses} must not have\n-        * {attribute declaration}s both of whose {type definition}s are or\n-        * are derived from ID.\"\n-        * TODO: Does 'derived' include member-types of unions?\n-        *\/\n-        if (WXS_ATTRUSE_TYPEDEF(use) != NULL) {\n-        if (xmlSchemaIsDerivedFromBuiltInType(\n-            WXS_ATTRUSE_TYPEDEF(use), XML_SCHEMAS_ID))\n-        {\n-            if (hasId) {\n-            xmlChar *str = NULL;\n-\n-            xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-                XML_SCHEMAP_AG_PROPS_CORRECT,\n-                attrGr->node, WXS_BASIC_CAST attrGr,\n-                \"There must not exist more than one attribute \"\n-                \"declaration of type 'xs:ID' \"\n-                \"(or derived from 'xs:ID'). The %s violates this \"\n-                \"constraint\",\n-                xmlSchemaGetComponentDesignation(&str, use),\n-                NULL);\n-            FREE_AND_NULL(str);\n-            if (xmlSchemaItemListRemove(uses, i) == -1)\n-                return(-1);\n-            }\n-            hasId = 1;\n-        }\n-        }\n-next_use: {}\n-    }\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaResolveAttrGroupReferences:\n- * @attrgrpDecl:  the schema attribute definition\n- * @ctxt:  the schema parser context\n- * @name:  the attribute name\n- *\n- * Resolves references to attribute group definitions.\n- *\/\n-static int\n-xmlSchemaResolveAttrGroupReferences(xmlSchemaQNameRefPtr ref,\n-                    xmlSchemaParserCtxtPtr ctxt)\n-{\n-    xmlSchemaAttributeGroupPtr group;\n-\n-    if (ref->item != NULL)\n-        return(0);\n-    group = xmlSchemaGetAttributeGroup(ctxt->schema,\n-    ref->name,\n-    ref->targetNamespace);\n-    if (group == NULL) {\n-    xmlSchemaPResCompAttrErr(ctxt,\n-        XML_SCHEMAP_SRC_RESOLVE,\n-        NULL, ref->node,\n-        \"ref\", ref->name, ref->targetNamespace,\n-        ref->itemType, NULL);\n-    return(ctxt->err);\n-    }\n-    ref->item = WXS_BASIC_CAST group;\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaCheckAttrPropsCorrect:\n- * @item:  an schema attribute declaration\/use\n- * @ctxt:  a schema parser context\n- * @name:  the name of the attribute\n- *\n- *\n- * Schema Component Constraint:\n- *    Attribute Declaration Properties Correct (a-props-correct)\n- *\n- * Validates the value constraints of an attribute declaration\/use.\n- * NOTE that this needs the simple type definitions to be already\n- *   built and checked.\n- *\/\n-static int\n-xmlSchemaCheckAttrPropsCorrect(xmlSchemaParserCtxtPtr pctxt,\n-                   xmlSchemaAttributePtr attr)\n-{\n-\n-    \/*\n-    * SPEC a-props-correct (1)\n-    * \"The values of the properties of an attribute declaration must\n-    * be as described in the property tableau in The Attribute\n-    * Declaration Schema Component ($3.2.1), modulo the impact of\n-    * Missing Sub-components ($5.3).\"\n-    *\/\n-\n-    if (WXS_ATTR_TYPEDEF(attr) == NULL)\n-    return(0);\n-\n-    if (attr->defValue != NULL) {\n-    int ret;\n-\n-    \/*\n-    * SPEC a-props-correct (3)\n-    * \"If the {type definition} is or is derived from ID then there\n-    * must not be a {value constraint}.\"\n-    *\/\n-    if (xmlSchemaIsDerivedFromBuiltInType(\n-        WXS_ATTR_TYPEDEF(attr), XML_SCHEMAS_ID))\n-    {\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_A_PROPS_CORRECT_3,\n-        NULL, WXS_BASIC_CAST attr,\n-        \"Value constraints are not allowed if the type definition \"\n-        \"is or is derived from xs:ID\",\n-        NULL, NULL);\n-        return(pctxt->err);\n-    }\n-    \/*\n-    * SPEC a-props-correct (2)\n-    * \"if there is a {value constraint}, the canonical lexical\n-    * representation of its value must be `valid` with respect\n-    * to the {type definition} as defined in String Valid ($3.14.4).\"\n-    * TODO: Don't care about the *canonical* stuff here, this requirement\n-    * will be removed in WXS 1.1 anyway.\n-    *\/\n-    ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST pctxt,\n-        attr->node, WXS_ATTR_TYPEDEF(attr),\n-        attr->defValue, &(attr->defVal),\n-        1, 1, 0);\n-    if (ret != 0) {\n-        if (ret < 0) {\n-        PERROR_INT(\"xmlSchemaCheckAttrPropsCorrect\",\n-            \"calling xmlSchemaVCheckCVCSimpleType()\");\n-        return(-1);\n-        }\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_A_PROPS_CORRECT_2,\n-        NULL, WXS_BASIC_CAST attr,\n-        \"The value of the value constraint is not valid\",\n-        NULL, NULL);\n-        return(pctxt->err);\n-    }\n-    }\n-\n-    return(0);\n-}\n-\n-static xmlSchemaElementPtr\n-xmlSchemaCheckSubstGroupCircular(xmlSchemaElementPtr elemDecl,\n-                 xmlSchemaElementPtr ancestor)\n-{\n-    xmlSchemaElementPtr ret;\n-\n-    if (WXS_SUBST_HEAD(ancestor) == NULL)\n-    return (NULL);\n-    if (WXS_SUBST_HEAD(ancestor) == elemDecl)\n-    return (ancestor);\n-\n-    if (WXS_SUBST_HEAD(ancestor)->flags & XML_SCHEMAS_ELEM_CIRCULAR)\n-    return (NULL);\n-    WXS_SUBST_HEAD(ancestor)->flags |= XML_SCHEMAS_ELEM_CIRCULAR;\n-    ret = xmlSchemaCheckSubstGroupCircular(elemDecl,\n-    WXS_SUBST_HEAD(ancestor));\n-    WXS_SUBST_HEAD(ancestor)->flags ^= XML_SCHEMAS_ELEM_CIRCULAR;\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaCheckElemPropsCorrect:\n- * @ctxt:  a schema parser context\n- * @decl: the element declaration\n- * @name:  the name of the attribute\n- *\n- * Schema Component Constraint:\n- * Element Declaration Properties Correct (e-props-correct)\n- *\n- * STATUS:\n- *   missing: (6)\n- *\/\n-static int\n-xmlSchemaCheckElemPropsCorrect(xmlSchemaParserCtxtPtr pctxt,\n-                   xmlSchemaElementPtr elemDecl)\n-{\n-    int ret = 0;\n-    xmlSchemaTypePtr typeDef = WXS_ELEM_TYPEDEF(elemDecl);\n-    \/*\n-    * SPEC (1) \"The values of the properties of an element declaration\n-    * must be as described in the property tableau in The Element\n-    * Declaration Schema Component ($3.3.1), modulo the impact of Missing\n-    * Sub-components ($5.3).\"\n-    *\/\n-    if (WXS_SUBST_HEAD(elemDecl) != NULL) {\n-    xmlSchemaElementPtr head = WXS_SUBST_HEAD(elemDecl), circ;\n-\n-    xmlSchemaCheckElementDeclComponent(head, pctxt);\n-    \/*\n-    * SPEC (3) \"If there is a non-`absent` {substitution group\n-    * affiliation}, then {scope} must be global.\"\n-    *\/\n-    if ((elemDecl->flags & XML_SCHEMAS_ELEM_GLOBAL) == 0) {\n-        xmlSchemaPCustomErr(pctxt,\n-        XML_SCHEMAP_E_PROPS_CORRECT_3,\n-        WXS_BASIC_CAST elemDecl, NULL,\n-        \"Only global element declarations can have a \"\n-        \"substitution group affiliation\", NULL);\n-        ret = XML_SCHEMAP_E_PROPS_CORRECT_3;\n-    }\n-    \/*\n-    * TODO: SPEC (6) \"Circular substitution groups are disallowed.\n-    * That is, it must not be possible to return to an element declaration\n-    * by repeatedly following the {substitution group affiliation}\n-    * property.\"\n-    *\/\n-    if (head == elemDecl)\n-        circ = head;\n-    else if (WXS_SUBST_HEAD(head) != NULL)\n-        circ = xmlSchemaCheckSubstGroupCircular(head, head);\n-    else\n-        circ = NULL;\n-    if (circ != NULL) {\n-        xmlChar *strA = NULL, *strB = NULL;\n-\n-        xmlSchemaPCustomErrExt(pctxt,\n-        XML_SCHEMAP_E_PROPS_CORRECT_6,\n-        WXS_BASIC_CAST circ, NULL,\n-        \"The element declaration '%s' defines a circular \"\n-        \"substitution group to element declaration '%s'\",\n-        xmlSchemaGetComponentQName(&strA, circ),\n-        xmlSchemaGetComponentQName(&strB, head),\n-        NULL);\n-        FREE_AND_NULL(strA)\n-        FREE_AND_NULL(strB)\n-        ret = XML_SCHEMAP_E_PROPS_CORRECT_6;\n-    }\n-    \/*\n-    * SPEC (4) \"If there is a {substitution group affiliation},\n-    * the {type definition}\n-    * of the element declaration must be validly derived from the {type\n-    * definition} of the {substitution group affiliation}, given the value\n-    * of the {substitution group exclusions} of the {substitution group\n-    * affiliation}, as defined in Type Derivation OK (Complex) ($3.4.6)\n-    * (if the {type definition} is complex) or as defined in\n-    * Type Derivation OK (Simple) ($3.14.6) (if the {type definition} is\n-    * simple).\"\n-    *\n-    * NOTE: {substitution group exclusions} means the values of the\n-    * attribute \"final\".\n-    *\/\n-\n-    if (typeDef != WXS_ELEM_TYPEDEF(WXS_SUBST_HEAD(elemDecl))) {\n-        int set = 0;\n-\n-        if (head->flags & XML_SCHEMAS_ELEM_FINAL_EXTENSION)\n-        set |= SUBSET_EXTENSION;\n-        if (head->flags & XML_SCHEMAS_ELEM_FINAL_RESTRICTION)\n-        set |= SUBSET_RESTRICTION;\n-\n-        if (xmlSchemaCheckCOSDerivedOK(ACTXT_CAST pctxt, typeDef,\n-        WXS_ELEM_TYPEDEF(head), set) != 0) {\n-        xmlChar *strA = NULL, *strB = NULL, *strC = NULL;\n-\n-        ret = XML_SCHEMAP_E_PROPS_CORRECT_4;\n-        xmlSchemaPCustomErrExt(pctxt,\n-            XML_SCHEMAP_E_PROPS_CORRECT_4,\n-            WXS_BASIC_CAST elemDecl, NULL,\n-            \"The type definition '%s' was \"\n-            \"either rejected by the substitution group \"\n-            \"affiliation '%s', or not validly derived from its type \"\n-            \"definition '%s'\",\n-            xmlSchemaGetComponentQName(&strA, typeDef),\n-            xmlSchemaGetComponentQName(&strB, head),\n-            xmlSchemaGetComponentQName(&strC, WXS_ELEM_TYPEDEF(head)));\n-        FREE_AND_NULL(strA)\n-        FREE_AND_NULL(strB)\n-        FREE_AND_NULL(strC)\n-        }\n-    }\n-    }\n-    \/*\n-    * SPEC (5) \"If the {type definition} or {type definition}'s\n-    * {content type}\n-    * is or is derived from ID then there must not be a {value constraint}.\n-    * Note: The use of ID as a type definition for elements goes beyond\n-    * XML 1.0, and should be avoided if backwards compatibility is desired\"\n-    *\/\n-    if ((elemDecl->value != NULL) &&\n-    ((WXS_IS_SIMPLE(typeDef) &&\n-      xmlSchemaIsDerivedFromBuiltInType(typeDef, XML_SCHEMAS_ID)) ||\n-     (WXS_IS_COMPLEX(typeDef) &&\n-      WXS_HAS_SIMPLE_CONTENT(typeDef) &&\n-      xmlSchemaIsDerivedFromBuiltInType(typeDef->contentTypeDef,\n-        XML_SCHEMAS_ID)))) {\n-\n-    ret = XML_SCHEMAP_E_PROPS_CORRECT_5;\n-    xmlSchemaPCustomErr(pctxt,\n-        XML_SCHEMAP_E_PROPS_CORRECT_5,\n-        WXS_BASIC_CAST elemDecl, NULL,\n-        \"The type definition (or type definition's content type) is or \"\n-        \"is derived from ID; value constraints are not allowed in \"\n-        \"conjunction with such a type definition\", NULL);\n-    } else if (elemDecl->value != NULL) {\n-    int vcret;\n-    xmlNodePtr node = NULL;\n-\n-    \/*\n-    * SPEC (2) \"If there is a {value constraint}, the canonical lexical\n-    * representation of its value must be `valid` with respect to the\n-    * {type definition} as defined in Element Default Valid (Immediate)\n-    * ($3.3.6).\"\n-    *\/\n-    if (typeDef == NULL) {\n-        xmlSchemaPErr(pctxt, elemDecl->node,\n-        XML_SCHEMAP_INTERNAL,\n-        \"Internal error: xmlSchemaCheckElemPropsCorrect, \"\n-        \"type is missing... skipping validation of \"\n-        \"the value constraint\", NULL, NULL);\n-        return (-1);\n-    }\n-    if (elemDecl->node != NULL) {\n-        if (elemDecl->flags & XML_SCHEMAS_ELEM_FIXED)\n-        node = (xmlNodePtr) xmlHasProp(elemDecl->node,\n-            BAD_CAST \"fixed\");\n-        else\n-        node = (xmlNodePtr) xmlHasProp(elemDecl->node,\n-            BAD_CAST \"default\");\n-    }\n-    vcret = xmlSchemaParseCheckCOSValidDefault(pctxt, node,\n-        typeDef, elemDecl->value, &(elemDecl->defVal));\n-    if (vcret != 0) {\n-        if (vcret < 0) {\n-        PERROR_INT(\"xmlSchemaElemCheckValConstr\",\n-            \"failed to validate the value constraint of an \"\n-            \"element declaration\");\n-        return (-1);\n-        }\n-        return (vcret);\n-    }\n-    }\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaCheckElemSubstGroup:\n- * @ctxt:  a schema parser context\n- * @decl: the element declaration\n- * @name:  the name of the attribute\n- *\n- * Schema Component Constraint:\n- * Substitution Group (cos-equiv-class)\n- *\n- * In Libxml2 the subst. groups will be precomputed, in terms of that\n- * a list will be built for each subst. group head, holding all direct\n- * referents to this head.\n- * NOTE that this function needs:\n- *   1. circular subst. groups to be checked beforehand\n- *   2. the declaration's type to be derived from the head's type\n- *\n- * STATUS:\n- *\n- *\/\n-static void\n-xmlSchemaCheckElemSubstGroup(xmlSchemaParserCtxtPtr ctxt,\n-                 xmlSchemaElementPtr elemDecl)\n-{\n-    if ((WXS_SUBST_HEAD(elemDecl) == NULL) ||\n-    \/* SPEC (1) \"Its {abstract} is false.\" *\/\n-    (elemDecl->flags & XML_SCHEMAS_ELEM_ABSTRACT))\n-    return;\n-    {\n-    xmlSchemaElementPtr head;\n-    xmlSchemaTypePtr headType, type;\n-    int set, methSet;\n-    \/*\n-    * SPEC (2) \"It is validly substitutable for HEAD subject to HEAD's\n-    * {disallowed substitutions} as the blocking constraint, as defined in\n-    * Substitution Group OK (Transitive) ($3.3.6).\"\n-    *\/\n-    for (head = WXS_SUBST_HEAD(elemDecl); head != NULL;\n-        head = WXS_SUBST_HEAD(head)) {\n-        set = 0;\n-        methSet = 0;\n-        \/*\n-        * The blocking constraints.\n-        *\/\n-        if (head->flags & XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION)\n-        continue;\n-        headType = head->subtypes;\n-        type = elemDecl->subtypes;\n-        if (headType == type)\n-        goto add_member;\n-        if (head->flags & XML_SCHEMAS_ELEM_BLOCK_RESTRICTION)\n-        set |= XML_SCHEMAS_TYPE_BLOCK_RESTRICTION;\n-        if (head->flags & XML_SCHEMAS_ELEM_BLOCK_EXTENSION)\n-        set |= XML_SCHEMAS_TYPE_BLOCK_EXTENSION;\n-        \/*\n-        * SPEC: Substitution Group OK (Transitive) (2.3)\n-        * \"The set of all {derivation method}s involved in the\n-        * derivation of D's {type definition} from C's {type definition}\n-        * does not intersect with the union of the blocking constraint,\n-        * C's {prohibited substitutions} (if C is complex, otherwise the\n-        * empty set) and the {prohibited substitutions} (respectively the\n-        * empty set) of any intermediate {type definition}s in the\n-        * derivation of D's {type definition} from C's {type definition}.\"\n-        *\/\n-        \/*\n-        * OPTIMIZE TODO: Optimize this a bit, since, if traversing the\n-        * subst.head axis, the methSet does not need to be computed for\n-        * the full depth over and over.\n-        *\/\n-        \/*\n-        * The set of all {derivation method}s involved in the derivation\n-        *\/\n-        while ((type != NULL) && (type != headType) &&\n-                   (type != type->baseType)) {\n-        if ((WXS_IS_EXTENSION(type)) &&\n-            ((methSet & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) == 0))\n-            methSet |= XML_SCHEMAS_TYPE_BLOCK_EXTENSION;\n-\n-        if (WXS_IS_RESTRICTION(type) &&\n-            ((methSet & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) == 0))\n-            methSet |= XML_SCHEMAS_TYPE_BLOCK_RESTRICTION;\n-\n-        type = type->baseType;\n-        }\n-        \/*\n-        * The {prohibited substitutions} of all intermediate types +\n-        * the head's type.\n-        *\/\n-        type = elemDecl->subtypes->baseType;\n-        while (type != NULL) {\n-        if (WXS_IS_COMPLEX(type)) {\n-            if ((type->flags &\n-                XML_SCHEMAS_TYPE_BLOCK_EXTENSION) &&\n-            ((set & XML_SCHEMAS_TYPE_BLOCK_EXTENSION) == 0))\n-            set |= XML_SCHEMAS_TYPE_BLOCK_EXTENSION;\n-            if ((type->flags &\n-                XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) &&\n-            ((set & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) == 0))\n-            set |= XML_SCHEMAS_TYPE_BLOCK_RESTRICTION;\n-        } else\n-            break;\n-        if (type == headType)\n-            break;\n-        type = type->baseType;\n-        }\n-        if ((set != 0) &&\n-        (((set & XML_SCHEMAS_TYPE_BLOCK_EXTENSION) &&\n-        (methSet & XML_SCHEMAS_TYPE_BLOCK_EXTENSION)) ||\n-        ((set & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION) &&\n-        (methSet & XML_SCHEMAS_TYPE_BLOCK_RESTRICTION)))) {\n-        continue;\n-        }\n-add_member:\n-        xmlSchemaAddElementSubstitutionMember(ctxt, head, elemDecl);\n-        if ((head->flags & XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD) == 0)\n-        head->flags |= XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD;\n-    }\n-    }\n-}\n-\n-#ifdef WXS_ELEM_DECL_CONS_ENABLED \/* enable when finished *\/\n-\/**\n- * xmlSchemaCheckElementDeclComponent\n- * @pctxt: the schema parser context\n- * @ctxtComponent: the context component (an element declaration)\n- * @ctxtParticle: the first particle of the context component\n- * @searchParticle: the element declaration particle to be analysed\n- *\n- * Schema Component Constraint: Element Declarations Consistent\n- *\/\n-static int\n-xmlSchemaCheckElementDeclConsistent(xmlSchemaParserCtxtPtr pctxt,\n-                    xmlSchemaBasicItemPtr ctxtComponent,\n-                    xmlSchemaParticlePtr ctxtParticle,\n-                    xmlSchemaParticlePtr searchParticle,\n-                    xmlSchemaParticlePtr curParticle,\n-                    int search)\n-{\n-    return(0);\n-\n-    int ret = 0;\n-    xmlSchemaParticlePtr cur = curParticle;\n-    if (curParticle == NULL) {\n-    return(0);\n-    }\n-    if (WXS_PARTICLE_TERM(curParticle) == NULL) {\n-    \/*\n-    * Just return in this case. A missing \"term\" of the particle\n-    * might arise due to an invalid \"term\" component.\n-    *\/\n-    return(0);\n-    }\n-    while (cur != NULL) {\n-    switch (WXS_PARTICLE_TERM(cur)->type) {\n-        case XML_SCHEMA_TYPE_ANY:\n-        break;\n-        case XML_SCHEMA_TYPE_ELEMENT:\n-        if (search == 0) {\n-            ret = xmlSchemaCheckElementDeclConsistent(pctxt,\n-            ctxtComponent, ctxtParticle, cur, ctxtParticle, 1);\n-            if (ret != 0)\n-            return(ret);\n-        } else {\n-            xmlSchemaElementPtr elem =\n-            WXS_ELEM_CAST(WXS_PARTICLE_TERM(cur));\n-            \/*\n-            * SPEC Element Declarations Consistent:\n-            * \"If the {particles} contains, either directly,\n-            * indirectly (that is, within the {particles} of a\n-            * contained model group, recursively) or `implicitly`\n-            * two or more element declaration particles with\n-            * the same {name} and {target namespace}, then\n-            * all their type definitions must be the same\n-            * top-level definition [...]\"\n-            *\/\n-            if (xmlStrEqual(WXS_PARTICLE_TERM_AS_ELEM(cur)->name,\n-                WXS_PARTICLE_TERM_AS_ELEM(searchParticle)->name) &&\n-            xmlStrEqual(WXS_PARTICLE_TERM_AS_ELEM(cur)->targetNamespace,\n-                WXS_PARTICLE_TERM_AS_ELEM(searchParticle)->targetNamespace))\n-            {\n-            xmlChar *strA = NULL, *strB = NULL;\n-\n-            xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-                \/* TODO: error code *\/\n-                XML_SCHEMAP_COS_NONAMBIG,\n-                WXS_ITEM_NODE(cur), NULL,\n-                \"In the content model of %s, there are multiple \"\n-                \"element declarations for '%s' with different \"\n-                \"type definitions\",\n-                xmlSchemaGetComponentDesignation(&strA,\n-                ctxtComponent),\n-                xmlSchemaFormatQName(&strB,\n-                WXS_PARTICLE_TERM_AS_ELEM(cur)->targetNamespace,\n-                WXS_PARTICLE_TERM_AS_ELEM(cur)->name));\n-            FREE_AND_NULL(strA);\n-            FREE_AND_NULL(strB);\n-            return(XML_SCHEMAP_COS_NONAMBIG);\n-            }\n-        }\n-        break;\n-        case XML_SCHEMA_TYPE_SEQUENCE: {\n-        break;\n-        }\n-        case XML_SCHEMA_TYPE_CHOICE:{\n-        \/*\n-        xmlSchemaTreeItemPtr sub;\n-\n-        sub = WXS_PARTICLE_TERM(particle)->children;  (xmlSchemaParticlePtr)\n-        while (sub != NULL) {\n-            ret = xmlSchemaCheckElementDeclConsistent(pctxt, ctxtComponent,\n-            ctxtParticle, ctxtElem);\n-            if (ret != 0)\n-            return(ret);\n-            sub = sub->next;\n-        }\n-        *\/\n-        break;\n-        }\n-        case XML_SCHEMA_TYPE_ALL:\n-        break;\n-        case XML_SCHEMA_TYPE_GROUP:\n-        break;\n-        default:\n-        xmlSchemaInternalErr2(ACTXT_CAST pctxt,\n-            \"xmlSchemaCheckElementDeclConsistent\",\n-            \"found unexpected term of type '%s' in content model\",\n-            WXS_ITEM_TYPE_NAME(WXS_PARTICLE_TERM(cur)), NULL);\n-        return(-1);\n-    }\n-    cur = (xmlSchemaParticlePtr) cur->next;\n-    }\n-\n-exit:\n-    return(ret);\n-}\n-#endif\n-\n-\/**\n- * xmlSchemaCheckElementDeclComponent\n- * @item:  an schema element declaration\/particle\n- * @ctxt:  a schema parser context\n- * @name:  the name of the attribute\n- *\n- * Validates the value constraints of an element declaration.\n- * Adds substitution group members.\n- *\/\n-static void\n-xmlSchemaCheckElementDeclComponent(xmlSchemaElementPtr elemDecl,\n-                   xmlSchemaParserCtxtPtr ctxt)\n-{\n-    if (elemDecl == NULL)\n-    return;\n-    if (elemDecl->flags & XML_SCHEMAS_ELEM_INTERNAL_CHECKED)\n-    return;\n-    elemDecl->flags |= XML_SCHEMAS_ELEM_INTERNAL_CHECKED;\n-    if (xmlSchemaCheckElemPropsCorrect(ctxt, elemDecl) == 0) {\n-    \/*\n-    * Adds substitution group members.\n-    *\/\n-    xmlSchemaCheckElemSubstGroup(ctxt, elemDecl);\n-    }\n-}\n-\n-\/**\n- * xmlSchemaResolveModelGroupParticleReferences:\n- * @particle:  a particle component\n- * @ctxt:  a parser context\n- *\n- * Resolves references of a model group's {particles} to\n- * model group definitions and to element declarations.\n- *\/\n-static void\n-xmlSchemaResolveModelGroupParticleReferences(\n-    xmlSchemaParserCtxtPtr ctxt,\n-    xmlSchemaModelGroupPtr mg)\n-{\n-    xmlSchemaParticlePtr particle = WXS_MODELGROUP_PARTICLE(mg);\n-    xmlSchemaQNameRefPtr ref;\n-    xmlSchemaBasicItemPtr refItem;\n-\n-    \/*\n-    * URGENT TODO: Test this.\n-    *\/\n-    while (particle != NULL) {\n-    if ((WXS_PARTICLE_TERM(particle) == NULL) ||\n-        ((WXS_PARTICLE_TERM(particle))->type !=\n-        XML_SCHEMA_EXTRA_QNAMEREF))\n-    {\n-        goto next_particle;\n-    }\n-    ref = WXS_QNAME_CAST WXS_PARTICLE_TERM(particle);\n-    \/*\n-    * Resolve the reference.\n-    * NULL the {term} by default.\n-    *\/\n-    particle->children = NULL;\n-\n-    refItem = xmlSchemaGetNamedComponent(ctxt->schema,\n-        ref->itemType, ref->name, ref->targetNamespace);\n-    if (refItem == NULL) {\n-        xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,\n-        NULL, WXS_ITEM_NODE(particle), \"ref\", ref->name,\n-        ref->targetNamespace, ref->itemType, NULL);\n-        \/* TODO: remove the particle. *\/\n-        goto next_particle;\n-    }\n-    if (refItem->type == XML_SCHEMA_TYPE_GROUP) {\n-        if (WXS_MODELGROUPDEF_MODEL(refItem) == NULL)\n-        \/* TODO: remove the particle. *\/\n-        goto next_particle;\n-        \/*\n-        * NOTE that we will assign the model group definition\n-        * itself to the \"term\" of the particle. This will ease\n-        * the check for circular model group definitions. After\n-        * that the \"term\" will be assigned the model group of the\n-        * model group definition.\n-        *\/\n-        if ((WXS_MODELGROUPDEF_MODEL(refItem))->type ==\n-            XML_SCHEMA_TYPE_ALL) {\n-        \/*\n-        * SPEC cos-all-limited (1)\n-        * SPEC cos-all-limited (1.2)\n-        * \"It appears only as the value of one or both of the\n-        * following properties:\"\n-        * (1.1) \"the {model group} property of a model group\n-        *        definition.\"\n-        * (1.2) \"the {term} property of a particle [... of] the \"\n-        * {content type} of a complex type definition.\"\n-        *\/\n-        xmlSchemaCustomErr(ACTXT_CAST ctxt,\n-            \/* TODO: error code *\/\n-            XML_SCHEMAP_COS_ALL_LIMITED,\n-            WXS_ITEM_NODE(particle), NULL,\n-            \"A model group definition is referenced, but \"\n-            \"it contains an 'all' model group, which \"\n-            \"cannot be contained by model groups\",\n-            NULL, NULL);\n-        \/* TODO: remove the particle. *\/\n-        goto next_particle;\n-        }\n-        particle->children = (xmlSchemaTreeItemPtr) refItem;\n-    } else {\n-        \/*\n-        * TODO: Are referenced element declarations the only\n-        * other components we expect here?\n-        *\/\n-        particle->children = (xmlSchemaTreeItemPtr) refItem;\n-    }\n-next_particle:\n-    particle = WXS_PTC_CAST particle->next;\n-    }\n-}\n-\n-static int\n-xmlSchemaAreValuesEqual(xmlSchemaValPtr x,\n-               xmlSchemaValPtr y)\n-{\n-    xmlSchemaTypePtr tx, ty, ptx, pty;\n-    int ret;\n-\n-    while (x != NULL) {\n-    \/* Same types. *\/\n-    tx = xmlSchemaGetBuiltInType(xmlSchemaGetValType(x));\n-    ty = xmlSchemaGetBuiltInType(xmlSchemaGetValType(y));\n-    ptx = xmlSchemaGetPrimitiveType(tx);\n-    pty = xmlSchemaGetPrimitiveType(ty);\n-    \/*\n-    * (1) if a datatype T' is `derived` by `restriction` from an\n-    * atomic datatype T then the `value space` of T' is a subset of\n-    * the `value space` of T. *\/\n-    \/*\n-    * (2) if datatypes T' and T'' are `derived` by `restriction`\n-    * from a common atomic ancestor T then the `value space`s of T'\n-    * and T'' may overlap.\n-    *\/\n-    if (ptx != pty)\n-        return(0);\n-    \/*\n-    * We assume computed values to be normalized, so do a fast\n-    * string comparison for string based types.\n-    *\/\n-    if ((ptx->builtInType == XML_SCHEMAS_STRING) ||\n-        WXS_IS_ANY_SIMPLE_TYPE(ptx)) {\n-        if (! xmlStrEqual(\n-        xmlSchemaValueGetAsString(x),\n-        xmlSchemaValueGetAsString(y)))\n-        return (0);\n-    } else {\n-        ret = xmlSchemaCompareValuesWhtsp(\n-        x, XML_SCHEMA_WHITESPACE_PRESERVE,\n-        y, XML_SCHEMA_WHITESPACE_PRESERVE);\n-        if (ret == -2)\n-        return(-1);\n-        if (ret != 0)\n-        return(0);\n-    }\n-    \/*\n-    * Lists.\n-    *\/\n-    x = xmlSchemaValueGetNext(x);\n-    if (x != NULL) {\n-        y = xmlSchemaValueGetNext(y);\n-        if (y == NULL)\n-        return (0);\n-    } else if (xmlSchemaValueGetNext(y) != NULL)\n-        return (0);\n-    else\n-        return (1);\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaResolveAttrUseReferences:\n- * @item:  an attribute use\n- * @ctxt:  a parser context\n- *\n- * Resolves the referenced attribute declaration.\n- *\/\n-static int\n-xmlSchemaResolveAttrUseReferences(xmlSchemaAttributeUsePtr ause,\n-                  xmlSchemaParserCtxtPtr ctxt)\n-{\n-    if ((ctxt == NULL) || (ause == NULL))\n-    return(-1);\n-    if ((ause->attrDecl == NULL) ||\n-    (ause->attrDecl->type != XML_SCHEMA_EXTRA_QNAMEREF))\n-    return(0);\n-\n-    {\n-    xmlSchemaQNameRefPtr ref = WXS_QNAME_CAST ause->attrDecl;\n-\n-    \/*\n-    * TODO: Evaluate, what errors could occur if the declaration is not\n-    * found.\n-    *\/\n-    ause->attrDecl = xmlSchemaGetAttributeDecl(ctxt->schema,\n-        ref->name, ref->targetNamespace);\n-        if (ause->attrDecl == NULL) {\n-        xmlSchemaPResCompAttrErr(ctxt,\n-        XML_SCHEMAP_SRC_RESOLVE,\n-        WXS_BASIC_CAST ause, ause->node,\n-        \"ref\", ref->name, ref->targetNamespace,\n-        XML_SCHEMA_TYPE_ATTRIBUTE, NULL);\n-            return(ctxt->err);;\n-        }\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaCheckAttrUsePropsCorrect:\n- * @ctxt:  a parser context\n- * @use:  an attribute use\n- *\n- * Schema Component Constraint:\n- * Attribute Use Correct (au-props-correct)\n- *\n- *\/\n-static int\n-xmlSchemaCheckAttrUsePropsCorrect(xmlSchemaParserCtxtPtr ctxt,\n-                 xmlSchemaAttributeUsePtr use)\n-{\n-    if ((ctxt == NULL) || (use == NULL))\n-    return(-1);\n-    if ((use->defValue == NULL) || (WXS_ATTRUSE_DECL(use) == NULL) ||\n-    ((WXS_ATTRUSE_DECL(use))->type != XML_SCHEMA_TYPE_ATTRIBUTE))\n-    return(0);\n-\n-    \/*\n-    * SPEC au-props-correct (1)\n-    * \"The values of the properties of an attribute use must be as\n-    * described in the property tableau in The Attribute Use Schema\n-    * Component ($3.5.1), modulo the impact of Missing\n-    * Sub-components ($5.3).\"\n-    *\/\n-\n-    if (((WXS_ATTRUSE_DECL(use))->defValue != NULL) &&\n-    ((WXS_ATTRUSE_DECL(use))->flags & XML_SCHEMAS_ATTR_FIXED) &&\n-        ((use->flags & XML_SCHEMA_ATTR_USE_FIXED) == 0))\n-    {\n-    xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_AU_PROPS_CORRECT_2,\n-        WXS_BASIC_CAST use, NULL,\n-        \"The attribute declaration has a 'fixed' value constraint \"\n-        \", thus the attribute use must also have a 'fixed' value \"\n-        \"constraint\",\n-        NULL);\n-    return(ctxt->err);\n-    }\n-    \/*\n-    * Compute and check the value constraint's value.\n-    *\/\n-    if ((use->defVal != NULL) && (WXS_ATTRUSE_TYPEDEF(use) != NULL)) {\n-    int ret;\n-    \/*\n-    * TODO: The spec seems to be missing a check of the\n-    * value constraint of the attribute use. We will do it here.\n-    *\/\n-    \/*\n-    * SPEC a-props-correct (3)\n-    *\/\n-    if (xmlSchemaIsDerivedFromBuiltInType(\n-        WXS_ATTRUSE_TYPEDEF(use), XML_SCHEMAS_ID))\n-    {\n-        xmlSchemaCustomErr(ACTXT_CAST ctxt,\n-        XML_SCHEMAP_AU_PROPS_CORRECT,\n-        NULL, WXS_BASIC_CAST use,\n-        \"Value constraints are not allowed if the type definition \"\n-        \"is or is derived from xs:ID\",\n-        NULL, NULL);\n-        return(ctxt->err);\n-    }\n-\n-    ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST ctxt,\n-        use->node, WXS_ATTRUSE_TYPEDEF(use),\n-        use->defValue, &(use->defVal),\n-        1, 1, 0);\n-    if (ret != 0) {\n-        if (ret < 0) {\n-        PERROR_INT2(\"xmlSchemaCheckAttrUsePropsCorrect\",\n-            \"calling xmlSchemaVCheckCVCSimpleType()\");\n-        return(-1);\n-        }\n-        xmlSchemaCustomErr(ACTXT_CAST ctxt,\n-        XML_SCHEMAP_AU_PROPS_CORRECT,\n-        NULL, WXS_BASIC_CAST use,\n-        \"The value of the value constraint is not valid\",\n-        NULL, NULL);\n-        return(ctxt->err);\n-    }\n-    }\n-    \/*\n-    * SPEC au-props-correct (2)\n-    * \"If the {attribute declaration} has a fixed\n-    * {value constraint}, then if the attribute use itself has a\n-    * {value constraint}, it must also be fixed and its value must match\n-    * that of the {attribute declaration}'s {value constraint}.\"\n-    *\/\n-    if (((WXS_ATTRUSE_DECL(use))->defVal != NULL) &&\n-    (((WXS_ATTRUSE_DECL(use))->flags & XML_SCHEMA_ATTR_USE_FIXED) == 0))\n-    {\n-    if (! xmlSchemaAreValuesEqual(use->defVal,\n-        (WXS_ATTRUSE_DECL(use))->defVal))\n-    {\n-        xmlSchemaPCustomErr(ctxt,\n-        XML_SCHEMAP_AU_PROPS_CORRECT_2,\n-        WXS_BASIC_CAST use, NULL,\n-        \"The 'fixed' value constraint of the attribute use \"\n-        \"must match the attribute declaration's value \"\n-        \"constraint '%s'\",\n-        (WXS_ATTRUSE_DECL(use))->defValue);\n-    }\n-    return(ctxt->err);\n-    }\n-    return(0);\n-}\n-\n-\n-\n-\n-\/**\n- * xmlSchemaResolveAttrTypeReferences:\n- * @item:  an attribute declaration\n- * @ctxt:  a parser context\n- *\n- * Resolves the referenced type definition component.\n- *\/\n-static int\n-xmlSchemaResolveAttrTypeReferences(xmlSchemaAttributePtr item,\n-                   xmlSchemaParserCtxtPtr ctxt)\n-{\n-    \/*\n-    * The simple type definition corresponding to the <simpleType> element\n-    * information item in the [children], if present, otherwise the simple\n-    * type definition `resolved` to by the `actual value` of the type\n-    * [attribute], if present, otherwise the `simple ur-type definition`.\n-    *\/\n-    if (item->flags & XML_SCHEMAS_ATTR_INTERNAL_RESOLVED)\n-    return(0);\n-    item->flags |= XML_SCHEMAS_ATTR_INTERNAL_RESOLVED;\n-    if (item->subtypes != NULL)\n-        return(0);\n-    if (item->typeName != NULL) {\n-        xmlSchemaTypePtr type;\n-\n-    type = xmlSchemaGetType(ctxt->schema, item->typeName,\n-        item->typeNs);\n-    if ((type == NULL) || (! WXS_IS_SIMPLE(type))) {\n-        xmlSchemaPResCompAttrErr(ctxt,\n-        XML_SCHEMAP_SRC_RESOLVE,\n-        WXS_BASIC_CAST item, item->node,\n-        \"type\", item->typeName, item->typeNs,\n-        XML_SCHEMA_TYPE_SIMPLE, NULL);\n-        return(ctxt->err);\n-    } else\n-        item->subtypes = type;\n-\n-    } else {\n-    \/*\n-    * The type defaults to the xs:anySimpleType.\n-    *\/\n-    item->subtypes = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaResolveIDCKeyReferences:\n- * @idc:  the identity-constraint definition\n- * @ctxt:  the schema parser context\n- * @name:  the attribute name\n- *\n- * Resolve keyRef references to key\/unique IDCs.\n- * Schema Component Constraint:\n- *   Identity-constraint Definition Properties Correct (c-props-correct)\n- *\/\n-static int\n-xmlSchemaResolveIDCKeyReferences(xmlSchemaIDCPtr idc,\n-              xmlSchemaParserCtxtPtr pctxt)\n-{\n-    if (idc->type != XML_SCHEMA_TYPE_IDC_KEYREF)\n-        return(0);\n-    if (idc->ref->name != NULL) {\n-    idc->ref->item = (xmlSchemaBasicItemPtr)\n-        xmlSchemaGetIDC(pctxt->schema, idc->ref->name,\n-        idc->ref->targetNamespace);\n-        if (idc->ref->item == NULL) {\n-        \/*\n-        * TODO: It is actually not an error to fail to resolve\n-        * at this stage. BUT we need to be that strict!\n-        *\/\n-        xmlSchemaPResCompAttrErr(pctxt,\n-        XML_SCHEMAP_SRC_RESOLVE,\n-        WXS_BASIC_CAST idc, idc->node,\n-        \"refer\", idc->ref->name,\n-        idc->ref->targetNamespace,\n-        XML_SCHEMA_TYPE_IDC_KEY, NULL);\n-            return(pctxt->err);\n-    } else if (idc->ref->item->type == XML_SCHEMA_TYPE_IDC_KEYREF) {\n-        \/*\n-        * SPEC c-props-correct (1)\n-        *\/\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_C_PROPS_CORRECT,\n-        NULL, WXS_BASIC_CAST idc,\n-        \"The keyref references a keyref\",\n-        NULL, NULL);\n-        idc->ref->item = NULL;\n-        return(pctxt->err);\n-    } else {\n-        if (idc->nbFields !=\n-        ((xmlSchemaIDCPtr) idc->ref->item)->nbFields) {\n-        xmlChar *str = NULL;\n-        xmlSchemaIDCPtr refer;\n-\n-        refer = (xmlSchemaIDCPtr) idc->ref->item;\n-        \/*\n-        * SPEC c-props-correct(2)\n-        * \"If the {identity-constraint category} is keyref,\n-        * the cardinality of the {fields} must equal that of\n-        * the {fields} of the {referenced key}.\n-        *\/\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-            XML_SCHEMAP_C_PROPS_CORRECT,\n-            NULL, WXS_BASIC_CAST idc,\n-            \"The cardinality of the keyref differs from the \"\n-            \"cardinality of the referenced key\/unique '%s'\",\n-            xmlSchemaFormatQName(&str, refer->targetNamespace,\n-            refer->name),\n-            NULL);\n-        FREE_AND_NULL(str)\n-        return(pctxt->err);\n-        }\n-    }\n-    }\n-    return(0);\n-}\n-\n-static int\n-xmlSchemaResolveAttrUseProhibReferences(xmlSchemaAttributeUseProhibPtr prohib,\n-                       xmlSchemaParserCtxtPtr pctxt)\n-{\n-    if (xmlSchemaGetAttributeDecl(pctxt->schema, prohib->name,\n-    prohib->targetNamespace) == NULL) {\n-\n-    xmlSchemaPResCompAttrErr(pctxt,\n-        XML_SCHEMAP_SRC_RESOLVE,\n-        NULL, prohib->node,\n-        \"ref\", prohib->name, prohib->targetNamespace,\n-        XML_SCHEMA_TYPE_ATTRIBUTE, NULL);\n-    return(XML_SCHEMAP_SRC_RESOLVE);\n-    }\n-    return(0);\n-}\n-\n-#define WXS_REDEFINED_TYPE(c) \\\n-(((xmlSchemaTypePtr) item)->flags & XML_SCHEMAS_TYPE_REDEFINED)\n-\n-#define WXS_REDEFINED_MODEL_GROUP_DEF(c) \\\n-(((xmlSchemaModelGroupDefPtr) item)->flags & XML_SCHEMA_MODEL_GROUP_DEF_REDEFINED)\n-\n-#define WXS_REDEFINED_ATTR_GROUP(c) \\\n-(((xmlSchemaAttributeGroupPtr) item)->flags & XML_SCHEMAS_ATTRGROUP_REDEFINED)\n-\n-static int\n-xmlSchemaCheckSRCRedefineFirst(xmlSchemaParserCtxtPtr pctxt)\n-{\n-    int err = 0;\n-    xmlSchemaRedefPtr redef = WXS_CONSTRUCTOR(pctxt)->redefs;\n-    xmlSchemaBasicItemPtr prev, item;\n-    int wasRedefined;\n-\n-    if (redef == NULL)\n-    return(0);\n-\n-    do {\n-    item = redef->item;\n-    \/*\n-    * First try to locate the redefined component in the\n-    * schema graph starting with the redefined schema.\n-    * NOTE: According to this schema bug entry:\n-    *   http:\/\/lists.w3.org\/Archives\/Public\/www-xml-schema-comments\/2005OctDec\/0019.html\n-    *   it's not clear if the referenced component needs to originate\n-    *   from the <redefine>d schema _document_ or the schema; the latter\n-    *   would include all imported and included sub-schemas of the\n-    *   <redefine>d schema. Currently the latter approach is used.\n-    *   SUPPLEMENT: It seems that the WG moves towards the latter\n-    *   approach, so we are doing it right.\n-    *\n-    *\/\n-    prev = xmlSchemaFindRedefCompInGraph(\n-        redef->targetBucket, item->type,\n-        redef->refName, redef->refTargetNs);\n-    if (prev == NULL) {\n-        xmlChar *str = NULL;\n-        xmlNodePtr node;\n-\n-        \/*\n-        * SPEC src-redefine:\n-        * (6.2.1) \"The `actual value` of its own name attribute plus\n-        * target namespace must successfully `resolve` to a model\n-        * group definition in I.\"\n-        * (7.2.1) \"The `actual value` of its own name attribute plus\n-        * target namespace must successfully `resolve` to an attribute\n-        * group definition in I.\"\n-\n-        *\n-        * Note that, if we are redefining with the use of references\n-        * to components, the spec assumes the src-resolve to be used;\n-        * but this won't assure that we search only *inside* the\n-        * redefined schema.\n-        *\/\n-        if (redef->reference)\n-        node = WXS_ITEM_NODE(redef->reference);\n-        else\n-        node = WXS_ITEM_NODE(item);\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-        \/*\n-        * TODO: error code.\n-        * Probably XML_SCHEMAP_SRC_RESOLVE, if this is using the\n-        * reference kind.\n-        *\/\n-        XML_SCHEMAP_SRC_REDEFINE, node, NULL,\n-        \"The %s '%s' to be redefined could not be found in \"\n-        \"the redefined schema\",\n-        WXS_ITEM_TYPE_NAME(item),\n-        xmlSchemaFormatQName(&str, redef->refTargetNs,\n-            redef->refName));\n-        FREE_AND_NULL(str);\n-        err = pctxt->err;\n-        redef = redef->next;\n-        continue;\n-    }\n-    \/*\n-    * TODO: Obtaining and setting the redefinition state is really\n-    * clumsy.\n-    *\/\n-    wasRedefined = 0;\n-    switch (item->type) {\n-        case XML_SCHEMA_TYPE_COMPLEX:\n-        case XML_SCHEMA_TYPE_SIMPLE:\n-        if ((WXS_TYPE_CAST prev)->flags &\n-            XML_SCHEMAS_TYPE_REDEFINED)\n-        {\n-            wasRedefined = 1;\n-            break;\n-        }\n-        \/* Mark it as redefined. *\/\n-        (WXS_TYPE_CAST prev)->flags |= XML_SCHEMAS_TYPE_REDEFINED;\n-        \/*\n-        * Assign the redefined type to the\n-        * base type of the redefining type.\n-        * TODO: How\n-        *\/\n-        ((xmlSchemaTypePtr) item)->baseType =\n-            (xmlSchemaTypePtr) prev;\n-        break;\n-        case XML_SCHEMA_TYPE_GROUP:\n-        if ((WXS_MODEL_GROUPDEF_CAST prev)->flags &\n-            XML_SCHEMA_MODEL_GROUP_DEF_REDEFINED)\n-        {\n-            wasRedefined = 1;\n-            break;\n-        }\n-        \/* Mark it as redefined. *\/\n-        (WXS_MODEL_GROUPDEF_CAST prev)->flags |=\n-            XML_SCHEMA_MODEL_GROUP_DEF_REDEFINED;\n-        if (redef->reference != NULL) {\n-            \/*\n-            * Overwrite the QName-reference with the\n-            * referenced model group def.\n-            *\/\n-            (WXS_PTC_CAST redef->reference)->children =\n-            WXS_TREE_CAST prev;\n-        }\n-        redef->target = prev;\n-        break;\n-        case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:\n-        if ((WXS_ATTR_GROUP_CAST prev)->flags &\n-            XML_SCHEMAS_ATTRGROUP_REDEFINED)\n-        {\n-            wasRedefined = 1;\n-            break;\n-        }\n-        (WXS_ATTR_GROUP_CAST prev)->flags |=\n-            XML_SCHEMAS_ATTRGROUP_REDEFINED;\n-        if (redef->reference != NULL) {\n-            \/*\n-            * Assign the redefined attribute group to the\n-            * QName-reference component.\n-            * This is the easy case, since we will just\n-            * expand the redefined group.\n-            *\/\n-            (WXS_QNAME_CAST redef->reference)->item = prev;\n-            redef->target = NULL;\n-        } else {\n-            \/*\n-            * This is the complicated case: we need\n-            * to apply src-redefine (7.2.2) at a later\n-            * stage, i.e. when attribute group references\n-            * have been expanded and simple types have\n-            * been fixed.\n-            *\/\n-            redef->target = prev;\n-        }\n-        break;\n-        default:\n-        PERROR_INT(\"xmlSchemaResolveRedefReferences\",\n-            \"Unexpected redefined component type\");\n-        return(-1);\n-    }\n-    if (wasRedefined) {\n-        xmlChar *str = NULL;\n-        xmlNodePtr node;\n-\n-        if (redef->reference)\n-        node = WXS_ITEM_NODE(redef->reference);\n-        else\n-        node = WXS_ITEM_NODE(redef->item);\n-\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-        \/* TODO: error code. *\/\n-        XML_SCHEMAP_SRC_REDEFINE,\n-        node, NULL,\n-        \"The referenced %s was already redefined. Multiple \"\n-        \"redefinition of the same component is not supported\",\n-        xmlSchemaGetComponentDesignation(&str, prev),\n-        NULL);\n-        FREE_AND_NULL(str)\n-        err = pctxt->err;\n-        redef = redef->next;\n-        continue;\n-    }\n-    redef = redef->next;\n-    } while (redef != NULL);\n-\n-    return(err);\n-}\n-\n-static int\n-xmlSchemaCheckSRCRedefineSecond(xmlSchemaParserCtxtPtr pctxt)\n-{\n-    int err = 0;\n-    xmlSchemaRedefPtr redef = WXS_CONSTRUCTOR(pctxt)->redefs;\n-    xmlSchemaBasicItemPtr item;\n-\n-    if (redef == NULL)\n-    return(0);\n-\n-    do {\n-    if (redef->target == NULL) {\n-        redef = redef->next;\n-        continue;\n-    }\n-    item = redef->item;\n-\n-    switch (item->type) {\n-        case XML_SCHEMA_TYPE_SIMPLE:\n-        case XML_SCHEMA_TYPE_COMPLEX:\n-        \/*\n-        * Since the spec wants the {name} of the redefined\n-        * type to be 'absent', we'll NULL it.\n-        *\/\n-        (WXS_TYPE_CAST redef->target)->name = NULL;\n-\n-        \/*\n-        * TODO: Seems like there's nothing more to do. The normal\n-        * inheritance mechanism is used. But not 100% sure.\n-        *\/\n-        break;\n-        case XML_SCHEMA_TYPE_GROUP:\n-        \/*\n-        * URGENT TODO:\n-        * SPEC src-redefine:\n-        * (6.2.2) \"The {model group} of the model group definition\n-        * which corresponds to it per XML Representation of Model\n-        * Group Definition Schema Components ($3.7.2) must be a\n-        * `valid restriction` of the {model group} of that model\n-        * group definition in I, as defined in Particle Valid\n-        * (Restriction) ($3.9.6).\"\n-        *\/\n-        break;\n-        case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:\n-        \/*\n-        * SPEC src-redefine:\n-        * (7.2.2) \"The {attribute uses} and {attribute wildcard} of\n-        * the attribute group definition which corresponds to it\n-        * per XML Representation of Attribute Group Definition Schema\n-        * Components ($3.6.2) must be `valid restrictions` of the\n-        * {attribute uses} and {attribute wildcard} of that attribute\n-        * group definition in I, as defined in clause 2, clause 3 and\n-        * clause 4 of Derivation Valid (Restriction, Complex)\n-        * ($3.4.6) (where references to the base type definition are\n-        * understood as references to the attribute group definition\n-        * in I).\"\n-        *\/\n-        err = xmlSchemaCheckDerivationOKRestriction2to4(pctxt,\n-            XML_SCHEMA_ACTION_REDEFINE,\n-            item, redef->target,\n-            (WXS_ATTR_GROUP_CAST item)->attrUses,\n-            (WXS_ATTR_GROUP_CAST redef->target)->attrUses,\n-            (WXS_ATTR_GROUP_CAST item)->attributeWildcard,\n-            (WXS_ATTR_GROUP_CAST redef->target)->attributeWildcard);\n-        if (err == -1)\n-            return(-1);\n-        break;\n-        default:\n-        break;\n-    }\n-    redef = redef->next;\n-    } while (redef != NULL);\n-    return(0);\n-}\n-\n-\n-static int\n-xmlSchemaAddComponents(xmlSchemaParserCtxtPtr pctxt,\n-               xmlSchemaBucketPtr bucket)\n-{\n-    xmlSchemaBasicItemPtr item;\n-    int err;\n-    xmlHashTablePtr *table;\n-    const xmlChar *name;\n-    int i;\n-\n-#define WXS_GET_GLOBAL_HASH(c, slot) { \\\n-    if (WXS_IS_BUCKET_IMPMAIN((c)->type)) \\\n-    table = &(WXS_IMPBUCKET((c))->schema->slot); \\\n-    else \\\n-    table = &(WXS_INCBUCKET((c))->ownerImport->schema->slot); }\n-\n-    \/*\n-    * Add global components to the schema's hash tables.\n-    * This is the place where duplicate components will be\n-    * detected.\n-    * TODO: I think normally we should support imports of the\n-    *   same namespace from multiple locations. We don't do currently,\n-    *   but if we do then according to:\n-    *   http:\/\/www.w3.org\/Bugs\/Public\/show_bug.cgi?id=2224\n-    *   we would need, if imported directly, to import redefined\n-    *   components as well to be able to catch clashing components.\n-    *   (I hope I'll still know what this means after some months :-()\n-    *\/\n-    if (bucket == NULL)\n-    return(-1);\n-    if (bucket->flags & XML_SCHEMA_BUCKET_COMPS_ADDED)\n-    return(0);\n-    bucket->flags |= XML_SCHEMA_BUCKET_COMPS_ADDED;\n-\n-    for (i = 0; i < bucket->globals->nbItems; i++) {\n-    item = bucket->globals->items[i];\n-    table = NULL;\n-    switch (item->type) {\n-        case XML_SCHEMA_TYPE_COMPLEX:\n-        case XML_SCHEMA_TYPE_SIMPLE:\n-        if (WXS_REDEFINED_TYPE(item))\n-            continue;\n-        name = (WXS_TYPE_CAST item)->name;\n-        WXS_GET_GLOBAL_HASH(bucket, typeDecl)\n-        break;\n-        case XML_SCHEMA_TYPE_ELEMENT:\n-        name = (WXS_ELEM_CAST item)->name;\n-        WXS_GET_GLOBAL_HASH(bucket, elemDecl)\n-        break;\n-        case XML_SCHEMA_TYPE_ATTRIBUTE:\n-        name = (WXS_ATTR_CAST item)->name;\n-        WXS_GET_GLOBAL_HASH(bucket, attrDecl)\n-        break;\n-        case XML_SCHEMA_TYPE_GROUP:\n-        if (WXS_REDEFINED_MODEL_GROUP_DEF(item))\n-            continue;\n-        name = (WXS_MODEL_GROUPDEF_CAST item)->name;\n-        WXS_GET_GLOBAL_HASH(bucket, groupDecl)\n-        break;\n-        case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:\n-        if (WXS_REDEFINED_ATTR_GROUP(item))\n-            continue;\n-        name = (WXS_ATTR_GROUP_CAST item)->name;\n-        WXS_GET_GLOBAL_HASH(bucket, attrgrpDecl)\n-        break;\n-        case XML_SCHEMA_TYPE_IDC_KEY:\n-        case XML_SCHEMA_TYPE_IDC_UNIQUE:\n-        case XML_SCHEMA_TYPE_IDC_KEYREF:\n-        name = (WXS_IDC_CAST item)->name;\n-        WXS_GET_GLOBAL_HASH(bucket, idcDef)\n-        break;\n-        case XML_SCHEMA_TYPE_NOTATION:\n-        name = ((xmlSchemaNotationPtr) item)->name;\n-        WXS_GET_GLOBAL_HASH(bucket, notaDecl)\n-        break;\n-        default:\n-        PERROR_INT(\"xmlSchemaAddComponents\",\n-            \"Unexpected global component type\");\n-        continue;\n-    }\n-    if (*table == NULL) {\n-        *table = xmlHashCreateDict(10, pctxt->dict);\n-        if (*table == NULL) {\n-        PERROR_INT(\"xmlSchemaAddComponents\",\n-            \"failed to create a component hash table\");\n-        return(-1);\n-        }\n-    }\n-    err = xmlHashAddEntry(*table, name, item);\n-    if (err != 0) {\n-        xmlChar *str = NULL;\n-\n-        xmlSchemaCustomErr(ACTXT_CAST pctxt,\n-        XML_SCHEMAP_REDEFINED_TYPE,\n-        WXS_ITEM_NODE(item),\n-        WXS_BASIC_CAST item,\n-        \"A global %s '%s' does already exist\",\n-        WXS_ITEM_TYPE_NAME(item),\n-        xmlSchemaGetComponentQName(&str, item));\n-        FREE_AND_NULL(str);\n-    }\n-    }\n-    \/*\n-    * Process imported\/included schemas.\n-    *\/\n-    if (bucket->relations != NULL) {\n-    xmlSchemaSchemaRelationPtr rel = bucket->relations;\n-    do {\n-        if ((rel->bucket != NULL) &&\n-        ((rel->bucket->flags & XML_SCHEMA_BUCKET_COMPS_ADDED) == 0)) {\n-        if (xmlSchemaAddComponents(pctxt, rel->bucket) == -1)\n-            return(-1);\n-        }\n-        rel = rel->next;\n-    } while (rel != NULL);\n-    }\n-    return(0);\n-}\n-\n-static int\n-xmlSchemaFixupComponents(xmlSchemaParserCtxtPtr pctxt,\n-             xmlSchemaBucketPtr rootBucket)\n-{\n-    xmlSchemaConstructionCtxtPtr con = pctxt->constructor;\n-    xmlSchemaTreeItemPtr item, *items;\n-    int nbItems, i, ret = 0;\n-    xmlSchemaBucketPtr oldbucket = con->bucket;\n-    xmlSchemaElementPtr elemDecl;\n-\n-#define FIXHFAILURE if (pctxt->err == XML_SCHEMAP_INTERNAL) goto exit_failure;\n-\n-    if ((con->pending == NULL) ||\n-    (con->pending->nbItems == 0))\n-    return(0);\n-\n-    \/*\n-    * Since xmlSchemaFixupComplexType() will create new particles\n-    * (local components), and those particle components need a bucket\n-    * on the constructor, we'll assure here that the constructor has\n-    * a bucket.\n-    * TODO: Think about storing locals _only_ on the main bucket.\n-    *\/\n-    if (con->bucket == NULL)\n-    con->bucket = rootBucket;\n-\n-    \/* TODO:\n-    * SPEC (src-redefine):\n-    * (6.2) \"If it has no such self-reference, then all of the\n-    * following must be true:\"\n-\n-    * (6.2.2) The {model group} of the model group definition which\n-    * corresponds to it per XML Representation of Model Group\n-    * Definition Schema Components ($3.7.2) must be a `valid\n-    * restriction` of the {model group} of that model group definition\n-    * in I, as defined in Particle Valid (Restriction) ($3.9.6).\"\n-    *\/\n-    xmlSchemaCheckSRCRedefineFirst(pctxt);\n-\n-    \/*\n-    * Add global components to the schemata's hash tables.\n-    *\/\n-    xmlSchemaAddComponents(pctxt, rootBucket);\n-\n-    pctxt->ctxtType = NULL;\n-    items = (xmlSchemaTreeItemPtr *) con->pending->items;\n-    nbItems = con->pending->nbItems;\n-    \/*\n-    * Now that we have parsed *all* the schema document(s) and converted\n-    * them to schema components, we can resolve references, apply component\n-    * constraints, create the FSA from the content model, etc.\n-    *\/\n-    \/*\n-    * Resolve references of..\n-    *\n-    * 1. element declarations:\n-    *   - the type definition\n-    *   - the substitution group affiliation\n-    * 2. simple\/complex types:\n-    *   - the base type definition\n-    *   - the memberTypes of union types\n-    *   - the itemType of list types\n-    * 3. attributes declarations and attribute uses:\n-    *   - the type definition\n-    *   - if an attribute use, then the attribute declaration\n-    * 4. attribute group references:\n-    *   - the attribute group definition\n-    * 5. particles:\n-    *   - the term of the particle (e.g. a model group)\n-    * 6. IDC key-references:\n-    *   - the referenced IDC 'key' or 'unique' definition\n-    * 7. Attribute prohibitions which had a \"ref\" attribute.\n-    *\/\n-    for (i = 0; i < nbItems; i++) {\n-    item = items[i];\n-    switch (item->type) {\n-        case XML_SCHEMA_TYPE_ELEMENT:\n-        xmlSchemaResolveElementReferences(\n-            (xmlSchemaElementPtr) item, pctxt);\n-        FIXHFAILURE;\n-        break;\n-        case XML_SCHEMA_TYPE_COMPLEX:\n-        case XML_SCHEMA_TYPE_SIMPLE:\n-        xmlSchemaResolveTypeReferences(\n-            (xmlSchemaTypePtr) item, pctxt);\n-        FIXHFAILURE;\n-        break;\n-        case XML_SCHEMA_TYPE_ATTRIBUTE:\n-        xmlSchemaResolveAttrTypeReferences(\n-            (xmlSchemaAttributePtr) item, pctxt);\n-        FIXHFAILURE;\n-        break;\n-        case XML_SCHEMA_TYPE_ATTRIBUTE_USE:\n-        xmlSchemaResolveAttrUseReferences(\n-            (xmlSchemaAttributeUsePtr) item, pctxt);\n-        FIXHFAILURE;\n-        break;\n-        case XML_SCHEMA_EXTRA_QNAMEREF:\n-        if ((WXS_QNAME_CAST item)->itemType ==\n-            XML_SCHEMA_TYPE_ATTRIBUTEGROUP)\n-        {\n-            xmlSchemaResolveAttrGroupReferences(\n-            WXS_QNAME_CAST item, pctxt);\n-        }\n-        FIXHFAILURE;\n-        break;\n-        case XML_SCHEMA_TYPE_SEQUENCE:\n-        case XML_SCHEMA_TYPE_CHOICE:\n-        case XML_SCHEMA_TYPE_ALL:\n-        xmlSchemaResolveModelGroupParticleReferences(pctxt,\n-            WXS_MODEL_GROUP_CAST item);\n-        FIXHFAILURE;\n-        break;\n-        case XML_SCHEMA_TYPE_IDC_KEY:\n-        case XML_SCHEMA_TYPE_IDC_UNIQUE:\n-        case XML_SCHEMA_TYPE_IDC_KEYREF:\n-        xmlSchemaResolveIDCKeyReferences(\n-            (xmlSchemaIDCPtr) item, pctxt);\n-        FIXHFAILURE;\n-        break;\n-        case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:\n-        \/*\n-        * Handle attribute prohibition which had a\n-        * \"ref\" attribute.\n-        *\/\n-        xmlSchemaResolveAttrUseProhibReferences(\n-            WXS_ATTR_PROHIB_CAST item, pctxt);\n-        FIXHFAILURE;\n-        break;\n-        default:\n-        break;\n-    }\n-    }\n-    if (pctxt->nberrors != 0)\n-    goto exit_error;\n-\n-    \/*\n-    * Now that all references are resolved we\n-    * can check for circularity of...\n-    * 1. the base axis of type definitions\n-    * 2. nested model group definitions\n-    * 3. nested attribute group definitions\n-    * TODO: check for circular substitution groups.\n-    *\/\n-    for (i = 0; i < nbItems; i++) {\n-    item = items[i];\n-    \/*\n-    * Let's better stop on the first error here.\n-    *\/\n-    switch (item->type) {\n-        case XML_SCHEMA_TYPE_COMPLEX:\n-        case XML_SCHEMA_TYPE_SIMPLE:\n-        xmlSchemaCheckTypeDefCircular(\n-            (xmlSchemaTypePtr) item, pctxt);\n-        FIXHFAILURE;\n-        if (pctxt->nberrors != 0)\n-            goto exit_error;\n-        break;\n-        case XML_SCHEMA_TYPE_GROUP:\n-        xmlSchemaCheckGroupDefCircular(\n-            (xmlSchemaModelGroupDefPtr) item, pctxt);\n-        FIXHFAILURE;\n-        if (pctxt->nberrors != 0)\n-            goto exit_error;\n-        break;\n-        case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:\n-        xmlSchemaCheckAttrGroupCircular(\n-            (xmlSchemaAttributeGroupPtr) item, pctxt);\n-        FIXHFAILURE;\n-        if (pctxt->nberrors != 0)\n-            goto exit_error;\n-        break;\n-        default:\n-        break;\n-    }\n-    }\n-    if (pctxt->nberrors != 0)\n-    goto exit_error;\n-    \/*\n-    * Model group definition references:\n-    * Such a reference is reflected by a particle at the component\n-    * level. Until now the 'term' of such particles pointed\n-    * to the model group definition; this was done, in order to\n-    * ease circularity checks. Now we need to set the 'term' of\n-    * such particles to the model group of the model group definition.\n-    *\/\n-    for (i = 0; i < nbItems; i++) {\n-    item = items[i];\n-    switch (item->type) {\n-        case XML_SCHEMA_TYPE_SEQUENCE:\n-        case XML_SCHEMA_TYPE_CHOICE:\n-        xmlSchemaModelGroupToModelGroupDefFixup(pctxt,\n-            WXS_MODEL_GROUP_CAST item);\n-        break;\n-        default:\n-        break;\n-    }\n-    }\n-    if (pctxt->nberrors != 0)\n-    goto exit_error;\n-    \/*\n-    * Expand attribute group references of attribute group definitions.\n-    *\/\n-    for (i = 0; i < nbItems; i++) {\n-    item = items[i];\n-    switch (item->type) {\n-            case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:\n-        if ((! WXS_ATTR_GROUP_EXPANDED(item)) &&\n-            WXS_ATTR_GROUP_HAS_REFS(item))\n-        {\n-            xmlSchemaAttributeGroupExpandRefs(pctxt,\n-            WXS_ATTR_GROUP_CAST item);\n-            FIXHFAILURE;\n-        }\n-        break;\n-        default:\n-        break;\n-    }\n-    }\n-    if (pctxt->nberrors != 0)\n-    goto exit_error;\n-    \/*\n-    * First compute the variety of simple types. This is needed as\n-    * a separate step, since otherwise we won't be able to detect\n-    * circular union types in all cases.\n-    *\/\n-    for (i = 0; i < nbItems; i++) {\n-    item = items[i];\n-    switch (item->type) {\n-            case XML_SCHEMA_TYPE_SIMPLE:\n-        if (WXS_IS_TYPE_NOT_FIXED_1((xmlSchemaTypePtr) item)) {\n-            xmlSchemaFixupSimpleTypeStageOne(pctxt,\n-            (xmlSchemaTypePtr) item);\n-            FIXHFAILURE;\n-        }\n-        break;\n-        default:\n-        break;\n-    }\n-    }\n-    if (pctxt->nberrors != 0)\n-    goto exit_error;\n-    \/*\n-    * Detect circular union types. Note that this needs the variety to\n-    * be already computed.\n-    *\/\n-    for (i = 0; i < nbItems; i++) {\n-    item = items[i];\n-    switch (item->type) {\n-            case XML_SCHEMA_TYPE_SIMPLE:\n-        if (((xmlSchemaTypePtr) item)->memberTypes != NULL) {\n-            xmlSchemaCheckUnionTypeDefCircular(pctxt,\n-            (xmlSchemaTypePtr) item);\n-            FIXHFAILURE;\n-        }\n-        break;\n-        default:\n-        break;\n-    }\n-    }\n-    if (pctxt->nberrors != 0)\n-    goto exit_error;\n-\n-    \/*\n-    * Do the complete type fixup for simple types.\n-    *\/\n-    for (i = 0; i < nbItems; i++) {\n-    item = items[i];\n-    switch (item->type) {\n-            case XML_SCHEMA_TYPE_SIMPLE:\n-        if (WXS_IS_TYPE_NOT_FIXED(WXS_TYPE_CAST item)) {\n-            xmlSchemaFixupSimpleTypeStageTwo(pctxt, WXS_TYPE_CAST item);\n-            FIXHFAILURE;\n-        }\n-        break;\n-        default:\n-        break;\n-    }\n-    }\n-    if (pctxt->nberrors != 0)\n-    goto exit_error;\n-    \/*\n-    * At this point we need build and check all simple types.\n-    *\/\n-    \/*\n-    * Apply constraints for attribute declarations.\n-    *\/\n-    for (i = 0; i < nbItems; i++) {\n-    item = items[i];\n-    switch (item->type) {\n-        case XML_SCHEMA_TYPE_ATTRIBUTE:\n-        xmlSchemaCheckAttrPropsCorrect(pctxt, WXS_ATTR_CAST item);\n-        FIXHFAILURE;\n-        break;\n-        default:\n-        break;\n-    }\n-    }\n-    if (pctxt->nberrors != 0)\n-    goto exit_error;\n-    \/*\n-    * Apply constraints for attribute uses.\n-    *\/\n-    for (i = 0; i < nbItems; i++) {\n-    item = items[i];\n-    switch (item->type) {\n-        case XML_SCHEMA_TYPE_ATTRIBUTE_USE:\n-        if (((xmlSchemaAttributeUsePtr)item)->defValue != NULL) {\n-            xmlSchemaCheckAttrUsePropsCorrect(pctxt,\n-            WXS_ATTR_USE_CAST item);\n-            FIXHFAILURE;\n-        }\n-        break;\n-        default:\n-        break;\n-    }\n-    }\n-    if (pctxt->nberrors != 0)\n-    goto exit_error;\n-\n-    \/*\n-    * Apply constraints for attribute group definitions.\n-    *\/\n-    for (i = 0; i < nbItems; i++) {\n-    item = items[i];\n-    switch (item->type) {\n-    case XML_SCHEMA_TYPE_ATTRIBUTEGROUP:\n-        if (( (WXS_ATTR_GROUP_CAST item)->attrUses != NULL) &&\n-        ( (WXS_LIST_CAST (WXS_ATTR_GROUP_CAST item)->attrUses)->nbItems > 1))\n-        {\n-        xmlSchemaCheckAGPropsCorrect(pctxt, WXS_ATTR_GROUP_CAST item);\n-        FIXHFAILURE;\n-        }\n-        break;\n-    default:\n-        break;\n-    }\n-    }\n-    if (pctxt->nberrors != 0)\n-    goto exit_error;\n-\n-    \/*\n-    * Apply constraints for redefinitions.\n-    *\/\n-    if (WXS_CONSTRUCTOR(pctxt)->redefs != NULL)\n-    xmlSchemaCheckSRCRedefineSecond(pctxt);\n-    if (pctxt->nberrors != 0)\n-    goto exit_error;\n-\n-    \/*\n-    * Complex types are built and checked.\n-    *\/\n-    for (i = 0; i < nbItems; i++) {\n-    item = con->pending->items[i];\n-    switch (item->type) {\n-        case XML_SCHEMA_TYPE_COMPLEX:\n-        if (WXS_IS_TYPE_NOT_FIXED(WXS_TYPE_CAST item)) {\n-            xmlSchemaFixupComplexType(pctxt, WXS_TYPE_CAST item);\n-            FIXHFAILURE;\n-        }\n-        break;\n-        default:\n-        break;\n-    }\n-    }\n-    if (pctxt->nberrors != 0)\n-    goto exit_error;\n-\n-    \/*\n-    * The list could have changed, since xmlSchemaFixupComplexType()\n-    * will create particles and model groups in some cases.\n-    *\/\n-    items = (xmlSchemaTreeItemPtr *) con->pending->items;\n-    nbItems = con->pending->nbItems;\n-\n-    \/*\n-    * Apply some constraints for element declarations.\n-    *\/\n-    for (i = 0; i < nbItems; i++) {\n-    item = items[i];\n-    switch (item->type) {\n-        case XML_SCHEMA_TYPE_ELEMENT:\n-        elemDecl = (xmlSchemaElementPtr) item;\n-\n-        if ((elemDecl->flags & XML_SCHEMAS_ELEM_INTERNAL_CHECKED) == 0)\n-        {\n-            xmlSchemaCheckElementDeclComponent(\n-            (xmlSchemaElementPtr) elemDecl, pctxt);\n-            FIXHFAILURE;\n-        }\n-\n-#ifdef WXS_ELEM_DECL_CONS_ENABLED\n-        \/*\n-        * Schema Component Constraint: Element Declarations Consistent\n-        * Apply this constraint to local types of element declarations.\n-        *\/\n-        if ((WXS_ELEM_TYPEDEF(elemDecl) != NULL) &&\n-            (WXS_IS_COMPLEX(WXS_ELEM_TYPEDEF(elemDecl))) &&\n-            (WXS_TYPE_IS_LOCAL(WXS_ELEM_TYPEDEF(elemDecl))))\n-        {\n-            xmlSchemaCheckElementDeclConsistent(pctxt,\n-            WXS_BASIC_CAST elemDecl,\n-            WXS_TYPE_PARTICLE(WXS_ELEM_TYPEDEF(elemDecl)),\n-            NULL, NULL, 0);\n-        }\n-#endif\n-        break;\n-        default:\n-        break;\n-    }\n-    }\n-    if (pctxt->nberrors != 0)\n-    goto exit_error;\n-\n-    \/*\n-    * Finally we can build the automaton from the content model of\n-    * complex types.\n-    *\/\n-\n-    for (i = 0; i < nbItems; i++) {\n-    item = items[i];\n-    switch (item->type) {\n-        case XML_SCHEMA_TYPE_COMPLEX:\n-        xmlSchemaBuildContentModel((xmlSchemaTypePtr) item, pctxt);\n-        \/* FIXHFAILURE; *\/\n-        break;\n-        default:\n-        break;\n-    }\n-    }\n-    if (pctxt->nberrors != 0)\n-    goto exit_error;\n-    \/*\n-    * URGENT TODO: cos-element-consistent\n-    *\/\n-    goto exit;\n-\n-exit_error:\n-    ret = pctxt->err;\n-    goto exit;\n-\n-exit_failure:\n-    ret = -1;\n-\n-exit:\n-    \/*\n-    * Reset the constructor. This is needed for XSI acquisition, since\n-    * those items will be processed over and over again for every XSI\n-    * if not cleared here.\n-    *\/\n-    con->bucket = oldbucket;\n-    con->pending->nbItems = 0;\n-    if (con->substGroups != NULL) {\n-    xmlHashFree(con->substGroups, xmlSchemaSubstGroupFreeEntry);\n-    con->substGroups = NULL;\n-    }\n-    if (con->redefs != NULL) {\n-    xmlSchemaRedefListFree(con->redefs);\n-    con->redefs = NULL;\n-    }\n-    return(ret);\n-}\n-\/**\n- * xmlSchemaParse:\n- * @ctxt:  a schema validation context\n- *\n- * parse a schema definition resource and build an internal\n- * XML Schema structure which can be used to validate instances.\n- *\n- * Returns the internal XML Schema structure built from the resource or\n- *         NULL in case of error\n- *\/\n-xmlSchemaPtr\n-xmlSchemaParse(xmlSchemaParserCtxtPtr ctxt)\n-{\n-    xmlSchemaPtr mainSchema = NULL;\n-    xmlSchemaBucketPtr bucket = NULL;\n-    int res;\n-\n-    \/*\n-    * This one is used if the schema to be parsed was specified via\n-    * the API; i.e. not automatically by the validated instance document.\n-    *\/\n-\n-    if (xmlSchemaInitTypes() < 0)\n-        return (NULL);\n-\n-    if (ctxt == NULL)\n-        return (NULL);\n-\n-    \/* TODO: Init the context. Is this all we need?*\/\n-    ctxt->nberrors = 0;\n-    ctxt->err = 0;\n-    ctxt->counter = 0;\n-\n-    \/* Create the *main* schema. *\/\n-    mainSchema = xmlSchemaNewSchema(ctxt);\n-    if (mainSchema == NULL)\n-    goto exit_failure;\n-    \/*\n-    * Create the schema constructor.\n-    *\/\n-    if (ctxt->constructor == NULL) {\n-    ctxt->constructor = xmlSchemaConstructionCtxtCreate(ctxt->dict);\n-    if (ctxt->constructor == NULL)\n-        goto exit_failure;\n-    \/* Take ownership of the constructor to be able to free it. *\/\n-    ctxt->ownsConstructor = 1;\n-    }\n-    ctxt->constructor->mainSchema = mainSchema;\n-    \/*\n-    * Locate and add the schema document.\n-    *\/\n-    res = xmlSchemaAddSchemaDoc(ctxt, XML_SCHEMA_SCHEMA_MAIN,\n-    ctxt->URL, ctxt->doc, ctxt->buffer, ctxt->size, NULL,\n-    NULL, NULL, &bucket);\n-    if (res == -1)\n-    goto exit_failure;\n-    if (res != 0)\n-    goto exit;\n-\n-    if (bucket == NULL) {\n-    \/* TODO: Error code, actually we failed to *locate* the schema. *\/\n-    if (ctxt->URL)\n-        xmlSchemaCustomErr(ACTXT_CAST ctxt, XML_SCHEMAP_FAILED_LOAD,\n-        NULL, NULL,\n-        \"Failed to locate the main schema resource at '%s'\",\n-        ctxt->URL, NULL);\n-    else\n-        xmlSchemaCustomErr(ACTXT_CAST ctxt, XML_SCHEMAP_FAILED_LOAD,\n-        NULL, NULL,\n-        \"Failed to locate the main schema resource\",\n-            NULL, NULL);\n-    goto exit;\n-    }\n-    \/* Then do the parsing for good. *\/\n-    if (xmlSchemaParseNewDocWithContext(ctxt, mainSchema, bucket) == -1)\n-    goto exit_failure;\n-    if (ctxt->nberrors != 0)\n-    goto exit;\n-\n-    mainSchema->doc = bucket->doc;\n-    mainSchema->preserve = ctxt->preserve;\n-\n-    ctxt->schema = mainSchema;\n-\n-    if (xmlSchemaFixupComponents(ctxt, WXS_CONSTRUCTOR(ctxt)->mainBucket) == -1)\n-    goto exit_failure;\n-\n-    \/*\n-    * TODO: This is not nice, since we cannot distinguish from the\n-    * result if there was an internal error or not.\n-    *\/\n-exit:\n-    if (ctxt->nberrors != 0) {\n-    if (mainSchema) {\n-        xmlSchemaFree(mainSchema);\n-        mainSchema = NULL;\n-    }\n-    if (ctxt->constructor) {\n-        xmlSchemaConstructionCtxtFree(ctxt->constructor);\n-        ctxt->constructor = NULL;\n-        ctxt->ownsConstructor = 0;\n-    }\n-    }\n-    ctxt->schema = NULL;\n-    return(mainSchema);\n-exit_failure:\n-    \/*\n-    * Quite verbose, but should catch internal errors, which were\n-    * not communicated.\n-    *\/\n-    if (mainSchema) {\n-        xmlSchemaFree(mainSchema);\n-    mainSchema = NULL;\n-    }\n-    if (ctxt->constructor) {\n-    xmlSchemaConstructionCtxtFree(ctxt->constructor);\n-    ctxt->constructor = NULL;\n-    ctxt->ownsConstructor = 0;\n-    }\n-    PERROR_INT2(\"xmlSchemaParse\",\n-    \"An internal error occurred\");\n-    ctxt->schema = NULL;\n-    return(NULL);\n-}\n-\n-\/**\n- * xmlSchemaSetParserErrors:\n- * @ctxt:  a schema validation context\n- * @err:  the error callback\n- * @warn:  the warning callback\n- * @ctx:  contextual data for the callbacks\n- *\n- * DEPRECATED: Use xmlSchemaSetParserStructuredErrors.\n- *\n- * Set the callback functions used to handle errors for a validation context\n- *\/\n-void\n-xmlSchemaSetParserErrors(xmlSchemaParserCtxtPtr ctxt,\n-                         xmlSchemaValidityErrorFunc err,\n-                         xmlSchemaValidityWarningFunc warn, void *ctx)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    ctxt->error = err;\n-    ctxt->warning = warn;\n-    ctxt->errCtxt = ctx;\n-    if (ctxt->vctxt != NULL)\n-    xmlSchemaSetValidErrors(ctxt->vctxt, err, warn, ctx);\n-}\n-\n-\/**\n- * xmlSchemaSetParserStructuredErrors:\n- * @ctxt:  a schema parser context\n- * @serror:  the structured error function\n- * @ctx: the functions context\n- *\n- * Set the structured error callback\n- *\/\n-void\n-xmlSchemaSetParserStructuredErrors(xmlSchemaParserCtxtPtr ctxt,\n-                   xmlStructuredErrorFunc serror,\n-                   void *ctx)\n-{\n-    if (ctxt == NULL)\n-    return;\n-    ctxt->serror = serror;\n-    ctxt->errCtxt = ctx;\n-    if (ctxt->vctxt != NULL)\n-    xmlSchemaSetValidStructuredErrors(ctxt->vctxt, serror, ctx);\n-}\n-\n-\/**\n- * xmlSchemaGetParserErrors:\n- * @ctxt:  a XMl-Schema parser context\n- * @err: the error callback result\n- * @warn: the warning callback result\n- * @ctx: contextual data for the callbacks result\n- *\n- * Get the callback information used to handle errors for a parser context\n- *\n- * Returns -1 in case of failure, 0 otherwise\n- *\/\n-int\n-xmlSchemaGetParserErrors(xmlSchemaParserCtxtPtr ctxt,\n-             xmlSchemaValidityErrorFunc * err,\n-             xmlSchemaValidityWarningFunc * warn, void **ctx)\n-{\n-    if (ctxt == NULL)\n-        return(-1);\n-    if (err != NULL)\n-        *err = ctxt->error;\n-    if (warn != NULL)\n-        *warn = ctxt->warning;\n-    if (ctx != NULL)\n-        *ctx = ctxt->errCtxt;\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaFacetTypeToString:\n- * @type:  the facet type\n- *\n- * Convert the xmlSchemaTypeType to a char string.\n- *\n- * Returns the char string representation of the facet type if the\n- *     type is a facet and an \"Internal Error\" string otherwise.\n- *\/\n-static const xmlChar *\n-xmlSchemaFacetTypeToString(xmlSchemaTypeType type)\n-{\n-    switch (type) {\n-        case XML_SCHEMA_FACET_PATTERN:\n-            return (BAD_CAST \"pattern\");\n-        case XML_SCHEMA_FACET_MAXEXCLUSIVE:\n-            return (BAD_CAST \"maxExclusive\");\n-        case XML_SCHEMA_FACET_MAXINCLUSIVE:\n-            return (BAD_CAST \"maxInclusive\");\n-        case XML_SCHEMA_FACET_MINEXCLUSIVE:\n-            return (BAD_CAST \"minExclusive\");\n-        case XML_SCHEMA_FACET_MININCLUSIVE:\n-            return (BAD_CAST \"minInclusive\");\n-        case XML_SCHEMA_FACET_WHITESPACE:\n-            return (BAD_CAST \"whiteSpace\");\n-        case XML_SCHEMA_FACET_ENUMERATION:\n-            return (BAD_CAST \"enumeration\");\n-        case XML_SCHEMA_FACET_LENGTH:\n-            return (BAD_CAST \"length\");\n-        case XML_SCHEMA_FACET_MAXLENGTH:\n-            return (BAD_CAST \"maxLength\");\n-        case XML_SCHEMA_FACET_MINLENGTH:\n-            return (BAD_CAST \"minLength\");\n-        case XML_SCHEMA_FACET_TOTALDIGITS:\n-            return (BAD_CAST \"totalDigits\");\n-        case XML_SCHEMA_FACET_FRACTIONDIGITS:\n-            return (BAD_CAST \"fractionDigits\");\n-        default:\n-            break;\n-    }\n-    return (BAD_CAST \"Internal Error\");\n-}\n-\n-static xmlSchemaWhitespaceValueType\n-xmlSchemaGetWhiteSpaceFacetValue(xmlSchemaTypePtr type)\n-{\n-    \/*\n-    * The normalization type can be changed only for types which are derived\n-    * from xsd:string.\n-    *\/\n-    if (type->type == XML_SCHEMA_TYPE_BASIC) {\n-    \/*\n-    * Note that we assume a whitespace of preserve for anySimpleType.\n-    *\/\n-    if ((type->builtInType == XML_SCHEMAS_STRING) ||\n-        (type->builtInType == XML_SCHEMAS_ANYSIMPLETYPE))\n-        return(XML_SCHEMA_WHITESPACE_PRESERVE);\n-    else if (type->builtInType == XML_SCHEMAS_NORMSTRING)\n-        return(XML_SCHEMA_WHITESPACE_REPLACE);\n-    else {\n-        \/*\n-        * For all `atomic` datatypes other than string (and types `derived`\n-        * by `restriction` from it) the value of whiteSpace is fixed to\n-        * collapse\n-        * Note that this includes built-in list datatypes.\n-        *\/\n-        return(XML_SCHEMA_WHITESPACE_COLLAPSE);\n-    }\n-    } else if (WXS_IS_LIST(type)) {\n-    \/*\n-    * For list types the facet \"whiteSpace\" is fixed to \"collapse\".\n-    *\/\n-    return (XML_SCHEMA_WHITESPACE_COLLAPSE);\n-    } else if (WXS_IS_UNION(type)) {\n-    return (XML_SCHEMA_WHITESPACE_UNKNOWN);\n-    } else if (WXS_IS_ATOMIC(type)) {\n-    if (type->flags & XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE)\n-        return (XML_SCHEMA_WHITESPACE_PRESERVE);\n-    else if (type->flags & XML_SCHEMAS_TYPE_WHITESPACE_REPLACE)\n-        return (XML_SCHEMA_WHITESPACE_REPLACE);\n-    else\n-        return (XML_SCHEMA_WHITESPACE_COLLAPSE);\n-    }\n-    return (-1);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Simple type validation                *\n- *                                    *\n- ************************************************************************\/\n-\n-\n-\/************************************************************************\n- *                                    *\n- *            DOM Validation code                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlSchemaAssembleByLocation:\n- * @pctxt:  a schema parser context\n- * @vctxt:  a schema validation context\n- * @schema: the existing schema\n- * @node: the node that fired the assembling\n- * @nsName: the namespace name of the new schema\n- * @location: the location of the schema\n- *\n- * Expands an existing schema by an additional schema.\n- *\n- * Returns 0 if the new schema is correct, a positive error code\n- * number otherwise and -1 in case of an internal or API error.\n- *\/\n-static int\n-xmlSchemaAssembleByLocation(xmlSchemaValidCtxtPtr vctxt,\n-                xmlSchemaPtr schema,\n-                xmlNodePtr node,\n-                const xmlChar *nsName,\n-                const xmlChar *location)\n-{\n-    int ret = 0;\n-    xmlSchemaParserCtxtPtr pctxt;\n-    xmlSchemaBucketPtr bucket = NULL;\n-\n-    if ((vctxt == NULL) || (schema == NULL))\n-    return (-1);\n-\n-    if (vctxt->pctxt == NULL) {\n-    VERROR_INT(\"xmlSchemaAssembleByLocation\",\n-        \"no parser context available\");\n-    return(-1);\n-    }\n-    pctxt = vctxt->pctxt;\n-    if (pctxt->constructor == NULL) {\n-    PERROR_INT(\"xmlSchemaAssembleByLocation\",\n-        \"no constructor\");\n-    return(-1);\n-    }\n-    \/*\n-    * Acquire the schema document.\n-    *\/\n-    location = xmlSchemaBuildAbsoluteURI(pctxt->dict,\n-    location, node);\n-    \/*\n-    * Note that we pass XML_SCHEMA_SCHEMA_IMPORT here;\n-    * the process will automatically change this to\n-    * XML_SCHEMA_SCHEMA_MAIN if it is the first schema document.\n-    *\/\n-    ret = xmlSchemaAddSchemaDoc(pctxt, XML_SCHEMA_SCHEMA_IMPORT,\n-    location, NULL, NULL, 0, node, NULL, nsName,\n-    &bucket);\n-    if (ret != 0)\n-    return(ret);\n-    if (bucket == NULL) {\n-    \/*\n-    * Generate a warning that the document could not be located.\n-    *\/\n-    xmlSchemaCustomWarning(ACTXT_CAST vctxt, XML_SCHEMAV_MISC,\n-        node, NULL,\n-        \"The document at location '%s' could not be acquired\",\n-        location, NULL, NULL);\n-    return(ret);\n-    }\n-    \/*\n-    * The first located schema will be handled as if all other\n-    * schemas imported by XSI were imported by this first schema.\n-    *\/\n-    if ((bucket != NULL) &&\n-    (WXS_CONSTRUCTOR(pctxt)->bucket == NULL))\n-    WXS_CONSTRUCTOR(pctxt)->bucket = bucket;\n-    \/*\n-    * TODO: Is this handled like an import? I.e. is it not an error\n-    * if the schema cannot be located?\n-    *\/\n-    if ((bucket == NULL) || (! CAN_PARSE_SCHEMA(bucket)))\n-    return(0);\n-    \/*\n-    * We will reuse the parser context for every schema imported\n-    * directly via XSI. So reset the context.\n-    *\/\n-    pctxt->nberrors = 0;\n-    pctxt->err = 0;\n-    pctxt->doc = bucket->doc;\n-\n-    ret = xmlSchemaParseNewDocWithContext(pctxt, schema, bucket);\n-    if (ret == -1) {\n-    pctxt->doc = NULL;\n-    goto exit_failure;\n-    }\n-    \/* Paranoid error channelling. *\/\n-    if ((ret == 0) && (pctxt->nberrors != 0))\n-    ret = pctxt->err;\n-    if (pctxt->nberrors == 0) {\n-    \/*\n-    * Only bother to fixup pending components, if there was\n-    * no error yet.\n-    * For every XSI acquired schema (and its sub-schemata) we will\n-    * fixup the components.\n-    *\/\n-    xmlSchemaFixupComponents(pctxt, bucket);\n-    ret = pctxt->err;\n-    \/*\n-    * Not nice, but we need somehow to channel the schema parser\n-    * error to the validation context.\n-    *\/\n-    if ((ret != 0) && (vctxt->err == 0))\n-        vctxt->err = ret;\n-    vctxt->nberrors += pctxt->nberrors;\n-    } else {\n-    \/* Add to validation error sum. *\/\n-    vctxt->nberrors += pctxt->nberrors;\n-    }\n-    pctxt->doc = NULL;\n-    return(ret);\n-exit_failure:\n-    pctxt->doc = NULL;\n-    return (-1);\n-}\n-\n-static xmlSchemaAttrInfoPtr\n-xmlSchemaGetMetaAttrInfo(xmlSchemaValidCtxtPtr vctxt,\n-             int metaType)\n-{\n-    if (vctxt->nbAttrInfos == 0)\n-    return (NULL);\n-    {\n-    int i;\n-    xmlSchemaAttrInfoPtr iattr;\n-\n-    for (i = 0; i < vctxt->nbAttrInfos; i++) {\n-        iattr = vctxt->attrInfos[i];\n-        if (iattr->metaType == metaType)\n-        return (iattr);\n-    }\n-\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlSchemaAssembleByXSI:\n- * @vctxt:  a schema validation context\n- *\n- * Expands an existing schema by an additional schema using\n- * the xsi:schemaLocation or xsi:noNamespaceSchemaLocation attribute\n- * of an instance. If xsi:noNamespaceSchemaLocation is used, @noNamespace\n- * must be set to 1.\n- *\n- * Returns 0 if the new schema is correct, a positive error code\n- * number otherwise and -1 in case of an internal or API error.\n- *\/\n-static int\n-xmlSchemaAssembleByXSI(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    const xmlChar *cur, *end;\n-    const xmlChar *nsname = NULL, *location;\n-    int ret = 0;\n-    xmlSchemaAttrInfoPtr iattr;\n-\n-    \/*\n-    * Parse the value; we will assume an even number of values\n-    * to be given (this is how Xerces and XSV work).\n-    *\n-    * URGENT TODO: !! This needs to work for both\n-    * @noNamespaceSchemaLocation AND @schemaLocation on the same\n-    * element !!\n-    *\/\n-    iattr = xmlSchemaGetMetaAttrInfo(vctxt,\n-    XML_SCHEMA_ATTR_INFO_META_XSI_SCHEMA_LOC);\n-    if (iattr == NULL)\n-    iattr = xmlSchemaGetMetaAttrInfo(vctxt,\n-    XML_SCHEMA_ATTR_INFO_META_XSI_NO_NS_SCHEMA_LOC);\n-    if (iattr == NULL)\n-    return (0);\n-    cur = iattr->value;\n-    do {\n-    \/*\n-    * TODO: Move the string parsing mechanism away from here.\n-    *\/\n-    if (iattr->metaType == XML_SCHEMA_ATTR_INFO_META_XSI_SCHEMA_LOC) {\n-        \/*\n-        * Get the namespace name.\n-        *\/\n-        while (IS_BLANK_CH(*cur))\n-        cur++;\n-        end = cur;\n-        while ((*end != 0) && (!(IS_BLANK_CH(*end))))\n-        end++;\n-        if (end == cur)\n-        break;\n-        \/* TODO: Don't use the schema's dict. *\/\n-        nsname = xmlDictLookup(vctxt->schema->dict, cur, end - cur);\n-        cur = end;\n-    }\n-    \/*\n-    * Get the URI.\n-    *\/\n-    while (IS_BLANK_CH(*cur))\n-        cur++;\n-    end = cur;\n-    while ((*end != 0) && (!(IS_BLANK_CH(*end))))\n-        end++;\n-    if (end == cur) {\n-        if (iattr->metaType ==\n-        XML_SCHEMA_ATTR_INFO_META_XSI_SCHEMA_LOC)\n-        {\n-        \/*\n-        * If using @schemaLocation then tuples are expected.\n-        * I.e. the namespace name *and* the document's URI.\n-        *\/\n-        xmlSchemaCustomWarning(ACTXT_CAST vctxt, XML_SCHEMAV_MISC,\n-            iattr->node, NULL,\n-            \"The value must consist of tuples: the target namespace \"\n-            \"name and the document's URI\", NULL, NULL, NULL);\n-        }\n-        break;\n-    }\n-    \/* TODO: Don't use the schema's dict. *\/\n-    location = xmlDictLookup(vctxt->schema->dict, cur, end - cur);\n-    cur = end;\n-    ret = xmlSchemaAssembleByLocation(vctxt, vctxt->schema,\n-        iattr->node, nsname, location);\n-    if (ret == -1) {\n-        VERROR_INT(\"xmlSchemaAssembleByXSI\",\n-        \"assembling schemata\");\n-        return (-1);\n-    }\n-    } while (*cur != 0);\n-    return (ret);\n-}\n-\n-static const xmlChar *\n-xmlSchemaLookupNamespace(xmlSchemaValidCtxtPtr vctxt,\n-             const xmlChar *prefix)\n-{\n-    if (vctxt->sax != NULL) {\n-    int i, j;\n-    xmlSchemaNodeInfoPtr inode;\n-\n-    for (i = vctxt->depth; i >= 0; i--) {\n-        if (vctxt->elemInfos[i]->nbNsBindings != 0) {\n-        inode = vctxt->elemInfos[i];\n-        for (j = 0; j < inode->nbNsBindings * 2; j += 2) {\n-            if (((prefix == NULL) &&\n-                (inode->nsBindings[j] == NULL)) ||\n-            ((prefix != NULL) && xmlStrEqual(prefix,\n-                inode->nsBindings[j]))) {\n-\n-            \/*\n-            * Note that the namespace bindings are already\n-            * in a string dict.\n-            *\/\n-            return (inode->nsBindings[j+1]);\n-            }\n-        }\n-        }\n-    }\n-    return (NULL);\n-#ifdef LIBXML_READER_ENABLED\n-    } else if (vctxt->reader != NULL) {\n-    xmlChar *nsName;\n-\n-    nsName = xmlTextReaderLookupNamespace(vctxt->reader, prefix);\n-    if (nsName != NULL) {\n-        const xmlChar *ret;\n-\n-        ret = xmlDictLookup(vctxt->dict, nsName, -1);\n-        xmlFree(nsName);\n-        return (ret);\n-    } else\n-        return (NULL);\n-#endif\n-    } else {\n-    xmlNsPtr ns;\n-\n-    if ((vctxt->inode->node == NULL) ||\n-        (vctxt->inode->node->doc == NULL)) {\n-        VERROR_INT(\"xmlSchemaLookupNamespace\",\n-        \"no node or node's doc available\");\n-        return (NULL);\n-    }\n-    ns = xmlSearchNs(vctxt->inode->node->doc,\n-        vctxt->inode->node, prefix);\n-    if (ns != NULL)\n-        return (ns->href);\n-    return (NULL);\n-    }\n-}\n-\n-\/*\n-* This one works on the schema of the validation context.\n-*\/\n-static int\n-xmlSchemaValidateNotation(xmlSchemaValidCtxtPtr vctxt,\n-              xmlSchemaPtr schema,\n-              xmlNodePtr node,\n-              const xmlChar *value,\n-              xmlSchemaValPtr *val,\n-              int valNeeded)\n-{\n-    int ret;\n-\n-    if (vctxt && (vctxt->schema == NULL)) {\n-    VERROR_INT(\"xmlSchemaValidateNotation\",\n-        \"a schema is needed on the validation context\");\n-    return (-1);\n-    }\n-    ret = xmlValidateQName(value, 1);\n-    if (ret != 0)\n-    return (ret);\n-    {\n-    xmlChar *localName = NULL;\n-    xmlChar *prefix = NULL;\n-\n-    localName = xmlSplitQName2(value, &prefix);\n-    if (prefix != NULL) {\n-        const xmlChar *nsName = NULL;\n-\n-        if (vctxt != NULL)\n-        nsName = xmlSchemaLookupNamespace(vctxt, BAD_CAST prefix);\n-        else if (node != NULL) {\n-        xmlNsPtr ns = xmlSearchNs(node->doc, node, prefix);\n-        if (ns != NULL)\n-            nsName = ns->href;\n-        } else {\n-        xmlFree(prefix);\n-        xmlFree(localName);\n-        return (1);\n-        }\n-        if (nsName == NULL) {\n-        xmlFree(prefix);\n-        xmlFree(localName);\n-        return (1);\n-        }\n-        if (xmlSchemaGetNotation(schema, localName, nsName) != NULL) {\n-        if ((valNeeded) && (val != NULL)) {\n-            (*val) = xmlSchemaNewNOTATIONValue(xmlStrdup(localName),\n-                               xmlStrdup(nsName));\n-            if (*val == NULL)\n-            ret = -1;\n-        }\n-        } else\n-        ret = 1;\n-        xmlFree(prefix);\n-        xmlFree(localName);\n-    } else {\n-        if (xmlSchemaGetNotation(schema, value, NULL) != NULL) {\n-        if (valNeeded && (val != NULL)) {\n-            (*val) = xmlSchemaNewNOTATIONValue(\n-            BAD_CAST xmlStrdup(value), NULL);\n-            if (*val == NULL)\n-            ret = -1;\n-        }\n-        } else\n-        return (1);\n-    }\n-    }\n-    return (ret);\n-}\n-\n-static int\n-xmlSchemaVAddNodeQName(xmlSchemaValidCtxtPtr vctxt,\n-               const xmlChar* lname,\n-               const xmlChar* nsname)\n-{\n-    int i;\n-\n-    lname = xmlDictLookup(vctxt->dict, lname, -1);\n-    if (lname == NULL)\n-    return(-1);\n-    if (nsname != NULL) {\n-    nsname = xmlDictLookup(vctxt->dict, nsname, -1);\n-    if (nsname == NULL)\n-        return(-1);\n-    }\n-    for (i = 0; i < vctxt->nodeQNames->nbItems; i += 2) {\n-    if ((vctxt->nodeQNames->items [i] == lname) &&\n-        (vctxt->nodeQNames->items[i +1] == nsname))\n-        \/* Already there *\/\n-        return(i);\n-    }\n-    \/* Add new entry. *\/\n-    i = vctxt->nodeQNames->nbItems;\n-    xmlSchemaItemListAdd(vctxt->nodeQNames, (void *) lname);\n-    xmlSchemaItemListAdd(vctxt->nodeQNames, (void *) nsname);\n-    return(i);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *  Validation of identity-constraints (IDC)                            *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlSchemaAugmentIDC:\n- * @idcDef: the IDC definition\n- *\n- * Creates an augmented IDC definition item.\n- *\n- * Returns the item, or NULL on internal errors.\n- *\/\n-static void\n-xmlSchemaAugmentIDC(void *payload, void *data,\n-                    const xmlChar *name ATTRIBUTE_UNUSED)\n-{\n-    xmlSchemaIDCPtr idcDef = (xmlSchemaIDCPtr) payload;\n-    xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) data;\n-    xmlSchemaIDCAugPtr aidc;\n-\n-    aidc = (xmlSchemaIDCAugPtr) xmlMalloc(sizeof(xmlSchemaIDCAug));\n-    if (aidc == NULL) {\n-    xmlSchemaVErrMemory(vctxt);\n-    return;\n-    }\n-    aidc->keyrefDepth = -1;\n-    aidc->def = idcDef;\n-    aidc->next = NULL;\n-    if (vctxt->aidcs == NULL)\n-    vctxt->aidcs = aidc;\n-    else {\n-    aidc->next = vctxt->aidcs;\n-    vctxt->aidcs = aidc;\n-    }\n-    \/*\n-    * Save if we have keyrefs at all.\n-    *\/\n-    if ((vctxt->hasKeyrefs == 0) &&\n-    (idcDef->type == XML_SCHEMA_TYPE_IDC_KEYREF))\n-    vctxt->hasKeyrefs = 1;\n-}\n-\n-\/**\n- * xmlSchemaAugmentImportedIDC:\n- * @imported: the imported schema\n- *\n- * Creates an augmented IDC definition for the imported schema.\n- *\/\n-static void\n-xmlSchemaAugmentImportedIDC(void *payload, void *data,\n-                            const xmlChar *name ATTRIBUTE_UNUSED) {\n-    xmlSchemaImportPtr imported = (xmlSchemaImportPtr) payload;\n-    xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) data;\n-    if (imported->schema->idcDef != NULL) {\n-        xmlHashScan(imported->schema->idcDef, xmlSchemaAugmentIDC, vctxt);\n-    }\n-}\n-\n-\/**\n- * xmlSchemaIDCNewBinding:\n- * @idcDef: the IDC definition of this binding\n- *\n- * Creates a new IDC binding.\n- *\n- * Returns the new IDC binding, NULL on internal errors.\n- *\/\n-static xmlSchemaPSVIIDCBindingPtr\n-xmlSchemaIDCNewBinding(xmlSchemaIDCPtr idcDef)\n-{\n-    xmlSchemaPSVIIDCBindingPtr ret;\n-\n-    ret = (xmlSchemaPSVIIDCBindingPtr) xmlMalloc(\n-        sizeof(xmlSchemaPSVIIDCBinding));\n-    if (ret == NULL) {\n-    xmlSchemaVErrMemory(NULL);\n-    return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaPSVIIDCBinding));\n-    ret->definition = idcDef;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaIDCStoreNodeTableItem:\n- * @vctxt: the WXS validation context\n- * @item: the IDC node table item\n- *\n- * The validation context is used to store IDC node table items.\n- * They are stored to avoid copying them if IDC node-tables are merged\n- * with corresponding parent IDC node-tables (bubbling).\n- *\n- * Returns 0 if succeeded, -1 on internal errors.\n- *\/\n-static int\n-xmlSchemaIDCStoreNodeTableItem(xmlSchemaValidCtxtPtr vctxt,\n-                   xmlSchemaPSVIIDCNodePtr item)\n-{\n-    \/*\n-    * Add to global list.\n-    *\/\n-    if (vctxt->idcNodes == NULL) {\n-    vctxt->idcNodes = (xmlSchemaPSVIIDCNodePtr *)\n-        xmlMalloc(20 * sizeof(xmlSchemaPSVIIDCNodePtr));\n-    if (vctxt->idcNodes == NULL) {\n-        xmlSchemaVErrMemory(vctxt);\n-        return (-1);\n-    }\n-    vctxt->sizeIdcNodes = 20;\n-    } else if (vctxt->sizeIdcNodes <= vctxt->nbIdcNodes) {\n-    vctxt->sizeIdcNodes *= 2;\n-    vctxt->idcNodes = (xmlSchemaPSVIIDCNodePtr *)\n-        xmlRealloc(vctxt->idcNodes, vctxt->sizeIdcNodes *\n-        sizeof(xmlSchemaPSVIIDCNodePtr));\n-    if (vctxt->idcNodes == NULL) {\n-        xmlSchemaVErrMemory(vctxt);\n-        return (-1);\n-    }\n-    }\n-    vctxt->idcNodes[vctxt->nbIdcNodes++] = item;\n-\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaIDCStoreKey:\n- * @vctxt: the WXS validation context\n- * @item: the IDC key\n- *\n- * The validation context is used to store an IDC key.\n- *\n- * Returns 0 if succeeded, -1 on internal errors.\n- *\/\n-static int\n-xmlSchemaIDCStoreKey(xmlSchemaValidCtxtPtr vctxt,\n-             xmlSchemaPSVIIDCKeyPtr key)\n-{\n-    \/*\n-    * Add to global list.\n-    *\/\n-    if (vctxt->idcKeys == NULL) {\n-    vctxt->idcKeys = (xmlSchemaPSVIIDCKeyPtr *)\n-        xmlMalloc(40 * sizeof(xmlSchemaPSVIIDCKeyPtr));\n-    if (vctxt->idcKeys == NULL) {\n-        xmlSchemaVErrMemory(vctxt);\n-        return (-1);\n-    }\n-    vctxt->sizeIdcKeys = 40;\n-    } else if (vctxt->sizeIdcKeys <= vctxt->nbIdcKeys) {\n-    vctxt->sizeIdcKeys *= 2;\n-    vctxt->idcKeys = (xmlSchemaPSVIIDCKeyPtr *)\n-        xmlRealloc(vctxt->idcKeys, vctxt->sizeIdcKeys *\n-        sizeof(xmlSchemaPSVIIDCKeyPtr));\n-    if (vctxt->idcKeys == NULL) {\n-        xmlSchemaVErrMemory(vctxt);\n-        return (-1);\n-    }\n-    }\n-    vctxt->idcKeys[vctxt->nbIdcKeys++] = key;\n-\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaIDCAppendNodeTableItem:\n- * @bind: the IDC binding\n- * @ntItem: the node-table item\n- *\n- * Appends the IDC node-table item to the binding.\n- *\n- * Returns 0 on success and -1 on internal errors.\n- *\/\n-static int\n-xmlSchemaIDCAppendNodeTableItem(xmlSchemaPSVIIDCBindingPtr bind,\n-                xmlSchemaPSVIIDCNodePtr ntItem)\n-{\n-    if (bind->nodeTable == NULL) {\n-    bind->sizeNodes = 10;\n-    bind->nodeTable = (xmlSchemaPSVIIDCNodePtr *)\n-        xmlMalloc(10 * sizeof(xmlSchemaPSVIIDCNodePtr));\n-    if (bind->nodeTable == NULL) {\n-        xmlSchemaVErrMemory(NULL);\n-        return(-1);\n-    }\n-    } else if (bind->sizeNodes <= bind->nbNodes) {\n-    bind->sizeNodes *= 2;\n-    bind->nodeTable = (xmlSchemaPSVIIDCNodePtr *)\n-        xmlRealloc(bind->nodeTable, bind->sizeNodes *\n-        sizeof(xmlSchemaPSVIIDCNodePtr));\n-    if (bind->nodeTable == NULL) {\n-        xmlSchemaVErrMemory(NULL);\n-        return(-1);\n-    }\n-    }\n-    bind->nodeTable[bind->nbNodes++] = ntItem;\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaIDCAcquireBinding:\n- * @vctxt: the WXS validation context\n- * @matcher: the IDC matcher\n- *\n- * Looks up an PSVI IDC binding, for the IDC definition and\n- * of the given matcher. If none found, a new one is created\n- * and added to the IDC table.\n- *\n- * Returns an IDC binding or NULL on internal errors.\n- *\/\n-static xmlSchemaPSVIIDCBindingPtr\n-xmlSchemaIDCAcquireBinding(xmlSchemaValidCtxtPtr vctxt,\n-              xmlSchemaIDCMatcherPtr matcher)\n-{\n-    xmlSchemaNodeInfoPtr ielem;\n-\n-    ielem = vctxt->elemInfos[matcher->depth];\n-\n-    if (ielem->idcTable == NULL) {\n-    ielem->idcTable = xmlSchemaIDCNewBinding(matcher->aidc->def);\n-    if (ielem->idcTable == NULL)\n-        return (NULL);\n-    return(ielem->idcTable);\n-    } else {\n-    xmlSchemaPSVIIDCBindingPtr bind = NULL;\n-\n-    bind = ielem->idcTable;\n-    do {\n-        if (bind->definition == matcher->aidc->def)\n-        return(bind);\n-        if (bind->next == NULL) {\n-        bind->next = xmlSchemaIDCNewBinding(matcher->aidc->def);\n-        if (bind->next == NULL)\n-            return (NULL);\n-        return(bind->next);\n-        }\n-        bind = bind->next;\n-    } while (bind != NULL);\n-    }\n-    return (NULL);\n-}\n-\n-static xmlSchemaItemListPtr\n-xmlSchemaIDCAcquireTargetList(xmlSchemaValidCtxtPtr vctxt ATTRIBUTE_UNUSED,\n-                 xmlSchemaIDCMatcherPtr matcher)\n-{\n-    if (matcher->targets == NULL)\n-    matcher->targets = xmlSchemaItemListCreate();\n-    return(matcher->targets);\n-}\n-\n-\/**\n- * xmlSchemaIDCFreeKey:\n- * @key: the IDC key\n- *\n- * Frees an IDC key together with its compiled value.\n- *\/\n-static void\n-xmlSchemaIDCFreeKey(xmlSchemaPSVIIDCKeyPtr key)\n-{\n-    if (key->val != NULL)\n-    xmlSchemaFreeValue(key->val);\n-    xmlFree(key);\n-}\n-\n-\/**\n- * xmlSchemaIDCFreeBinding:\n- *\n- * Frees an IDC binding. Note that the node table-items\n- * are not freed.\n- *\/\n-static void\n-xmlSchemaIDCFreeBinding(xmlSchemaPSVIIDCBindingPtr bind)\n-{\n-    if (bind->nodeTable != NULL)\n-    xmlFree(bind->nodeTable);\n-    if (bind->dupls != NULL)\n-    xmlSchemaItemListFree(bind->dupls);\n-    xmlFree(bind);\n-}\n-\n-\/**\n- * xmlSchemaIDCFreeIDCTable:\n- * @bind: the first IDC binding in the list\n- *\n- * Frees an IDC table, i.e. all the IDC bindings in the list.\n- *\/\n-static void\n-xmlSchemaIDCFreeIDCTable(xmlSchemaPSVIIDCBindingPtr bind)\n-{\n-    xmlSchemaPSVIIDCBindingPtr prev;\n-\n-    while (bind != NULL) {\n-    prev = bind;\n-    bind = bind->next;\n-    xmlSchemaIDCFreeBinding(prev);\n-    }\n-}\n-\n-static void\n-xmlFreeIDCHashEntry (void *payload, const xmlChar *name ATTRIBUTE_UNUSED)\n-{\n-    xmlIDCHashEntryPtr e = payload, n;\n-    while (e) {\n-    n = e->next;\n-    xmlFree(e);\n-    e = n;\n-    }\n-}\n-\n-\/**\n- * xmlSchemaIDCFreeMatcherList:\n- * @matcher: the first IDC matcher in the list\n- *\n- * Frees a list of IDC matchers.\n- *\/\n-static void\n-xmlSchemaIDCFreeMatcherList(xmlSchemaIDCMatcherPtr matcher)\n-{\n-    xmlSchemaIDCMatcherPtr next;\n-\n-    while (matcher != NULL) {\n-    next = matcher->next;\n-    if (matcher->keySeqs != NULL) {\n-        int i;\n-        for (i = 0; i < matcher->sizeKeySeqs; i++)\n-        if (matcher->keySeqs[i] != NULL)\n-            xmlFree(matcher->keySeqs[i]);\n-        xmlFree(matcher->keySeqs);\n-    }\n-    if (matcher->targets != NULL) {\n-        if (matcher->idcType == XML_SCHEMA_TYPE_IDC_KEYREF) {\n-        int i;\n-        xmlSchemaPSVIIDCNodePtr idcNode;\n-        \/*\n-        * Node-table items for keyrefs are not stored globally\n-        * to the validation context, since they are not bubbled.\n-        * We need to free them here.\n-        *\/\n-        for (i = 0; i < matcher->targets->nbItems; i++) {\n-            idcNode =\n-            (xmlSchemaPSVIIDCNodePtr) matcher->targets->items[i];\n-            xmlFree(idcNode->keys);\n-            xmlFree(idcNode);\n-        }\n-        }\n-        xmlSchemaItemListFree(matcher->targets);\n-    }\n-    if (matcher->htab != NULL)\n-      xmlHashFree(matcher->htab, xmlFreeIDCHashEntry);\n-    xmlFree(matcher);\n-    matcher = next;\n-    }\n-}\n-\n-\/**\n- * xmlSchemaIDCReleaseMatcherList:\n- * @vctxt: the WXS validation context\n- * @matcher: the first IDC matcher in the list\n- *\n- * Caches a list of IDC matchers for reuse.\n- *\/\n-static void\n-xmlSchemaIDCReleaseMatcherList(xmlSchemaValidCtxtPtr vctxt,\n-                   xmlSchemaIDCMatcherPtr matcher)\n-{\n-    xmlSchemaIDCMatcherPtr next;\n-\n-    while (matcher != NULL) {\n-    next = matcher->next;\n-    if (matcher->keySeqs != NULL) {\n-        int i;\n-        \/*\n-        * Don't free the array, but only the content.\n-        *\/\n-        for (i = 0; i < matcher->sizeKeySeqs; i++)\n-        if (matcher->keySeqs[i] != NULL) {\n-            xmlFree(matcher->keySeqs[i]);\n-            matcher->keySeqs[i] = NULL;\n-        }\n-    }\n-    if (matcher->targets) {\n-        if (matcher->idcType == XML_SCHEMA_TYPE_IDC_KEYREF) {\n-        int i;\n-        xmlSchemaPSVIIDCNodePtr idcNode;\n-        \/*\n-        * Node-table items for keyrefs are not stored globally\n-        * to the validation context, since they are not bubbled.\n-        * We need to free them here.\n-        *\/\n-        for (i = 0; i < matcher->targets->nbItems; i++) {\n-            idcNode =\n-            (xmlSchemaPSVIIDCNodePtr) matcher->targets->items[i];\n-            xmlFree(idcNode->keys);\n-            xmlFree(idcNode);\n-        }\n-        }\n-        xmlSchemaItemListFree(matcher->targets);\n-        matcher->targets = NULL;\n-    }\n-    if (matcher->htab != NULL) {\n-        xmlHashFree(matcher->htab, xmlFreeIDCHashEntry);\n-        matcher->htab = NULL;\n-    }\n-    matcher->next = NULL;\n-    \/*\n-    * Cache the matcher.\n-    *\/\n-    if (vctxt->idcMatcherCache != NULL)\n-        matcher->nextCached = vctxt->idcMatcherCache;\n-    vctxt->idcMatcherCache = matcher;\n-\n-    matcher = next;\n-    }\n-}\n-\n-\/**\n- * xmlSchemaIDCAddStateObject:\n- * @vctxt: the WXS validation context\n- * @matcher: the IDC matcher\n- * @sel: the XPath information\n- * @parent: the parent \"selector\" state object if any\n- * @type: \"selector\" or \"field\"\n- *\n- * Creates\/reuses and activates state objects for the given\n- * XPath information; if the XPath expression consists of unions,\n- * multiple state objects are created for every unioned expression.\n- *\n- * Returns 0 on success and -1 on internal errors.\n- *\/\n-static int\n-xmlSchemaIDCAddStateObject(xmlSchemaValidCtxtPtr vctxt,\n-            xmlSchemaIDCMatcherPtr matcher,\n-            xmlSchemaIDCSelectPtr sel,\n-            int type)\n-{\n-    xmlSchemaIDCStateObjPtr sto;\n-\n-    \/*\n-    * Reuse the state objects from the pool.\n-    *\/\n-    if (vctxt->xpathStatePool != NULL) {\n-    sto = vctxt->xpathStatePool;\n-    vctxt->xpathStatePool = sto->next;\n-    sto->next = NULL;\n-    } else {\n-    \/*\n-    * Create a new state object.\n-    *\/\n-    sto = (xmlSchemaIDCStateObjPtr) xmlMalloc(sizeof(xmlSchemaIDCStateObj));\n-    if (sto == NULL) {\n-        xmlSchemaVErrMemory(NULL);\n-        return (-1);\n-    }\n-    memset(sto, 0, sizeof(xmlSchemaIDCStateObj));\n-    }\n-    \/*\n-    * Add to global list.\n-    *\/\n-    if (vctxt->xpathStates != NULL)\n-    sto->next = vctxt->xpathStates;\n-    vctxt->xpathStates = sto;\n-\n-    \/*\n-    * Free the old xpath validation context.\n-    *\/\n-    if (sto->xpathCtxt != NULL)\n-    xmlFreeStreamCtxt((xmlStreamCtxtPtr) sto->xpathCtxt);\n-\n-    \/*\n-    * Create a new XPath (pattern) validation context.\n-    *\/\n-    sto->xpathCtxt = (void *) xmlPatternGetStreamCtxt(\n-    (xmlPatternPtr) sel->xpathComp);\n-    if (sto->xpathCtxt == NULL) {\n-    VERROR_INT(\"xmlSchemaIDCAddStateObject\",\n-        \"failed to create an XPath validation context\");\n-    return (-1);\n-    }\n-    sto->type = type;\n-    sto->depth = vctxt->depth;\n-    sto->matcher = matcher;\n-    sto->sel = sel;\n-    sto->nbHistory = 0;\n-\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaXPathEvaluate:\n- * @vctxt: the WXS validation context\n- * @nodeType: the nodeType of the current node\n- *\n- * Evaluates all active XPath state objects.\n- *\n- * Returns the number of IC \"field\" state objects which resolved to\n- * this node, 0 if none resolved and -1 on internal errors.\n- *\/\n-static int\n-xmlSchemaXPathEvaluate(xmlSchemaValidCtxtPtr vctxt,\n-               xmlElementType nodeType)\n-{\n-    xmlSchemaIDCStateObjPtr sto, head = NULL, first;\n-    int res, resolved = 0, depth = vctxt->depth;\n-\n-    if (vctxt->xpathStates == NULL)\n-    return (0);\n-\n-    if (nodeType == XML_ATTRIBUTE_NODE)\n-    depth++;\n-    \/*\n-    * Process all active XPath state objects.\n-    *\/\n-    first = vctxt->xpathStates;\n-    sto = first;\n-    while (sto != head) {\n-    if (nodeType == XML_ELEMENT_NODE)\n-        res = xmlStreamPush((xmlStreamCtxtPtr) sto->xpathCtxt,\n-        vctxt->inode->localName, vctxt->inode->nsName);\n-    else\n-        res = xmlStreamPushAttr((xmlStreamCtxtPtr) sto->xpathCtxt,\n-        vctxt->inode->localName, vctxt->inode->nsName);\n-\n-    if (res == -1) {\n-        VERROR_INT(\"xmlSchemaXPathEvaluate\",\n-        \"calling xmlStreamPush()\");\n-        return (-1);\n-    }\n-    if (res == 0)\n-        goto next_sto;\n-    \/*\n-    * Full match.\n-    *\/\n-    \/*\n-    * Register a match in the state object history.\n-    *\/\n-    if (sto->history == NULL) {\n-        sto->history = (int *) xmlMalloc(5 * sizeof(int));\n-        if (sto->history == NULL) {\n-        xmlSchemaVErrMemory(NULL);\n-        return(-1);\n-        }\n-        sto->sizeHistory = 5;\n-    } else if (sto->sizeHistory <= sto->nbHistory) {\n-        sto->sizeHistory *= 2;\n-        sto->history = (int *) xmlRealloc(sto->history,\n-        sto->sizeHistory * sizeof(int));\n-        if (sto->history == NULL) {\n-        xmlSchemaVErrMemory(NULL);\n-        return(-1);\n-        }\n-    }\n-    sto->history[sto->nbHistory++] = depth;\n-\n-    if (sto->type == XPATH_STATE_OBJ_TYPE_IDC_SELECTOR) {\n-        xmlSchemaIDCSelectPtr sel;\n-        \/*\n-        * Activate state objects for the IDC fields of\n-        * the IDC selector.\n-        *\/\n-        sel = sto->matcher->aidc->def->fields;\n-        while (sel != NULL) {\n-        if (xmlSchemaIDCAddStateObject(vctxt, sto->matcher,\n-            sel, XPATH_STATE_OBJ_TYPE_IDC_FIELD) == -1)\n-            return (-1);\n-        sel = sel->next;\n-        }\n-    } else if (sto->type == XPATH_STATE_OBJ_TYPE_IDC_FIELD) {\n-        \/*\n-        * An IDC key node was found by the IDC field.\n-        *\/\n-        \/*\n-        * Notify that the character value of this node is\n-        * needed.\n-        *\/\n-        if (resolved == 0) {\n-        if ((vctxt->inode->flags &\n-            XML_SCHEMA_NODE_INFO_VALUE_NEEDED) == 0)\n-        vctxt->inode->flags |= XML_SCHEMA_NODE_INFO_VALUE_NEEDED;\n-        }\n-        resolved++;\n-    }\n-next_sto:\n-    if (sto->next == NULL) {\n-        \/*\n-        * Evaluate field state objects created on this node as well.\n-        *\/\n-        head = first;\n-        sto = vctxt->xpathStates;\n-    } else\n-        sto = sto->next;\n-    }\n-    return (resolved);\n-}\n-\n-static const xmlChar *\n-xmlSchemaFormatIDCKeySequence_1(xmlSchemaValidCtxtPtr vctxt,\n-                xmlChar **buf,\n-                xmlSchemaPSVIIDCKeyPtr *seq,\n-                int count, int for_hash)\n-{\n-    int i, res;\n-    xmlChar *value = NULL;\n-\n-    *buf = xmlStrdup(BAD_CAST \"[\");\n-    for (i = 0; i < count; i++) {\n-    *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-    if (!for_hash)\n-        res = xmlSchemaGetCanonValueWhtspExt(seq[i]->val,\n-            xmlSchemaGetWhiteSpaceFacetValue(seq[i]->type),\n-            &value);\n-    else {\n-        res = xmlSchemaGetCanonValueHash(seq[i]->val, &value);\n-    }\n-    if (res == 0)\n-        *buf = xmlStrcat(*buf, BAD_CAST value);\n-    else {\n-        VERROR_INT(\"xmlSchemaFormatIDCKeySequence\",\n-        \"failed to compute a canonical value\");\n-        *buf = xmlStrcat(*buf, BAD_CAST \"???\");\n-    }\n-    if (i < count -1)\n-        *buf = xmlStrcat(*buf, BAD_CAST \"', \");\n-    else\n-        *buf = xmlStrcat(*buf, BAD_CAST \"'\");\n-    if (value != NULL) {\n-        xmlFree(value);\n-        value = NULL;\n-    }\n-    }\n-    *buf = xmlStrcat(*buf, BAD_CAST \"]\");\n-\n-    return (BAD_CAST *buf);\n-}\n-\n-static const xmlChar *\n-xmlSchemaFormatIDCKeySequence(xmlSchemaValidCtxtPtr vctxt,\n-                  xmlChar **buf,\n-                  xmlSchemaPSVIIDCKeyPtr *seq,\n-                  int count)\n-{\n-    return xmlSchemaFormatIDCKeySequence_1(vctxt, buf, seq, count, 0);\n-}\n-\n-static const xmlChar *\n-xmlSchemaHashKeySequence(xmlSchemaValidCtxtPtr vctxt,\n-             xmlChar **buf,\n-             xmlSchemaPSVIIDCKeyPtr *seq,\n-             int count)\n-{\n-    return xmlSchemaFormatIDCKeySequence_1(vctxt, buf, seq, count, 1);\n-}\n-\n-\/**\n- * xmlSchemaXPathPop:\n- * @vctxt: the WXS validation context\n- *\n- * Pops all XPath states.\n- *\n- * Returns 0 on success and -1 on internal errors.\n- *\/\n-static int\n-xmlSchemaXPathPop(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    xmlSchemaIDCStateObjPtr sto;\n-    int res;\n-\n-    if (vctxt->xpathStates == NULL)\n-    return(0);\n-    sto = vctxt->xpathStates;\n-    do {\n-    res = xmlStreamPop((xmlStreamCtxtPtr) sto->xpathCtxt);\n-    if (res == -1)\n-        return (-1);\n-    sto = sto->next;\n-    } while (sto != NULL);\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaXPathProcessHistory:\n- * @vctxt: the WXS validation context\n- * @type: the simple\/complex type of the current node if any at all\n- * @val: the precompiled value\n- *\n- * Processes and pops the history items of the IDC state objects.\n- * IDC key-sequences are validated\/created on IDC bindings.\n- *\n- * Returns 0 on success and -1 on internal errors.\n- *\/\n-static int\n-xmlSchemaXPathProcessHistory(xmlSchemaValidCtxtPtr vctxt,\n-                 int depth)\n-{\n-    xmlSchemaIDCStateObjPtr sto, nextsto;\n-    int res, matchDepth;\n-    xmlSchemaPSVIIDCKeyPtr key = NULL;\n-    xmlSchemaTypePtr type = vctxt->inode->typeDef, simpleType = NULL;\n-\n-    if (vctxt->xpathStates == NULL)\n-    return (0);\n-    sto = vctxt->xpathStates;\n-\n-    \/*\n-    * Evaluate the state objects.\n-    *\/\n-    while (sto != NULL) {\n-    res = xmlStreamPop((xmlStreamCtxtPtr) sto->xpathCtxt);\n-    if (res == -1) {\n-        VERROR_INT(\"xmlSchemaXPathProcessHistory\",\n-        \"calling xmlStreamPop()\");\n-        return (-1);\n-    }\n-    if (sto->nbHistory == 0)\n-        goto deregister_check;\n-\n-    matchDepth = sto->history[sto->nbHistory -1];\n-\n-    \/*\n-    * Only matches at the current depth are of interest.\n-    *\/\n-    if (matchDepth != depth) {\n-        sto = sto->next;\n-        continue;\n-    }\n-    if (sto->type == XPATH_STATE_OBJ_TYPE_IDC_FIELD) {\n-        \/*\n-        * NOTE: According to\n-        *   http:\/\/www.w3.org\/Bugs\/Public\/show_bug.cgi?id=2198\n-        *   ... the simple-content of complex types is also allowed.\n-        *\/\n-\n-        if (WXS_IS_COMPLEX(type)) {\n-        if (WXS_HAS_SIMPLE_CONTENT(type)) {\n-            \/*\n-            * Sanity check for complex types with simple content.\n-            *\/\n-            simpleType = type->contentTypeDef;\n-            if (simpleType == NULL) {\n-            VERROR_INT(\"xmlSchemaXPathProcessHistory\",\n-                \"field resolves to a CT with simple content \"\n-                \"but the CT is missing the ST definition\");\n-            return (-1);\n-            }\n-        } else\n-            simpleType = NULL;\n-        } else\n-        simpleType = type;\n-        if (simpleType == NULL) {\n-        xmlChar *str = NULL;\n-\n-        \/*\n-        * Not qualified if the field resolves to a node of non\n-        * simple type.\n-        *\/\n-        xmlSchemaCustomErr(ACTXT_CAST vctxt,\n-            XML_SCHEMAV_CVC_IDC, NULL,\n-            WXS_BASIC_CAST sto->matcher->aidc->def,\n-            \"The XPath '%s' of a field of %s does evaluate to a node of \"\n-            \"non-simple type\",\n-            sto->sel->xpath,\n-            xmlSchemaGetIDCDesignation(&str, sto->matcher->aidc->def));\n-        FREE_AND_NULL(str);\n-        sto->nbHistory--;\n-        goto deregister_check;\n-        }\n-\n-        if ((key == NULL) && (vctxt->inode->val == NULL)) {\n-        \/*\n-        * Failed to provide the normalized value; maybe\n-        * the value was invalid.\n-        *\/\n-        VERROR(XML_SCHEMAV_CVC_IDC,\n-            WXS_BASIC_CAST sto->matcher->aidc->def,\n-            \"Warning: No precomputed value available, the value \"\n-            \"was either invalid or something strange happened\");\n-        sto->nbHistory--;\n-        goto deregister_check;\n-        } else {\n-        xmlSchemaIDCMatcherPtr matcher = sto->matcher;\n-        xmlSchemaPSVIIDCKeyPtr *keySeq;\n-        int pos, idx;\n-\n-        \/*\n-        * The key will be anchored on the matcher's list of\n-        * key-sequences. The position in this list is determined\n-        * by the target node's depth relative to the matcher's\n-        * depth of creation (i.e. the depth of the scope element).\n-        *\n-        * Element        Depth    Pos   List-entries\n-        * <scope>          0              NULL\n-        *   <bar>          1              NULL\n-        *     <target\/>    2       2      target\n-        *   <bar>\n-                * <\/scope>\n-        *\n-        * The size of the list is only dependent on the depth of\n-        * the tree.\n-        * An entry will be NULLed in selector_leave, i.e. when\n-        * we hit the target's\n-        *\/\n-        pos = sto->depth - matcher->depth;\n-        idx = sto->sel->index;\n-\n-        \/*\n-        * Create\/grow the array of key-sequences.\n-        *\/\n-        if (matcher->keySeqs == NULL) {\n-            if (pos > 9)\n-            matcher->sizeKeySeqs = pos * 2;\n-            else\n-            matcher->sizeKeySeqs = 10;\n-            matcher->keySeqs = (xmlSchemaPSVIIDCKeyPtr **)\n-            xmlMalloc(matcher->sizeKeySeqs *\n-            sizeof(xmlSchemaPSVIIDCKeyPtr *));\n-            if (matcher->keySeqs == NULL) {\n-            xmlSchemaVErrMemory(NULL);\n-            return(-1);\n-            }\n-            memset(matcher->keySeqs, 0,\n-            matcher->sizeKeySeqs *\n-            sizeof(xmlSchemaPSVIIDCKeyPtr *));\n-        } else if (pos >= matcher->sizeKeySeqs) {\n-            int i = matcher->sizeKeySeqs;\n-\n-            matcher->sizeKeySeqs = pos * 2;\n-            matcher->keySeqs = (xmlSchemaPSVIIDCKeyPtr **)\n-            xmlRealloc(matcher->keySeqs,\n-            matcher->sizeKeySeqs *\n-            sizeof(xmlSchemaPSVIIDCKeyPtr *));\n-            if (matcher->keySeqs == NULL) {\n-            xmlSchemaVErrMemory(NULL);\n-            return (-1);\n-            }\n-            \/*\n-            * The array needs to be NULLed.\n-            * TODO: Use memset?\n-            *\/\n-            for (; i < matcher->sizeKeySeqs; i++)\n-            matcher->keySeqs[i] = NULL;\n-        }\n-\n-        \/*\n-        * Get\/create the key-sequence.\n-        *\/\n-        keySeq = matcher->keySeqs[pos];\n-        if (keySeq == NULL) {\n-            goto create_sequence;\n-        } else if (keySeq[idx] != NULL) {\n-            xmlChar *str = NULL;\n-            \/*\n-            * cvc-identity-constraint:\n-            * 3 For each node in the `target node set` all\n-            * of the {fields}, with that node as the context\n-            * node, evaluate to either an empty node-set or\n-            * a node-set with exactly one member, which must\n-            * have a simple type.\n-            *\n-            * The key was already set; report an error.\n-            *\/\n-            xmlSchemaCustomErr(ACTXT_CAST vctxt,\n-            XML_SCHEMAV_CVC_IDC, NULL,\n-            WXS_BASIC_CAST matcher->aidc->def,\n-            \"The XPath '%s' of a field of %s evaluates to a \"\n-            \"node-set with more than one member\",\n-            sto->sel->xpath,\n-            xmlSchemaGetIDCDesignation(&str, matcher->aidc->def));\n-            FREE_AND_NULL(str);\n-            sto->nbHistory--;\n-            goto deregister_check;\n-        } else\n-            goto create_key;\n-\n-create_sequence:\n-        \/*\n-        * Create a key-sequence.\n-        *\/\n-        keySeq = (xmlSchemaPSVIIDCKeyPtr *) xmlMalloc(\n-            matcher->aidc->def->nbFields *\n-            sizeof(xmlSchemaPSVIIDCKeyPtr));\n-        if (keySeq == NULL) {\n-            xmlSchemaVErrMemory(NULL);\n-            return(-1);\n-        }\n-        memset(keySeq, 0, matcher->aidc->def->nbFields *\n-            sizeof(xmlSchemaPSVIIDCKeyPtr));\n-        matcher->keySeqs[pos] = keySeq;\n-create_key:\n-        \/*\n-        * Create a key once per node only.\n-        *\/\n-        if (key == NULL) {\n-            key = (xmlSchemaPSVIIDCKeyPtr) xmlMalloc(\n-            sizeof(xmlSchemaPSVIIDCKey));\n-            if (key == NULL) {\n-            xmlSchemaVErrMemory(NULL);\n-            xmlFree(keySeq);\n-            matcher->keySeqs[pos] = NULL;\n-            return(-1);\n-            }\n-            \/*\n-            * Consume the compiled value.\n-            *\/\n-            key->type = simpleType;\n-            key->val = vctxt->inode->val;\n-            vctxt->inode->val = NULL;\n-            \/*\n-            * Store the key in a global list.\n-            *\/\n-            if (xmlSchemaIDCStoreKey(vctxt, key) == -1) {\n-            xmlSchemaIDCFreeKey(key);\n-            return (-1);\n-            }\n-        }\n-        keySeq[idx] = key;\n-        }\n-    } else if (sto->type == XPATH_STATE_OBJ_TYPE_IDC_SELECTOR) {\n-\n-        xmlSchemaPSVIIDCKeyPtr **keySeq = NULL;\n-        \/* xmlSchemaPSVIIDCBindingPtr bind; *\/\n-        xmlSchemaPSVIIDCNodePtr ntItem;\n-        xmlSchemaIDCMatcherPtr matcher;\n-        xmlSchemaIDCPtr idc;\n-        xmlSchemaItemListPtr targets;\n-        int pos, i, j, nbKeys;\n-        \/*\n-        * Here we have the following scenario:\n-        * An IDC 'selector' state object resolved to a target node,\n-        * during the time this target node was in the\n-        * ancestor-or-self axis, the 'field' state object(s) looked\n-        * out for matching nodes to create a key-sequence for this\n-        * target node. Now we are back to this target node and need\n-        * to put the key-sequence, together with the target node\n-        * itself, into the node-table of the corresponding IDC\n-        * binding.\n-        *\/\n-        matcher = sto->matcher;\n-        idc = matcher->aidc->def;\n-        nbKeys = idc->nbFields;\n-        pos = depth - matcher->depth;\n-        \/*\n-        * Check if the matcher has any key-sequences at all, plus\n-        * if it has a key-sequence for the current target node.\n-        *\/\n-        if ((matcher->keySeqs == NULL) ||\n-        (matcher->sizeKeySeqs <= pos)) {\n-        if (idc->type == XML_SCHEMA_TYPE_IDC_KEY)\n-            goto selector_key_error;\n-        else\n-            goto selector_leave;\n-        }\n-\n-        keySeq = &(matcher->keySeqs[pos]);\n-        if (*keySeq == NULL) {\n-        if (idc->type == XML_SCHEMA_TYPE_IDC_KEY)\n-            goto selector_key_error;\n-        else\n-            goto selector_leave;\n-        }\n-\n-        for (i = 0; i < nbKeys; i++) {\n-        if ((*keySeq)[i] == NULL) {\n-            \/*\n-            * Not qualified, if not all fields did resolve.\n-            *\/\n-            if (idc->type == XML_SCHEMA_TYPE_IDC_KEY) {\n-            \/*\n-            * All fields of a \"key\" IDC must resolve.\n-            *\/\n-            goto selector_key_error;\n-            }\n-            goto selector_leave;\n-        }\n-        }\n-        \/*\n-        * All fields did resolve.\n-        *\/\n-\n-        \/*\n-        * 4.1 If the {identity-constraint category} is unique(\/key),\n-        * then no two members of the `qualified node set` have\n-        * `key-sequences` whose members are pairwise equal, as\n-        * defined by Equal in [XML Schemas: Datatypes].\n-        *\n-        * Get the IDC binding from the matcher and check for\n-        * duplicate key-sequences.\n-        *\/\n-#if 0\n-        bind = xmlSchemaIDCAcquireBinding(vctxt, matcher);\n-#endif\n-        targets = xmlSchemaIDCAcquireTargetList(vctxt, matcher);\n-        if ((idc->type != XML_SCHEMA_TYPE_IDC_KEYREF) &&\n-        (targets->nbItems != 0)) {\n-        xmlSchemaPSVIIDCKeyPtr ckey, bkey, *bkeySeq;\n-        xmlIDCHashEntryPtr e;\n-\n-        res = 0;\n-\n-        if (!matcher->htab)\n-            e = NULL;\n-        else {\n-            xmlChar *value = NULL;\n-            xmlSchemaHashKeySequence(vctxt, &value, *keySeq, nbKeys);\n-            e = xmlHashLookup(matcher->htab, value);\n-            FREE_AND_NULL(value);\n-        }\n-\n-        \/*\n-        * Compare the key-sequences, key by key.\n-        *\/\n-        for (;e; e = e->next) {\n-            bkeySeq =\n-            ((xmlSchemaPSVIIDCNodePtr) targets->items[e->index])->keys;\n-            for (j = 0; j < nbKeys; j++) {\n-            ckey = (*keySeq)[j];\n-            bkey = bkeySeq[j];\n-            res = xmlSchemaAreValuesEqual(ckey->val, bkey->val);\n-            if (res == -1) {\n-                return (-1);\n-            } else if (res == 0) {\n-                \/*\n-                * One of the keys differs, so the key-sequence\n-                * won't be equal; get out.\n-                *\/\n-                break;\n-            }\n-            }\n-            if (res == 1) {\n-            \/*\n-            * Duplicate key-sequence found.\n-            *\/\n-            break;\n-            }\n-        }\n-        if (e) {\n-            xmlChar *str = NULL, *strB = NULL;\n-            \/*\n-            * TODO: Try to report the key-sequence.\n-            *\/\n-            xmlSchemaCustomErr(ACTXT_CAST vctxt,\n-            XML_SCHEMAV_CVC_IDC, NULL,\n-            WXS_BASIC_CAST idc,\n-            \"Duplicate key-sequence %s in %s\",\n-            xmlSchemaFormatIDCKeySequence(vctxt, &str,\n-                (*keySeq), nbKeys),\n-            xmlSchemaGetIDCDesignation(&strB, idc));\n-            FREE_AND_NULL(str);\n-            FREE_AND_NULL(strB);\n-            goto selector_leave;\n-        }\n-        }\n-        \/*\n-        * Add a node-table item to the IDC binding.\n-        *\/\n-        ntItem = (xmlSchemaPSVIIDCNodePtr) xmlMalloc(\n-        sizeof(xmlSchemaPSVIIDCNode));\n-        if (ntItem == NULL) {\n-        xmlSchemaVErrMemory(NULL);\n-        xmlFree(*keySeq);\n-        *keySeq = NULL;\n-        return(-1);\n-        }\n-        memset(ntItem, 0, sizeof(xmlSchemaPSVIIDCNode));\n-\n-        \/*\n-        * Store the node-table item in a global list.\n-        *\/\n-        if (idc->type != XML_SCHEMA_TYPE_IDC_KEYREF) {\n-        if (xmlSchemaIDCStoreNodeTableItem(vctxt, ntItem) == -1) {\n-            xmlFree(ntItem);\n-            xmlFree(*keySeq);\n-            *keySeq = NULL;\n-            return (-1);\n-        }\n-        ntItem->nodeQNameID = -1;\n-        } else {\n-        \/*\n-        * Save a cached QName for this node on the IDC node, to be\n-        * able to report it, even if the node is not saved.\n-        *\/\n-        ntItem->nodeQNameID = xmlSchemaVAddNodeQName(vctxt,\n-            vctxt->inode->localName, vctxt->inode->nsName);\n-        if (ntItem->nodeQNameID == -1) {\n-            xmlFree(ntItem);\n-            xmlFree(*keySeq);\n-            *keySeq = NULL;\n-            return (-1);\n-        }\n-        }\n-        \/*\n-        * Init the node-table item: Save the node, position and\n-        * consume the key-sequence.\n-        *\/\n-        ntItem->node = vctxt->node;\n-        ntItem->nodeLine = vctxt->inode->nodeLine;\n-        ntItem->keys = *keySeq;\n-        *keySeq = NULL;\n-#if 0\n-        if (xmlSchemaIDCAppendNodeTableItem(bind, ntItem) == -1)\n-#endif\n-        if (xmlSchemaItemListAdd(targets, ntItem) == -1) {\n-        if (idc->type == XML_SCHEMA_TYPE_IDC_KEYREF) {\n-            \/*\n-            * Free the item, since keyref items won't be\n-            * put on a global list.\n-            *\/\n-            xmlFree(ntItem->keys);\n-            xmlFree(ntItem);\n-        }\n-        return (-1);\n-        }\n-        if (idc->type != XML_SCHEMA_TYPE_IDC_KEYREF) {\n-        xmlChar *value = NULL;\n-        xmlIDCHashEntryPtr r, e;\n-        if (!matcher->htab)\n-          matcher->htab = xmlHashCreate(4);\n-        xmlSchemaHashKeySequence(vctxt, &value, ntItem->keys, nbKeys);\n-        e = xmlMalloc(sizeof *e);\n-        e->index = targets->nbItems - 1;\n-        r = xmlHashLookup(matcher->htab, value);\n-        if (r) {\n-            e->next = r->next;\n-            r->next = e;\n-        } else {\n-            e->next = NULL;\n-            xmlHashAddEntry(matcher->htab, value, e);\n-        }\n-        FREE_AND_NULL(value);\n-        }\n-\n-        goto selector_leave;\n-selector_key_error:\n-        {\n-        xmlChar *str = NULL;\n-        \/*\n-        * 4.2.1 (KEY) The `target node set` and the\n-        * `qualified node set` are equal, that is, every\n-        * member of the `target node set` is also a member\n-        * of the `qualified node set` and vice versa.\n-        *\/\n-        xmlSchemaCustomErr(ACTXT_CAST vctxt,\n-            XML_SCHEMAV_CVC_IDC, NULL,\n-            WXS_BASIC_CAST idc,\n-            \"Not all fields of %s evaluate to a node\",\n-            xmlSchemaGetIDCDesignation(&str, idc), NULL);\n-        FREE_AND_NULL(str);\n-        }\n-selector_leave:\n-        \/*\n-        * Free the key-sequence if not added to the IDC table.\n-        *\/\n-        if ((keySeq != NULL) && (*keySeq != NULL)) {\n-        xmlFree(*keySeq);\n-        *keySeq = NULL;\n-        }\n-    } \/* if selector *\/\n-\n-    sto->nbHistory--;\n-\n-deregister_check:\n-    \/*\n-    * Deregister state objects if they reach the depth of creation.\n-    *\/\n-    if ((sto->nbHistory == 0) && (sto->depth == depth)) {\n-        if (vctxt->xpathStates != sto) {\n-        VERROR_INT(\"xmlSchemaXPathProcessHistory\",\n-            \"The state object to be removed is not the first \"\n-            \"in the list\");\n-        }\n-        nextsto = sto->next;\n-        \/*\n-        * Unlink from the list of active XPath state objects.\n-        *\/\n-        vctxt->xpathStates = sto->next;\n-        sto->next = vctxt->xpathStatePool;\n-        \/*\n-        * Link it to the pool of reusable state objects.\n-        *\/\n-        vctxt->xpathStatePool = sto;\n-        sto = nextsto;\n-    } else\n-        sto = sto->next;\n-    } \/* while (sto != NULL) *\/\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaIDCRegisterMatchers:\n- * @vctxt: the WXS validation context\n- * @elemDecl: the element declaration\n- *\n- * Creates helper objects to evaluate IDC selectors\/fields\n- * successively.\n- *\n- * Returns 0 if OK and -1 on internal errors.\n- *\/\n-static int\n-xmlSchemaIDCRegisterMatchers(xmlSchemaValidCtxtPtr vctxt,\n-                 xmlSchemaElementPtr elemDecl)\n-{\n-    xmlSchemaIDCMatcherPtr matcher, last = NULL;\n-    xmlSchemaIDCPtr idc, refIdc;\n-    xmlSchemaIDCAugPtr aidc;\n-\n-    idc = (xmlSchemaIDCPtr) elemDecl->idcs;\n-    if (idc == NULL)\n-    return (0);\n-\n-    if (vctxt->inode->idcMatchers != NULL) {\n-    VERROR_INT(\"xmlSchemaIDCRegisterMatchers\",\n-        \"The chain of IDC matchers is expected to be empty\");\n-    return (-1);\n-    }\n-    do {\n-    if (idc->type == XML_SCHEMA_TYPE_IDC_KEYREF) {\n-        \/*\n-        * Since IDCs bubbles are expensive we need to know the\n-        * depth at which the bubbles should stop; this will be\n-        * the depth of the top-most keyref IDC. If no keyref\n-        * references a key\/unique IDC, the keyrefDepth will\n-        * be -1, indicating that no bubbles are needed.\n-        *\/\n-        refIdc = (xmlSchemaIDCPtr) idc->ref->item;\n-        if (refIdc != NULL) {\n-        \/*\n-        * Remember that we have keyrefs on this node.\n-        *\/\n-        vctxt->inode->hasKeyrefs = 1;\n-        \/*\n-        * Lookup the referenced augmented IDC info.\n-        *\/\n-        aidc = vctxt->aidcs;\n-        while (aidc != NULL) {\n-            if (aidc->def == refIdc)\n-            break;\n-            aidc = aidc->next;\n-        }\n-        if (aidc == NULL) {\n-            VERROR_INT(\"xmlSchemaIDCRegisterMatchers\",\n-            \"Could not find an augmented IDC item for an IDC \"\n-            \"definition\");\n-            return (-1);\n-        }\n-        if ((aidc->keyrefDepth == -1) ||\n-            (vctxt->depth < aidc->keyrefDepth))\n-            aidc->keyrefDepth = vctxt->depth;\n-        }\n-    }\n-    \/*\n-    * Lookup the augmented IDC item for the IDC definition.\n-    *\/\n-    aidc = vctxt->aidcs;\n-    while (aidc != NULL) {\n-        if (aidc->def == idc)\n-        break;\n-        aidc = aidc->next;\n-    }\n-    if (aidc == NULL) {\n-        VERROR_INT(\"xmlSchemaIDCRegisterMatchers\",\n-        \"Could not find an augmented IDC item for an IDC definition\");\n-        return (-1);\n-    }\n-    \/*\n-    * Create an IDC matcher for every IDC definition.\n-    *\/\n-    if (vctxt->idcMatcherCache != NULL) {\n-        \/*\n-        * Reuse a cached matcher.\n-        *\/\n-        matcher = vctxt->idcMatcherCache;\n-        vctxt->idcMatcherCache = matcher->nextCached;\n-        matcher->nextCached = NULL;\n-    } else {\n-        matcher = (xmlSchemaIDCMatcherPtr)\n-        xmlMalloc(sizeof(xmlSchemaIDCMatcher));\n-        if (matcher == NULL) {\n-        xmlSchemaVErrMemory(vctxt);\n-        return (-1);\n-        }\n-        memset(matcher, 0, sizeof(xmlSchemaIDCMatcher));\n-    }\n-    if (last == NULL)\n-        vctxt->inode->idcMatchers = matcher;\n-    else\n-        last->next = matcher;\n-    last = matcher;\n-\n-    matcher->type = IDC_MATCHER;\n-    matcher->depth = vctxt->depth;\n-    matcher->aidc = aidc;\n-    matcher->idcType = aidc->def->type;\n-    \/*\n-    * Init the automaton state object.\n-    *\/\n-    if (xmlSchemaIDCAddStateObject(vctxt, matcher,\n-        idc->selector, XPATH_STATE_OBJ_TYPE_IDC_SELECTOR) == -1)\n-        return (-1);\n-\n-    idc = idc->next;\n-    } while (idc != NULL);\n-    return (0);\n-}\n-\n-static int\n-xmlSchemaIDCFillNodeTables(xmlSchemaValidCtxtPtr vctxt,\n-               xmlSchemaNodeInfoPtr ielem)\n-{\n-    xmlSchemaPSVIIDCBindingPtr bind;\n-    int res, i, j, k, nbTargets, nbFields, nbDupls, nbNodeTable;\n-    xmlSchemaPSVIIDCKeyPtr *keys, *ntkeys;\n-    xmlSchemaPSVIIDCNodePtr *targets, *dupls;\n-\n-    xmlSchemaIDCMatcherPtr matcher = ielem->idcMatchers;\n-    \/* vctxt->createIDCNodeTables *\/\n-    while (matcher != NULL) {\n-    \/*\n-    * Skip keyref IDCs and empty IDC target-lists.\n-    *\/\n-    if ((matcher->aidc->def->type == XML_SCHEMA_TYPE_IDC_KEYREF) ||\n-        WXS_ILIST_IS_EMPTY(matcher->targets))\n-    {\n-        matcher = matcher->next;\n-        continue;\n-    }\n-    \/*\n-    * If we _want_ the IDC node-table to be created in any case\n-    * then do so. Otherwise create them only if keyrefs need them.\n-    *\/\n-    if ((! vctxt->createIDCNodeTables) &&\n-        ((matcher->aidc->keyrefDepth == -1) ||\n-         (matcher->aidc->keyrefDepth > vctxt->depth)))\n-    {\n-        matcher = matcher->next;\n-        continue;\n-    }\n-    \/*\n-    * Get\/create the IDC binding on this element for the IDC definition.\n-    *\/\n-    bind = xmlSchemaIDCAcquireBinding(vctxt, matcher);\n-    if (bind == NULL)\n-       goto internal_error;\n-\n-    if (! WXS_ILIST_IS_EMPTY(bind->dupls)) {\n-        dupls = (xmlSchemaPSVIIDCNodePtr *) bind->dupls->items;\n-        nbDupls = bind->dupls->nbItems;\n-    } else {\n-        dupls = NULL;\n-        nbDupls = 0;\n-    }\n-    if (bind->nodeTable != NULL) {\n-        nbNodeTable = bind->nbNodes;\n-    } else {\n-        nbNodeTable = 0;\n-    }\n-\n-    if ((nbNodeTable == 0) && (nbDupls == 0)) {\n-        \/*\n-        * Transfer all IDC target-nodes to the IDC node-table.\n-        *\/\n-        bind->nodeTable =\n-        (xmlSchemaPSVIIDCNodePtr *) matcher->targets->items;\n-        bind->sizeNodes = matcher->targets->sizeItems;\n-        bind->nbNodes = matcher->targets->nbItems;\n-\n-        matcher->targets->items = NULL;\n-        matcher->targets->sizeItems = 0;\n-        matcher->targets->nbItems = 0;\n-        if (matcher->htab) {\n-        xmlHashFree(matcher->htab, xmlFreeIDCHashEntry);\n-        matcher->htab = NULL;\n-        }\n-    } else {\n-        \/*\n-        * Compare the key-sequences and add to the IDC node-table.\n-        *\/\n-        nbTargets = matcher->targets->nbItems;\n-        targets = (xmlSchemaPSVIIDCNodePtr *) matcher->targets->items;\n-        nbFields = matcher->aidc->def->nbFields;\n-        i = 0;\n-        do {\n-        keys = targets[i]->keys;\n-        if (nbDupls) {\n-            \/*\n-            * Search in already found duplicates first.\n-            *\/\n-            j = 0;\n-            do {\n-            if (nbFields == 1) {\n-                res = xmlSchemaAreValuesEqual(keys[0]->val,\n-                dupls[j]->keys[0]->val);\n-                if (res == -1)\n-                goto internal_error;\n-                if (res == 1) {\n-                \/*\n-                * Equal key-sequence.\n-                *\/\n-                goto next_target;\n-                }\n-            } else {\n-                res = 0;\n-                ntkeys = dupls[j]->keys;\n-                for (k = 0; k < nbFields; k++) {\n-                res = xmlSchemaAreValuesEqual(keys[k]->val,\n-                    ntkeys[k]->val);\n-                if (res == -1)\n-                    goto internal_error;\n-                if (res == 0) {\n-                    \/*\n-                    * One of the keys differs.\n-                    *\/\n-                    break;\n-                }\n-                }\n-                if (res == 1) {\n-                \/*\n-                * Equal key-sequence found.\n-                *\/\n-                goto next_target;\n-                }\n-            }\n-            j++;\n-            } while (j < nbDupls);\n-        }\n-        if (bind->nbNodes) {\n-            j = 0;\n-            do {\n-            if (nbFields == 1) {\n-                res = xmlSchemaAreValuesEqual(keys[0]->val,\n-                bind->nodeTable[j]->keys[0]->val);\n-                if (res == -1)\n-                goto internal_error;\n-                if (res == 0) {\n-                \/*\n-                * The key-sequence differs.\n-                *\/\n-                goto next_node_table_entry;\n-                }\n-            } else {\n-                res = 0;\n-                ntkeys = bind->nodeTable[j]->keys;\n-                for (k = 0; k < nbFields; k++) {\n-                res = xmlSchemaAreValuesEqual(keys[k]->val,\n-                    ntkeys[k]->val);\n-                if (res == -1)\n-                    goto internal_error;\n-                if (res == 0) {\n-                    \/*\n-                    * One of the keys differs.\n-                    *\/\n-                    goto next_node_table_entry;\n-                }\n-                }\n-            }\n-            \/*\n-            * Add the duplicate to the list of duplicates.\n-            *\/\n-            if (bind->dupls == NULL) {\n-                bind->dupls = xmlSchemaItemListCreate();\n-                if (bind->dupls == NULL)\n-                goto internal_error;\n-            }\n-            if (xmlSchemaItemListAdd(bind->dupls, bind->nodeTable[j]) == -1)\n-                goto internal_error;\n-                        dupls = (xmlSchemaPSVIIDCNodePtr *) bind->dupls->items;\n-            \/*\n-            * Remove the duplicate entry from the IDC node-table.\n-            *\/\n-            bind->nodeTable[j] = bind->nodeTable[bind->nbNodes -1];\n-            bind->nbNodes--;\n-\n-            goto next_target;\n-\n-next_node_table_entry:\n-            j++;\n-            } while (j < bind->nbNodes);\n-        }\n-        \/*\n-        * If everything is fine, then add the IDC target-node to\n-        * the IDC node-table.\n-        *\/\n-        if (xmlSchemaIDCAppendNodeTableItem(bind, targets[i]) == -1)\n-            goto internal_error;\n-\n-next_target:\n-        i++;\n-        } while (i < nbTargets);\n-    }\n-    matcher = matcher->next;\n-    }\n-    return(0);\n-\n-internal_error:\n-    return(-1);\n-}\n-\n-\/**\n- * xmlSchemaBubbleIDCNodeTables:\n- * @depth: the current tree depth\n- *\n- * Merges IDC bindings of an element at @depth into the corresponding IDC\n- * bindings of its parent element. If a duplicate note-table entry is found,\n- * both, the parent node-table entry and child entry are discarded from the\n- * node-table of the parent.\n- *\n- * Returns 0 if OK and -1 on internal errors.\n- *\/\n-static int\n-xmlSchemaBubbleIDCNodeTables(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    xmlSchemaPSVIIDCBindingPtr bind; \/* IDC bindings of the current node. *\/\n-    xmlSchemaPSVIIDCBindingPtr *parTable, parBind = NULL; \/* parent IDC bindings. *\/\n-    xmlSchemaPSVIIDCNodePtr node, parNode = NULL, *dupls, *parNodes; \/* node-table entries. *\/\n-    xmlSchemaIDCAugPtr aidc;\n-    int i, j, k, ret = 0, nbFields, oldNum, oldDupls;\n-\n-    bind = vctxt->inode->idcTable;\n-    if (bind == NULL) {\n-    \/* Fine, no table, no bubbles. *\/\n-    return (0);\n-    }\n-\n-    parTable = &(vctxt->elemInfos[vctxt->depth -1]->idcTable);\n-    \/*\n-    * Walk all bindings; create new or add to existing bindings.\n-    * Remove duplicate key-sequences.\n-    *\/\n-    while (bind != NULL) {\n-\n-    if ((bind->nbNodes == 0) && WXS_ILIST_IS_EMPTY(bind->dupls))\n-        goto next_binding;\n-    \/*\n-    * Check if the key\/unique IDC table needs to be bubbled.\n-    *\/\n-    if (! vctxt->createIDCNodeTables) {\n-        aidc = vctxt->aidcs;\n-        do {\n-        if (aidc->def == bind->definition) {\n-            if ((aidc->keyrefDepth == -1) ||\n-            (aidc->keyrefDepth >= vctxt->depth)) {\n-            goto next_binding;\n-            }\n-            break;\n-        }\n-        aidc = aidc->next;\n-        } while (aidc != NULL);\n-    }\n-\n-    if (parTable != NULL)\n-        parBind = *parTable;\n-    \/*\n-    * Search a matching parent binding for the\n-    * IDC definition.\n-    *\/\n-    while (parBind != NULL) {\n-        if (parBind->definition == bind->definition)\n-        break;\n-        parBind = parBind->next;\n-    }\n-\n-    if (parBind != NULL) {\n-        \/*\n-        * Compare every node-table entry of the child node,\n-        * i.e. the key-sequence within, ...\n-        *\/\n-        oldNum = parBind->nbNodes; \/* Skip newly added items. *\/\n-\n-        if (! WXS_ILIST_IS_EMPTY(parBind->dupls)) {\n-        oldDupls = parBind->dupls->nbItems;\n-        dupls = (xmlSchemaPSVIIDCNodePtr *) parBind->dupls->items;\n-        } else {\n-        dupls = NULL;\n-        oldDupls = 0;\n-        }\n-\n-        parNodes = parBind->nodeTable;\n-        nbFields = bind->definition->nbFields;\n-\n-        for (i = 0; i < bind->nbNodes; i++) {\n-        node = bind->nodeTable[i];\n-        if (node == NULL)\n-            continue;\n-        \/*\n-        * ...with every key-sequence of the parent node, already\n-        * evaluated to be a duplicate key-sequence.\n-        *\/\n-        if (oldDupls) {\n-            j = 0;\n-            while (j < oldDupls) {\n-            if (nbFields == 1) {\n-                ret = xmlSchemaAreValuesEqual(\n-                node->keys[0]->val,\n-                dupls[j]->keys[0]->val);\n-                if (ret == -1)\n-                goto internal_error;\n-                if (ret == 0) {\n-                j++;\n-                continue;\n-                }\n-            } else {\n-                parNode = dupls[j];\n-                for (k = 0; k < nbFields; k++) {\n-                ret = xmlSchemaAreValuesEqual(\n-                    node->keys[k]->val,\n-                    parNode->keys[k]->val);\n-                if (ret == -1)\n-                    goto internal_error;\n-                if (ret == 0)\n-                    break;\n-                }\n-            }\n-            if (ret == 1)\n-                \/* Duplicate found. *\/\n-                break;\n-            j++;\n-            }\n-            if (j != oldDupls) {\n-            \/* Duplicate found. Skip this entry. *\/\n-            continue;\n-            }\n-        }\n-        \/*\n-        * ... and with every key-sequence of the parent node.\n-        *\/\n-        if (oldNum) {\n-            j = 0;\n-            while (j < oldNum) {\n-            parNode = parNodes[j];\n-            if (nbFields == 1) {\n-                ret = xmlSchemaAreValuesEqual(\n-                node->keys[0]->val,\n-                parNode->keys[0]->val);\n-                if (ret == -1)\n-                goto internal_error;\n-                if (ret == 0) {\n-                j++;\n-                continue;\n-                }\n-            } else {\n-                for (k = 0; k < nbFields; k++) {\n-                ret = xmlSchemaAreValuesEqual(\n-                    node->keys[k]->val,\n-                    parNode->keys[k]->val);\n-                if (ret == -1)\n-                    goto internal_error;\n-                if (ret == 0)\n-                    break;\n-                }\n-            }\n-            if (ret == 1)\n-                \/* Duplicate found. *\/\n-                break;\n-            j++;\n-            }\n-            if (j != oldNum) {\n-            \/*\n-            * Handle duplicates. Move the duplicate in\n-            * the parent's node-table to the list of\n-            * duplicates.\n-            *\/\n-            oldNum--;\n-            parBind->nbNodes--;\n-            \/*\n-            * Move last old item to pos of duplicate.\n-            *\/\n-            parNodes[j] = parNodes[oldNum];\n-\n-            if (parBind->nbNodes != oldNum) {\n-                \/*\n-                * If new items exist, move last new item to\n-                * last of old items.\n-                *\/\n-                parNodes[oldNum] =\n-                parNodes[parBind->nbNodes];\n-            }\n-            if (parBind->dupls == NULL) {\n-                parBind->dupls = xmlSchemaItemListCreate();\n-                if (parBind->dupls == NULL)\n-                goto internal_error;\n-            }\n-            xmlSchemaItemListAdd(parBind->dupls, parNode);\n-                dupls = (xmlSchemaPSVIIDCNodePtr *)\n-                            parBind->dupls->items;\n-            } else {\n-            \/*\n-            * Add the node-table entry (node and key-sequence) of\n-            * the child node to the node table of the parent node.\n-            *\/\n-            if (parBind->nodeTable == NULL) {\n-                parBind->nodeTable = (xmlSchemaPSVIIDCNodePtr *)\n-                xmlMalloc(10 * sizeof(xmlSchemaPSVIIDCNodePtr));\n-                if (parBind->nodeTable == NULL) {\n-                xmlSchemaVErrMemory(NULL);\n-                goto internal_error;\n-                }\n-                parBind->sizeNodes = 1;\n-            } else if (parBind->nbNodes >= parBind->sizeNodes) {\n-                parBind->sizeNodes *= 2;\n-                parBind->nodeTable = (xmlSchemaPSVIIDCNodePtr *)\n-                xmlRealloc(parBind->nodeTable, parBind->sizeNodes *\n-                sizeof(xmlSchemaPSVIIDCNodePtr));\n-                if (parBind->nodeTable == NULL) {\n-                xmlSchemaVErrMemory(NULL);\n-                goto internal_error;\n-                }\n-            }\n-            parNodes = parBind->nodeTable;\n-            \/*\n-            * Append the new node-table entry to the 'new node-table\n-            * entries' section.\n-            *\/\n-            parNodes[parBind->nbNodes++] = node;\n-            }\n-\n-        }\n-\n-        }\n-    } else {\n-        \/*\n-        * No binding for the IDC was found: create a new one and\n-        * copy all node-tables.\n-        *\/\n-        parBind = xmlSchemaIDCNewBinding(bind->definition);\n-        if (parBind == NULL)\n-        goto internal_error;\n-\n-        \/*\n-        * TODO: Hmm, how to optimize the initial number of\n-        * allocated entries?\n-        *\/\n-        if (bind->nbNodes != 0) {\n-        \/*\n-        * Add all IDC node-table entries.\n-        *\/\n-        if (! vctxt->psviExposeIDCNodeTables) {\n-            \/*\n-            * Just move the entries.\n-            * NOTE: this is quite save here, since\n-            * all the keyref lookups have already been\n-            * performed.\n-            *\/\n-            parBind->nodeTable = bind->nodeTable;\n-            bind->nodeTable = NULL;\n-            parBind->sizeNodes = bind->sizeNodes;\n-            bind->sizeNodes = 0;\n-            parBind->nbNodes = bind->nbNodes;\n-            bind->nbNodes = 0;\n-        } else {\n-            \/*\n-            * Copy the entries.\n-            *\/\n-            parBind->nodeTable = (xmlSchemaPSVIIDCNodePtr *)\n-            xmlMalloc(bind->nbNodes *\n-            sizeof(xmlSchemaPSVIIDCNodePtr));\n-            if (parBind->nodeTable == NULL) {\n-            xmlSchemaVErrMemory(NULL);\n-            xmlSchemaIDCFreeBinding(parBind);\n-            goto internal_error;\n-            }\n-            parBind->sizeNodes = bind->nbNodes;\n-            parBind->nbNodes = bind->nbNodes;\n-            memcpy(parBind->nodeTable, bind->nodeTable,\n-            bind->nbNodes * sizeof(xmlSchemaPSVIIDCNodePtr));\n-        }\n-        }\n-        if (bind->dupls) {\n-        \/*\n-        * Move the duplicates.\n-        *\/\n-        if (parBind->dupls != NULL)\n-            xmlSchemaItemListFree(parBind->dupls);\n-        parBind->dupls = bind->dupls;\n-        bind->dupls = NULL;\n-        }\n-            if (parTable != NULL) {\n-                if (*parTable == NULL)\n-                    *parTable = parBind;\n-                else {\n-                    parBind->next = *parTable;\n-                    *parTable = parBind;\n-                }\n-            }\n-    }\n-\n-next_binding:\n-    bind = bind->next;\n-    }\n-    return (0);\n-\n-internal_error:\n-    return(-1);\n-}\n-\n-\/**\n- * xmlSchemaCheckCVCIDCKeyRef:\n- * @vctxt: the WXS validation context\n- * @elemDecl: the element declaration\n- *\n- * Check the cvc-idc-keyref constraints.\n- *\/\n-static int\n-xmlSchemaCheckCVCIDCKeyRef(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    xmlSchemaIDCMatcherPtr matcher;\n-    xmlSchemaPSVIIDCBindingPtr bind;\n-\n-    matcher = vctxt->inode->idcMatchers;\n-    \/*\n-    * Find a keyref.\n-    *\/\n-    while (matcher != NULL) {\n-    if ((matcher->idcType == XML_SCHEMA_TYPE_IDC_KEYREF) &&\n-        matcher->targets &&\n-        matcher->targets->nbItems)\n-    {\n-        int i, j, k, res, nbFields, hasDupls;\n-        xmlSchemaPSVIIDCKeyPtr *refKeys, *keys;\n-        xmlSchemaPSVIIDCNodePtr refNode = NULL;\n-        xmlHashTablePtr table = NULL;\n-\n-        nbFields = matcher->aidc->def->nbFields;\n-\n-        \/*\n-        * Find the IDC node-table for the referenced IDC key\/unique.\n-        *\/\n-        bind = vctxt->inode->idcTable;\n-        while (bind != NULL) {\n-        if ((xmlSchemaIDCPtr) matcher->aidc->def->ref->item ==\n-            bind->definition)\n-            break;\n-        bind = bind->next;\n-        }\n-        hasDupls = (bind && bind->dupls && bind->dupls->nbItems) ? 1 : 0;\n-        \/*\n-        * Search for a matching key-sequences.\n-        *\/\n-        if (bind) {\n-        table = xmlHashCreate(bind->nbNodes * 2);\n-        for (j = 0; j < bind->nbNodes; j++) {\n-            xmlChar *value;\n-            xmlIDCHashEntryPtr r, e;\n-            keys = bind->nodeTable[j]->keys;\n-            xmlSchemaHashKeySequence(vctxt, &value, keys, nbFields);\n-            e = xmlMalloc(sizeof *e);\n-            e->index = j;\n-            r = xmlHashLookup(table, value);\n-            if (r) {\n-            e->next = r->next;\n-            r->next = e;\n-            } else {\n-            e->next = NULL;\n-            xmlHashAddEntry(table, value, e);\n-            }\n-            FREE_AND_NULL(value);\n-        }\n-        }\n-        for (i = 0; i < matcher->targets->nbItems; i++) {\n-        res = 0;\n-        refNode = matcher->targets->items[i];\n-        if (bind != NULL) {\n-            xmlChar *value;\n-            xmlIDCHashEntryPtr e;\n-            refKeys = refNode->keys;\n-            xmlSchemaHashKeySequence(vctxt, &value, refKeys, nbFields);\n-            e = xmlHashLookup(table, value);\n-            FREE_AND_NULL(value);\n-            res = 0;\n-            for (;e; e = e->next) {\n-            keys = bind->nodeTable[e->index]->keys;\n-            for (k = 0; k < nbFields; k++) {\n-                res = xmlSchemaAreValuesEqual(keys[k]->val,\n-                              refKeys[k]->val);\n-                if (res == 0)\n-                    break;\n-                else if (res == -1) {\n-                return (-1);\n-                }\n-            }\n-            if (res == 1) {\n-                \/*\n-                 * Match found.\n-                 *\/\n-                break;\n-            }\n-            }\n-            if ((res == 0) && hasDupls) {\n-            \/*\n-            * Search in duplicates\n-            *\/\n-            for (j = 0; j < bind->dupls->nbItems; j++) {\n-                keys = ((xmlSchemaPSVIIDCNodePtr)\n-                bind->dupls->items[j])->keys;\n-                for (k = 0; k < nbFields; k++) {\n-                res = xmlSchemaAreValuesEqual(keys[k]->val,\n-                    refKeys[k]->val);\n-                if (res == 0)\n-                    break;\n-                else if (res == -1) {\n-                    return (-1);\n-                }\n-                }\n-                if (res == 1) {\n-                \/*\n-                * Match in duplicates found.\n-                *\/\n-                xmlChar *str = NULL, *strB = NULL;\n-                xmlSchemaKeyrefErr(vctxt,\n-                    XML_SCHEMAV_CVC_IDC, refNode,\n-                    (xmlSchemaTypePtr) matcher->aidc->def,\n-                    \"More than one match found for \"\n-                    \"key-sequence %s of keyref '%s'\",\n-                    xmlSchemaFormatIDCKeySequence(vctxt, &str,\n-                    refNode->keys, nbFields),\n-                    xmlSchemaGetComponentQName(&strB,\n-                    matcher->aidc->def));\n-                FREE_AND_NULL(str);\n-                FREE_AND_NULL(strB);\n-                break;\n-                }\n-            }\n-            }\n-        }\n-\n-        if (res == 0) {\n-            xmlChar *str = NULL, *strB = NULL;\n-            xmlSchemaKeyrefErr(vctxt,\n-            XML_SCHEMAV_CVC_IDC, refNode,\n-            (xmlSchemaTypePtr) matcher->aidc->def,\n-            \"No match found for key-sequence %s of keyref '%s'\",\n-            xmlSchemaFormatIDCKeySequence(vctxt, &str,\n-                refNode->keys, nbFields),\n-            xmlSchemaGetComponentQName(&strB, matcher->aidc->def));\n-            FREE_AND_NULL(str);\n-            FREE_AND_NULL(strB);\n-        }\n-        }\n-        if (table) {\n-        xmlHashFree(table, xmlFreeIDCHashEntry);\n-        }\n-    }\n-    matcher = matcher->next;\n-    }\n-    \/* TODO: Return an error if any error encountered. *\/\n-    return (0);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            XML Reader validation code                      *\n- *                                    *\n- ************************************************************************\/\n-\n-static xmlSchemaAttrInfoPtr\n-xmlSchemaGetFreshAttrInfo(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    xmlSchemaAttrInfoPtr iattr;\n-    \/*\n-    * Grow\/create list of attribute infos.\n-    *\/\n-    if (vctxt->attrInfos == NULL) {\n-    vctxt->attrInfos = (xmlSchemaAttrInfoPtr *)\n-        xmlMalloc(sizeof(xmlSchemaAttrInfoPtr));\n-    vctxt->sizeAttrInfos = 1;\n-    if (vctxt->attrInfos == NULL) {\n-        xmlSchemaVErrMemory(vctxt);\n-        return (NULL);\n-    }\n-    } else if (vctxt->sizeAttrInfos <= vctxt->nbAttrInfos) {\n-    vctxt->sizeAttrInfos++;\n-    vctxt->attrInfos = (xmlSchemaAttrInfoPtr *)\n-        xmlRealloc(vctxt->attrInfos,\n-        vctxt->sizeAttrInfos * sizeof(xmlSchemaAttrInfoPtr));\n-    if (vctxt->attrInfos == NULL) {\n-        xmlSchemaVErrMemory(vctxt);\n-        return (NULL);\n-    }\n-    } else {\n-    iattr = vctxt->attrInfos[vctxt->nbAttrInfos++];\n-    if (iattr->localName != NULL) {\n-        VERROR_INT(\"xmlSchemaGetFreshAttrInfo\",\n-        \"attr info not cleared\");\n-        return (NULL);\n-    }\n-    iattr->nodeType = XML_ATTRIBUTE_NODE;\n-    return (iattr);\n-    }\n-    \/*\n-    * Create an attribute info.\n-    *\/\n-    iattr = (xmlSchemaAttrInfoPtr)\n-    xmlMalloc(sizeof(xmlSchemaAttrInfo));\n-    if (iattr == NULL) {\n-    xmlSchemaVErrMemory(vctxt);\n-    return (NULL);\n-    }\n-    memset(iattr, 0, sizeof(xmlSchemaAttrInfo));\n-    iattr->nodeType = XML_ATTRIBUTE_NODE;\n-    vctxt->attrInfos[vctxt->nbAttrInfos++] = iattr;\n-\n-    return (iattr);\n-}\n-\n-static int\n-xmlSchemaValidatorPushAttribute(xmlSchemaValidCtxtPtr vctxt,\n-            xmlNodePtr attrNode,\n-            int nodeLine,\n-            const xmlChar *localName,\n-            const xmlChar *nsName,\n-            int ownedNames,\n-            xmlChar *value,\n-            int ownedValue)\n-{\n-    xmlSchemaAttrInfoPtr attr;\n-\n-    attr = xmlSchemaGetFreshAttrInfo(vctxt);\n-    if (attr == NULL) {\n-    VERROR_INT(\"xmlSchemaPushAttribute\",\n-        \"calling xmlSchemaGetFreshAttrInfo()\");\n-    return (-1);\n-    }\n-    attr->node = attrNode;\n-    attr->nodeLine = nodeLine;\n-    attr->state = XML_SCHEMAS_ATTR_UNKNOWN;\n-    attr->localName = localName;\n-    attr->nsName = nsName;\n-    if (ownedNames)\n-    attr->flags |= XML_SCHEMA_NODE_INFO_FLAG_OWNED_NAMES;\n-    \/*\n-    * Evaluate if it's an XSI attribute.\n-    *\/\n-    if (nsName != NULL) {\n-    if (xmlStrEqual(localName, BAD_CAST \"nil\")) {\n-        if (xmlStrEqual(attr->nsName, xmlSchemaInstanceNs)) {\n-        attr->metaType = XML_SCHEMA_ATTR_INFO_META_XSI_NIL;\n-        }\n-    } else if (xmlStrEqual(localName, BAD_CAST \"type\")) {\n-        if (xmlStrEqual(attr->nsName, xmlSchemaInstanceNs)) {\n-        attr->metaType = XML_SCHEMA_ATTR_INFO_META_XSI_TYPE;\n-        }\n-    } else if (xmlStrEqual(localName, BAD_CAST \"schemaLocation\")) {\n-        if (xmlStrEqual(attr->nsName, xmlSchemaInstanceNs)) {\n-        attr->metaType = XML_SCHEMA_ATTR_INFO_META_XSI_SCHEMA_LOC;\n-        }\n-    } else if (xmlStrEqual(localName, BAD_CAST \"noNamespaceSchemaLocation\")) {\n-        if (xmlStrEqual(attr->nsName, xmlSchemaInstanceNs)) {\n-        attr->metaType = XML_SCHEMA_ATTR_INFO_META_XSI_NO_NS_SCHEMA_LOC;\n-        }\n-    } else if (xmlStrEqual(attr->nsName, xmlNamespaceNs)) {\n-        attr->metaType = XML_SCHEMA_ATTR_INFO_META_XMLNS;\n-    }\n-    }\n-    attr->value = value;\n-    if (ownedValue)\n-    attr->flags |= XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES;\n-    if (attr->metaType != 0)\n-    attr->state = XML_SCHEMAS_ATTR_META;\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaClearElemInfo:\n- * @vctxt: the WXS validation context\n- * @ielem: the element information item\n- *\/\n-static void\n-xmlSchemaClearElemInfo(xmlSchemaValidCtxtPtr vctxt,\n-               xmlSchemaNodeInfoPtr ielem)\n-{\n-    ielem->hasKeyrefs = 0;\n-    ielem->appliedXPath = 0;\n-    if (ielem->flags & XML_SCHEMA_NODE_INFO_FLAG_OWNED_NAMES) {\n-    FREE_AND_NULL(ielem->localName);\n-    FREE_AND_NULL(ielem->nsName);\n-    } else {\n-    ielem->localName = NULL;\n-    ielem->nsName = NULL;\n-    }\n-    if (ielem->flags & XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES) {\n-    FREE_AND_NULL(ielem->value);\n-    } else {\n-    ielem->value = NULL;\n-    }\n-    if (ielem->val != NULL) {\n-    \/*\n-    * PSVI TODO: Be careful not to free it when the value is\n-    * exposed via PSVI.\n-    *\/\n-    xmlSchemaFreeValue(ielem->val);\n-    ielem->val = NULL;\n-    }\n-    if (ielem->idcMatchers != NULL) {\n-    \/*\n-    * REVISIT OPTIMIZE TODO: Use a pool of IDC matchers.\n-    *   Does it work?\n-    *\/\n-    xmlSchemaIDCReleaseMatcherList(vctxt, ielem->idcMatchers);\n-#if 0\n-    xmlSchemaIDCFreeMatcherList(ielem->idcMatchers);\n-#endif\n-    ielem->idcMatchers = NULL;\n-    }\n-    if (ielem->idcTable != NULL) {\n-    \/*\n-    * OPTIMIZE TODO: Use a pool of IDC tables??.\n-    *\/\n-    xmlSchemaIDCFreeIDCTable(ielem->idcTable);\n-    ielem->idcTable = NULL;\n-    }\n-    if (ielem->regexCtxt != NULL) {\n-    xmlRegFreeExecCtxt(ielem->regexCtxt);\n-    ielem->regexCtxt = NULL;\n-    }\n-    if (ielem->nsBindings != NULL) {\n-    xmlFree((xmlChar **)ielem->nsBindings);\n-    ielem->nsBindings = NULL;\n-    ielem->nbNsBindings = 0;\n-    ielem->sizeNsBindings = 0;\n-    }\n-}\n-\n-\/**\n- * xmlSchemaGetFreshElemInfo:\n- * @vctxt: the schema validation context\n- *\n- * Creates\/reuses and initializes the element info item for\n- * the current tree depth.\n- *\n- * Returns the element info item or NULL on API or internal errors.\n- *\/\n-static xmlSchemaNodeInfoPtr\n-xmlSchemaGetFreshElemInfo(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    xmlSchemaNodeInfoPtr info = NULL;\n-\n-    if (vctxt->depth > vctxt->sizeElemInfos) {\n-    VERROR_INT(\"xmlSchemaGetFreshElemInfo\",\n-        \"inconsistent depth encountered\");\n-    return (NULL);\n-    }\n-    if (vctxt->elemInfos == NULL) {\n-    vctxt->elemInfos = (xmlSchemaNodeInfoPtr *)\n-        xmlMalloc(10 * sizeof(xmlSchemaNodeInfoPtr));\n-    if (vctxt->elemInfos == NULL) {\n-        xmlSchemaVErrMemory(vctxt);\n-        return (NULL);\n-    }\n-    memset(vctxt->elemInfos, 0, 10 * sizeof(xmlSchemaNodeInfoPtr));\n-    vctxt->sizeElemInfos = 10;\n-    } else if (vctxt->sizeElemInfos <= vctxt->depth) {\n-    int i = vctxt->sizeElemInfos;\n-\n-    vctxt->sizeElemInfos *= 2;\n-    vctxt->elemInfos = (xmlSchemaNodeInfoPtr *)\n-        xmlRealloc(vctxt->elemInfos, vctxt->sizeElemInfos *\n-        sizeof(xmlSchemaNodeInfoPtr));\n-    if (vctxt->elemInfos == NULL) {\n-        xmlSchemaVErrMemory(vctxt);\n-        return (NULL);\n-    }\n-    \/*\n-    * We need the new memory to be NULLed.\n-    * TODO: Use memset instead?\n-    *\/\n-    for (; i < vctxt->sizeElemInfos; i++)\n-        vctxt->elemInfos[i] = NULL;\n-    } else\n-    info = vctxt->elemInfos[vctxt->depth];\n-\n-    if (info == NULL) {\n-    info = (xmlSchemaNodeInfoPtr)\n-        xmlMalloc(sizeof(xmlSchemaNodeInfo));\n-    if (info == NULL) {\n-        xmlSchemaVErrMemory(vctxt);\n-        return (NULL);\n-    }\n-    vctxt->elemInfos[vctxt->depth] = info;\n-    } else {\n-    if (info->localName != NULL) {\n-        VERROR_INT(\"xmlSchemaGetFreshElemInfo\",\n-        \"elem info has not been cleared\");\n-        return (NULL);\n-    }\n-    }\n-    memset(info, 0, sizeof(xmlSchemaNodeInfo));\n-    info->nodeType = XML_ELEMENT_NODE;\n-    info->depth = vctxt->depth;\n-\n-    return (info);\n-}\n-\n-#define ACTIVATE_ATTRIBUTE(item) vctxt->inode = (xmlSchemaNodeInfoPtr) item;\n-#define ACTIVATE_ELEM vctxt->inode = vctxt->elemInfos[vctxt->depth];\n-#define ACTIVATE_PARENT_ELEM vctxt->inode = vctxt->elemInfos[vctxt->depth -1];\n-\n-static int\n-xmlSchemaValidateFacets(xmlSchemaAbstractCtxtPtr actxt,\n-            xmlNodePtr node,\n-            xmlSchemaTypePtr type,\n-            xmlSchemaValType valType,\n-            const xmlChar * value,\n-            xmlSchemaValPtr val,\n-            unsigned long length,\n-            int fireErrors)\n-{\n-    int ret, error = 0, found;\n-\n-    xmlSchemaTypePtr tmpType;\n-    xmlSchemaFacetLinkPtr facetLink;\n-    xmlSchemaFacetPtr facet;\n-    unsigned long len = 0;\n-    xmlSchemaWhitespaceValueType ws;\n-\n-    \/*\n-    * In Libxml2, derived built-in types have currently no explicit facets.\n-    *\/\n-    if (type->type == XML_SCHEMA_TYPE_BASIC)\n-    return (0);\n-\n-    \/*\n-    * NOTE: Do not jump away, if the facetSet of the given type is\n-    * empty: until now, \"pattern\" and \"enumeration\" facets of the\n-    * *base types* need to be checked as well.\n-    *\/\n-    if (type->facetSet == NULL)\n-    goto pattern_and_enum;\n-\n-    if (! WXS_IS_ATOMIC(type)) {\n-    if (WXS_IS_LIST(type))\n-        goto WXS_IS_LIST;\n-    else\n-        goto pattern_and_enum;\n-    }\n-\n-    \/*\n-    * Whitespace handling is only of importance for string-based\n-    * types.\n-    *\/\n-    tmpType = xmlSchemaGetPrimitiveType(type);\n-    if ((tmpType->builtInType == XML_SCHEMAS_STRING) ||\n-    WXS_IS_ANY_SIMPLE_TYPE(tmpType)) {\n-    ws = xmlSchemaGetWhiteSpaceFacetValue(type);\n-    } else\n-    ws = XML_SCHEMA_WHITESPACE_COLLAPSE;\n-\n-    \/*\n-    * If the value was not computed (for string or\n-    * anySimpleType based types), then use the provided\n-    * type.\n-    *\/\n-    if (val != NULL)\n-    valType = xmlSchemaGetValType(val);\n-\n-    ret = 0;\n-    for (facetLink = type->facetSet; facetLink != NULL;\n-    facetLink = facetLink->next) {\n-    \/*\n-    * Skip the pattern \"whiteSpace\": it is used to\n-    * format the character content beforehand.\n-    *\/\n-    switch (facetLink->facet->type) {\n-        case XML_SCHEMA_FACET_WHITESPACE:\n-        case XML_SCHEMA_FACET_PATTERN:\n-        case XML_SCHEMA_FACET_ENUMERATION:\n-        continue;\n-        case XML_SCHEMA_FACET_LENGTH:\n-        case XML_SCHEMA_FACET_MINLENGTH:\n-        case XML_SCHEMA_FACET_MAXLENGTH:\n-        ret = xmlSchemaValidateLengthFacetWhtsp(facetLink->facet,\n-            valType, value, val, &len, ws);\n-        break;\n-        default:\n-        ret = xmlSchemaValidateFacetWhtsp(facetLink->facet, ws,\n-            valType, value, val, ws);\n-        break;\n-    }\n-    if (ret < 0) {\n-        AERROR_INT(\"xmlSchemaValidateFacets\",\n-        \"validating against a atomic type facet\");\n-        return (-1);\n-    } else if (ret > 0) {\n-        if (fireErrors)\n-        xmlSchemaFacetErr(actxt, ret, node,\n-        value, len, type, facetLink->facet, NULL, NULL, NULL);\n-        else\n-        return (ret);\n-        if (error == 0)\n-        error = ret;\n-    }\n-    ret = 0;\n-    }\n-\n-WXS_IS_LIST:\n-    if (! WXS_IS_LIST(type))\n-    goto pattern_and_enum;\n-    \/*\n-    * \"length\", \"minLength\" and \"maxLength\" of list types.\n-    *\/\n-    ret = 0;\n-    for (facetLink = type->facetSet; facetLink != NULL;\n-    facetLink = facetLink->next) {\n-\n-    switch (facetLink->facet->type) {\n-        case XML_SCHEMA_FACET_LENGTH:\n-        case XML_SCHEMA_FACET_MINLENGTH:\n-        case XML_SCHEMA_FACET_MAXLENGTH:\n-        ret = xmlSchemaValidateListSimpleTypeFacet(facetLink->facet,\n-            value, length, NULL);\n-        break;\n-        default:\n-        continue;\n-    }\n-    if (ret < 0) {\n-        AERROR_INT(\"xmlSchemaValidateFacets\",\n-        \"validating against a list type facet\");\n-        return (-1);\n-    } else if (ret > 0) {\n-        if (fireErrors)\n-        xmlSchemaFacetErr(actxt, ret, node,\n-        value, length, type, facetLink->facet, NULL, NULL, NULL);\n-        else\n-        return (ret);\n-        if (error == 0)\n-        error = ret;\n-    }\n-    ret = 0;\n-    }\n-\n-pattern_and_enum:\n-    found = 0;\n-    \/*\n-    * Process enumerations. Facet values are in the value space\n-    * of the defining type's base type. This seems to be a bug in the\n-    * XML Schema 1.0 spec. Use the whitespace type of the base type.\n-    * Only the first set of enumerations in the ancestor-or-self axis\n-    * is used for validation.\n-    *\/\n-    ret = 0;\n-    tmpType = type;\n-    do {\n-        for (facet = tmpType->facets; facet != NULL; facet = facet->next) {\n-            if (facet->type != XML_SCHEMA_FACET_ENUMERATION)\n-                continue;\n-            found = 1;\n-            ret = xmlSchemaAreValuesEqual(facet->val, val);\n-            if (ret == 1)\n-                break;\n-            else if (ret < 0) {\n-                AERROR_INT(\"xmlSchemaValidateFacets\",\n-                    \"validating against an enumeration facet\");\n-                return (-1);\n-            }\n-        }\n-        if (ret != 0)\n-            break;\n-        \/*\n-        * Break on the first set of enumerations. Any additional\n-        *  enumerations which might be existent on the ancestors\n-        *  of the current type are restricted by this set; thus\n-        *  *must* *not* be taken into account.\n-        *\/\n-        if (found)\n-            break;\n-        tmpType = tmpType->baseType;\n-    } while ((tmpType != NULL) &&\n-        (tmpType->type != XML_SCHEMA_TYPE_BASIC));\n-    if (found && (ret == 0)) {\n-        ret = XML_SCHEMAV_CVC_ENUMERATION_VALID;\n-        if (fireErrors) {\n-            xmlSchemaFacetErr(actxt, ret, node,\n-                value, 0, type, NULL, NULL, NULL, NULL);\n-        } else\n-            return (ret);\n-        if (error == 0)\n-            error = ret;\n-    }\n-\n-    \/*\n-    * Process patters. Pattern facets are ORed at type level\n-    * and ANDed if derived. Walk the base type axis.\n-    *\/\n-    tmpType = type;\n-    facet = NULL;\n-    do {\n-        found = 0;\n-        for (facetLink = tmpType->facetSet; facetLink != NULL;\n-            facetLink = facetLink->next) {\n-            if (facetLink->facet->type != XML_SCHEMA_FACET_PATTERN)\n-                continue;\n-            found = 1;\n-            \/*\n-            * NOTE that for patterns, @value needs to be the\n-            * normalized value.\n-            *\/\n-            ret = xmlRegexpExec(facetLink->facet->regexp, value);\n-            if (ret == 1)\n-                break;\n-            else if (ret < 0) {\n-                AERROR_INT(\"xmlSchemaValidateFacets\",\n-                    \"validating against a pattern facet\");\n-                return (-1);\n-            } else {\n-                \/*\n-                * Save the last non-validating facet.\n-                *\/\n-                facet = facetLink->facet;\n-            }\n-        }\n-        if (found && (ret != 1)) {\n-            ret = XML_SCHEMAV_CVC_PATTERN_VALID;\n-            if (fireErrors) {\n-                xmlSchemaFacetErr(actxt, ret, node,\n-                    value, 0, type, facet, NULL, NULL, NULL);\n-            } else\n-                return (ret);\n-            if (error == 0)\n-                error = ret;\n-            break;\n-        }\n-        tmpType = tmpType->baseType;\n-    } while ((tmpType != NULL) && (tmpType->type != XML_SCHEMA_TYPE_BASIC));\n-\n-    return (error);\n-}\n-\n-static xmlChar *\n-xmlSchemaNormalizeValue(xmlSchemaTypePtr type,\n-            const xmlChar *value)\n-{\n-    switch (xmlSchemaGetWhiteSpaceFacetValue(type)) {\n-    case XML_SCHEMA_WHITESPACE_COLLAPSE:\n-        return (xmlSchemaCollapseString(value));\n-    case XML_SCHEMA_WHITESPACE_REPLACE:\n-        return (xmlSchemaWhiteSpaceReplace(value));\n-    default:\n-        return (NULL);\n-    }\n-}\n-\n-static int\n-xmlSchemaValidateQName(xmlSchemaValidCtxtPtr vctxt,\n-               const xmlChar *value,\n-               xmlSchemaValPtr *val,\n-               int valNeeded)\n-{\n-    int ret;\n-    xmlChar *stripped;\n-    const xmlChar *nsName;\n-    xmlChar *local, *prefix = NULL;\n-\n-    ret = xmlValidateQName(value, 1);\n-    if (ret != 0) {\n-    if (ret == -1) {\n-        VERROR_INT(\"xmlSchemaValidateQName\",\n-        \"calling xmlValidateQName()\");\n-        return (-1);\n-    }\n-    return( XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1);\n-    }\n-    \/*\n-    * NOTE: xmlSplitQName2 will always return a duplicated\n-    * strings.\n-    *\/\n-    \/* TODO: Export and use xmlSchemaStrip instead *\/\n-    stripped = xmlSchemaCollapseString(value);\n-    local = xmlSplitQName2(stripped ? stripped : value, &prefix);\n-    xmlFree(stripped);\n-    if (local == NULL)\n-    local = xmlStrdup(value);\n-    \/*\n-    * OPTIMIZE TODO: Use flags for:\n-    *  - is there any namespace binding?\n-    *  - is there a default namespace?\n-    *\/\n-    nsName = xmlSchemaLookupNamespace(vctxt, prefix);\n-\n-    if (prefix != NULL) {\n-    xmlFree(prefix);\n-    \/*\n-    * A namespace must be found if the prefix is\n-    * NOT NULL.\n-    *\/\n-    if (nsName == NULL) {\n-        ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1;\n-        xmlSchemaCustomErr(ACTXT_CAST vctxt, ret, NULL,\n-        WXS_BASIC_CAST xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),\n-        \"The QName value '%s' has no \"\n-        \"corresponding namespace declaration in \"\n-        \"scope\", value, NULL);\n-        if (local != NULL)\n-        xmlFree(local);\n-        return (ret);\n-    }\n-    }\n-    if (valNeeded && val) {\n-    if (nsName != NULL)\n-        *val = xmlSchemaNewQNameValue(\n-        BAD_CAST xmlStrdup(nsName), BAD_CAST local);\n-    else\n-        *val = xmlSchemaNewQNameValue(NULL,\n-        BAD_CAST local);\n-    } else\n-    xmlFree(local);\n-    return (0);\n-}\n-\n-\/*\n-* cvc-simple-type\n-*\/\n-static int\n-xmlSchemaVCheckCVCSimpleType(xmlSchemaAbstractCtxtPtr actxt,\n-                 xmlNodePtr node,\n-                 xmlSchemaTypePtr type,\n-                 const xmlChar *value,\n-                 xmlSchemaValPtr *retVal,\n-                 int fireErrors,\n-                 int normalize,\n-                 int isNormalized)\n-{\n-    int ret = 0, valNeeded = (retVal) ? 1 : 0;\n-    xmlSchemaValPtr val = NULL;\n-    \/* xmlSchemaWhitespaceValueType ws; *\/\n-    xmlChar *normValue = NULL;\n-\n-#define NORMALIZE(atype) \\\n-    if ((! isNormalized) && \\\n-    (normalize || (type->flags & XML_SCHEMAS_TYPE_NORMVALUENEEDED))) { \\\n-    normValue = xmlSchemaNormalizeValue(atype, value); \\\n-    if (normValue != NULL) \\\n-        value = normValue; \\\n-    isNormalized = 1; \\\n-    }\n-\n-    if ((retVal != NULL) && (*retVal != NULL)) {\n-    xmlSchemaFreeValue(*retVal);\n-    *retVal = NULL;\n-    }\n-    \/*\n-    * 3.14.4 Simple Type Definition Validation Rules\n-    * Validation Rule: String Valid\n-    *\/\n-    \/*\n-    * 1 It is schema-valid with respect to that definition as defined\n-    * by Datatype Valid in [XML Schemas: Datatypes].\n-    *\/\n-    \/*\n-    * 2.1 If The definition is ENTITY or is validly derived from ENTITY given\n-    * the empty set, as defined in Type Derivation OK (Simple) ($3.14.6), then\n-    * the string must be a `declared entity name`.\n-    *\/\n-    \/*\n-    * 2.2 If The definition is ENTITIES or is validly derived from ENTITIES\n-    * given the empty set, as defined in Type Derivation OK (Simple) ($3.14.6),\n-    * then every whitespace-delimited substring of the string must be a `declared\n-    * entity name`.\n-    *\/\n-    \/*\n-    * 2.3 otherwise no further condition applies.\n-    *\/\n-    if ((! valNeeded) && (type->flags & XML_SCHEMAS_TYPE_FACETSNEEDVALUE))\n-    valNeeded = 1;\n-    if (value == NULL)\n-    value = BAD_CAST \"\";\n-    if (WXS_IS_ANY_SIMPLE_TYPE(type) || WXS_IS_ATOMIC(type)) {\n-    xmlSchemaTypePtr biType; \/* The built-in type. *\/\n-    \/*\n-    * SPEC (1.2.1) \"if {variety} is `atomic` then the string must `match`\n-    * a literal in the `lexical space` of {base type definition}\"\n-    *\/\n-    \/*\n-    * Whitespace-normalize.\n-    *\/\n-    NORMALIZE(type);\n-    if (type->type != XML_SCHEMA_TYPE_BASIC) {\n-        \/*\n-        * Get the built-in type.\n-        *\/\n-        biType = type->baseType;\n-        while ((biType != NULL) &&\n-        (biType->type != XML_SCHEMA_TYPE_BASIC))\n-        biType = biType->baseType;\n-\n-        if (biType == NULL) {\n-        AERROR_INT(\"xmlSchemaVCheckCVCSimpleType\",\n-            \"could not get the built-in type\");\n-        goto internal_error;\n-        }\n-    } else\n-        biType = type;\n-    \/*\n-    * NOTATIONs need to be processed here, since they need\n-    * to lookup in the hashtable of NOTATION declarations of the schema.\n-    *\/\n-    if (actxt->type == XML_SCHEMA_CTXT_VALIDATOR) {\n-        switch (biType->builtInType) {\n-        case XML_SCHEMAS_NOTATION:\n-            ret = xmlSchemaValidateNotation(\n-            (xmlSchemaValidCtxtPtr) actxt,\n-            ((xmlSchemaValidCtxtPtr) actxt)->schema,\n-            NULL, value, &val, valNeeded);\n-            break;\n-        case XML_SCHEMAS_QNAME:\n-            ret = xmlSchemaValidateQName((xmlSchemaValidCtxtPtr) actxt,\n-            value, &val, valNeeded);\n-            break;\n-        default:\n-            \/* ws = xmlSchemaGetWhiteSpaceFacetValue(type); *\/\n-            if (valNeeded)\n-            ret = xmlSchemaValPredefTypeNodeNoNorm(biType,\n-                value, &val, node);\n-            else\n-            ret = xmlSchemaValPredefTypeNodeNoNorm(biType,\n-                value, NULL, node);\n-            break;\n-        }\n-    } else if (actxt->type == XML_SCHEMA_CTXT_PARSER) {\n-        switch (biType->builtInType) {\n-        case XML_SCHEMAS_NOTATION:\n-            ret = xmlSchemaValidateNotation(NULL,\n-            ((xmlSchemaParserCtxtPtr) actxt)->schema, node,\n-            value, &val, valNeeded);\n-            break;\n-        default:\n-            \/* ws = xmlSchemaGetWhiteSpaceFacetValue(type); *\/\n-            if (valNeeded)\n-            ret = xmlSchemaValPredefTypeNodeNoNorm(biType,\n-                value, &val, node);\n-            else\n-            ret = xmlSchemaValPredefTypeNodeNoNorm(biType,\n-                value, NULL, node);\n-            break;\n-        }\n-    } else {\n-        \/*\n-        * Validation via a public API is not implemented yet.\n-        *\/\n-        goto internal_error;\n-    }\n-    if (ret != 0) {\n-        if (ret < 0) {\n-        AERROR_INT(\"xmlSchemaVCheckCVCSimpleType\",\n-            \"validating against a built-in type\");\n-        goto internal_error;\n-        }\n-        if (WXS_IS_LIST(type))\n-        ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;\n-        else\n-        ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1;\n-    }\n-    if ((ret == 0) && (type->flags & XML_SCHEMAS_TYPE_HAS_FACETS)) {\n-        \/*\n-        * Check facets.\n-        *\/\n-        ret = xmlSchemaValidateFacets(actxt, node, type,\n-        (xmlSchemaValType) biType->builtInType, value, val,\n-        0, fireErrors);\n-        if (ret != 0) {\n-        if (ret < 0) {\n-            AERROR_INT(\"xmlSchemaVCheckCVCSimpleType\",\n-            \"validating facets of atomic simple type\");\n-            goto internal_error;\n-        }\n-        if (WXS_IS_LIST(type))\n-            ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;\n-        else\n-            ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1;\n-        }\n-    }\n-    else if (fireErrors && (ret > 0))\n-        xmlSchemaSimpleTypeErr(actxt, ret, node, value, type, 1);\n-    } else if (WXS_IS_LIST(type)) {\n-\n-    xmlSchemaTypePtr itemType;\n-    const xmlChar *cur, *end;\n-    xmlChar *tmpValue = NULL;\n-    unsigned long len = 0;\n-    xmlSchemaValPtr prevVal = NULL, curVal = NULL;\n-    \/* 1.2.2 if {variety} is `list` then the string must be a sequence\n-    * of white space separated tokens, each of which `match`es a literal\n-    * in the `lexical space` of {item type definition}\n-    *\/\n-    \/*\n-    * Note that XML_SCHEMAS_TYPE_NORMVALUENEEDED will be set if\n-    * the list type has an enum or pattern facet.\n-    *\/\n-    NORMALIZE(type);\n-    \/*\n-    * VAL TODO: Optimize validation of empty values.\n-    * VAL TODO: We do not have computed values for lists.\n-    *\/\n-    itemType = WXS_LIST_ITEMTYPE(type);\n-    cur = value;\n-    do {\n-        while (IS_BLANK_CH(*cur))\n-        cur++;\n-        end = cur;\n-        while ((*end != 0) && (!(IS_BLANK_CH(*end))))\n-        end++;\n-        if (end == cur)\n-        break;\n-        tmpValue = xmlStrndup(cur, end - cur);\n-        len++;\n-\n-        if (valNeeded)\n-        ret = xmlSchemaVCheckCVCSimpleType(actxt, node, itemType,\n-            tmpValue, &curVal, fireErrors, 0, 1);\n-        else\n-        ret = xmlSchemaVCheckCVCSimpleType(actxt, node, itemType,\n-            tmpValue, NULL, fireErrors, 0, 1);\n-        FREE_AND_NULL(tmpValue);\n-        if (curVal != NULL) {\n-        \/*\n-        * Add to list of computed values.\n-        *\/\n-        if (val == NULL)\n-            val = curVal;\n-        else\n-            xmlSchemaValueAppend(prevVal, curVal);\n-        prevVal = curVal;\n-        curVal = NULL;\n-        }\n-        if (ret != 0) {\n-        if (ret < 0) {\n-            AERROR_INT(\"xmlSchemaVCheckCVCSimpleType\",\n-            \"validating an item of list simple type\");\n-            goto internal_error;\n-        }\n-        ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;\n-        break;\n-        }\n-        cur = end;\n-    } while (*cur != 0);\n-    FREE_AND_NULL(tmpValue);\n-    if ((ret == 0) && (type->flags & XML_SCHEMAS_TYPE_HAS_FACETS)) {\n-        \/*\n-        * Apply facets (pattern, enumeration).\n-        *\/\n-        ret = xmlSchemaValidateFacets(actxt, node, type,\n-        XML_SCHEMAS_UNKNOWN, value, val,\n-        len, fireErrors);\n-        if (ret != 0) {\n-        if (ret < 0) {\n-            AERROR_INT(\"xmlSchemaVCheckCVCSimpleType\",\n-            \"validating facets of list simple type\");\n-            goto internal_error;\n-        }\n-        ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;\n-        }\n-    }\n-    if (fireErrors && (ret > 0)) {\n-        \/*\n-        * Report the normalized value.\n-        *\/\n-        normalize = 1;\n-        NORMALIZE(type);\n-        xmlSchemaSimpleTypeErr(actxt, ret, node, value, type, 1);\n-    }\n-    } else if (WXS_IS_UNION(type)) {\n-    xmlSchemaTypeLinkPtr memberLink;\n-    \/*\n-    * TODO: For all datatypes `derived` by `union`  whiteSpace does\n-    * not apply directly; however, the normalization behavior of `union`\n-    * types is controlled by the value of whiteSpace on that one of the\n-    * `memberTypes` against which the `union` is successfully validated.\n-    *\n-    * This means that the value is normalized by the first validating\n-    * member type, then the facets of the union type are applied. This\n-    * needs changing of the value!\n-    *\/\n-\n-    \/*\n-    * 1.2.3 if {variety} is `union` then the string must `match` a\n-    * literal in the `lexical space` of at least one member of\n-    * {member type definitions}\n-    *\/\n-    memberLink = xmlSchemaGetUnionSimpleTypeMemberTypes(type);\n-    if (memberLink == NULL) {\n-        AERROR_INT(\"xmlSchemaVCheckCVCSimpleType\",\n-        \"union simple type has no member types\");\n-        goto internal_error;\n-    }\n-    \/*\n-    * Always normalize union type values, since we currently\n-    * cannot store the whitespace information with the value\n-    * itself; otherwise a later value-comparison would be\n-    * not possible.\n-    *\/\n-    while (memberLink != NULL) {\n-        if (valNeeded)\n-        ret = xmlSchemaVCheckCVCSimpleType(actxt, node,\n-            memberLink->type, value, &val, 0, 1, 0);\n-        else\n-        ret = xmlSchemaVCheckCVCSimpleType(actxt, node,\n-            memberLink->type, value, NULL, 0, 1, 0);\n-        if (ret <= 0)\n-        break;\n-        memberLink = memberLink->next;\n-    }\n-    if (ret != 0) {\n-        if (ret < 0) {\n-        AERROR_INT(\"xmlSchemaVCheckCVCSimpleType\",\n-            \"validating members of union simple type\");\n-        goto internal_error;\n-        }\n-        ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3;\n-    }\n-    \/*\n-    * Apply facets (pattern, enumeration).\n-    *\/\n-    if ((ret == 0) && (type->flags & XML_SCHEMAS_TYPE_HAS_FACETS)) {\n-        \/*\n-        * The normalization behavior of `union` types is controlled by\n-        * the value of whiteSpace on that one of the `memberTypes`\n-        * against which the `union` is successfully validated.\n-        *\/\n-        NORMALIZE(memberLink->type);\n-        ret = xmlSchemaValidateFacets(actxt, node, type,\n-        XML_SCHEMAS_UNKNOWN, value, val,\n-        0, fireErrors);\n-        if (ret != 0) {\n-        if (ret < 0) {\n-            AERROR_INT(\"xmlSchemaVCheckCVCSimpleType\",\n-            \"validating facets of union simple type\");\n-            goto internal_error;\n-        }\n-        ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3;\n-        }\n-    }\n-    if (fireErrors && (ret > 0))\n-        xmlSchemaSimpleTypeErr(actxt, ret, node, value, type, 1);\n-    }\n-\n-    if (normValue != NULL)\n-    xmlFree(normValue);\n-    if (ret == 0) {\n-    if (retVal != NULL)\n-        *retVal = val;\n-    else if (val != NULL)\n-        xmlSchemaFreeValue(val);\n-    } else if (val != NULL)\n-    xmlSchemaFreeValue(val);\n-    return (ret);\n-internal_error:\n-    if (normValue != NULL)\n-    xmlFree(normValue);\n-    if (val != NULL)\n-    xmlSchemaFreeValue(val);\n-    return (-1);\n-}\n-\n-static int\n-xmlSchemaVExpandQName(xmlSchemaValidCtxtPtr vctxt,\n-               const xmlChar *value,\n-               const xmlChar **nsName,\n-               const xmlChar **localName)\n-{\n-    int ret = 0;\n-\n-    if ((nsName == NULL) || (localName == NULL))\n-    return (-1);\n-    *nsName = NULL;\n-    *localName = NULL;\n-\n-    ret = xmlValidateQName(value, 1);\n-    if (ret == -1)\n-    return (-1);\n-    if (ret > 0) {\n-    xmlSchemaSimpleTypeErr(ACTXT_CAST vctxt,\n-        XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1, NULL,\n-        value, xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME), 1);\n-    return (1);\n-    }\n-    {\n-    xmlChar *local = NULL;\n-    xmlChar *prefix;\n-\n-    \/*\n-    * NOTE: xmlSplitQName2 will return a duplicated\n-    * string.\n-    *\/\n-    local = xmlSplitQName2(value, &prefix);\n-    if (local == NULL)\n-        *localName = xmlDictLookup(vctxt->dict, value, -1);\n-    else {\n-        *localName = xmlDictLookup(vctxt->dict, local, -1);\n-        xmlFree(local);\n-    }\n-\n-    *nsName = xmlSchemaLookupNamespace(vctxt, prefix);\n-\n-    if (prefix != NULL) {\n-        xmlFree(prefix);\n-        \/*\n-        * A namespace must be found if the prefix is NOT NULL.\n-        *\/\n-        if (*nsName == NULL) {\n-        xmlSchemaCustomErr(ACTXT_CAST vctxt,\n-            XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1, NULL,\n-            WXS_BASIC_CAST xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),\n-            \"The QName value '%s' has no \"\n-            \"corresponding namespace declaration in scope\",\n-            value, NULL);\n-        return (2);\n-        }\n-    }\n-    }\n-    return (0);\n-}\n-\n-static int\n-xmlSchemaProcessXSIType(xmlSchemaValidCtxtPtr vctxt,\n-            xmlSchemaAttrInfoPtr iattr,\n-            xmlSchemaTypePtr *localType,\n-            xmlSchemaElementPtr elemDecl)\n-{\n-    int ret = 0;\n-    \/*\n-    * cvc-elt (3.3.4) : (4)\n-    * AND\n-    * Schema-Validity Assessment (Element) (cvc-assess-elt)\n-    *   (1.2.1.2.1) - (1.2.1.2.4)\n-    * Handle 'xsi:type'.\n-    *\/\n-    if (localType == NULL)\n-    return (-1);\n-    *localType = NULL;\n-    if (iattr == NULL)\n-    return (0);\n-    else {\n-    const xmlChar *nsName = NULL, *local = NULL;\n-    \/*\n-    * TODO: We should report a *warning* that the type was overridden\n-    * by the instance.\n-    *\/\n-    ACTIVATE_ATTRIBUTE(iattr);\n-    \/*\n-    * (cvc-elt) (3.3.4) : (4.1)\n-    * (cvc-assess-elt) (1.2.1.2.2)\n-    *\/\n-    ret = xmlSchemaVExpandQName(vctxt, iattr->value,\n-        &nsName, &local);\n-    if (ret != 0) {\n-        if (ret < 0) {\n-        VERROR_INT(\"xmlSchemaValidateElementByDeclaration\",\n-            \"calling xmlSchemaQNameExpand() to validate the \"\n-            \"attribute 'xsi:type'\");\n-        goto internal_error;\n-        }\n-        goto exit;\n-    }\n-    \/*\n-    * (cvc-elt) (3.3.4) : (4.2)\n-    * (cvc-assess-elt) (1.2.1.2.3)\n-    *\/\n-    *localType = xmlSchemaGetType(vctxt->schema, local, nsName);\n-    if (*localType == NULL) {\n-        xmlChar *str = NULL;\n-\n-        xmlSchemaCustomErr(ACTXT_CAST vctxt,\n-        XML_SCHEMAV_CVC_ELT_4_2, NULL,\n-        WXS_BASIC_CAST xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),\n-        \"The QName value '%s' of the xsi:type attribute does not \"\n-        \"resolve to a type definition\",\n-        xmlSchemaFormatQName(&str, nsName, local), NULL);\n-        FREE_AND_NULL(str);\n-        ret = vctxt->err;\n-        goto exit;\n-    }\n-    if (elemDecl != NULL) {\n-        int set = 0;\n-\n-        \/*\n-        * SPEC cvc-elt (3.3.4) : (4.3) (Type Derivation OK)\n-        * \"The `local type definition` must be validly\n-        * derived from the {type definition} given the union of\n-        * the {disallowed substitutions} and the {type definition}'s\n-        * {prohibited substitutions}, as defined in\n-        * Type Derivation OK (Complex) ($3.4.6)\n-        * (if it is a complex type definition),\n-        * or given {disallowed substitutions} as defined in Type\n-        * Derivation OK (Simple) ($3.14.6) (if it is a simple type\n-        * definition).\"\n-        *\n-        * {disallowed substitutions}: the \"block\" on the element decl.\n-        * {prohibited substitutions}: the \"block\" on the type def.\n-        *\/\n-        \/*\n-        * OPTIMIZE TODO: We could map types already evaluated\n-        * to be validly derived from other types to avoid checking\n-        * this over and over for the same types.\n-        *\/\n-        if ((elemDecl->flags & XML_SCHEMAS_ELEM_BLOCK_EXTENSION) ||\n-        (elemDecl->subtypes->flags &\n-            XML_SCHEMAS_TYPE_BLOCK_EXTENSION))\n-        set |= SUBSET_EXTENSION;\n-\n-        if ((elemDecl->flags & XML_SCHEMAS_ELEM_BLOCK_RESTRICTION) ||\n-        (elemDecl->subtypes->flags &\n-            XML_SCHEMAS_TYPE_BLOCK_RESTRICTION))\n-        set |= SUBSET_RESTRICTION;\n-\n-        \/*\n-        * REMOVED and CHANGED since this produced a parser context\n-        * which adds to the string dict of the schema. So this would\n-        * change the schema and we don't want this. We don't need\n-        * the parser context anymore.\n-        *\n-        * if ((vctxt->pctxt == NULL) &&\n-        *    (xmlSchemaCreatePCtxtOnVCtxt(vctxt) == -1))\n-        *        return (-1);\n-        *\/\n-\n-        if (xmlSchemaCheckCOSDerivedOK(ACTXT_CAST vctxt, *localType,\n-        elemDecl->subtypes, set) != 0) {\n-        xmlChar *str = NULL;\n-\n-        xmlSchemaCustomErr(ACTXT_CAST vctxt,\n-            XML_SCHEMAV_CVC_ELT_4_3, NULL, NULL,\n-            \"The type definition '%s', specified by xsi:type, is \"\n-            \"blocked or not validly derived from the type definition \"\n-            \"of the element declaration\",\n-            xmlSchemaFormatQName(&str,\n-            (*localType)->targetNamespace,\n-            (*localType)->name),\n-            NULL);\n-        FREE_AND_NULL(str);\n-        ret = vctxt->err;\n-        *localType = NULL;\n-        }\n-    }\n-    }\n-exit:\n-    ACTIVATE_ELEM;\n-    return (ret);\n-internal_error:\n-    ACTIVATE_ELEM;\n-    return (-1);\n-}\n-\n-static int\n-xmlSchemaValidateElemDecl(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    xmlSchemaElementPtr elemDecl = vctxt->inode->decl;\n-    xmlSchemaTypePtr actualType;\n-\n-    \/*\n-    * cvc-elt (3.3.4) : 1\n-    *\/\n-    if (elemDecl == NULL) {\n-    VERROR(XML_SCHEMAV_CVC_ELT_1, NULL,\n-        \"No matching declaration available\");\n-        return (vctxt->err);\n-    }\n-    actualType = WXS_ELEM_TYPEDEF(elemDecl);\n-    \/*\n-    * cvc-elt (3.3.4) : 2\n-    *\/\n-    if (elemDecl->flags & XML_SCHEMAS_ELEM_ABSTRACT) {\n-    VERROR(XML_SCHEMAV_CVC_ELT_2, NULL,\n-        \"The element declaration is abstract\");\n-        return (vctxt->err);\n-    }\n-    if (actualType == NULL) {\n-    VERROR(XML_SCHEMAV_CVC_TYPE_1, NULL,\n-        \"The type definition is absent\");\n-    return (XML_SCHEMAV_CVC_TYPE_1);\n-    }\n-    if (vctxt->nbAttrInfos != 0) {\n-    int ret;\n-    xmlSchemaAttrInfoPtr iattr;\n-    \/*\n-    * cvc-elt (3.3.4) : 3\n-    * Handle 'xsi:nil'.\n-    *\/\n-    iattr = xmlSchemaGetMetaAttrInfo(vctxt,\n-        XML_SCHEMA_ATTR_INFO_META_XSI_NIL);\n-    if (iattr) {\n-        ACTIVATE_ATTRIBUTE(iattr);\n-        \/*\n-        * Validate the value.\n-        *\/\n-        ret = xmlSchemaVCheckCVCSimpleType(\n-        ACTXT_CAST vctxt, NULL,\n-        xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),\n-        iattr->value, &(iattr->val), 1, 0, 0);\n-        ACTIVATE_ELEM;\n-        if (ret < 0) {\n-        VERROR_INT(\"xmlSchemaValidateElemDecl\",\n-            \"calling xmlSchemaVCheckCVCSimpleType() to \"\n-            \"validate the attribute 'xsi:nil'\");\n-        return (-1);\n-        }\n-        if (ret == 0) {\n-        if ((elemDecl->flags & XML_SCHEMAS_ELEM_NILLABLE) == 0) {\n-            \/*\n-            * cvc-elt (3.3.4) : 3.1\n-            *\/\n-            VERROR(XML_SCHEMAV_CVC_ELT_3_1, NULL,\n-            \"The element is not 'nillable'\");\n-            \/* Does not return an error on purpose. *\/\n-        } else {\n-            if (xmlSchemaValueGetAsBoolean(iattr->val)) {\n-            \/*\n-            * cvc-elt (3.3.4) : 3.2.2\n-            *\/\n-            if ((elemDecl->flags & XML_SCHEMAS_ELEM_FIXED) &&\n-                (elemDecl->value != NULL)) {\n-                VERROR(XML_SCHEMAV_CVC_ELT_3_2_2, NULL,\n-                \"The element cannot be 'nilled' because \"\n-                \"there is a fixed value constraint defined \"\n-                \"for it\");\n-                 \/* Does not return an error on purpose. *\/\n-            } else\n-                vctxt->inode->flags |=\n-                XML_SCHEMA_ELEM_INFO_NILLED;\n-            }\n-        }\n-        }\n-    }\n-    \/*\n-    * cvc-elt (3.3.4) : 4\n-    * Handle 'xsi:type'.\n-    *\/\n-    iattr = xmlSchemaGetMetaAttrInfo(vctxt,\n-        XML_SCHEMA_ATTR_INFO_META_XSI_TYPE);\n-    if (iattr) {\n-        xmlSchemaTypePtr localType = NULL;\n-\n-        ret = xmlSchemaProcessXSIType(vctxt, iattr, &localType,\n-        elemDecl);\n-        if (ret != 0) {\n-        if (ret == -1) {\n-            VERROR_INT(\"xmlSchemaValidateElemDecl\",\n-            \"calling xmlSchemaProcessXSIType() to \"\n-            \"process the attribute 'xsi:type'\");\n-            return (-1);\n-        }\n-        \/* Does not return an error on purpose. *\/\n-        }\n-        if (localType != NULL) {\n-        vctxt->inode->flags |= XML_SCHEMA_ELEM_INFO_LOCAL_TYPE;\n-        actualType = localType;\n-        }\n-    }\n-    }\n-    \/*\n-    * IDC: Register identity-constraint XPath matchers.\n-    *\/\n-    if ((elemDecl->idcs != NULL) &&\n-    (xmlSchemaIDCRegisterMatchers(vctxt, elemDecl) == -1))\n-        return (-1);\n-    \/*\n-    * No actual type definition.\n-    *\/\n-    if (actualType == NULL) {\n-    VERROR(XML_SCHEMAV_CVC_TYPE_1, NULL,\n-        \"The type definition is absent\");\n-    return (XML_SCHEMAV_CVC_TYPE_1);\n-    }\n-    \/*\n-    * Remember the actual type definition.\n-    *\/\n-    vctxt->inode->typeDef = actualType;\n-\n-    return (0);\n-}\n-\n-static int\n-xmlSchemaVAttributesSimple(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    xmlSchemaAttrInfoPtr iattr;\n-    int ret = 0, i;\n-\n-    \/*\n-    * SPEC cvc-type (3.1.1)\n-    * \"The attributes of must be empty, excepting those whose namespace\n-    * name is identical to http:\/\/www.w3.org\/2001\/XMLSchema-instance and\n-    * whose local name is one of type, nil, schemaLocation or\n-    * noNamespaceSchemaLocation.\"\n-    *\/\n-    if (vctxt->nbAttrInfos == 0)\n-    return (0);\n-    for (i = 0; i < vctxt->nbAttrInfos; i++) {\n-    iattr = vctxt->attrInfos[i];\n-    if (! iattr->metaType) {\n-        ACTIVATE_ATTRIBUTE(iattr)\n-        xmlSchemaIllegalAttrErr(ACTXT_CAST vctxt,\n-        XML_SCHEMAV_CVC_TYPE_3_1_1, iattr, NULL);\n-        ret = XML_SCHEMAV_CVC_TYPE_3_1_1;\n-        }\n-    }\n-    ACTIVATE_ELEM\n-    return (ret);\n-}\n-\n-\/*\n-* Cleanup currently used attribute infos.\n-*\/\n-static void\n-xmlSchemaClearAttrInfos(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    int i;\n-    xmlSchemaAttrInfoPtr attr;\n-\n-    if (vctxt->nbAttrInfos == 0)\n-    return;\n-    for (i = 0; i < vctxt->nbAttrInfos; i++) {\n-    attr = vctxt->attrInfos[i];\n-    if (attr->flags & XML_SCHEMA_NODE_INFO_FLAG_OWNED_NAMES) {\n-        if (attr->localName != NULL)\n-        xmlFree((xmlChar *) attr->localName);\n-        if (attr->nsName != NULL)\n-        xmlFree((xmlChar *) attr->nsName);\n-    }\n-    if (attr->flags & XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES) {\n-        if (attr->value != NULL)\n-        xmlFree((xmlChar *) attr->value);\n-    }\n-    if (attr->val != NULL) {\n-        xmlSchemaFreeValue(attr->val);\n-        attr->val = NULL;\n-    }\n-    memset(attr, 0, sizeof(xmlSchemaAttrInfo));\n-    }\n-    vctxt->nbAttrInfos = 0;\n-}\n-\n-\/*\n-* 3.4.4 Complex Type Definition Validation Rules\n-*   Element Locally Valid (Complex Type) (cvc-complex-type)\n-* 3.2.4 Attribute Declaration Validation Rules\n-*   Validation Rule: Attribute Locally Valid (cvc-attribute)\n-*   Attribute Locally Valid (Use) (cvc-au)\n-*\n-* Only \"assessed\" attribute information items will be visible to\n-* IDCs. I.e. not \"lax\" (without declaration) and \"skip\" wild attributes.\n-*\/\n-static int\n-xmlSchemaVAttributesComplex(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    xmlSchemaTypePtr type = vctxt->inode->typeDef;\n-    xmlSchemaItemListPtr attrUseList;\n-    xmlSchemaAttributeUsePtr attrUse = NULL;\n-    xmlSchemaAttributePtr attrDecl = NULL;\n-    xmlSchemaAttrInfoPtr iattr, tmpiattr;\n-    int i, j, found, nbAttrs, nbUses;\n-    int xpathRes = 0, res, wildIDs = 0, fixed;\n-    xmlNodePtr defAttrOwnerElem = NULL;\n-\n-    \/*\n-    * SPEC (cvc-attribute)\n-    * (1) \"The declaration must not be `absent` (see Missing\n-    * Sub-components ($5.3) for how this can fail to be\n-    * the case).\"\n-    * (2) \"Its {type definition} must not be absent.\"\n-    *\n-    * NOTE (1) + (2): This is not handled here, since we currently do not\n-    * allow validation against schemas which have missing sub-components.\n-    *\n-    * SPEC (cvc-complex-type)\n-    * (3) \"For each attribute information item in the element information\n-    * item's [attributes] excepting those whose [namespace name] is\n-    * identical to http:\/\/www.w3.org\/2001\/XMLSchema-instance and whose\n-    * [local name] is one of type, nil, schemaLocation or\n-    * noNamespaceSchemaLocation, the appropriate case among the following\n-    * must be true:\n-    *\n-    *\/\n-    attrUseList = (xmlSchemaItemListPtr) type->attrUses;\n-    \/*\n-    * @nbAttrs is the number of attributes present in the instance.\n-    *\/\n-    nbAttrs = vctxt->nbAttrInfos;\n-    if (attrUseList != NULL)\n-    nbUses = attrUseList->nbItems;\n-    else\n-    nbUses = 0;\n-    for (i = 0; i < nbUses; i++) {\n-        found = 0;\n-    attrUse = attrUseList->items[i];\n-    attrDecl = WXS_ATTRUSE_DECL(attrUse);\n-        for (j = 0; j < nbAttrs; j++) {\n-        iattr = vctxt->attrInfos[j];\n-        \/*\n-        * SPEC (cvc-complex-type) (3)\n-        * Skip meta attributes.\n-        *\/\n-        if (iattr->metaType)\n-        continue;\n-        if (iattr->localName[0] != attrDecl->name[0])\n-        continue;\n-        if (!xmlStrEqual(iattr->localName, attrDecl->name))\n-        continue;\n-        if (!xmlStrEqual(iattr->nsName, attrDecl->targetNamespace))\n-        continue;\n-        found = 1;\n-        \/*\n-        * SPEC (cvc-complex-type)\n-        * (3.1) \"If there is among the {attribute uses} an attribute\n-        * use with an {attribute declaration} whose {name} matches\n-        * the attribute information item's [local name] and whose\n-        * {target namespace} is identical to the attribute information\n-        * item's [namespace name] (where an `absent` {target namespace}\n-        * is taken to be identical to a [namespace name] with no value),\n-        * then the attribute information must be `valid` with respect\n-        * to that attribute use as per Attribute Locally Valid (Use)\n-        * ($3.5.4). In this case the {attribute declaration} of that\n-        * attribute use is the `context-determined declaration` for the\n-        * attribute information item with respect to Schema-Validity\n-        * Assessment (Attribute) ($3.2.4) and\n-        * Assessment Outcome (Attribute) ($3.2.5).\n-        *\/\n-        iattr->state = XML_SCHEMAS_ATTR_ASSESSED;\n-        iattr->use = attrUse;\n-        \/*\n-        * Context-determined declaration.\n-        *\/\n-        iattr->decl = attrDecl;\n-        iattr->typeDef = attrDecl->subtypes;\n-        break;\n-    }\n-\n-    if (found)\n-        continue;\n-\n-    if (attrUse->occurs == XML_SCHEMAS_ATTR_USE_REQUIRED) {\n-        \/*\n-        * Handle non-existent, required attributes.\n-        *\n-        * SPEC (cvc-complex-type)\n-        * (4) \"The {attribute declaration} of each attribute use in\n-        * the {attribute uses} whose {required} is true matches one\n-        * of the attribute information items in the element information\n-        * item's [attributes] as per clause 3.1 above.\"\n-        *\/\n-        tmpiattr = xmlSchemaGetFreshAttrInfo(vctxt);\n-        if (tmpiattr == NULL) {\n-        VERROR_INT(\n-            \"xmlSchemaVAttributesComplex\",\n-            \"calling xmlSchemaGetFreshAttrInfo()\");\n-        return (-1);\n-        }\n-        tmpiattr->state = XML_SCHEMAS_ATTR_ERR_MISSING;\n-        tmpiattr->use = attrUse;\n-        tmpiattr->decl = attrDecl;\n-    } else if ((attrUse->occurs == XML_SCHEMAS_ATTR_USE_OPTIONAL) &&\n-        ((attrUse->defValue != NULL) ||\n-         (attrDecl->defValue != NULL))) {\n-        \/*\n-        * Handle non-existent, optional, default\/fixed attributes.\n-        *\/\n-        tmpiattr = xmlSchemaGetFreshAttrInfo(vctxt);\n-        if (tmpiattr == NULL) {\n-        VERROR_INT(\n-            \"xmlSchemaVAttributesComplex\",\n-            \"calling xmlSchemaGetFreshAttrInfo()\");\n-        return (-1);\n-        }\n-        tmpiattr->state = XML_SCHEMAS_ATTR_DEFAULT;\n-        tmpiattr->use = attrUse;\n-        tmpiattr->decl = attrDecl;\n-        tmpiattr->typeDef = attrDecl->subtypes;\n-        tmpiattr->localName = attrDecl->name;\n-        tmpiattr->nsName = attrDecl->targetNamespace;\n-    }\n-    }\n-\n-    if (vctxt->nbAttrInfos == 0)\n-    return (0);\n-    \/*\n-    * Validate against the wildcard.\n-    *\/\n-    if (type->attributeWildcard != NULL) {\n-    \/*\n-    * SPEC (cvc-complex-type)\n-    * (3.2.1) \"There must be an {attribute wildcard}.\"\n-    *\/\n-    for (i = 0; i < nbAttrs; i++) {\n-        iattr = vctxt->attrInfos[i];\n-        \/*\n-        * SPEC (cvc-complex-type) (3)\n-        * Skip meta attributes.\n-        *\/\n-        if (iattr->state != XML_SCHEMAS_ATTR_UNKNOWN)\n-        continue;\n-        \/*\n-        * SPEC (cvc-complex-type)\n-        * (3.2.2) \"The attribute information item must be `valid` with\n-        * respect to it as defined in Item Valid (Wildcard) ($3.10.4).\"\n-        *\n-        * SPEC Item Valid (Wildcard) (cvc-wildcard)\n-        * \"... its [namespace name] must be `valid` with respect to\n-        * the wildcard constraint, as defined in Wildcard allows\n-        * Namespace Name ($3.10.4).\"\n-        *\/\n-        if (xmlSchemaCheckCVCWildcardNamespace(type->attributeWildcard,\n-            iattr->nsName) == 0) {\n-        \/*\n-        * Handle processContents.\n-        *\n-        * SPEC (cvc-wildcard):\n-        * processContents | context-determined declaration:\n-        * \"strict\"          \"mustFind\"\n-        * \"lax\"             \"none\"\n-        * \"skip\"            \"skip\"\n-        *\/\n-        if (type->attributeWildcard->processContents ==\n-            XML_SCHEMAS_ANY_SKIP) {\n-             \/*\n-            * context-determined declaration = \"skip\"\n-            *\n-            * SPEC PSVI Assessment Outcome (Attribute)\n-            * [validity] = \"notKnown\"\n-            * [validation attempted] = \"none\"\n-            *\/\n-            iattr->state = XML_SCHEMAS_ATTR_WILD_SKIP;\n-            continue;\n-        }\n-        \/*\n-        * Find an attribute declaration.\n-        *\/\n-        iattr->decl = xmlSchemaGetAttributeDecl(vctxt->schema,\n-            iattr->localName, iattr->nsName);\n-        if (iattr->decl != NULL) {\n-            iattr->state = XML_SCHEMAS_ATTR_ASSESSED;\n-            \/*\n-            * SPEC (cvc-complex-type)\n-            * (5) \"Let [Definition:]  the wild IDs be the set of\n-            * all attribute information item to which clause 3.2\n-            * applied and whose `validation` resulted in a\n-            * `context-determined declaration` of mustFind or no\n-            * `context-determined declaration` at all, and whose\n-            * [local name] and [namespace name] resolve (as\n-            * defined by QName resolution (Instance) ($3.15.4)) to\n-            * an attribute declaration whose {type definition} is\n-            * or is derived from ID. Then all of the following\n-            * must be true:\"\n-            *\/\n-            iattr->typeDef = WXS_ATTR_TYPEDEF(iattr->decl);\n-            if (xmlSchemaIsDerivedFromBuiltInType(\n-            iattr->typeDef, XML_SCHEMAS_ID)) {\n-            \/*\n-            * SPEC (5.1) \"There must be no more than one\n-            * item in `wild IDs`.\"\n-            *\/\n-            if (wildIDs != 0) {\n-                \/* VAL TODO *\/\n-                iattr->state = XML_SCHEMAS_ATTR_ERR_WILD_DUPLICATE_ID;\n-                continue;\n-            }\n-            wildIDs++;\n-            \/*\n-            * SPEC (cvc-complex-type)\n-            * (5.2) \"If `wild IDs` is non-empty, there must not\n-            * be any attribute uses among the {attribute uses}\n-            * whose {attribute declaration}'s {type definition}\n-            * is or is derived from ID.\"\n-            *\/\n-                        if (attrUseList != NULL) {\n-                            for (j = 0; j < attrUseList->nbItems; j++) {\n-                                if (xmlSchemaIsDerivedFromBuiltInType(\n-                                    WXS_ATTRUSE_TYPEDEF(attrUseList->items[j]),\n-                                    XML_SCHEMAS_ID)) {\n-                                    \/* URGENT VAL TODO: implement *\/\n-                            iattr->state = XML_SCHEMAS_ATTR_ERR_WILD_AND_USE_ID;\n-                                    break;\n-                                }\n-                            }\n-                        }\n-            }\n-        } else if (type->attributeWildcard->processContents ==\n-            XML_SCHEMAS_ANY_LAX) {\n-            iattr->state = XML_SCHEMAS_ATTR_WILD_LAX_NO_DECL;\n-            \/*\n-            * SPEC PSVI Assessment Outcome (Attribute)\n-            * [validity] = \"notKnown\"\n-            * [validation attempted] = \"none\"\n-            *\/\n-        } else {\n-            iattr->state = XML_SCHEMAS_ATTR_ERR_WILD_STRICT_NO_DECL;\n-        }\n-        }\n-    }\n-    }\n-\n-    if (vctxt->nbAttrInfos == 0)\n-    return (0);\n-\n-    \/*\n-    * Get the owner element; needed for creation of default attributes.\n-    * This fixes bug #341337, reported by David Grohmann.\n-    *\/\n-    if (vctxt->options & XML_SCHEMA_VAL_VC_I_CREATE) {\n-    xmlSchemaNodeInfoPtr ielem = vctxt->elemInfos[vctxt->depth];\n-    if (ielem && ielem->node && ielem->node->doc)\n-        defAttrOwnerElem = ielem->node;\n-    }\n-    \/*\n-    * Validate values, create default attributes, evaluate IDCs.\n-    *\/\n-    for (i = 0; i < vctxt->nbAttrInfos; i++) {\n-    iattr = vctxt->attrInfos[i];\n-    \/*\n-    * VAL TODO: Note that we won't try to resolve IDCs to\n-    * \"lax\" and \"skip\" validated attributes. Check what to\n-    * do in this case.\n-    *\/\n-    if ((iattr->state != XML_SCHEMAS_ATTR_ASSESSED) &&\n-        (iattr->state != XML_SCHEMAS_ATTR_DEFAULT))\n-        continue;\n-    \/*\n-    * VAL TODO: What to do if the type definition is missing?\n-    *\/\n-    if (iattr->typeDef == NULL) {\n-        iattr->state = XML_SCHEMAS_ATTR_ERR_NO_TYPE;\n-        continue;\n-    }\n-\n-    ACTIVATE_ATTRIBUTE(iattr);\n-    fixed = 0;\n-    xpathRes = 0;\n-\n-    if (vctxt->xpathStates != NULL) {\n-        \/*\n-        * Evaluate IDCs.\n-        *\/\n-        xpathRes = xmlSchemaXPathEvaluate(vctxt,\n-        XML_ATTRIBUTE_NODE);\n-        if (xpathRes == -1) {\n-        VERROR_INT(\"xmlSchemaVAttributesComplex\",\n-            \"calling xmlSchemaXPathEvaluate()\");\n-        goto internal_error;\n-        }\n-    }\n-\n-    if (iattr->state == XML_SCHEMAS_ATTR_DEFAULT) {\n-        \/*\n-        * Default\/fixed attributes.\n-        * We need the value only if we need to resolve IDCs or\n-        * will create default attributes.\n-        *\/\n-        if ((xpathRes) || (defAttrOwnerElem)) {\n-        if (iattr->use->defValue != NULL) {\n-            iattr->value = (xmlChar *) iattr->use->defValue;\n-            iattr->val = iattr->use->defVal;\n-        } else {\n-            iattr->value = (xmlChar *) iattr->decl->defValue;\n-            iattr->val = iattr->decl->defVal;\n-        }\n-        \/*\n-        * IDCs will consume the precomputed default value,\n-        * so we need to clone it.\n-        *\/\n-        if (iattr->val == NULL) {\n-            VERROR_INT(\"xmlSchemaVAttributesComplex\",\n-            \"default\/fixed value on an attribute use was \"\n-            \"not precomputed\");\n-            goto internal_error;\n-        }\n-        iattr->val = xmlSchemaCopyValue(iattr->val);\n-        if (iattr->val == NULL) {\n-            VERROR_INT(\"xmlSchemaVAttributesComplex\",\n-            \"calling xmlSchemaCopyValue()\");\n-            goto internal_error;\n-        }\n-        }\n-        \/*\n-        * PSVI: Add the default attribute to the current element.\n-        * VAL TODO: Should we use the *normalized* value? This currently\n-        *   uses the *initial* value.\n-        *\/\n-\n-        if (defAttrOwnerElem) {\n-        xmlChar *normValue;\n-        const xmlChar *value;\n-\n-        value = iattr->value;\n-        \/*\n-        * Normalize the value.\n-        *\/\n-        normValue = xmlSchemaNormalizeValue(iattr->typeDef,\n-            iattr->value);\n-        if (normValue != NULL)\n-            value = BAD_CAST normValue;\n-\n-        if (iattr->nsName == NULL) {\n-            if (xmlNewProp(defAttrOwnerElem,\n-            iattr->localName, value) == NULL) {\n-            VERROR_INT(\"xmlSchemaVAttributesComplex\",\n-                \"calling xmlNewProp()\");\n-            if (normValue != NULL)\n-                xmlFree(normValue);\n-            goto internal_error;\n-            }\n-        } else {\n-            xmlNsPtr ns;\n-\n-            ns = xmlSearchNsByHref(defAttrOwnerElem->doc,\n-            defAttrOwnerElem, iattr->nsName);\n-            if (ns == NULL) {\n-            xmlChar prefix[13];\n-            int counter = 0;\n-\n-            \/*\n-            * Create a namespace declaration on the validation\n-            * root node if no namespace declaration is in scope.\n-            *\/\n-            do {\n-                snprintf((char *) prefix, 13, \"p%d\", counter++);\n-                ns = xmlSearchNs(defAttrOwnerElem->doc,\n-                defAttrOwnerElem, BAD_CAST prefix);\n-                if (counter > 1000) {\n-                VERROR_INT(\n-                    \"xmlSchemaVAttributesComplex\",\n-                    \"could not compute a ns prefix for a \"\n-                    \"default\/fixed attribute\");\n-                if (normValue != NULL)\n-                    xmlFree(normValue);\n-                goto internal_error;\n-                }\n-            } while (ns != NULL);\n-            ns = xmlNewNs(vctxt->validationRoot,\n-                iattr->nsName, BAD_CAST prefix);\n-            }\n-            \/*\n-            * TODO:\n-            * http:\/\/lists.w3.org\/Archives\/Public\/www-xml-schema-comments\/2005JulSep\/0406.html\n-            * If we have QNames: do we need to ensure there's a\n-            * prefix defined for the QName?\n-            *\/\n-            xmlNewNsProp(defAttrOwnerElem, ns, iattr->localName, value);\n-        }\n-        if (normValue != NULL)\n-            xmlFree(normValue);\n-        }\n-        \/*\n-        * Go directly to IDC evaluation.\n-        *\/\n-        goto eval_idcs;\n-    }\n-    \/*\n-    * Validate the value.\n-    *\/\n-    if (vctxt->value != NULL) {\n-        \/*\n-        * Free last computed value; just for safety reasons.\n-        *\/\n-        xmlSchemaFreeValue(vctxt->value);\n-        vctxt->value = NULL;\n-    }\n-    \/*\n-    * Note that the attribute *use* can be unavailable, if\n-    * the attribute was a wild attribute.\n-    *\/\n-    if ((iattr->decl->flags & XML_SCHEMAS_ATTR_FIXED) ||\n-        ((iattr->use != NULL) &&\n-         (iattr->use->flags & XML_SCHEMAS_ATTR_FIXED)))\n-        fixed = 1;\n-    else\n-        fixed = 0;\n-    \/*\n-    * SPEC (cvc-attribute)\n-    * (3) \"The item's `normalized value` must be locally `valid`\n-    * with respect to that {type definition} as per\n-    * String Valid ($3.14.4).\"\n-    *\n-    * VAL TODO: Do we already have the\n-    * \"normalized attribute value\" here?\n-    *\/\n-    if (xpathRes || fixed) {\n-        iattr->flags |= XML_SCHEMA_NODE_INFO_VALUE_NEEDED;\n-        \/*\n-        * Request a computed value.\n-        *\/\n-        res = xmlSchemaVCheckCVCSimpleType(\n-        ACTXT_CAST vctxt,\n-        iattr->node, iattr->typeDef, iattr->value, &(iattr->val),\n-        1, 1, 0);\n-    } else {\n-        res = xmlSchemaVCheckCVCSimpleType(\n-        ACTXT_CAST vctxt,\n-        iattr->node, iattr->typeDef, iattr->value, NULL,\n-        1, 0, 0);\n-    }\n-\n-    if (res != 0) {\n-        if (res == -1) {\n-        VERROR_INT(\"xmlSchemaVAttributesComplex\",\n-            \"calling xmlSchemaStreamValidateSimpleTypeValue()\");\n-        goto internal_error;\n-        }\n-        iattr->state = XML_SCHEMAS_ATTR_INVALID_VALUE;\n-        \/*\n-        * SPEC PSVI Assessment Outcome (Attribute)\n-        * [validity] = \"invalid\"\n-        *\/\n-        goto eval_idcs;\n-    }\n-\n-    if (fixed) {\n-        \/*\n-        * SPEC Attribute Locally Valid (Use) (cvc-au)\n-        * \"For an attribute information item to be `valid`\n-        * with respect to an attribute use its *normalized*\n-        * value must match the *canonical* lexical\n-        * representation of the attribute use's {value\n-        * constraint}value, if it is present and fixed.\"\n-        *\n-        * VAL TODO: The requirement for the *canonical* value\n-        * will be removed in XML Schema 1.1.\n-        *\/\n-        \/*\n-        * SPEC Attribute Locally Valid (cvc-attribute)\n-        * (4) \"The item's *actual* value must match the *value* of\n-        * the {value constraint}, if it is present and fixed.\"\n-        *\/\n-        if (iattr->val == NULL) {\n-        \/* VAL TODO: A value was not precomputed. *\/\n-        goto eval_idcs;\n-        }\n-        if ((iattr->use != NULL) &&\n-        (iattr->use->defValue != NULL)) {\n-        if (iattr->use->defVal == NULL) {\n-            \/* VAL TODO: A default value was not precomputed. *\/\n-            goto eval_idcs;\n-        }\n-        iattr->vcValue = iattr->use->defValue;\n-        \/*\n-        if (xmlSchemaCompareValuesWhtsp(attr->val,\n-            (xmlSchemaWhitespaceValueType) ws,\n-            attr->use->defVal,\n-            (xmlSchemaWhitespaceValueType) ws) != 0) {\n-        *\/\n-        if (! xmlSchemaAreValuesEqual(iattr->val, iattr->use->defVal))\n-            iattr->state = XML_SCHEMAS_ATTR_ERR_FIXED_VALUE;\n-        } else {\n-        if (iattr->decl->defVal == NULL) {\n-            \/* VAL TODO: A default value was not precomputed. *\/\n-            goto eval_idcs;\n-        }\n-        iattr->vcValue = iattr->decl->defValue;\n-        \/*\n-        if (xmlSchemaCompareValuesWhtsp(attr->val,\n-            (xmlSchemaWhitespaceValueType) ws,\n-            attrDecl->defVal,\n-            (xmlSchemaWhitespaceValueType) ws) != 0) {\n-        *\/\n-        if (! xmlSchemaAreValuesEqual(iattr->val, iattr->decl->defVal))\n-            iattr->state = XML_SCHEMAS_ATTR_ERR_FIXED_VALUE;\n-        }\n-        \/*\n-        * [validity] = \"valid\"\n-        *\/\n-    }\n-eval_idcs:\n-    \/*\n-    * Evaluate IDCs.\n-    *\/\n-    if (xpathRes) {\n-        if (xmlSchemaXPathProcessHistory(vctxt,\n-        vctxt->depth +1) == -1) {\n-        VERROR_INT(\"xmlSchemaVAttributesComplex\",\n-            \"calling xmlSchemaXPathEvaluate()\");\n-        goto internal_error;\n-        }\n-    } else if (vctxt->xpathStates != NULL)\n-        xmlSchemaXPathPop(vctxt);\n-    }\n-\n-    \/*\n-    * Report errors.\n-    *\/\n-    for (i = 0; i < vctxt->nbAttrInfos; i++) {\n-    iattr = vctxt->attrInfos[i];\n-    if ((iattr->state == XML_SCHEMAS_ATTR_META) ||\n-        (iattr->state == XML_SCHEMAS_ATTR_ASSESSED) ||\n-        (iattr->state == XML_SCHEMAS_ATTR_WILD_SKIP) ||\n-        (iattr->state == XML_SCHEMAS_ATTR_WILD_LAX_NO_DECL))\n-        continue;\n-    ACTIVATE_ATTRIBUTE(iattr);\n-    switch (iattr->state) {\n-        case XML_SCHEMAS_ATTR_ERR_MISSING: {\n-            xmlChar *str = NULL;\n-            ACTIVATE_ELEM;\n-            xmlSchemaCustomErr(ACTXT_CAST vctxt,\n-            XML_SCHEMAV_CVC_COMPLEX_TYPE_4, NULL, NULL,\n-            \"The attribute '%s' is required but missing\",\n-            xmlSchemaFormatQName(&str,\n-                iattr->decl->targetNamespace,\n-                iattr->decl->name),\n-            NULL);\n-            FREE_AND_NULL(str)\n-            break;\n-        }\n-        case XML_SCHEMAS_ATTR_ERR_NO_TYPE:\n-        VERROR(XML_SCHEMAV_CVC_ATTRIBUTE_2, NULL,\n-            \"The type definition is absent\");\n-        break;\n-        case XML_SCHEMAS_ATTR_ERR_FIXED_VALUE:\n-        xmlSchemaCustomErr(ACTXT_CAST vctxt,\n-            XML_SCHEMAV_CVC_AU, NULL, NULL,\n-            \"The value '%s' does not match the fixed \"\n-            \"value constraint '%s'\",\n-            iattr->value, iattr->vcValue);\n-        break;\n-        case XML_SCHEMAS_ATTR_ERR_WILD_STRICT_NO_DECL:\n-        VERROR(XML_SCHEMAV_CVC_WILDCARD, NULL,\n-            \"No matching global attribute declaration available, but \"\n-            \"demanded by the strict wildcard\");\n-        break;\n-        case XML_SCHEMAS_ATTR_UNKNOWN:\n-        if (iattr->metaType)\n-            break;\n-        \/*\n-        * MAYBE VAL TODO: One might report different error messages\n-        * for the following errors.\n-        *\/\n-        if (type->attributeWildcard == NULL) {\n-            xmlSchemaIllegalAttrErr(ACTXT_CAST vctxt,\n-            XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1, iattr, NULL);\n-        } else {\n-            xmlSchemaIllegalAttrErr(ACTXT_CAST vctxt,\n-            XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2, iattr, NULL);\n-        }\n-        break;\n-        default:\n-        break;\n-    }\n-    }\n-\n-    ACTIVATE_ELEM;\n-    return (0);\n-internal_error:\n-    ACTIVATE_ELEM;\n-    return (-1);\n-}\n-\n-static int\n-xmlSchemaValidateElemWildcard(xmlSchemaValidCtxtPtr vctxt,\n-                  int *skip)\n-{\n-    xmlSchemaWildcardPtr wild = (xmlSchemaWildcardPtr) vctxt->inode->decl;\n-    \/*\n-    * The namespace of the element was already identified to be\n-    * matching the wildcard.\n-    *\/\n-    if ((skip == NULL) || (wild == NULL) ||\n-    (wild->type != XML_SCHEMA_TYPE_ANY)) {\n-    VERROR_INT(\"xmlSchemaValidateElemWildcard\",\n-        \"bad arguments\");\n-    return (-1);\n-    }\n-    *skip = 0;\n-    if (wild->processContents == XML_SCHEMAS_ANY_SKIP) {\n-    \/*\n-    * URGENT VAL TODO: Either we need to position the stream to the\n-    * next sibling, or walk the whole subtree.\n-    *\/\n-    *skip = 1;\n-    return (0);\n-    }\n-    {\n-    xmlSchemaElementPtr decl = NULL;\n-\n-    decl = xmlSchemaGetElem(vctxt->schema,\n-        vctxt->inode->localName, vctxt->inode->nsName);\n-    if (decl != NULL) {\n-        vctxt->inode->decl = decl;\n-        return (0);\n-    }\n-    }\n-    if (wild->processContents == XML_SCHEMAS_ANY_STRICT) {\n-    \/* VAL TODO: Change to proper error code. *\/\n-    VERROR(XML_SCHEMAV_CVC_ELT_1, NULL, \/* WXS_BASIC_CAST wild *\/\n-        \"No matching global element declaration available, but \"\n-        \"demanded by the strict wildcard\");\n-    return (vctxt->err);\n-    }\n-    if (vctxt->nbAttrInfos != 0) {\n-    xmlSchemaAttrInfoPtr iattr;\n-    \/*\n-    * SPEC Validation Rule: Schema-Validity Assessment (Element)\n-    * (1.2.1.2.1) - (1.2.1.2.3 )\n-    *\n-    * Use the xsi:type attribute for the type definition.\n-    *\/\n-    iattr = xmlSchemaGetMetaAttrInfo(vctxt,\n-        XML_SCHEMA_ATTR_INFO_META_XSI_TYPE);\n-    if (iattr != NULL) {\n-        if (xmlSchemaProcessXSIType(vctxt, iattr,\n-        &(vctxt->inode->typeDef), NULL) == -1) {\n-        VERROR_INT(\"xmlSchemaValidateElemWildcard\",\n-            \"calling xmlSchemaProcessXSIType() to \"\n-            \"process the attribute 'xsi:nil'\");\n-        return (-1);\n-        }\n-        \/*\n-        * Don't return an error on purpose.\n-        *\/\n-        return (0);\n-    }\n-    }\n-    \/*\n-    * SPEC Validation Rule: Schema-Validity Assessment (Element)\n-    *\n-    * Fallback to \"anyType\".\n-    *\/\n-    vctxt->inode->typeDef =\n-    xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);\n-    return (0);\n-}\n-\n-\/*\n-* xmlSchemaCheckCOSValidDefault:\n-*\n-* This will be called if: not nilled, no content and a default\/fixed\n-* value is provided.\n-*\/\n-\n-static int\n-xmlSchemaCheckCOSValidDefault(xmlSchemaValidCtxtPtr vctxt,\n-                  const xmlChar *value,\n-                  xmlSchemaValPtr *val)\n-{\n-    int ret = 0;\n-    xmlSchemaNodeInfoPtr inode = vctxt->inode;\n-\n-    \/*\n-    * cos-valid-default:\n-    * Schema Component Constraint: Element Default Valid (Immediate)\n-    * For a string to be a valid default with respect to a type\n-    * definition the appropriate case among the following must be true:\n-    *\/\n-    if WXS_IS_COMPLEX(inode->typeDef) {\n-    \/*\n-    * Complex type.\n-    *\n-    * SPEC (2.1) \"its {content type} must be a simple type definition\n-    * or mixed.\"\n-    * SPEC (2.2.2) \"If the {content type} is mixed, then the {content\n-    * type}'s particle must be `emptiable` as defined by\n-    * Particle Emptiable ($3.9.6).\"\n-    *\/\n-    if ((! WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) &&\n-        ((! WXS_HAS_MIXED_CONTENT(inode->typeDef)) ||\n-         (! WXS_EMPTIABLE(inode->typeDef)))) {\n-        ret = XML_SCHEMAP_COS_VALID_DEFAULT_2_1;\n-        \/* NOTE that this covers (2.2.2) as well. *\/\n-        VERROR(ret, NULL,\n-        \"For a string to be a valid default, the type definition \"\n-        \"must be a simple type or a complex type with simple content \"\n-        \"or mixed content and a particle emptiable\");\n-        return(ret);\n-    }\n-    }\n-    \/*\n-    * 1 If the type definition is a simple type definition, then the string\n-    * must be `valid` with respect to that definition as defined by String\n-    * Valid ($3.14.4).\n-    *\n-    * AND\n-    *\n-    * 2.2.1 If the {content type} is a simple type definition, then the\n-    * string must be `valid` with respect to that simple type definition\n-    * as defined by String Valid ($3.14.4).\n-    *\/\n-    if (WXS_IS_SIMPLE(inode->typeDef)) {\n-\n-    ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST vctxt,\n-        NULL, inode->typeDef, value, val, 1, 1, 0);\n-\n-    } else if (WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) {\n-\n-    ret = xmlSchemaVCheckCVCSimpleType(ACTXT_CAST vctxt,\n-        NULL, inode->typeDef->contentTypeDef, value, val, 1, 1, 0);\n-    }\n-    if (ret < 0) {\n-    VERROR_INT(\"xmlSchemaCheckCOSValidDefault\",\n-        \"calling xmlSchemaVCheckCVCSimpleType()\");\n-    }\n-    return (ret);\n-}\n-\n-static void\n-xmlSchemaVContentModelCallback(xmlRegExecCtxtPtr exec ATTRIBUTE_UNUSED,\n-                   const xmlChar * name ATTRIBUTE_UNUSED,\n-                   void *transdata, void *inputdata)\n-{\n-    xmlSchemaElementPtr item = (xmlSchemaElementPtr) transdata;\n-    xmlSchemaNodeInfoPtr inode = (xmlSchemaNodeInfoPtr) inputdata;\n-    inode->decl = item;\n-}\n-\n-static int\n-xmlSchemaValidatorPushElem(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    vctxt->inode = xmlSchemaGetFreshElemInfo(vctxt);\n-    if (vctxt->inode == NULL) {\n-    VERROR_INT(\"xmlSchemaValidatorPushElem\",\n-        \"calling xmlSchemaGetFreshElemInfo()\");\n-    return (-1);\n-    }\n-    vctxt->nbAttrInfos = 0;\n-    return (0);\n-}\n-\n-static int\n-xmlSchemaVCheckINodeDataType(xmlSchemaValidCtxtPtr vctxt,\n-                 xmlSchemaNodeInfoPtr inode,\n-                 xmlSchemaTypePtr type,\n-                 const xmlChar *value)\n-{\n-    if (inode->flags & XML_SCHEMA_NODE_INFO_VALUE_NEEDED)\n-    return (xmlSchemaVCheckCVCSimpleType(\n-        ACTXT_CAST vctxt, NULL,\n-        type, value, &(inode->val), 1, 1, 0));\n-    else\n-    return (xmlSchemaVCheckCVCSimpleType(\n-        ACTXT_CAST vctxt, NULL,\n-        type, value, NULL, 1, 0, 0));\n-}\n-\n-\n-\n-\/*\n-* Process END of element.\n-*\/\n-static int\n-xmlSchemaValidatorPopElem(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    int ret = 0;\n-    xmlSchemaNodeInfoPtr inode = vctxt->inode;\n-\n-    if (vctxt->nbAttrInfos != 0)\n-    xmlSchemaClearAttrInfos(vctxt);\n-    if (inode->flags & XML_SCHEMA_NODE_INFO_ERR_NOT_EXPECTED) {\n-    \/*\n-    * This element was not expected;\n-    * we will not validate child elements of broken parents.\n-    * Skip validation of all content of the parent.\n-    *\/\n-    vctxt->skipDepth = vctxt->depth -1;\n-    goto end_elem;\n-    }\n-    if ((inode->typeDef == NULL) ||\n-    (inode->flags & XML_SCHEMA_NODE_INFO_ERR_BAD_TYPE)) {\n-    \/*\n-    * 1. the type definition might be missing if the element was\n-    *    error prone\n-    * 2. it might be abstract.\n-    *\/\n-    goto end_elem;\n-    }\n-    \/*\n-    * Check the content model.\n-    *\/\n-    if ((inode->typeDef->contentType == XML_SCHEMA_CONTENT_MIXED) ||\n-    (inode->typeDef->contentType == XML_SCHEMA_CONTENT_ELEMENTS)) {\n-\n-    \/*\n-    * Workaround for \"anyType\".\n-    *\/\n-    if (inode->typeDef->builtInType == XML_SCHEMAS_ANYTYPE)\n-        goto character_content;\n-\n-    if ((inode->flags & XML_SCHEMA_ELEM_INFO_ERR_BAD_CONTENT) == 0) {\n-        xmlChar *values[10];\n-        int terminal, nbval = 10, nbneg;\n-\n-        if (inode->regexCtxt == NULL) {\n-        \/*\n-        * Create the regex context.\n-        *\/\n-        inode->regexCtxt =\n-            xmlRegNewExecCtxt(inode->typeDef->contModel,\n-            xmlSchemaVContentModelCallback, vctxt);\n-        if (inode->regexCtxt == NULL) {\n-            VERROR_INT(\"xmlSchemaValidatorPopElem\",\n-            \"failed to create a regex context\");\n-            goto internal_error;\n-        }\n-        }\n-\n-        \/*\n-         * Do not check further content if the node has been nilled\n-         *\/\n-        if (INODE_NILLED(inode)) {\n-        ret = 0;\n-                goto skip_nilled;\n-        }\n-\n-        \/*\n-        * Get hold of the still expected content, since a further\n-        * call to xmlRegExecPushString() will lose this information.\n-        *\/\n-        xmlRegExecNextValues(inode->regexCtxt,\n-        &nbval, &nbneg, &values[0], &terminal);\n-        ret = xmlRegExecPushString(inode->regexCtxt, NULL, NULL);\n-        if ((ret<0) || ((ret==0) && (!INODE_NILLED(inode)))) {\n-        \/*\n-        * Still missing something.\n-        *\/\n-        ret = 1;\n-        inode->flags |=\n-            XML_SCHEMA_ELEM_INFO_ERR_BAD_CONTENT;\n-        xmlSchemaComplexTypeErr(ACTXT_CAST vctxt,\n-            XML_SCHEMAV_ELEMENT_CONTENT, NULL, NULL,\n-            \"Missing child element(s)\",\n-            nbval, nbneg, values);\n-        } else {\n-        \/*\n-        * Content model is satisfied.\n-        *\/\n-        ret = 0;\n-        }\n-\n-    }\n-    }\n-\n-skip_nilled:\n-\n-    if (inode->typeDef->contentType == XML_SCHEMA_CONTENT_ELEMENTS)\n-    goto end_elem;\n-\n-character_content:\n-\n-    if (vctxt->value != NULL) {\n-    xmlSchemaFreeValue(vctxt->value);\n-    vctxt->value = NULL;\n-    }\n-    \/*\n-    * Check character content.\n-    *\/\n-    if (inode->decl == NULL) {\n-    \/*\n-    * Speedup if no declaration exists.\n-    *\/\n-    if (WXS_IS_SIMPLE(inode->typeDef)) {\n-        ret = xmlSchemaVCheckINodeDataType(vctxt,\n-        inode, inode->typeDef, inode->value);\n-    } else if (WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) {\n-        ret = xmlSchemaVCheckINodeDataType(vctxt,\n-        inode, inode->typeDef->contentTypeDef,\n-        inode->value);\n-    }\n-    if (ret < 0) {\n-        VERROR_INT(\"xmlSchemaValidatorPopElem\",\n-        \"calling xmlSchemaVCheckCVCSimpleType()\");\n-        goto internal_error;\n-    }\n-    goto end_elem;\n-    }\n-    \/*\n-    * cvc-elt (3.3.4) : 5\n-    * The appropriate case among the following must be true:\n-    *\/\n-    \/*\n-    * cvc-elt (3.3.4) : 5.1\n-    * If the declaration has a {value constraint},\n-    * the item has neither element nor character [children] and\n-    * clause 3.2 has not applied, then all of the following must be true:\n-    *\/\n-    if ((inode->decl->value != NULL) &&\n-    (inode->flags & XML_SCHEMA_ELEM_INFO_EMPTY) &&\n-    (! INODE_NILLED(inode))) {\n-    \/*\n-    * cvc-elt (3.3.4) : 5.1.1\n-    * If the `actual type definition` is a `local type definition`\n-    * then the canonical lexical representation of the {value constraint}\n-    * value must be a valid default for the `actual type definition` as\n-    * defined in Element Default Valid (Immediate) ($3.3.6).\n-    *\/\n-    \/*\n-    * NOTE: 'local' above means types acquired by xsi:type.\n-    * NOTE: Although the *canonical* value is stated, it is not\n-    * relevant if canonical or not. Additionally XML Schema 1.1\n-    * will removed this requirement as well.\n-    *\/\n-    if (inode->flags & XML_SCHEMA_ELEM_INFO_LOCAL_TYPE) {\n-\n-        ret = xmlSchemaCheckCOSValidDefault(vctxt,\n-        inode->decl->value, &(inode->val));\n-        if (ret != 0) {\n-        if (ret < 0) {\n-            VERROR_INT(\"xmlSchemaValidatorPopElem\",\n-            \"calling xmlSchemaCheckCOSValidDefault()\");\n-            goto internal_error;\n-        }\n-        goto end_elem;\n-        }\n-        \/*\n-        * Stop here, to avoid redundant validation of the value\n-        * (see following).\n-        *\/\n-        goto default_psvi;\n-    }\n-    \/*\n-    * cvc-elt (3.3.4) : 5.1.2\n-    * The element information item with the canonical lexical\n-    * representation of the {value constraint} value used as its\n-    * `normalized value` must be `valid` with respect to the\n-    * `actual type definition` as defined by Element Locally Valid (Type)\n-    * ($3.3.4).\n-    *\/\n-    if (WXS_IS_SIMPLE(inode->typeDef)) {\n-        ret = xmlSchemaVCheckINodeDataType(vctxt,\n-        inode, inode->typeDef, inode->decl->value);\n-    } else if (WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) {\n-        ret = xmlSchemaVCheckINodeDataType(vctxt,\n-        inode, inode->typeDef->contentTypeDef,\n-        inode->decl->value);\n-    }\n-    if (ret != 0) {\n-        if (ret < 0) {\n-        VERROR_INT(\"xmlSchemaValidatorPopElem\",\n-            \"calling xmlSchemaVCheckCVCSimpleType()\");\n-        goto internal_error;\n-        }\n-        goto end_elem;\n-    }\n-\n-default_psvi:\n-    \/*\n-    * PSVI: Create a text node on the instance element.\n-    *\/\n-    if ((vctxt->options & XML_SCHEMA_VAL_VC_I_CREATE) &&\n-        (inode->node != NULL)) {\n-        xmlNodePtr textChild;\n-        xmlChar *normValue;\n-        \/*\n-        * VAL TODO: Normalize the value.\n-        *\/\n-        normValue = xmlSchemaNormalizeValue(inode->typeDef,\n-        inode->decl->value);\n-        if (normValue != NULL) {\n-        textChild = xmlNewDocText(inode->node->doc,\n-                        BAD_CAST normValue);\n-        xmlFree(normValue);\n-        } else\n-        textChild = xmlNewDocText(inode->node->doc,\n-                        inode->decl->value);\n-        if (textChild == NULL) {\n-        VERROR_INT(\"xmlSchemaValidatorPopElem\",\n-            \"calling xmlNewDocText()\");\n-        goto internal_error;\n-        } else\n-        xmlAddChild(inode->node, textChild);\n-    }\n-\n-    } else if (! INODE_NILLED(inode)) {\n-    \/*\n-    * 5.2.1 The element information item must be `valid` with respect\n-    * to the `actual type definition` as defined by Element Locally\n-    * Valid (Type) ($3.3.4).\n-    *\/\n-    if (WXS_IS_SIMPLE(inode->typeDef)) {\n-         \/*\n-        * SPEC (cvc-type) (3.1)\n-        * \"If the type definition is a simple type definition, ...\"\n-        * (3.1.3) \"If clause 3.2 of Element Locally Valid\n-        * (Element) ($3.3.4) did not apply, then the `normalized value`\n-        * must be `valid` with respect to the type definition as defined\n-        * by String Valid ($3.14.4).\n-        *\/\n-        ret = xmlSchemaVCheckINodeDataType(vctxt,\n-            inode, inode->typeDef, inode->value);\n-    } else if (WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) {\n-        \/*\n-        * SPEC (cvc-type) (3.2) \"If the type definition is a complex type\n-        * definition, then the element information item must be\n-        * `valid` with respect to the type definition as per\n-        * Element Locally Valid (Complex Type) ($3.4.4);\"\n-        *\n-        * SPEC (cvc-complex-type) (2.2)\n-        * \"If the {content type} is a simple type definition, ...\n-        * the `normalized value` of the element information item is\n-        * `valid` with respect to that simple type definition as\n-        * defined by String Valid ($3.14.4).\"\n-        *\/\n-        ret = xmlSchemaVCheckINodeDataType(vctxt,\n-        inode, inode->typeDef->contentTypeDef, inode->value);\n-    }\n-    if (ret != 0) {\n-        if (ret < 0) {\n-        VERROR_INT(\"xmlSchemaValidatorPopElem\",\n-            \"calling xmlSchemaVCheckCVCSimpleType()\");\n-        goto internal_error;\n-        }\n-        goto end_elem;\n-    }\n-    \/*\n-    * 5.2.2 If there is a fixed {value constraint} and clause 3.2 has\n-    * not applied, all of the following must be true:\n-    *\/\n-    if ((inode->decl->value != NULL) &&\n-        (inode->decl->flags & XML_SCHEMAS_ELEM_FIXED)) {\n-\n-        \/*\n-        * TODO: We will need a computed value, when comparison is\n-        * done on computed values.\n-        *\/\n-        \/*\n-        * 5.2.2.1 The element information item must have no element\n-        * information item [children].\n-        *\/\n-        if (inode->flags &\n-            XML_SCHEMA_ELEM_INFO_HAS_ELEM_CONTENT) {\n-        ret = XML_SCHEMAV_CVC_ELT_5_2_2_1;\n-        VERROR(ret, NULL,\n-            \"The content must not contain element nodes since \"\n-            \"there is a fixed value constraint\");\n-        goto end_elem;\n-        } else {\n-        \/*\n-        * 5.2.2.2 The appropriate case among the following must\n-        * be true:\n-        *\/\n-        if (WXS_HAS_MIXED_CONTENT(inode->typeDef)) {\n-            \/*\n-            * 5.2.2.2.1 If the {content type} of the `actual type\n-            * definition` is mixed, then the *initial value* of the\n-            * item must match the canonical lexical representation\n-            * of the {value constraint} value.\n-            *\n-            * ... the *initial value* of an element information\n-            * item is the string composed of, in order, the\n-            * [character code] of each character information item in\n-            * the [children] of that element information item.\n-            *\/\n-            if (! xmlStrEqual(inode->value, inode->decl->value)){\n-            \/*\n-            * VAL TODO: Report invalid & expected values as well.\n-            * VAL TODO: Implement the canonical stuff.\n-            *\/\n-            ret = XML_SCHEMAV_CVC_ELT_5_2_2_2_1;\n-            xmlSchemaCustomErr(ACTXT_CAST vctxt,\n-                ret, NULL, NULL,\n-                \"The initial value '%s' does not match the fixed \"\n-                \"value constraint '%s'\",\n-                inode->value, inode->decl->value);\n-            goto end_elem;\n-            }\n-        } else if (WXS_HAS_SIMPLE_CONTENT(inode->typeDef)) {\n-            \/*\n-            * 5.2.2.2.2 If the {content type} of the `actual type\n-            * definition` is a simple type definition, then the\n-            * *actual value* of the item must match the canonical\n-            * lexical representation of the {value constraint} value.\n-            *\/\n-            \/*\n-            * VAL TODO: *actual value* is the normalized value, impl.\n-            *           this.\n-            * VAL TODO: Report invalid & expected values as well.\n-            * VAL TODO: Implement a comparison with the computed values.\n-            *\/\n-            if (! xmlStrEqual(inode->value,\n-                inode->decl->value)) {\n-            ret = XML_SCHEMAV_CVC_ELT_5_2_2_2_2;\n-            xmlSchemaCustomErr(ACTXT_CAST vctxt,\n-                ret, NULL, NULL,\n-                \"The actual value '%s' does not match the fixed \"\n-                \"value constraint '%s'\",\n-                inode->value,\n-                inode->decl->value);\n-            goto end_elem;\n-            }\n-        }\n-        }\n-    }\n-    }\n-\n-end_elem:\n-    if (vctxt->depth < 0) {\n-    \/* TODO: raise error? *\/\n-    return (0);\n-    }\n-    if (vctxt->depth == vctxt->skipDepth)\n-    vctxt->skipDepth = -1;\n-    \/*\n-    * Evaluate the history of XPath state objects.\n-    *\/\n-    if (inode->appliedXPath &&\n-    (xmlSchemaXPathProcessHistory(vctxt, vctxt->depth) == -1))\n-    goto internal_error;\n-    \/*\n-    * MAYBE TODO:\n-    * SPEC (6) \"The element information item must be `valid` with\n-    * respect to each of the {identity-constraint definitions} as per\n-    * Identity-constraint Satisfied ($3.11.4).\"\n-    *\/\n-    \/*\n-    * PSVI TODO: If we expose IDC node-tables via PSVI then the tables\n-    *   need to be built in any case.\n-    *   We will currently build IDC node-tables and bubble them only if\n-    *   keyrefs do exist.\n-    *\/\n-\n-    \/*\n-    * Add the current IDC target-nodes to the IDC node-tables.\n-    *\/\n-    if ((inode->idcMatchers != NULL) &&\n-    (vctxt->hasKeyrefs || vctxt->createIDCNodeTables))\n-    {\n-    if (xmlSchemaIDCFillNodeTables(vctxt, inode) == -1)\n-        goto internal_error;\n-    }\n-    \/*\n-    * Validate IDC keyrefs.\n-    *\/\n-    if (vctxt->inode->hasKeyrefs)\n-    if (xmlSchemaCheckCVCIDCKeyRef(vctxt) == -1)\n-        goto internal_error;\n-    \/*\n-    * Merge\/free the IDC table.\n-    *\/\n-    if (inode->idcTable != NULL) {\n-    if ((vctxt->depth > 0) &&\n-        (vctxt->hasKeyrefs || vctxt->createIDCNodeTables))\n-    {\n-        \/*\n-        * Merge the IDC node table with the table of the parent node.\n-        *\/\n-        if (xmlSchemaBubbleIDCNodeTables(vctxt) == -1)\n-        goto internal_error;\n-    }\n-    }\n-    \/*\n-    * Clear the current ielem.\n-    * VAL TODO: Don't free the PSVI IDC tables if they are\n-    * requested for the PSVI.\n-    *\/\n-    xmlSchemaClearElemInfo(vctxt, inode);\n-    \/*\n-    * Skip further processing if we are on the validation root.\n-    *\/\n-    if (vctxt->depth == 0) {\n-    vctxt->depth--;\n-    vctxt->inode = NULL;\n-    return (0);\n-    }\n-    \/*\n-    * Reset the keyrefDepth if needed.\n-    *\/\n-    if (vctxt->aidcs != NULL) {\n-    xmlSchemaIDCAugPtr aidc = vctxt->aidcs;\n-    do {\n-        if (aidc->keyrefDepth == vctxt->depth) {\n-        \/*\n-        * A 'keyrefDepth' of a key\/unique IDC matches the current\n-        * depth, this means that we are leaving the scope of the\n-        * top-most keyref IDC which refers to this IDC.\n-        *\/\n-        aidc->keyrefDepth = -1;\n-        }\n-        aidc = aidc->next;\n-    } while (aidc != NULL);\n-    }\n-    vctxt->depth--;\n-    vctxt->inode = vctxt->elemInfos[vctxt->depth];\n-    \/*\n-    * VAL TODO: 7 If the element information item is the `validation root`, it must be\n-    * `valid` per Validation Root Valid (ID\/IDREF) ($3.3.4).\n-    *\/\n-    return (ret);\n-\n-internal_error:\n-    vctxt->err = -1;\n-    return (-1);\n-}\n-\n-\/*\n-* 3.4.4 Complex Type Definition Validation Rules\n-* Validation Rule: Element Locally Valid (Complex Type) (cvc-complex-type)\n-*\/\n-static int\n-xmlSchemaValidateChildElem(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    xmlSchemaNodeInfoPtr pielem;\n-    xmlSchemaTypePtr ptype;\n-    int ret = 0;\n-\n-    if (vctxt->depth <= 0) {\n-    VERROR_INT(\"xmlSchemaValidateChildElem\",\n-        \"not intended for the validation root\");\n-    return (-1);\n-    }\n-    pielem = vctxt->elemInfos[vctxt->depth -1];\n-    if (pielem->flags & XML_SCHEMA_ELEM_INFO_EMPTY)\n-    pielem->flags ^= XML_SCHEMA_ELEM_INFO_EMPTY;\n-    \/*\n-    * Handle 'nilled' elements.\n-    *\/\n-    if (INODE_NILLED(pielem)) {\n-    \/*\n-    * SPEC (cvc-elt) (3.3.4) : (3.2.1)\n-    *\/\n-    ACTIVATE_PARENT_ELEM;\n-    ret = XML_SCHEMAV_CVC_ELT_3_2_1;\n-    VERROR(ret, NULL,\n-        \"Neither character nor element content is allowed, \"\n-        \"because the element was 'nilled'\");\n-    ACTIVATE_ELEM;\n-    goto unexpected_elem;\n-    }\n-\n-    ptype = pielem->typeDef;\n-\n-    if (ptype->builtInType == XML_SCHEMAS_ANYTYPE) {\n-    \/*\n-    * Workaround for \"anyType\": we have currently no content model\n-    * assigned for \"anyType\", so handle it explicitly.\n-    * \"anyType\" has an unbounded, lax \"any\" wildcard.\n-    *\/\n-    vctxt->inode->decl = xmlSchemaGetElem(vctxt->schema,\n-        vctxt->inode->localName,\n-        vctxt->inode->nsName);\n-\n-    if (vctxt->inode->decl == NULL) {\n-        xmlSchemaAttrInfoPtr iattr;\n-        \/*\n-        * Process \"xsi:type\".\n-        * SPEC (cvc-assess-elt) (1.2.1.2.1) - (1.2.1.2.3)\n-        *\/\n-        iattr = xmlSchemaGetMetaAttrInfo(vctxt,\n-        XML_SCHEMA_ATTR_INFO_META_XSI_TYPE);\n-        if (iattr != NULL) {\n-        ret = xmlSchemaProcessXSIType(vctxt, iattr,\n-            &(vctxt->inode->typeDef), NULL);\n-        if (ret != 0) {\n-            if (ret == -1) {\n-            VERROR_INT(\"xmlSchemaValidateChildElem\",\n-                \"calling xmlSchemaProcessXSIType() to \"\n-                \"process the attribute 'xsi:nil'\");\n-            return (-1);\n-            }\n-            return (ret);\n-        }\n-        } else {\n-         \/*\n-         * Fallback to \"anyType\".\n-         *\n-         * SPEC (cvc-assess-elt)\n-         * \"If the item cannot be `strictly assessed`, [...]\n-         * an element information item's schema validity may be laxly\n-         * assessed if its `context-determined declaration` is not\n-         * skip by `validating` with respect to the `ur-type\n-         * definition` as per Element Locally Valid (Type) ($3.3.4).\"\n-        *\/\n-        vctxt->inode->typeDef =\n-            xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);\n-        }\n-    }\n-    return (0);\n-    }\n-\n-    switch (ptype->contentType) {\n-    case XML_SCHEMA_CONTENT_EMPTY:\n-        \/*\n-        * SPEC (2.1) \"If the {content type} is empty, then the\n-        * element information item has no character or element\n-        * information item [children].\"\n-        *\/\n-        ACTIVATE_PARENT_ELEM\n-        ret = XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1;\n-        VERROR(ret, NULL,\n-        \"Element content is not allowed, \"\n-        \"because the content type is empty\");\n-        ACTIVATE_ELEM\n-        goto unexpected_elem;\n-        break;\n-\n-    case XML_SCHEMA_CONTENT_MIXED:\n-        case XML_SCHEMA_CONTENT_ELEMENTS: {\n-        xmlRegExecCtxtPtr regexCtxt;\n-        xmlChar *values[10];\n-        int terminal, nbval = 10, nbneg;\n-\n-        \/* VAL TODO: Optimized \"anyType\" validation.*\/\n-\n-        if (ptype->contModel == NULL) {\n-        VERROR_INT(\"xmlSchemaValidateChildElem\",\n-            \"type has elem content but no content model\");\n-        return (-1);\n-        }\n-        \/*\n-        * Safety belt for evaluation if the cont. model was already\n-        * examined to be invalid.\n-        *\/\n-        if (pielem->flags & XML_SCHEMA_ELEM_INFO_ERR_BAD_CONTENT) {\n-        VERROR_INT(\"xmlSchemaValidateChildElem\",\n-            \"validating elem, but elem content is already invalid\");\n-        return (-1);\n-        }\n-\n-        regexCtxt = pielem->regexCtxt;\n-        if (regexCtxt == NULL) {\n-        \/*\n-        * Create the regex context.\n-        *\/\n-        regexCtxt = xmlRegNewExecCtxt(ptype->contModel,\n-            xmlSchemaVContentModelCallback, vctxt);\n-        if (regexCtxt == NULL) {\n-            VERROR_INT(\"xmlSchemaValidateChildElem\",\n-            \"failed to create a regex context\");\n-            return (-1);\n-        }\n-        pielem->regexCtxt = regexCtxt;\n-        }\n-\n-        \/*\n-        * SPEC (2.4) \"If the {content type} is element-only or mixed,\n-        * then the sequence of the element information item's\n-        * element information item [children], if any, taken in\n-        * order, is `valid` with respect to the {content type}'s\n-        * particle, as defined in Element Sequence Locally Valid\n-        * (Particle) ($3.9.4).\"\n-        *\/\n-        ret = xmlRegExecPushString2(regexCtxt,\n-        vctxt->inode->localName,\n-        vctxt->inode->nsName,\n-        vctxt->inode);\n-        if (vctxt->err == XML_SCHEMAV_INTERNAL) {\n-        VERROR_INT(\"xmlSchemaValidateChildElem\",\n-            \"calling xmlRegExecPushString2()\");\n-        return (-1);\n-        }\n-        if (ret < 0) {\n-        xmlRegExecErrInfo(regexCtxt, NULL, &nbval, &nbneg,\n-            &values[0], &terminal);\n-        xmlSchemaComplexTypeErr(ACTXT_CAST vctxt,\n-            XML_SCHEMAV_ELEMENT_CONTENT, NULL,NULL,\n-            \"This element is not expected\",\n-            nbval, nbneg, values);\n-        ret = vctxt->err;\n-        goto unexpected_elem;\n-        } else\n-        ret = 0;\n-    }\n-        break;\n-    case XML_SCHEMA_CONTENT_SIMPLE:\n-    case XML_SCHEMA_CONTENT_BASIC:\n-        ACTIVATE_PARENT_ELEM\n-        if (WXS_IS_COMPLEX(ptype)) {\n-        \/*\n-        * SPEC (cvc-complex-type) (2.2)\n-        * \"If the {content type} is a simple type definition, then\n-        * the element information item has no element information\n-        * item [children], ...\"\n-        *\/\n-        ret = XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2;\n-        VERROR(ret, NULL, \"Element content is not allowed, \"\n-            \"because the content type is a simple type definition\");\n-        } else {\n-        \/*\n-        * SPEC (cvc-type) (3.1.2) \"The element information item must\n-        * have no element information item [children].\"\n-        *\/\n-        ret = XML_SCHEMAV_CVC_TYPE_3_1_2;\n-        VERROR(ret, NULL, \"Element content is not allowed, \"\n-            \"because the type definition is simple\");\n-        }\n-        ACTIVATE_ELEM\n-        ret = vctxt->err;\n-        goto unexpected_elem;\n-        break;\n-\n-    default:\n-        break;\n-    }\n-    return (ret);\n-unexpected_elem:\n-    \/*\n-    * Pop this element and set the skipDepth to skip\n-    * all further content of the parent element.\n-    *\/\n-    vctxt->skipDepth = vctxt->depth;\n-    vctxt->inode->flags |= XML_SCHEMA_NODE_INFO_ERR_NOT_EXPECTED;\n-    pielem->flags |= XML_SCHEMA_ELEM_INFO_ERR_BAD_CONTENT;\n-    return (ret);\n-}\n-\n-#define XML_SCHEMA_PUSH_TEXT_PERSIST 1\n-#define XML_SCHEMA_PUSH_TEXT_CREATED 2\n-#define XML_SCHEMA_PUSH_TEXT_VOLATILE 3\n-\n-static int\n-xmlSchemaVPushText(xmlSchemaValidCtxtPtr vctxt,\n-          int nodeType, const xmlChar *value, int len,\n-          int mode, int *consumed)\n-{\n-    \/*\n-    * Unfortunately we have to duplicate the text sometimes.\n-    * OPTIMIZE: Maybe we could skip it, if:\n-    *   1. content type is simple\n-    *   2. whitespace is \"collapse\"\n-    *   3. it consists of whitespace only\n-    *\n-    * Process character content.\n-    *\/\n-    if (consumed != NULL)\n-    *consumed = 0;\n-    if (INODE_NILLED(vctxt->inode)) {\n-    \/*\n-    * SPEC cvc-elt (3.3.4 - 3.2.1)\n-    * \"The element information item must have no character or\n-    * element information item [children].\"\n-    *\/\n-    VERROR(XML_SCHEMAV_CVC_ELT_3_2_1, NULL,\n-        \"Neither character nor element content is allowed \"\n-        \"because the element is 'nilled'\");\n-    return (vctxt->err);\n-    }\n-    \/*\n-    * SPEC (2.1) \"If the {content type} is empty, then the\n-    * element information item has no character or element\n-    * information item [children].\"\n-    *\/\n-    if (vctxt->inode->typeDef->contentType ==\n-        XML_SCHEMA_CONTENT_EMPTY) {\n-    VERROR(XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1, NULL,\n-        \"Character content is not allowed, \"\n-        \"because the content type is empty\");\n-    return (vctxt->err);\n-    }\n-\n-    if (vctxt->inode->typeDef->contentType ==\n-        XML_SCHEMA_CONTENT_ELEMENTS) {\n-    if ((nodeType != XML_TEXT_NODE) ||\n-        (! xmlSchemaIsBlank((xmlChar *) value, len))) {\n-        \/*\n-        * SPEC cvc-complex-type (2.3)\n-        * \"If the {content type} is element-only, then the\n-        * element information item has no character information\n-        * item [children] other than those whose [character\n-        * code] is defined as a white space in [XML 1.0 (Second\n-        * Edition)].\"\n-        *\/\n-        VERROR(XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3, NULL,\n-        \"Character content other than whitespace is not allowed \"\n-        \"because the content type is 'element-only'\");\n-        return (vctxt->err);\n-    }\n-    return (0);\n-    }\n-\n-    if ((value == NULL) || (value[0] == 0))\n-    return (0);\n-    \/*\n-    * Save the value.\n-    * NOTE that even if the content type is *mixed*, we need the\n-    * *initial value* for default\/fixed value constraints.\n-    *\/\n-    if ((vctxt->inode->typeDef->contentType == XML_SCHEMA_CONTENT_MIXED) &&\n-    ((vctxt->inode->decl == NULL) ||\n-    (vctxt->inode->decl->value == NULL)))\n-    return (0);\n-\n-    if (vctxt->inode->value == NULL) {\n-    \/*\n-    * Set the value.\n-    *\/\n-    switch (mode) {\n-        case XML_SCHEMA_PUSH_TEXT_PERSIST:\n-        \/*\n-        * When working on a tree.\n-        *\/\n-        vctxt->inode->value = value;\n-        break;\n-        case XML_SCHEMA_PUSH_TEXT_CREATED:\n-        \/*\n-        * When working with the reader.\n-        * The value will be freed by the element info.\n-        *\/\n-        vctxt->inode->value = value;\n-        if (consumed != NULL)\n-            *consumed = 1;\n-        vctxt->inode->flags |=\n-            XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES;\n-        break;\n-        case XML_SCHEMA_PUSH_TEXT_VOLATILE:\n-        \/*\n-        * When working with SAX.\n-        * The value will be freed by the element info.\n-        *\/\n-        if (len != -1)\n-            vctxt->inode->value = BAD_CAST xmlStrndup(value, len);\n-        else\n-            vctxt->inode->value = BAD_CAST xmlStrdup(value);\n-        vctxt->inode->flags |=\n-            XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES;\n-        break;\n-        default:\n-        break;\n-    }\n-    } else {\n-    if (len < 0)\n-        len = xmlStrlen(value);\n-    \/*\n-    * Concat the value.\n-    *\/\n-    if (vctxt->inode->flags & XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES) {\n-        vctxt->inode->value = BAD_CAST xmlStrncat(\n-        (xmlChar *) vctxt->inode->value, value, len);\n-    } else {\n-        vctxt->inode->value =\n-        BAD_CAST xmlStrncatNew(vctxt->inode->value, value, len);\n-        vctxt->inode->flags |= XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES;\n-    }\n-    }\n-\n-    return (0);\n-}\n-\n-static int\n-xmlSchemaValidateElem(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    int ret = 0;\n-\n-    if ((vctxt->skipDepth != -1) &&\n-    (vctxt->depth >= vctxt->skipDepth)) {\n-    VERROR_INT(\"xmlSchemaValidateElem\",\n-        \"in skip-state\");\n-    goto internal_error;\n-    }\n-    if (vctxt->xsiAssemble) {\n-    \/*\n-    * We will stop validation if there was an error during\n-    * dynamic schema construction.\n-    * Note that we simply set @skipDepth to 0, this could\n-    * mean that a streaming document via SAX would be\n-    * still read to the end but it won't be validated any more.\n-    * TODO: If we are sure how to stop the validation at once\n-    *   for all input scenarios, then this should be changed to\n-    *   instantly stop the validation.\n-    *\/\n-    ret = xmlSchemaAssembleByXSI(vctxt);\n-    if (ret != 0) {\n-        if (ret == -1)\n-        goto internal_error;\n-        vctxt->skipDepth = 0;\n-        return(ret);\n-    }\n-        \/*\n-         * Augment the IDC definitions for the main schema and all imported ones\n-         * NOTE: main schema is the first in the imported list\n-         *\/\n-        xmlHashScan(vctxt->schema->schemasImports, xmlSchemaAugmentImportedIDC,\n-                    vctxt);\n-    }\n-    if (vctxt->depth > 0) {\n-    \/*\n-    * Validate this element against the content model\n-    * of the parent.\n-    *\/\n-    ret = xmlSchemaValidateChildElem(vctxt);\n-    if (ret != 0) {\n-        if (ret < 0) {\n-        VERROR_INT(\"xmlSchemaValidateElem\",\n-            \"calling xmlSchemaStreamValidateChildElement()\");\n-        goto internal_error;\n-        }\n-        goto exit;\n-    }\n-    if (vctxt->depth == vctxt->skipDepth)\n-        goto exit;\n-    if ((vctxt->inode->decl == NULL) &&\n-        (vctxt->inode->typeDef == NULL)) {\n-        VERROR_INT(\"xmlSchemaValidateElem\",\n-        \"the child element was valid but neither the \"\n-        \"declaration nor the type was set\");\n-        goto internal_error;\n-    }\n-    } else {\n-    \/*\n-    * Get the declaration of the validation root.\n-    *\/\n-    vctxt->inode->decl = xmlSchemaGetElem(vctxt->schema,\n-        vctxt->inode->localName,\n-        vctxt->inode->nsName);\n-    if (vctxt->inode->decl == NULL) {\n-        ret = XML_SCHEMAV_CVC_ELT_1;\n-        VERROR(ret, NULL,\n-        \"No matching global declaration available \"\n-        \"for the validation root\");\n-        goto exit;\n-    }\n-    }\n-\n-    if (vctxt->inode->decl == NULL)\n-    goto type_validation;\n-\n-    if (vctxt->inode->decl->type == XML_SCHEMA_TYPE_ANY) {\n-    int skip;\n-    \/*\n-    * Wildcards.\n-    *\/\n-    ret = xmlSchemaValidateElemWildcard(vctxt, &skip);\n-    if (ret != 0) {\n-        if (ret < 0) {\n-        VERROR_INT(\"xmlSchemaValidateElem\",\n-            \"calling xmlSchemaValidateElemWildcard()\");\n-        goto internal_error;\n-        }\n-        goto exit;\n-    }\n-    if (skip) {\n-        vctxt->skipDepth = vctxt->depth;\n-        goto exit;\n-    }\n-    \/*\n-    * The declaration might be set by the wildcard validation,\n-    * when the processContents is \"lax\" or \"strict\".\n-    *\/\n-    if (vctxt->inode->decl->type != XML_SCHEMA_TYPE_ELEMENT) {\n-        \/*\n-        * Clear the \"decl\" field to not confuse further processing.\n-        *\/\n-        vctxt->inode->decl = NULL;\n-        goto type_validation;\n-    }\n-    }\n-    \/*\n-    * Validate against the declaration.\n-    *\/\n-    ret = xmlSchemaValidateElemDecl(vctxt);\n-    if (ret != 0) {\n-    if (ret < 0) {\n-        VERROR_INT(\"xmlSchemaValidateElem\",\n-        \"calling xmlSchemaValidateElemDecl()\");\n-        goto internal_error;\n-    }\n-    goto exit;\n-    }\n-    \/*\n-    * Validate against the type definition.\n-    *\/\n-type_validation:\n-\n-    if (vctxt->inode->typeDef == NULL) {\n-    vctxt->inode->flags |= XML_SCHEMA_NODE_INFO_ERR_BAD_TYPE;\n-    ret = XML_SCHEMAV_CVC_TYPE_1;\n-    VERROR(ret, NULL,\n-        \"The type definition is absent\");\n-    goto exit;\n-    }\n-    if (vctxt->inode->typeDef->flags & XML_SCHEMAS_TYPE_ABSTRACT) {\n-    vctxt->inode->flags |= XML_SCHEMA_NODE_INFO_ERR_BAD_TYPE;\n-    ret = XML_SCHEMAV_CVC_TYPE_2;\n-        VERROR(ret, NULL,\n-        \"The type definition is abstract\");\n-    goto exit;\n-    }\n-    \/*\n-    * Evaluate IDCs. Do it here, since new IDC matchers are registered\n-    * during validation against the declaration. This must be done\n-    * _before_ attribute validation.\n-    *\/\n-    if (vctxt->xpathStates != NULL) {\n-    ret = xmlSchemaXPathEvaluate(vctxt, XML_ELEMENT_NODE);\n-    vctxt->inode->appliedXPath = 1;\n-    if (ret == -1) {\n-        VERROR_INT(\"xmlSchemaValidateElem\",\n-        \"calling xmlSchemaXPathEvaluate()\");\n-        goto internal_error;\n-    }\n-    }\n-    \/*\n-    * Validate attributes.\n-    *\/\n-    if (WXS_IS_COMPLEX(vctxt->inode->typeDef)) {\n-    if ((vctxt->nbAttrInfos != 0) ||\n-        (vctxt->inode->typeDef->attrUses != NULL)) {\n-\n-        ret = xmlSchemaVAttributesComplex(vctxt);\n-    }\n-    } else if (vctxt->nbAttrInfos != 0) {\n-\n-    ret = xmlSchemaVAttributesSimple(vctxt);\n-    }\n-    \/*\n-    * Clear registered attributes.\n-    *\/\n-    if (vctxt->nbAttrInfos != 0)\n-    xmlSchemaClearAttrInfos(vctxt);\n-    if (ret == -1) {\n-    VERROR_INT(\"xmlSchemaValidateElem\",\n-        \"calling attributes validation\");\n-    goto internal_error;\n-    }\n-    \/*\n-    * Don't return an error if attributes are invalid on purpose.\n-    *\/\n-    ret = 0;\n-\n-exit:\n-    if (ret != 0)\n-    vctxt->skipDepth = vctxt->depth;\n-    return (ret);\n-internal_error:\n-    return (-1);\n-}\n-\n-#ifdef XML_SCHEMA_READER_ENABLED\n-static int\n-xmlSchemaVReaderWalk(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    const int WHTSP = 13, SIGN_WHTSP = 14, END_ELEM = 15;\n-    int depth, nodeType, ret = 0, consumed;\n-    xmlSchemaNodeInfoPtr ielem;\n-\n-    vctxt->depth = -1;\n-    ret = xmlTextReaderRead(vctxt->reader);\n-    \/*\n-    * Move to the document element.\n-    *\/\n-    while (ret == 1) {\n-    nodeType = xmlTextReaderNodeType(vctxt->reader);\n-    if (nodeType == XML_ELEMENT_NODE)\n-        goto root_found;\n-    ret = xmlTextReaderRead(vctxt->reader);\n-    }\n-    goto exit;\n-\n-root_found:\n-\n-    do {\n-    depth = xmlTextReaderDepth(vctxt->reader);\n-    nodeType = xmlTextReaderNodeType(vctxt->reader);\n-\n-    if (nodeType == XML_ELEMENT_NODE) {\n-\n-        vctxt->depth++;\n-        if (xmlSchemaValidatorPushElem(vctxt) == -1) {\n-        VERROR_INT(\"xmlSchemaVReaderWalk\",\n-            \"calling xmlSchemaValidatorPushElem()\");\n-        goto internal_error;\n-        }\n-        ielem = vctxt->inode;\n-        ielem->localName = xmlTextReaderLocalName(vctxt->reader);\n-        ielem->nsName = xmlTextReaderNamespaceUri(vctxt->reader);\n-        ielem->flags |= XML_SCHEMA_NODE_INFO_FLAG_OWNED_NAMES;\n-        \/*\n-        * Is the element empty?\n-        *\/\n-        ret = xmlTextReaderIsEmptyElement(vctxt->reader);\n-        if (ret == -1) {\n-        VERROR_INT(\"xmlSchemaVReaderWalk\",\n-            \"calling xmlTextReaderIsEmptyElement()\");\n-        goto internal_error;\n-        }\n-        if (ret) {\n-        ielem->flags |= XML_SCHEMA_ELEM_INFO_EMPTY;\n-        }\n-        \/*\n-        * Register attributes.\n-        *\/\n-        vctxt->nbAttrInfos = 0;\n-        ret = xmlTextReaderMoveToFirstAttribute(vctxt->reader);\n-        if (ret == -1) {\n-        VERROR_INT(\"xmlSchemaVReaderWalk\",\n-            \"calling xmlTextReaderMoveToFirstAttribute()\");\n-        goto internal_error;\n-        }\n-        if (ret == 1) {\n-        do {\n-            \/*\n-            * VAL TODO: How do we know that the reader works on a\n-            * node tree, to be able to pass a node here?\n-            *\/\n-            if (xmlSchemaValidatorPushAttribute(vctxt, NULL,\n-            (const xmlChar *) xmlTextReaderLocalName(vctxt->reader),\n-            xmlTextReaderNamespaceUri(vctxt->reader), 1,\n-            xmlTextReaderValue(vctxt->reader), 1) == -1) {\n-\n-            VERROR_INT(\"xmlSchemaVReaderWalk\",\n-                \"calling xmlSchemaValidatorPushAttribute()\");\n-            goto internal_error;\n-            }\n-            ret = xmlTextReaderMoveToNextAttribute(vctxt->reader);\n-            if (ret == -1) {\n-            VERROR_INT(\"xmlSchemaVReaderWalk\",\n-                \"calling xmlTextReaderMoveToFirstAttribute()\");\n-            goto internal_error;\n-            }\n-        } while (ret == 1);\n-        \/*\n-        * Back to element position.\n-        *\/\n-        ret = xmlTextReaderMoveToElement(vctxt->reader);\n-        if (ret == -1) {\n-            VERROR_INT(\"xmlSchemaVReaderWalk\",\n-            \"calling xmlTextReaderMoveToElement()\");\n-            goto internal_error;\n-        }\n-        }\n-        \/*\n-        * Validate the element.\n-        *\/\n-        ret= xmlSchemaValidateElem(vctxt);\n-        if (ret != 0) {\n-        if (ret == -1) {\n-            VERROR_INT(\"xmlSchemaVReaderWalk\",\n-            \"calling xmlSchemaValidateElem()\");\n-            goto internal_error;\n-        }\n-        goto exit;\n-        }\n-        if (vctxt->depth == vctxt->skipDepth) {\n-        int curDepth;\n-        \/*\n-        * Skip all content.\n-        *\/\n-        if ((ielem->flags & XML_SCHEMA_ELEM_INFO_EMPTY) == 0) {\n-            ret = xmlTextReaderRead(vctxt->reader);\n-            curDepth = xmlTextReaderDepth(vctxt->reader);\n-            while ((ret == 1) && (curDepth != depth)) {\n-            ret = xmlTextReaderRead(vctxt->reader);\n-            curDepth = xmlTextReaderDepth(vctxt->reader);\n-            }\n-            if (ret < 0) {\n-            \/*\n-            * VAL TODO: A reader error occurred; what to do here?\n-            *\/\n-            ret = 1;\n-            goto exit;\n-            }\n-        }\n-        goto leave_elem;\n-        }\n-        \/*\n-        * READER VAL TODO: Is an END_ELEM really never called\n-        * if the elem is empty?\n-        *\/\n-        if (ielem->flags & XML_SCHEMA_ELEM_INFO_EMPTY)\n-        goto leave_elem;\n-    } else if (nodeType == END_ELEM) {\n-        \/*\n-        * Process END of element.\n-        *\/\n-leave_elem:\n-        ret = xmlSchemaValidatorPopElem(vctxt);\n-        if (ret != 0) {\n-        if (ret < 0) {\n-            VERROR_INT(\"xmlSchemaVReaderWalk\",\n-            \"calling xmlSchemaValidatorPopElem()\");\n-            goto internal_error;\n-        }\n-        goto exit;\n-        }\n-        if (vctxt->depth >= 0)\n-        ielem = vctxt->inode;\n-        else\n-        ielem = NULL;\n-    } else if ((nodeType == XML_TEXT_NODE) ||\n-        (nodeType == XML_CDATA_SECTION_NODE) ||\n-        (nodeType == WHTSP) ||\n-        (nodeType == SIGN_WHTSP)) {\n-        \/*\n-        * Process character content.\n-        *\/\n-        xmlChar *value;\n-\n-        if ((nodeType == WHTSP) || (nodeType == SIGN_WHTSP))\n-        nodeType = XML_TEXT_NODE;\n-\n-        value = xmlTextReaderValue(vctxt->reader);\n-        ret = xmlSchemaVPushText(vctxt, nodeType, BAD_CAST value,\n-        -1, XML_SCHEMA_PUSH_TEXT_CREATED, &consumed);\n-        if (! consumed)\n-        xmlFree(value);\n-        if (ret == -1) {\n-        VERROR_INT(\"xmlSchemaVReaderWalk\",\n-            \"calling xmlSchemaVPushText()\");\n-        goto internal_error;\n-        }\n-    } else if ((nodeType == XML_ENTITY_NODE) ||\n-        (nodeType == XML_ENTITY_REF_NODE)) {\n-        \/*\n-        * VAL TODO: What to do with entities?\n-        *\/\n-        TODO\n-    }\n-    \/*\n-    * Read next node.\n-    *\/\n-    ret = xmlTextReaderRead(vctxt->reader);\n-    } while (ret == 1);\n-\n-exit:\n-    return (ret);\n-internal_error:\n-    return (-1);\n-}\n-#endif\n-\n-\/************************************************************************\n- *                                    *\n- *            SAX validation handlers                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/*\n-* Process text content.\n-*\/\n-static void\n-xmlSchemaSAXHandleText(void *ctx,\n-               const xmlChar * ch,\n-               int len)\n-{\n-    xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) ctx;\n-\n-    if (vctxt->depth < 0)\n-    return;\n-    if ((vctxt->skipDepth != -1) && (vctxt->depth >= vctxt->skipDepth))\n-    return;\n-    if (vctxt->inode->flags & XML_SCHEMA_ELEM_INFO_EMPTY)\n-    vctxt->inode->flags ^= XML_SCHEMA_ELEM_INFO_EMPTY;\n-    if (xmlSchemaVPushText(vctxt, XML_TEXT_NODE, ch, len,\n-    XML_SCHEMA_PUSH_TEXT_VOLATILE, NULL) == -1) {\n-    VERROR_INT(\"xmlSchemaSAXHandleCDataSection\",\n-        \"calling xmlSchemaVPushText()\");\n-    vctxt->err = -1;\n-    xmlStopParser(vctxt->parserCtxt);\n-    }\n-}\n-\n-\/*\n-* Process CDATA content.\n-*\/\n-static void\n-xmlSchemaSAXHandleCDataSection(void *ctx,\n-                 const xmlChar * ch,\n-                 int len)\n-{\n-    xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) ctx;\n-\n-    if (vctxt->depth < 0)\n-    return;\n-    if ((vctxt->skipDepth != -1) && (vctxt->depth >= vctxt->skipDepth))\n-    return;\n-    if (vctxt->inode->flags & XML_SCHEMA_ELEM_INFO_EMPTY)\n-    vctxt->inode->flags ^= XML_SCHEMA_ELEM_INFO_EMPTY;\n-    if (xmlSchemaVPushText(vctxt, XML_CDATA_SECTION_NODE, ch, len,\n-    XML_SCHEMA_PUSH_TEXT_VOLATILE, NULL) == -1) {\n-    VERROR_INT(\"xmlSchemaSAXHandleCDataSection\",\n-        \"calling xmlSchemaVPushText()\");\n-    vctxt->err = -1;\n-    xmlStopParser(vctxt->parserCtxt);\n-    }\n-}\n-\n-static void\n-xmlSchemaSAXHandleReference(void *ctx ATTRIBUTE_UNUSED,\n-                const xmlChar * name ATTRIBUTE_UNUSED)\n-{\n-    xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) ctx;\n-\n-    if (vctxt->depth < 0)\n-    return;\n-    if ((vctxt->skipDepth != -1) && (vctxt->depth >= vctxt->skipDepth))\n-    return;\n-    \/* SAX VAL TODO: What to do here? *\/\n-}\n-\n-static void\n-xmlSchemaSAXHandleStartElementNs(void *ctx,\n-                 const xmlChar * localname,\n-                 const xmlChar * prefix ATTRIBUTE_UNUSED,\n-                 const xmlChar * URI,\n-                 int nb_namespaces,\n-                 const xmlChar ** namespaces,\n-                 int nb_attributes,\n-                 int nb_defaulted ATTRIBUTE_UNUSED,\n-                 const xmlChar ** attributes)\n-{\n-    xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) ctx;\n-    int ret;\n-    xmlSchemaNodeInfoPtr ielem;\n-    int i, j;\n-\n-    \/*\n-    * SAX VAL TODO: What to do with nb_defaulted?\n-    *\/\n-    \/*\n-    * Skip elements if inside a \"skip\" wildcard or invalid.\n-    *\/\n-    vctxt->depth++;\n-    if ((vctxt->skipDepth != -1) && (vctxt->depth >= vctxt->skipDepth))\n-    return;\n-    \/*\n-    * Push the element.\n-    *\/\n-    if (xmlSchemaValidatorPushElem(vctxt) == -1) {\n-    VERROR_INT(\"xmlSchemaSAXHandleStartElementNs\",\n-        \"calling xmlSchemaValidatorPushElem()\");\n-    goto internal_error;\n-    }\n-    ielem = vctxt->inode;\n-    \/*\n-    * TODO: Is this OK?\n-    *\/\n-    ielem->nodeLine = xmlSAX2GetLineNumber(vctxt->parserCtxt);\n-    ielem->localName = localname;\n-    ielem->nsName = URI;\n-    ielem->flags |= XML_SCHEMA_ELEM_INFO_EMPTY;\n-    \/*\n-    * Register namespaces on the elem info.\n-    *\/\n-    if (nb_namespaces != 0) {\n-    \/*\n-    * Although the parser builds its own namespace list,\n-    * we have no access to it, so we'll use an own one.\n-    *\/\n-        for (i = 0, j = 0; i < nb_namespaces; i++, j += 2) {\n-        \/*\n-        * Store prefix and namespace name.\n-        *\/\n-        if (ielem->nsBindings == NULL) {\n-        ielem->nsBindings =\n-            (const xmlChar **) xmlMalloc(10 *\n-            sizeof(const xmlChar *));\n-        if (ielem->nsBindings == NULL) {\n-            xmlSchemaVErrMemory(vctxt);\n-            goto internal_error;\n-        }\n-        ielem->nbNsBindings = 0;\n-        ielem->sizeNsBindings = 5;\n-        } else if (ielem->sizeNsBindings <= ielem->nbNsBindings) {\n-        ielem->sizeNsBindings *= 2;\n-        ielem->nsBindings =\n-            (const xmlChar **) xmlRealloc(\n-            (void *) ielem->nsBindings,\n-            ielem->sizeNsBindings * 2 * sizeof(const xmlChar *));\n-        if (ielem->nsBindings == NULL) {\n-            xmlSchemaVErrMemory(vctxt);\n-            goto internal_error;\n-        }\n-        }\n-\n-        ielem->nsBindings[ielem->nbNsBindings * 2] = namespaces[j];\n-        if (namespaces[j+1][0] == 0) {\n-        \/*\n-        * Handle xmlns=\"\".\n-        *\/\n-        ielem->nsBindings[ielem->nbNsBindings * 2 + 1] = NULL;\n-        } else\n-        ielem->nsBindings[ielem->nbNsBindings * 2 + 1] =\n-            namespaces[j+1];\n-        ielem->nbNsBindings++;\n-    }\n-    }\n-    \/*\n-    * Register attributes.\n-    * SAX VAL TODO: We are not adding namespace declaration\n-    * attributes yet.\n-    *\/\n-    if (nb_attributes != 0) {\n-    int valueLen, k, l;\n-    xmlChar *value;\n-\n-        for (j = 0, i = 0; i < nb_attributes; i++, j += 5) {\n-        \/*\n-        * Duplicate the value, changing any &#38; to a literal ampersand.\n-        *\n-        * libxml2 differs from normal SAX here in that it escapes all ampersands\n-        * as &#38; instead of delivering the raw converted string. Changing the\n-        * behavior at this point would break applications that use this API, so\n-        * we are forced to work around it.\n-        *\/\n-        valueLen = attributes[j+4] - attributes[j+3];\n-        value = xmlMallocAtomic(valueLen + 1);\n-        if (value == NULL) {\n-        xmlSchemaVErrMemory(vctxt);\n-        goto internal_error;\n-        }\n-        for (k = 0, l = 0; k < valueLen; l++) {\n-        if (k < valueLen - 4 &&\n-            attributes[j+3][k+0] == '&' &&\n-            attributes[j+3][k+1] == '#' &&\n-            attributes[j+3][k+2] == '3' &&\n-            attributes[j+3][k+3] == '8' &&\n-            attributes[j+3][k+4] == ';') {\n-            value[l] = '&';\n-            k += 5;\n-        } else {\n-            value[l] = attributes[j+3][k];\n-            k++;\n-        }\n-        }\n-        value[l] = '\\0';\n-        \/*\n-        * TODO: Set the node line.\n-        *\/\n-        ret = xmlSchemaValidatorPushAttribute(vctxt,\n-        NULL, ielem->nodeLine, attributes[j], attributes[j+2], 0,\n-        value, 1);\n-        if (ret == -1) {\n-        VERROR_INT(\"xmlSchemaSAXHandleStartElementNs\",\n-            \"calling xmlSchemaValidatorPushAttribute()\");\n-        goto internal_error;\n-        }\n-    }\n-    }\n-    \/*\n-    * Validate the element.\n-    *\/\n-    ret = xmlSchemaValidateElem(vctxt);\n-    if (ret != 0) {\n-    if (ret == -1) {\n-        VERROR_INT(\"xmlSchemaSAXHandleStartElementNs\",\n-        \"calling xmlSchemaValidateElem()\");\n-        goto internal_error;\n-    }\n-    goto exit;\n-    }\n-\n-exit:\n-    return;\n-internal_error:\n-    vctxt->err = -1;\n-    xmlStopParser(vctxt->parserCtxt);\n-    return;\n-}\n-\n-static void\n-xmlSchemaSAXHandleEndElementNs(void *ctx,\n-                   const xmlChar * localname ATTRIBUTE_UNUSED,\n-                   const xmlChar * prefix ATTRIBUTE_UNUSED,\n-                   const xmlChar * URI ATTRIBUTE_UNUSED)\n-{\n-    xmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) ctx;\n-    int res;\n-\n-    \/*\n-    * Skip elements if inside a \"skip\" wildcard or if invalid.\n-    *\/\n-    if (vctxt->skipDepth != -1) {\n-    if (vctxt->depth > vctxt->skipDepth) {\n-        vctxt->depth--;\n-        return;\n-    } else\n-        vctxt->skipDepth = -1;\n-    }\n-    \/*\n-    * SAX VAL TODO: Just a temporary check.\n-    *\/\n-    if ((!xmlStrEqual(vctxt->inode->localName, localname)) ||\n-    (!xmlStrEqual(vctxt->inode->nsName, URI))) {\n-    VERROR_INT(\"xmlSchemaSAXHandleEndElementNs\",\n-        \"elem pop mismatch\");\n-    }\n-    res = xmlSchemaValidatorPopElem(vctxt);\n-    if (res != 0) {\n-    if (res < 0) {\n-        VERROR_INT(\"xmlSchemaSAXHandleEndElementNs\",\n-        \"calling xmlSchemaValidatorPopElem()\");\n-        goto internal_error;\n-    }\n-    goto exit;\n-    }\n-exit:\n-    return;\n-internal_error:\n-    vctxt->err = -1;\n-    xmlStopParser(vctxt->parserCtxt);\n-    return;\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Validation interfaces                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlSchemaNewValidCtxt:\n- * @schema:  a precompiled XML Schemas\n- *\n- * Create an XML Schemas validation context based on the given schema.\n- *\n- * Returns the validation context or NULL in case of error\n- *\/\n-xmlSchemaValidCtxtPtr\n-xmlSchemaNewValidCtxt(xmlSchemaPtr schema)\n-{\n-    xmlSchemaValidCtxtPtr ret;\n-\n-    ret = (xmlSchemaValidCtxtPtr) xmlMalloc(sizeof(xmlSchemaValidCtxt));\n-    if (ret == NULL) {\n-        xmlSchemaVErrMemory(NULL);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaValidCtxt));\n-    ret->type = XML_SCHEMA_CTXT_VALIDATOR;\n-    ret->dict = xmlDictCreate();\n-    ret->nodeQNames = xmlSchemaItemListCreate();\n-    ret->schema = schema;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaValidateSetFilename:\n- * @vctxt: the schema validation context\n- * @filename: the file name\n- *\n- * Workaround to provide file error reporting information when this is\n- * not provided by current APIs\n- *\/\n-void\n-xmlSchemaValidateSetFilename(xmlSchemaValidCtxtPtr vctxt, const char *filename) {\n-    if (vctxt == NULL)\n-        return;\n-    if (vctxt->filename != NULL)\n-        xmlFree(vctxt->filename);\n-    if (filename != NULL)\n-        vctxt->filename = (char *) xmlStrdup((const xmlChar *) filename);\n-    else\n-        vctxt->filename = NULL;\n-}\n-\n-\/**\n- * xmlSchemaClearValidCtxt:\n- * @vctxt: the schema validation context\n- *\n- * Free the resources associated to the schema validation context;\n- * leaves some fields alive intended for reuse of the context.\n- *\/\n-static void\n-xmlSchemaClearValidCtxt(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    if (vctxt == NULL)\n-        return;\n-\n-    \/*\n-    * TODO: Should we clear the flags?\n-    *   Might be problematic if one reuses the context\n-    *   and assumes that the options remain the same.\n-    *\/\n-    vctxt->flags = 0;\n-    vctxt->validationRoot = NULL;\n-    vctxt->doc = NULL;\n-#ifdef LIBXML_READER_ENABLED\n-    vctxt->reader = NULL;\n-#endif\n-    vctxt->hasKeyrefs = 0;\n-\n-    if (vctxt->value != NULL) {\n-        xmlSchemaFreeValue(vctxt->value);\n-    vctxt->value = NULL;\n-    }\n-    \/*\n-    * Augmented IDC information.\n-    *\/\n-    if (vctxt->aidcs != NULL) {\n-    xmlSchemaIDCAugPtr cur = vctxt->aidcs, next;\n-    do {\n-        next = cur->next;\n-        xmlFree(cur);\n-        cur = next;\n-    } while (cur != NULL);\n-    vctxt->aidcs = NULL;\n-    }\n-\n-    if (vctxt->idcNodes != NULL) {\n-    int i;\n-    xmlSchemaPSVIIDCNodePtr item;\n-\n-    for (i = 0; i < vctxt->nbIdcNodes; i++) {\n-        item = vctxt->idcNodes[i];\n-        xmlFree(item->keys);\n-        xmlFree(item);\n-    }\n-    xmlFree(vctxt->idcNodes);\n-    vctxt->idcNodes = NULL;\n-    vctxt->nbIdcNodes = 0;\n-    vctxt->sizeIdcNodes = 0;\n-    }\n-\n-    if (vctxt->idcKeys != NULL) {\n-    int i;\n-    for (i = 0; i < vctxt->nbIdcKeys; i++)\n-        xmlSchemaIDCFreeKey(vctxt->idcKeys[i]);\n-    xmlFree(vctxt->idcKeys);\n-    vctxt->idcKeys = NULL;\n-    vctxt->nbIdcKeys = 0;\n-    vctxt->sizeIdcKeys = 0;\n-    }\n-\n-    \/*\n-    * Note that we won't delete the XPath state pool here.\n-    *\/\n-    if (vctxt->xpathStates != NULL) {\n-    xmlSchemaFreeIDCStateObjList(vctxt->xpathStates);\n-    vctxt->xpathStates = NULL;\n-    }\n-    \/*\n-    * Attribute info.\n-    *\/\n-    if (vctxt->nbAttrInfos != 0) {\n-    xmlSchemaClearAttrInfos(vctxt);\n-    }\n-    \/*\n-    * Element info.\n-    *\/\n-    if (vctxt->elemInfos != NULL) {\n-    int i;\n-    xmlSchemaNodeInfoPtr ei;\n-\n-    for (i = 0; i < vctxt->sizeElemInfos; i++) {\n-        ei = vctxt->elemInfos[i];\n-        if (ei == NULL)\n-        break;\n-        xmlSchemaClearElemInfo(vctxt, ei);\n-    }\n-    }\n-    xmlSchemaItemListClear(vctxt->nodeQNames);\n-    \/* Recreate the dict. *\/\n-    xmlDictFree(vctxt->dict);\n-    \/*\n-    * TODO: Is is save to recreate it? Do we have a scenario\n-    * where the user provides the dict?\n-    *\/\n-    vctxt->dict = xmlDictCreate();\n-\n-    if (vctxt->filename != NULL) {\n-        xmlFree(vctxt->filename);\n-    vctxt->filename = NULL;\n-    }\n-\n-    \/*\n-     * Note that some cleanup functions can move items to the cache,\n-     * so the cache shouldn't be freed too early.\n-     *\/\n-    if (vctxt->idcMatcherCache != NULL) {\n-    xmlSchemaIDCMatcherPtr matcher = vctxt->idcMatcherCache, tmp;\n-\n-    while (matcher) {\n-        tmp = matcher;\n-        matcher = matcher->nextCached;\n-        xmlSchemaIDCFreeMatcherList(tmp);\n-    }\n-    vctxt->idcMatcherCache = NULL;\n-    }\n-}\n-\n-\/**\n- * xmlSchemaFreeValidCtxt:\n- * @ctxt:  the schema validation context\n- *\n- * Free the resources associated to the schema validation context\n- *\/\n-void\n-xmlSchemaFreeValidCtxt(xmlSchemaValidCtxtPtr ctxt)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    if (ctxt->value != NULL)\n-        xmlSchemaFreeValue(ctxt->value);\n-    if (ctxt->pctxt != NULL)\n-    xmlSchemaFreeParserCtxt(ctxt->pctxt);\n-    if (ctxt->idcNodes != NULL) {\n-    int i;\n-    xmlSchemaPSVIIDCNodePtr item;\n-\n-    for (i = 0; i < ctxt->nbIdcNodes; i++) {\n-        item = ctxt->idcNodes[i];\n-        xmlFree(item->keys);\n-        xmlFree(item);\n-    }\n-    xmlFree(ctxt->idcNodes);\n-    }\n-    if (ctxt->idcKeys != NULL) {\n-    int i;\n-    for (i = 0; i < ctxt->nbIdcKeys; i++)\n-        xmlSchemaIDCFreeKey(ctxt->idcKeys[i]);\n-    xmlFree(ctxt->idcKeys);\n-    }\n-\n-    if (ctxt->xpathStates != NULL) {\n-    xmlSchemaFreeIDCStateObjList(ctxt->xpathStates);\n-    ctxt->xpathStates = NULL;\n-    }\n-    if (ctxt->xpathStatePool != NULL) {\n-    xmlSchemaFreeIDCStateObjList(ctxt->xpathStatePool);\n-    ctxt->xpathStatePool = NULL;\n-    }\n-\n-    \/*\n-    * Augmented IDC information.\n-    *\/\n-    if (ctxt->aidcs != NULL) {\n-    xmlSchemaIDCAugPtr cur = ctxt->aidcs, next;\n-    do {\n-        next = cur->next;\n-        xmlFree(cur);\n-        cur = next;\n-    } while (cur != NULL);\n-    }\n-    if (ctxt->attrInfos != NULL) {\n-    int i;\n-    xmlSchemaAttrInfoPtr attr;\n-\n-    \/* Just a paranoid call to the cleanup. *\/\n-    if (ctxt->nbAttrInfos != 0)\n-        xmlSchemaClearAttrInfos(ctxt);\n-    for (i = 0; i < ctxt->sizeAttrInfos; i++) {\n-        attr = ctxt->attrInfos[i];\n-        xmlFree(attr);\n-    }\n-    xmlFree(ctxt->attrInfos);\n-    }\n-    if (ctxt->elemInfos != NULL) {\n-    int i;\n-    xmlSchemaNodeInfoPtr ei;\n-\n-    for (i = 0; i < ctxt->sizeElemInfos; i++) {\n-        ei = ctxt->elemInfos[i];\n-        if (ei == NULL)\n-        break;\n-        xmlSchemaClearElemInfo(ctxt, ei);\n-        xmlFree(ei);\n-    }\n-    xmlFree(ctxt->elemInfos);\n-    }\n-    if (ctxt->nodeQNames != NULL)\n-    xmlSchemaItemListFree(ctxt->nodeQNames);\n-    if (ctxt->dict != NULL)\n-    xmlDictFree(ctxt->dict);\n-    if (ctxt->filename != NULL)\n-    xmlFree(ctxt->filename);\n-    xmlFree(ctxt);\n-}\n-\n-\/**\n- * xmlSchemaIsValid:\n- * @ctxt: the schema validation context\n- *\n- * Check if any error was detected during validation.\n- *\n- * Returns 1 if valid so far, 0 if errors were detected, and -1 in case\n- *         of internal error.\n- *\/\n-int\n-xmlSchemaIsValid(xmlSchemaValidCtxtPtr ctxt)\n-{\n-    if (ctxt == NULL)\n-        return(-1);\n-    return(ctxt->err == 0);\n-}\n-\n-\/**\n- * xmlSchemaSetValidErrors:\n- * @ctxt:  a schema validation context\n- * @err:  the error function\n- * @warn: the warning function\n- * @ctx: the functions context\n- *\n- * DEPRECATED: Use xmlSchemaSetValidStructuredErrors.\n- *\n- * Set the error and warning callback information\n- *\/\n-void\n-xmlSchemaSetValidErrors(xmlSchemaValidCtxtPtr ctxt,\n-                        xmlSchemaValidityErrorFunc err,\n-                        xmlSchemaValidityWarningFunc warn, void *ctx)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    ctxt->error = err;\n-    ctxt->warning = warn;\n-    ctxt->errCtxt = ctx;\n-    if (ctxt->pctxt != NULL)\n-    xmlSchemaSetParserErrors(ctxt->pctxt, err, warn, ctx);\n-}\n-\n-\/**\n- * xmlSchemaSetValidStructuredErrors:\n- * @ctxt:  a schema validation context\n- * @serror:  the structured error function\n- * @ctx: the functions context\n- *\n- * Set the structured error callback\n- *\/\n-void\n-xmlSchemaSetValidStructuredErrors(xmlSchemaValidCtxtPtr ctxt,\n-                  xmlStructuredErrorFunc serror, void *ctx)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    ctxt->serror = serror;\n-    ctxt->error = NULL;\n-    ctxt->warning = NULL;\n-    ctxt->errCtxt = ctx;\n-    if (ctxt->pctxt != NULL)\n-    xmlSchemaSetParserStructuredErrors(ctxt->pctxt, serror, ctx);\n-}\n-\n-\/**\n- * xmlSchemaGetValidErrors:\n- * @ctxt: a XML-Schema validation context\n- * @err: the error function result\n- * @warn: the warning function result\n- * @ctx: the functions context result\n- *\n- * Get the error and warning callback information\n- *\n- * Returns -1 in case of error and 0 otherwise\n- *\/\n-int\n-xmlSchemaGetValidErrors(xmlSchemaValidCtxtPtr ctxt,\n-            xmlSchemaValidityErrorFunc * err,\n-            xmlSchemaValidityWarningFunc * warn, void **ctx)\n-{\n-    if (ctxt == NULL)\n-        return (-1);\n-    if (err != NULL)\n-        *err = ctxt->error;\n-    if (warn != NULL)\n-        *warn = ctxt->warning;\n-    if (ctx != NULL)\n-        *ctx = ctxt->errCtxt;\n-    return (0);\n-}\n-\n-\n-\/**\n- * xmlSchemaSetValidOptions:\n- * @ctxt:    a schema validation context\n- * @options: a combination of xmlSchemaValidOption\n- *\n- * Sets the options to be used during the validation.\n- *\n- * Returns 0 in case of success, -1 in case of an\n- * API error.\n- *\/\n-int\n-xmlSchemaSetValidOptions(xmlSchemaValidCtxtPtr ctxt,\n-             int options)\n-\n-{\n-    int i;\n-\n-    if (ctxt == NULL)\n-    return (-1);\n-    \/*\n-    * WARNING: Change the start value if adding to the\n-    * xmlSchemaValidOption.\n-    * TODO: Is there an other, more easy to maintain,\n-    * way?\n-    *\/\n-    for (i = 1; i < (int) sizeof(int) * 8; i++) {\n-        if (options & 1<<i)\n-        return (-1);\n-    }\n-    ctxt->options = options;\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaValidCtxtGetOptions:\n- * @ctxt: a schema validation context\n- *\n- * Get the validation context options.\n- *\n- * Returns the option combination or -1 on error.\n- *\/\n-int\n-xmlSchemaValidCtxtGetOptions(xmlSchemaValidCtxtPtr ctxt)\n-\n-{\n-    if (ctxt == NULL)\n-    return (-1);\n-    else\n-    return (ctxt->options);\n-}\n-\n-static int\n-xmlSchemaVDocWalk(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    xmlAttrPtr attr;\n-    int ret = 0;\n-    xmlSchemaNodeInfoPtr ielem = NULL;\n-    xmlNodePtr node, valRoot;\n-    const xmlChar *nsName;\n-\n-    \/* DOC VAL TODO: Move this to the start function. *\/\n-    if (vctxt->validationRoot != NULL)\n-        valRoot = vctxt->validationRoot;\n-    else\n-    valRoot = xmlDocGetRootElement(vctxt->doc);\n-    if (valRoot == NULL) {\n-    \/* VAL TODO: Error code? *\/\n-    VERROR(1, NULL, \"The document has no document element\");\n-    return (1);\n-    }\n-    vctxt->depth = -1;\n-    vctxt->validationRoot = valRoot;\n-    node = valRoot;\n-    while (node != NULL) {\n-    if ((vctxt->skipDepth != -1) && (vctxt->depth >= vctxt->skipDepth))\n-        goto next_sibling;\n-    if (node->type == XML_ELEMENT_NODE) {\n-\n-        \/*\n-        * Init the node-info.\n-        *\/\n-        vctxt->depth++;\n-        if (xmlSchemaValidatorPushElem(vctxt) == -1)\n-        goto internal_error;\n-        ielem = vctxt->inode;\n-        ielem->node = node;\n-        ielem->nodeLine = node->line;\n-        ielem->localName = node->name;\n-        if (node->ns != NULL)\n-        ielem->nsName = node->ns->href;\n-        ielem->flags |= XML_SCHEMA_ELEM_INFO_EMPTY;\n-        \/*\n-        * Register attributes.\n-        * DOC VAL TODO: We do not register namespace declaration\n-        * attributes yet.\n-        *\/\n-        vctxt->nbAttrInfos = 0;\n-        if (node->properties != NULL) {\n-        attr = node->properties;\n-        do {\n-            if (attr->ns != NULL)\n-            nsName = attr->ns->href;\n-            else\n-            nsName = NULL;\n-            ret = xmlSchemaValidatorPushAttribute(vctxt,\n-            (xmlNodePtr) attr,\n-            \/*\n-            * Note that we give it the line number of the\n-            * parent element.\n-            *\/\n-            ielem->nodeLine,\n-            attr->name, nsName, 0,\n-            xmlNodeListGetString(attr->doc, attr->children, 1), 1);\n-            if (ret == -1) {\n-            VERROR_INT(\"xmlSchemaDocWalk\",\n-                \"calling xmlSchemaValidatorPushAttribute()\");\n-            goto internal_error;\n-            }\n-            attr = attr->next;\n-        } while (attr);\n-        }\n-        \/*\n-        * Validate the element.\n-        *\/\n-        ret = xmlSchemaValidateElem(vctxt);\n-        if (ret != 0) {\n-        if (ret == -1) {\n-            VERROR_INT(\"xmlSchemaDocWalk\",\n-            \"calling xmlSchemaValidateElem()\");\n-            goto internal_error;\n-        }\n-        \/*\n-        * Don't stop validation; just skip the content\n-        * of this element.\n-        *\/\n-        goto leave_node;\n-        }\n-        if ((vctxt->skipDepth != -1) &&\n-        (vctxt->depth >= vctxt->skipDepth))\n-        goto leave_node;\n-    } else if ((node->type == XML_TEXT_NODE) ||\n-        (node->type == XML_CDATA_SECTION_NODE)) {\n-        \/*\n-        * Process character content.\n-        *\/\n-        if ((ielem != NULL) && (ielem->flags & XML_SCHEMA_ELEM_INFO_EMPTY))\n-        ielem->flags ^= XML_SCHEMA_ELEM_INFO_EMPTY;\n-        ret = xmlSchemaVPushText(vctxt, node->type, node->content,\n-        -1, XML_SCHEMA_PUSH_TEXT_PERSIST, NULL);\n-        if (ret < 0) {\n-        VERROR_INT(\"xmlSchemaVDocWalk\",\n-            \"calling xmlSchemaVPushText()\");\n-        goto internal_error;\n-        }\n-        \/*\n-        * DOC VAL TODO: Should we skip further validation of the\n-        * element content here?\n-        *\/\n-    } else if ((node->type == XML_ENTITY_NODE) ||\n-        (node->type == XML_ENTITY_REF_NODE)) {\n-        \/*\n-        * DOC VAL TODO: What to do with entities?\n-        *\/\n-        VERROR_INT(\"xmlSchemaVDocWalk\",\n-        \"there is at least one entity reference in the node-tree \"\n-        \"currently being validated. Processing of entities with \"\n-        \"this XML Schema processor is not supported (yet). Please \"\n-        \"substitute entities before validation.\");\n-        goto internal_error;\n-    } else {\n-        goto leave_node;\n-        \/*\n-        * DOC VAL TODO: XInclude nodes, etc.\n-        *\/\n-    }\n-    \/*\n-    * Walk the doc.\n-    *\/\n-    if (node->children != NULL) {\n-        node = node->children;\n-        continue;\n-    }\n-leave_node:\n-    if (node->type == XML_ELEMENT_NODE) {\n-        \/*\n-        * Leaving the scope of an element.\n-        *\/\n-        if (node != vctxt->inode->node) {\n-        VERROR_INT(\"xmlSchemaVDocWalk\",\n-            \"element position mismatch\");\n-        goto internal_error;\n-        }\n-        ret = xmlSchemaValidatorPopElem(vctxt);\n-        if (ret != 0) {\n-        if (ret < 0) {\n-            VERROR_INT(\"xmlSchemaVDocWalk\",\n-            \"calling xmlSchemaValidatorPopElem()\");\n-            goto internal_error;\n-        }\n-        }\n-        if (node == valRoot)\n-        goto exit;\n-    }\n-next_sibling:\n-    if (node->next != NULL)\n-        node = node->next;\n-    else {\n-        node = node->parent;\n-        goto leave_node;\n-    }\n-    }\n-\n-exit:\n-    return (ret);\n-internal_error:\n-    return (-1);\n-}\n-\n-static int\n-xmlSchemaPreRun(xmlSchemaValidCtxtPtr vctxt) {\n-    \/*\n-    * Some initialization.\n-    *\/\n-    vctxt->err = 0;\n-    vctxt->nberrors = 0;\n-    vctxt->depth = -1;\n-    vctxt->skipDepth = -1;\n-    vctxt->hasKeyrefs = 0;\n-#ifdef ENABLE_IDC_NODE_TABLES_TEST\n-    vctxt->createIDCNodeTables = 1;\n-#else\n-    vctxt->createIDCNodeTables = 0;\n-#endif\n-    \/*\n-    * Create a schema + parser if necessary.\n-    *\/\n-    if (vctxt->schema == NULL) {\n-    xmlSchemaParserCtxtPtr pctxt;\n-\n-    vctxt->xsiAssemble = 1;\n-    \/*\n-    * If not schema was given then we will create a schema\n-    * dynamically using XSI schema locations.\n-    *\n-    * Create the schema parser context.\n-    *\/\n-    if ((vctxt->pctxt == NULL) &&\n-       (xmlSchemaCreatePCtxtOnVCtxt(vctxt) == -1))\n-       return (-1);\n-    pctxt = vctxt->pctxt;\n-    pctxt->xsiAssemble = 1;\n-    \/*\n-    * Create the schema.\n-    *\/\n-    vctxt->schema = xmlSchemaNewSchema(pctxt);\n-    if (vctxt->schema == NULL)\n-        return (-1);\n-    \/*\n-    * Create the schema construction context.\n-    *\/\n-    pctxt->constructor = xmlSchemaConstructionCtxtCreate(pctxt->dict);\n-    if (pctxt->constructor == NULL)\n-        return(-1);\n-    pctxt->constructor->mainSchema = vctxt->schema;\n-    \/*\n-    * Take ownership of the constructor to be able to free it.\n-    *\/\n-    pctxt->ownsConstructor = 1;\n-    }\n-    \/*\n-    * Augment the IDC definitions for the main schema and all imported ones\n-    * NOTE: main schema if the first in the imported list\n-    *\/\n-    xmlHashScan(vctxt->schema->schemasImports, xmlSchemaAugmentImportedIDC,\n-                vctxt);\n-\n-    return(0);\n-}\n-\n-static void\n-xmlSchemaPostRun(xmlSchemaValidCtxtPtr vctxt) {\n-    if (vctxt->xsiAssemble) {\n-    if (vctxt->schema != NULL) {\n-        xmlSchemaFree(vctxt->schema);\n-        vctxt->schema = NULL;\n-    }\n-    }\n-    xmlSchemaClearValidCtxt(vctxt);\n-}\n-\n-static int\n-xmlSchemaVStart(xmlSchemaValidCtxtPtr vctxt)\n-{\n-    int ret = 0;\n-\n-    if (xmlSchemaPreRun(vctxt) < 0)\n-        return(-1);\n-\n-    if (vctxt->doc != NULL) {\n-    \/*\n-     * Tree validation.\n-     *\/\n-    ret = xmlSchemaVDocWalk(vctxt);\n-#ifdef LIBXML_READER_ENABLED\n-    } else if (vctxt->reader != NULL) {\n-    \/*\n-     * XML Reader validation.\n-     *\/\n-#ifdef XML_SCHEMA_READER_ENABLED\n-    ret = xmlSchemaVReaderWalk(vctxt);\n-#endif\n-#endif\n-    } else if ((vctxt->sax != NULL) && (vctxt->parserCtxt != NULL)) {\n-    \/*\n-     * SAX validation.\n-     *\/\n-    ret = xmlParseDocument(vctxt->parserCtxt);\n-    } else {\n-    VERROR_INT(\"xmlSchemaVStart\",\n-        \"no instance to validate\");\n-    ret = -1;\n-    }\n-\n-    xmlSchemaPostRun(vctxt);\n-    if (ret == 0)\n-    ret = vctxt->err;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaValidateOneElement:\n- * @ctxt:  a schema validation context\n- * @elem:  an element node\n- *\n- * Validate a branch of a tree, starting with the given @elem.\n- *\n- * Returns 0 if the element and its subtree is valid, a positive error\n- * code number otherwise and -1 in case of an internal or API error.\n- *\/\n-int\n-xmlSchemaValidateOneElement(xmlSchemaValidCtxtPtr ctxt, xmlNodePtr elem)\n-{\n-    if ((ctxt == NULL) || (elem == NULL) || (elem->type != XML_ELEMENT_NODE))\n-    return (-1);\n-\n-    if (ctxt->schema == NULL)\n-    return (-1);\n-\n-    ctxt->doc = elem->doc;\n-    ctxt->node = elem;\n-    ctxt->validationRoot = elem;\n-    return(xmlSchemaVStart(ctxt));\n-}\n-\n-\/**\n- * xmlSchemaValidateDoc:\n- * @ctxt:  a schema validation context\n- * @doc:  a parsed document tree\n- *\n- * Validate a document tree in memory.\n- *\n- * Returns 0 if the document is schemas valid, a positive error code\n- *     number otherwise and -1 in case of internal or API error.\n- *\/\n-int\n-xmlSchemaValidateDoc(xmlSchemaValidCtxtPtr ctxt, xmlDocPtr doc)\n-{\n-    if ((ctxt == NULL) || (doc == NULL))\n-        return (-1);\n-\n-    ctxt->doc = doc;\n-    ctxt->node = xmlDocGetRootElement(doc);\n-    if (ctxt->node == NULL) {\n-        xmlSchemaCustomErr(ACTXT_CAST ctxt,\n-        XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING,\n-        (xmlNodePtr) doc, NULL,\n-        \"The document has no document element\", NULL, NULL);\n-        return (ctxt->err);\n-    }\n-    ctxt->validationRoot = ctxt->node;\n-    return (xmlSchemaVStart(ctxt));\n-}\n-\n-\n-\/************************************************************************\n- *                                    *\n- *        Function and data for SAX streaming API            *\n- *                                    *\n- ************************************************************************\/\n-typedef struct _xmlSchemaSplitSAXData xmlSchemaSplitSAXData;\n-typedef xmlSchemaSplitSAXData *xmlSchemaSplitSAXDataPtr;\n-\n-struct _xmlSchemaSplitSAXData {\n-    xmlSAXHandlerPtr      user_sax;\n-    void                 *user_data;\n-    xmlSchemaValidCtxtPtr ctxt;\n-    xmlSAXHandlerPtr      schemas_sax;\n-};\n-\n-#define XML_SAX_PLUG_MAGIC 0xdc43ba21\n-\n-struct _xmlSchemaSAXPlug {\n-    unsigned int magic;\n-\n-    \/* the original callbacks information *\/\n-    xmlSAXHandlerPtr     *user_sax_ptr;\n-    xmlSAXHandlerPtr      user_sax;\n-    void                **user_data_ptr;\n-    void                 *user_data;\n-\n-    \/* the block plugged back and validation information *\/\n-    xmlSAXHandler         schemas_sax;\n-    xmlSchemaValidCtxtPtr ctxt;\n-};\n-\n-\/* All those functions just bounces to the user provided SAX handlers *\/\n-static void\n-internalSubsetSplit(void *ctx, const xmlChar *name,\n-           const xmlChar *ExternalID, const xmlChar *SystemID)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->internalSubset != NULL))\n-    ctxt->user_sax->internalSubset(ctxt->user_data, name, ExternalID,\n-                                   SystemID);\n-}\n-\n-static int\n-isStandaloneSplit(void *ctx)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->isStandalone != NULL))\n-    return(ctxt->user_sax->isStandalone(ctxt->user_data));\n-    return(0);\n-}\n-\n-static int\n-hasInternalSubsetSplit(void *ctx)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->hasInternalSubset != NULL))\n-    return(ctxt->user_sax->hasInternalSubset(ctxt->user_data));\n-    return(0);\n-}\n-\n-static int\n-hasExternalSubsetSplit(void *ctx)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->hasExternalSubset != NULL))\n-    return(ctxt->user_sax->hasExternalSubset(ctxt->user_data));\n-    return(0);\n-}\n-\n-static void\n-externalSubsetSplit(void *ctx, const xmlChar *name,\n-           const xmlChar *ExternalID, const xmlChar *SystemID)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->externalSubset != NULL))\n-    ctxt->user_sax->externalSubset(ctxt->user_data, name, ExternalID,\n-                                   SystemID);\n-}\n-\n-static xmlParserInputPtr\n-resolveEntitySplit(void *ctx, const xmlChar *publicId, const xmlChar *systemId)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->resolveEntity != NULL))\n-    return(ctxt->user_sax->resolveEntity(ctxt->user_data, publicId,\n-                                         systemId));\n-    return(NULL);\n-}\n-\n-static xmlEntityPtr\n-getEntitySplit(void *ctx, const xmlChar *name)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->getEntity != NULL))\n-    return(ctxt->user_sax->getEntity(ctxt->user_data, name));\n-    return(NULL);\n-}\n-\n-static xmlEntityPtr\n-getParameterEntitySplit(void *ctx, const xmlChar *name)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->getParameterEntity != NULL))\n-    return(ctxt->user_sax->getParameterEntity(ctxt->user_data, name));\n-    return(NULL);\n-}\n-\n-\n-static void\n-entityDeclSplit(void *ctx, const xmlChar *name, int type,\n-          const xmlChar *publicId, const xmlChar *systemId, xmlChar *content)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->entityDecl != NULL))\n-    ctxt->user_sax->entityDecl(ctxt->user_data, name, type, publicId,\n-                               systemId, content);\n-}\n-\n-static void\n-attributeDeclSplit(void *ctx, const xmlChar * elem,\n-                   const xmlChar * name, int type, int def,\n-                   const xmlChar * defaultValue, xmlEnumerationPtr tree)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->attributeDecl != NULL)) {\n-    ctxt->user_sax->attributeDecl(ctxt->user_data, elem, name, type,\n-                                  def, defaultValue, tree);\n-    } else {\n-    xmlFreeEnumeration(tree);\n-    }\n-}\n-\n-static void\n-elementDeclSplit(void *ctx, const xmlChar *name, int type,\n-        xmlElementContentPtr content)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->elementDecl != NULL))\n-    ctxt->user_sax->elementDecl(ctxt->user_data, name, type, content);\n-}\n-\n-static void\n-notationDeclSplit(void *ctx, const xmlChar *name,\n-         const xmlChar *publicId, const xmlChar *systemId)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->notationDecl != NULL))\n-    ctxt->user_sax->notationDecl(ctxt->user_data, name, publicId,\n-                                 systemId);\n-}\n-\n-static void\n-unparsedEntityDeclSplit(void *ctx, const xmlChar *name,\n-           const xmlChar *publicId, const xmlChar *systemId,\n-           const xmlChar *notationName)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->unparsedEntityDecl != NULL))\n-    ctxt->user_sax->unparsedEntityDecl(ctxt->user_data, name, publicId,\n-                                       systemId, notationName);\n-}\n-\n-static void\n-setDocumentLocatorSplit(void *ctx, xmlSAXLocatorPtr loc)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->setDocumentLocator != NULL))\n-    ctxt->user_sax->setDocumentLocator(ctxt->user_data, loc);\n-}\n-\n-static void\n-startDocumentSplit(void *ctx)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->startDocument != NULL))\n-    ctxt->user_sax->startDocument(ctxt->user_data);\n-}\n-\n-static void\n-endDocumentSplit(void *ctx)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->endDocument != NULL))\n-    ctxt->user_sax->endDocument(ctxt->user_data);\n-}\n-\n-static void\n-processingInstructionSplit(void *ctx, const xmlChar *target,\n-                      const xmlChar *data)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->processingInstruction != NULL))\n-    ctxt->user_sax->processingInstruction(ctxt->user_data, target, data);\n-}\n-\n-static void\n-commentSplit(void *ctx, const xmlChar *value)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->comment != NULL))\n-    ctxt->user_sax->comment(ctxt->user_data, value);\n-}\n-\n-\/*\n- * Varargs error callbacks to the user application, harder ...\n- *\/\n-\n-static void\n-warningSplit(void *ctx, const char *msg ATTRIBUTE_UNUSED, ...) {\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->warning != NULL)) {\n-    \/* TODO *\/\n-    }\n-}\n-static void\n-errorSplit(void *ctx, const char *msg ATTRIBUTE_UNUSED, ...) {\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->error != NULL)) {\n-    \/* TODO *\/\n-    }\n-}\n-static void\n-fatalErrorSplit(void *ctx, const char *msg ATTRIBUTE_UNUSED, ...) {\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->fatalError != NULL)) {\n-    \/* TODO *\/\n-    }\n-}\n-\n-\/*\n- * Those are function where both the user handler and the schemas handler\n- * need to be called.\n- *\/\n-static void\n-charactersSplit(void *ctx, const xmlChar *ch, int len)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if (ctxt == NULL)\n-        return;\n-    if ((ctxt->user_sax != NULL) && (ctxt->user_sax->characters != NULL))\n-    ctxt->user_sax->characters(ctxt->user_data, ch, len);\n-    if (ctxt->ctxt != NULL)\n-    xmlSchemaSAXHandleText(ctxt->ctxt, ch, len);\n-}\n-\n-static void\n-ignorableWhitespaceSplit(void *ctx, const xmlChar *ch, int len)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if (ctxt == NULL)\n-        return;\n-    if ((ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->ignorableWhitespace != NULL))\n-    ctxt->user_sax->ignorableWhitespace(ctxt->user_data, ch, len);\n-    if (ctxt->ctxt != NULL)\n-    xmlSchemaSAXHandleText(ctxt->ctxt, ch, len);\n-}\n-\n-static void\n-cdataBlockSplit(void *ctx, const xmlChar *value, int len)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if (ctxt == NULL)\n-        return;\n-    if ((ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->cdataBlock != NULL))\n-    ctxt->user_sax->cdataBlock(ctxt->user_data, value, len);\n-    if (ctxt->ctxt != NULL)\n-    xmlSchemaSAXHandleCDataSection(ctxt->ctxt, value, len);\n-}\n-\n-static void\n-referenceSplit(void *ctx, const xmlChar *name)\n-{\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if (ctxt == NULL)\n-        return;\n-    if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->reference != NULL))\n-    ctxt->user_sax->reference(ctxt->user_data, name);\n-    if (ctxt->ctxt != NULL)\n-        xmlSchemaSAXHandleReference(ctxt->user_data, name);\n-}\n-\n-static void\n-startElementNsSplit(void *ctx, const xmlChar * localname,\n-            const xmlChar * prefix, const xmlChar * URI,\n-            int nb_namespaces, const xmlChar ** namespaces,\n-            int nb_attributes, int nb_defaulted,\n-            const xmlChar ** attributes) {\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if (ctxt == NULL)\n-        return;\n-    if ((ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->startElementNs != NULL))\n-    ctxt->user_sax->startElementNs(ctxt->user_data, localname, prefix,\n-                                   URI, nb_namespaces, namespaces,\n-                       nb_attributes, nb_defaulted,\n-                       attributes);\n-    if (ctxt->ctxt != NULL)\n-    xmlSchemaSAXHandleStartElementNs(ctxt->ctxt, localname, prefix,\n-                                     URI, nb_namespaces, namespaces,\n-                     nb_attributes, nb_defaulted,\n-                     attributes);\n-}\n-\n-static void\n-endElementNsSplit(void *ctx, const xmlChar * localname,\n-            const xmlChar * prefix, const xmlChar * URI) {\n-    xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;\n-    if (ctxt == NULL)\n-        return;\n-    if ((ctxt->user_sax != NULL) &&\n-        (ctxt->user_sax->endElementNs != NULL))\n-    ctxt->user_sax->endElementNs(ctxt->user_data, localname, prefix, URI);\n-    if (ctxt->ctxt != NULL)\n-    xmlSchemaSAXHandleEndElementNs(ctxt->ctxt, localname, prefix, URI);\n-}\n-\n-\/**\n- * xmlSchemaSAXPlug:\n- * @ctxt:  a schema validation context\n- * @sax:  a pointer to the original xmlSAXHandlerPtr\n- * @user_data:  a pointer to the original SAX user data pointer\n- *\n- * Plug a SAX based validation layer in a SAX parsing event flow.\n- * The original @saxptr and @dataptr data are replaced by new pointers\n- * but the calls to the original will be maintained.\n- *\n- * Returns a pointer to a data structure needed to unplug the validation layer\n- *         or NULL in case of errors.\n- *\/\n-xmlSchemaSAXPlugPtr\n-xmlSchemaSAXPlug(xmlSchemaValidCtxtPtr ctxt,\n-         xmlSAXHandlerPtr *sax, void **user_data)\n-{\n-    xmlSchemaSAXPlugPtr ret;\n-    xmlSAXHandlerPtr old_sax;\n-\n-    if ((ctxt == NULL) || (sax == NULL) || (user_data == NULL))\n-        return(NULL);\n-\n-    \/*\n-     * We only allow to plug into SAX2 event streams\n-     *\/\n-    old_sax = *sax;\n-    if ((old_sax != NULL) && (old_sax->initialized != XML_SAX2_MAGIC))\n-        return(NULL);\n-    if ((old_sax != NULL) &&\n-        (old_sax->startElementNs == NULL) && (old_sax->endElementNs == NULL) &&\n-        ((old_sax->startElement != NULL) || (old_sax->endElement != NULL)))\n-        return(NULL);\n-\n-    \/*\n-     * everything seems right allocate the local data needed for that layer\n-     *\/\n-    ret = (xmlSchemaSAXPlugPtr) xmlMalloc(sizeof(xmlSchemaSAXPlugStruct));\n-    if (ret == NULL) {\n-        return(NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaSAXPlugStruct));\n-    ret->magic = XML_SAX_PLUG_MAGIC;\n-    ret->schemas_sax.initialized = XML_SAX2_MAGIC;\n-    ret->ctxt = ctxt;\n-    ret->user_sax_ptr = sax;\n-    ret->user_sax = old_sax;\n-    if (old_sax == NULL) {\n-        \/*\n-     * go direct, no need for the split block and functions.\n-     *\/\n-    ret->schemas_sax.startElementNs = xmlSchemaSAXHandleStartElementNs;\n-    ret->schemas_sax.endElementNs = xmlSchemaSAXHandleEndElementNs;\n-    \/*\n-     * Note that we use the same text-function for both, to prevent\n-     * the parser from testing for ignorable whitespace.\n-     *\/\n-    ret->schemas_sax.ignorableWhitespace = xmlSchemaSAXHandleText;\n-    ret->schemas_sax.characters = xmlSchemaSAXHandleText;\n-\n-    ret->schemas_sax.cdataBlock = xmlSchemaSAXHandleCDataSection;\n-    ret->schemas_sax.reference = xmlSchemaSAXHandleReference;\n-\n-    ret->user_data = ctxt;\n-    *user_data = ctxt;\n-    } else {\n-       \/*\n-        * for each callback unused by Schemas initialize it to the Split\n-    * routine only if non NULL in the user block, this can speed up\n-    * things at the SAX level.\n-    *\/\n-        if (old_sax->internalSubset != NULL)\n-            ret->schemas_sax.internalSubset = internalSubsetSplit;\n-        if (old_sax->isStandalone != NULL)\n-            ret->schemas_sax.isStandalone = isStandaloneSplit;\n-        if (old_sax->hasInternalSubset != NULL)\n-            ret->schemas_sax.hasInternalSubset = hasInternalSubsetSplit;\n-        if (old_sax->hasExternalSubset != NULL)\n-            ret->schemas_sax.hasExternalSubset = hasExternalSubsetSplit;\n-        if (old_sax->resolveEntity != NULL)\n-            ret->schemas_sax.resolveEntity = resolveEntitySplit;\n-        if (old_sax->getEntity != NULL)\n-            ret->schemas_sax.getEntity = getEntitySplit;\n-        if (old_sax->entityDecl != NULL)\n-            ret->schemas_sax.entityDecl = entityDeclSplit;\n-        if (old_sax->notationDecl != NULL)\n-            ret->schemas_sax.notationDecl = notationDeclSplit;\n-        if (old_sax->attributeDecl != NULL)\n-            ret->schemas_sax.attributeDecl = attributeDeclSplit;\n-        if (old_sax->elementDecl != NULL)\n-            ret->schemas_sax.elementDecl = elementDeclSplit;\n-        if (old_sax->unparsedEntityDecl != NULL)\n-            ret->schemas_sax.unparsedEntityDecl = unparsedEntityDeclSplit;\n-        if (old_sax->setDocumentLocator != NULL)\n-            ret->schemas_sax.setDocumentLocator = setDocumentLocatorSplit;\n-        if (old_sax->startDocument != NULL)\n-            ret->schemas_sax.startDocument = startDocumentSplit;\n-        if (old_sax->endDocument != NULL)\n-            ret->schemas_sax.endDocument = endDocumentSplit;\n-        if (old_sax->processingInstruction != NULL)\n-            ret->schemas_sax.processingInstruction = processingInstructionSplit;\n-        if (old_sax->comment != NULL)\n-            ret->schemas_sax.comment = commentSplit;\n-        if (old_sax->warning != NULL)\n-            ret->schemas_sax.warning = warningSplit;\n-        if (old_sax->error != NULL)\n-            ret->schemas_sax.error = errorSplit;\n-        if (old_sax->fatalError != NULL)\n-            ret->schemas_sax.fatalError = fatalErrorSplit;\n-        if (old_sax->getParameterEntity != NULL)\n-            ret->schemas_sax.getParameterEntity = getParameterEntitySplit;\n-        if (old_sax->externalSubset != NULL)\n-            ret->schemas_sax.externalSubset = externalSubsetSplit;\n-\n-    \/*\n-     * the 6 schemas callback have to go to the splitter functions\n-     * Note that we use the same text-function for ignorableWhitespace\n-     * if possible, to prevent the parser from testing for ignorable\n-     * whitespace.\n-     *\/\n-        ret->schemas_sax.characters = charactersSplit;\n-    if ((old_sax->ignorableWhitespace != NULL) &&\n-        (old_sax->ignorableWhitespace != old_sax->characters))\n-        ret->schemas_sax.ignorableWhitespace = ignorableWhitespaceSplit;\n-    else\n-        ret->schemas_sax.ignorableWhitespace = charactersSplit;\n-        ret->schemas_sax.cdataBlock = cdataBlockSplit;\n-        ret->schemas_sax.reference = referenceSplit;\n-        ret->schemas_sax.startElementNs = startElementNsSplit;\n-        ret->schemas_sax.endElementNs = endElementNsSplit;\n-\n-    ret->user_data_ptr = user_data;\n-    ret->user_data = *user_data;\n-    *user_data = ret;\n-    }\n-\n-    \/*\n-     * plug the pointers back.\n-     *\/\n-    *sax = &(ret->schemas_sax);\n-    ctxt->sax = *sax;\n-    ctxt->flags |= XML_SCHEMA_VALID_CTXT_FLAG_STREAM;\n-    xmlSchemaPreRun(ctxt);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlSchemaSAXUnplug:\n- * @plug:  a data structure returned by xmlSchemaSAXPlug\n- *\n- * Unplug a SAX based validation layer in a SAX parsing event flow.\n- * The original pointers used in the call are restored.\n- *\n- * Returns 0 in case of success and -1 in case of failure.\n- *\/\n-int\n-xmlSchemaSAXUnplug(xmlSchemaSAXPlugPtr plug)\n-{\n-    xmlSAXHandlerPtr *sax;\n-    void **user_data;\n-\n-    if ((plug == NULL) || (plug->magic != XML_SAX_PLUG_MAGIC))\n-        return(-1);\n-    plug->magic = 0;\n-\n-    xmlSchemaPostRun(plug->ctxt);\n-    \/* restore the data *\/\n-    sax = plug->user_sax_ptr;\n-    *sax = plug->user_sax;\n-    if (plug->user_sax != NULL) {\n-    user_data = plug->user_data_ptr;\n-    *user_data = plug->user_data;\n-    }\n-\n-    \/* free and return *\/\n-    xmlFree(plug);\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaValidateSetLocator:\n- * @vctxt: a schema validation context\n- * @f: the locator function pointer\n- * @ctxt: the locator context\n- *\n- * Allows to set a locator function to the validation context,\n- * which will be used to provide file and line information since\n- * those are not provided as part of the SAX validation flow\n- * Setting @f to NULL disable the locator.\n- *\/\n-\n-void\n-xmlSchemaValidateSetLocator(xmlSchemaValidCtxtPtr vctxt,\n-                            xmlSchemaValidityLocatorFunc f,\n-                void *ctxt)\n-{\n-    if (vctxt == NULL) return;\n-    vctxt->locFunc = f;\n-    vctxt->locCtxt = ctxt;\n-}\n-\n-\/**\n- * xmlSchemaValidateStreamLocator:\n- * @ctx: the xmlTextReaderPtr used\n- * @file: returned file information\n- * @line: returned line information\n- *\n- * Internal locator function for the readers\n- *\n- * Returns 0 in case the Schema validation could be (de)activated and\n- *         -1 in case of error.\n- *\/\n-static int\n-xmlSchemaValidateStreamLocator(void *ctx, const char **file,\n-                               unsigned long *line) {\n-    xmlParserCtxtPtr ctxt;\n-\n-    if ((ctx == NULL) || ((file == NULL) && (line == NULL)))\n-        return(-1);\n-\n-    if (file != NULL)\n-        *file = NULL;\n-    if (line != NULL)\n-        *line = 0;\n-\n-    ctxt = (xmlParserCtxtPtr) ctx;\n-    if (ctxt->input != NULL) {\n-       if (file != NULL)\n-           *file = ctxt->input->filename;\n-       if (line != NULL)\n-           *line = ctxt->input->line;\n-       return(0);\n-    }\n-    return(-1);\n-}\n-\n-\/**\n- * xmlSchemaValidateStreamInternal:\n- * @ctxt:  a schema validation context\n- * @pctxt:  a parser context\n- *\n- * Returns 0 if the document is schemas valid, a positive error code\n- *     number otherwise and -1 in case of internal or API error.\n- *\/\n-static int\n-xmlSchemaValidateStreamInternal(xmlSchemaValidCtxtPtr ctxt,\n-                                 xmlParserCtxtPtr pctxt) {\n-    xmlSchemaSAXPlugPtr plug = NULL;\n-    int ret;\n-\n-    pctxt->linenumbers = 1;\n-    xmlSchemaValidateSetLocator(ctxt, xmlSchemaValidateStreamLocator, pctxt);\n-\n-    ctxt->parserCtxt = pctxt;\n-    ctxt->input = pctxt->input->buf;\n-\n-    \/*\n-     * Plug the validation and launch the parsing\n-     *\/\n-    plug = xmlSchemaSAXPlug(ctxt, &(pctxt->sax), &(pctxt->userData));\n-    if (plug == NULL) {\n-        ret = -1;\n-    goto done;\n-    }\n-    ctxt->input = pctxt->input->buf;\n-    ctxt->sax = pctxt->sax;\n-    ctxt->flags |= XML_SCHEMA_VALID_CTXT_FLAG_STREAM;\n-    ret = xmlSchemaVStart(ctxt);\n-\n-    if ((ret == 0) && (! ctxt->parserCtxt->wellFormed)) {\n-    ret = ctxt->parserCtxt->errNo;\n-    if (ret == 0)\n-        ret = 1;\n-    }\n-\n-done:\n-    ctxt->parserCtxt = NULL;\n-    ctxt->sax = NULL;\n-    ctxt->input = NULL;\n-    if (plug != NULL) {\n-        xmlSchemaSAXUnplug(plug);\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaValidateStream:\n- * @ctxt:  a schema validation context\n- * @input:  the input to use for reading the data\n- * @enc:  an optional encoding information\n- * @sax:  a SAX handler for the resulting events\n- * @user_data:  the context to provide to the SAX handler.\n- *\n- * Validate an input based on a flow of SAX event from the parser\n- * and forward the events to the @sax handler with the provided @user_data\n- * the user provided @sax handler must be a SAX2 one.\n- *\n- * Returns 0 if the document is schemas valid, a positive error code\n- *     number otherwise and -1 in case of internal or API error.\n- *\/\n-int\n-xmlSchemaValidateStream(xmlSchemaValidCtxtPtr ctxt,\n-                        xmlParserInputBufferPtr input, xmlCharEncoding enc,\n-                        xmlSAXHandlerPtr sax, void *user_data)\n-{\n-    xmlParserCtxtPtr pctxt = NULL;\n-    xmlParserInputPtr inputStream = NULL;\n-    int ret;\n-\n-    if ((ctxt == NULL) || (input == NULL))\n-        return (-1);\n-\n-    \/*\n-     * prepare the parser\n-     *\/\n-    if (sax != NULL) {\n-        pctxt = xmlNewSAXParserCtxt(sax, user_data);\n-        if (pctxt == NULL)\n-            return (-1);\n-    } else {\n-        pctxt = xmlNewParserCtxt();\n-        if (pctxt == NULL)\n-            return (-1);\n-        \/* We really want pctxt->sax to be NULL here. *\/\n-        xmlFree(pctxt->sax);\n-        pctxt->sax = NULL;\n-    }\n-#if 0\n-    if (options)\n-        xmlCtxtUseOptions(pctxt, options);\n-#endif\n-\n-    inputStream = xmlNewIOInputStream(pctxt, input, enc);;\n-    if (inputStream == NULL) {\n-        ret = -1;\n-    goto done;\n-    }\n-    inputPush(pctxt, inputStream);\n-\n-    ctxt->enc = enc;\n-\n-    ret = xmlSchemaValidateStreamInternal(ctxt, pctxt);\n-\n-done:\n-    \/* cleanup *\/\n-    if (pctxt != NULL) {\n-    xmlFreeParserCtxt(pctxt);\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaValidateFile:\n- * @ctxt: a schema validation context\n- * @filename: the URI of the instance\n- * @options: a future set of options, currently unused\n- *\n- * Do a schemas validation of the given resource, it will use the\n- * SAX streamable validation internally.\n- *\n- * Returns 0 if the document is valid, a positive error code\n- *     number otherwise and -1 in case of an internal or API error.\n- *\/\n-int\n-xmlSchemaValidateFile(xmlSchemaValidCtxtPtr ctxt,\n-                      const char * filename,\n-              int options ATTRIBUTE_UNUSED)\n-{\n-    int ret;\n-    xmlParserCtxtPtr pctxt = NULL;\n-\n-    if ((ctxt == NULL) || (filename == NULL))\n-        return (-1);\n-\n-    pctxt = xmlCreateURLParserCtxt(filename, 0);\n-    if (pctxt == NULL)\n-    return (-1);\n-    \/* We really want pctxt->sax to be NULL here. *\/\n-    xmlFree(pctxt->sax);\n-    pctxt->sax = NULL;\n-    ret = xmlSchemaValidateStreamInternal(ctxt, pctxt);\n-    xmlFreeParserCtxt(pctxt);\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchemaValidCtxtGetParserCtxt:\n- * @ctxt: a schema validation context\n- *\n- * allow access to the parser context of the schema validation context\n- *\n- * Returns the parser context of the schema validation context or NULL\n- *         in case of error.\n- *\/\n-xmlParserCtxtPtr\n-xmlSchemaValidCtxtGetParserCtxt(xmlSchemaValidCtxtPtr ctxt)\n-{\n-    if (ctxt == NULL)\n-        return(NULL);\n-    return (ctxt->parserCtxt);\n-}\n-\n-#endif \/* LIBXML_SCHEMAS_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlschemas.c","additions":0,"deletions":28853,"binary":false,"changes":28853,"status":"deleted"},{"patch":"@@ -1,6268 +0,0 @@\n-\/*\n- * schemastypes.c : implementation of the XML Schema Datatypes\n- *             definition and validity checking\n- *\n- * See Copyright for the status of this software.\n- *\n- * Daniel Veillard <veillard@redhat.com>\n- *\/\n-\n-\/* To avoid EBCDIC trouble when parsing on zOS *\/\n-#if defined(__MVS__)\n-#pragma convert(\"ISO8859-1\")\n-#endif\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include <math.h>\n-#include <float.h>\n-\n-#include <libxml\/xmlmemory.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/hash.h>\n-#include <libxml\/xpath.h>\n-#include <libxml\/uri.h>\n-#include <string.h>\n-\n-#include <libxml\/xmlschemas.h>\n-#include <libxml\/schemasInternals.h>\n-#include <libxml\/xmlschemastypes.h>\n-\n-#include \"private\/error.h\"\n-\n-#ifndef LIBXML_XPATH_ENABLED\n-extern double xmlXPathNAN;\n-extern double xmlXPathPINF;\n-extern double xmlXPathNINF;\n-#endif\n-\n-#define XML_SCHEMAS_NAMESPACE_NAME \\\n-    (const xmlChar *)\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n-\n-#define IS_WSP_REPLACE_CH(c)    ((((c) == 0x9) || ((c) == 0xa)) || \\\n-                 ((c) == 0xd))\n-\n-#define IS_WSP_SPACE_CH(c)    ((c) == 0x20)\n-\n-#define IS_WSP_BLANK_CH(c) IS_BLANK_CH(c)\n-\n-\/* Date value *\/\n-typedef struct _xmlSchemaValDate xmlSchemaValDate;\n-typedef xmlSchemaValDate *xmlSchemaValDatePtr;\n-struct _xmlSchemaValDate {\n-    long        year;\n-    unsigned int    mon    :4;    \/* 1 <=  mon    <= 12   *\/\n-    unsigned int    day    :5;    \/* 1 <=  day    <= 31   *\/\n-    unsigned int    hour    :5;    \/* 0 <=  hour   <= 24   *\/\n-    unsigned int    min    :6;    \/* 0 <=  min    <= 59    *\/\n-    double        sec;\n-    unsigned int    tz_flag    :1;    \/* is tzo explicitly set? *\/\n-    signed int        tzo    :12;    \/* -1440 <= tzo <= 1440;\n-                       currently only -840 to +840 are needed *\/\n-};\n-\n-\/* Duration value *\/\n-typedef struct _xmlSchemaValDuration xmlSchemaValDuration;\n-typedef xmlSchemaValDuration *xmlSchemaValDurationPtr;\n-struct _xmlSchemaValDuration {\n-    long            mon;        \/* mon stores years also *\/\n-    long    day;\n-    double        sec;            \/* sec stores min and hour also *\/\n-};\n-\n-typedef struct _xmlSchemaValDecimal xmlSchemaValDecimal;\n-typedef xmlSchemaValDecimal *xmlSchemaValDecimalPtr;\n-struct _xmlSchemaValDecimal\n-{\n-    xmlChar *str;\n-    unsigned integralPlaces;\n-    unsigned fractionalPlaces;\n-};\n-\n-typedef struct _xmlSchemaValQName xmlSchemaValQName;\n-typedef xmlSchemaValQName *xmlSchemaValQNamePtr;\n-struct _xmlSchemaValQName {\n-    xmlChar *name;\n-    xmlChar *uri;\n-};\n-\n-typedef struct _xmlSchemaValHex xmlSchemaValHex;\n-typedef xmlSchemaValHex *xmlSchemaValHexPtr;\n-struct _xmlSchemaValHex {\n-    xmlChar     *str;\n-    unsigned int total;\n-};\n-\n-typedef struct _xmlSchemaValBase64 xmlSchemaValBase64;\n-typedef xmlSchemaValBase64 *xmlSchemaValBase64Ptr;\n-struct _xmlSchemaValBase64 {\n-    xmlChar     *str;\n-    unsigned int total;\n-};\n-\n-struct _xmlSchemaVal {\n-    xmlSchemaValType type;\n-    struct _xmlSchemaVal *next;\n-    union {\n-    xmlSchemaValDecimal     decimal;\n-        xmlSchemaValDate        date;\n-        xmlSchemaValDuration    dur;\n-    xmlSchemaValQName    qname;\n-    xmlSchemaValHex        hex;\n-    xmlSchemaValBase64    base64;\n-    float            f;\n-    double            d;\n-    int            b;\n-    xmlChar                *str;\n-    } value;\n-};\n-\n-static int xmlSchemaTypesInitialized = 0;\n-static xmlHashTablePtr xmlSchemaTypesBank = NULL;\n-\n-\/*\n- * Basic types\n- *\/\n-static xmlSchemaTypePtr xmlSchemaTypeStringDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeAnyTypeDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeAnySimpleTypeDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeDecimalDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeDatetimeDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeDateDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeTimeDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeGYearDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeGYearMonthDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeGDayDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeGMonthDayDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeGMonthDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeDurationDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeFloatDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeBooleanDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeDoubleDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeHexBinaryDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeBase64BinaryDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeAnyURIDef = NULL;\n-\n-\/*\n- * Derived types\n- *\/\n-static xmlSchemaTypePtr xmlSchemaTypePositiveIntegerDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeNonPositiveIntegerDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeNegativeIntegerDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeNonNegativeIntegerDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeIntegerDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeLongDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeIntDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeShortDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeByteDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeUnsignedLongDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeUnsignedIntDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeUnsignedShortDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeUnsignedByteDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeNormStringDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeTokenDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeLanguageDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeNameDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeQNameDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeNCNameDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeIdDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeIdrefDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeIdrefsDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeEntityDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeEntitiesDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeNotationDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeNmtokenDef = NULL;\n-static xmlSchemaTypePtr xmlSchemaTypeNmtokensDef = NULL;\n-\n-\/************************************************************************\n- *                                    *\n- *            Datatype error handlers                *\n- *                                    *\n- ************************************************************************\/\n-\/**\n- * xmlSchemaTypeErrMemory:\n- * @extra:  extra information\n- *\n- * Handle an out of memory condition\n- *\/\n-static void\n-xmlSchemaTypeErrMemory(void)\n-{\n-    xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_DATATYPE, NULL);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            Base types support                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlSchemaNewValue:\n- * @type:  the value type\n- *\n- * Allocate a new simple type value\n- *\n- * Returns a pointer to the new value or NULL in case of error\n- *\/\n-static xmlSchemaValPtr\n-xmlSchemaNewValue(xmlSchemaValType type) {\n-    xmlSchemaValPtr value;\n-\n-    value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));\n-    if (value == NULL) {\n-    return(NULL);\n-    }\n-    memset(value, 0, sizeof(xmlSchemaVal));\n-    value->type = type;\n-    return(value);\n-}\n-\n-static xmlSchemaFacetPtr\n-xmlSchemaNewMinLengthFacet(int value)\n-{\n-    xmlSchemaFacetPtr ret;\n-    size_t bufsize;\n-    xmlSchemaValDecimal *decimal;\n-\n-    ret = xmlSchemaNewFacet();\n-    if (ret == NULL) {\n-        return(NULL);\n-    }\n-    ret->type = XML_SCHEMA_FACET_MINLENGTH;\n-    ret->val = xmlSchemaNewValue(XML_SCHEMAS_NNINTEGER);\n-    if (ret->val == NULL) {\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n-    bufsize = snprintf(NULL, 0, \"%+d.0\", value) + 1;\n-    decimal = &ret->val->value.decimal;\n-    decimal->str = xmlMalloc(bufsize);\n-    if (decimal->str == NULL)\n-    {\n-        xmlSchemaFreeFacet(ret);\n-        return NULL;\n-    }\n-    snprintf((char *)decimal->str, bufsize, \"%+d.0\", value);\n-    decimal->integralPlaces = bufsize - 4;\n-    decimal->fractionalPlaces = 1;\n-    return (ret);\n-}\n-\n-\/*\n- * xmlSchemaInitBasicType:\n- * @name:  the type name\n- * @type:  the value type associated\n- *\n- * Initialize one primitive built-in type\n- *\/\n-static xmlSchemaTypePtr\n-xmlSchemaInitBasicType(const char *name, xmlSchemaValType type,\n-               xmlSchemaTypePtr baseType) {\n-    xmlSchemaTypePtr ret;\n-\n-    ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));\n-    if (ret == NULL) {\n-        xmlSchemaTypeErrMemory();\n-    return(NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaType));\n-    ret->name = (const xmlChar *)name;\n-    ret->targetNamespace = XML_SCHEMAS_NAMESPACE_NAME;\n-    ret->type = XML_SCHEMA_TYPE_BASIC;\n-    ret->baseType = baseType;\n-    ret->contentType = XML_SCHEMA_CONTENT_BASIC;\n-    \/*\n-    * Primitive types.\n-    *\/\n-    switch (type) {\n-    case XML_SCHEMAS_STRING:\n-    case XML_SCHEMAS_DECIMAL:\n-    case XML_SCHEMAS_DATE:\n-    case XML_SCHEMAS_DATETIME:\n-    case XML_SCHEMAS_TIME:\n-    case XML_SCHEMAS_GYEAR:\n-    case XML_SCHEMAS_GYEARMONTH:\n-    case XML_SCHEMAS_GMONTH:\n-    case XML_SCHEMAS_GMONTHDAY:\n-    case XML_SCHEMAS_GDAY:\n-    case XML_SCHEMAS_DURATION:\n-    case XML_SCHEMAS_FLOAT:\n-    case XML_SCHEMAS_DOUBLE:\n-    case XML_SCHEMAS_BOOLEAN:\n-    case XML_SCHEMAS_ANYURI:\n-    case XML_SCHEMAS_HEXBINARY:\n-    case XML_SCHEMAS_BASE64BINARY:\n-    case XML_SCHEMAS_QNAME:\n-    case XML_SCHEMAS_NOTATION:\n-        ret->flags |= XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE;\n-        break;\n-    default:\n-        break;\n-    }\n-    \/*\n-    * Set variety.\n-    *\/\n-    switch (type) {\n-    case XML_SCHEMAS_ANYTYPE:\n-    case XML_SCHEMAS_ANYSIMPLETYPE:\n-        break;\n-    case XML_SCHEMAS_IDREFS:\n-    case XML_SCHEMAS_NMTOKENS:\n-    case XML_SCHEMAS_ENTITIES:\n-        ret->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;\n-        ret->facets = xmlSchemaNewMinLengthFacet(1);\n-        ret->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;\n-        break;\n-    default:\n-        ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;\n-        break;\n-    }\n-    xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,\n-                 XML_SCHEMAS_NAMESPACE_NAME, ret);\n-    ret->builtInType = type;\n-    return(ret);\n-}\n-\n-static const xmlChar *\n-xmlSchemaValDecimalGetFractionalPart(const xmlSchemaValDecimal *decimal)\n-{\n-    \/* 2 = sign+dot *\/\n-    return decimal->str+2+decimal->integralPlaces;\n-}\n-\n-static int\n-xmlSchemaValDecimalIsInteger(const xmlSchemaValDecimal *decimal)\n-{\n-    return decimal->fractionalPlaces == 1 && xmlSchemaValDecimalGetFractionalPart(decimal)[0] == '0';\n-}\n-\n-static unsigned long\n-xmlSchemaValDecimalGetSignificantDigitCount(const xmlSchemaValDecimal *decimal)\n-{\n-    unsigned fractionalPlaces = xmlSchemaValDecimalIsInteger(decimal) ? 0 : decimal->fractionalPlaces;\n-    unsigned integralPlaces = decimal->integralPlaces;\n-    if(integralPlaces == 1 && decimal->str[1] == '0')\n-    {\n-        integralPlaces = 0;\n-    }\n-    if(integralPlaces+fractionalPlaces == 0)\n-    {\n-        \/* 0, but that's still 1 significant digit *\/\n-        return 1;\n-    }\n-    return integralPlaces+fractionalPlaces;\n-}\n-\n-\/**\n- * @brief Compares two decimals\n- *\n- * @param lhs\n- * @param rhs\n- * @return positive value if lhs > rhs, negative if lhs < rhs, or 0 if lhs == rhs\n- *\/\n-static int xmlSchemaValDecimalCompare(const xmlSchemaValDecimal *lhs, const xmlSchemaValDecimal *rhs)\n-{\n-    int sign = 1;\n-    \/* may be +0 and -0 for some reason, handle *\/\n-    if(strcmp((const char*)lhs->str+1, \"0.0\") == 0 &&\n-        strcmp((const char*)rhs->str+1, \"0.0\") == 0)\n-    {\n-        return 0;\n-    }\n-    \/* first take care of sign *\/\n-    if(lhs->str[0] != rhs->str[0])\n-    {\n-        \/* ASCII- > ASCII+ *\/\n-        return rhs->str[0]-lhs->str[0];\n-    }\n-    \/* signs are equal, but if negative the comparison must be reversed *\/\n-    if(lhs->str[0] == '-')\n-    {\n-        sign = -1;\n-    }\n-    \/* internal representation never contains leading zeroes, longer decimal representation = larger number *\/\n-    if(lhs->integralPlaces != rhs->integralPlaces)\n-    {\n-        return ((int)lhs->integralPlaces-(int)rhs->integralPlaces)*sign;\n-    }\n-    \/* same length, only digits => lexicographical sorting == numerical sorting.\n-       If integral parts are equal it will compare compare fractional parts. Again, lexicographical is good enough,\n-       length doesn't matter. We'll be starting from 0.1, always comparing like to like, and NULL < '0'\n-       If one is shorter and is equal until end, it must be smaller, since there are no trailing zeroes\n-       and the longer number must therefore have at least one non-zero digit after the other has ended.\n-       +1 to skip the sign\n-    *\/\n-    return strcmp((const char*)lhs->str+1, (const char*)rhs->str+1)*sign;\n-}\n-\n-static int xmlSchemaValDecimalCompareWithInteger(const xmlSchemaValDecimal *lhs, long rhs)\n-{\n-    \/* can handle integers up to 128 bits, should be good for a while *\/\n-    char buf[43];\n-    xmlSchemaValDecimal tmpVal;\n-    \/* 3 = sign+dot+0+NULL *\/\n-    tmpVal.integralPlaces = snprintf(buf, sizeof(buf), \"%+ld.0\", rhs)-3;\n-    tmpVal.str = (xmlChar*)buf;\n-    tmpVal.fractionalPlaces = 1;\n-    return xmlSchemaValDecimalCompare(lhs, &tmpVal);\n-}\n-\n-\/*\n-* WARNING: Those type reside normally in xmlschemas.c but are\n-* redefined here locally in oder of being able to use them for xs:anyType-\n-* TODO: Remove those definition if we move the types to a header file.\n-* TODO: Always keep those structs up-to-date with the originals.\n-*\/\n-#define UNBOUNDED (1 << 30)\n-\n-typedef struct _xmlSchemaTreeItem xmlSchemaTreeItem;\n-typedef xmlSchemaTreeItem *xmlSchemaTreeItemPtr;\n-struct _xmlSchemaTreeItem {\n-    xmlSchemaTypeType type;\n-    xmlSchemaAnnotPtr annot;\n-    xmlSchemaTreeItemPtr next;\n-    xmlSchemaTreeItemPtr children;\n-};\n-\n-typedef struct _xmlSchemaParticle xmlSchemaParticle;\n-typedef xmlSchemaParticle *xmlSchemaParticlePtr;\n-struct _xmlSchemaParticle {\n-    xmlSchemaTypeType type;\n-    xmlSchemaAnnotPtr annot;\n-    xmlSchemaTreeItemPtr next;\n-    xmlSchemaTreeItemPtr children;\n-    int minOccurs;\n-    int maxOccurs;\n-    xmlNodePtr node;\n-};\n-\n-typedef struct _xmlSchemaModelGroup xmlSchemaModelGroup;\n-typedef xmlSchemaModelGroup *xmlSchemaModelGroupPtr;\n-struct _xmlSchemaModelGroup {\n-    xmlSchemaTypeType type;\n-    xmlSchemaAnnotPtr annot;\n-    xmlSchemaTreeItemPtr next;\n-    xmlSchemaTreeItemPtr children;\n-    xmlNodePtr node;\n-};\n-\n-static xmlSchemaParticlePtr\n-xmlSchemaAddParticle(void)\n-{\n-    xmlSchemaParticlePtr ret = NULL;\n-\n-    ret = (xmlSchemaParticlePtr)\n-    xmlMalloc(sizeof(xmlSchemaParticle));\n-    if (ret == NULL) {\n-    xmlSchemaTypeErrMemory();\n-    return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchemaParticle));\n-    ret->type = XML_SCHEMA_TYPE_PARTICLE;\n-    ret->minOccurs = 1;\n-    ret->maxOccurs = 1;\n-    return (ret);\n-}\n-\n-static void\n-xmlSchemaFreeTypeEntry(void *type, const xmlChar *name ATTRIBUTE_UNUSED) {\n-    xmlSchemaFreeType((xmlSchemaTypePtr) type);\n-}\n-\n-\/**\n- * xmlSchemaCleanupTypesInternal:\n- *\n- * Cleanup the default XML Schemas type library\n- *\/\n-static void\n-xmlSchemaCleanupTypesInternal(void) {\n-    xmlSchemaParticlePtr particle;\n-\n-    \/*\n-    * Free xs:anyType.\n-    *\/\n-    if (xmlSchemaTypeAnyTypeDef != NULL) {\n-        \/* Attribute wildcard. *\/\n-        xmlSchemaFreeWildcard(xmlSchemaTypeAnyTypeDef->attributeWildcard);\n-        \/* Content type. *\/\n-        particle = (xmlSchemaParticlePtr) xmlSchemaTypeAnyTypeDef->subtypes;\n-        \/* Wildcard. *\/\n-        xmlSchemaFreeWildcard((xmlSchemaWildcardPtr)\n-            particle->children->children->children);\n-        xmlFree((xmlSchemaParticlePtr) particle->children->children);\n-        \/* Sequence model group. *\/\n-        xmlFree((xmlSchemaModelGroupPtr) particle->children);\n-        xmlFree((xmlSchemaParticlePtr) particle);\n-        xmlSchemaTypeAnyTypeDef->subtypes = NULL;\n-        xmlSchemaTypeAnyTypeDef = NULL;\n-    }\n-\n-    xmlHashFree(xmlSchemaTypesBank, xmlSchemaFreeTypeEntry);\n-    xmlSchemaTypesBank = NULL;\n-    \/* Note that the xmlSchemaType*Def pointers aren't set to NULL. *\/\n-}\n-\n-\/*\n- * xmlSchemaInitTypes:\n- *\n- * Initialize the default XML Schemas type library\n- *\n- * Returns 0 on success, -1 on error.\n- *\/\n-int\n-xmlSchemaInitTypes(void)\n-{\n-    if (xmlSchemaTypesInitialized != 0)\n-        return (0);\n-    xmlSchemaTypesBank = xmlHashCreate(40);\n-    if (xmlSchemaTypesBank == NULL) {\n-    xmlSchemaTypeErrMemory();\n-        goto error;\n-    }\n-\n-    \/*\n-    * 3.4.7 Built-in Complex Type Definition\n-    *\/\n-    xmlSchemaTypeAnyTypeDef = xmlSchemaInitBasicType(\"anyType\",\n-                                                     XML_SCHEMAS_ANYTYPE,\n-                             NULL);\n-    if (xmlSchemaTypeAnyTypeDef == NULL)\n-        goto error;\n-    xmlSchemaTypeAnyTypeDef->baseType = xmlSchemaTypeAnyTypeDef;\n-    xmlSchemaTypeAnyTypeDef->contentType = XML_SCHEMA_CONTENT_MIXED;\n-    \/*\n-    * Init the content type.\n-    *\/\n-    xmlSchemaTypeAnyTypeDef->contentType = XML_SCHEMA_CONTENT_MIXED;\n-    {\n-    xmlSchemaParticlePtr particle;\n-    xmlSchemaModelGroupPtr sequence;\n-    xmlSchemaWildcardPtr wild;\n-    \/* First particle. *\/\n-    particle = xmlSchemaAddParticle();\n-    if (particle == NULL)\n-        goto error;\n-    xmlSchemaTypeAnyTypeDef->subtypes = (xmlSchemaTypePtr) particle;\n-    \/* Sequence model group. *\/\n-    sequence = (xmlSchemaModelGroupPtr)\n-        xmlMalloc(sizeof(xmlSchemaModelGroup));\n-    if (sequence == NULL) {\n-        xmlSchemaTypeErrMemory();\n-        goto error;\n-    }\n-    memset(sequence, 0, sizeof(xmlSchemaModelGroup));\n-    sequence->type = XML_SCHEMA_TYPE_SEQUENCE;\n-    particle->children = (xmlSchemaTreeItemPtr) sequence;\n-    \/* Second particle. *\/\n-    particle = xmlSchemaAddParticle();\n-    if (particle == NULL)\n-        goto error;\n-    particle->minOccurs = 0;\n-    particle->maxOccurs = UNBOUNDED;\n-    sequence->children = (xmlSchemaTreeItemPtr) particle;\n-    \/* The wildcard *\/\n-    wild = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));\n-    if (wild == NULL) {\n-        xmlSchemaTypeErrMemory();\n-        goto error;\n-    }\n-    memset(wild, 0, sizeof(xmlSchemaWildcard));\n-    wild->type = XML_SCHEMA_TYPE_ANY;\n-    wild->any = 1;\n-    wild->processContents = XML_SCHEMAS_ANY_LAX;\n-    particle->children = (xmlSchemaTreeItemPtr) wild;\n-    \/*\n-    * Create the attribute wildcard.\n-    *\/\n-    wild = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));\n-    if (wild == NULL) {\n-        xmlSchemaTypeErrMemory();\n-        goto error;\n-    }\n-    memset(wild, 0, sizeof(xmlSchemaWildcard));\n-    wild->any = 1;\n-    wild->processContents = XML_SCHEMAS_ANY_LAX;\n-    xmlSchemaTypeAnyTypeDef->attributeWildcard = wild;\n-    }\n-    xmlSchemaTypeAnySimpleTypeDef = xmlSchemaInitBasicType(\"anySimpleType\",\n-                                                           XML_SCHEMAS_ANYSIMPLETYPE,\n-                               xmlSchemaTypeAnyTypeDef);\n-    if (xmlSchemaTypeAnySimpleTypeDef == NULL)\n-        goto error;\n-    \/*\n-    * primitive datatypes\n-    *\/\n-    xmlSchemaTypeStringDef = xmlSchemaInitBasicType(\"string\",\n-                                                    XML_SCHEMAS_STRING,\n-                            xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeStringDef == NULL)\n-        goto error;\n-    xmlSchemaTypeDecimalDef = xmlSchemaInitBasicType(\"decimal\",\n-                                                     XML_SCHEMAS_DECIMAL,\n-                             xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeDecimalDef == NULL)\n-        goto error;\n-    xmlSchemaTypeDateDef = xmlSchemaInitBasicType(\"date\",\n-                                                  XML_SCHEMAS_DATE,\n-                          xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeDateDef == NULL)\n-        goto error;\n-    xmlSchemaTypeDatetimeDef = xmlSchemaInitBasicType(\"dateTime\",\n-                                                      XML_SCHEMAS_DATETIME,\n-                              xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeDatetimeDef == NULL)\n-        goto error;\n-    xmlSchemaTypeTimeDef = xmlSchemaInitBasicType(\"time\",\n-                                                  XML_SCHEMAS_TIME,\n-                          xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeTimeDef == NULL)\n-        goto error;\n-    xmlSchemaTypeGYearDef = xmlSchemaInitBasicType(\"gYear\",\n-                                                   XML_SCHEMAS_GYEAR,\n-                           xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeGYearDef == NULL)\n-        goto error;\n-    xmlSchemaTypeGYearMonthDef = xmlSchemaInitBasicType(\"gYearMonth\",\n-                                                        XML_SCHEMAS_GYEARMONTH,\n-                            xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeGYearMonthDef == NULL)\n-        goto error;\n-    xmlSchemaTypeGMonthDef = xmlSchemaInitBasicType(\"gMonth\",\n-                                                    XML_SCHEMAS_GMONTH,\n-                            xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeGMonthDef == NULL)\n-        goto error;\n-    xmlSchemaTypeGMonthDayDef = xmlSchemaInitBasicType(\"gMonthDay\",\n-                                                       XML_SCHEMAS_GMONTHDAY,\n-                               xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeGMonthDayDef == NULL)\n-        goto error;\n-    xmlSchemaTypeGDayDef = xmlSchemaInitBasicType(\"gDay\",\n-                                                  XML_SCHEMAS_GDAY,\n-                          xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeGDayDef == NULL)\n-        goto error;\n-    xmlSchemaTypeDurationDef = xmlSchemaInitBasicType(\"duration\",\n-                                                      XML_SCHEMAS_DURATION,\n-                              xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeDurationDef == NULL)\n-        goto error;\n-    xmlSchemaTypeFloatDef = xmlSchemaInitBasicType(\"float\",\n-                                                   XML_SCHEMAS_FLOAT,\n-                           xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeFloatDef == NULL)\n-        goto error;\n-    xmlSchemaTypeDoubleDef = xmlSchemaInitBasicType(\"double\",\n-                                                    XML_SCHEMAS_DOUBLE,\n-                            xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeDoubleDef == NULL)\n-        goto error;\n-    xmlSchemaTypeBooleanDef = xmlSchemaInitBasicType(\"boolean\",\n-                                                     XML_SCHEMAS_BOOLEAN,\n-                             xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeBooleanDef == NULL)\n-        goto error;\n-    xmlSchemaTypeAnyURIDef = xmlSchemaInitBasicType(\"anyURI\",\n-                                                    XML_SCHEMAS_ANYURI,\n-                            xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeAnyURIDef == NULL)\n-        goto error;\n-    xmlSchemaTypeHexBinaryDef = xmlSchemaInitBasicType(\"hexBinary\",\n-                                                     XML_SCHEMAS_HEXBINARY,\n-                             xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeHexBinaryDef == NULL)\n-        goto error;\n-    xmlSchemaTypeBase64BinaryDef\n-        = xmlSchemaInitBasicType(\"base64Binary\", XML_SCHEMAS_BASE64BINARY,\n-    xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeBase64BinaryDef == NULL)\n-        goto error;\n-    xmlSchemaTypeNotationDef = xmlSchemaInitBasicType(\"NOTATION\",\n-                                                    XML_SCHEMAS_NOTATION,\n-                            xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeNotationDef == NULL)\n-        goto error;\n-    xmlSchemaTypeQNameDef = xmlSchemaInitBasicType(\"QName\",\n-                                                   XML_SCHEMAS_QNAME,\n-                           xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeQNameDef == NULL)\n-        goto error;\n-\n-    \/*\n-     * derived datatypes\n-     *\/\n-    xmlSchemaTypeIntegerDef = xmlSchemaInitBasicType(\"integer\",\n-                                                     XML_SCHEMAS_INTEGER,\n-                             xmlSchemaTypeDecimalDef);\n-    if (xmlSchemaTypeIntegerDef == NULL)\n-        goto error;\n-    xmlSchemaTypeNonPositiveIntegerDef =\n-        xmlSchemaInitBasicType(\"nonPositiveInteger\",\n-                               XML_SCHEMAS_NPINTEGER,\n-                   xmlSchemaTypeIntegerDef);\n-    if (xmlSchemaTypeNonPositiveIntegerDef == NULL)\n-        goto error;\n-    xmlSchemaTypeNegativeIntegerDef =\n-        xmlSchemaInitBasicType(\"negativeInteger\", XML_SCHEMAS_NINTEGER,\n-    xmlSchemaTypeNonPositiveIntegerDef);\n-    if (xmlSchemaTypeNegativeIntegerDef == NULL)\n-        goto error;\n-    xmlSchemaTypeLongDef =\n-        xmlSchemaInitBasicType(\"long\", XML_SCHEMAS_LONG,\n-    xmlSchemaTypeIntegerDef);\n-    if (xmlSchemaTypeLongDef == NULL)\n-        goto error;\n-    xmlSchemaTypeIntDef = xmlSchemaInitBasicType(\"int\", XML_SCHEMAS_INT,\n-    xmlSchemaTypeLongDef);\n-    if (xmlSchemaTypeIntDef == NULL)\n-        goto error;\n-    xmlSchemaTypeShortDef = xmlSchemaInitBasicType(\"short\",\n-                                                   XML_SCHEMAS_SHORT,\n-                           xmlSchemaTypeIntDef);\n-    if (xmlSchemaTypeShortDef == NULL)\n-        goto error;\n-    xmlSchemaTypeByteDef = xmlSchemaInitBasicType(\"byte\",\n-                                                  XML_SCHEMAS_BYTE,\n-                          xmlSchemaTypeShortDef);\n-    if (xmlSchemaTypeByteDef == NULL)\n-        goto error;\n-    xmlSchemaTypeNonNegativeIntegerDef =\n-        xmlSchemaInitBasicType(\"nonNegativeInteger\",\n-                               XML_SCHEMAS_NNINTEGER,\n-                   xmlSchemaTypeIntegerDef);\n-    if (xmlSchemaTypeNonNegativeIntegerDef == NULL)\n-        goto error;\n-    xmlSchemaTypeUnsignedLongDef =\n-        xmlSchemaInitBasicType(\"unsignedLong\", XML_SCHEMAS_ULONG,\n-    xmlSchemaTypeNonNegativeIntegerDef);\n-    if (xmlSchemaTypeUnsignedLongDef == NULL)\n-        goto error;\n-    xmlSchemaTypeUnsignedIntDef =\n-        xmlSchemaInitBasicType(\"unsignedInt\", XML_SCHEMAS_UINT,\n-    xmlSchemaTypeUnsignedLongDef);\n-    if (xmlSchemaTypeUnsignedIntDef == NULL)\n-        goto error;\n-    xmlSchemaTypeUnsignedShortDef =\n-        xmlSchemaInitBasicType(\"unsignedShort\", XML_SCHEMAS_USHORT,\n-    xmlSchemaTypeUnsignedIntDef);\n-    if (xmlSchemaTypeUnsignedShortDef == NULL)\n-        goto error;\n-    xmlSchemaTypeUnsignedByteDef =\n-        xmlSchemaInitBasicType(\"unsignedByte\", XML_SCHEMAS_UBYTE,\n-    xmlSchemaTypeUnsignedShortDef);\n-    if (xmlSchemaTypeUnsignedByteDef == NULL)\n-        goto error;\n-    xmlSchemaTypePositiveIntegerDef =\n-        xmlSchemaInitBasicType(\"positiveInteger\", XML_SCHEMAS_PINTEGER,\n-    xmlSchemaTypeNonNegativeIntegerDef);\n-    if (xmlSchemaTypePositiveIntegerDef == NULL)\n-        goto error;\n-    xmlSchemaTypeNormStringDef = xmlSchemaInitBasicType(\"normalizedString\",\n-                                                        XML_SCHEMAS_NORMSTRING,\n-                            xmlSchemaTypeStringDef);\n-    if (xmlSchemaTypeNormStringDef == NULL)\n-        goto error;\n-    xmlSchemaTypeTokenDef = xmlSchemaInitBasicType(\"token\",\n-                                                   XML_SCHEMAS_TOKEN,\n-                           xmlSchemaTypeNormStringDef);\n-    if (xmlSchemaTypeTokenDef == NULL)\n-        goto error;\n-    xmlSchemaTypeLanguageDef = xmlSchemaInitBasicType(\"language\",\n-                                                      XML_SCHEMAS_LANGUAGE,\n-                              xmlSchemaTypeTokenDef);\n-    if (xmlSchemaTypeLanguageDef == NULL)\n-        goto error;\n-    xmlSchemaTypeNameDef = xmlSchemaInitBasicType(\"Name\",\n-                                                  XML_SCHEMAS_NAME,\n-                          xmlSchemaTypeTokenDef);\n-    if (xmlSchemaTypeNameDef == NULL)\n-        goto error;\n-    xmlSchemaTypeNmtokenDef = xmlSchemaInitBasicType(\"NMTOKEN\",\n-                                                     XML_SCHEMAS_NMTOKEN,\n-                             xmlSchemaTypeTokenDef);\n-    if (xmlSchemaTypeNmtokenDef == NULL)\n-        goto error;\n-    xmlSchemaTypeNCNameDef = xmlSchemaInitBasicType(\"NCName\",\n-                                                    XML_SCHEMAS_NCNAME,\n-                            xmlSchemaTypeNameDef);\n-    if (xmlSchemaTypeNCNameDef == NULL)\n-        goto error;\n-    xmlSchemaTypeIdDef = xmlSchemaInitBasicType(\"ID\", XML_SCHEMAS_ID,\n-                            xmlSchemaTypeNCNameDef);\n-    if (xmlSchemaTypeIdDef == NULL)\n-        goto error;\n-    xmlSchemaTypeIdrefDef = xmlSchemaInitBasicType(\"IDREF\",\n-                                                   XML_SCHEMAS_IDREF,\n-                           xmlSchemaTypeNCNameDef);\n-    if (xmlSchemaTypeIdrefDef == NULL)\n-        goto error;\n-    xmlSchemaTypeEntityDef = xmlSchemaInitBasicType(\"ENTITY\",\n-                                                    XML_SCHEMAS_ENTITY,\n-                            xmlSchemaTypeNCNameDef);\n-    if (xmlSchemaTypeEntityDef == NULL)\n-        goto error;\n-    \/*\n-    * Derived list types.\n-    *\/\n-    \/* ENTITIES *\/\n-    xmlSchemaTypeEntitiesDef = xmlSchemaInitBasicType(\"ENTITIES\",\n-                                                      XML_SCHEMAS_ENTITIES,\n-                              xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeEntitiesDef == NULL)\n-        goto error;\n-    xmlSchemaTypeEntitiesDef->subtypes = xmlSchemaTypeEntityDef;\n-    \/* IDREFS *\/\n-    xmlSchemaTypeIdrefsDef = xmlSchemaInitBasicType(\"IDREFS\",\n-                                                    XML_SCHEMAS_IDREFS,\n-                            xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeIdrefsDef == NULL)\n-        goto error;\n-    xmlSchemaTypeIdrefsDef->subtypes = xmlSchemaTypeIdrefDef;\n-\n-    \/* NMTOKENS *\/\n-    xmlSchemaTypeNmtokensDef = xmlSchemaInitBasicType(\"NMTOKENS\",\n-                                                      XML_SCHEMAS_NMTOKENS,\n-                              xmlSchemaTypeAnySimpleTypeDef);\n-    if (xmlSchemaTypeNmtokensDef == NULL)\n-        goto error;\n-    xmlSchemaTypeNmtokensDef->subtypes = xmlSchemaTypeNmtokenDef;\n-\n-    xmlSchemaTypesInitialized = 1;\n-    return (0);\n-\n-error:\n-    xmlSchemaCleanupTypesInternal();\n-    return (-1);\n-}\n-\n-\/**\n- * xmlSchemaCleanupTypes:\n- *\n- * DEPRECATED: This function will be made private. Call xmlCleanupParser\n- * to free global state but see the warnings there. xmlCleanupParser\n- * should be only called once at program exit. In most cases, you don't\n- * have to call cleanup functions at all.\n- *\n- * Cleanup the default XML Schemas type library\n- *\/\n-void\n-xmlSchemaCleanupTypes(void) {\n-    if (xmlSchemaTypesInitialized != 0) {\n-        xmlSchemaCleanupTypesInternal();\n-        xmlSchemaTypesInitialized = 0;\n-    }\n-}\n-\n-\/**\n- * xmlSchemaIsBuiltInTypeFacet:\n- * @type: the built-in type\n- * @facetType:  the facet type\n- *\n- * Evaluates if a specific facet can be\n- * used in conjunction with a type.\n- *\n- * Returns 1 if the facet can be used with the given built-in type,\n- * 0 otherwise and -1 in case the type is not a built-in type.\n- *\/\n-int\n-xmlSchemaIsBuiltInTypeFacet(xmlSchemaTypePtr type, int facetType)\n-{\n-    if (type == NULL)\n-    return (-1);\n-    if (type->type != XML_SCHEMA_TYPE_BASIC)\n-    return (-1);\n-    switch (type->builtInType) {\n-    case XML_SCHEMAS_BOOLEAN:\n-        if ((facetType == XML_SCHEMA_FACET_PATTERN) ||\n-        (facetType == XML_SCHEMA_FACET_WHITESPACE))\n-        return (1);\n-        else\n-        return (0);\n-    case XML_SCHEMAS_STRING:\n-    case XML_SCHEMAS_NOTATION:\n-    case XML_SCHEMAS_QNAME:\n-    case XML_SCHEMAS_ANYURI:\n-    case XML_SCHEMAS_BASE64BINARY:\n-    case XML_SCHEMAS_HEXBINARY:\n-        if ((facetType == XML_SCHEMA_FACET_LENGTH) ||\n-        (facetType == XML_SCHEMA_FACET_MINLENGTH) ||\n-        (facetType == XML_SCHEMA_FACET_MAXLENGTH) ||\n-        (facetType == XML_SCHEMA_FACET_PATTERN) ||\n-        (facetType == XML_SCHEMA_FACET_ENUMERATION) ||\n-        (facetType == XML_SCHEMA_FACET_WHITESPACE))\n-        return (1);\n-        else\n-        return (0);\n-    case XML_SCHEMAS_DECIMAL:\n-        if ((facetType == XML_SCHEMA_FACET_TOTALDIGITS) ||\n-        (facetType == XML_SCHEMA_FACET_FRACTIONDIGITS) ||\n-        (facetType == XML_SCHEMA_FACET_PATTERN) ||\n-        (facetType == XML_SCHEMA_FACET_WHITESPACE) ||\n-        (facetType == XML_SCHEMA_FACET_ENUMERATION) ||\n-        (facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) ||\n-        (facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) ||\n-        (facetType == XML_SCHEMA_FACET_MININCLUSIVE) ||\n-        (facetType == XML_SCHEMA_FACET_MINEXCLUSIVE))\n-        return (1);\n-        else\n-        return (0);\n-    case XML_SCHEMAS_TIME:\n-    case XML_SCHEMAS_GDAY:\n-    case XML_SCHEMAS_GMONTH:\n-    case XML_SCHEMAS_GMONTHDAY:\n-    case XML_SCHEMAS_GYEAR:\n-    case XML_SCHEMAS_GYEARMONTH:\n-    case XML_SCHEMAS_DATE:\n-    case XML_SCHEMAS_DATETIME:\n-    case XML_SCHEMAS_DURATION:\n-    case XML_SCHEMAS_FLOAT:\n-    case XML_SCHEMAS_DOUBLE:\n-        if ((facetType == XML_SCHEMA_FACET_PATTERN) ||\n-        (facetType == XML_SCHEMA_FACET_ENUMERATION) ||\n-        (facetType == XML_SCHEMA_FACET_WHITESPACE) ||\n-        (facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) ||\n-        (facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) ||\n-        (facetType == XML_SCHEMA_FACET_MININCLUSIVE) ||\n-        (facetType == XML_SCHEMA_FACET_MINEXCLUSIVE))\n-        return (1);\n-        else\n-        return (0);\n-    default:\n-        break;\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaGetBuiltInType:\n- * @type:  the type of the built in type\n- *\n- * Gives you the type struct for a built-in\n- * type by its type id.\n- *\n- * Returns the type if found, NULL otherwise.\n- *\/\n-xmlSchemaTypePtr\n-xmlSchemaGetBuiltInType(xmlSchemaValType type)\n-{\n-    if ((xmlSchemaTypesInitialized == 0) &&\n-    (xmlSchemaInitTypes() < 0))\n-        return (NULL);\n-    switch (type) {\n-\n-    case XML_SCHEMAS_ANYSIMPLETYPE:\n-        return (xmlSchemaTypeAnySimpleTypeDef);\n-    case XML_SCHEMAS_STRING:\n-        return (xmlSchemaTypeStringDef);\n-    case XML_SCHEMAS_NORMSTRING:\n-        return (xmlSchemaTypeNormStringDef);\n-    case XML_SCHEMAS_DECIMAL:\n-        return (xmlSchemaTypeDecimalDef);\n-    case XML_SCHEMAS_TIME:\n-        return (xmlSchemaTypeTimeDef);\n-    case XML_SCHEMAS_GDAY:\n-        return (xmlSchemaTypeGDayDef);\n-    case XML_SCHEMAS_GMONTH:\n-        return (xmlSchemaTypeGMonthDef);\n-    case XML_SCHEMAS_GMONTHDAY:\n-        return (xmlSchemaTypeGMonthDayDef);\n-    case XML_SCHEMAS_GYEAR:\n-        return (xmlSchemaTypeGYearDef);\n-    case XML_SCHEMAS_GYEARMONTH:\n-        return (xmlSchemaTypeGYearMonthDef);\n-    case XML_SCHEMAS_DATE:\n-        return (xmlSchemaTypeDateDef);\n-    case XML_SCHEMAS_DATETIME:\n-        return (xmlSchemaTypeDatetimeDef);\n-    case XML_SCHEMAS_DURATION:\n-        return (xmlSchemaTypeDurationDef);\n-    case XML_SCHEMAS_FLOAT:\n-        return (xmlSchemaTypeFloatDef);\n-    case XML_SCHEMAS_DOUBLE:\n-        return (xmlSchemaTypeDoubleDef);\n-    case XML_SCHEMAS_BOOLEAN:\n-        return (xmlSchemaTypeBooleanDef);\n-    case XML_SCHEMAS_TOKEN:\n-        return (xmlSchemaTypeTokenDef);\n-    case XML_SCHEMAS_LANGUAGE:\n-        return (xmlSchemaTypeLanguageDef);\n-    case XML_SCHEMAS_NMTOKEN:\n-        return (xmlSchemaTypeNmtokenDef);\n-    case XML_SCHEMAS_NMTOKENS:\n-        return (xmlSchemaTypeNmtokensDef);\n-    case XML_SCHEMAS_NAME:\n-        return (xmlSchemaTypeNameDef);\n-    case XML_SCHEMAS_QNAME:\n-        return (xmlSchemaTypeQNameDef);\n-    case XML_SCHEMAS_NCNAME:\n-        return (xmlSchemaTypeNCNameDef);\n-    case XML_SCHEMAS_ID:\n-        return (xmlSchemaTypeIdDef);\n-    case XML_SCHEMAS_IDREF:\n-        return (xmlSchemaTypeIdrefDef);\n-    case XML_SCHEMAS_IDREFS:\n-        return (xmlSchemaTypeIdrefsDef);\n-    case XML_SCHEMAS_ENTITY:\n-        return (xmlSchemaTypeEntityDef);\n-    case XML_SCHEMAS_ENTITIES:\n-        return (xmlSchemaTypeEntitiesDef);\n-    case XML_SCHEMAS_NOTATION:\n-        return (xmlSchemaTypeNotationDef);\n-    case XML_SCHEMAS_ANYURI:\n-        return (xmlSchemaTypeAnyURIDef);\n-    case XML_SCHEMAS_INTEGER:\n-        return (xmlSchemaTypeIntegerDef);\n-    case XML_SCHEMAS_NPINTEGER:\n-        return (xmlSchemaTypeNonPositiveIntegerDef);\n-    case XML_SCHEMAS_NINTEGER:\n-        return (xmlSchemaTypeNegativeIntegerDef);\n-    case XML_SCHEMAS_NNINTEGER:\n-        return (xmlSchemaTypeNonNegativeIntegerDef);\n-    case XML_SCHEMAS_PINTEGER:\n-        return (xmlSchemaTypePositiveIntegerDef);\n-    case XML_SCHEMAS_INT:\n-        return (xmlSchemaTypeIntDef);\n-    case XML_SCHEMAS_UINT:\n-        return (xmlSchemaTypeUnsignedIntDef);\n-    case XML_SCHEMAS_LONG:\n-        return (xmlSchemaTypeLongDef);\n-    case XML_SCHEMAS_ULONG:\n-        return (xmlSchemaTypeUnsignedLongDef);\n-    case XML_SCHEMAS_SHORT:\n-        return (xmlSchemaTypeShortDef);\n-    case XML_SCHEMAS_USHORT:\n-        return (xmlSchemaTypeUnsignedShortDef);\n-    case XML_SCHEMAS_BYTE:\n-        return (xmlSchemaTypeByteDef);\n-    case XML_SCHEMAS_UBYTE:\n-        return (xmlSchemaTypeUnsignedByteDef);\n-    case XML_SCHEMAS_HEXBINARY:\n-        return (xmlSchemaTypeHexBinaryDef);\n-    case XML_SCHEMAS_BASE64BINARY:\n-        return (xmlSchemaTypeBase64BinaryDef);\n-    case XML_SCHEMAS_ANYTYPE:\n-        return (xmlSchemaTypeAnyTypeDef);\n-    default:\n-        return (NULL);\n-    }\n-}\n-\n-\/**\n- * xmlSchemaValueAppend:\n- * @prev: the value\n- * @cur: the value to be appended\n- *\n- * Appends a next sibling to a list of computed values.\n- *\n- * Returns 0 if succeeded and -1 on API errors.\n- *\/\n-int\n-xmlSchemaValueAppend(xmlSchemaValPtr prev, xmlSchemaValPtr cur) {\n-\n-    if ((prev == NULL) || (cur == NULL))\n-    return (-1);\n-    prev->next = cur;\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaValueGetNext:\n- * @cur: the value\n- *\n- * Accessor for the next sibling of a list of computed values.\n- *\n- * Returns the next value or NULL if there was none, or on\n- *         API errors.\n- *\/\n-xmlSchemaValPtr\n-xmlSchemaValueGetNext(xmlSchemaValPtr cur) {\n-\n-    if (cur == NULL)\n-    return (NULL);\n-    return (cur->next);\n-}\n-\n-\/**\n- * xmlSchemaValueGetAsString:\n- * @val: the value\n- *\n- * Accessor for the string value of a computed value.\n- *\n- * Returns the string value or NULL if there was none, or on\n- *         API errors.\n- *\/\n-const xmlChar *\n-xmlSchemaValueGetAsString(xmlSchemaValPtr val)\n-{\n-    if (val == NULL)\n-    return (NULL);\n-    switch (val->type) {\n-    case XML_SCHEMAS_STRING:\n-    case XML_SCHEMAS_NORMSTRING:\n-    case XML_SCHEMAS_ANYSIMPLETYPE:\n-    case XML_SCHEMAS_TOKEN:\n-        case XML_SCHEMAS_LANGUAGE:\n-        case XML_SCHEMAS_NMTOKEN:\n-        case XML_SCHEMAS_NAME:\n-        case XML_SCHEMAS_NCNAME:\n-        case XML_SCHEMAS_ID:\n-        case XML_SCHEMAS_IDREF:\n-        case XML_SCHEMAS_ENTITY:\n-        case XML_SCHEMAS_ANYURI:\n-        return (BAD_CAST val->value.str);\n-    default:\n-        break;\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlSchemaValueGetAsBoolean:\n- * @val: the value\n- *\n- * Accessor for the boolean value of a computed value.\n- *\n- * Returns 1 if true and 0 if false, or in case of an error. Hmm.\n- *\/\n-int\n-xmlSchemaValueGetAsBoolean(xmlSchemaValPtr val)\n-{\n-    if ((val == NULL) || (val->type != XML_SCHEMAS_BOOLEAN))\n-    return (0);\n-    return (val->value.b);\n-}\n-\n-\/**\n- * xmlSchemaNewStringValue:\n- * @type:  the value type\n- * @value:  the value\n- *\n- * Allocate a new simple type value. The type can be\n- * of XML_SCHEMAS_STRING.\n- * WARNING: This one is intended to be expanded for other\n- * string based types. We need this for anySimpleType as well.\n- * The given value is consumed and freed with the struct.\n- *\n- * Returns a pointer to the new value or NULL in case of error\n- *\/\n-xmlSchemaValPtr\n-xmlSchemaNewStringValue(xmlSchemaValType type,\n-            const xmlChar *value)\n-{\n-    xmlSchemaValPtr val;\n-\n-    if (type != XML_SCHEMAS_STRING)\n-    return(NULL);\n-    val = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));\n-    if (val == NULL) {\n-    return(NULL);\n-    }\n-    memset(val, 0, sizeof(xmlSchemaVal));\n-    val->type = type;\n-    val->value.str = (xmlChar *) value;\n-    return(val);\n-}\n-\n-\/**\n- * xmlSchemaNewNOTATIONValue:\n- * @name:  the notation name\n- * @ns: the notation namespace name or NULL\n- *\n- * Allocate a new NOTATION value.\n- * The given values are consumed and freed with the struct.\n- *\n- * Returns a pointer to the new value or NULL in case of error\n- *\/\n-xmlSchemaValPtr\n-xmlSchemaNewNOTATIONValue(const xmlChar *name,\n-              const xmlChar *ns)\n-{\n-    xmlSchemaValPtr val;\n-\n-    val = xmlSchemaNewValue(XML_SCHEMAS_NOTATION);\n-    if (val == NULL)\n-    return (NULL);\n-\n-    val->value.qname.name = (xmlChar *)name;\n-    if (ns != NULL)\n-    val->value.qname.uri = (xmlChar *)ns;\n-    return(val);\n-}\n-\n-\/**\n- * xmlSchemaNewQNameValue:\n- * @namespaceName: the namespace name\n- * @localName: the local name\n- *\n- * Allocate a new QName value.\n- * The given values are consumed and freed with the struct.\n- *\n- * Returns a pointer to the new value or NULL in case of an error.\n- *\/\n-xmlSchemaValPtr\n-xmlSchemaNewQNameValue(const xmlChar *namespaceName,\n-               const xmlChar *localName)\n-{\n-    xmlSchemaValPtr val;\n-\n-    val = xmlSchemaNewValue(XML_SCHEMAS_QNAME);\n-    if (val == NULL)\n-    return (NULL);\n-\n-    val->value.qname.name = (xmlChar *) localName;\n-    val->value.qname.uri = (xmlChar *) namespaceName;\n-    return(val);\n-}\n-\n-\/**\n- * xmlSchemaFreeValue:\n- * @value:  the value to free\n- *\n- * Cleanup the default XML Schemas type library\n- *\/\n-void\n-xmlSchemaFreeValue(xmlSchemaValPtr value) {\n-    xmlSchemaValPtr prev;\n-\n-    while (value != NULL) {\n-    switch (value->type) {\n-        case XML_SCHEMAS_STRING:\n-        case XML_SCHEMAS_NORMSTRING:\n-        case XML_SCHEMAS_TOKEN:\n-        case XML_SCHEMAS_LANGUAGE:\n-        case XML_SCHEMAS_NMTOKEN:\n-        case XML_SCHEMAS_NMTOKENS:\n-        case XML_SCHEMAS_NAME:\n-        case XML_SCHEMAS_NCNAME:\n-        case XML_SCHEMAS_ID:\n-        case XML_SCHEMAS_IDREF:\n-        case XML_SCHEMAS_IDREFS:\n-        case XML_SCHEMAS_ENTITY:\n-        case XML_SCHEMAS_ENTITIES:\n-        case XML_SCHEMAS_ANYURI:\n-        case XML_SCHEMAS_ANYSIMPLETYPE:\n-        if (value->value.str != NULL)\n-            xmlFree(value->value.str);\n-        break;\n-        case XML_SCHEMAS_NOTATION:\n-        case XML_SCHEMAS_QNAME:\n-        if (value->value.qname.uri != NULL)\n-            xmlFree(value->value.qname.uri);\n-        if (value->value.qname.name != NULL)\n-            xmlFree(value->value.qname.name);\n-        break;\n-        case XML_SCHEMAS_HEXBINARY:\n-        if (value->value.hex.str != NULL)\n-            xmlFree(value->value.hex.str);\n-        break;\n-        case XML_SCHEMAS_BASE64BINARY:\n-        if (value->value.base64.str != NULL)\n-            xmlFree(value->value.base64.str);\n-        break;\n-        case XML_SCHEMAS_DECIMAL:\n-        case XML_SCHEMAS_INTEGER:\n-        case XML_SCHEMAS_NNINTEGER:\n-        case XML_SCHEMAS_PINTEGER:\n-        case XML_SCHEMAS_NPINTEGER:\n-        case XML_SCHEMAS_NINTEGER:\n-        case XML_SCHEMAS_INT:\n-        case XML_SCHEMAS_UINT:\n-        case XML_SCHEMAS_LONG:\n-        case XML_SCHEMAS_ULONG:\n-        case XML_SCHEMAS_SHORT:\n-        case XML_SCHEMAS_USHORT:\n-        case XML_SCHEMAS_BYTE:\n-        case XML_SCHEMAS_UBYTE:\n-        if (value->value.decimal.str != NULL)\n-            xmlFree(value->value.decimal.str);\n-        break;\n-        default:\n-        break;\n-    }\n-    prev = value;\n-    value = value->next;\n-    xmlFree(prev);\n-    }\n-}\n-\n-\/**\n- * xmlSchemaGetPredefinedType:\n- * @name: the type name\n- * @ns:  the URI of the namespace usually \"http:\/\/www.w3.org\/2001\/XMLSchema\"\n- *\n- * Lookup a type in the default XML Schemas type library\n- *\n- * Returns the type if found, NULL otherwise\n- *\/\n-xmlSchemaTypePtr\n-xmlSchemaGetPredefinedType(const xmlChar *name, const xmlChar *ns) {\n-    if ((xmlSchemaTypesInitialized == 0) &&\n-    (xmlSchemaInitTypes() < 0))\n-        return (NULL);\n-    if (name == NULL)\n-    return(NULL);\n-    return((xmlSchemaTypePtr) xmlHashLookup2(xmlSchemaTypesBank, name, ns));\n-}\n-\n-\/**\n- * xmlSchemaGetBuiltInListSimpleTypeItemType:\n- * @type: the built-in simple type.\n- *\n- * Lookup function\n- *\n- * Returns the item type of @type as defined by the built-in datatype\n- * hierarchy of XML Schema Part 2: Datatypes, or NULL in case of an error.\n- *\/\n-xmlSchemaTypePtr\n-xmlSchemaGetBuiltInListSimpleTypeItemType(xmlSchemaTypePtr type)\n-{\n-    if ((type == NULL) || (type->type != XML_SCHEMA_TYPE_BASIC))\n-    return (NULL);\n-    switch (type->builtInType) {\n-    case XML_SCHEMAS_NMTOKENS:\n-        return (xmlSchemaTypeNmtokenDef );\n-    case XML_SCHEMAS_IDREFS:\n-        return (xmlSchemaTypeIdrefDef);\n-    case XML_SCHEMAS_ENTITIES:\n-        return (xmlSchemaTypeEntityDef);\n-    default:\n-        return (NULL);\n-    }\n-}\n-\n-\/****************************************************************\n- *                                *\n- *        Convenience macros and functions        *\n- *                                *\n- ****************************************************************\/\n-\n-#define IS_TZO_CHAR(c)                        \\\n-    ((c == 0) || (c == 'Z') || (c == '+') || (c == '-'))\n-\n-#define VALID_YEAR(yr)          (yr != 0)\n-#define VALID_MONTH(mon)        ((mon >= 1) && (mon <= 12))\n-\/* VALID_DAY should only be used when month is unknown *\/\n-#define VALID_DAY(day)          ((day >= 1) && (day <= 31))\n-#define VALID_HOUR(hr)          ((hr >= 0) && (hr <= 23))\n-#define VALID_MIN(min)          ((min >= 0) && (min <= 59))\n-#define VALID_SEC(sec)          ((sec >= 0) && (sec < 60))\n-#define VALID_TZO(tzo)          ((tzo >= -840) && (tzo <= 840))\n-#define IS_LEAP(y)                        \\\n-    (((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0))\n-\n-static const unsigned int daysInMonth[12] =\n-    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n-static const unsigned int daysInMonthLeap[12] =\n-    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n-\n-#define MAX_DAYINMONTH(yr,mon)                                  \\\n-        (IS_LEAP(yr) ? daysInMonthLeap[mon - 1] : daysInMonth[mon - 1])\n-\n-#define VALID_MDAY(dt)                        \\\n-    (IS_LEAP(dt->year) ?                        \\\n-        (dt->day <= daysInMonthLeap[dt->mon - 1]) :            \\\n-        (dt->day <= daysInMonth[dt->mon - 1]))\n-\n-#define VALID_DATE(dt)                        \\\n-    (VALID_YEAR(dt->year) && VALID_MONTH(dt->mon) && VALID_MDAY(dt))\n-\n-#define VALID_END_OF_DAY(dt)                    \\\n-    ((dt)->hour == 24 && (dt)->min == 0 && (dt)->sec == 0)\n-\n-#define VALID_TIME(dt)                        \\\n-    (((VALID_HOUR((int)dt->hour) && VALID_MIN((int)dt->min) &&    \\\n-      VALID_SEC(dt->sec)) || VALID_END_OF_DAY(dt)) &&    \\\n-     VALID_TZO(dt->tzo))\n-\n-#define VALID_DATETIME(dt)                    \\\n-    (VALID_DATE(dt) && VALID_TIME(dt))\n-\n-#define SECS_PER_MIN            60\n-#define MINS_PER_HOUR           60\n-#define HOURS_PER_DAY           24\n-#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)\n-#define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)\n-#define MINS_PER_DAY            (HOURS_PER_DAY * MINS_PER_HOUR)\n-\n-static const long dayInYearByMonth[12] =\n-    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };\n-static const long dayInLeapYearByMonth[12] =\n-    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335 };\n-\n-#define DAY_IN_YEAR(day, month, year)                \\\n-        ((IS_LEAP(year) ?                    \\\n-                dayInLeapYearByMonth[month - 1] :        \\\n-                dayInYearByMonth[month - 1]) + day)\n-\n-\/**\n- * _xmlSchemaParseGYear:\n- * @dt:  pointer to a date structure\n- * @str: pointer to the string to analyze\n- *\n- * Parses a xs:gYear without time zone and fills in the appropriate\n- * field of the @dt structure. @str is updated to point just after the\n- * xs:gYear. It is supposed that @dt->year is big enough to contain\n- * the year.\n- *\n- * Returns 0 or the error code\n- *\/\n-static int\n-_xmlSchemaParseGYear (xmlSchemaValDatePtr dt, const xmlChar **str) {\n-    const xmlChar *cur = *str, *firstChar;\n-    int isneg = 0, digcnt = 0;\n-\n-    if (((*cur < '0') || (*cur > '9')) &&\n-    (*cur != '-') && (*cur != '+'))\n-    return -1;\n-\n-    if (*cur == '-') {\n-    isneg = 1;\n-    cur++;\n-    }\n-\n-    firstChar = cur;\n-\n-    while ((*cur >= '0') && (*cur <= '9')) {\n-        int digit = *cur - '0';\n-\n-        if (dt->year > LONG_MAX \/ 10)\n-            return 2;\n-    dt->year *= 10;\n-        if (dt->year > LONG_MAX - digit)\n-            return 2;\n-        dt->year += digit;\n-    cur++;\n-    digcnt++;\n-    }\n-\n-    \/* year must be at least 4 digits (CCYY); over 4\n-     * digits cannot have a leading zero. *\/\n-    if ((digcnt < 4) || ((digcnt > 4) && (*firstChar == '0')))\n-    return 1;\n-\n-    if (isneg)\n-    dt->year = - dt->year;\n-\n-    if (!VALID_YEAR(dt->year))\n-    return 2;\n-\n-    *str = cur;\n-    return 0;\n-}\n-\n-\/**\n- * PARSE_2_DIGITS:\n- * @num:  the integer to fill in\n- * @cur:  an #xmlChar *\n- * @invalid: an integer\n- *\n- * Parses a 2-digits integer and updates @num with the value. @cur is\n- * updated to point just after the integer.\n- * In case of error, @invalid is set to %TRUE, values of @num and\n- * @cur are undefined.\n- *\/\n-#define PARSE_2_DIGITS(num, cur, invalid)            \\\n-    if ((cur[0] < '0') || (cur[0] > '9') ||            \\\n-        (cur[1] < '0') || (cur[1] > '9'))            \\\n-        invalid = 1;                    \\\n-    else                            \\\n-        num = (cur[0] - '0') * 10 + (cur[1] - '0');        \\\n-    cur += 2;\n-\n-\/**\n- * PARSE_FLOAT:\n- * @num:  the double to fill in\n- * @cur:  an #xmlChar *\n- * @invalid: an integer\n- *\n- * Parses a float and updates @num with the value. @cur is\n- * updated to point just after the float. The float must have a\n- * 2-digits integer part and may or may not have a decimal part.\n- * In case of error, @invalid is set to %TRUE, values of @num and\n- * @cur are undefined.\n- *\/\n-#define PARSE_FLOAT(num, cur, invalid)                \\\n-    PARSE_2_DIGITS(num, cur, invalid);            \\\n-    if (!invalid && (*cur == '.')) {            \\\n-        double mult = 1;                        \\\n-        cur++;                        \\\n-        if ((*cur < '0') || (*cur > '9'))            \\\n-        invalid = 1;                    \\\n-        while ((*cur >= '0') && (*cur <= '9')) {        \\\n-        mult \/= 10;                    \\\n-        num += (*cur - '0') * mult;            \\\n-        cur++;                        \\\n-        }                            \\\n-    }\n-\n-\/**\n- * _xmlSchemaParseGMonth:\n- * @dt:  pointer to a date structure\n- * @str: pointer to the string to analyze\n- *\n- * Parses a xs:gMonth without time zone and fills in the appropriate\n- * field of the @dt structure. @str is updated to point just after the\n- * xs:gMonth.\n- *\n- * Returns 0 or the error code\n- *\/\n-static int\n-_xmlSchemaParseGMonth (xmlSchemaValDatePtr dt, const xmlChar **str) {\n-    const xmlChar *cur = *str;\n-    int ret = 0;\n-    unsigned int value = 0;\n-\n-    PARSE_2_DIGITS(value, cur, ret);\n-    if (ret != 0)\n-    return ret;\n-\n-    if (!VALID_MONTH(value))\n-    return 2;\n-\n-    dt->mon = value;\n-\n-    *str = cur;\n-    return 0;\n-}\n-\n-\/**\n- * _xmlSchemaParseGDay:\n- * @dt:  pointer to a date structure\n- * @str: pointer to the string to analyze\n- *\n- * Parses a xs:gDay without time zone and fills in the appropriate\n- * field of the @dt structure. @str is updated to point just after the\n- * xs:gDay.\n- *\n- * Returns 0 or the error code\n- *\/\n-static int\n-_xmlSchemaParseGDay (xmlSchemaValDatePtr dt, const xmlChar **str) {\n-    const xmlChar *cur = *str;\n-    int ret = 0;\n-    unsigned int value = 0;\n-\n-    PARSE_2_DIGITS(value, cur, ret);\n-    if (ret != 0)\n-    return ret;\n-\n-    if (!VALID_DAY(value))\n-    return 2;\n-\n-    dt->day = value;\n-    *str = cur;\n-    return 0;\n-}\n-\n-\/**\n- * _xmlSchemaParseTime:\n- * @dt:  pointer to a date structure\n- * @str: pointer to the string to analyze\n- *\n- * Parses a xs:time without time zone and fills in the appropriate\n- * fields of the @dt structure. @str is updated to point just after the\n- * xs:time.\n- * In case of error, values of @dt fields are undefined.\n- *\n- * Returns 0 or the error code\n- *\/\n-static int\n-_xmlSchemaParseTime (xmlSchemaValDatePtr dt, const xmlChar **str) {\n-    const xmlChar *cur = *str;\n-    int ret = 0;\n-    int value = 0;\n-\n-    PARSE_2_DIGITS(value, cur, ret);\n-    if (ret != 0)\n-    return ret;\n-    if (*cur != ':')\n-    return 1;\n-    if (!VALID_HOUR(value) && value != 24 \/* Allow end-of-day hour *\/)\n-    return 2;\n-    cur++;\n-\n-    \/* the ':' insures this string is xs:time *\/\n-    dt->hour = value;\n-\n-    PARSE_2_DIGITS(value, cur, ret);\n-    if (ret != 0)\n-    return ret;\n-    if (!VALID_MIN(value))\n-    return 2;\n-    dt->min = value;\n-\n-    if (*cur != ':')\n-    return 1;\n-    cur++;\n-\n-    PARSE_FLOAT(dt->sec, cur, ret);\n-    if (ret != 0)\n-    return ret;\n-\n-    if (!VALID_TIME(dt))\n-    return 2;\n-\n-    *str = cur;\n-    return 0;\n-}\n-\n-\/**\n- * _xmlSchemaParseTimeZone:\n- * @dt:  pointer to a date structure\n- * @str: pointer to the string to analyze\n- *\n- * Parses a time zone without time zone and fills in the appropriate\n- * field of the @dt structure. @str is updated to point just after the\n- * time zone.\n- *\n- * Returns 0 or the error code\n- *\/\n-static int\n-_xmlSchemaParseTimeZone (xmlSchemaValDatePtr dt, const xmlChar **str) {\n-    const xmlChar *cur;\n-    int ret = 0;\n-\n-    if (str == NULL)\n-    return -1;\n-    cur = *str;\n-\n-    switch (*cur) {\n-    case 0:\n-    dt->tz_flag = 0;\n-    dt->tzo = 0;\n-    break;\n-\n-    case 'Z':\n-    dt->tz_flag = 1;\n-    dt->tzo = 0;\n-    cur++;\n-    break;\n-\n-    case '+':\n-    case '-': {\n-    int isneg = 0, tmp = 0;\n-    isneg = (*cur == '-');\n-\n-    cur++;\n-\n-    PARSE_2_DIGITS(tmp, cur, ret);\n-    if (ret != 0)\n-        return ret;\n-    if (!VALID_HOUR(tmp))\n-        return 2;\n-\n-    if (*cur != ':')\n-        return 1;\n-    cur++;\n-\n-    dt->tzo = tmp * 60;\n-\n-    PARSE_2_DIGITS(tmp, cur, ret);\n-    if (ret != 0)\n-        return ret;\n-    if (!VALID_MIN(tmp))\n-        return 2;\n-\n-    dt->tzo += tmp;\n-    if (isneg)\n-        dt->tzo = - dt->tzo;\n-\n-    if (!VALID_TZO(dt->tzo))\n-        return 2;\n-\n-    dt->tz_flag = 1;\n-    break;\n-      }\n-    default:\n-    return 1;\n-    }\n-\n-    *str = cur;\n-    return 0;\n-}\n-\n-\/**\n- * _xmlSchemaBase64Decode:\n- * @ch: a character\n- *\n- * Converts a base64 encoded character to its base 64 value.\n- *\n- * Returns 0-63 (value), 64 (pad), or -1 (not recognized)\n- *\/\n-static int\n-_xmlSchemaBase64Decode (const xmlChar ch) {\n-    if (('A' <= ch) && (ch <= 'Z')) return ch - 'A';\n-    if (('a' <= ch) && (ch <= 'z')) return ch - 'a' + 26;\n-    if (('0' <= ch) && (ch <= '9')) return ch - '0' + 52;\n-    if ('+' == ch) return 62;\n-    if ('\/' == ch) return 63;\n-    if ('=' == ch) return 64;\n-    return -1;\n-}\n-\n-\/****************************************************************\n- *                                *\n- *    XML Schema Dates\/Times Datatypes Handling        *\n- *                                *\n- ****************************************************************\/\n-\n-\/**\n- * PARSE_DIGITS:\n- * @num:  the integer to fill in\n- * @cur:  an #xmlChar *\n- * @num_type: an integer flag\n- *\n- * Parses a digits integer and updates @num with the value. @cur is\n- * updated to point just after the integer.\n- * In case of error, @num_type is set to -1, values of @num and\n- * @cur are undefined.\n- *\/\n-#define PARSE_DIGITS(num, cur, num_type)                    \\\n-    if ((*cur < '0') || (*cur > '9'))            \\\n-        num_type = -1;                    \\\n-        else                                                    \\\n-        while ((*cur >= '0') && (*cur <= '9')) {        \\\n-            num = num * 10 + (*cur - '0');                \\\n-            cur++;                                          \\\n-            }\n-\n-\/**\n- * PARSE_NUM:\n- * @num:  the double to fill in\n- * @cur:  an #xmlChar *\n- * @num_type: an integer flag\n- *\n- * Parses a float or integer and updates @num with the value. @cur is\n- * updated to point just after the number. If the number is a float,\n- * then it must have an integer part and a decimal part; @num_type will\n- * be set to 1. If there is no decimal part, @num_type is set to zero.\n- * In case of error, @num_type is set to -1, values of @num and\n- * @cur are undefined.\n- *\/\n-#define PARSE_NUM(num, cur, num_type)                \\\n-        num = 0;                                                \\\n-    PARSE_DIGITS(num, cur, num_type);                    \\\n-    if (!num_type && (*cur == '.')) {            \\\n-        double mult = 1;                        \\\n-        cur++;                        \\\n-        if ((*cur < '0') || (*cur > '9'))            \\\n-        num_type = -1;                    \\\n-            else                                                \\\n-                num_type = 1;                                   \\\n-        while ((*cur >= '0') && (*cur <= '9')) {        \\\n-        mult \/= 10;                    \\\n-        num += (*cur - '0') * mult;            \\\n-        cur++;                        \\\n-        }                            \\\n-    }\n-\n-\/**\n- * xmlSchemaValidateDates:\n- * @type: the expected type or XML_SCHEMAS_UNKNOWN\n- * @dateTime:  string to analyze\n- * @val:  the return computed value\n- *\n- * Check that @dateTime conforms to the lexical space of one of the date types.\n- * if true a value is computed and returned in @val.\n- *\n- * Returns 0 if this validates, a positive error code number otherwise\n- *         and -1 in case of internal or API error.\n- *\/\n-static int\n-xmlSchemaValidateDates (xmlSchemaValType type,\n-                    const xmlChar *dateTime, xmlSchemaValPtr *val,\n-            int collapse) {\n-    xmlSchemaValPtr dt;\n-    int ret;\n-    const xmlChar *cur = dateTime;\n-\n-#define RETURN_TYPE_IF_VALID(t)                    \\\n-    if (IS_TZO_CHAR(*cur)) {                    \\\n-    ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);    \\\n-    if (ret == 0) {                        \\\n-        if (*cur != 0)                    \\\n-        goto error;                    \\\n-        dt->type = t;                    \\\n-        goto done;                        \\\n-    }                            \\\n-    }\n-\n-    if (dateTime == NULL)\n-    return -1;\n-\n-    if (collapse)\n-    while IS_WSP_BLANK_CH(*cur) cur++;\n-\n-    if ((*cur != '-') && (*cur < '0') && (*cur > '9'))\n-    return 1;\n-\n-    dt = xmlSchemaNewValue(XML_SCHEMAS_UNKNOWN);\n-    if (dt == NULL)\n-    return -1;\n-\n-    if ((cur[0] == '-') && (cur[1] == '-')) {\n-    \/*\n-     * It's an incomplete date (xs:gMonthDay, xs:gMonth or\n-     * xs:gDay)\n-     *\/\n-    cur += 2;\n-\n-    \/* is it an xs:gDay? *\/\n-    if (*cur == '-') {\n-        if (type == XML_SCHEMAS_GMONTH)\n-        goto error;\n-      ++cur;\n-        ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);\n-        if (ret != 0)\n-        goto error;\n-\n-        RETURN_TYPE_IF_VALID(XML_SCHEMAS_GDAY);\n-\n-        goto error;\n-    }\n-\n-    \/*\n-     * it should be an xs:gMonthDay or xs:gMonth\n-     *\/\n-    ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur);\n-    if (ret != 0)\n-        goto error;\n-\n-        \/*\n-         * a '-' char could indicate this type is xs:gMonthDay or\n-         * a negative time zone offset. Check for xs:gMonthDay first.\n-         * Also the first three char's of a negative tzo (-MM:SS) can\n-         * appear to be a valid day; so even if the day portion\n-         * of the xs:gMonthDay verifies, we must insure it was not\n-         * a tzo.\n-         *\/\n-        if (*cur == '-') {\n-            const xmlChar *rewnd = cur;\n-            cur++;\n-\n-        ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);\n-            if ((ret == 0) && ((*cur == 0) || (*cur != ':'))) {\n-\n-                \/*\n-                 * we can use the VALID_MDAY macro to validate the month\n-                 * and day because the leap year test will flag year zero\n-                 * as a leap year (even though zero is an invalid year).\n-         * FUTURE TODO: Zero will become valid in XML Schema 1.1\n-         * probably.\n-                 *\/\n-                if (VALID_MDAY((&(dt->value.date)))) {\n-\n-                RETURN_TYPE_IF_VALID(XML_SCHEMAS_GMONTHDAY);\n-\n-                    goto error;\n-                }\n-            }\n-\n-            \/*\n-             * not xs:gMonthDay so rewind and check if just xs:gMonth\n-             * with an optional time zone.\n-             *\/\n-            cur = rewnd;\n-        }\n-\n-    RETURN_TYPE_IF_VALID(XML_SCHEMAS_GMONTH);\n-\n-    goto error;\n-    }\n-\n-    \/*\n-     * It's a right-truncated date or an xs:time.\n-     * Try to parse an xs:time then fallback on right-truncated dates.\n-     *\/\n-    if ((*cur >= '0') && (*cur <= '9')) {\n-    ret = _xmlSchemaParseTime(&(dt->value.date), &cur);\n-    if (ret == 0) {\n-        \/* it's an xs:time *\/\n-        RETURN_TYPE_IF_VALID(XML_SCHEMAS_TIME);\n-    }\n-    }\n-\n-    \/* fallback on date parsing *\/\n-    cur = dateTime;\n-\n-    ret = _xmlSchemaParseGYear(&(dt->value.date), &cur);\n-    if (ret != 0)\n-    goto error;\n-\n-    \/* is it an xs:gYear? *\/\n-    RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEAR);\n-\n-    if (*cur != '-')\n-    goto error;\n-    cur++;\n-\n-    ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur);\n-    if (ret != 0)\n-    goto error;\n-\n-    \/* is it an xs:gYearMonth? *\/\n-    RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEARMONTH);\n-\n-    if (*cur != '-')\n-    goto error;\n-    cur++;\n-\n-    ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);\n-    if ((ret != 0) || !VALID_DATE((&(dt->value.date))))\n-    goto error;\n-\n-    \/* is it an xs:date? *\/\n-    RETURN_TYPE_IF_VALID(XML_SCHEMAS_DATE);\n-\n-    if (*cur != 'T')\n-    goto error;\n-    cur++;\n-\n-    \/* it should be an xs:dateTime *\/\n-    ret = _xmlSchemaParseTime(&(dt->value.date), &cur);\n-    if (ret != 0)\n-    goto error;\n-\n-    ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);\n-    if (collapse)\n-    while IS_WSP_BLANK_CH(*cur) cur++;\n-    if ((ret != 0) || (*cur != 0) || (!(VALID_DATETIME((&(dt->value.date))))))\n-    goto error;\n-\n-\n-    dt->type = XML_SCHEMAS_DATETIME;\n-\n-done:\n-#if 1\n-    if ((type != XML_SCHEMAS_UNKNOWN) && (type != dt->type))\n-        goto error;\n-#else\n-    \/*\n-     * insure the parsed type is equal to or less significant (right\n-     * truncated) than the desired type.\n-     *\/\n-    if ((type != XML_SCHEMAS_UNKNOWN) && (type != dt->type)) {\n-\n-        \/* time only matches time *\/\n-        if ((type == XML_SCHEMAS_TIME) && (dt->type == XML_SCHEMAS_TIME))\n-            goto error;\n-\n-        if ((type == XML_SCHEMAS_DATETIME) &&\n-            ((dt->type != XML_SCHEMAS_DATE) ||\n-             (dt->type != XML_SCHEMAS_GYEARMONTH) ||\n-             (dt->type != XML_SCHEMAS_GYEAR)))\n-            goto error;\n-\n-        if ((type == XML_SCHEMAS_DATE) &&\n-            ((dt->type != XML_SCHEMAS_GYEAR) ||\n-             (dt->type != XML_SCHEMAS_GYEARMONTH)))\n-            goto error;\n-\n-        if ((type == XML_SCHEMAS_GYEARMONTH) && (dt->type != XML_SCHEMAS_GYEAR))\n-            goto error;\n-\n-        if ((type == XML_SCHEMAS_GMONTHDAY) && (dt->type != XML_SCHEMAS_GMONTH))\n-            goto error;\n-    }\n-#endif\n-\n-    if (val != NULL)\n-        *val = dt;\n-    else\n-    xmlSchemaFreeValue(dt);\n-\n-    return 0;\n-\n-error:\n-    if (dt != NULL)\n-    xmlSchemaFreeValue(dt);\n-    return 1;\n-}\n-\n-\/**\n- * xmlSchemaValidateDuration:\n- * @type: the predefined type\n- * @duration:  string to analyze\n- * @val:  the return computed value\n- *\n- * Check that @duration conforms to the lexical space of the duration type.\n- * if true a value is computed and returned in @val.\n- *\n- * Returns 0 if this validates, a positive error code number otherwise\n- *         and -1 in case of internal or API error.\n- *\/\n-static int\n-xmlSchemaValidateDuration (xmlSchemaTypePtr type ATTRIBUTE_UNUSED,\n-                       const xmlChar *duration, xmlSchemaValPtr *val,\n-               int collapse) {\n-    const xmlChar  *cur = duration;\n-    xmlSchemaValPtr dur;\n-    int isneg = 0;\n-    unsigned int seq = 0;\n-    long days, secs = 0;\n-    double sec_frac = 0.0;\n-\n-    if (duration == NULL)\n-    return -1;\n-\n-    if (collapse)\n-    while IS_WSP_BLANK_CH(*cur) cur++;\n-\n-    if (*cur == '-') {\n-        isneg = 1;\n-        cur++;\n-    }\n-\n-    \/* duration must start with 'P' (after sign) *\/\n-    if (*cur++ != 'P')\n-    return 1;\n-\n-    if (*cur == 0)\n-    return 1;\n-\n-    dur = xmlSchemaNewValue(XML_SCHEMAS_DURATION);\n-    if (dur == NULL)\n-    return -1;\n-\n-    while (*cur != 0) {\n-        long           num = 0;\n-        size_t         has_digits = 0;\n-        int            has_frac = 0;\n-        const xmlChar  desig[] = {'Y', 'M', 'D', 'H', 'M', 'S'};\n-\n-        \/* input string should be empty or invalid date\/time item *\/\n-        if (seq >= sizeof(desig))\n-            goto error;\n-\n-        \/* T designator must be present for time items *\/\n-        if (*cur == 'T') {\n-            if (seq > 3)\n-                goto error;\n-            cur++;\n-            seq = 3;\n-        } else if (seq == 3)\n-            goto error;\n-\n-        \/* Parse integral part. *\/\n-        while (*cur >= '0' && *cur <= '9') {\n-            long digit = *cur - '0';\n-\n-            if (num > LONG_MAX \/ 10)\n-                goto error;\n-            num *= 10;\n-            if (num > LONG_MAX - digit)\n-                goto error;\n-            num += digit;\n-\n-            has_digits = 1;\n-            cur++;\n-        }\n-\n-        if (*cur == '.') {\n-            \/* Parse fractional part. *\/\n-            double mult = 1.0;\n-            cur++;\n-            has_frac = 1;\n-            while (*cur >= '0' && *cur <= '9') {\n-                mult \/= 10.0;\n-                sec_frac += (*cur - '0') * mult;\n-                has_digits = 1;\n-                cur++;\n-            }\n-        }\n-\n-        while (*cur != desig[seq]) {\n-            seq++;\n-            \/* No T designator or invalid char. *\/\n-            if (seq == 3 || seq == sizeof(desig))\n-                goto error;\n-        }\n-    cur++;\n-\n-        if (!has_digits || (has_frac && (seq != 5)))\n-            goto error;\n-\n-        switch (seq) {\n-            case 0:\n-                \/* Year *\/\n-                if (num > LONG_MAX \/ 12)\n-                    goto error;\n-                dur->value.dur.mon = num * 12;\n-                break;\n-            case 1:\n-                \/* Month *\/\n-                if (dur->value.dur.mon > LONG_MAX - num)\n-                    goto error;\n-                dur->value.dur.mon += num;\n-                break;\n-            case 2:\n-                \/* Day *\/\n-                dur->value.dur.day = num;\n-                break;\n-            case 3:\n-                \/* Hour *\/\n-                days = num \/ HOURS_PER_DAY;\n-                if (dur->value.dur.day > LONG_MAX - days)\n-                    goto error;\n-                dur->value.dur.day += days;\n-                secs = (num % HOURS_PER_DAY) * SECS_PER_HOUR;\n-                break;\n-            case 4:\n-                \/* Minute *\/\n-                days = num \/ MINS_PER_DAY;\n-                if (dur->value.dur.day > LONG_MAX - days)\n-                    goto error;\n-                dur->value.dur.day += days;\n-                secs += (num % MINS_PER_DAY) * SECS_PER_MIN;\n-                break;\n-            case 5:\n-                \/* Second *\/\n-                days = num \/ SECS_PER_DAY;\n-                if (dur->value.dur.day > LONG_MAX - days)\n-                    goto error;\n-                dur->value.dur.day += days;\n-                secs += num % SECS_PER_DAY;\n-                break;\n-        }\n-\n-        seq++;\n-    }\n-\n-    days = secs \/ SECS_PER_DAY;\n-    if (dur->value.dur.day > LONG_MAX - days)\n-        goto error;\n-    dur->value.dur.day += days;\n-    dur->value.dur.sec = (secs % SECS_PER_DAY) + sec_frac;\n-\n-    if (isneg) {\n-        dur->value.dur.mon = -dur->value.dur.mon;\n-        dur->value.dur.day = -dur->value.dur.day;\n-        dur->value.dur.sec = -dur->value.dur.sec;\n-    }\n-\n-    if (val != NULL)\n-        *val = dur;\n-    else\n-    xmlSchemaFreeValue(dur);\n-\n-    return 0;\n-\n-error:\n-    if (dur != NULL)\n-    xmlSchemaFreeValue(dur);\n-    return 1;\n-}\n-\n-\/**\n- * xmlSchemaStrip:\n- * @value: a value\n- *\n- * Removes the leading and ending spaces of a string\n- *\n- * Returns the new string or NULL if no change was required.\n- *\/\n-static xmlChar *\n-xmlSchemaStrip(const xmlChar *value) {\n-    const xmlChar *start = value, *end, *f;\n-\n-    if (value == NULL) return(NULL);\n-    while ((*start != 0) && (IS_BLANK_CH(*start))) start++;\n-    end = start;\n-    while (*end != 0) end++;\n-    f = end;\n-    end--;\n-    while ((end > start) && (IS_BLANK_CH(*end))) end--;\n-    end++;\n-    if ((start == value) && (f == end)) return(NULL);\n-    return(xmlStrndup(start, end - start));\n-}\n-\n-\/**\n- * xmlSchemaWhiteSpaceReplace:\n- * @value: a value\n- *\n- * Replaces 0xd, 0x9 and 0xa with a space.\n- *\n- * Returns the new string or NULL if no change was required.\n- *\/\n-xmlChar *\n-xmlSchemaWhiteSpaceReplace(const xmlChar *value) {\n-    const xmlChar *cur = value;\n-    xmlChar *ret = NULL, *mcur;\n-\n-    if (value == NULL)\n-    return(NULL);\n-\n-    while ((*cur != 0) &&\n-    (((*cur) != 0xd) && ((*cur) != 0x9) && ((*cur) != 0xa))) {\n-    cur++;\n-    }\n-    if (*cur == 0)\n-    return (NULL);\n-    ret = xmlStrdup(value);\n-    \/* TODO FIXME: I guess gcc will bark at this. *\/\n-    mcur = (xmlChar *)  (ret + (cur - value));\n-    do {\n-    if ( ((*mcur) == 0xd) || ((*mcur) == 0x9) || ((*mcur) == 0xa) )\n-        *mcur = ' ';\n-    mcur++;\n-    } while (*mcur != 0);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlSchemaCollapseString:\n- * @value: a value\n- *\n- * Removes and normalize white spaces in the string\n- *\n- * Returns the new string or NULL if no change was required.\n- *\/\n-xmlChar *\n-xmlSchemaCollapseString(const xmlChar *value) {\n-    const xmlChar *start = value, *end, *f;\n-    xmlChar *g;\n-    int col = 0;\n-\n-    if (value == NULL) return(NULL);\n-    while ((*start != 0) && (IS_BLANK_CH(*start))) start++;\n-    end = start;\n-    while (*end != 0) {\n-    if ((*end == ' ') && (IS_BLANK_CH(end[1]))) {\n-        col = end - start;\n-        break;\n-    } else if ((*end == 0xa) || (*end == 0x9) || (*end == 0xd)) {\n-        col = end - start;\n-        break;\n-    }\n-    end++;\n-    }\n-    if (col == 0) {\n-    f = end;\n-    end--;\n-    while ((end > start) && (IS_BLANK_CH(*end))) end--;\n-    end++;\n-    if ((start == value) && (f == end)) return(NULL);\n-    return(xmlStrndup(start, end - start));\n-    }\n-    start = xmlStrdup(start);\n-    if (start == NULL) return(NULL);\n-    g = (xmlChar *) (start + col);\n-    end = g;\n-    while (*end != 0) {\n-    if (IS_BLANK_CH(*end)) {\n-        end++;\n-        while (IS_BLANK_CH(*end)) end++;\n-        if (*end != 0)\n-        *g++ = ' ';\n-    } else\n-        *g++ = *end++;\n-    }\n-    *g = 0;\n-    return((xmlChar *) start);\n-}\n-\n-\/**\n- * xmlSchemaValAtomicListNode:\n- * @type: the predefined atomic type for a token in the list\n- * @value: the list value to check\n- * @ret:  the return computed value\n- * @node:  the node containing the value\n- *\n- * Check that a value conforms to the lexical space of the predefined\n- * list type. if true a value is computed and returned in @ret.\n- *\n- * Returns the number of items if this validates, a negative error code\n- *         number otherwise\n- *\/\n-static int\n-xmlSchemaValAtomicListNode(xmlSchemaTypePtr type, const xmlChar *value,\n-                       xmlSchemaValPtr *ret, xmlNodePtr node) {\n-    xmlChar *val, *cur, *endval;\n-    int nb_values = 0;\n-    int tmp = 0;\n-\n-    if (value == NULL) {\n-    return(-1);\n-    }\n-    val = xmlStrdup(value);\n-    if (val == NULL) {\n-    return(-1);\n-    }\n-    if (ret != NULL) {\n-        *ret = NULL;\n-    }\n-    cur = val;\n-    \/*\n-     * Split the list\n-     *\/\n-    while (IS_BLANK_CH(*cur)) *cur++ = 0;\n-    while (*cur != 0) {\n-    if (IS_BLANK_CH(*cur)) {\n-        *cur = 0;\n-        cur++;\n-        while (IS_BLANK_CH(*cur)) *cur++ = 0;\n-    } else {\n-        nb_values++;\n-        cur++;\n-        while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n-    }\n-    }\n-    if (nb_values == 0) {\n-    xmlFree(val);\n-    return(nb_values);\n-    }\n-    endval = cur;\n-    cur = val;\n-    while ((*cur == 0) && (cur != endval)) cur++;\n-    while (cur != endval) {\n-    tmp = xmlSchemaValPredefTypeNode(type, cur, NULL, node);\n-    if (tmp != 0)\n-        break;\n-    while (*cur != 0) cur++;\n-    while ((*cur == 0) && (cur != endval)) cur++;\n-    }\n-    \/* TODO what return value ? c.f. bug #158628\n-    if (ret != NULL) {\n-    TODO\n-    } *\/\n-    xmlFree(val);\n-    if (tmp == 0)\n-    return(nb_values);\n-    return(-1);\n-}\n-\n-\/**\n- * xmlSchemaParseUInt:\n- * @str: pointer to the string R\/W\n- * @val: pointer to the resulting decimal\n- *\n- * Parse an unsigned long into a decimal.\n- *\n- * Returns the number of significant digits in the number or\n- * -1 if overflow of the capacity and -2 if it's not a number.\n- *\/\n-static int xmlSchemaParseUInt(const xmlChar **str, xmlSchemaValDecimalPtr val) {\n-    const xmlChar *tmp, *cur = *str;\n-    int ret = 0, i = 0;\n-\n-    if (!((*cur >= '0') && (*cur <= '9')))\n-        return(-2);\n-\n-    while (*cur == '0') {        \/* ignore leading zeroes *\/\n-        cur++;\n-    }\n-    \/* back up in case there is nothing after the leading zeroes *\/\n-    if(!(*cur >= '0' && *cur <= '9'))\n-    {\n-        --cur;\n-    }\n-    tmp = cur;\n-    while ((*tmp != 0) && (*tmp >= '0') && (*tmp <= '9')) {\n-        i++;tmp++;ret++;\n-    }\n-    if (val->integralPlaces + val->fractionalPlaces < (unsigned)i + 1)\n-    {\n-        if (val->str != NULL)\n-        {\n-            xmlFree(val->str);\n-        }\n-        \/*  sign, dot, fractional 0 and NULL terminator *\/\n-        val->str = xmlMalloc(i + 4);\n-    }\n-    val->fractionalPlaces = 1;\n-    val->integralPlaces = i;\n-    snprintf((char *)val->str, i + 4, \"+%.*s.0\", i, cur);\n-\n-    *str = tmp;\n-    return(ret);\n-}\n-\n-\/*\n- * xmlSchemaCheckLanguageType\n- * @value: the value to check\n- *\n- * Check that a value conforms to the lexical space of the language datatype.\n- * Must conform to [a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*\n- *\n- * Returns 1 if this validates, 0 otherwise.\n- *\/\n-static int\n-xmlSchemaCheckLanguageType(const xmlChar* value) {\n-    int first = 1, len = 0;\n-    const xmlChar* cur = value;\n-\n-    if (value == NULL)\n-        return (0);\n-\n-    while (cur[0] != 0) {\n-        if (!( ((cur[0] >= 'a') && (cur[0] <= 'z')) || ((cur[0] >= 'A') && (cur[0] <= 'Z'))\n-            || (cur[0] == '-')\n-            || ((first == 0) && (xmlIsDigit_ch(cur[0]))) ))\n-            return (0);\n-        if (cur[0] == '-') {\n-            if ((len < 1) || (len > 8))\n-                return (0);\n-            len = 0;\n-            first = 0;\n-        }\n-        else\n-            len++;\n-        cur++;\n-    }\n-    if ((len < 1) || (len > 8))\n-        return (0);\n-\n-    return (1);\n-}\n-\n-\/**\n- * xmlSchemaValAtomicType:\n- * @type: the predefined type\n- * @value: the value to check\n- * @val:  the return computed value\n- * @node:  the node containing the value\n- * flags:  flags to control the validation\n- *\n- * Check that a value conforms to the lexical space of the atomic type.\n- * if true a value is computed and returned in @val.\n- * This checks the value space for list types as well (IDREFS, NMTOKENS).\n- *\n- * Returns 0 if this validates, a positive error code number otherwise\n- *         and -1 in case of internal or API error.\n- *\/\n-static int\n-xmlSchemaValAtomicType(xmlSchemaTypePtr type, const xmlChar * value,\n-                       xmlSchemaValPtr * val, xmlNodePtr node, int flags,\n-               xmlSchemaWhitespaceValueType ws,\n-               int normOnTheFly, int applyNorm, int createStringValue)\n-{\n-    xmlSchemaValPtr v;\n-    xmlChar *norm = NULL;\n-    int ret = 0;\n-\n-    if ((xmlSchemaTypesInitialized == 0) &&\n-    (xmlSchemaInitTypes() < 0))\n-        return (-1);\n-    if (type == NULL)\n-        return (-1);\n-\n-    \/*\n-     * validating a non existent text node is similar to validating\n-     * an empty one.\n-     *\/\n-    if (value == NULL)\n-        value = BAD_CAST \"\";\n-\n-    if (val != NULL)\n-        *val = NULL;\n-    if ((flags == 0) && (value != NULL)) {\n-\n-        if ((type->builtInType != XML_SCHEMAS_STRING) &&\n-      (type->builtInType != XML_SCHEMAS_ANYTYPE) &&\n-      (type->builtInType != XML_SCHEMAS_ANYSIMPLETYPE)) {\n-        if (type->builtInType == XML_SCHEMAS_NORMSTRING)\n-        norm = xmlSchemaWhiteSpaceReplace(value);\n-            else\n-        norm = xmlSchemaCollapseString(value);\n-            if (norm != NULL)\n-                value = norm;\n-        }\n-    }\n-\n-    switch (type->builtInType) {\n-        case XML_SCHEMAS_UNKNOWN:\n-            goto error;\n-    case XML_SCHEMAS_ANYTYPE:\n-    case XML_SCHEMAS_ANYSIMPLETYPE:\n-        if ((createStringValue) && (val != NULL)) {\n-        v = xmlSchemaNewValue(XML_SCHEMAS_ANYSIMPLETYPE);\n-        if (v != NULL) {\n-            v->value.str = xmlStrdup(value);\n-            *val = v;\n-        } else {\n-            goto error;\n-        }\n-        }\n-        goto return0;\n-        case XML_SCHEMAS_STRING:\n-        if (! normOnTheFly) {\n-        const xmlChar *cur = value;\n-\n-        if (ws == XML_SCHEMA_WHITESPACE_REPLACE) {\n-            while (*cur != 0) {\n-            if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {\n-                goto return1;\n-            } else {\n-                cur++;\n-            }\n-            }\n-        } else if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE) {\n-            while (*cur != 0) {\n-            if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {\n-                goto return1;\n-            } else if IS_WSP_SPACE_CH(*cur) {\n-                cur++;\n-                if IS_WSP_SPACE_CH(*cur)\n-                goto return1;\n-            } else {\n-                cur++;\n-            }\n-            }\n-        }\n-        }\n-        if (createStringValue && (val != NULL)) {\n-        if (applyNorm) {\n-            if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)\n-            norm = xmlSchemaCollapseString(value);\n-            else if (ws == XML_SCHEMA_WHITESPACE_REPLACE)\n-            norm = xmlSchemaWhiteSpaceReplace(value);\n-            if (norm != NULL)\n-            value = norm;\n-        }\n-        v = xmlSchemaNewValue(XML_SCHEMAS_STRING);\n-        if (v != NULL) {\n-            v->value.str = xmlStrdup(value);\n-            *val = v;\n-        } else {\n-            goto error;\n-        }\n-        }\n-            goto return0;\n-        case XML_SCHEMAS_NORMSTRING:{\n-        if (normOnTheFly) {\n-            if (applyNorm) {\n-            if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)\n-                norm = xmlSchemaCollapseString(value);\n-            else\n-                norm = xmlSchemaWhiteSpaceReplace(value);\n-            if (norm != NULL)\n-                value = norm;\n-            }\n-        } else {\n-            const xmlChar *cur = value;\n-            while (*cur != 0) {\n-            if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {\n-                goto return1;\n-            } else {\n-                cur++;\n-            }\n-            }\n-        }\n-                if (val != NULL) {\n-                    v = xmlSchemaNewValue(XML_SCHEMAS_NORMSTRING);\n-                    if (v != NULL) {\n-                        v->value.str = xmlStrdup(value);\n-                        *val = v;\n-                    } else {\n-                        goto error;\n-                    }\n-                }\n-                goto return0;\n-            }\n-        case XML_SCHEMAS_DECIMAL:{\n-                const xmlChar *cur = value;\n-                const xmlChar *numStart, *numEnd;\n-                xmlSchemaValDecimal decimal;\n-                xmlChar sign;\n-\n-                memset(&decimal, 0, sizeof(decimal));\n-\n-                if ((cur == NULL) || (*cur == 0))\n-                    goto return1;\n-\n-        \/*\n-        * xs:decimal has a whitespace-facet value of 'collapse'.\n-        *\/\n-        if (normOnTheFly)\n-            while IS_WSP_BLANK_CH(*cur) cur++;\n-\n-        \/*\n-        * First we handle an optional sign.\n-        *\/\n-                sign = '+';\n-                if (*cur == '-') {\n-                    sign = '-';\n-                    cur++;\n-        } else if (*cur == '+')\n-                    cur++;\n-        \/*\n-        * Disallow: \"\", \"-\", \"- \"\n-        *\/\n-        if (*cur == 0)\n-            goto return1;\n-\n-        \/*\n-        * Skip leading zeroes.\n-        *\/\n-        while (*cur == '0') {\n-            cur++;\n-        }\n-\n-                numStart = cur;\n-\n-                while ((*cur >= '0') && (*cur <= '9')) {\n-                    ++cur;\n-                    ++decimal.integralPlaces;\n-                }\n-                if (*cur == '.') {\n-                    ++cur;\n-                }\n-                while ((*cur >= '0') && (*cur <= '9')) {\n-                    ++cur;\n-                    ++decimal.fractionalPlaces;\n-                }\n-\n-                \/*  disallow \".\" *\/\n-                if (\n-                    decimal.fractionalPlaces == 0 && decimal.integralPlaces == 0\n-                    && (numStart == value || numStart[-1] != '0')\n-                ) {\n-                    goto return1;\n-                }\n-\n-                numEnd = cur;\n-\n-                \/*  find if there are trailing FRACTIONAL zeroes, and deal with them if necessary *\/\n-                while (numEnd > numStart && decimal.fractionalPlaces && numEnd[-1] == '0') {\n-                    --numEnd;\n-                    --decimal.fractionalPlaces;\n-                }\n-\n-        if (normOnTheFly)\n-            while IS_WSP_BLANK_CH(*cur) cur++;\n-        if (*cur != 0)\n-            goto return1; \/* error if any extraneous chars *\/\n-                if (val != NULL) {\n-                    v = xmlSchemaNewValue(XML_SCHEMAS_DECIMAL);\n-                    if (v != NULL) {\n-                        \/*  create a standardized representation *\/\n-                        size_t bufsize;\n-                        const char *integralStart = (const char *)numStart;\n-                        const char *fractionalStart = (const char *)numEnd - decimal.fractionalPlaces;\n-                        if (decimal.integralPlaces == 0)\n-                        {\n-                            integralStart = \"0\";\n-                            decimal.integralPlaces = 1;\n-                        }\n-                        if (decimal.fractionalPlaces == 0)\n-                        {\n-                            fractionalStart = \"0\";\n-                            decimal.fractionalPlaces = 1;\n-                        }\n-                        \/*  3 = sign, dot, NULL terminator *\/\n-                        bufsize = decimal.integralPlaces + decimal.fractionalPlaces + 3;\n-                        decimal.str = xmlMalloc(bufsize);\n-                        if (!decimal.str)\n-                        {\n-                            goto error;\n-                        }\n-                        snprintf((char *)decimal.str, bufsize, \"%c%.*s.%.*s\", sign, decimal.integralPlaces, integralStart,\n-                                decimal.fractionalPlaces, fractionalStart);\n-                        v->value.decimal = decimal;\n-                        *val = v;\n-                    }\n-                    else\n-                    {\n-                        goto error;\n-                    }\n-                }\n-                goto return0;\n-            }\n-        case XML_SCHEMAS_TIME:\n-        case XML_SCHEMAS_GDAY:\n-        case XML_SCHEMAS_GMONTH:\n-        case XML_SCHEMAS_GMONTHDAY:\n-        case XML_SCHEMAS_GYEAR:\n-        case XML_SCHEMAS_GYEARMONTH:\n-        case XML_SCHEMAS_DATE:\n-        case XML_SCHEMAS_DATETIME:\n-            ret = xmlSchemaValidateDates(type->builtInType, value, val,\n-        normOnTheFly);\n-            break;\n-        case XML_SCHEMAS_DURATION:\n-            ret = xmlSchemaValidateDuration(type, value, val,\n-        normOnTheFly);\n-            break;\n-        case XML_SCHEMAS_FLOAT:\n-        case XML_SCHEMAS_DOUBLE: {\n-                const xmlChar *cur = value;\n-                int neg = 0;\n-                int digits_before = 0;\n-                int digits_after = 0;\n-\n-        if (normOnTheFly)\n-            while IS_WSP_BLANK_CH(*cur) cur++;\n-\n-                if ((cur[0] == 'N') && (cur[1] == 'a') && (cur[2] == 'N')) {\n-                    cur += 3;\n-                    if (*cur != 0)\n-                        goto return1;\n-                    if (val != NULL) {\n-                        if (type == xmlSchemaTypeFloatDef) {\n-                            v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);\n-                            if (v != NULL) {\n-                                v->value.f = (float) xmlXPathNAN;\n-                            } else {\n-                                xmlSchemaFreeValue(v);\n-                                goto error;\n-                            }\n-                        } else {\n-                            v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);\n-                            if (v != NULL) {\n-                                v->value.d = xmlXPathNAN;\n-                            } else {\n-                                xmlSchemaFreeValue(v);\n-                                goto error;\n-                            }\n-                        }\n-                        *val = v;\n-                    }\n-                    goto return0;\n-                }\n-                if (*cur == '-') {\n-                    neg = 1;\n-                    cur++;\n-                }\n-                if ((cur[0] == 'I') && (cur[1] == 'N') && (cur[2] == 'F')) {\n-                    cur += 3;\n-                    if (*cur != 0)\n-                        goto return1;\n-                    if (val != NULL) {\n-                        if (type == xmlSchemaTypeFloatDef) {\n-                            v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);\n-                            if (v != NULL) {\n-                                if (neg)\n-                                    v->value.f = (float) xmlXPathNINF;\n-                                else\n-                                    v->value.f = (float) xmlXPathPINF;\n-                            } else {\n-                                xmlSchemaFreeValue(v);\n-                                goto error;\n-                            }\n-                        } else {\n-                            v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);\n-                            if (v != NULL) {\n-                                if (neg)\n-                                    v->value.d = xmlXPathNINF;\n-                                else\n-                                    v->value.d = xmlXPathPINF;\n-                            } else {\n-                                xmlSchemaFreeValue(v);\n-                                goto error;\n-                            }\n-                        }\n-                        *val = v;\n-                    }\n-                    goto return0;\n-                }\n-                if ((neg == 0) && (*cur == '+'))\n-                    cur++;\n-                if ((cur[0] == 0) || (cur[0] == '+') || (cur[0] == '-'))\n-                    goto return1;\n-                while ((*cur >= '0') && (*cur <= '9')) {\n-                    cur++;\n-                    digits_before++;\n-                }\n-                if (*cur == '.') {\n-                    cur++;\n-                    while ((*cur >= '0') && (*cur <= '9')) {\n-                        cur++;\n-                        digits_after++;\n-                    }\n-                }\n-                if ((digits_before == 0) && (digits_after == 0))\n-                    goto return1;\n-                if ((*cur == 'e') || (*cur == 'E')) {\n-                    cur++;\n-                    if ((*cur == '-') || (*cur == '+'))\n-                        cur++;\n-                    while ((*cur >= '0') && (*cur <= '9'))\n-                        cur++;\n-                }\n-        if (normOnTheFly)\n-            while IS_WSP_BLANK_CH(*cur) cur++;\n-\n-                if (*cur != 0)\n-                    goto return1;\n-                if (val != NULL) {\n-                    if (type == xmlSchemaTypeFloatDef) {\n-                        v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);\n-                        if (v != NULL) {\n-                \/*\n-                * TODO: sscanf seems not to give the correct\n-                * value for extremely high\/low values.\n-                * E.g. \"1E-149\" results in zero.\n-                *\/\n-                            if (sscanf((const char *) value, \"%f\",\n-                                 &(v->value.f)) == 1) {\n-                                *val = v;\n-                            } else {\n-                                xmlSchemaFreeValue(v);\n-                                goto return1;\n-                            }\n-                        } else {\n-                            goto error;\n-                        }\n-                    } else {\n-                        v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);\n-                        if (v != NULL) {\n-                \/*\n-                * TODO: sscanf seems not to give the correct\n-                * value for extremely high\/low values.\n-                *\/\n-                            if (sscanf((const char *) value, \"%lf\",\n-                                 &(v->value.d)) == 1) {\n-                                *val = v;\n-                            } else {\n-                                xmlSchemaFreeValue(v);\n-                                goto return1;\n-                            }\n-                        } else {\n-                            goto error;\n-                        }\n-                    }\n-                }\n-                goto return0;\n-            }\n-        case XML_SCHEMAS_BOOLEAN:{\n-                const xmlChar *cur = value;\n-\n-        if (normOnTheFly) {\n-            while IS_WSP_BLANK_CH(*cur) cur++;\n-            if (*cur == '0') {\n-            ret = 0;\n-            cur++;\n-            } else if (*cur == '1') {\n-            ret = 1;\n-            cur++;\n-            } else if (*cur == 't') {\n-            cur++;\n-            if ((*cur++ == 'r') && (*cur++ == 'u') &&\n-                (*cur++ == 'e')) {\n-                ret = 1;\n-            } else\n-                goto return1;\n-            } else if (*cur == 'f') {\n-            cur++;\n-            if ((*cur++ == 'a') && (*cur++ == 'l') &&\n-                (*cur++ == 's') && (*cur++ == 'e')) {\n-                ret = 0;\n-            } else\n-                goto return1;\n-            } else\n-            goto return1;\n-            if (*cur != 0) {\n-            while IS_WSP_BLANK_CH(*cur) cur++;\n-            if (*cur != 0)\n-                goto return1;\n-            }\n-        } else {\n-            if ((cur[0] == '0') && (cur[1] == 0))\n-            ret = 0;\n-            else if ((cur[0] == '1') && (cur[1] == 0))\n-            ret = 1;\n-            else if ((cur[0] == 't') && (cur[1] == 'r')\n-            && (cur[2] == 'u') && (cur[3] == 'e')\n-            && (cur[4] == 0))\n-            ret = 1;\n-            else if ((cur[0] == 'f') && (cur[1] == 'a')\n-            && (cur[2] == 'l') && (cur[3] == 's')\n-            && (cur[4] == 'e') && (cur[5] == 0))\n-            ret = 0;\n-            else\n-            goto return1;\n-        }\n-                if (val != NULL) {\n-                    v = xmlSchemaNewValue(XML_SCHEMAS_BOOLEAN);\n-                    if (v != NULL) {\n-                        v->value.b = ret;\n-                        *val = v;\n-                    } else {\n-                        goto error;\n-                    }\n-                }\n-                goto return0;\n-            }\n-        case XML_SCHEMAS_TOKEN:{\n-                const xmlChar *cur = value;\n-\n-        if (! normOnTheFly) {\n-            while (*cur != 0) {\n-            if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {\n-                goto return1;\n-            } else if (*cur == ' ') {\n-                cur++;\n-                if (*cur == 0)\n-                goto return1;\n-                if (*cur == ' ')\n-                goto return1;\n-            } else {\n-                cur++;\n-            }\n-            }\n-        }\n-                if (val != NULL) {\n-                    v = xmlSchemaNewValue(XML_SCHEMAS_TOKEN);\n-                    if (v != NULL) {\n-                        v->value.str = xmlStrdup(value);\n-                        *val = v;\n-                    } else {\n-                        goto error;\n-                    }\n-                }\n-                goto return0;\n-            }\n-        case XML_SCHEMAS_LANGUAGE:\n-        if ((norm == NULL) && (normOnTheFly)) {\n-        norm = xmlSchemaCollapseString(value);\n-        if (norm != NULL)\n-            value = norm;\n-        }\n-\n-            if (xmlSchemaCheckLanguageType(value) == 1) {\n-                if (val != NULL) {\n-                    v = xmlSchemaNewValue(XML_SCHEMAS_LANGUAGE);\n-                    if (v != NULL) {\n-                        v->value.str = xmlStrdup(value);\n-                        *val = v;\n-                    } else {\n-                        goto error;\n-                    }\n-                }\n-                goto return0;\n-            }\n-            goto return1;\n-        case XML_SCHEMAS_NMTOKEN:\n-            if (xmlValidateNMToken(value, 1) == 0) {\n-                if (val != NULL) {\n-                    v = xmlSchemaNewValue(XML_SCHEMAS_NMTOKEN);\n-                    if (v != NULL) {\n-                        v->value.str = xmlStrdup(value);\n-                        *val = v;\n-                    } else {\n-                        goto error;\n-                    }\n-                }\n-                goto return0;\n-            }\n-            goto return1;\n-        case XML_SCHEMAS_NMTOKENS:\n-            ret = xmlSchemaValAtomicListNode(xmlSchemaTypeNmtokenDef,\n-                                             value, val, node);\n-            if (ret > 0)\n-                ret = 0;\n-            else\n-                ret = 1;\n-            goto done;\n-        case XML_SCHEMAS_NAME:\n-            ret = xmlValidateName(value, 1);\n-            if ((ret == 0) && (val != NULL) && (value != NULL)) {\n-        v = xmlSchemaNewValue(XML_SCHEMAS_NAME);\n-        if (v != NULL) {\n-             const xmlChar *start = value, *end;\n-             while (IS_BLANK_CH(*start)) start++;\n-             end = start;\n-             while ((*end != 0) && (!IS_BLANK_CH(*end))) end++;\n-             v->value.str = xmlStrndup(start, end - start);\n-            *val = v;\n-        } else {\n-            goto error;\n-        }\n-            }\n-            goto done;\n-        case XML_SCHEMAS_QNAME:{\n-                const xmlChar *uri = NULL;\n-                xmlChar *local = NULL;\n-\n-                ret = xmlValidateQName(value, 1);\n-        if (ret != 0)\n-            goto done;\n-                if (node != NULL) {\n-                    xmlChar *prefix;\n-            xmlNsPtr ns;\n-\n-                    local = xmlSplitQName2(value, &prefix);\n-            ns = xmlSearchNs(node->doc, node, prefix);\n-            if ((ns == NULL) && (prefix != NULL)) {\n-            xmlFree(prefix);\n-            if (local != NULL)\n-                xmlFree(local);\n-            goto return1;\n-            }\n-            if (ns != NULL)\n-            uri = ns->href;\n-                    if (prefix != NULL)\n-                        xmlFree(prefix);\n-                }\n-                if (val != NULL) {\n-                    v = xmlSchemaNewValue(XML_SCHEMAS_QNAME);\n-                    if (v == NULL) {\n-            if (local != NULL)\n-                xmlFree(local);\n-            goto error;\n-            }\n-            if (local != NULL)\n-            v->value.qname.name = local;\n-            else\n-            v->value.qname.name = xmlStrdup(value);\n-            if (uri != NULL)\n-            v->value.qname.uri = xmlStrdup(uri);\n-            *val = v;\n-                } else\n-            if (local != NULL)\n-            xmlFree(local);\n-                goto done;\n-            }\n-        case XML_SCHEMAS_NCNAME:\n-            ret = xmlValidateNCName(value, 1);\n-            if ((ret == 0) && (val != NULL)) {\n-                v = xmlSchemaNewValue(XML_SCHEMAS_NCNAME);\n-                if (v != NULL) {\n-                    v->value.str = xmlStrdup(value);\n-                    *val = v;\n-                } else {\n-                    goto error;\n-                }\n-            }\n-            goto done;\n-        case XML_SCHEMAS_ID:\n-            ret = xmlValidateNCName(value, 1);\n-            if ((ret == 0) && (val != NULL)) {\n-                v = xmlSchemaNewValue(XML_SCHEMAS_ID);\n-                if (v != NULL) {\n-                    v->value.str = xmlStrdup(value);\n-                    *val = v;\n-                } else {\n-                    goto error;\n-                }\n-            }\n-            if ((ret == 0) && (node != NULL) &&\n-                (node->type == XML_ATTRIBUTE_NODE)) {\n-                xmlAttrPtr attr = (xmlAttrPtr) node;\n-\n-                \/*\n-                 * NOTE: the IDness might have already be declared in the DTD\n-                 *\/\n-                if (attr->atype != XML_ATTRIBUTE_ID) {\n-                    xmlChar *strip;\n-                    int res;\n-\n-                    strip = xmlSchemaStrip(value);\n-                    if (strip != NULL) {\n-                        res = xmlAddIDSafe(attr, strip);\n-                        xmlFree(strip);\n-                    } else\n-                        res = xmlAddIDSafe(attr, value);\n-                    if (res < 0) {\n-                        goto error;\n-                    } else if (res == 0) {\n-                        ret = 2;\n-                    }\n-                }\n-            }\n-            goto done;\n-        case XML_SCHEMAS_IDREF:\n-            ret = xmlValidateNCName(value, 1);\n-            if ((ret == 0) && (val != NULL)) {\n-        v = xmlSchemaNewValue(XML_SCHEMAS_IDREF);\n-        if (v == NULL)\n-            goto error;\n-        v->value.str = xmlStrdup(value);\n-        *val = v;\n-            }\n-            if ((ret == 0) && (node != NULL) &&\n-                (node->type == XML_ATTRIBUTE_NODE)) {\n-                xmlAttrPtr attr = (xmlAttrPtr) node;\n-                xmlChar *strip;\n-\n-                strip = xmlSchemaStrip(value);\n-                if (strip != NULL) {\n-                    xmlAddRef(NULL, node->doc, strip, attr);\n-                    xmlFree(strip);\n-                } else\n-                    xmlAddRef(NULL, node->doc, value, attr);\n-                attr->atype = XML_ATTRIBUTE_IDREF;\n-            }\n-            goto done;\n-        case XML_SCHEMAS_IDREFS:\n-            ret = xmlSchemaValAtomicListNode(xmlSchemaTypeIdrefDef,\n-                                             value, val, node);\n-            if (ret < 0)\n-                ret = 2;\n-            else\n-                ret = 0;\n-            if ((ret == 0) && (node != NULL) &&\n-                (node->type == XML_ATTRIBUTE_NODE)) {\n-                xmlAttrPtr attr = (xmlAttrPtr) node;\n-\n-                attr->atype = XML_ATTRIBUTE_IDREFS;\n-            }\n-            goto done;\n-        case XML_SCHEMAS_ENTITY:{\n-                xmlChar *strip;\n-\n-                ret = xmlValidateNCName(value, 1);\n-                if ((node == NULL) || (node->doc == NULL))\n-                    ret = 3;\n-                if (ret == 0) {\n-                    xmlEntityPtr ent;\n-\n-                    strip = xmlSchemaStrip(value);\n-                    if (strip != NULL) {\n-                        ent = xmlGetDocEntity(node->doc, strip);\n-                        xmlFree(strip);\n-                    } else {\n-                        ent = xmlGetDocEntity(node->doc, value);\n-                    }\n-                    if ((ent == NULL) ||\n-                        (ent->etype !=\n-                         XML_EXTERNAL_GENERAL_UNPARSED_ENTITY))\n-                        ret = 4;\n-                }\n-                if ((ret == 0) && (val != NULL)) {\n-                    \/* TODO *\/\n-                }\n-                if ((ret == 0) && (node != NULL) &&\n-                    (node->type == XML_ATTRIBUTE_NODE)) {\n-                    xmlAttrPtr attr = (xmlAttrPtr) node;\n-\n-                    attr->atype = XML_ATTRIBUTE_ENTITY;\n-                }\n-                goto done;\n-            }\n-        case XML_SCHEMAS_ENTITIES:\n-            if ((node == NULL) || (node->doc == NULL))\n-                goto return3;\n-            ret = xmlSchemaValAtomicListNode(xmlSchemaTypeEntityDef,\n-                                             value, val, node);\n-            if (ret <= 0)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            if ((ret == 0) && (node != NULL) &&\n-                (node->type == XML_ATTRIBUTE_NODE)) {\n-                xmlAttrPtr attr = (xmlAttrPtr) node;\n-\n-                attr->atype = XML_ATTRIBUTE_ENTITIES;\n-            }\n-            goto done;\n-        case XML_SCHEMAS_NOTATION:{\n-                xmlChar *uri = NULL;\n-                xmlChar *local = NULL;\n-\n-                ret = xmlValidateQName(value, 1);\n-                if ((ret == 0) && (node != NULL)) {\n-                    xmlChar *prefix;\n-\n-                    local = xmlSplitQName2(value, &prefix);\n-                    if (prefix != NULL) {\n-                        xmlNsPtr ns;\n-\n-                        ns = xmlSearchNs(node->doc, node, prefix);\n-                        if (ns == NULL)\n-                            ret = 1;\n-                        else if (val != NULL)\n-                            uri = xmlStrdup(ns->href);\n-                    }\n-                    if ((local != NULL) && ((val == NULL) || (ret != 0)))\n-                        xmlFree(local);\n-                    if (prefix != NULL)\n-                        xmlFree(prefix);\n-                }\n-                if ((node == NULL) || (node->doc == NULL))\n-                    ret = 3;\n-                if (ret == 0) {\n-                    ret = xmlValidateNotationUse(NULL, node->doc, value);\n-                    if (ret == 1)\n-                        ret = 0;\n-                    else\n-                        ret = 1;\n-                }\n-                if ((ret == 0) && (val != NULL)) {\n-                    v = xmlSchemaNewValue(XML_SCHEMAS_NOTATION);\n-                    if (v != NULL) {\n-                        if (local != NULL)\n-                            v->value.qname.name = local;\n-                        else\n-                            v->value.qname.name = xmlStrdup(value);\n-                        if (uri != NULL)\n-                            v->value.qname.uri = uri;\n-\n-                        *val = v;\n-                    } else {\n-                        if (local != NULL)\n-                            xmlFree(local);\n-                        if (uri != NULL)\n-                            xmlFree(uri);\n-                        goto error;\n-                    }\n-                }\n-                goto done;\n-            }\n-        case XML_SCHEMAS_ANYURI:{\n-                if (*value != 0) {\n-            xmlURIPtr uri;\n-            xmlChar *tmpval, *cur;\n-            if ((norm == NULL) && (normOnTheFly)) {\n-            norm = xmlSchemaCollapseString(value);\n-            if (norm != NULL)\n-                value = norm;\n-            }\n-            tmpval = xmlStrdup(value);\n-                    if (tmpval == NULL)\n-                        goto error;\n-            for (cur = tmpval; *cur; ++cur) {\n-            if (*cur < 32 || *cur >= 127 || *cur == ' ' ||\n-                *cur == '<' || *cur == '>' || *cur == '\"' ||\n-                *cur == '{' || *cur == '}' || *cur == '|' ||\n-                *cur == '\\\\' || *cur == '^' || *cur == '`' ||\n-                *cur == '\\'')\n-                *cur = '_';\n-            }\n-                    uri = xmlParseURI((const char *) tmpval);\n-            xmlFree(tmpval);\n-                    if (uri == NULL)\n-                        goto return1;\n-                    xmlFreeURI(uri);\n-                }\n-\n-                if (val != NULL) {\n-                    v = xmlSchemaNewValue(XML_SCHEMAS_ANYURI);\n-                    if (v == NULL)\n-                        goto error;\n-                    v->value.str = xmlStrdup(value);\n-                    *val = v;\n-                }\n-                goto return0;\n-            }\n-        case XML_SCHEMAS_HEXBINARY:{\n-                const xmlChar *cur = value, *start;\n-                xmlChar *base;\n-                int total, i = 0;\n-\n-                if (cur == NULL)\n-                    goto return1;\n-\n-        if (normOnTheFly)\n-            while IS_WSP_BLANK_CH(*cur) cur++;\n-\n-        start = cur;\n-                while (((*cur >= '0') && (*cur <= '9')) ||\n-                       ((*cur >= 'A') && (*cur <= 'F')) ||\n-                       ((*cur >= 'a') && (*cur <= 'f'))) {\n-                    i++;\n-                    cur++;\n-                }\n-        if (normOnTheFly)\n-            while IS_WSP_BLANK_CH(*cur) cur++;\n-\n-                if (*cur != 0)\n-                    goto return1;\n-                if ((i % 2) != 0)\n-                    goto return1;\n-\n-                if (val != NULL) {\n-\n-                    v = xmlSchemaNewValue(XML_SCHEMAS_HEXBINARY);\n-                    if (v == NULL)\n-                        goto error;\n-            \/*\n-            * Copy only the normalized piece.\n-            * CRITICAL TODO: Check this.\n-            *\/\n-                    cur = xmlStrndup(start, i);\n-                    if (cur == NULL) {\n-                xmlSchemaTypeErrMemory();\n-                        xmlFree(v);\n-                        goto return1;\n-                    }\n-\n-                    total = i \/ 2;      \/* number of octets *\/\n-\n-                    base = (xmlChar *) cur;\n-                    while (i-- > 0) {\n-                        if (*base >= 'a')\n-                            *base = *base - ('a' - 'A');\n-                        base++;\n-                    }\n-\n-                    v->value.hex.str = (xmlChar *) cur;\n-                    v->value.hex.total = total;\n-                    *val = v;\n-                }\n-                goto return0;\n-            }\n-        case XML_SCHEMAS_BASE64BINARY:{\n-                \/* ISSUE:\n-                 *\n-                 * Ignore all stray characters? (yes, currently)\n-                 * Worry about long lines? (no, currently)\n-                 *\n-                 * rfc2045.txt:\n-                 *\n-                 * \"The encoded output stream must be represented in lines of\n-                 * no more than 76 characters each.  All line breaks or other\n-                 * characters not found in Table 1 must be ignored by decoding\n-                 * software.  In base64 data, characters other than those in\n-                 * Table 1, line breaks, and other white space probably\n-                 * indicate a transmission error, about which a warning\n-                 * message or even a message rejection might be appropriate\n-                 * under some circumstances.\" *\/\n-                const xmlChar *cur = value;\n-                xmlChar *base;\n-                int total, i = 0, pad = 0;\n-\n-                if (cur == NULL)\n-                    goto return1;\n-\n-                for (; *cur; ++cur) {\n-                    int decc;\n-\n-                    decc = _xmlSchemaBase64Decode(*cur);\n-                    if (decc < 0) ;\n-                    else if (decc < 64)\n-                        i++;\n-                    else\n-                        break;\n-                }\n-                for (; *cur; ++cur) {\n-                    int decc;\n-\n-                    decc = _xmlSchemaBase64Decode(*cur);\n-                    if (decc < 0) ;\n-                    else if (decc < 64)\n-                        goto return1;\n-                    if (decc == 64)\n-                        pad++;\n-                }\n-\n-                \/* rfc2045.txt: \"Special processing is performed if fewer than\n-                 * 24 bits are available at the end of the data being encoded.\n-                 * A full encoding quantum is always completed at the end of a\n-                 * body.  When fewer than 24 input bits are available in an\n-                 * input group, zero bits are added (on the right) to form an\n-                 * integral number of 6-bit groups.  Padding at the end of the\n-                 * data is performed using the \"=\" character.  Since all\n-                 * base64 input is an integral number of octets, only the\n-                 * following cases can arise: (1) the final quantum of\n-                 * encoding input is an integral multiple of 24 bits; here,\n-                 * the final unit of encoded output will be an integral\n-                 * multiple of indent: Standard input:701: Warning:old style\n-         * assignment ambiguity in \"=*\".  Assuming \"= *\" 4 characters\n-         * with no \"=\" padding, (2) the final\n-                 * quantum of encoding input is exactly 8 bits; here, the\n-                 * final unit of encoded output will be two characters\n-                 * followed by two \"=\" padding characters, or (3) the final\n-                 * quantum of encoding input is exactly 16 bits; here, the\n-                 * final unit of encoded output will be three characters\n-                 * followed by one \"=\" padding character.\" *\/\n-\n-                total = 3 * (i \/ 4);\n-                if (pad == 0) {\n-                    if (i % 4 != 0)\n-                        goto return1;\n-                } else if (pad == 1) {\n-                    int decc;\n-\n-                    if (i % 4 != 3)\n-                        goto return1;\n-                    for (decc = _xmlSchemaBase64Decode(*cur);\n-                         (decc < 0) || (decc > 63);\n-                         decc = _xmlSchemaBase64Decode(*cur))\n-                        --cur;\n-                    \/* 16bits in 24bits means 2 pad bits: nnnnnn nnmmmm mmmm00*\/\n-                    \/* 00111100 -> 0x3c *\/\n-                    if (decc & ~0x3c)\n-                        goto return1;\n-                    total += 2;\n-                } else if (pad == 2) {\n-                    int decc;\n-\n-                    if (i % 4 != 2)\n-                        goto return1;\n-                    for (decc = _xmlSchemaBase64Decode(*cur);\n-                         (decc < 0) || (decc > 63);\n-                         decc = _xmlSchemaBase64Decode(*cur))\n-                        --cur;\n-                    \/* 8bits in 12bits means 4 pad bits: nnnnnn nn0000 *\/\n-                    \/* 00110000 -> 0x30 *\/\n-                    if (decc & ~0x30)\n-                        goto return1;\n-                    total += 1;\n-                } else\n-                    goto return1;\n-\n-                if (val != NULL) {\n-                    v = xmlSchemaNewValue(XML_SCHEMAS_BASE64BINARY);\n-                    if (v == NULL)\n-                        goto error;\n-                    base =\n-                        (xmlChar *) xmlMallocAtomic(i + pad + 1);\n-                    if (base == NULL) {\n-                xmlSchemaTypeErrMemory();\n-                        xmlFree(v);\n-                        goto return1;\n-                    }\n-                    v->value.base64.str = base;\n-                    for (cur = value; *cur; ++cur)\n-                        if (_xmlSchemaBase64Decode(*cur) >= 0) {\n-                            *base = *cur;\n-                            ++base;\n-                        }\n-                    *base = 0;\n-                    v->value.base64.total = total;\n-                    *val = v;\n-                }\n-                goto return0;\n-            }\n-        case XML_SCHEMAS_INTEGER:\n-        case XML_SCHEMAS_PINTEGER:\n-        case XML_SCHEMAS_NPINTEGER:\n-        case XML_SCHEMAS_NINTEGER:\n-        case XML_SCHEMAS_NNINTEGER:\n-        case XML_SCHEMAS_LONG:\n-        case XML_SCHEMAS_BYTE:\n-        case XML_SCHEMAS_SHORT:\n-        case XML_SCHEMAS_INT:\n-        case XML_SCHEMAS_UINT:\n-        case XML_SCHEMAS_ULONG:\n-        case XML_SCHEMAS_USHORT:\n-        case XML_SCHEMAS_UBYTE: {\n-                const xmlChar *cur = value;\n-                xmlSchemaValDecimal decimal;\n-                xmlChar sign = '+';\n-\n-                memset(&decimal, 0, sizeof(decimal));\n-\n-                if (cur == NULL)\n-                    goto return1;\n-         if (normOnTheFly)\n-            while IS_WSP_BLANK_CH(*cur) cur++;\n-                if (*cur == '-') {\n-                    sign = '-';\n-                    cur++;\n-                } else if (*cur == '+')\n-                    cur++;\n-                ret = xmlSchemaParseUInt(&cur, &decimal);\n-                \/* add sign *\/\n-                if (ret < 0)\n-                    goto valIntegerReturn1;\n-                decimal.str[0] = sign;\n-        if (normOnTheFly)\n-            while IS_WSP_BLANK_CH(*cur) cur++;\n-                if (*cur != 0)\n-                    goto valIntegerReturn1;\n-                if (type->builtInType == XML_SCHEMAS_NPINTEGER)\n-                {\n-                    if(xmlSchemaValDecimalCompareWithInteger(&decimal, 0) > 0)\n-                        goto valIntegerReturn1;\n-                }\n-                else if (type->builtInType == XML_SCHEMAS_PINTEGER)\n-                {\n-                    if (sign == '-')\n-                        goto valIntegerReturn1;\n-                    if (xmlSchemaValDecimalCompareWithInteger(&decimal, 0) <= 0)\n-                        goto valIntegerReturn1;\n-                }\n-                else if (type->builtInType == XML_SCHEMAS_NINTEGER)\n-                {\n-                    if (xmlSchemaValDecimalCompareWithInteger(&decimal, 0) >= 0)\n-                        goto valIntegerReturn1;\n-                }\n-                else if (type->builtInType == XML_SCHEMAS_NNINTEGER)\n-                {\n-                    if (xmlSchemaValDecimalCompareWithInteger(&decimal, 0) < 0)\n-                        goto valIntegerReturn1;\n-                }\n-                else if(type->builtInType == XML_SCHEMAS_LONG)\n-                {\n-                    \/* (u)int64_t may not be available on 32 bit platform, just use decimal *\/\n-                    xmlSchemaValDecimal tmpDecimal;\n-                    static const char maxLong[] = \"+9223372036854775807.0\";\n-                    static const char minLong[] = \"-9223372036854775808.0\";\n-                    tmpDecimal.fractionalPlaces = 1;\n-                    tmpDecimal.integralPlaces = 19;\n-                    tmpDecimal.str = BAD_CAST maxLong;\n-                    if (xmlSchemaValDecimalCompare(&decimal, &tmpDecimal) > 0)\n-                        goto valIntegerReturn1;\n-                    tmpDecimal.str = BAD_CAST minLong;\n-                    if (xmlSchemaValDecimalCompare(&decimal, &tmpDecimal) < 0)\n-                        goto valIntegerReturn1;\n-                }\n-                else if(type->builtInType == XML_SCHEMAS_ULONG)\n-                {\n-                    xmlSchemaValDecimal tmpDecimal;\n-                    static const char maxULong[] = \"+18446744073709551615.0\";\n-                    tmpDecimal.fractionalPlaces = 1;\n-                    tmpDecimal.integralPlaces = 20;\n-                    tmpDecimal.str = (xmlChar*)maxULong;\n-                    if (xmlSchemaValDecimalCompare(&decimal, &tmpDecimal) > 0)\n-                        goto valIntegerReturn1;\n-                    if (xmlSchemaValDecimalCompareWithInteger(&decimal, 0) < 0)\n-                        goto valIntegerReturn1;\n-                }\n-                else if(type->builtInType == XML_SCHEMAS_INT)\n-                {\n-                    if (xmlSchemaValDecimalCompareWithInteger(&decimal, 0x7fffffff) > 0) \/* INT32_MAX *\/\n-                        goto valIntegerReturn1;\n-                    if (xmlSchemaValDecimalCompareWithInteger(&decimal, -0x7fffffff-1) < 0) \/* INT32_MIN *\/\n-                        goto valIntegerReturn1;\n-                }\n-                else if(type->builtInType == XML_SCHEMAS_SHORT)\n-                {\n-                    if (xmlSchemaValDecimalCompareWithInteger(&decimal, 0x7fff) > 0) \/* INT16_MAX *\/\n-                        goto valIntegerReturn1;\n-                    if (xmlSchemaValDecimalCompareWithInteger(&decimal, -0x8000) < 0) \/* INT16_MIN *\/\n-                        goto valIntegerReturn1;\n-                }\n-                else if(type->builtInType == XML_SCHEMAS_BYTE)\n-                {if (xmlSchemaValDecimalCompareWithInteger(&decimal, 0x7f) > 0) \/* INT8_MAX *\/\n-                        goto valIntegerReturn1;\n-                    if (xmlSchemaValDecimalCompareWithInteger(&decimal, -0x80) < 0) \/* INT8_MIN *\/\n-                        goto valIntegerReturn1;\n-                }\n-                else if(type->builtInType == XML_SCHEMAS_UINT)\n-                {\n-                    xmlSchemaValDecimal tmpDecimal;\n-                    static const char maxUInt[] = \"+4294967295.0\";\n-                    tmpDecimal.fractionalPlaces = 1;\n-                    tmpDecimal.integralPlaces = 10;\n-                    tmpDecimal.str = (xmlChar*)maxUInt;\n-                    if (xmlSchemaValDecimalCompare(&decimal, &tmpDecimal) > 0)\n-                        goto valIntegerReturn1;\n-                    if (xmlSchemaValDecimalCompareWithInteger(&decimal, 0) < 0)\n-                        goto valIntegerReturn1;\n-                }\n-                else if(type->builtInType == XML_SCHEMAS_USHORT)\n-                {\n-                    if (xmlSchemaValDecimalCompareWithInteger(&decimal, 0xffff) > 0) \/* UINT16_MAX *\/\n-                        goto valIntegerReturn1;\n-                    if (xmlSchemaValDecimalCompareWithInteger(&decimal, 0) < 0)\n-                        goto valIntegerReturn1;\n-                }\n-                else if(type->builtInType == XML_SCHEMAS_UBYTE)\n-                {\n-                    if (xmlSchemaValDecimalCompareWithInteger(&decimal, 0xff) > 0) \/* UINT8_MAX *\/\n-                        goto valIntegerReturn1;\n-                    if (xmlSchemaValDecimalCompareWithInteger(&decimal, 0) < 0)\n-                        goto valIntegerReturn1;\n-                }\n-                if (val != NULL) {\n-                    v = xmlSchemaNewValue(type->builtInType);\n-                    if (v != NULL) {\n-                        v->value.decimal = decimal;\n-                        *val = v;\n-                    }\n-                }\n-                else if(decimal.str != NULL)\n-                {\n-                    xmlFree(decimal.str);\n-                }\n-                goto return0;\n-            valIntegerReturn1:\n-                if(decimal.str != NULL)\n-                {\n-                    xmlFree(decimal.str);\n-                }\n-                goto return1;\n-            }\n-    }\n-\n-  done:\n-    if (norm != NULL)\n-        xmlFree(norm);\n-    return (ret);\n-  return3:\n-    if (norm != NULL)\n-        xmlFree(norm);\n-    return (3);\n-  return1:\n-    if (norm != NULL)\n-        xmlFree(norm);\n-    return (1);\n-  return0:\n-    if (norm != NULL)\n-        xmlFree(norm);\n-    return (0);\n-  error:\n-    if (norm != NULL)\n-        xmlFree(norm);\n-    return (-1);\n-}\n-\n-\/**\n- * xmlSchemaValPredefTypeNode:\n- * @type: the predefined type\n- * @value: the value to check\n- * @val:  the return computed value\n- * @node:  the node containing the value\n- *\n- * Check that a value conforms to the lexical space of the predefined type.\n- * if true a value is computed and returned in @val.\n- *\n- * Returns 0 if this validates, a positive error code number otherwise\n- *         and -1 in case of internal or API error.\n- *\/\n-int\n-xmlSchemaValPredefTypeNode(xmlSchemaTypePtr type, const xmlChar *value,\n-                       xmlSchemaValPtr *val, xmlNodePtr node) {\n-    return(xmlSchemaValAtomicType(type, value, val, node, 0,\n-    XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 1, 0));\n-}\n-\n-\/**\n- * xmlSchemaValPredefTypeNodeNoNorm:\n- * @type: the predefined type\n- * @value: the value to check\n- * @val:  the return computed value\n- * @node:  the node containing the value\n- *\n- * Check that a value conforms to the lexical space of the predefined type.\n- * if true a value is computed and returned in @val.\n- * This one does apply any normalization to the value.\n- *\n- * Returns 0 if this validates, a positive error code number otherwise\n- *         and -1 in case of internal or API error.\n- *\/\n-int\n-xmlSchemaValPredefTypeNodeNoNorm(xmlSchemaTypePtr type, const xmlChar *value,\n-                 xmlSchemaValPtr *val, xmlNodePtr node) {\n-    return(xmlSchemaValAtomicType(type, value, val, node, 1,\n-    XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 0, 1));\n-}\n-\n-\/**\n- * xmlSchemaValidatePredefinedType:\n- * @type: the predefined type\n- * @value: the value to check\n- * @val:  the return computed value\n- *\n- * Check that a value conforms to the lexical space of the predefined type.\n- * if true a value is computed and returned in @val.\n- *\n- * Returns 0 if this validates, a positive error code number otherwise\n- *         and -1 in case of internal or API error.\n- *\/\n-int\n-xmlSchemaValidatePredefinedType(xmlSchemaTypePtr type, const xmlChar *value,\n-                            xmlSchemaValPtr *val) {\n-    return(xmlSchemaValPredefTypeNode(type, value, val, NULL));\n-}\n-\n-\/**\n- * xmlSchemaCompareDecimals:\n- * @x:  a first decimal value\n- * @y:  a second decimal value\n- *\n- * Compare 2 decimals\n- *\n- * Returns -1 if x < y, 0 if x == y, 1 if x > y and -2 in case of error\n- *\/\n-static int\n-xmlSchemaCompareDecimals(xmlSchemaValPtr x, xmlSchemaValPtr y)\n-{\n-    int res = xmlSchemaValDecimalCompare(&x->value.decimal, &y->value.decimal);\n-    if(res > 0)\n-    {\n-        return 1;\n-    }\n-    if(res < 0)\n-    {\n-        return -1;\n-    }\n-    return 0;\n-}\n-\n-\/**\n- * xmlSchemaCompareDurations:\n- * @x:  a first duration value\n- * @y:  a second duration value\n- *\n- * Compare 2 durations\n- *\n- * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in\n- * case of error\n- *\/\n-static int\n-xmlSchemaCompareDurations(xmlSchemaValPtr x, xmlSchemaValPtr y)\n-{\n-    long carry, mon, day;\n-    double sec;\n-    int invert = 1;\n-    long xmon, xday, myear, minday, maxday;\n-    static const long dayRange [2][12] = {\n-        { 0, 28, 59, 89, 120, 150, 181, 212, 242, 273, 303, 334, },\n-        { 0, 31, 62, 92, 123, 153, 184, 215, 245, 276, 306, 337} };\n-\n-    if ((x == NULL) || (y == NULL))\n-        return -2;\n-\n-    \/* months *\/\n-    mon = x->value.dur.mon - y->value.dur.mon;\n-\n-    \/* seconds *\/\n-    sec = x->value.dur.sec - y->value.dur.sec;\n-    carry = (long)(sec \/ SECS_PER_DAY);\n-    sec -= ((double)carry) * SECS_PER_DAY;\n-\n-    \/* days *\/\n-    day = x->value.dur.day - y->value.dur.day + carry;\n-\n-    \/* easy test *\/\n-    if (mon == 0) {\n-        if (day == 0)\n-            if (sec == 0.0)\n-                return 0;\n-            else if (sec < 0.0)\n-                return -1;\n-            else\n-                return 1;\n-        else if (day < 0)\n-            return -1;\n-        else\n-            return 1;\n-    }\n-\n-    if (mon > 0) {\n-        if ((day >= 0) && (sec >= 0.0))\n-            return 1;\n-        else {\n-            xmon = mon;\n-            xday = -day;\n-        }\n-    } else if ((day <= 0) && (sec <= 0.0)) {\n-        return -1;\n-    } else {\n-    invert = -1;\n-        xmon = -mon;\n-        xday = day;\n-    }\n-\n-    myear = xmon \/ 12;\n-    if (myear == 0) {\n-    minday = 0;\n-    maxday = 0;\n-    } else {\n-        if (myear > LONG_MAX \/ 366)\n-            return -2;\n-        \/* FIXME: This doesn't take leap year exceptions every 100\/400 years\n-           into account. *\/\n-    maxday = 365 * myear + (myear + 3) \/ 4;\n-        \/* FIXME: Needs to be calculated separately *\/\n-    minday = maxday - 1;\n-    }\n-\n-    xmon = xmon % 12;\n-    minday += dayRange[0][xmon];\n-    maxday += dayRange[1][xmon];\n-\n-    if ((maxday == minday) && (maxday == xday))\n-    return(0); \/* can this really happen ? *\/\n-    if (maxday < xday)\n-        return(-invert);\n-    if (minday > xday)\n-        return(invert);\n-\n-    \/* indeterminate *\/\n-    return 2;\n-}\n-\n-\/*\n- * macros for adding date\/times and durations\n- *\/\n-#define FQUOTIENT(a,b)                  (floor(((double)a\/(double)b)))\n-#define MODULO(a,b)                     (a - FQUOTIENT(a,b) * b)\n-#define FQUOTIENT_RANGE(a,low,high)     (FQUOTIENT((a-low),(high-low)))\n-#define MODULO_RANGE(a,low,high)        ((MODULO((a-low),(high-low)))+low)\n-\n-\/**\n- * xmlSchemaDupVal:\n- * @v: the #xmlSchemaValPtr value to duplicate\n- *\n- * Makes a copy of @v. The calling program is responsible for freeing\n- * the returned value.\n- *\n- * returns a pointer to a duplicated #xmlSchemaValPtr or NULL if error.\n- *\/\n-static xmlSchemaValPtr\n-xmlSchemaDupVal (xmlSchemaValPtr v)\n-{\n-    xmlSchemaValPtr ret = xmlSchemaNewValue(v->type);\n-    if (ret == NULL)\n-        return NULL;\n-\n-    memcpy(ret, v, sizeof(xmlSchemaVal));\n-    ret->next = NULL;\n-    return ret;\n-}\n-\n-\/**\n- * xmlSchemaCopyValue:\n- * @val:  the precomputed value to be copied\n- *\n- * Copies the precomputed value. This duplicates any string within.\n- *\n- * Returns the copy or NULL if a copy for a data-type is not implemented.\n- *\/\n-xmlSchemaValPtr\n-xmlSchemaCopyValue(xmlSchemaValPtr val)\n-{\n-    xmlSchemaValPtr ret = NULL, prev = NULL, cur;\n-\n-    \/*\n-    * Copy the string values.\n-    *\/\n-    while (val != NULL) {\n-    switch (val->type) {\n-        case XML_SCHEMAS_ANYTYPE:\n-        case XML_SCHEMAS_IDREFS:\n-        case XML_SCHEMAS_ENTITIES:\n-        case XML_SCHEMAS_NMTOKENS:\n-        xmlSchemaFreeValue(ret);\n-        return (NULL);\n-        case XML_SCHEMAS_ANYSIMPLETYPE:\n-        case XML_SCHEMAS_STRING:\n-        case XML_SCHEMAS_NORMSTRING:\n-        case XML_SCHEMAS_TOKEN:\n-        case XML_SCHEMAS_LANGUAGE:\n-        case XML_SCHEMAS_NAME:\n-        case XML_SCHEMAS_NCNAME:\n-        case XML_SCHEMAS_ID:\n-        case XML_SCHEMAS_IDREF:\n-        case XML_SCHEMAS_ENTITY:\n-        case XML_SCHEMAS_NMTOKEN:\n-        case XML_SCHEMAS_ANYURI:\n-        cur = xmlSchemaDupVal(val);\n-        if (val->value.str != NULL)\n-            cur->value.str = xmlStrdup(BAD_CAST val->value.str);\n-        break;\n-        case XML_SCHEMAS_QNAME:\n-        case XML_SCHEMAS_NOTATION:\n-        cur = xmlSchemaDupVal(val);\n-        if (val->value.qname.name != NULL)\n-            cur->value.qname.name =\n-                    xmlStrdup(BAD_CAST val->value.qname.name);\n-        if (val->value.qname.uri != NULL)\n-            cur->value.qname.uri =\n-                    xmlStrdup(BAD_CAST val->value.qname.uri);\n-        break;\n-        case XML_SCHEMAS_HEXBINARY:\n-        cur = xmlSchemaDupVal(val);\n-        if (val->value.hex.str != NULL)\n-            cur->value.hex.str = xmlStrdup(BAD_CAST val->value.hex.str);\n-        break;\n-        case XML_SCHEMAS_BASE64BINARY:\n-        cur = xmlSchemaDupVal(val);\n-        if (val->value.base64.str != NULL)\n-            cur->value.base64.str =\n-                    xmlStrdup(BAD_CAST val->value.base64.str);\n-        break;\n-            case XML_SCHEMAS_DECIMAL:\n-            case XML_SCHEMAS_INTEGER:\n-            case XML_SCHEMAS_PINTEGER:\n-            case XML_SCHEMAS_NPINTEGER:\n-            case XML_SCHEMAS_NINTEGER:\n-            case XML_SCHEMAS_NNINTEGER:\n-            case XML_SCHEMAS_LONG:\n-            case XML_SCHEMAS_BYTE:\n-            case XML_SCHEMAS_SHORT:\n-            case XML_SCHEMAS_INT:\n-            case XML_SCHEMAS_UINT:\n-            case XML_SCHEMAS_ULONG:\n-            case XML_SCHEMAS_USHORT:\n-            case XML_SCHEMAS_UBYTE:\n-                cur = xmlSchemaDupVal(val);\n-                if (val->value.decimal.str != NULL)\n-                    cur->value.decimal.str = xmlStrdup(BAD_CAST val->value.decimal.str);\n-        break;\n-        default:\n-        cur = xmlSchemaDupVal(val);\n-        break;\n-    }\n-    if (ret == NULL)\n-        ret = cur;\n-    else\n-        prev->next = cur;\n-    prev = cur;\n-    val = val->next;\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * _xmlSchemaDateAdd:\n- * @dt: an #xmlSchemaValPtr\n- * @dur: an #xmlSchemaValPtr of type #XS_DURATION\n- *\n- * Compute a new date\/time from @dt and @dur. This function assumes @dt\n- * is either #XML_SCHEMAS_DATETIME, #XML_SCHEMAS_DATE, #XML_SCHEMAS_GYEARMONTH,\n- * or #XML_SCHEMAS_GYEAR. The returned #xmlSchemaVal is the same type as\n- * @dt. The calling program is responsible for freeing the returned value.\n- *\n- * Returns a pointer to a new #xmlSchemaVal or NULL if error.\n- *\/\n-static xmlSchemaValPtr\n-_xmlSchemaDateAdd (xmlSchemaValPtr dt, xmlSchemaValPtr dur)\n-{\n-    xmlSchemaValPtr ret, tmp;\n-    long carry, tempdays, temp;\n-    xmlSchemaValDatePtr r, d;\n-    xmlSchemaValDurationPtr u;\n-\n-    if ((dt == NULL) || (dur == NULL))\n-        return NULL;\n-\n-    ret = xmlSchemaNewValue(dt->type);\n-    if (ret == NULL)\n-        return NULL;\n-\n-    \/* make a copy so we don't alter the original value *\/\n-    tmp = xmlSchemaDupVal(dt);\n-    if (tmp == NULL) {\n-        xmlSchemaFreeValue(ret);\n-        return NULL;\n-    }\n-\n-    r = &(ret->value.date);\n-    d = &(tmp->value.date);\n-    u = &(dur->value.dur);\n-\n-    \/* normalization *\/\n-    if (d->mon == 0)\n-        d->mon = 1;\n-\n-    \/* normalize for time zone offset *\/\n-    u->sec -= (d->tzo * 60);\n-    d->tzo = 0;\n-\n-    \/* normalization *\/\n-    if (d->day == 0)\n-        d->day = 1;\n-\n-    \/* month *\/\n-    carry  = d->mon + u->mon;\n-    r->mon = (unsigned int) MODULO_RANGE(carry, 1, 13);\n-    carry  = (long) FQUOTIENT_RANGE(carry, 1, 13);\n-\n-    \/* year (may be modified later) *\/\n-    r->year = d->year + carry;\n-    if (r->year == 0) {\n-        if (d->year > 0)\n-            r->year--;\n-        else\n-            r->year++;\n-    }\n-\n-    \/* time zone *\/\n-    r->tzo     = d->tzo;\n-    r->tz_flag = d->tz_flag;\n-\n-    \/* seconds *\/\n-    r->sec = d->sec + u->sec;\n-    carry  = (long) FQUOTIENT((long)r->sec, 60);\n-    if (r->sec != 0.0) {\n-        r->sec = MODULO(r->sec, 60.0);\n-    }\n-\n-    \/* minute *\/\n-    carry += d->min;\n-    r->min = (unsigned int) MODULO(carry, 60);\n-    carry  = (long) FQUOTIENT(carry, 60);\n-\n-    \/* hours *\/\n-    carry  += d->hour;\n-    r->hour = (unsigned int) MODULO(carry, 24);\n-    carry   = (long)FQUOTIENT(carry, 24);\n-\n-    \/*\n-     * days\n-     * Note we use tempdays because the temporary values may need more\n-     * than 5 bits\n-     *\/\n-    if ((VALID_YEAR(r->year)) && (VALID_MONTH(r->mon)) &&\n-                  (d->day > MAX_DAYINMONTH(r->year, r->mon)))\n-        tempdays = MAX_DAYINMONTH(r->year, r->mon);\n-    else if (d->day < 1)\n-        tempdays = 1;\n-    else\n-        tempdays = d->day;\n-\n-    tempdays += u->day + carry;\n-\n-    while (1) {\n-        if (tempdays < 1) {\n-            long tmon = (long) MODULO_RANGE((int)r->mon-1, 1, 13);\n-            long tyr  = r->year + (long)FQUOTIENT_RANGE((int)r->mon-1, 1, 13);\n-            if (tyr == 0)\n-                tyr--;\n-        \/*\n-         * Coverity detected an overrun in daysInMonth\n-         * of size 12 at position 12 with index variable \"((r)->mon - 1)\"\n-         *\/\n-        if (tmon < 1)\n-            tmon = 1;\n-        if (tmon > 12)\n-            tmon = 12;\n-            tempdays += MAX_DAYINMONTH(tyr, tmon);\n-            carry = -1;\n-        } else if (VALID_YEAR(r->year) && VALID_MONTH(r->mon) &&\n-                   tempdays > (long) MAX_DAYINMONTH(r->year, r->mon)) {\n-            tempdays = tempdays - MAX_DAYINMONTH(r->year, r->mon);\n-            carry = 1;\n-        } else\n-            break;\n-\n-        temp = r->mon + carry;\n-        r->mon = (unsigned int) MODULO_RANGE(temp, 1, 13);\n-        r->year = r->year + (long) FQUOTIENT_RANGE(temp, 1, 13);\n-        if (r->year == 0) {\n-            if (temp < 1)\n-                r->year--;\n-            else\n-                r->year++;\n-    }\n-    }\n-\n-    r->day = tempdays;\n-\n-    \/*\n-     * adjust the date\/time type to the date values\n-     *\/\n-    if (ret->type != XML_SCHEMAS_DATETIME) {\n-        if ((r->hour) || (r->min) || (r->sec))\n-            ret->type = XML_SCHEMAS_DATETIME;\n-        else if (ret->type != XML_SCHEMAS_DATE) {\n-            if ((r->mon != 1) && (r->day != 1))\n-                ret->type = XML_SCHEMAS_DATE;\n-            else if ((ret->type != XML_SCHEMAS_GYEARMONTH) && (r->mon != 1))\n-                ret->type = XML_SCHEMAS_GYEARMONTH;\n-        }\n-    }\n-\n-    xmlSchemaFreeValue(tmp);\n-\n-    return ret;\n-}\n-\n-\/**\n- * xmlSchemaDateNormalize:\n- * @dt: an #xmlSchemaValPtr of a date\/time type value.\n- * @offset: number of seconds to adjust @dt by.\n- *\n- * Normalize @dt to GMT time. The @offset parameter is subtracted from\n- * the return value is a time-zone offset is present on @dt.\n- *\n- * Returns a normalized copy of @dt or NULL if error.\n- *\/\n-static xmlSchemaValPtr\n-xmlSchemaDateNormalize (xmlSchemaValPtr dt, double offset)\n-{\n-    xmlSchemaValPtr dur, ret;\n-\n-    if (dt == NULL)\n-        return NULL;\n-\n-    if (((dt->type != XML_SCHEMAS_TIME) &&\n-         (dt->type != XML_SCHEMAS_DATETIME) &&\n-     (dt->type != XML_SCHEMAS_DATE)) || (dt->value.date.tzo == 0))\n-        return xmlSchemaDupVal(dt);\n-\n-    dur = xmlSchemaNewValue(XML_SCHEMAS_DURATION);\n-    if (dur == NULL)\n-        return NULL;\n-\n-    dur->value.date.sec -= offset;\n-\n-    ret = _xmlSchemaDateAdd(dt, dur);\n-    if (ret == NULL)\n-        return NULL;\n-\n-    xmlSchemaFreeValue(dur);\n-\n-    \/* ret->value.date.tzo = 0; *\/\n-    return ret;\n-}\n-\n-\/**\n- * _xmlSchemaDateCastYMToDays:\n- * @dt: an #xmlSchemaValPtr\n- *\n- * Convert mon and year of @dt to total number of days. Take the\n- * number of years since (or before) 1 AD and add the number of leap\n- * years. This is a function  because negative\n- * years must be handled a little differently and there is no zero year.\n- *\n- * Returns number of days.\n- *\/\n-static long\n-_xmlSchemaDateCastYMToDays (const xmlSchemaValPtr dt)\n-{\n-    long ret;\n-    int mon;\n-\n-    mon = dt->value.date.mon;\n-    if (mon <= 0) mon = 1; \/* normalization *\/\n-\n-    if (dt->value.date.year <= 0)\n-        ret = (dt->value.date.year * 365) +\n-              (((dt->value.date.year+1)\/4)-((dt->value.date.year+1)\/100)+\n-               ((dt->value.date.year+1)\/400)) +\n-              DAY_IN_YEAR(0, mon, dt->value.date.year);\n-    else\n-        ret = ((dt->value.date.year-1) * 365) +\n-              (((dt->value.date.year-1)\/4)-((dt->value.date.year-1)\/100)+\n-               ((dt->value.date.year-1)\/400)) +\n-              DAY_IN_YEAR(0, mon, dt->value.date.year);\n-\n-    return ret;\n-}\n-\n-\/**\n- * TIME_TO_NUMBER:\n- * @dt:  an #xmlSchemaValPtr\n- *\n- * Calculates the number of seconds in the time portion of @dt.\n- *\n- * Returns seconds.\n- *\/\n-#define TIME_TO_NUMBER(dt)                              \\\n-    ((double)((dt->value.date.hour * SECS_PER_HOUR) +   \\\n-              (dt->value.date.min * SECS_PER_MIN) +    \\\n-              (dt->value.date.tzo * SECS_PER_MIN)) +    \\\n-               dt->value.date.sec)\n-\n-\/**\n- * xmlSchemaCompareDates:\n- * @x:  a first date\/time value\n- * @y:  a second date\/time value\n- *\n- * Compare 2 date\/times\n- *\n- * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in\n- * case of error\n- *\/\n-static int\n-xmlSchemaCompareDates (xmlSchemaValPtr x, xmlSchemaValPtr y)\n-{\n-    unsigned char xmask, ymask, xor_mask, and_mask;\n-    xmlSchemaValPtr p1, p2, q1, q2;\n-    long p1d, p2d, q1d, q2d;\n-\n-    if ((x == NULL) || (y == NULL))\n-        return -2;\n-\n-    if ((x->value.date.year > LONG_MAX \/ 366) ||\n-        (x->value.date.year < LONG_MIN \/ 366) ||\n-        (y->value.date.year > LONG_MAX \/ 366) ||\n-        (y->value.date.year < LONG_MIN \/ 366)) {\n-        \/* Possible overflow when converting to days. *\/\n-        return -2;\n-    }\n-\n-    if (x->value.date.tz_flag) {\n-\n-        if (!y->value.date.tz_flag) {\n-            p1 = xmlSchemaDateNormalize(x, 0);\n-            if (p1 == NULL)\n-                return -2;\n-            p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day;\n-            \/* normalize y + 14:00 *\/\n-            q1 = xmlSchemaDateNormalize(y, (14 * SECS_PER_HOUR));\n-            if (q1 == NULL) {\n-        xmlSchemaFreeValue(p1);\n-                return -2;\n-            }\n-\n-            q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day;\n-            if (p1d < q1d) {\n-        xmlSchemaFreeValue(p1);\n-        xmlSchemaFreeValue(q1);\n-                return -1;\n-        } else if (p1d == q1d) {\n-                double sec;\n-\n-                sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);\n-                if (sec < 0.0) {\n-            xmlSchemaFreeValue(p1);\n-            xmlSchemaFreeValue(q1);\n-                    return -1;\n-        } else {\n-            int ret = 0;\n-                    \/* normalize y - 14:00 *\/\n-                    q2 = xmlSchemaDateNormalize(y, -(14 * SECS_PER_HOUR));\n-                    if (q2 == NULL) {\n-                        xmlSchemaFreeValue(p1);\n-                        xmlSchemaFreeValue(q1);\n-                        return -2;\n-                    }\n-                    q2d = _xmlSchemaDateCastYMToDays(q2) + q2->value.date.day;\n-                    if (p1d > q2d)\n-                        ret = 1;\n-                    else if (p1d == q2d) {\n-                        sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q2);\n-                        if (sec > 0.0)\n-                            ret = 1;\n-                        else\n-                            ret = 2; \/* indeterminate *\/\n-                    }\n-            xmlSchemaFreeValue(p1);\n-            xmlSchemaFreeValue(q1);\n-            xmlSchemaFreeValue(q2);\n-            if (ret != 0)\n-                return(ret);\n-                }\n-            } else {\n-        xmlSchemaFreeValue(p1);\n-        xmlSchemaFreeValue(q1);\n-        }\n-        }\n-    } else if (y->value.date.tz_flag) {\n-        q1 = xmlSchemaDateNormalize(y, 0);\n-        if (q1 == NULL)\n-            return -2;\n-        q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day;\n-\n-        \/* normalize x - 14:00 *\/\n-        p1 = xmlSchemaDateNormalize(x, -(14 * SECS_PER_HOUR));\n-        if (p1 == NULL) {\n-        xmlSchemaFreeValue(q1);\n-            return -2;\n-        }\n-        p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day;\n-\n-        if (p1d < q1d) {\n-        xmlSchemaFreeValue(p1);\n-        xmlSchemaFreeValue(q1);\n-            return -1;\n-    } else if (p1d == q1d) {\n-            double sec;\n-\n-            sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);\n-            if (sec < 0.0) {\n-        xmlSchemaFreeValue(p1);\n-        xmlSchemaFreeValue(q1);\n-                return -1;\n-        } else {\n-            int ret = 0;\n-                \/* normalize x + 14:00 *\/\n-                p2 = xmlSchemaDateNormalize(x, (14 * SECS_PER_HOUR));\n-                if (p2 == NULL) {\n-                    xmlSchemaFreeValue(p1);\n-                    xmlSchemaFreeValue(q1);\n-                    return -2;\n-                }\n-                p2d = _xmlSchemaDateCastYMToDays(p2) + p2->value.date.day;\n-\n-                if (p2d > q1d) {\n-                    ret = 1;\n-        } else if (p2d == q1d) {\n-                    sec = TIME_TO_NUMBER(p2) - TIME_TO_NUMBER(q1);\n-                    if (sec > 0.0)\n-                        ret = 1;\n-                    else\n-                        ret = 2; \/* indeterminate *\/\n-                }\n-        xmlSchemaFreeValue(p1);\n-        xmlSchemaFreeValue(q1);\n-        xmlSchemaFreeValue(p2);\n-        if (ret != 0)\n-            return(ret);\n-            }\n-    } else {\n-        xmlSchemaFreeValue(p1);\n-        xmlSchemaFreeValue(q1);\n-        }\n-    }\n-\n-    \/*\n-     * if the same type then calculate the difference\n-     *\/\n-    if (x->type == y->type) {\n-        int ret = 0;\n-        q1 = xmlSchemaDateNormalize(y, 0);\n-        if (q1 == NULL)\n-            return -2;\n-        q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day;\n-\n-        p1 = xmlSchemaDateNormalize(x, 0);\n-        if (p1 == NULL) {\n-        xmlSchemaFreeValue(q1);\n-            return -2;\n-        }\n-        p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day;\n-\n-        if (p1d < q1d) {\n-            ret = -1;\n-    } else if (p1d > q1d) {\n-            ret = 1;\n-    } else {\n-            double sec;\n-\n-            sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);\n-            if (sec < 0.0)\n-                ret = -1;\n-            else if (sec > 0.0)\n-                ret = 1;\n-\n-        }\n-    xmlSchemaFreeValue(p1);\n-    xmlSchemaFreeValue(q1);\n-        return(ret);\n-    }\n-\n-    switch (x->type) {\n-        case XML_SCHEMAS_DATETIME:\n-            xmask = 0xf;\n-            break;\n-        case XML_SCHEMAS_DATE:\n-            xmask = 0x7;\n-            break;\n-        case XML_SCHEMAS_GYEAR:\n-            xmask = 0x1;\n-            break;\n-        case XML_SCHEMAS_GMONTH:\n-            xmask = 0x2;\n-            break;\n-        case XML_SCHEMAS_GDAY:\n-            xmask = 0x3;\n-            break;\n-        case XML_SCHEMAS_GYEARMONTH:\n-            xmask = 0x3;\n-            break;\n-        case XML_SCHEMAS_GMONTHDAY:\n-            xmask = 0x6;\n-            break;\n-        case XML_SCHEMAS_TIME:\n-            xmask = 0x8;\n-            break;\n-        default:\n-            xmask = 0;\n-            break;\n-    }\n-\n-    switch (y->type) {\n-        case XML_SCHEMAS_DATETIME:\n-            ymask = 0xf;\n-            break;\n-        case XML_SCHEMAS_DATE:\n-            ymask = 0x7;\n-            break;\n-        case XML_SCHEMAS_GYEAR:\n-            ymask = 0x1;\n-            break;\n-        case XML_SCHEMAS_GMONTH:\n-            ymask = 0x2;\n-            break;\n-        case XML_SCHEMAS_GDAY:\n-            ymask = 0x3;\n-            break;\n-        case XML_SCHEMAS_GYEARMONTH:\n-            ymask = 0x3;\n-            break;\n-        case XML_SCHEMAS_GMONTHDAY:\n-            ymask = 0x6;\n-            break;\n-        case XML_SCHEMAS_TIME:\n-            ymask = 0x8;\n-            break;\n-        default:\n-            ymask = 0;\n-            break;\n-    }\n-\n-    xor_mask = xmask ^ ymask;           \/* mark type differences *\/\n-    and_mask = xmask & ymask;           \/* mark field specification *\/\n-\n-    \/* year *\/\n-    if (xor_mask & 1)\n-        return 2; \/* indeterminate *\/\n-    else if (and_mask & 1) {\n-        if (x->value.date.year < y->value.date.year)\n-            return -1;\n-        else if (x->value.date.year > y->value.date.year)\n-            return 1;\n-    }\n-\n-    \/* month *\/\n-    if (xor_mask & 2)\n-        return 2; \/* indeterminate *\/\n-    else if (and_mask & 2) {\n-        if (x->value.date.mon < y->value.date.mon)\n-            return -1;\n-        else if (x->value.date.mon > y->value.date.mon)\n-            return 1;\n-    }\n-\n-    \/* day *\/\n-    if (xor_mask & 4)\n-        return 2; \/* indeterminate *\/\n-    else if (and_mask & 4) {\n-        if (x->value.date.day < y->value.date.day)\n-            return -1;\n-        else if (x->value.date.day > y->value.date.day)\n-            return 1;\n-    }\n-\n-    \/* time *\/\n-    if (xor_mask & 8)\n-        return 2; \/* indeterminate *\/\n-    else if (and_mask & 8) {\n-        if (x->value.date.hour < y->value.date.hour)\n-            return -1;\n-        else if (x->value.date.hour > y->value.date.hour)\n-            return 1;\n-        else if (x->value.date.min < y->value.date.min)\n-            return -1;\n-        else if (x->value.date.min > y->value.date.min)\n-            return 1;\n-        else if (x->value.date.sec < y->value.date.sec)\n-            return -1;\n-        else if (x->value.date.sec > y->value.date.sec)\n-            return 1;\n-    }\n-\n-    return 0;\n-}\n-\n-\/**\n- * xmlSchemaComparePreserveReplaceStrings:\n- * @x:  a first string value\n- * @y:  a second string value\n- * @invert: inverts the result if x < y or x > y.\n- *\n- * Compare 2 string for their normalized values.\n- * @x is a string with whitespace of \"preserve\", @y is\n- * a string with a whitespace of \"replace\". I.e. @x could\n- * be an \"xsd:string\" and @y an \"xsd:normalizedString\".\n- *\n- * Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in\n- * case of error\n- *\/\n-static int\n-xmlSchemaComparePreserveReplaceStrings(const xmlChar *x,\n-                       const xmlChar *y,\n-                       int invert)\n-{\n-    int tmp;\n-\n-    while ((*x != 0) && (*y != 0)) {\n-    if (IS_WSP_REPLACE_CH(*y)) {\n-        if (! IS_WSP_SPACE_CH(*x)) {\n-        if ((*x - 0x20) < 0) {\n-            if (invert)\n-            return(1);\n-            else\n-            return(-1);\n-        } else {\n-            if (invert)\n-            return(-1);\n-            else\n-            return(1);\n-        }\n-        }\n-    } else {\n-        tmp = *x - *y;\n-        if (tmp < 0) {\n-        if (invert)\n-            return(1);\n-        else\n-            return(-1);\n-        }\n-        if (tmp > 0) {\n-        if (invert)\n-            return(-1);\n-        else\n-            return(1);\n-        }\n-    }\n-    x++;\n-    y++;\n-    }\n-    if (*x != 0) {\n-    if (invert)\n-        return(-1);\n-    else\n-        return(1);\n-    }\n-    if (*y != 0) {\n-    if (invert)\n-        return(1);\n-    else\n-        return(-1);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaComparePreserveCollapseStrings:\n- * @x:  a first string value\n- * @y:  a second string value\n- *\n- * Compare 2 string for their normalized values.\n- * @x is a string with whitespace of \"preserve\", @y is\n- * a string with a whitespace of \"collapse\". I.e. @x could\n- * be an \"xsd:string\" and @y an \"xsd:normalizedString\".\n- *\n- * Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in\n- * case of error\n- *\/\n-static int\n-xmlSchemaComparePreserveCollapseStrings(const xmlChar *x,\n-                        const xmlChar *y,\n-                    int invert)\n-{\n-    int tmp;\n-\n-    \/*\n-    * Skip leading blank chars of the collapsed string.\n-    *\/\n-    while IS_WSP_BLANK_CH(*y)\n-    y++;\n-\n-    while ((*x != 0) && (*y != 0)) {\n-    if IS_WSP_BLANK_CH(*y) {\n-        if (! IS_WSP_SPACE_CH(*x)) {\n-        \/*\n-        * The yv character would have been replaced to 0x20.\n-        *\/\n-        if ((*x - 0x20) < 0) {\n-            if (invert)\n-            return(1);\n-            else\n-            return(-1);\n-        } else {\n-            if (invert)\n-            return(-1);\n-            else\n-            return(1);\n-        }\n-        }\n-        x++;\n-        y++;\n-        \/*\n-        * Skip contiguous blank chars of the collapsed string.\n-        *\/\n-        while IS_WSP_BLANK_CH(*y)\n-        y++;\n-    } else {\n-        tmp = *x++ - *y++;\n-        if (tmp < 0) {\n-        if (invert)\n-            return(1);\n-        else\n-            return(-1);\n-        }\n-        if (tmp > 0) {\n-        if (invert)\n-            return(-1);\n-        else\n-            return(1);\n-        }\n-    }\n-    }\n-    if (*x != 0) {\n-     if (invert)\n-         return(-1);\n-     else\n-         return(1);\n-    }\n-    if (*y != 0) {\n-    \/*\n-    * Skip trailing blank chars of the collapsed string.\n-    *\/\n-    while IS_WSP_BLANK_CH(*y)\n-        y++;\n-    if (*y != 0) {\n-        if (invert)\n-        return(1);\n-        else\n-        return(-1);\n-    }\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaComparePreserveCollapseStrings:\n- * @x:  a first string value\n- * @y:  a second string value\n- *\n- * Compare 2 string for their normalized values.\n- * @x is a string with whitespace of \"preserve\", @y is\n- * a string with a whitespace of \"collapse\". I.e. @x could\n- * be an \"xsd:string\" and @y an \"xsd:normalizedString\".\n- *\n- * Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in\n- * case of error\n- *\/\n-static int\n-xmlSchemaCompareReplaceCollapseStrings(const xmlChar *x,\n-                       const xmlChar *y,\n-                       int invert)\n-{\n-    int tmp;\n-\n-    \/*\n-    * Skip leading blank chars of the collapsed string.\n-    *\/\n-    while IS_WSP_BLANK_CH(*y)\n-    y++;\n-\n-    while ((*x != 0) && (*y != 0)) {\n-    if IS_WSP_BLANK_CH(*y) {\n-        if (! IS_WSP_BLANK_CH(*x)) {\n-        \/*\n-        * The yv character would have been replaced to 0x20.\n-        *\/\n-        if ((*x - 0x20) < 0) {\n-            if (invert)\n-            return(1);\n-            else\n-            return(-1);\n-        } else {\n-            if (invert)\n-            return(-1);\n-            else\n-            return(1);\n-        }\n-        }\n-        x++;\n-        y++;\n-        \/*\n-        * Skip contiguous blank chars of the collapsed string.\n-        *\/\n-        while IS_WSP_BLANK_CH(*y)\n-        y++;\n-    } else {\n-        if IS_WSP_BLANK_CH(*x) {\n-        \/*\n-        * The xv character would have been replaced to 0x20.\n-        *\/\n-        if ((0x20 - *y) < 0) {\n-            if (invert)\n-            return(1);\n-            else\n-            return(-1);\n-        } else {\n-            if (invert)\n-            return(-1);\n-            else\n-            return(1);\n-        }\n-        }\n-        tmp = *x++ - *y++;\n-        if (tmp < 0)\n-        return(-1);\n-        if (tmp > 0)\n-        return(1);\n-    }\n-    }\n-    if (*x != 0) {\n-     if (invert)\n-         return(-1);\n-     else\n-         return(1);\n-    }\n-    if (*y != 0) {\n-    \/*\n-    * Skip trailing blank chars of the collapsed string.\n-    *\/\n-    while IS_WSP_BLANK_CH(*y)\n-        y++;\n-    if (*y != 0) {\n-        if (invert)\n-        return(1);\n-        else\n-        return(-1);\n-    }\n-    }\n-    return(0);\n-}\n-\n-\n-\/**\n- * xmlSchemaCompareReplacedStrings:\n- * @x:  a first string value\n- * @y:  a second string value\n- *\n- * Compare 2 string for their normalized values.\n- *\n- * Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in\n- * case of error\n- *\/\n-static int\n-xmlSchemaCompareReplacedStrings(const xmlChar *x,\n-                const xmlChar *y)\n-{\n-    int tmp;\n-\n-    while ((*x != 0) && (*y != 0)) {\n-    if IS_WSP_BLANK_CH(*y) {\n-        if (! IS_WSP_BLANK_CH(*x)) {\n-        if ((*x - 0x20) < 0)\n-            return(-1);\n-        else\n-            return(1);\n-        }\n-    } else {\n-        if IS_WSP_BLANK_CH(*x) {\n-        if ((0x20 - *y) < 0)\n-            return(-1);\n-        else\n-            return(1);\n-        }\n-        tmp = *x - *y;\n-        if (tmp < 0)\n-        return(-1);\n-        if (tmp > 0)\n-        return(1);\n-    }\n-    x++;\n-    y++;\n-    }\n-    if (*x != 0)\n-        return(1);\n-    if (*y != 0)\n-        return(-1);\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaCompareNormStrings:\n- * @x:  a first string value\n- * @y:  a second string value\n- *\n- * Compare 2 string for their normalized values.\n- *\n- * Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in\n- * case of error\n- *\/\n-static int\n-xmlSchemaCompareNormStrings(const xmlChar *x,\n-                const xmlChar *y) {\n-    int tmp;\n-\n-    while (IS_BLANK_CH(*x)) x++;\n-    while (IS_BLANK_CH(*y)) y++;\n-    while ((*x != 0) && (*y != 0)) {\n-    if (IS_BLANK_CH(*x)) {\n-        if (!IS_BLANK_CH(*y)) {\n-        tmp = *x - *y;\n-        return(tmp);\n-        }\n-        while (IS_BLANK_CH(*x)) x++;\n-        while (IS_BLANK_CH(*y)) y++;\n-    } else {\n-        tmp = *x++ - *y++;\n-        if (tmp < 0)\n-        return(-1);\n-        if (tmp > 0)\n-        return(1);\n-    }\n-    }\n-    if (*x != 0) {\n-    while (IS_BLANK_CH(*x)) x++;\n-    if (*x != 0)\n-        return(1);\n-    }\n-    if (*y != 0) {\n-    while (IS_BLANK_CH(*y)) y++;\n-    if (*y != 0)\n-        return(-1);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlSchemaCompareFloats:\n- * @x:  a first float or double value\n- * @y:  a second float or double value\n- *\n- * Compare 2 values\n- *\n- * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in\n- * case of error\n- *\/\n-static int\n-xmlSchemaCompareFloats(xmlSchemaValPtr x, xmlSchemaValPtr y) {\n-    double d1, d2;\n-\n-    if ((x == NULL) || (y == NULL))\n-    return(-2);\n-\n-    \/*\n-     * Cast everything to doubles.\n-     *\/\n-    if (x->type == XML_SCHEMAS_DOUBLE)\n-    d1 = x->value.d;\n-    else if (x->type == XML_SCHEMAS_FLOAT)\n-    d1 = x->value.f;\n-    else\n-    return(-2);\n-\n-    if (y->type == XML_SCHEMAS_DOUBLE)\n-    d2 = y->value.d;\n-    else if (y->type == XML_SCHEMAS_FLOAT)\n-    d2 = y->value.f;\n-    else\n-    return(-2);\n-\n-    \/*\n-     * Check for special cases.\n-     *\/\n-    if (xmlXPathIsNaN(d1)) {\n-    if (xmlXPathIsNaN(d2))\n-        return(0);\n-    return(1);\n-    }\n-    if (xmlXPathIsNaN(d2))\n-    return(-1);\n-    if (d1 == xmlXPathPINF) {\n-    if (d2 == xmlXPathPINF)\n-        return(0);\n-        return(1);\n-    }\n-    if (d2 == xmlXPathPINF)\n-        return(-1);\n-    if (d1 == xmlXPathNINF) {\n-    if (d2 == xmlXPathNINF)\n-        return(0);\n-        return(-1);\n-    }\n-    if (d2 == xmlXPathNINF)\n-        return(1);\n-\n-    \/*\n-     * basic tests, the last one we should have equality, but\n-     * portability is more important than speed and handling\n-     * NaN or Inf in a portable way is always a challenge, so ...\n-     *\/\n-    if (d1 < d2)\n-    return(-1);\n-    if (d1 > d2)\n-    return(1);\n-    if (d1 == d2)\n-    return(0);\n-    return(2);\n-}\n-\n-\/**\n- * xmlSchemaCompareValues:\n- * @x:  a first value\n- * @xvalue: the first value as a string (optional)\n- * @xwtsp: the whitespace type\n- * @y:  a second value\n- * @xvalue: the second value as a string (optional)\n- * @ywtsp: the whitespace type\n- *\n- * Compare 2 values\n- *\n- * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, 3 if not\n- * comparable and -2 in case of error\n- *\/\n-static int\n-xmlSchemaCompareValuesInternal(xmlSchemaValType xtype,\n-                   xmlSchemaValPtr x,\n-                   const xmlChar *xvalue,\n-                   xmlSchemaWhitespaceValueType xws,\n-                   xmlSchemaValType ytype,\n-                   xmlSchemaValPtr y,\n-                   const xmlChar *yvalue,\n-                   xmlSchemaWhitespaceValueType yws)\n-{\n-    switch (xtype) {\n-    case XML_SCHEMAS_UNKNOWN:\n-    case XML_SCHEMAS_ANYTYPE:\n-        return(-2);\n-        case XML_SCHEMAS_INTEGER:\n-        case XML_SCHEMAS_NPINTEGER:\n-        case XML_SCHEMAS_NINTEGER:\n-        case XML_SCHEMAS_NNINTEGER:\n-        case XML_SCHEMAS_PINTEGER:\n-        case XML_SCHEMAS_INT:\n-        case XML_SCHEMAS_UINT:\n-        case XML_SCHEMAS_LONG:\n-        case XML_SCHEMAS_ULONG:\n-        case XML_SCHEMAS_SHORT:\n-        case XML_SCHEMAS_USHORT:\n-        case XML_SCHEMAS_BYTE:\n-        case XML_SCHEMAS_UBYTE:\n-    case XML_SCHEMAS_DECIMAL:\n-        if ((x == NULL) || (y == NULL))\n-        return(-2);\n-        if (ytype == xtype)\n-        return(xmlSchemaCompareDecimals(x, y));\n-        if ((ytype == XML_SCHEMAS_DECIMAL) ||\n-        (ytype == XML_SCHEMAS_INTEGER) ||\n-        (ytype == XML_SCHEMAS_NPINTEGER) ||\n-        (ytype == XML_SCHEMAS_NINTEGER) ||\n-        (ytype == XML_SCHEMAS_NNINTEGER) ||\n-        (ytype == XML_SCHEMAS_PINTEGER) ||\n-        (ytype == XML_SCHEMAS_INT) ||\n-        (ytype == XML_SCHEMAS_UINT) ||\n-        (ytype == XML_SCHEMAS_LONG) ||\n-        (ytype == XML_SCHEMAS_ULONG) ||\n-        (ytype == XML_SCHEMAS_SHORT) ||\n-        (ytype == XML_SCHEMAS_USHORT) ||\n-        (ytype == XML_SCHEMAS_BYTE) ||\n-        (ytype == XML_SCHEMAS_UBYTE))\n-        return(xmlSchemaCompareDecimals(x, y));\n-        return(-2);\n-        case XML_SCHEMAS_DURATION:\n-        if ((x == NULL) || (y == NULL))\n-        return(-2);\n-        if (ytype == XML_SCHEMAS_DURATION)\n-                return(xmlSchemaCompareDurations(x, y));\n-            return(-2);\n-        case XML_SCHEMAS_TIME:\n-        case XML_SCHEMAS_GDAY:\n-        case XML_SCHEMAS_GMONTH:\n-        case XML_SCHEMAS_GMONTHDAY:\n-        case XML_SCHEMAS_GYEAR:\n-        case XML_SCHEMAS_GYEARMONTH:\n-        case XML_SCHEMAS_DATE:\n-        case XML_SCHEMAS_DATETIME:\n-        if ((x == NULL) || (y == NULL))\n-        return(-2);\n-            if ((ytype == XML_SCHEMAS_DATETIME)  ||\n-                (ytype == XML_SCHEMAS_TIME)      ||\n-                (ytype == XML_SCHEMAS_GDAY)      ||\n-                (ytype == XML_SCHEMAS_GMONTH)    ||\n-                (ytype == XML_SCHEMAS_GMONTHDAY) ||\n-                (ytype == XML_SCHEMAS_GYEAR)     ||\n-                (ytype == XML_SCHEMAS_DATE)      ||\n-                (ytype == XML_SCHEMAS_GYEARMONTH))\n-                return (xmlSchemaCompareDates(x, y));\n-            return (-2);\n-    \/*\n-    * Note that we will support comparison of string types against\n-    * anySimpleType as well.\n-    *\/\n-    case XML_SCHEMAS_ANYSIMPLETYPE:\n-    case XML_SCHEMAS_STRING:\n-        case XML_SCHEMAS_NORMSTRING:\n-        case XML_SCHEMAS_TOKEN:\n-        case XML_SCHEMAS_LANGUAGE:\n-        case XML_SCHEMAS_NMTOKEN:\n-        case XML_SCHEMAS_NAME:\n-        case XML_SCHEMAS_NCNAME:\n-        case XML_SCHEMAS_ID:\n-        case XML_SCHEMAS_IDREF:\n-        case XML_SCHEMAS_ENTITY:\n-        case XML_SCHEMAS_ANYURI:\n-    {\n-        const xmlChar *xv, *yv;\n-\n-        if (x == NULL)\n-        xv = xvalue;\n-        else\n-        xv = x->value.str;\n-        if (y == NULL)\n-        yv = yvalue;\n-        else\n-        yv = y->value.str;\n-        \/*\n-        * TODO: Compare those against QName.\n-        *\/\n-        if (ytype == XML_SCHEMAS_QNAME) {\n-        \/* TODO *\/\n-        if (y == NULL)\n-            return(-2);\n-        return (-2);\n-        }\n-            if ((ytype == XML_SCHEMAS_ANYSIMPLETYPE) ||\n-        (ytype == XML_SCHEMAS_STRING) ||\n-        (ytype == XML_SCHEMAS_NORMSTRING) ||\n-                (ytype == XML_SCHEMAS_TOKEN) ||\n-                (ytype == XML_SCHEMAS_LANGUAGE) ||\n-                (ytype == XML_SCHEMAS_NMTOKEN) ||\n-                (ytype == XML_SCHEMAS_NAME) ||\n-                (ytype == XML_SCHEMAS_NCNAME) ||\n-                (ytype == XML_SCHEMAS_ID) ||\n-                (ytype == XML_SCHEMAS_IDREF) ||\n-                (ytype == XML_SCHEMAS_ENTITY) ||\n-                (ytype == XML_SCHEMAS_ANYURI)) {\n-\n-        if (xws == XML_SCHEMA_WHITESPACE_PRESERVE) {\n-\n-            if (yws == XML_SCHEMA_WHITESPACE_PRESERVE) {\n-            \/* TODO: What about x < y or x > y. *\/\n-            if (xmlStrEqual(xv, yv))\n-                return (0);\n-            else\n-                return (2);\n-            } else if (yws == XML_SCHEMA_WHITESPACE_REPLACE)\n-            return (xmlSchemaComparePreserveReplaceStrings(xv, yv, 0));\n-            else if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE)\n-            return (xmlSchemaComparePreserveCollapseStrings(xv, yv, 0));\n-\n-        } else if (xws == XML_SCHEMA_WHITESPACE_REPLACE) {\n-\n-            if (yws == XML_SCHEMA_WHITESPACE_PRESERVE)\n-            return (xmlSchemaComparePreserveReplaceStrings(yv, xv, 1));\n-            if (yws == XML_SCHEMA_WHITESPACE_REPLACE)\n-            return (xmlSchemaCompareReplacedStrings(xv, yv));\n-            if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE)\n-            return (xmlSchemaCompareReplaceCollapseStrings(xv, yv, 0));\n-\n-        } else if (xws == XML_SCHEMA_WHITESPACE_COLLAPSE) {\n-\n-            if (yws == XML_SCHEMA_WHITESPACE_PRESERVE)\n-            return (xmlSchemaComparePreserveCollapseStrings(yv, xv, 1));\n-            if (yws == XML_SCHEMA_WHITESPACE_REPLACE)\n-            return (xmlSchemaCompareReplaceCollapseStrings(yv, xv, 1));\n-            if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE)\n-            return (xmlSchemaCompareNormStrings(xv, yv));\n-        } else\n-            return (-2);\n-\n-        }\n-            return (-2);\n-    }\n-        case XML_SCHEMAS_QNAME:\n-    case XML_SCHEMAS_NOTATION:\n-        if ((x == NULL) || (y == NULL))\n-        return(-2);\n-            if ((ytype == XML_SCHEMAS_QNAME) ||\n-        (ytype == XML_SCHEMAS_NOTATION)) {\n-        if ((xmlStrEqual(x->value.qname.name, y->value.qname.name)) &&\n-            (xmlStrEqual(x->value.qname.uri, y->value.qname.uri)))\n-            return(0);\n-        return(2);\n-        }\n-        return (-2);\n-        case XML_SCHEMAS_FLOAT:\n-        case XML_SCHEMAS_DOUBLE:\n-        if ((x == NULL) || (y == NULL))\n-        return(-2);\n-            if ((ytype == XML_SCHEMAS_FLOAT) ||\n-                (ytype == XML_SCHEMAS_DOUBLE))\n-                return (xmlSchemaCompareFloats(x, y));\n-            return (-2);\n-        case XML_SCHEMAS_BOOLEAN:\n-        if ((x == NULL) || (y == NULL))\n-        return(-2);\n-            if (ytype == XML_SCHEMAS_BOOLEAN) {\n-        if (x->value.b == y->value.b)\n-            return(0);\n-        if (x->value.b == 0)\n-            return(-1);\n-        return(1);\n-        }\n-        return (-2);\n-        case XML_SCHEMAS_HEXBINARY:\n-        if ((x == NULL) || (y == NULL))\n-        return(-2);\n-            if (ytype == XML_SCHEMAS_HEXBINARY) {\n-            if (x->value.hex.total == y->value.hex.total) {\n-            int ret = xmlStrcmp(x->value.hex.str, y->value.hex.str);\n-            if (ret > 0)\n-            return(1);\n-            else if (ret == 0)\n-            return(0);\n-        }\n-        else if (x->value.hex.total > y->value.hex.total)\n-            return(1);\n-\n-        return(-1);\n-            }\n-            return (-2);\n-        case XML_SCHEMAS_BASE64BINARY:\n-        if ((x == NULL) || (y == NULL))\n-        return(-2);\n-            if (ytype == XML_SCHEMAS_BASE64BINARY) {\n-                if (x->value.base64.total == y->value.base64.total) {\n-                    int ret = xmlStrcmp(x->value.base64.str,\n-                                y->value.base64.str);\n-                    if (ret > 0)\n-                        return(1);\n-                    else if (ret == 0)\n-                        return(0);\n-            else\n-                return(-1);\n-                }\n-                else if (x->value.base64.total > y->value.base64.total)\n-                    return(1);\n-                else\n-                    return(-1);\n-            }\n-            return (-2);\n-        case XML_SCHEMAS_IDREFS:\n-        case XML_SCHEMAS_ENTITIES:\n-        case XML_SCHEMAS_NMTOKENS:\n-        \/* TODO *\/\n-        break;\n-    }\n-    return -2;\n-}\n-\n-\/**\n- * xmlSchemaCompareValues:\n- * @x:  a first value\n- * @y:  a second value\n- *\n- * Compare 2 values\n- *\n- * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in\n- * case of error\n- *\/\n-int\n-xmlSchemaCompareValues(xmlSchemaValPtr x, xmlSchemaValPtr y) {\n-    xmlSchemaWhitespaceValueType xws, yws;\n-\n-    if ((x == NULL) || (y == NULL))\n-        return(-2);\n-    if (x->type == XML_SCHEMAS_STRING)\n-    xws = XML_SCHEMA_WHITESPACE_PRESERVE;\n-    else if (x->type == XML_SCHEMAS_NORMSTRING)\n-        xws = XML_SCHEMA_WHITESPACE_REPLACE;\n-    else\n-        xws = XML_SCHEMA_WHITESPACE_COLLAPSE;\n-\n-    if (y->type == XML_SCHEMAS_STRING)\n-    yws = XML_SCHEMA_WHITESPACE_PRESERVE;\n-    else if (y->type == XML_SCHEMAS_NORMSTRING)\n-        yws = XML_SCHEMA_WHITESPACE_REPLACE;\n-    else\n-        yws = XML_SCHEMA_WHITESPACE_COLLAPSE;\n-\n-    return(xmlSchemaCompareValuesInternal(x->type, x, NULL, xws, y->type,\n-    y, NULL, yws));\n-}\n-\n-\/**\n- * xmlSchemaCompareValuesWhtsp:\n- * @x:  a first value\n- * @xws: the whitespace value of x\n- * @y:  a second value\n- * @yws: the whitespace value of y\n- *\n- * Compare 2 values\n- *\n- * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in\n- * case of error\n- *\/\n-int\n-xmlSchemaCompareValuesWhtsp(xmlSchemaValPtr x,\n-                xmlSchemaWhitespaceValueType xws,\n-                xmlSchemaValPtr y,\n-                xmlSchemaWhitespaceValueType yws)\n-{\n-    if ((x == NULL) || (y == NULL))\n-    return(-2);\n-    return(xmlSchemaCompareValuesInternal(x->type, x, NULL, xws, y->type,\n-    y, NULL, yws));\n-}\n-\n-\/**\n- * xmlSchemaCompareValuesWhtspExt:\n- * @x:  a first value\n- * @xws: the whitespace value of x\n- * @y:  a second value\n- * @yws: the whitespace value of y\n- *\n- * Compare 2 values\n- *\n- * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in\n- * case of error\n- *\/\n-static int\n-xmlSchemaCompareValuesWhtspExt(xmlSchemaValType xtype,\n-                   xmlSchemaValPtr x,\n-                   const xmlChar *xvalue,\n-                   xmlSchemaWhitespaceValueType xws,\n-                   xmlSchemaValType ytype,\n-                   xmlSchemaValPtr y,\n-                   const xmlChar *yvalue,\n-                   xmlSchemaWhitespaceValueType yws)\n-{\n-    return(xmlSchemaCompareValuesInternal(xtype, x, xvalue, xws, ytype, y,\n-    yvalue, yws));\n-}\n-\n-\/**\n- * xmlSchemaNormLen:\n- * @value:  a string\n- *\n- * Computes the UTF8 length of the normalized value of the string\n- *\n- * Returns the length or -1 in case of error.\n- *\/\n-static int\n-xmlSchemaNormLen(const xmlChar *value) {\n-    const xmlChar *utf;\n-    int ret = 0;\n-\n-    if (value == NULL)\n-    return(-1);\n-    utf = value;\n-    while (IS_BLANK_CH(*utf)) utf++;\n-    while (*utf != 0) {\n-    if (utf[0] & 0x80) {\n-        if ((utf[1] & 0xc0) != 0x80)\n-        return(-1);\n-        if ((utf[0] & 0xe0) == 0xe0) {\n-        if ((utf[2] & 0xc0) != 0x80)\n-            return(-1);\n-        if ((utf[0] & 0xf0) == 0xf0) {\n-            if ((utf[0] & 0xf8) != 0xf0 || (utf[3] & 0xc0) != 0x80)\n-            return(-1);\n-            utf += 4;\n-        } else {\n-            utf += 3;\n-        }\n-        } else {\n-        utf += 2;\n-        }\n-    } else if (IS_BLANK_CH(*utf)) {\n-        while (IS_BLANK_CH(*utf)) utf++;\n-        if (*utf == 0)\n-        break;\n-    } else {\n-        utf++;\n-    }\n-    ret++;\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlSchemaGetFacetValueAsULong:\n- * @facet: an schemas type facet\n- *\n- * Extract the value of a facet\n- *\n- * Returns the value as a long\n- *\/\n-unsigned long\n-xmlSchemaGetFacetValueAsULong(xmlSchemaFacetPtr facet)\n-{\n-    \/*\n-    * TODO: Check if this is a decimal.\n-    *\/\n-    char *discard;\n-    if (facet == NULL || facet->val == NULL)\n-        return 0;\n-    return strtoul((const char*)facet->val->value.decimal.str+1, &discard, 10);\n-}\n-\n-\/**\n- * xmlSchemaValidateListSimpleTypeFacet:\n- * @facet:  the facet to check\n- * @value:  the lexical repr of the value to validate\n- * @actualLen:  the number of list items\n- * @expectedLen: the resulting expected number of list items\n- *\n- * Checks the value of a list simple type against a facet.\n- *\n- * Returns 0 if the value is valid, a positive error code\n- * number otherwise and -1 in case of an internal error.\n- *\/\n-int\n-xmlSchemaValidateListSimpleTypeFacet(xmlSchemaFacetPtr facet,\n-                     const xmlChar *value,\n-                     unsigned long actualLen,\n-                     unsigned long *expectedLen)\n-{\n-    if (facet == NULL)\n-        return(-1);\n-    \/*\n-    * TODO: Check if this will work with large numbers.\n-    * (compare value.decimal.mi and value.decimal.hi as well?).\n-    *\/\n-    if (facet->type == XML_SCHEMA_FACET_LENGTH) {\n-        if (actualLen != xmlSchemaGetFacetValueAsULong(facet)) {\n-        if (expectedLen != NULL)\n-                *expectedLen = xmlSchemaGetFacetValueAsULong(facet);\n-        return (XML_SCHEMAV_CVC_LENGTH_VALID);\n-    }\n-    } else if (facet->type == XML_SCHEMA_FACET_MINLENGTH) {\n-        if (actualLen < xmlSchemaGetFacetValueAsULong(facet)) {\n-        if (expectedLen != NULL)\n-                *expectedLen = xmlSchemaGetFacetValueAsULong(facet);\n-        return (XML_SCHEMAV_CVC_MINLENGTH_VALID);\n-    }\n-    } else if (facet->type == XML_SCHEMA_FACET_MAXLENGTH) {\n-        if (actualLen > xmlSchemaGetFacetValueAsULong(facet)) {\n-        if (expectedLen != NULL)\n-                *expectedLen = xmlSchemaGetFacetValueAsULong(facet);\n-        return (XML_SCHEMAV_CVC_MAXLENGTH_VALID);\n-    }\n-    } else\n-    \/*\n-    * NOTE: That we can pass NULL as xmlSchemaValPtr to\n-    * xmlSchemaValidateFacet, since the remaining facet types\n-    * are: XML_SCHEMA_FACET_PATTERN, XML_SCHEMA_FACET_ENUMERATION.\n-    *\/\n-    return(xmlSchemaValidateFacet(NULL, facet, value, NULL));\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaValidateLengthFacet:\n- * @type:  the built-in type\n- * @facet:  the facet to check\n- * @value:  the lexical repr. of the value to be validated\n- * @val:  the precomputed value\n- * @ws: the whitespace type of the value\n- * @length: the actual length of the value\n- *\n- * Checka a value against a \"length\", \"minLength\" and \"maxLength\"\n- * facet; sets @length to the computed length of @value.\n- *\n- * Returns 0 if the value is valid, a positive error code\n- * otherwise and -1 in case of an internal or API error.\n- *\/\n-static int\n-xmlSchemaValidateLengthFacetInternal(xmlSchemaFacetPtr facet,\n-                     xmlSchemaValType valType,\n-                     const xmlChar *value,\n-                     xmlSchemaValPtr val,\n-                     unsigned long *length,\n-                     xmlSchemaWhitespaceValueType ws)\n-{\n-    unsigned int len = 0;\n-\n-    if ((length == NULL) || (facet == NULL))\n-        return (-1);\n-    *length = 0;\n-    if ((facet->type != XML_SCHEMA_FACET_LENGTH) &&\n-    (facet->type != XML_SCHEMA_FACET_MAXLENGTH) &&\n-    (facet->type != XML_SCHEMA_FACET_MINLENGTH))\n-    return (-1);\n-\n-    \/*\n-    * TODO: length, maxLength and minLength must be of type\n-    * nonNegativeInteger only. Check if decimal is used somehow.\n-    *\/\n-    if ((facet->val == NULL) ||\n-    ((facet->val->type != XML_SCHEMAS_DECIMAL) &&\n-     (facet->val->type != XML_SCHEMAS_NNINTEGER)) ||\n-    !(xmlSchemaValDecimalIsInteger(&facet->val->value.decimal)))\n- {\n-    return(-1);\n-    }\n-    if ((val != NULL) && (val->type == XML_SCHEMAS_HEXBINARY))\n-    len = val->value.hex.total;\n-    else if ((val != NULL) && (val->type == XML_SCHEMAS_BASE64BINARY))\n-    len = val->value.base64.total;\n-    else {\n-    switch (valType) {\n-        case XML_SCHEMAS_STRING:\n-        case XML_SCHEMAS_NORMSTRING:\n-        if (ws == XML_SCHEMA_WHITESPACE_UNKNOWN) {\n-            \/*\n-            * This is to ensure API compatibility with the old\n-            * xmlSchemaValidateLengthFacet(). Anyway, this was and\n-            * is not the correct handling.\n-            * TODO: Get rid of this case somehow.\n-            *\/\n-            if (valType == XML_SCHEMAS_STRING)\n-            len = xmlUTF8Strlen(value);\n-            else\n-            len = xmlSchemaNormLen(value);\n-        } else if (value != NULL) {\n-            if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)\n-            len = xmlSchemaNormLen(value);\n-            else\n-            \/*\n-            * Should be OK for \"preserve\" as well.\n-            *\/\n-            len = xmlUTF8Strlen(value);\n-        }\n-        break;\n-        case XML_SCHEMAS_IDREF:\n-        case XML_SCHEMAS_TOKEN:\n-        case XML_SCHEMAS_LANGUAGE:\n-        case XML_SCHEMAS_NMTOKEN:\n-        case XML_SCHEMAS_NAME:\n-        case XML_SCHEMAS_NCNAME:\n-        case XML_SCHEMAS_ID:\n-        \/*\n-        * FIXME: What exactly to do with anyURI?\n-        *\/\n-        case XML_SCHEMAS_ANYURI:\n-        if (value != NULL)\n-            len = xmlSchemaNormLen(value);\n-        break;\n-        case XML_SCHEMAS_QNAME:\n-        case XML_SCHEMAS_NOTATION:\n-        \/*\n-        * For QName and NOTATION, those facets are\n-        * deprecated and should be ignored.\n-        *\/\n-        return (0);\n-        default:\n-        \/* TODO *\/\n-                break;\n-    }\n-    }\n-    *length = (unsigned long) len;\n-    \/*\n-    * TODO: Return the whole expected value. (This may be possible now with xmlSchemaValDecimalCompareWithInteger)\n-    *\/\n-    if (facet->type == XML_SCHEMA_FACET_LENGTH) {\n-        if (len != xmlSchemaGetFacetValueAsULong(facet))\n-        return(XML_SCHEMAV_CVC_LENGTH_VALID);\n-    } else if (facet->type == XML_SCHEMA_FACET_MINLENGTH) {\n-        if (len < xmlSchemaGetFacetValueAsULong(facet))\n-        return(XML_SCHEMAV_CVC_MINLENGTH_VALID);\n-    } else {\n-        if (len > xmlSchemaGetFacetValueAsULong(facet))\n-        return(XML_SCHEMAV_CVC_MAXLENGTH_VALID);\n-    }\n-\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaValidateLengthFacet:\n- * @type:  the built-in type\n- * @facet:  the facet to check\n- * @value:  the lexical repr. of the value to be validated\n- * @val:  the precomputed value\n- * @length: the actual length of the value\n- *\n- * Checka a value against a \"length\", \"minLength\" and \"maxLength\"\n- * facet; sets @length to the computed length of @value.\n- *\n- * Returns 0 if the value is valid, a positive error code\n- * otherwise and -1 in case of an internal or API error.\n- *\/\n-int\n-xmlSchemaValidateLengthFacet(xmlSchemaTypePtr type,\n-                 xmlSchemaFacetPtr facet,\n-                 const xmlChar *value,\n-                 xmlSchemaValPtr val,\n-                 unsigned long *length)\n-{\n-    if (type == NULL)\n-        return(-1);\n-    return (xmlSchemaValidateLengthFacetInternal(facet,\n-    type->builtInType, value, val, length,\n-    XML_SCHEMA_WHITESPACE_UNKNOWN));\n-}\n-\n-\/**\n- * xmlSchemaValidateLengthFacetWhtsp:\n- * @facet:  the facet to check\n- * @valType:  the built-in type\n- * @value:  the lexical repr. of the value to be validated\n- * @val:  the precomputed value\n- * @ws: the whitespace type of the value\n- * @length: the actual length of the value\n- *\n- * Checka a value against a \"length\", \"minLength\" and \"maxLength\"\n- * facet; sets @length to the computed length of @value.\n- *\n- * Returns 0 if the value is valid, a positive error code\n- * otherwise and -1 in case of an internal or API error.\n- *\/\n-int\n-xmlSchemaValidateLengthFacetWhtsp(xmlSchemaFacetPtr facet,\n-                  xmlSchemaValType valType,\n-                  const xmlChar *value,\n-                  xmlSchemaValPtr val,\n-                  unsigned long *length,\n-                  xmlSchemaWhitespaceValueType ws)\n-{\n-    return (xmlSchemaValidateLengthFacetInternal(facet, valType, value, val,\n-    length, ws));\n-}\n-\n-\/**\n- * xmlSchemaValidateFacetInternal:\n- * @facet:  the facet to check\n- * @fws: the whitespace type of the facet's value\n- * @valType: the built-in type of the value\n- * @value:  the lexical repr of the value to validate\n- * @val:  the precomputed value\n- * @ws: the whitespace type of the value\n- *\n- * Check a value against a facet condition\n- *\n- * Returns 0 if the element is schemas valid, a positive error code\n- *     number otherwise and -1 in case of internal or API error.\n- *\/\n-static int\n-xmlSchemaValidateFacetInternal(xmlSchemaFacetPtr facet,\n-                   xmlSchemaWhitespaceValueType fws,\n-                   xmlSchemaValType valType,\n-                   const xmlChar *value,\n-                   xmlSchemaValPtr val,\n-                   xmlSchemaWhitespaceValueType ws)\n-{\n-    int ret;\n-\n-    if (facet == NULL)\n-    return(-1);\n-\n-    switch (facet->type) {\n-    case XML_SCHEMA_FACET_PATTERN:\n-        \/*\n-        * NOTE that for patterns, the @value needs to be the normalized\n-        * value, *not* the lexical initial value or the canonical value.\n-        *\/\n-        if (value == NULL)\n-        return(-1);\n-        \/*\n-        * If string-derived type, regexp must be tested on the value space of\n-        * the datatype.\n-        * See https:\/\/www.w3.org\/TR\/xmlschema-2\/#rf-pattern\n-        *\/\n-        if (val &&\n-                val->value.str &&\n-                ((val->type >= XML_SCHEMAS_STRING &&\n-                  val->type <= XML_SCHEMAS_NORMSTRING) ||\n-                 (val->type >= XML_SCHEMAS_TOKEN &&\n-                  val->type <= XML_SCHEMAS_ENTITIES &&\n-                  val->type != XML_SCHEMAS_QNAME))) {\n-                value = val->value.str;\n-            }\n-        ret = xmlRegexpExec(facet->regexp, value);\n-        if (ret == 1)\n-        return(0);\n-        if (ret == 0)\n-        return(XML_SCHEMAV_CVC_PATTERN_VALID);\n-        return(ret);\n-    case XML_SCHEMA_FACET_MAXEXCLUSIVE:\n-        ret = xmlSchemaCompareValues(val, facet->val);\n-        if (ret == -2)\n-        return(-1);\n-        if (ret == -1)\n-        return(0);\n-        return(XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID);\n-    case XML_SCHEMA_FACET_MAXINCLUSIVE:\n-        ret = xmlSchemaCompareValues(val, facet->val);\n-        if (ret == -2)\n-        return(-1);\n-        if ((ret == -1) || (ret == 0))\n-        return(0);\n-        return(XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID);\n-    case XML_SCHEMA_FACET_MINEXCLUSIVE:\n-        ret = xmlSchemaCompareValues(val, facet->val);\n-        if (ret == -2)\n-        return(-1);\n-        if (ret == 1)\n-        return(0);\n-        return(XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID);\n-    case XML_SCHEMA_FACET_MININCLUSIVE:\n-        ret = xmlSchemaCompareValues(val, facet->val);\n-        if (ret == -2)\n-        return(-1);\n-        if ((ret == 1) || (ret == 0))\n-        return(0);\n-        return(XML_SCHEMAV_CVC_MININCLUSIVE_VALID);\n-    case XML_SCHEMA_FACET_WHITESPACE:\n-        \/* TODO whitespaces *\/\n-        \/*\n-        * NOTE: Whitespace should be handled to normalize\n-        * the value to be validated against a the facets;\n-        * not to normalize the value in-between.\n-        *\/\n-        return(0);\n-    case  XML_SCHEMA_FACET_ENUMERATION:\n-        if (ws == XML_SCHEMA_WHITESPACE_UNKNOWN) {\n-        \/*\n-        * This is to ensure API compatibility with the old\n-        * xmlSchemaValidateFacet().\n-        * TODO: Get rid of this case.\n-        *\/\n-        if ((facet->value != NULL) &&\n-            (xmlStrEqual(facet->value, value)))\n-            return(0);\n-        } else {\n-        ret = xmlSchemaCompareValuesWhtspExt(facet->val->type,\n-            facet->val, facet->value, fws, valType, val,\n-            value, ws);\n-        if (ret == -2)\n-            return(-1);\n-        if (ret == 0)\n-            return(0);\n-        }\n-        return(XML_SCHEMAV_CVC_ENUMERATION_VALID);\n-    case XML_SCHEMA_FACET_LENGTH:\n-        \/*\n-        * SPEC (1.3) \"if {primitive type definition} is QName or NOTATION,\n-        * then any {value} is facet-valid.\"\n-        *\/\n-        if ((valType == XML_SCHEMAS_QNAME) ||\n-        (valType == XML_SCHEMAS_NOTATION))\n-        return (0);\n-            \/* Falls through. *\/\n-    case XML_SCHEMA_FACET_MAXLENGTH:\n-    case XML_SCHEMA_FACET_MINLENGTH: {\n-        unsigned int len = 0;\n-\n-        if ((valType == XML_SCHEMAS_QNAME) ||\n-        (valType == XML_SCHEMAS_NOTATION))\n-        return (0);\n-        \/*\n-        * TODO: length, maxLength and minLength must be of type\n-        * nonNegativeInteger only. Check if decimal is used somehow.\n-        *\/\n-        if ((facet->val == NULL) ||\n-        ((facet->val->type != XML_SCHEMAS_DECIMAL) &&\n-         (facet->val->type != XML_SCHEMAS_NNINTEGER)) ||\n-        !xmlSchemaValDecimalIsInteger(&facet->val->value.decimal)) {\n-        return(-1);\n-        }\n-        if ((val != NULL) && (val->type == XML_SCHEMAS_HEXBINARY))\n-        len = val->value.hex.total;\n-        else if ((val != NULL) && (val->type == XML_SCHEMAS_BASE64BINARY))\n-        len = val->value.base64.total;\n-        else {\n-        switch (valType) {\n-            case XML_SCHEMAS_STRING:\n-            case XML_SCHEMAS_NORMSTRING:\n-            if (ws == XML_SCHEMA_WHITESPACE_UNKNOWN) {\n-                \/*\n-                * This is to ensure API compatibility with the old\n-                * xmlSchemaValidateFacet(). Anyway, this was and\n-                * is not the correct handling.\n-                * TODO: Get rid of this case somehow.\n-                *\/\n-                if (valType == XML_SCHEMAS_STRING)\n-                len = xmlUTF8Strlen(value);\n-                else\n-                len = xmlSchemaNormLen(value);\n-            } else if (value != NULL) {\n-                if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)\n-                len = xmlSchemaNormLen(value);\n-                else\n-                \/*\n-                * Should be OK for \"preserve\" as well.\n-                *\/\n-                len = xmlUTF8Strlen(value);\n-            }\n-            break;\n-            case XML_SCHEMAS_IDREF:\n-            case XML_SCHEMAS_TOKEN:\n-            case XML_SCHEMAS_LANGUAGE:\n-            case XML_SCHEMAS_NMTOKEN:\n-            case XML_SCHEMAS_NAME:\n-            case XML_SCHEMAS_NCNAME:\n-            case XML_SCHEMAS_ID:\n-            case XML_SCHEMAS_ANYURI:\n-            if (value != NULL)\n-                len = xmlSchemaNormLen(value);\n-            break;\n-            default:\n-                \/* TODO *\/\n-                        break;\n-        }\n-        }\n-        if (facet->type == XML_SCHEMA_FACET_LENGTH) {\n-                if (len != xmlSchemaGetFacetValueAsULong(facet))\n-            return(XML_SCHEMAV_CVC_LENGTH_VALID);\n-        } else if (facet->type == XML_SCHEMA_FACET_MINLENGTH) {\n-                if (len < xmlSchemaGetFacetValueAsULong(facet))\n-            return(XML_SCHEMAV_CVC_MINLENGTH_VALID);\n-        } else if (len > xmlSchemaGetFacetValueAsULong(facet)) {\n-                return (XML_SCHEMAV_CVC_MAXLENGTH_VALID);\n-        }\n-        break;\n-    }\n-    case XML_SCHEMA_FACET_TOTALDIGITS:\n-    case XML_SCHEMA_FACET_FRACTIONDIGITS:\n-\n-        if ((facet->val == NULL) ||\n-        ((facet->val->type != XML_SCHEMAS_PINTEGER) &&\n-         (facet->val->type != XML_SCHEMAS_NNINTEGER)) ||\n-        !xmlSchemaValDecimalIsInteger(&facet->val->value.decimal)) {\n-        return(-1);\n-        }\n-        if ((val == NULL) ||\n-        ((val->type != XML_SCHEMAS_DECIMAL) &&\n-         (val->type != XML_SCHEMAS_INTEGER) &&\n-         (val->type != XML_SCHEMAS_NPINTEGER) &&\n-         (val->type != XML_SCHEMAS_NINTEGER) &&\n-         (val->type != XML_SCHEMAS_NNINTEGER) &&\n-         (val->type != XML_SCHEMAS_PINTEGER) &&\n-         (val->type != XML_SCHEMAS_INT) &&\n-         (val->type != XML_SCHEMAS_UINT) &&\n-         (val->type != XML_SCHEMAS_LONG) &&\n-         (val->type != XML_SCHEMAS_ULONG) &&\n-         (val->type != XML_SCHEMAS_SHORT) &&\n-         (val->type != XML_SCHEMAS_USHORT) &&\n-         (val->type != XML_SCHEMAS_BYTE) &&\n-         (val->type != XML_SCHEMAS_UBYTE))) {\n-        return(-1);\n-        }\n-        if (facet->type == XML_SCHEMA_FACET_TOTALDIGITS) {\n-                if (xmlSchemaValDecimalGetSignificantDigitCount(&val->value.decimal) > xmlSchemaGetFacetValueAsULong(facet))\n-                return(XML_SCHEMAV_CVC_TOTALDIGITS_VALID);\n-\n-        } else if (facet->type == XML_SCHEMA_FACET_FRACTIONDIGITS) {\n-            if ((xmlSchemaValDecimalIsInteger(&val->value.decimal) ? 0 : val->value.decimal.fractionalPlaces) > xmlSchemaGetFacetValueAsULong(facet))\n-            return(XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID);\n-        }\n-        break;\n-    default:\n-        \/* TODO *\/\n-            break;\n-    }\n-    return(0);\n-\n-}\n-\n-\/**\n- * xmlSchemaValidateFacet:\n- * @base:  the base type\n- * @facet:  the facet to check\n- * @value:  the lexical repr of the value to validate\n- * @val:  the precomputed value\n- *\n- * Check a value against a facet condition\n- *\n- * Returns 0 if the element is schemas valid, a positive error code\n- *     number otherwise and -1 in case of internal or API error.\n- *\/\n-int\n-xmlSchemaValidateFacet(xmlSchemaTypePtr base,\n-                   xmlSchemaFacetPtr facet,\n-                   const xmlChar *value,\n-               xmlSchemaValPtr val)\n-{\n-    \/*\n-    * This tries to ensure API compatibility regarding the old\n-    * xmlSchemaValidateFacet() and the new xmlSchemaValidateFacetInternal() and\n-    * xmlSchemaValidateFacetWhtsp().\n-    *\/\n-    if (val != NULL)\n-    return(xmlSchemaValidateFacetInternal(facet,\n-        XML_SCHEMA_WHITESPACE_UNKNOWN, val->type, value, val,\n-        XML_SCHEMA_WHITESPACE_UNKNOWN));\n-    else if (base != NULL)\n-    return(xmlSchemaValidateFacetInternal(facet,\n-        XML_SCHEMA_WHITESPACE_UNKNOWN, base->builtInType, value, val,\n-        XML_SCHEMA_WHITESPACE_UNKNOWN));\n-    return(-1);\n-}\n-\n-\/**\n- * xmlSchemaValidateFacetWhtsp:\n- * @facet:  the facet to check\n- * @fws: the whitespace type of the facet's value\n- * @valType: the built-in type of the value\n- * @value:  the lexical (or normalized for pattern) repr of the value to validate\n- * @val:  the precomputed value\n- * @ws: the whitespace type of the value\n- *\n- * Check a value against a facet condition. This takes value normalization\n- * according to the specified whitespace types into account.\n- * Note that @value needs to be the *normalized* value if the facet\n- * is of type \"pattern\".\n- *\n- * Returns 0 if the element is schemas valid, a positive error code\n- *     number otherwise and -1 in case of internal or API error.\n- *\/\n-int\n-xmlSchemaValidateFacetWhtsp(xmlSchemaFacetPtr facet,\n-                xmlSchemaWhitespaceValueType fws,\n-                xmlSchemaValType valType,\n-                const xmlChar *value,\n-                xmlSchemaValPtr val,\n-                xmlSchemaWhitespaceValueType ws)\n-{\n-     return(xmlSchemaValidateFacetInternal(facet, fws, valType,\n-     value, val, ws));\n-}\n-\n-#if 0\n-#ifndef DBL_DIG\n-#define DBL_DIG 16\n-#endif\n-#ifndef DBL_EPSILON\n-#define DBL_EPSILON 1E-9\n-#endif\n-\n-#define INTEGER_DIGITS DBL_DIG\n-#define FRACTION_DIGITS (DBL_DIG + 1)\n-#define EXPONENT_DIGITS (3 + 2)\n-\n-\/**\n- * xmlXPathFormatNumber:\n- * @number:     number to format\n- * @buffer:     output buffer\n- * @buffersize: size of output buffer\n- *\n- * Convert the number into a string representation.\n- *\/\n-static void\n-xmlSchemaFormatFloat(double number, char buffer[], int buffersize)\n-{\n-    switch (xmlXPathIsInf(number)) {\n-    case 1:\n-    if (buffersize > (int)sizeof(\"INF\"))\n-        snprintf(buffer, buffersize, \"INF\");\n-    break;\n-    case -1:\n-    if (buffersize > (int)sizeof(\"-INF\"))\n-        snprintf(buffer, buffersize, \"-INF\");\n-    break;\n-    default:\n-    if (xmlXPathIsNaN(number)) {\n-        if (buffersize > (int)sizeof(\"NaN\"))\n-        snprintf(buffer, buffersize, \"NaN\");\n-    } else if (number == 0) {\n-        snprintf(buffer, buffersize, \"0.0E0\");\n-    } else {\n-        \/* 3 is sign, decimal point, and terminating zero *\/\n-        char work[DBL_DIG + EXPONENT_DIGITS + 3];\n-        int integer_place, fraction_place;\n-        char *ptr;\n-        char *after_fraction;\n-        double absolute_value;\n-        int size;\n-\n-        absolute_value = fabs(number);\n-\n-        \/*\n-         * Result is in work, and after_fraction points\n-         * just past the fractional part.\n-         * Use scientific notation\n-        *\/\n-        integer_place = DBL_DIG + EXPONENT_DIGITS + 1;\n-        fraction_place = DBL_DIG - 1;\n-        snprintf(work, sizeof(work),\"%*.*e\",\n-        integer_place, fraction_place, number);\n-        after_fraction = strchr(work + DBL_DIG, 'e');\n-        \/* Remove fractional trailing zeroes *\/\n-        ptr = after_fraction;\n-        while (*(--ptr) == '0')\n-        ;\n-        if (*ptr != '.')\n-            ptr++;\n-        while ((*ptr++ = *after_fraction++) != 0);\n-\n-        \/* Finally copy result back to caller *\/\n-        size = strlen(work) + 1;\n-        if (size > buffersize) {\n-        work[buffersize - 1] = 0;\n-        size = buffersize;\n-        }\n-        memmove(buffer, work, size);\n-    }\n-    break;\n-    }\n-}\n-#endif\n-\n-\/**\n- * xmlSchemaGetCanonValue:\n- * @val: the precomputed value\n- * @retValue: the returned value\n- *\n- * Get the canonical lexical representation of the value.\n- * The caller has to FREE the returned retValue.\n- *\n- * WARNING: Some value types are not supported yet, resulting\n- * in a @retValue of \"???\".\n- *\n- * TODO: XML Schema 1.0 does not define canonical representations\n- * for: duration, gYearMonth, gYear, gMonthDay, gMonth, gDay,\n- * anyURI, QName, NOTATION. This will be fixed in XML Schema 1.1.\n- *\n- *\n- * Returns 0 if the value could be built, 1 if the value type is\n- * not supported yet and -1 in case of API errors.\n- *\/\n-int\n-xmlSchemaGetCanonValue(xmlSchemaValPtr val, const xmlChar **retValue)\n-{\n-    if ((retValue == NULL) || (val == NULL))\n-    return (-1);\n-    *retValue = NULL;\n-    switch (val->type) {\n-    case XML_SCHEMAS_STRING:\n-        if (val->value.str == NULL)\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST \"\");\n-        else\n-        *retValue =\n-            BAD_CAST xmlStrdup((const xmlChar *) val->value.str);\n-        break;\n-    case XML_SCHEMAS_NORMSTRING:\n-        if (val->value.str == NULL)\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST \"\");\n-        else {\n-        *retValue = xmlSchemaWhiteSpaceReplace(\n-            (const xmlChar *) val->value.str);\n-        if ((*retValue) == NULL)\n-            *retValue = BAD_CAST xmlStrdup(\n-            (const xmlChar *) val->value.str);\n-        }\n-        break;\n-    case XML_SCHEMAS_TOKEN:\n-    case XML_SCHEMAS_LANGUAGE:\n-    case XML_SCHEMAS_NMTOKEN:\n-    case XML_SCHEMAS_NAME:\n-    case XML_SCHEMAS_NCNAME:\n-    case XML_SCHEMAS_ID:\n-    case XML_SCHEMAS_IDREF:\n-    case XML_SCHEMAS_ENTITY:\n-    case XML_SCHEMAS_NOTATION: \/* Unclear *\/\n-    case XML_SCHEMAS_ANYURI:   \/* Unclear *\/\n-        if (val->value.str == NULL)\n-        return (-1);\n-        *retValue =\n-        BAD_CAST xmlSchemaCollapseString(BAD_CAST val->value.str);\n-        if (*retValue == NULL)\n-        *retValue =\n-            BAD_CAST xmlStrdup((const xmlChar *) val->value.str);\n-        break;\n-    case XML_SCHEMAS_QNAME:\n-        \/* TODO: Unclear in XML Schema 1.0. *\/\n-        if (val->value.qname.uri == NULL) {\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST val->value.qname.name);\n-        return (0);\n-        } else {\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST \"{\");\n-        *retValue = BAD_CAST xmlStrcat((xmlChar *) (*retValue),\n-            BAD_CAST val->value.qname.uri);\n-        *retValue = BAD_CAST xmlStrcat((xmlChar *) (*retValue),\n-            BAD_CAST \"}\");\n-        *retValue = BAD_CAST xmlStrcat((xmlChar *) (*retValue),\n-            BAD_CAST val->value.qname.uri);\n-        }\n-        break;\n-    case XML_SCHEMAS_DECIMAL: {\n-                xmlChar *start = val->value.decimal.str;\n-                if(start[0] == '+')\n-                {\n-                    start += 1;\n-                }\n-                *retValue = xmlStrdup(start);\n-        }\n-        break;\n-    case XML_SCHEMAS_INTEGER:\n-        case XML_SCHEMAS_PINTEGER:\n-        case XML_SCHEMAS_NPINTEGER:\n-        case XML_SCHEMAS_NINTEGER:\n-        case XML_SCHEMAS_NNINTEGER:\n-    case XML_SCHEMAS_LONG:\n-        case XML_SCHEMAS_BYTE:\n-        case XML_SCHEMAS_SHORT:\n-        case XML_SCHEMAS_INT:\n-    case XML_SCHEMAS_UINT:\n-        case XML_SCHEMAS_ULONG:\n-        case XML_SCHEMAS_USHORT:\n-        case XML_SCHEMAS_UBYTE: {\n-            xmlChar *start = val->value.decimal.str;\n-            \/* 2 = sign+NULL *\/\n-            size_t bufSize = val->value.decimal.integralPlaces+2;\n-            if(start[0] == '+')\n-            {\n-                start += 1;\n-                bufSize -= 1;\n-            }\n-            *retValue = xmlMalloc(bufSize);\n-            if(*retValue) {\n-                \/* no need to limit string length in format, it will only print bufSize-1 chars anyways *\/\n-                snprintf((char*)*retValue, bufSize, \"%s\", start);\n-            }\n-        }\n-        break;\n-    case XML_SCHEMAS_BOOLEAN:\n-        if (val->value.b)\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST \"true\");\n-        else\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST \"false\");\n-        break;\n-    case XML_SCHEMAS_DURATION: {\n-        char buf[100];\n-        unsigned long year;\n-        unsigned long mon, day, hour = 0, min = 0;\n-        double sec = 0, left;\n-\n-        \/* TODO: Unclear in XML Schema 1.0 *\/\n-        \/*\n-        * TODO: This results in a normalized output of the value\n-        * - which is NOT conformant to the spec -\n-        * since the exact values of each property are not\n-        * recoverable. Think about extending the structure to\n-        * provide a field for every property.\n-        *\/\n-        year = (unsigned long) FQUOTIENT(labs(val->value.dur.mon), 12);\n-        mon = labs(val->value.dur.mon) - 12 * year;\n-\n-        day = (unsigned long) FQUOTIENT(fabs(val->value.dur.sec), 86400);\n-        left = fabs(val->value.dur.sec) - day * 86400;\n-        if (left > 0) {\n-            hour = (unsigned long) FQUOTIENT(left, 3600);\n-            left = left - (hour * 3600);\n-            if (left > 0) {\n-            min = (unsigned long) FQUOTIENT(left, 60);\n-            sec = left - (min * 60);\n-            }\n-        }\n-        if ((val->value.dur.mon < 0) || (val->value.dur.sec < 0))\n-            snprintf(buf, 100, \"P%luY%luM%luDT%luH%luM%.14gS\",\n-            year, mon, day, hour, min, sec);\n-        else\n-            snprintf(buf, 100, \"-P%luY%luM%luDT%luH%luM%.14gS\",\n-            year, mon, day, hour, min, sec);\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST buf);\n-        }\n-        break;\n-    case XML_SCHEMAS_GYEAR: {\n-        char buf[30];\n-        \/* TODO: Unclear in XML Schema 1.0 *\/\n-        \/* TODO: What to do with the timezone? *\/\n-        snprintf(buf, 30, \"%04ld\", val->value.date.year);\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST buf);\n-        }\n-        break;\n-    case XML_SCHEMAS_GMONTH: {\n-        \/* TODO: Unclear in XML Schema 1.0 *\/\n-        \/* TODO: What to do with the timezone? *\/\n-        *retValue = xmlMalloc(6);\n-        if (*retValue == NULL)\n-            return(-1);\n-        snprintf((char *) *retValue, 6, \"--%02u\",\n-            val->value.date.mon);\n-        }\n-        break;\n-        case XML_SCHEMAS_GDAY: {\n-        \/* TODO: Unclear in XML Schema 1.0 *\/\n-        \/* TODO: What to do with the timezone? *\/\n-        *retValue = xmlMalloc(6);\n-        if (*retValue == NULL)\n-            return(-1);\n-        snprintf((char *) *retValue, 6, \"---%02u\",\n-            val->value.date.day);\n-        }\n-        break;\n-        case XML_SCHEMAS_GMONTHDAY: {\n-        \/* TODO: Unclear in XML Schema 1.0 *\/\n-        \/* TODO: What to do with the timezone? *\/\n-        *retValue = xmlMalloc(8);\n-        if (*retValue == NULL)\n-            return(-1);\n-        snprintf((char *) *retValue, 8, \"--%02u-%02u\",\n-            val->value.date.mon, val->value.date.day);\n-        }\n-        break;\n-        case XML_SCHEMAS_GYEARMONTH: {\n-        char buf[35];\n-        \/* TODO: Unclear in XML Schema 1.0 *\/\n-        \/* TODO: What to do with the timezone? *\/\n-        if (val->value.date.year < 0)\n-            snprintf(buf, 35, \"-%04ld-%02u\",\n-            labs(val->value.date.year),\n-            val->value.date.mon);\n-        else\n-            snprintf(buf, 35, \"%04ld-%02u\",\n-            val->value.date.year, val->value.date.mon);\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST buf);\n-        }\n-        break;\n-    case XML_SCHEMAS_TIME:\n-        {\n-        char buf[30];\n-\n-        if (val->value.date.tz_flag) {\n-            xmlSchemaValPtr norm;\n-\n-            norm = xmlSchemaDateNormalize(val, 0);\n-            if (norm == NULL)\n-            return (-1);\n-            \/*\n-            * TODO: Check if \"%.14g\" is portable.\n-            *\/\n-            snprintf(buf, 30,\n-            \"%02u:%02u:%02.14gZ\",\n-            norm->value.date.hour,\n-            norm->value.date.min,\n-            norm->value.date.sec);\n-            xmlSchemaFreeValue(norm);\n-        } else {\n-            snprintf(buf, 30,\n-            \"%02u:%02u:%02.14g\",\n-            val->value.date.hour,\n-            val->value.date.min,\n-            val->value.date.sec);\n-        }\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST buf);\n-        }\n-        break;\n-        case XML_SCHEMAS_DATE:\n-        {\n-        char buf[30];\n-\n-        if (val->value.date.tz_flag) {\n-            xmlSchemaValPtr norm;\n-\n-            norm = xmlSchemaDateNormalize(val, 0);\n-            if (norm == NULL)\n-            return (-1);\n-            \/*\n-            * TODO: Append the canonical value of the\n-            * recoverable timezone and not \"Z\".\n-            *\/\n-            snprintf(buf, 30,\n-            \"%04ld-%02u-%02uZ\",\n-            norm->value.date.year, norm->value.date.mon,\n-            norm->value.date.day);\n-            xmlSchemaFreeValue(norm);\n-        } else {\n-            snprintf(buf, 30,\n-            \"%04ld-%02u-%02u\",\n-            val->value.date.year, val->value.date.mon,\n-            val->value.date.day);\n-        }\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST buf);\n-        }\n-        break;\n-        case XML_SCHEMAS_DATETIME:\n-        {\n-        char buf[50];\n-\n-        if (val->value.date.tz_flag) {\n-            xmlSchemaValPtr norm;\n-\n-            norm = xmlSchemaDateNormalize(val, 0);\n-            if (norm == NULL)\n-            return (-1);\n-            \/*\n-            * TODO: Check if \"%.14g\" is portable.\n-            *\/\n-            snprintf(buf, 50,\n-            \"%04ld-%02u-%02uT%02u:%02u:%02.14gZ\",\n-            norm->value.date.year, norm->value.date.mon,\n-            norm->value.date.day, norm->value.date.hour,\n-            norm->value.date.min, norm->value.date.sec);\n-            xmlSchemaFreeValue(norm);\n-        } else {\n-            snprintf(buf, 50,\n-            \"%04ld-%02u-%02uT%02u:%02u:%02.14g\",\n-            val->value.date.year, val->value.date.mon,\n-            val->value.date.day, val->value.date.hour,\n-            val->value.date.min, val->value.date.sec);\n-        }\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST buf);\n-        }\n-        break;\n-    case XML_SCHEMAS_HEXBINARY:\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST val->value.hex.str);\n-        break;\n-    case XML_SCHEMAS_BASE64BINARY:\n-        \/*\n-        * TODO: Is the following spec piece implemented?:\n-        * SPEC: \"Note: For some values the canonical form defined\n-        * above does not conform to [RFC 2045], which requires breaking\n-        * with linefeeds at appropriate intervals.\"\n-        *\/\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST val->value.base64.str);\n-        break;\n-    case XML_SCHEMAS_FLOAT: {\n-        char buf[30];\n-        \/*\n-        * |m| < 16777216, -149 <= e <= 104.\n-        * TODO: Handle, NaN, INF, -INF. The format is not\n-        * yet conformant. The c type float does not cover\n-        * the whole range.\n-        *\/\n-        snprintf(buf, 30, \"%01.14e\", val->value.f);\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST buf);\n-        }\n-        break;\n-    case XML_SCHEMAS_DOUBLE: {\n-        char buf[40];\n-        \/* |m| < 9007199254740992, -1075 <= e <= 970 *\/\n-        \/*\n-        * TODO: Handle, NaN, INF, -INF. The format is not\n-        * yet conformant. The c type float does not cover\n-        * the whole range.\n-        *\/\n-        snprintf(buf, 40, \"%01.14e\", val->value.d);\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST buf);\n-        }\n-        break;\n-    default:\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST \"???\");\n-        return (1);\n-    }\n-    if (*retValue == NULL)\n-    return(-1);\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaGetCanonValueWhtsp:\n- * @val: the precomputed value\n- * @retValue: the returned value\n- * @ws: the whitespace type of the value\n- *\n- * Get the canonical representation of the value.\n- * The caller has to free the returned @retValue.\n- *\n- * Returns 0 if the value could be built, 1 if the value type is\n- * not supported yet and -1 in case of API errors.\n- *\/\n-int\n-xmlSchemaGetCanonValueWhtsp(xmlSchemaValPtr val,\n-                const xmlChar **retValue,\n-                xmlSchemaWhitespaceValueType ws)\n-{\n-    if ((retValue == NULL) || (val == NULL))\n-    return (-1);\n-    if ((ws == XML_SCHEMA_WHITESPACE_UNKNOWN) ||\n-    (ws > XML_SCHEMA_WHITESPACE_COLLAPSE))\n-    return (-1);\n-\n-    *retValue = NULL;\n-    switch (val->type) {\n-    case XML_SCHEMAS_STRING:\n-        if (val->value.str == NULL)\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST \"\");\n-        else if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)\n-        *retValue = xmlSchemaCollapseString(val->value.str);\n-        else if (ws == XML_SCHEMA_WHITESPACE_REPLACE)\n-        *retValue = xmlSchemaWhiteSpaceReplace(val->value.str);\n-        if ((*retValue) == NULL)\n-        *retValue = BAD_CAST xmlStrdup(val->value.str);\n-        break;\n-    case XML_SCHEMAS_NORMSTRING:\n-        if (val->value.str == NULL)\n-        *retValue = BAD_CAST xmlStrdup(BAD_CAST \"\");\n-        else {\n-        if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)\n-            *retValue = xmlSchemaCollapseString(val->value.str);\n-        else\n-            *retValue = xmlSchemaWhiteSpaceReplace(val->value.str);\n-        if ((*retValue) == NULL)\n-            *retValue = BAD_CAST xmlStrdup(val->value.str);\n-        }\n-        break;\n-    default:\n-        return (xmlSchemaGetCanonValue(val, retValue));\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSchemaGetValType:\n- * @val: a schemas value\n- *\n- * Accessor for the type of a value\n- *\n- * Returns the xmlSchemaValType of the value\n- *\/\n-xmlSchemaValType\n-xmlSchemaGetValType(xmlSchemaValPtr val)\n-{\n-    if (val == NULL)\n-        return(XML_SCHEMAS_UNKNOWN);\n-    return (val->type);\n-}\n-\n-#endif \/* LIBXML_SCHEMAS_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlschemastypes.c","additions":0,"deletions":6268,"binary":false,"changes":6268,"status":"deleted"},{"patch":"@@ -1,2924 +0,0 @@\n-\/*\n- * xpointer.c : Code to handle XML Pointer\n- *\n- * Base implementation was made accordingly to\n- * W3C Candidate Recommendation 7 June 2000\n- * http:\/\/www.w3.org\/TR\/2000\/CR-xptr-20000607\n- *\n- * Added support for the element() scheme described in:\n- * W3C Proposed Recommendation 13 November 2002\n- * http:\/\/www.w3.org\/TR\/2002\/PR-xptr-element-20021113\/\n- *\n- * See Copyright for the status of this software.\n- *\n- * daniel@veillard.com\n- *\/\n-\n-\/* To avoid EBCDIC trouble when parsing on zOS *\/\n-#if defined(__MVS__)\n-#pragma convert(\"ISO8859-1\")\n-#endif\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-\n-\/*\n- * TODO: better handling of error cases, the full expression should\n- *       be parsed beforehand instead of a progressive evaluation\n- * TODO: Access into entities references are not supported now ...\n- *       need a start to be able to pop out of entities refs since\n- *       parent is the entity declaration, not the ref.\n- *\/\n-\n-#include <string.h>\n-#include <libxml\/xpointer.h>\n-#include <libxml\/xmlmemory.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/uri.h>\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-#include <libxml\/xmlerror.h>\n-\n-#ifdef LIBXML_XPTR_ENABLED\n-\n-\/* Add support of the xmlns() xpointer scheme to initialize the namespaces *\/\n-#define XPTR_XMLNS_SCHEME\n-\n-#include \"private\/error.h\"\n-#include \"private\/xpath.h\"\n-\n-\/************************************************************************\n- *                                    *\n- *        Some factorized error routines                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlXPtrErr:\n- * @ctxt:  an XPTR evaluation context\n- * @extra:  extra information\n- *\n- * Handle an XPointer error\n- *\/\n-static void LIBXML_ATTR_FORMAT(3,0)\n-xmlXPtrErr(xmlXPathParserContextPtr ctxt, int code,\n-           const char * msg, const xmlChar *extra)\n-{\n-    xmlStructuredErrorFunc serror = NULL;\n-    void *data = NULL;\n-    xmlNodePtr node = NULL;\n-    int res;\n-\n-    if (ctxt == NULL)\n-        return;\n-    \/* Only report the first error *\/\n-    if (ctxt->error != 0)\n-        return;\n-\n-    ctxt->error = code;\n-\n-    if (ctxt->context != NULL) {\n-        xmlErrorPtr err = &ctxt->context->lastError;\n-\n-        \/* cleanup current last error *\/\n-        xmlResetError(err);\n-\n-        err->domain = XML_FROM_XPOINTER;\n-        err->code = code;\n-        err->level = XML_ERR_ERROR;\n-        err->str1 = (char *) xmlStrdup(ctxt->base);\n-        if (err->str1 == NULL) {\n-            xmlXPathPErrMemory(ctxt);\n-            return;\n-        }\n-        err->int1 = ctxt->cur - ctxt->base;\n-        err->node = ctxt->context->debugNode;\n-\n-        serror = ctxt->context->error;\n-        data = ctxt->context->userData;\n-        node = ctxt->context->debugNode;\n-    }\n-\n-    res = __xmlRaiseError(serror, NULL, data, NULL, node,\n-                          XML_FROM_XPOINTER, code, XML_ERR_ERROR, NULL, 0,\n-                          (const char *) extra, (const char *) ctxt->base,\n-                          NULL, ctxt->cur - ctxt->base, 0,\n-                          msg, extra);\n-    if (res < 0)\n-        xmlXPathPErrMemory(ctxt);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        A few helper functions for child sequences        *\n- *                                    *\n- ************************************************************************\/\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-\/* xmlXPtrAdvanceNode is a private function, but used by xinclude.c *\/\n-xmlNodePtr xmlXPtrAdvanceNode(xmlNodePtr cur, int *level);\n-\/**\n- * xmlXPtrGetArity:\n- * @cur:  the node\n- *\n- * Returns the number of child for an element, -1 in case of error\n- *\/\n-static int\n-xmlXPtrGetArity(xmlNodePtr cur) {\n-    int i;\n-    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n-    return(-1);\n-    cur = cur->children;\n-    for (i = 0;cur != NULL;cur = cur->next) {\n-    if ((cur->type == XML_ELEMENT_NODE) ||\n-        (cur->type == XML_DOCUMENT_NODE) ||\n-        (cur->type == XML_HTML_DOCUMENT_NODE)) {\n-        i++;\n-    }\n-    }\n-    return(i);\n-}\n-\n-\/**\n- * xmlXPtrGetIndex:\n- * @cur:  the node\n- *\n- * Returns the index of the node in its parent children list, -1\n- *         in case of error\n- *\/\n-static int\n-xmlXPtrGetIndex(xmlNodePtr cur) {\n-    int i;\n-    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n-    return(-1);\n-    for (i = 1;cur != NULL;cur = cur->prev) {\n-    if ((cur->type == XML_ELEMENT_NODE) ||\n-        (cur->type == XML_DOCUMENT_NODE) ||\n-        (cur->type == XML_HTML_DOCUMENT_NODE)) {\n-        i++;\n-    }\n-    }\n-    return(i);\n-}\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-\n-\/**\n- * xmlXPtrGetNthChild:\n- * @cur:  the node\n- * @no:  the child number\n- *\n- * Returns the @no'th element child of @cur or NULL\n- *\/\n-static xmlNodePtr\n-xmlXPtrGetNthChild(xmlNodePtr cur, int no) {\n-    int i;\n-    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n-    return(cur);\n-    cur = cur->children;\n-    for (i = 0;i <= no;cur = cur->next) {\n-    if (cur == NULL)\n-        return(cur);\n-    if ((cur->type == XML_ELEMENT_NODE) ||\n-        (cur->type == XML_DOCUMENT_NODE) ||\n-        (cur->type == XML_HTML_DOCUMENT_NODE)) {\n-        i++;\n-        if (i == no)\n-        break;\n-    }\n-    }\n-    return(cur);\n-}\n-\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-\/************************************************************************\n- *                                    *\n- *        Handling of XPointer specific types            *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlXPtrErrMemory:\n- * @extra:  extra information\n- *\n- * Handle a redefinition of attribute error\n- *\/\n-static void\n-xmlXPtrErrMemory(const char *extra ATTRIBUTE_UNUSED)\n-{\n-    xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_XPOINTER, NULL);\n-}\n-\n-\/**\n- * xmlXPtrCmpPoints:\n- * @node1:  the first node\n- * @index1:  the first index\n- * @node2:  the second node\n- * @index2:  the second index\n- *\n- * Compare two points w.r.t document order\n- *\n- * Returns -2 in case of error 1 if first point < second point, 0 if\n- *         that's the same point, -1 otherwise\n- *\/\n-static int\n-xmlXPtrCmpPoints(xmlNodePtr node1, int index1, xmlNodePtr node2, int index2) {\n-    if ((node1 == NULL) || (node2 == NULL))\n-    return(-2);\n-    \/*\n-     * a couple of optimizations which will avoid computations in most cases\n-     *\/\n-    if (node1 == node2) {\n-    if (index1 < index2)\n-        return(1);\n-    if (index1 > index2)\n-        return(-1);\n-    return(0);\n-    }\n-    return(xmlXPathCmpNodes(node1, node2));\n-}\n-\n-\/**\n- * xmlXPtrNewPoint:\n- * @node:  the xmlNodePtr\n- * @indx:  the indx within the node\n- *\n- * Create a new xmlXPathObjectPtr of type point\n- *\n- * Returns the newly created object.\n- *\/\n-static xmlXPathObjectPtr\n-xmlXPtrNewPoint(xmlNodePtr node, int indx) {\n-    xmlXPathObjectPtr ret;\n-\n-    if (node == NULL)\n-    return(NULL);\n-    if (indx < 0)\n-    return(NULL);\n-\n-    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));\n-    if (ret == NULL) {\n-        xmlXPtrErrMemory(\"allocating point\");\n-    return(NULL);\n-    }\n-    memset(ret, 0 , sizeof(xmlXPathObject));\n-    ret->type = XPATH_POINT;\n-    ret->user = (void *) node;\n-    ret->index = indx;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXPtrRangeCheckOrder:\n- * @range:  an object range\n- *\n- * Make sure the points in the range are in the right order\n- *\/\n-static void\n-xmlXPtrRangeCheckOrder(xmlXPathObjectPtr range) {\n-    int tmp;\n-    xmlNodePtr tmp2;\n-    if (range == NULL)\n-    return;\n-    if (range->type != XPATH_RANGE)\n-    return;\n-    if (range->user2 == NULL)\n-    return;\n-    tmp = xmlXPtrCmpPoints(range->user, range->index,\n-                         range->user2, range->index2);\n-    if (tmp == -1) {\n-    tmp2 = range->user;\n-    range->user = range->user2;\n-    range->user2 = tmp2;\n-    tmp = range->index;\n-    range->index = range->index2;\n-    range->index2 = tmp;\n-    }\n-}\n-\n-\/**\n- * xmlXPtrRangesEqual:\n- * @range1:  the first range\n- * @range2:  the second range\n- *\n- * Compare two ranges\n- *\n- * Returns 1 if equal, 0 otherwise\n- *\/\n-static int\n-xmlXPtrRangesEqual(xmlXPathObjectPtr range1, xmlXPathObjectPtr range2) {\n-    if (range1 == range2)\n-    return(1);\n-    if ((range1 == NULL) || (range2 == NULL))\n-    return(0);\n-    if (range1->type != range2->type)\n-    return(0);\n-    if (range1->type != XPATH_RANGE)\n-    return(0);\n-    if (range1->user != range2->user)\n-    return(0);\n-    if (range1->index != range2->index)\n-    return(0);\n-    if (range1->user2 != range2->user2)\n-    return(0);\n-    if (range1->index2 != range2->index2)\n-    return(0);\n-    return(1);\n-}\n-\n-\/**\n- * xmlXPtrNewRangeInternal:\n- * @start:  the starting node\n- * @startindex:  the start index\n- * @end:  the ending point\n- * @endindex:  the ending index\n- *\n- * Internal function to create a new xmlXPathObjectPtr of type range\n- *\n- * Returns the newly created object.\n- *\/\n-static xmlXPathObjectPtr\n-xmlXPtrNewRangeInternal(xmlNodePtr start, int startindex,\n-                        xmlNodePtr end, int endindex) {\n-    xmlXPathObjectPtr ret;\n-\n-    \/*\n-     * Namespace nodes must be copied (see xmlXPathNodeSetDupNs).\n-     * Disallow them for now.\n-     *\/\n-    if ((start != NULL) && (start->type == XML_NAMESPACE_DECL))\n-    return(NULL);\n-    if ((end != NULL) && (end->type == XML_NAMESPACE_DECL))\n-    return(NULL);\n-\n-    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));\n-    if (ret == NULL) {\n-        xmlXPtrErrMemory(\"allocating range\");\n-    return(NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlXPathObject));\n-    ret->type = XPATH_RANGE;\n-    ret->user = start;\n-    ret->index = startindex;\n-    ret->user2 = end;\n-    ret->index2 = endindex;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXPtrNewRange:\n- * @start:  the starting node\n- * @startindex:  the start index\n- * @end:  the ending point\n- * @endindex:  the ending index\n- *\n- * Create a new xmlXPathObjectPtr of type range\n- *\n- * Returns the newly created object.\n- *\/\n-xmlXPathObjectPtr\n-xmlXPtrNewRange(xmlNodePtr start, int startindex,\n-            xmlNodePtr end, int endindex) {\n-    xmlXPathObjectPtr ret;\n-\n-    if (start == NULL)\n-    return(NULL);\n-    if (end == NULL)\n-    return(NULL);\n-    if (startindex < 0)\n-    return(NULL);\n-    if (endindex < 0)\n-    return(NULL);\n-\n-    ret = xmlXPtrNewRangeInternal(start, startindex, end, endindex);\n-    xmlXPtrRangeCheckOrder(ret);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXPtrNewRangePoints:\n- * @start:  the starting point\n- * @end:  the ending point\n- *\n- * Create a new xmlXPathObjectPtr of type range using 2 Points\n- *\n- * Returns the newly created object.\n- *\/\n-xmlXPathObjectPtr\n-xmlXPtrNewRangePoints(xmlXPathObjectPtr start, xmlXPathObjectPtr end) {\n-    xmlXPathObjectPtr ret;\n-\n-    if (start == NULL)\n-    return(NULL);\n-    if (end == NULL)\n-    return(NULL);\n-    if (start->type != XPATH_POINT)\n-    return(NULL);\n-    if (end->type != XPATH_POINT)\n-    return(NULL);\n-\n-    ret = xmlXPtrNewRangeInternal(start->user, start->index, end->user,\n-                                  end->index);\n-    xmlXPtrRangeCheckOrder(ret);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXPtrNewRangePointNode:\n- * @start:  the starting point\n- * @end:  the ending node\n- *\n- * Create a new xmlXPathObjectPtr of type range from a point to a node\n- *\n- * Returns the newly created object.\n- *\/\n-xmlXPathObjectPtr\n-xmlXPtrNewRangePointNode(xmlXPathObjectPtr start, xmlNodePtr end) {\n-    xmlXPathObjectPtr ret;\n-\n-    if (start == NULL)\n-    return(NULL);\n-    if (end == NULL)\n-    return(NULL);\n-    if (start->type != XPATH_POINT)\n-    return(NULL);\n-\n-    ret = xmlXPtrNewRangeInternal(start->user, start->index, end, -1);\n-    xmlXPtrRangeCheckOrder(ret);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXPtrNewRangeNodePoint:\n- * @start:  the starting node\n- * @end:  the ending point\n- *\n- * Create a new xmlXPathObjectPtr of type range from a node to a point\n- *\n- * Returns the newly created object.\n- *\/\n-xmlXPathObjectPtr\n-xmlXPtrNewRangeNodePoint(xmlNodePtr start, xmlXPathObjectPtr end) {\n-    xmlXPathObjectPtr ret;\n-\n-    if (start == NULL)\n-    return(NULL);\n-    if (end == NULL)\n-    return(NULL);\n-    if (end->type != XPATH_POINT)\n-    return(NULL);\n-\n-    ret = xmlXPtrNewRangeInternal(start, -1, end->user, end->index);\n-    xmlXPtrRangeCheckOrder(ret);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXPtrNewRangeNodes:\n- * @start:  the starting node\n- * @end:  the ending node\n- *\n- * Create a new xmlXPathObjectPtr of type range using 2 nodes\n- *\n- * Returns the newly created object.\n- *\/\n-xmlXPathObjectPtr\n-xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {\n-    xmlXPathObjectPtr ret;\n-\n-    if (start == NULL)\n-    return(NULL);\n-    if (end == NULL)\n-    return(NULL);\n-\n-    ret = xmlXPtrNewRangeInternal(start, -1, end, -1);\n-    xmlXPtrRangeCheckOrder(ret);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXPtrNewCollapsedRange:\n- * @start:  the starting and ending node\n- *\n- * Create a new xmlXPathObjectPtr of type range using a single nodes\n- *\n- * Returns the newly created object.\n- *\/\n-xmlXPathObjectPtr\n-xmlXPtrNewCollapsedRange(xmlNodePtr start) {\n-    xmlXPathObjectPtr ret;\n-\n-    if (start == NULL)\n-    return(NULL);\n-\n-    ret = xmlXPtrNewRangeInternal(start, -1, NULL, -1);\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXPtrNewRangeNodeObject:\n- * @start:  the starting node\n- * @end:  the ending object\n- *\n- * Create a new xmlXPathObjectPtr of type range from a not to an object\n- *\n- * Returns the newly created object.\n- *\/\n-xmlXPathObjectPtr\n-xmlXPtrNewRangeNodeObject(xmlNodePtr start, xmlXPathObjectPtr end) {\n-    xmlNodePtr endNode;\n-    int endIndex;\n-    xmlXPathObjectPtr ret;\n-\n-    if (start == NULL)\n-    return(NULL);\n-    if (end == NULL)\n-    return(NULL);\n-    switch (end->type) {\n-    case XPATH_POINT:\n-        endNode = end->user;\n-        endIndex = end->index;\n-        break;\n-    case XPATH_RANGE:\n-        endNode = end->user2;\n-        endIndex = end->index2;\n-        break;\n-    case XPATH_NODESET:\n-        \/*\n-         * Empty set ...\n-         *\/\n-        if ((end->nodesetval == NULL) || (end->nodesetval->nodeNr <= 0))\n-        return(NULL);\n-        endNode = end->nodesetval->nodeTab[end->nodesetval->nodeNr - 1];\n-        endIndex = -1;\n-        break;\n-    default:\n-        \/* TODO *\/\n-        return(NULL);\n-    }\n-\n-    ret = xmlXPtrNewRangeInternal(start, -1, endNode, endIndex);\n-    xmlXPtrRangeCheckOrder(ret);\n-    return(ret);\n-}\n-\n-#define XML_RANGESET_DEFAULT    10\n-\n-\/**\n- * xmlXPtrLocationSetCreate:\n- * @val:  an initial xmlXPathObjectPtr, or NULL\n- *\n- * Create a new xmlLocationSetPtr of type double and of value @val\n- *\n- * Returns the newly created object.\n- *\/\n-xmlLocationSetPtr\n-xmlXPtrLocationSetCreate(xmlXPathObjectPtr val) {\n-    xmlLocationSetPtr ret;\n-\n-    ret = (xmlLocationSetPtr) xmlMalloc(sizeof(xmlLocationSet));\n-    if (ret == NULL) {\n-        xmlXPtrErrMemory(\"allocating locationset\");\n-    return(NULL);\n-    }\n-    memset(ret, 0 , sizeof(xmlLocationSet));\n-    if (val != NULL) {\n-        ret->locTab = (xmlXPathObjectPtr *) xmlMalloc(XML_RANGESET_DEFAULT *\n-                         sizeof(xmlXPathObjectPtr));\n-    if (ret->locTab == NULL) {\n-        xmlXPtrErrMemory(\"allocating locationset\");\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n-    memset(ret->locTab, 0 ,\n-           XML_RANGESET_DEFAULT * sizeof(xmlXPathObjectPtr));\n-        ret->locMax = XML_RANGESET_DEFAULT;\n-    ret->locTab[ret->locNr++] = val;\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXPtrLocationSetAdd:\n- * @cur:  the initial range set\n- * @val:  a new xmlXPathObjectPtr\n- *\n- * add a new xmlXPathObjectPtr to an existing LocationSet\n- * If the location already exist in the set @val is freed.\n- *\/\n-void\n-xmlXPtrLocationSetAdd(xmlLocationSetPtr cur, xmlXPathObjectPtr val) {\n-    int i;\n-\n-    if ((cur == NULL) || (val == NULL)) return;\n-\n-    \/*\n-     * check against doublons\n-     *\/\n-    for (i = 0;i < cur->locNr;i++) {\n-    if (xmlXPtrRangesEqual(cur->locTab[i], val)) {\n-        xmlXPathFreeObject(val);\n-        return;\n-    }\n-    }\n-\n-    \/*\n-     * grow the locTab if needed\n-     *\/\n-    if (cur->locMax == 0) {\n-        cur->locTab = (xmlXPathObjectPtr *) xmlMalloc(XML_RANGESET_DEFAULT *\n-                         sizeof(xmlXPathObjectPtr));\n-    if (cur->locTab == NULL) {\n-        xmlXPtrErrMemory(\"adding location to set\");\n-        return;\n-    }\n-    memset(cur->locTab, 0 ,\n-           XML_RANGESET_DEFAULT * sizeof(xmlXPathObjectPtr));\n-        cur->locMax = XML_RANGESET_DEFAULT;\n-    } else if (cur->locNr == cur->locMax) {\n-        xmlXPathObjectPtr *temp;\n-\n-        cur->locMax *= 2;\n-    temp = (xmlXPathObjectPtr *) xmlRealloc(cur->locTab, cur->locMax *\n-                      sizeof(xmlXPathObjectPtr));\n-    if (temp == NULL) {\n-        xmlXPtrErrMemory(\"adding location to set\");\n-        return;\n-    }\n-    cur->locTab = temp;\n-    }\n-    cur->locTab[cur->locNr++] = val;\n-}\n-\n-\/**\n- * xmlXPtrLocationSetMerge:\n- * @val1:  the first LocationSet\n- * @val2:  the second LocationSet\n- *\n- * Merges two rangesets, all ranges from @val2 are added to @val1\n- *\n- * Returns val1 once extended or NULL in case of error.\n- *\/\n-xmlLocationSetPtr\n-xmlXPtrLocationSetMerge(xmlLocationSetPtr val1, xmlLocationSetPtr val2) {\n-    int i;\n-\n-    if (val1 == NULL) return(NULL);\n-    if (val2 == NULL) return(val1);\n-\n-    \/*\n-     * !!!!! this can be optimized a lot, knowing that both\n-     *       val1 and val2 already have unicity of their values.\n-     *\/\n-\n-    for (i = 0;i < val2->locNr;i++)\n-        xmlXPtrLocationSetAdd(val1, val2->locTab[i]);\n-\n-    return(val1);\n-}\n-\n-\/**\n- * xmlXPtrLocationSetDel:\n- * @cur:  the initial range set\n- * @val:  an xmlXPathObjectPtr\n- *\n- * Removes an xmlXPathObjectPtr from an existing LocationSet\n- *\/\n-void\n-xmlXPtrLocationSetDel(xmlLocationSetPtr cur, xmlXPathObjectPtr val) {\n-    int i;\n-\n-    if (cur == NULL) return;\n-    if (val == NULL) return;\n-\n-    \/*\n-     * check against doublons\n-     *\/\n-    for (i = 0;i < cur->locNr;i++)\n-        if (cur->locTab[i] == val) break;\n-\n-    if (i >= cur->locNr) {\n-        return;\n-    }\n-    cur->locNr--;\n-    for (;i < cur->locNr;i++)\n-        cur->locTab[i] = cur->locTab[i + 1];\n-    cur->locTab[cur->locNr] = NULL;\n-}\n-\n-\/**\n- * xmlXPtrLocationSetRemove:\n- * @cur:  the initial range set\n- * @val:  the index to remove\n- *\n- * Removes an entry from an existing LocationSet list.\n- *\/\n-void\n-xmlXPtrLocationSetRemove(xmlLocationSetPtr cur, int val) {\n-    if (cur == NULL) return;\n-    if (val >= cur->locNr) return;\n-    cur->locNr--;\n-    for (;val < cur->locNr;val++)\n-        cur->locTab[val] = cur->locTab[val + 1];\n-    cur->locTab[cur->locNr] = NULL;\n-}\n-\n-\/**\n- * xmlXPtrFreeLocationSet:\n- * @obj:  the xmlLocationSetPtr to free\n- *\n- * Free the LocationSet compound (not the actual ranges !).\n- *\/\n-void\n-xmlXPtrFreeLocationSet(xmlLocationSetPtr obj) {\n-    int i;\n-\n-    if (obj == NULL) return;\n-    if (obj->locTab != NULL) {\n-    for (i = 0;i < obj->locNr; i++) {\n-            xmlXPathFreeObject(obj->locTab[i]);\n-    }\n-    xmlFree(obj->locTab);\n-    }\n-    xmlFree(obj);\n-}\n-\n-\/**\n- * xmlXPtrNewLocationSetNodes:\n- * @start:  the start NodePtr value\n- * @end:  the end NodePtr value or NULL\n- *\n- * Create a new xmlXPathObjectPtr of type LocationSet and initialize\n- * it with the single range made of the two nodes @start and @end\n- *\n- * Returns the newly created object.\n- *\/\n-xmlXPathObjectPtr\n-xmlXPtrNewLocationSetNodes(xmlNodePtr start, xmlNodePtr end) {\n-    xmlXPathObjectPtr ret;\n-\n-    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));\n-    if (ret == NULL) {\n-        xmlXPtrErrMemory(\"allocating locationset\");\n-    return(NULL);\n-    }\n-    memset(ret, 0 , sizeof(xmlXPathObject));\n-    ret->type = XPATH_LOCATIONSET;\n-    if (end == NULL)\n-    ret->user = xmlXPtrLocationSetCreate(xmlXPtrNewCollapsedRange(start));\n-    else\n-    ret->user = xmlXPtrLocationSetCreate(xmlXPtrNewRangeNodes(start,end));\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXPtrNewLocationSetNodeSet:\n- * @set:  a node set\n- *\n- * Create a new xmlXPathObjectPtr of type LocationSet and initialize\n- * it with all the nodes from @set\n- *\n- * Returns the newly created object.\n- *\/\n-xmlXPathObjectPtr\n-xmlXPtrNewLocationSetNodeSet(xmlNodeSetPtr set) {\n-    xmlXPathObjectPtr ret;\n-\n-    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));\n-    if (ret == NULL) {\n-        xmlXPtrErrMemory(\"allocating locationset\");\n-    return(NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlXPathObject));\n-    ret->type = XPATH_LOCATIONSET;\n-    if (set != NULL) {\n-    int i;\n-    xmlLocationSetPtr newset;\n-\n-    newset = xmlXPtrLocationSetCreate(NULL);\n-    if (newset == NULL)\n-        return(ret);\n-\n-    for (i = 0;i < set->nodeNr;i++)\n-        xmlXPtrLocationSetAdd(newset,\n-                xmlXPtrNewCollapsedRange(set->nodeTab[i]));\n-\n-    ret->user = (void *) newset;\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXPtrWrapLocationSet:\n- * @val:  the LocationSet value\n- *\n- * Wrap the LocationSet @val in a new xmlXPathObjectPtr\n- *\n- * Returns the newly created object.\n- *\/\n-xmlXPathObjectPtr\n-xmlXPtrWrapLocationSet(xmlLocationSetPtr val) {\n-    xmlXPathObjectPtr ret;\n-\n-    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));\n-    if (ret == NULL) {\n-        xmlXPtrErrMemory(\"allocating locationset\");\n-    return(NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlXPathObject));\n-    ret->type = XPATH_LOCATIONSET;\n-    ret->user = (void *) val;\n-    return(ret);\n-}\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-\n-\/************************************************************************\n- *                                    *\n- *            The parser                    *\n- *                                    *\n- ************************************************************************\/\n-\n-static void xmlXPtrEvalChildSeq(xmlXPathParserContextPtr ctxt, xmlChar *name);\n-\n-\/*\n- * Macros for accessing the content. Those should be used only by the parser,\n- * and not exported.\n- *\n- * Dirty macros, i.e. one need to make assumption on the context to use them\n- *\n- *   CUR     returns the current xmlChar value, i.e. a 8 bit value\n- *           in ISO-Latin or UTF-8.\n- *           This should be used internally by the parser\n- *           only to compare to ASCII values otherwise it would break when\n- *           running with UTF-8 encoding.\n- *   NXT(n)  returns the n'th next xmlChar. Same as CUR is should be used only\n- *           to compare on ASCII based substring.\n- *   SKIP(n) Skip n xmlChar, and must also be used only to skip ASCII defined\n- *           strings within the parser.\n- *   CURRENT Returns the current char value, with the full decoding of\n- *           UTF-8 if we are using this mode. It returns an int.\n- *   NEXT    Skip to the next character, this does the proper decoding\n- *           in UTF-8 mode. It also pop-up unfinished entities on the fly.\n- *           It returns the pointer to the current xmlChar.\n- *\/\n-\n-#define CUR (*ctxt->cur)\n-#define SKIP(val) ctxt->cur += (val)\n-#define NXT(val) ctxt->cur[(val)]\n-\n-#define SKIP_BLANKS                            \\\n-    while (IS_BLANK_CH(*(ctxt->cur))) NEXT\n-\n-#define CURRENT (*ctxt->cur)\n-#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)\n-\n-\/*\n- * xmlXPtrGetChildNo:\n- * @ctxt:  the XPointer Parser context\n- * @index:  the child number\n- *\n- * Move the current node of the nodeset on the stack to the\n- * given child if found\n- *\/\n-static void\n-xmlXPtrGetChildNo(xmlXPathParserContextPtr ctxt, int indx) {\n-    xmlNodePtr cur = NULL;\n-    xmlXPathObjectPtr obj;\n-    xmlNodeSetPtr oldset;\n-\n-    CHECK_TYPE(XPATH_NODESET);\n-    obj = valuePop(ctxt);\n-    oldset = obj->nodesetval;\n-    if ((indx <= 0) || (oldset == NULL) || (oldset->nodeNr != 1)) {\n-    xmlXPathFreeObject(obj);\n-    valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n-    return;\n-    }\n-    cur = xmlXPtrGetNthChild(oldset->nodeTab[0], indx);\n-    if (cur == NULL) {\n-    xmlXPathFreeObject(obj);\n-    valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n-    return;\n-    }\n-    oldset->nodeTab[0] = cur;\n-    valuePush(ctxt, obj);\n-}\n-\n-\/**\n- * xmlXPtrEvalXPtrPart:\n- * @ctxt:  the XPointer Parser context\n- * @name:  the preparsed Scheme for the XPtrPart\n- *\n- * XPtrPart ::= 'xpointer' '(' XPtrExpr ')'\n- *            | Scheme '(' SchemeSpecificExpr ')'\n- *\n- * Scheme   ::=  NCName - 'xpointer' [VC: Non-XPointer schemes]\n- *\n- * SchemeSpecificExpr ::= StringWithBalancedParens\n- *\n- * StringWithBalancedParens ::=\n- *              [^()]* ('(' StringWithBalancedParens ')' [^()]*)*\n- *              [VC: Parenthesis escaping]\n- *\n- * XPtrExpr ::= Expr [VC: Parenthesis escaping]\n- *\n- * VC: Parenthesis escaping:\n- *   The end of an XPointer part is signaled by the right parenthesis \")\"\n- *   character that is balanced with the left parenthesis \"(\" character\n- *   that began the part. Any unbalanced parenthesis character inside the\n- *   expression, even within literals, must be escaped with a circumflex (^)\n- *   character preceding it. If the expression contains any literal\n- *   occurrences of the circumflex, each must be escaped with an additional\n- *   circumflex (that is, ^^). If the unescaped parentheses in the expression\n- *   are not balanced, a syntax error results.\n- *\n- * Parse and evaluate an XPtrPart. Basically it generates the unescaped\n- * string and if the scheme is 'xpointer' it will call the XPath interpreter.\n- *\n- * TODO: there is no new scheme registration mechanism\n- *\/\n-\n-static void\n-xmlXPtrEvalXPtrPart(xmlXPathParserContextPtr ctxt, xmlChar *name) {\n-    xmlChar *buffer, *cur;\n-    int len;\n-    int level;\n-\n-    if (name == NULL)\n-    name = xmlXPathParseName(ctxt);\n-    if (name == NULL)\n-    XP_ERROR(XPATH_EXPR_ERROR);\n-\n-    if (CUR != '(') {\n-        xmlFree(name);\n-    XP_ERROR(XPATH_EXPR_ERROR);\n-    }\n-    NEXT;\n-    level = 1;\n-\n-    len = xmlStrlen(ctxt->cur);\n-    len++;\n-    buffer = (xmlChar *) xmlMallocAtomic(len);\n-    if (buffer == NULL) {\n-        xmlXPathPErrMemory(ctxt);\n-        xmlFree(name);\n-    return;\n-    }\n-\n-    cur = buffer;\n-    while (CUR != 0) {\n-    if (CUR == ')') {\n-        level--;\n-        if (level == 0) {\n-        NEXT;\n-        break;\n-        }\n-    } else if (CUR == '(') {\n-        level++;\n-    } else if (CUR == '^') {\n-            if ((NXT(1) == ')') || (NXT(1) == '(') || (NXT(1) == '^')) {\n-                NEXT;\n-            }\n-    }\n-        *cur++ = CUR;\n-    NEXT;\n-    }\n-    *cur = 0;\n-\n-    if ((level != 0) && (CUR == 0)) {\n-        xmlFree(name);\n-    xmlFree(buffer);\n-    XP_ERROR(XPTR_SYNTAX_ERROR);\n-    }\n-\n-    if (xmlStrEqual(name, (xmlChar *) \"xpointer\") ||\n-        xmlStrEqual(name, (xmlChar *) \"xpath1\")) {\n-    const xmlChar *oldBase = ctxt->base;\n-    const xmlChar *oldCur = ctxt->cur;\n-\n-    ctxt->cur = ctxt->base = buffer;\n-    \/*\n-     * To evaluate an xpointer scheme element (4.3) we need:\n-     *   context initialized to the root\n-     *   context position initialized to 1\n-     *   context size initialized to 1\n-     *\/\n-    ctxt->context->node = (xmlNodePtr)ctxt->context->doc;\n-    ctxt->context->proximityPosition = 1;\n-    ctxt->context->contextSize = 1;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        ctxt->xptr = xmlStrEqual(name, (xmlChar *) \"xpointer\");\n-#endif\n-    xmlXPathEvalExpr(ctxt);\n-    ctxt->base = oldBase;\n-        ctxt->cur = oldCur;\n-    } else if (xmlStrEqual(name, (xmlChar *) \"element\")) {\n-    const xmlChar *oldBase = ctxt->base;\n-    const xmlChar *oldCur = ctxt->cur;\n-    xmlChar *name2;\n-\n-    ctxt->cur = ctxt->base = buffer;\n-    if (buffer[0] == '\/') {\n-        xmlXPathRoot(ctxt);\n-        xmlXPtrEvalChildSeq(ctxt, NULL);\n-    } else {\n-        name2 = xmlXPathParseName(ctxt);\n-        if (name2 == NULL) {\n-                ctxt->base = oldBase;\n-                ctxt->cur = oldCur;\n-        xmlFree(buffer);\n-                xmlFree(name);\n-        XP_ERROR(XPATH_EXPR_ERROR);\n-        }\n-        xmlXPtrEvalChildSeq(ctxt, name2);\n-    }\n-    ctxt->base = oldBase;\n-        ctxt->cur = oldCur;\n-#ifdef XPTR_XMLNS_SCHEME\n-    } else if (xmlStrEqual(name, (xmlChar *) \"xmlns\")) {\n-    const xmlChar *oldBase = ctxt->base;\n-    const xmlChar *oldCur = ctxt->cur;\n-    xmlChar *prefix;\n-\n-    ctxt->cur = ctxt->base = buffer;\n-        prefix = xmlXPathParseNCName(ctxt);\n-    if (prefix == NULL) {\n-            ctxt->base = oldBase;\n-            ctxt->cur = oldCur;\n-        xmlFree(buffer);\n-        xmlFree(name);\n-        XP_ERROR(XPTR_SYNTAX_ERROR);\n-    }\n-    SKIP_BLANKS;\n-    if (CUR != '=') {\n-            ctxt->base = oldBase;\n-            ctxt->cur = oldCur;\n-        xmlFree(prefix);\n-        xmlFree(buffer);\n-        xmlFree(name);\n-        XP_ERROR(XPTR_SYNTAX_ERROR);\n-    }\n-    NEXT;\n-    SKIP_BLANKS;\n-\n-    if (xmlXPathRegisterNs(ctxt->context, prefix, ctxt->cur) < 0)\n-            xmlXPathPErrMemory(ctxt);\n-        ctxt->base = oldBase;\n-        ctxt->cur = oldCur;\n-    xmlFree(prefix);\n-#endif \/* XPTR_XMLNS_SCHEME *\/\n-    } else {\n-        xmlXPtrErr(ctxt, XML_XPTR_UNKNOWN_SCHEME,\n-           \"unsupported scheme '%s'\\n\", name);\n-    }\n-    xmlFree(buffer);\n-    xmlFree(name);\n-}\n-\n-\/**\n- * xmlXPtrEvalFullXPtr:\n- * @ctxt:  the XPointer Parser context\n- * @name:  the preparsed Scheme for the first XPtrPart\n- *\n- * FullXPtr ::= XPtrPart (S? XPtrPart)*\n- *\n- * As the specs says:\n- * -----------\n- * When multiple XPtrParts are provided, they must be evaluated in\n- * left-to-right order. If evaluation of one part fails, the nexti\n- * is evaluated. The following conditions cause XPointer part failure:\n- *\n- * - An unknown scheme\n- * - A scheme that does not locate any sub-resource present in the resource\n- * - A scheme that is not applicable to the media type of the resource\n- *\n- * The XPointer application must consume a failed XPointer part and\n- * attempt to evaluate the next one, if any. The result of the first\n- * XPointer part whose evaluation succeeds is taken to be the fragment\n- * located by the XPointer as a whole. If all the parts fail, the result\n- * for the XPointer as a whole is a sub-resource error.\n- * -----------\n- *\n- * Parse and evaluate a Full XPtr i.e. possibly a cascade of XPath based\n- * expressions or other schemes.\n- *\/\n-static void\n-xmlXPtrEvalFullXPtr(xmlXPathParserContextPtr ctxt, xmlChar *name) {\n-    if (name == NULL)\n-    name = xmlXPathParseName(ctxt);\n-    if (name == NULL)\n-    XP_ERROR(XPATH_EXPR_ERROR);\n-    while (name != NULL) {\n-    ctxt->error = XPATH_EXPRESSION_OK;\n-    xmlXPtrEvalXPtrPart(ctxt, name);\n-\n-    \/* in case of syntax error, break here *\/\n-    if ((ctxt->error != XPATH_EXPRESSION_OK) &&\n-            (ctxt->error != XML_XPTR_UNKNOWN_SCHEME))\n-        return;\n-\n-    \/*\n-     * If the returned value is a non-empty nodeset\n-     * or location set, return here.\n-     *\/\n-    if (ctxt->value != NULL) {\n-        xmlXPathObjectPtr obj = ctxt->value;\n-\n-        switch (obj->type) {\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        case XPATH_LOCATIONSET: {\n-            xmlLocationSetPtr loc = ctxt->value->user;\n-            if ((loc != NULL) && (loc->locNr > 0))\n-            return;\n-            break;\n-        }\n-#endif\n-        case XPATH_NODESET: {\n-            xmlNodeSetPtr loc = ctxt->value->nodesetval;\n-            if ((loc != NULL) && (loc->nodeNr > 0))\n-            return;\n-            break;\n-        }\n-        default:\n-            break;\n-        }\n-\n-        \/*\n-         * Evaluating to improper values is equivalent to\n-         * a sub-resource error, clean-up the stack\n-         *\/\n-        do {\n-        obj = valuePop(ctxt);\n-        if (obj != NULL) {\n-            xmlXPathFreeObject(obj);\n-        }\n-        } while (obj != NULL);\n-    }\n-\n-    \/*\n-     * Is there another XPointer part.\n-     *\/\n-    SKIP_BLANKS;\n-    name = xmlXPathParseName(ctxt);\n-    }\n-}\n-\n-\/**\n- * xmlXPtrEvalChildSeq:\n- * @ctxt:  the XPointer Parser context\n- * @name:  a possible ID name of the child sequence\n- *\n- *  ChildSeq ::= '\/1' ('\/' [0-9]*)*\n- *             | Name ('\/' [0-9]*)+\n- *\n- * Parse and evaluate a Child Sequence. This routine also handle the\n- * case of a Bare Name used to get a document ID.\n- *\/\n-static void\n-xmlXPtrEvalChildSeq(xmlXPathParserContextPtr ctxt, xmlChar *name) {\n-    \/*\n-     * XPointer don't allow by syntax to address in multirooted trees\n-     * this might prove useful in some cases, warn about it.\n-     *\/\n-    if ((name == NULL) && (CUR == '\/') && (NXT(1) != '1')) {\n-        xmlXPtrErr(ctxt, XML_XPTR_CHILDSEQ_START,\n-           \"warning: ChildSeq not starting by \/1\\n\", NULL);\n-    }\n-\n-    if (name != NULL) {\n-    valuePush(ctxt, xmlXPathNewString(name));\n-    xmlFree(name);\n-    xmlXPathIdFunction(ctxt, 1);\n-    CHECK_ERROR;\n-    }\n-\n-    while (CUR == '\/') {\n-    int child = 0, overflow = 0;\n-    NEXT;\n-\n-    while ((CUR >= '0') && (CUR <= '9')) {\n-            int d = CUR - '0';\n-            if (child > INT_MAX \/ 10)\n-                overflow = 1;\n-            else\n-                child *= 10;\n-            if (child > INT_MAX - d)\n-                overflow = 1;\n-            else\n-                child += d;\n-        NEXT;\n-    }\n-        if (overflow)\n-            child = 0;\n-    xmlXPtrGetChildNo(ctxt, child);\n-    }\n-}\n-\n-\n-\/**\n- * xmlXPtrEvalXPointer:\n- * @ctxt:  the XPointer Parser context\n- *\n- *  XPointer ::= Name\n- *             | ChildSeq\n- *             | FullXPtr\n- *\n- * Parse and evaluate an XPointer\n- *\/\n-static void\n-xmlXPtrEvalXPointer(xmlXPathParserContextPtr ctxt) {\n-    if (ctxt->valueTab == NULL) {\n-    \/* Allocate the value stack *\/\n-    ctxt->valueTab = (xmlXPathObjectPtr *)\n-             xmlMalloc(10 * sizeof(xmlXPathObjectPtr));\n-    if (ctxt->valueTab == NULL) {\n-        xmlXPathPErrMemory(ctxt);\n-        return;\n-    }\n-    ctxt->valueNr = 0;\n-    ctxt->valueMax = 10;\n-    ctxt->value = NULL;\n-    }\n-    SKIP_BLANKS;\n-    if (CUR == '\/') {\n-    xmlXPathRoot(ctxt);\n-        xmlXPtrEvalChildSeq(ctxt, NULL);\n-    } else {\n-    xmlChar *name;\n-\n-    name = xmlXPathParseName(ctxt);\n-    if (name == NULL)\n-        XP_ERROR(XPATH_EXPR_ERROR);\n-    if (CUR == '(') {\n-        xmlXPtrEvalFullXPtr(ctxt, name);\n-        \/* Short evaluation *\/\n-        return;\n-    } else {\n-        \/* this handle both Bare Names and Child Sequences *\/\n-        xmlXPtrEvalChildSeq(ctxt, name);\n-    }\n-    }\n-    SKIP_BLANKS;\n-    if (CUR != 0)\n-    XP_ERROR(XPATH_EXPR_ERROR);\n-}\n-\n-\n-\/************************************************************************\n- *                                    *\n- *            General routines                *\n- *                                    *\n- ************************************************************************\/\n-\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-static\n-void xmlXPtrStringRangeFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-static\n-void xmlXPtrStartPointFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-static\n-void xmlXPtrEndPointFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-static\n-void xmlXPtrHereFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-static\n-void xmlXPtrOriginFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-static\n-void xmlXPtrRangeInsideFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-static\n-void xmlXPtrRangeFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-\n-\/**\n- * xmlXPtrNewContext:\n- * @doc:  the XML document\n- * @here:  the node that directly contains the XPointer being evaluated or NULL\n- * @origin:  the element from which a user or program initiated traversal of\n- *           the link, or NULL.\n- *\n- * Create a new XPointer context\n- *\n- * Returns the xmlXPathContext just allocated.\n- *\/\n-xmlXPathContextPtr\n-xmlXPtrNewContext(xmlDocPtr doc, xmlNodePtr here, xmlNodePtr origin) {\n-    xmlXPathContextPtr ret;\n-    (void) here;\n-    (void) origin;\n-\n-    ret = xmlXPathNewContext(doc);\n-    if (ret == NULL)\n-    return(ret);\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    ret->xptr = 1;\n-    ret->here = here;\n-    ret->origin = origin;\n-\n-    xmlXPathRegisterFunc(ret, (xmlChar *)\"range\",\n-                     xmlXPtrRangeFunction);\n-    xmlXPathRegisterFunc(ret, (xmlChar *)\"range-inside\",\n-                     xmlXPtrRangeInsideFunction);\n-    xmlXPathRegisterFunc(ret, (xmlChar *)\"string-range\",\n-                     xmlXPtrStringRangeFunction);\n-    xmlXPathRegisterFunc(ret, (xmlChar *)\"start-point\",\n-                     xmlXPtrStartPointFunction);\n-    xmlXPathRegisterFunc(ret, (xmlChar *)\"end-point\",\n-                     xmlXPtrEndPointFunction);\n-    xmlXPathRegisterFunc(ret, (xmlChar *)\"here\",\n-                     xmlXPtrHereFunction);\n-    xmlXPathRegisterFunc(ret, (xmlChar *)\" origin\",\n-                     xmlXPtrOriginFunction);\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXPtrEval:\n- * @str:  the XPointer expression\n- * @ctx:  the XPointer context\n- *\n- * Evaluate the XPath Location Path in the given context.\n- *\n- * Returns the xmlXPathObjectPtr resulting from the evaluation or NULL.\n- *         the caller has to free the object.\n- *\/\n-xmlXPathObjectPtr\n-xmlXPtrEval(const xmlChar *str, xmlXPathContextPtr ctx) {\n-    xmlXPathParserContextPtr ctxt;\n-    xmlXPathObjectPtr res = NULL, tmp;\n-    xmlXPathObjectPtr init = NULL;\n-    int stack = 0;\n-\n-    xmlInitParser();\n-\n-    if ((ctx == NULL) || (str == NULL))\n-    return(NULL);\n-\n-    xmlResetError(&ctx->lastError);\n-\n-    ctxt = xmlXPathNewParserContext(str, ctx);\n-    if (ctxt == NULL) {\n-        xmlXPathErrMemory(ctx);\n-    return(NULL);\n-    }\n-    xmlXPtrEvalXPointer(ctxt);\n-    if (ctx->lastError.code != XML_ERR_OK)\n-        goto error;\n-\n-    if ((ctxt->value != NULL) &&\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    (ctxt->value->type != XPATH_LOCATIONSET) &&\n-#endif\n-    (ctxt->value->type != XPATH_NODESET)) {\n-        xmlXPtrErr(ctxt, XML_XPTR_EVAL_FAILED,\n-        \"xmlXPtrEval: evaluation failed to return a node set\\n\",\n-           NULL);\n-    } else {\n-    res = valuePop(ctxt);\n-    }\n-\n-    do {\n-        tmp = valuePop(ctxt);\n-    if (tmp != NULL) {\n-        if (tmp != init) {\n-        if (tmp->type == XPATH_NODESET) {\n-            \/*\n-             * Evaluation may push a root nodeset which is unused\n-             *\/\n-            xmlNodeSetPtr set;\n-            set = tmp->nodesetval;\n-            if ((set == NULL) || (set->nodeNr != 1) ||\n-            (set->nodeTab[0] != (xmlNodePtr) ctx->doc))\n-            stack++;\n-        } else\n-            stack++;\n-        }\n-        xmlXPathFreeObject(tmp);\n-        }\n-    } while (tmp != NULL);\n-    if (stack != 0) {\n-        xmlXPtrErr(ctxt, XML_XPTR_EXTRA_OBJECTS,\n-           \"xmlXPtrEval: object(s) left on the eval stack\\n\",\n-           NULL);\n-    }\n-    if (ctx->lastError.code != XML_ERR_OK) {\n-    xmlXPathFreeObject(res);\n-    res = NULL;\n-    }\n-\n-error:\n-    xmlXPathFreeParserContext(ctxt);\n-    return(res);\n-}\n-\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-\/**\n- * xmlXPtrBuildRangeNodeList:\n- * @range:  a range object\n- *\n- * Build a node list tree copy of the range\n- *\n- * Returns an xmlNodePtr list or NULL.\n- *         the caller has to free the node tree.\n- *\/\n-static xmlNodePtr\n-xmlXPtrBuildRangeNodeList(xmlXPathObjectPtr range) {\n-    \/* pointers to generated nodes *\/\n-    xmlNodePtr list = NULL, last = NULL, parent = NULL, tmp;\n-    \/* pointers to traversal nodes *\/\n-    xmlNodePtr start, cur, end;\n-    int index1, index2;\n-\n-    if (range == NULL)\n-    return(NULL);\n-    if (range->type != XPATH_RANGE)\n-    return(NULL);\n-    start = (xmlNodePtr) range->user;\n-\n-    if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))\n-    return(NULL);\n-    end = range->user2;\n-    if (end == NULL)\n-    return(xmlCopyNode(start, 1));\n-    if (end->type == XML_NAMESPACE_DECL)\n-        return(NULL);\n-\n-    cur = start;\n-    index1 = range->index;\n-    index2 = range->index2;\n-    while (cur != NULL) {\n-    if (cur == end) {\n-        if (cur->type == XML_TEXT_NODE) {\n-        const xmlChar *content = cur->content;\n-        int len;\n-\n-        if (content == NULL) {\n-            tmp = xmlNewTextLen(NULL, 0);\n-        } else {\n-            len = index2;\n-            if ((cur == start) && (index1 > 1)) {\n-            content += (index1 - 1);\n-            len -= (index1 - 1);\n-            index1 = 0;\n-            } else {\n-            len = index2;\n-            }\n-            tmp = xmlNewTextLen(content, len);\n-        }\n-        \/* single sub text node selection *\/\n-        if (list == NULL)\n-            return(tmp);\n-        \/* prune and return full set *\/\n-        if (last != NULL)\n-            xmlAddNextSibling(last, tmp);\n-        else\n-            xmlAddChild(parent, tmp);\n-        return(list);\n-        } else {\n-        tmp = xmlCopyNode(cur, 0);\n-        if (list == NULL) {\n-            list = tmp;\n-            parent = tmp;\n-        } else {\n-            if (last != NULL)\n-            parent = xmlAddNextSibling(last, tmp);\n-            else\n-            parent = xmlAddChild(parent, tmp);\n-        }\n-        last = NULL;\n-\n-        if (index2 > 1) {\n-            end = xmlXPtrGetNthChild(cur, index2 - 1);\n-            index2 = 0;\n-        }\n-        if ((cur == start) && (index1 > 1)) {\n-            cur = xmlXPtrGetNthChild(cur, index1 - 1);\n-            index1 = 0;\n-        } else {\n-            cur = cur->children;\n-        }\n-        \/*\n-         * Now gather the remaining nodes from cur to end\n-         *\/\n-        continue; \/* while *\/\n-        }\n-    } else if ((cur == start) &&\n-           (list == NULL) \/* looks superfluous but ... *\/ ) {\n-        if ((cur->type == XML_TEXT_NODE) ||\n-        (cur->type == XML_CDATA_SECTION_NODE)) {\n-        const xmlChar *content = cur->content;\n-\n-        if (content == NULL) {\n-            tmp = xmlNewTextLen(NULL, 0);\n-        } else {\n-            if (index1 > 1) {\n-            content += (index1 - 1);\n-            }\n-            tmp = xmlNewText(content);\n-        }\n-        last = list = tmp;\n-        } else {\n-        if ((cur == start) && (index1 > 1)) {\n-            tmp = xmlCopyNode(cur, 0);\n-            list = tmp;\n-            parent = tmp;\n-            last = NULL;\n-            cur = xmlXPtrGetNthChild(cur, index1 - 1);\n-            index1 = 0;\n-            \/*\n-             * Now gather the remaining nodes from cur to end\n-             *\/\n-            continue; \/* while *\/\n-        }\n-        tmp = xmlCopyNode(cur, 1);\n-        list = tmp;\n-        parent = NULL;\n-        last = tmp;\n-        }\n-    } else {\n-        tmp = NULL;\n-        switch (cur->type) {\n-        case XML_DTD_NODE:\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_ENTITY_NODE:\n-            \/* Do not copy DTD information *\/\n-            break;\n-        case XML_ENTITY_DECL:\n-            \/* TODO: handle crossing entities -> stack needed *\/\n-            break;\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-            \/* don't consider it part of the tree content *\/\n-            break;\n-        case XML_ATTRIBUTE_NODE:\n-            \/* Humm, should not happen ! *\/\n-            break;\n-        default:\n-            tmp = xmlCopyNode(cur, 1);\n-            break;\n-        }\n-        if (tmp != NULL) {\n-        if ((list == NULL) || ((last == NULL) && (parent == NULL)))  {\n-            return(NULL);\n-        }\n-        if (last != NULL)\n-            xmlAddNextSibling(last, tmp);\n-        else {\n-            last = xmlAddChild(parent, tmp);\n-        }\n-        }\n-    }\n-    \/*\n-     * Skip to next node in document order\n-     *\/\n-    if ((list == NULL) || ((last == NULL) && (parent == NULL)))  {\n-        return(NULL);\n-    }\n-    cur = xmlXPtrAdvanceNode(cur, NULL);\n-    }\n-    return(list);\n-}\n-\n-\/**\n- * xmlXPtrBuildNodeList:\n- * @obj:  the XPointer result from the evaluation.\n- *\n- * Build a node list tree copy of the XPointer result.\n- * This will drop Attributes and Namespace declarations.\n- *\n- * Returns an xmlNodePtr list or NULL.\n- *         the caller has to free the node tree.\n- *\/\n-xmlNodePtr\n-xmlXPtrBuildNodeList(xmlXPathObjectPtr obj) {\n-    xmlNodePtr list = NULL, last = NULL;\n-    int i;\n-\n-    if (obj == NULL)\n-    return(NULL);\n-    switch (obj->type) {\n-        case XPATH_NODESET: {\n-        xmlNodeSetPtr set = obj->nodesetval;\n-        if (set == NULL)\n-        return(NULL);\n-        for (i = 0;i < set->nodeNr;i++) {\n-        if (set->nodeTab[i] == NULL)\n-            continue;\n-        switch (set->nodeTab[i]->type) {\n-            case XML_TEXT_NODE:\n-            case XML_CDATA_SECTION_NODE:\n-            case XML_ELEMENT_NODE:\n-            case XML_ENTITY_REF_NODE:\n-            case XML_ENTITY_NODE:\n-            case XML_PI_NODE:\n-            case XML_COMMENT_NODE:\n-            case XML_DOCUMENT_NODE:\n-            case XML_HTML_DOCUMENT_NODE:\n-            case XML_XINCLUDE_START:\n-            case XML_XINCLUDE_END:\n-            break;\n-            case XML_ATTRIBUTE_NODE:\n-            case XML_NAMESPACE_DECL:\n-            case XML_DOCUMENT_TYPE_NODE:\n-            case XML_DOCUMENT_FRAG_NODE:\n-            case XML_NOTATION_NODE:\n-            case XML_DTD_NODE:\n-            case XML_ELEMENT_DECL:\n-            case XML_ATTRIBUTE_DECL:\n-            case XML_ENTITY_DECL:\n-            continue; \/* for *\/\n-        }\n-        if (last == NULL)\n-            list = last = xmlCopyNode(set->nodeTab[i], 1);\n-        else {\n-            xmlAddNextSibling(last, xmlCopyNode(set->nodeTab[i], 1));\n-            if (last->next != NULL)\n-            last = last->next;\n-        }\n-        }\n-        break;\n-    }\n-    case XPATH_LOCATIONSET: {\n-        xmlLocationSetPtr set = (xmlLocationSetPtr) obj->user;\n-        if (set == NULL)\n-        return(NULL);\n-        for (i = 0;i < set->locNr;i++) {\n-        if (last == NULL)\n-            list = last = xmlXPtrBuildNodeList(set->locTab[i]);\n-        else\n-            xmlAddNextSibling(last,\n-                xmlXPtrBuildNodeList(set->locTab[i]));\n-        if (last != NULL) {\n-            while (last->next != NULL)\n-            last = last->next;\n-        }\n-        }\n-        break;\n-    }\n-    case XPATH_RANGE:\n-        return(xmlXPtrBuildRangeNodeList(obj));\n-    case XPATH_POINT:\n-        return(xmlCopyNode(obj->user, 0));\n-    default:\n-        break;\n-    }\n-    return(list);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *            XPointer functions                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlXPtrNbLocChildren:\n- * @node:  an xmlNodePtr\n- *\n- * Count the number of location children of @node or the length of the\n- * string value in case of text\/PI\/Comments nodes\n- *\n- * Returns the number of location children\n- *\/\n-static int\n-xmlXPtrNbLocChildren(xmlNodePtr node) {\n-    int ret = 0;\n-    if (node == NULL)\n-    return(-1);\n-    switch (node->type) {\n-        case XML_HTML_DOCUMENT_NODE:\n-        case XML_DOCUMENT_NODE:\n-        case XML_ELEMENT_NODE:\n-        node = node->children;\n-        while (node != NULL) {\n-        if (node->type == XML_ELEMENT_NODE)\n-            ret++;\n-        node = node->next;\n-        }\n-        break;\n-        case XML_ATTRIBUTE_NODE:\n-        return(-1);\n-\n-        case XML_PI_NODE:\n-        case XML_COMMENT_NODE:\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        case XML_ENTITY_REF_NODE:\n-        ret = xmlStrlen(node->content);\n-        break;\n-    default:\n-        return(-1);\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXPtrHereFunction:\n- * @ctxt:  the XPointer Parser context\n- * @nargs:  the number of args\n- *\n- * Function implementing here() operation\n- * as described in 5.4.3\n- *\/\n-static void\n-xmlXPtrHereFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n-    CHECK_ARITY(0);\n-\n-    if (ctxt->context->here == NULL)\n-    XP_ERROR(XPTR_SYNTAX_ERROR);\n-\n-    valuePush(ctxt, xmlXPtrNewLocationSetNodes(ctxt->context->here, NULL));\n-}\n-\n-\/**\n- * xmlXPtrOriginFunction:\n- * @ctxt:  the XPointer Parser context\n- * @nargs:  the number of args\n- *\n- * Function implementing origin() operation\n- * as described in 5.4.3\n- *\/\n-static void\n-xmlXPtrOriginFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n-    CHECK_ARITY(0);\n-\n-    if (ctxt->context->origin == NULL)\n-    XP_ERROR(XPTR_SYNTAX_ERROR);\n-\n-    valuePush(ctxt, xmlXPtrNewLocationSetNodes(ctxt->context->origin, NULL));\n-}\n-\n-\/**\n- * xmlXPtrStartPointFunction:\n- * @ctxt:  the XPointer Parser context\n- * @nargs:  the number of args\n- *\n- * Function implementing start-point() operation\n- * as described in 5.4.3\n- * ----------------\n- * location-set start-point(location-set)\n- *\n- * For each location x in the argument location-set, start-point adds a\n- * location of type point to the result location-set. That point represents\n- * the start point of location x and is determined by the following rules:\n- *\n- * - If x is of type point, the start point is x.\n- * - If x is of type range, the start point is the start point of x.\n- * - If x is of type root, element, text, comment, or processing instruction,\n- * - the container node of the start point is x and the index is 0.\n- * - If x is of type attribute or namespace, the function must signal a\n- *   syntax error.\n- * ----------------\n- *\n- *\/\n-static void\n-xmlXPtrStartPointFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlXPathObjectPtr tmp, obj, point;\n-    xmlLocationSetPtr newset = NULL;\n-    xmlLocationSetPtr oldset = NULL;\n-\n-    CHECK_ARITY(1);\n-    if ((ctxt->value == NULL) ||\n-    ((ctxt->value->type != XPATH_LOCATIONSET) &&\n-     (ctxt->value->type != XPATH_NODESET)))\n-        XP_ERROR(XPATH_INVALID_TYPE)\n-\n-    obj = valuePop(ctxt);\n-    if (obj->type == XPATH_NODESET) {\n-    \/*\n-     * First convert to a location set\n-     *\/\n-    tmp = xmlXPtrNewLocationSetNodeSet(obj->nodesetval);\n-    xmlXPathFreeObject(obj);\n-    if (tmp == NULL)\n-            XP_ERROR(XPATH_MEMORY_ERROR)\n-    obj = tmp;\n-    }\n-\n-    newset = xmlXPtrLocationSetCreate(NULL);\n-    if (newset == NULL) {\n-    xmlXPathFreeObject(obj);\n-        XP_ERROR(XPATH_MEMORY_ERROR);\n-    }\n-    oldset = (xmlLocationSetPtr) obj->user;\n-    if (oldset != NULL) {\n-    int i;\n-\n-    for (i = 0; i < oldset->locNr; i++) {\n-        tmp = oldset->locTab[i];\n-        if (tmp == NULL)\n-        continue;\n-        point = NULL;\n-        switch (tmp->type) {\n-        case XPATH_POINT:\n-            point = xmlXPtrNewPoint(tmp->user, tmp->index);\n-            break;\n-        case XPATH_RANGE: {\n-            xmlNodePtr node = tmp->user;\n-            if (node != NULL) {\n-            if ((node->type == XML_ATTRIBUTE_NODE) ||\n-                            (node->type == XML_NAMESPACE_DECL)) {\n-                xmlXPathFreeObject(obj);\n-                xmlXPtrFreeLocationSet(newset);\n-                XP_ERROR(XPTR_SYNTAX_ERROR);\n-            }\n-            point = xmlXPtrNewPoint(node, tmp->index);\n-            }\n-            break;\n-            }\n-        default:\n-            \/*** Should we raise an error ?\n-            xmlXPathFreeObject(obj);\n-            xmlXPathFreeObject(newset);\n-            XP_ERROR(XPATH_INVALID_TYPE)\n-            ***\/\n-            break;\n-        }\n-            if (point != NULL)\n-        xmlXPtrLocationSetAdd(newset, point);\n-    }\n-    }\n-    xmlXPathFreeObject(obj);\n-    valuePush(ctxt, xmlXPtrWrapLocationSet(newset));\n-}\n-\n-\/**\n- * xmlXPtrEndPointFunction:\n- * @ctxt:  the XPointer Parser context\n- * @nargs:  the number of args\n- *\n- * Function implementing end-point() operation\n- * as described in 5.4.3\n- * ----------------------------\n- * location-set end-point(location-set)\n- *\n- * For each location x in the argument location-set, end-point adds a\n- * location of type point to the result location-set. That point represents\n- * the end point of location x and is determined by the following rules:\n- *\n- * - If x is of type point, the resulting point is x.\n- * - If x is of type range, the resulting point is the end point of x.\n- * - If x is of type root or element, the container node of the resulting\n- *   point is x and the index is the number of location children of x.\n- * - If x is of type text, comment, or processing instruction, the container\n- *   node of the resulting point is x and the index is the length of the\n- *   string-value of x.\n- * - If x is of type attribute or namespace, the function must signal a\n- *   syntax error.\n- * ----------------------------\n- *\/\n-static void\n-xmlXPtrEndPointFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlXPathObjectPtr tmp, obj, point;\n-    xmlLocationSetPtr newset = NULL;\n-    xmlLocationSetPtr oldset = NULL;\n-\n-    CHECK_ARITY(1);\n-    if ((ctxt->value == NULL) ||\n-    ((ctxt->value->type != XPATH_LOCATIONSET) &&\n-     (ctxt->value->type != XPATH_NODESET)))\n-        XP_ERROR(XPATH_INVALID_TYPE)\n-\n-    obj = valuePop(ctxt);\n-    if (obj->type == XPATH_NODESET) {\n-    \/*\n-     * First convert to a location set\n-     *\/\n-    tmp = xmlXPtrNewLocationSetNodeSet(obj->nodesetval);\n-    xmlXPathFreeObject(obj);\n-    if (tmp == NULL)\n-            XP_ERROR(XPATH_MEMORY_ERROR)\n-    obj = tmp;\n-    }\n-\n-    newset = xmlXPtrLocationSetCreate(NULL);\n-    if (newset == NULL) {\n-    xmlXPathFreeObject(obj);\n-        XP_ERROR(XPATH_MEMORY_ERROR);\n-    }\n-    oldset = (xmlLocationSetPtr) obj->user;\n-    if (oldset != NULL) {\n-    int i;\n-\n-    for (i = 0; i < oldset->locNr; i++) {\n-        tmp = oldset->locTab[i];\n-        if (tmp == NULL)\n-        continue;\n-        point = NULL;\n-        switch (tmp->type) {\n-        case XPATH_POINT:\n-            point = xmlXPtrNewPoint(tmp->user, tmp->index);\n-            break;\n-        case XPATH_RANGE: {\n-            xmlNodePtr node = tmp->user2;\n-            if (node != NULL) {\n-            if ((node->type == XML_ATTRIBUTE_NODE) ||\n-                            (node->type == XML_NAMESPACE_DECL)) {\n-                xmlXPathFreeObject(obj);\n-                xmlXPtrFreeLocationSet(newset);\n-                XP_ERROR(XPTR_SYNTAX_ERROR);\n-            }\n-            point = xmlXPtrNewPoint(node, tmp->index2);\n-            } else if (tmp->user == NULL) {\n-            point = xmlXPtrNewPoint(node,\n-                       xmlXPtrNbLocChildren(node));\n-            }\n-            break;\n-            }\n-        default:\n-            \/*** Should we raise an error ?\n-            xmlXPathFreeObject(obj);\n-            xmlXPathFreeObject(newset);\n-            XP_ERROR(XPATH_INVALID_TYPE)\n-            ***\/\n-            break;\n-        }\n-            if (point != NULL)\n-        xmlXPtrLocationSetAdd(newset, point);\n-    }\n-    }\n-    xmlXPathFreeObject(obj);\n-    valuePush(ctxt, xmlXPtrWrapLocationSet(newset));\n-}\n-\n-\n-\/**\n- * xmlXPtrCoveringRange:\n- * @ctxt:  the XPointer Parser context\n- * @loc:  the location for which the covering range must be computed\n- *\n- * A covering range is a range that wholly encompasses a location\n- * Section 5.3.3. Covering Ranges for All Location Types\n- *        http:\/\/www.w3.org\/TR\/xptr#N2267\n- *\n- * Returns a new location or NULL in case of error\n- *\/\n-static xmlXPathObjectPtr\n-xmlXPtrCoveringRange(xmlXPathParserContextPtr ctxt, xmlXPathObjectPtr loc) {\n-    if (loc == NULL)\n-    return(NULL);\n-    if ((ctxt == NULL) || (ctxt->context == NULL) ||\n-    (ctxt->context->doc == NULL))\n-    return(NULL);\n-    switch (loc->type) {\n-        case XPATH_POINT:\n-        return(xmlXPtrNewRange(loc->user, loc->index,\n-                       loc->user, loc->index));\n-        case XPATH_RANGE:\n-        if (loc->user2 != NULL) {\n-        return(xmlXPtrNewRange(loc->user, loc->index,\n-                          loc->user2, loc->index2));\n-        } else {\n-        xmlNodePtr node = (xmlNodePtr) loc->user;\n-        if (node == (xmlNodePtr) ctxt->context->doc) {\n-            return(xmlXPtrNewRange(node, 0, node,\n-                       xmlXPtrGetArity(node)));\n-        } else {\n-            switch (node->type) {\n-            case XML_ATTRIBUTE_NODE:\n-            \/* !!! our model is slightly different than XPath *\/\n-                return(xmlXPtrNewRange(node, 0, node,\n-                               xmlXPtrGetArity(node)));\n-            case XML_ELEMENT_NODE:\n-            case XML_TEXT_NODE:\n-            case XML_CDATA_SECTION_NODE:\n-            case XML_ENTITY_REF_NODE:\n-            case XML_PI_NODE:\n-            case XML_COMMENT_NODE:\n-            case XML_DOCUMENT_NODE:\n-            case XML_NOTATION_NODE:\n-            case XML_HTML_DOCUMENT_NODE: {\n-                int indx = xmlXPtrGetIndex(node);\n-\n-                node = node->parent;\n-                return(xmlXPtrNewRange(node, indx - 1,\n-                               node, indx + 1));\n-            }\n-            default:\n-                return(NULL);\n-            }\n-        }\n-        }\n-    default:\n-        \/* TODO: missed one case ??? *\/\n-            break;\n-    }\n-    return(NULL);\n-}\n-\n-\/**\n- * xmlXPtrRangeFunction:\n- * @ctxt:  the XPointer Parser context\n- * @nargs:  the number of args\n- *\n- * Function implementing the range() function 5.4.3\n- *  location-set range(location-set )\n- *\n- *  The range function returns ranges covering the locations in\n- *  the argument location-set. For each location x in the argument\n- *  location-set, a range location representing the covering range of\n- *  x is added to the result location-set.\n- *\/\n-static void\n-xmlXPtrRangeFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n-    int i;\n-    xmlXPathObjectPtr set;\n-    xmlLocationSetPtr oldset;\n-    xmlLocationSetPtr newset;\n-\n-    CHECK_ARITY(1);\n-    if ((ctxt->value == NULL) ||\n-    ((ctxt->value->type != XPATH_LOCATIONSET) &&\n-     (ctxt->value->type != XPATH_NODESET)))\n-        XP_ERROR(XPATH_INVALID_TYPE)\n-\n-    set = valuePop(ctxt);\n-    if (set->type == XPATH_NODESET) {\n-    xmlXPathObjectPtr tmp;\n-\n-    \/*\n-     * First convert to a location set\n-     *\/\n-    tmp = xmlXPtrNewLocationSetNodeSet(set->nodesetval);\n-    xmlXPathFreeObject(set);\n-    if (tmp == NULL)\n-            XP_ERROR(XPATH_MEMORY_ERROR)\n-    set = tmp;\n-    }\n-    oldset = (xmlLocationSetPtr) set->user;\n-\n-    \/*\n-     * The loop is to compute the covering range for each item and add it\n-     *\/\n-    newset = xmlXPtrLocationSetCreate(NULL);\n-    if (newset == NULL) {\n-    xmlXPathFreeObject(set);\n-        XP_ERROR(XPATH_MEMORY_ERROR);\n-    }\n-    if (oldset != NULL) {\n-        for (i = 0;i < oldset->locNr;i++) {\n-            xmlXPtrLocationSetAdd(newset,\n-                    xmlXPtrCoveringRange(ctxt, oldset->locTab[i]));\n-        }\n-    }\n-\n-    \/*\n-     * Save the new value and cleanup\n-     *\/\n-    valuePush(ctxt, xmlXPtrWrapLocationSet(newset));\n-    xmlXPathFreeObject(set);\n-}\n-\n-\/**\n- * xmlXPtrInsideRange:\n- * @ctxt:  the XPointer Parser context\n- * @loc:  the location for which the inside range must be computed\n- *\n- * A inside range is a range described in the range-inside() description\n- *\n- * Returns a new location or NULL in case of error\n- *\/\n-static xmlXPathObjectPtr\n-xmlXPtrInsideRange(xmlXPathParserContextPtr ctxt, xmlXPathObjectPtr loc) {\n-    if (loc == NULL)\n-    return(NULL);\n-    if ((ctxt == NULL) || (ctxt->context == NULL) ||\n-    (ctxt->context->doc == NULL))\n-    return(NULL);\n-    switch (loc->type) {\n-        case XPATH_POINT: {\n-        xmlNodePtr node = (xmlNodePtr) loc->user;\n-        switch (node->type) {\n-        case XML_PI_NODE:\n-        case XML_COMMENT_NODE:\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE: {\n-            if (node->content == NULL) {\n-            return(xmlXPtrNewRange(node, 0, node, 0));\n-            } else {\n-            return(xmlXPtrNewRange(node, 0, node,\n-                           xmlStrlen(node->content)));\n-            }\n-        }\n-        case XML_ATTRIBUTE_NODE:\n-        case XML_ELEMENT_NODE:\n-        case XML_ENTITY_REF_NODE:\n-        case XML_DOCUMENT_NODE:\n-        case XML_NOTATION_NODE:\n-        case XML_HTML_DOCUMENT_NODE: {\n-            return(xmlXPtrNewRange(node, 0, node,\n-                       xmlXPtrGetArity(node)));\n-        }\n-        default:\n-            break;\n-        }\n-        return(NULL);\n-    }\n-        case XPATH_RANGE: {\n-        xmlNodePtr node = (xmlNodePtr) loc->user;\n-        if (loc->user2 != NULL) {\n-        return(xmlXPtrNewRange(node, loc->index,\n-                           loc->user2, loc->index2));\n-        } else {\n-        switch (node->type) {\n-            case XML_PI_NODE:\n-            case XML_COMMENT_NODE:\n-            case XML_TEXT_NODE:\n-            case XML_CDATA_SECTION_NODE: {\n-            if (node->content == NULL) {\n-                return(xmlXPtrNewRange(node, 0, node, 0));\n-            } else {\n-                return(xmlXPtrNewRange(node, 0, node,\n-                           xmlStrlen(node->content)));\n-            }\n-            }\n-            case XML_ATTRIBUTE_NODE:\n-            case XML_ELEMENT_NODE:\n-            case XML_ENTITY_REF_NODE:\n-            case XML_DOCUMENT_NODE:\n-            case XML_NOTATION_NODE:\n-            case XML_HTML_DOCUMENT_NODE: {\n-            return(xmlXPtrNewRange(node, 0, node,\n-                           xmlXPtrGetArity(node)));\n-            }\n-            default:\n-            break;\n-        }\n-        return(NULL);\n-        }\n-        }\n-    default:\n-        \/* TODO: missed one case ??? *\/\n-            break;\n-    }\n-    return(NULL);\n-}\n-\n-\/**\n- * xmlXPtrRangeInsideFunction:\n- * @ctxt:  the XPointer Parser context\n- * @nargs:  the number of args\n- *\n- * Function implementing the range-inside() function 5.4.3\n- *  location-set range-inside(location-set )\n- *\n- *  The range-inside function returns ranges covering the contents of\n- *  the locations in the argument location-set. For each location x in\n- *  the argument location-set, a range location is added to the result\n- *  location-set. If x is a range location, then x is added to the\n- *  result location-set. If x is not a range location, then x is used\n- *  as the container location of the start and end points of the range\n- *  location to be added; the index of the start point of the range is\n- *  zero; if the end point is a character point then its index is the\n- *  length of the string-value of x, and otherwise is the number of\n- *  location children of x.\n- *\n- *\/\n-static void\n-xmlXPtrRangeInsideFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n-    int i;\n-    xmlXPathObjectPtr set;\n-    xmlLocationSetPtr oldset;\n-    xmlLocationSetPtr newset;\n-\n-    CHECK_ARITY(1);\n-    if ((ctxt->value == NULL) ||\n-    ((ctxt->value->type != XPATH_LOCATIONSET) &&\n-     (ctxt->value->type != XPATH_NODESET)))\n-        XP_ERROR(XPATH_INVALID_TYPE)\n-\n-    set = valuePop(ctxt);\n-    if (set->type == XPATH_NODESET) {\n-    xmlXPathObjectPtr tmp;\n-\n-    \/*\n-     * First convert to a location set\n-     *\/\n-    tmp = xmlXPtrNewLocationSetNodeSet(set->nodesetval);\n-    xmlXPathFreeObject(set);\n-    if (tmp == NULL)\n-         XP_ERROR(XPATH_MEMORY_ERROR)\n-    set = tmp;\n-    }\n-\n-    \/*\n-     * The loop is to compute the covering range for each item and add it\n-     *\/\n-    newset = xmlXPtrLocationSetCreate(NULL);\n-    if (newset == NULL) {\n-    xmlXPathFreeObject(set);\n-        XP_ERROR(XPATH_MEMORY_ERROR);\n-    }\n-    oldset = (xmlLocationSetPtr) set->user;\n-    if (oldset != NULL) {\n-        for (i = 0;i < oldset->locNr;i++) {\n-            xmlXPtrLocationSetAdd(newset,\n-                    xmlXPtrInsideRange(ctxt, oldset->locTab[i]));\n-        }\n-    }\n-\n-    \/*\n-     * Save the new value and cleanup\n-     *\/\n-    valuePush(ctxt, xmlXPtrWrapLocationSet(newset));\n-    xmlXPathFreeObject(set);\n-}\n-\n-\/**\n- * xmlXPtrRangeToFunction:\n- * @ctxt:  the XPointer Parser context\n- * @nargs:  the number of args\n- *\n- * Implement the range-to() XPointer function\n- *\n- * Obsolete. range-to is not a real function but a special type of location\n- * step which is handled in xpath.c.\n- *\/\n-void\n-xmlXPtrRangeToFunction(xmlXPathParserContextPtr ctxt,\n-                       int nargs ATTRIBUTE_UNUSED) {\n-    XP_ERROR(XPATH_EXPR_ERROR);\n-}\n-\n-\/**\n- * xmlXPtrAdvanceNode:\n- * @cur:  the node\n- * @level: incremented\/decremented to show level in tree\n- *\n- * Advance to the next element or text node in document order\n- * TODO: add a stack for entering\/exiting entities\n- *\n- * Returns -1 in case of failure, 0 otherwise\n- *\/\n-xmlNodePtr\n-xmlXPtrAdvanceNode(xmlNodePtr cur, int *level) {\n-next:\n-    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n-    return(NULL);\n-    if (cur->children != NULL) {\n-        cur = cur->children ;\n-    if (level != NULL)\n-        (*level)++;\n-    goto found;\n-    }\n-skip:        \/* This label should only be needed if something is wrong! *\/\n-    if (cur->next != NULL) {\n-    cur = cur->next;\n-    goto found;\n-    }\n-    do {\n-        cur = cur->parent;\n-    if (level != NULL)\n-        (*level)--;\n-        if (cur == NULL) return(NULL);\n-        if (cur->next != NULL) {\n-        cur = cur->next;\n-        goto found;\n-    }\n-    } while (cur != NULL);\n-\n-found:\n-    if ((cur->type != XML_ELEMENT_NODE) &&\n-    (cur->type != XML_TEXT_NODE) &&\n-    (cur->type != XML_DOCUMENT_NODE) &&\n-    (cur->type != XML_HTML_DOCUMENT_NODE) &&\n-    (cur->type != XML_CDATA_SECTION_NODE)) {\n-        if (cur->type == XML_ENTITY_REF_NODE) {    \/* Shouldn't happen *\/\n-        goto skip;\n-        }\n-        goto next;\n-    }\n-    return(cur);\n-}\n-\n-\/**\n- * xmlXPtrAdvanceChar:\n- * @node:  the node\n- * @indx:  the indx\n- * @bytes:  the number of bytes\n- *\n- * Advance a point of the associated number of bytes (not UTF8 chars)\n- *\n- * Returns -1 in case of failure, 0 otherwise\n- *\/\n-static int\n-xmlXPtrAdvanceChar(xmlNodePtr *node, int *indx, int bytes) {\n-    xmlNodePtr cur;\n-    int pos;\n-    int len;\n-\n-    if ((node == NULL) || (indx == NULL))\n-    return(-1);\n-    cur = *node;\n-    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n-    return(-1);\n-    pos = *indx;\n-\n-    while (bytes >= 0) {\n-    \/*\n-     * First position to the beginning of the first text node\n-     * corresponding to this point\n-     *\/\n-    while ((cur != NULL) &&\n-           ((cur->type == XML_ELEMENT_NODE) ||\n-            (cur->type == XML_DOCUMENT_NODE) ||\n-            (cur->type == XML_HTML_DOCUMENT_NODE))) {\n-        if (pos > 0) {\n-        cur = xmlXPtrGetNthChild(cur, pos);\n-        pos = 0;\n-        } else {\n-        cur = xmlXPtrAdvanceNode(cur, NULL);\n-        pos = 0;\n-        }\n-    }\n-\n-    if (cur == NULL) {\n-        *node = NULL;\n-        *indx = 0;\n-        return(-1);\n-    }\n-\n-    \/*\n-     * if there is no move needed return the current value.\n-     *\/\n-    if (pos == 0) pos = 1;\n-    if (bytes == 0) {\n-        *node = cur;\n-        *indx = pos;\n-        return(0);\n-    }\n-    \/*\n-     * We should have a text (or cdata) node ...\n-     *\/\n-    len = 0;\n-    if ((cur->type != XML_ELEMENT_NODE) &&\n-            (cur->content != NULL)) {\n-        len = xmlStrlen(cur->content);\n-    }\n-    if (pos > len) {\n-        \/* Strange, the indx in the text node is greater than it's len *\/\n-        pos = len;\n-    }\n-    if (pos + bytes >= len) {\n-        bytes -= (len - pos);\n-        cur = xmlXPtrAdvanceNode(cur, NULL);\n-        pos = 0;\n-    } else if (pos + bytes < len) {\n-        pos += bytes;\n-        *node = cur;\n-        *indx = pos;\n-        return(0);\n-    }\n-    }\n-    return(-1);\n-}\n-\n-\/**\n- * xmlXPtrMatchString:\n- * @string:  the string to search\n- * @start:  the start textnode\n- * @startindex:  the start index\n- * @end:  the end textnode IN\/OUT\n- * @endindex:  the end index IN\/OUT\n- *\n- * Check whether the document contains @string at the position\n- * (@start, @startindex) and limited by the (@end, @endindex) point\n- *\n- * Returns -1 in case of failure, 0 if not found, 1 if found in which case\n- *            (@start, @startindex) will indicate the position of the beginning\n- *            of the range and (@end, @endindex) will indicate the end\n- *            of the range\n- *\/\n-static int\n-xmlXPtrMatchString(const xmlChar *string, xmlNodePtr start, int startindex,\n-                xmlNodePtr *end, int *endindex) {\n-    xmlNodePtr cur;\n-    int pos; \/* 0 based *\/\n-    int len; \/* in bytes *\/\n-    int stringlen; \/* in bytes *\/\n-    int match;\n-\n-    if (string == NULL)\n-    return(-1);\n-    if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))\n-    return(-1);\n-    if ((end == NULL) || (*end == NULL) ||\n-        ((*end)->type == XML_NAMESPACE_DECL) || (endindex == NULL))\n-    return(-1);\n-    cur = start;\n-    pos = startindex - 1;\n-    stringlen = xmlStrlen(string);\n-\n-    while (stringlen > 0) {\n-    if ((cur == *end) && (pos + stringlen > *endindex))\n-        return(0);\n-\n-    if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {\n-        len = xmlStrlen(cur->content);\n-        if (len >= pos + stringlen) {\n-        match = (!xmlStrncmp(&cur->content[pos], string, stringlen));\n-        if (match) {\n-            *end = cur;\n-            *endindex = pos + stringlen;\n-            return(1);\n-        } else {\n-            return(0);\n-        }\n-        } else {\n-                int sub = len - pos;\n-        match = (!xmlStrncmp(&cur->content[pos], string, sub));\n-        if (match) {\n-                    string = &string[sub];\n-            stringlen -= sub;\n-        } else {\n-            return(0);\n-        }\n-        }\n-    }\n-    cur = xmlXPtrAdvanceNode(cur, NULL);\n-    if (cur == NULL)\n-        return(0);\n-    pos = 0;\n-    }\n-    return(1);\n-}\n-\n-\/**\n- * xmlXPtrSearchString:\n- * @string:  the string to search\n- * @start:  the start textnode IN\/OUT\n- * @startindex:  the start index IN\/OUT\n- * @end:  the end textnode\n- * @endindex:  the end index\n- *\n- * Search the next occurrence of @string within the document content\n- * until the (@end, @endindex) point is reached\n- *\n- * Returns -1 in case of failure, 0 if not found, 1 if found in which case\n- *            (@start, @startindex) will indicate the position of the beginning\n- *            of the range and (@end, @endindex) will indicate the end\n- *            of the range\n- *\/\n-static int\n-xmlXPtrSearchString(const xmlChar *string, xmlNodePtr *start, int *startindex,\n-                xmlNodePtr *end, int *endindex) {\n-    xmlNodePtr cur;\n-    const xmlChar *str;\n-    int pos; \/* 0 based *\/\n-    int len; \/* in bytes *\/\n-    xmlChar first;\n-\n-    if (string == NULL)\n-    return(-1);\n-    if ((start == NULL) || (*start == NULL) ||\n-        ((*start)->type == XML_NAMESPACE_DECL) || (startindex == NULL))\n-    return(-1);\n-    if ((end == NULL) || (endindex == NULL))\n-    return(-1);\n-    cur = *start;\n-    pos = *startindex - 1;\n-    first = string[0];\n-\n-    while (cur != NULL) {\n-    if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {\n-        len = xmlStrlen(cur->content);\n-        while (pos <= len) {\n-        if (first != 0) {\n-            str = xmlStrchr(&cur->content[pos], first);\n-            if (str != NULL) {\n-            pos = (str - (xmlChar *)(cur->content));\n-            if (xmlXPtrMatchString(string, cur, pos + 1,\n-                           end, endindex)) {\n-                *start = cur;\n-                *startindex = pos + 1;\n-                return(1);\n-            }\n-            pos++;\n-            } else {\n-            pos = len + 1;\n-            }\n-        } else {\n-            \/*\n-             * An empty string is considered to match before each\n-             * character of the string-value and after the final\n-             * character.\n-             *\/\n-            *start = cur;\n-            *startindex = pos + 1;\n-            *end = cur;\n-            *endindex = pos + 1;\n-            return(1);\n-        }\n-        }\n-    }\n-    if ((cur == *end) && (pos >= *endindex))\n-        return(0);\n-    cur = xmlXPtrAdvanceNode(cur, NULL);\n-    if (cur == NULL)\n-        return(0);\n-    pos = 1;\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlXPtrGetLastChar:\n- * @node:  the node\n- * @index:  the index\n- *\n- * Computes the point coordinates of the last char of this point\n- *\n- * Returns -1 in case of failure, 0 otherwise\n- *\/\n-static int\n-xmlXPtrGetLastChar(xmlNodePtr *node, int *indx) {\n-    xmlNodePtr cur;\n-    int pos, len = 0;\n-\n-    if ((node == NULL) || (*node == NULL) ||\n-        ((*node)->type == XML_NAMESPACE_DECL) || (indx == NULL))\n-    return(-1);\n-    cur = *node;\n-    pos = *indx;\n-\n-    if ((cur->type == XML_ELEMENT_NODE) ||\n-    (cur->type == XML_DOCUMENT_NODE) ||\n-    (cur->type == XML_HTML_DOCUMENT_NODE)) {\n-    if (pos > 0) {\n-        cur = xmlXPtrGetNthChild(cur, pos);\n-    }\n-    }\n-    while (cur != NULL) {\n-    if (cur->last != NULL)\n-        cur = cur->last;\n-    else if ((cur->type != XML_ELEMENT_NODE) &&\n-             (cur->content != NULL)) {\n-        len = xmlStrlen(cur->content);\n-        break;\n-    } else {\n-        return(-1);\n-    }\n-    }\n-    if (cur == NULL)\n-    return(-1);\n-    *node = cur;\n-    *indx = len;\n-    return(0);\n-}\n-\n-\/**\n- * xmlXPtrGetStartPoint:\n- * @obj:  an range\n- * @node:  the resulting node\n- * @indx:  the resulting index\n- *\n- * read the object and return the start point coordinates.\n- *\n- * Returns -1 in case of failure, 0 otherwise\n- *\/\n-static int\n-xmlXPtrGetStartPoint(xmlXPathObjectPtr obj, xmlNodePtr *node, int *indx) {\n-    if ((obj == NULL) || (node == NULL) || (indx == NULL))\n-    return(-1);\n-\n-    switch (obj->type) {\n-        case XPATH_POINT:\n-        *node = obj->user;\n-        if (obj->index <= 0)\n-        *indx = 0;\n-        else\n-        *indx = obj->index;\n-        return(0);\n-        case XPATH_RANGE:\n-        *node = obj->user;\n-        if (obj->index <= 0)\n-        *indx = 0;\n-        else\n-        *indx = obj->index;\n-        return(0);\n-    default:\n-        break;\n-    }\n-    return(-1);\n-}\n-\n-\/**\n- * xmlXPtrGetEndPoint:\n- * @obj:  an range\n- * @node:  the resulting node\n- * @indx:  the resulting indx\n- *\n- * read the object and return the end point coordinates.\n- *\n- * Returns -1 in case of failure, 0 otherwise\n- *\/\n-static int\n-xmlXPtrGetEndPoint(xmlXPathObjectPtr obj, xmlNodePtr *node, int *indx) {\n-    if ((obj == NULL) || (node == NULL) || (indx == NULL))\n-    return(-1);\n-\n-    switch (obj->type) {\n-        case XPATH_POINT:\n-        *node = obj->user;\n-        if (obj->index <= 0)\n-        *indx = 0;\n-        else\n-        *indx = obj->index;\n-        return(0);\n-        case XPATH_RANGE:\n-        *node = obj->user;\n-        if (obj->index <= 0)\n-        *indx = 0;\n-        else\n-        *indx = obj->index;\n-        return(0);\n-    default:\n-        break;\n-    }\n-    return(-1);\n-}\n-\n-\/**\n- * xmlXPtrStringRangeFunction:\n- * @ctxt:  the XPointer Parser context\n- * @nargs:  the number of args\n- *\n- * Function implementing the string-range() function\n- * range as described in 5.4.2\n- *\n- * ------------------------------\n- * [Definition: For each location in the location-set argument,\n- * string-range returns a set of string ranges, a set of substrings in a\n- * string. Specifically, the string-value of the location is searched for\n- * substrings that match the string argument, and the resulting location-set\n- * will contain a range location for each non-overlapping match.]\n- * An empty string is considered to match before each character of the\n- * string-value and after the final character. Whitespace in a string\n- * is matched literally, with no normalization except that provided by\n- * XML for line ends. The third argument gives the position of the first\n- * character to be in the resulting range, relative to the start of the\n- * match. The default value is 1, which makes the range start immediately\n- * before the first character of the matched string. The fourth argument\n- * gives the number of characters in the range; the default is that the\n- * range extends to the end of the matched string.\n- *\n- * Element boundaries, as well as entire embedded nodes such as processing\n- * instructions and comments, are ignored as defined in [XPath].\n- *\n- * If the string in the second argument is not found in the string-value\n- * of the location, or if a value in the third or fourth argument indicates\n- * a string that is beyond the beginning or end of the document, the\n- * expression fails.\n- *\n- * The points of the range-locations in the returned location-set will\n- * all be character points.\n- * ------------------------------\n- *\/\n-static void\n-xmlXPtrStringRangeFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n-    int i, startindex, endindex = 0, fendindex;\n-    xmlNodePtr start, end = 0, fend;\n-    xmlXPathObjectPtr set = NULL;\n-    xmlLocationSetPtr oldset;\n-    xmlLocationSetPtr newset = NULL;\n-    xmlXPathObjectPtr string = NULL;\n-    xmlXPathObjectPtr position = NULL;\n-    xmlXPathObjectPtr number = NULL;\n-    int found, pos = 0, num = 0;\n-\n-    \/*\n-     * Grab the arguments\n-     *\/\n-    if ((nargs < 2) || (nargs > 4))\n-    XP_ERROR(XPATH_INVALID_ARITY);\n-\n-    if (nargs >= 4) {\n-        if ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NUMBER)) {\n-            xmlXPathErr(ctxt, XPATH_INVALID_TYPE);\n-            goto error;\n-        }\n-    number = valuePop(ctxt);\n-    if (number != NULL)\n-        num = (int) number->floatval;\n-    }\n-    if (nargs >= 3) {\n-        if ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NUMBER)) {\n-            xmlXPathErr(ctxt, XPATH_INVALID_TYPE);\n-            goto error;\n-        }\n-    position = valuePop(ctxt);\n-    if (position != NULL)\n-        pos = (int) position->floatval;\n-    }\n-    if ((ctxt->value == NULL) || (ctxt->value->type != XPATH_STRING)) {\n-        xmlXPathErr(ctxt, XPATH_INVALID_TYPE);\n-        goto error;\n-    }\n-    string = valuePop(ctxt);\n-    if ((ctxt->value == NULL) ||\n-    ((ctxt->value->type != XPATH_LOCATIONSET) &&\n-     (ctxt->value->type != XPATH_NODESET))) {\n-        xmlXPathErr(ctxt, XPATH_INVALID_TYPE);\n-        goto error;\n-    }\n-    set = valuePop(ctxt);\n-    newset = xmlXPtrLocationSetCreate(NULL);\n-    if (newset == NULL) {\n-        xmlXPathErr(ctxt, XPATH_MEMORY_ERROR);\n-        goto error;\n-    }\n-    if (set->nodesetval == NULL) {\n-        goto error;\n-    }\n-    if (set->type == XPATH_NODESET) {\n-    xmlXPathObjectPtr tmp;\n-\n-    \/*\n-     * First convert to a location set\n-     *\/\n-    tmp = xmlXPtrNewLocationSetNodeSet(set->nodesetval);\n-    xmlXPathFreeObject(set);\n-        set = NULL;\n-    if (tmp == NULL) {\n-            xmlXPathErr(ctxt, XPATH_MEMORY_ERROR);\n-            goto error;\n-        }\n-    set = tmp;\n-    }\n-    oldset = (xmlLocationSetPtr) set->user;\n-\n-    \/*\n-     * The loop is to search for each element in the location set\n-     * the list of location set corresponding to that search\n-     *\/\n-    for (i = 0;i < oldset->locNr;i++) {\n-\n-    xmlXPtrGetStartPoint(oldset->locTab[i], &start, &startindex);\n-    xmlXPtrGetEndPoint(oldset->locTab[i], &end, &endindex);\n-    xmlXPtrAdvanceChar(&start, &startindex, 0);\n-    xmlXPtrGetLastChar(&end, &endindex);\n-\n-    do {\n-            fend = end;\n-            fendindex = endindex;\n-        found = xmlXPtrSearchString(string->stringval, &start, &startindex,\n-                                &fend, &fendindex);\n-        if (found == 1) {\n-        if (position == NULL) {\n-            xmlXPtrLocationSetAdd(newset,\n-             xmlXPtrNewRange(start, startindex, fend, fendindex));\n-        } else if (xmlXPtrAdvanceChar(&start, &startindex,\n-                                  pos - 1) == 0) {\n-            if ((number != NULL) && (num > 0)) {\n-            int rindx;\n-            xmlNodePtr rend;\n-            rend = start;\n-            rindx = startindex - 1;\n-            if (xmlXPtrAdvanceChar(&rend, &rindx,\n-                               num) == 0) {\n-                xmlXPtrLocationSetAdd(newset,\n-                    xmlXPtrNewRange(start, startindex,\n-                            rend, rindx));\n-            }\n-            } else if ((number != NULL) && (num <= 0)) {\n-            xmlXPtrLocationSetAdd(newset,\n-                    xmlXPtrNewRange(start, startindex,\n-                            start, startindex));\n-            } else {\n-            xmlXPtrLocationSetAdd(newset,\n-                    xmlXPtrNewRange(start, startindex,\n-                            fend, fendindex));\n-            }\n-        }\n-        start = fend;\n-        startindex = fendindex;\n-        if (string->stringval[0] == 0)\n-            startindex++;\n-        }\n-    } while (found == 1);\n-    }\n-\n-    \/*\n-     * Save the new value and cleanup\n-     *\/\n-error:\n-    if (newset != NULL)\n-        valuePush(ctxt, xmlXPtrWrapLocationSet(newset));\n-    xmlXPathFreeObject(set);\n-    xmlXPathFreeObject(string);\n-    if (position) xmlXPathFreeObject(position);\n-    if (number) xmlXPathFreeObject(number);\n-}\n-\n-\/**\n- * xmlXPtrEvalRangePredicate:\n- * @ctxt:  the XPointer Parser context\n- *\n- *  [8]   Predicate ::=   '[' PredicateExpr ']'\n- *  [9]   PredicateExpr ::=   Expr\n- *\n- * Evaluate a predicate as in xmlXPathEvalPredicate() but for\n- * a Location Set instead of a node set\n- *\/\n-void\n-xmlXPtrEvalRangePredicate(xmlXPathParserContextPtr ctxt) {\n-    const xmlChar *cur;\n-    xmlXPathObjectPtr res;\n-    xmlXPathObjectPtr obj, tmp;\n-    xmlLocationSetPtr newset = NULL;\n-    xmlLocationSetPtr oldset;\n-    int i;\n-\n-    if (ctxt == NULL) return;\n-\n-    SKIP_BLANKS;\n-    if (CUR != '[') {\n-    XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);\n-    }\n-    NEXT;\n-    SKIP_BLANKS;\n-\n-    \/*\n-     * Extract the old set, and then evaluate the result of the\n-     * expression for all the element in the set. use it to grow\n-     * up a new set.\n-     *\/\n-    CHECK_TYPE(XPATH_LOCATIONSET);\n-    obj = valuePop(ctxt);\n-    oldset = obj->user;\n-    ctxt->context->node = NULL;\n-\n-    if ((oldset == NULL) || (oldset->locNr == 0)) {\n-    ctxt->context->contextSize = 0;\n-    ctxt->context->proximityPosition = 0;\n-    xmlXPathEvalExpr(ctxt);\n-    res = valuePop(ctxt);\n-    if (res != NULL)\n-        xmlXPathFreeObject(res);\n-    valuePush(ctxt, obj);\n-    CHECK_ERROR;\n-    } else {\n-    \/*\n-     * Save the expression pointer since we will have to evaluate\n-     * it multiple times. Initialize the new set.\n-     *\/\n-        cur = ctxt->cur;\n-    newset = xmlXPtrLocationSetCreate(NULL);\n-\n-        for (i = 0; i < oldset->locNr; i++) {\n-        ctxt->cur = cur;\n-\n-        \/*\n-         * Run the evaluation with a node list made of a single item\n-         * in the nodeset.\n-         *\/\n-        ctxt->context->node = oldset->locTab[i]->user;\n-        tmp = xmlXPathNewNodeSet(ctxt->context->node);\n-        valuePush(ctxt, tmp);\n-        ctxt->context->contextSize = oldset->locNr;\n-        ctxt->context->proximityPosition = i + 1;\n-\n-        xmlXPathEvalExpr(ctxt);\n-        CHECK_ERROR;\n-\n-        \/*\n-         * The result of the evaluation need to be tested to\n-         * decided whether the filter succeeded or not\n-         *\/\n-        res = valuePop(ctxt);\n-        if (xmlXPathEvaluatePredicateResult(ctxt, res)) {\n-            xmlXPtrLocationSetAdd(newset,\n-            xmlXPathObjectCopy(oldset->locTab[i]));\n-        }\n-\n-        \/*\n-         * Cleanup\n-         *\/\n-        if (res != NULL)\n-        xmlXPathFreeObject(res);\n-        if (ctxt->value == tmp) {\n-        res = valuePop(ctxt);\n-        xmlXPathFreeObject(res);\n-        }\n-\n-        ctxt->context->node = NULL;\n-    }\n-\n-    \/*\n-     * The result is used as the new evaluation set.\n-     *\/\n-    xmlXPathFreeObject(obj);\n-    ctxt->context->node = NULL;\n-    ctxt->context->contextSize = -1;\n-    ctxt->context->proximityPosition = -1;\n-    valuePush(ctxt, xmlXPtrWrapLocationSet(newset));\n-    }\n-    if (CUR != ']') {\n-    XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);\n-    }\n-\n-    NEXT;\n-    SKIP_BLANKS;\n-}\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-\n-#endif\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xpointer.c","additions":0,"deletions":2924,"binary":false,"changes":2924,"status":"deleted"},{"patch":"@@ -1,824 +0,0 @@\n-\/**\n- * xzlib.c: front end for the transparent support of lzma compression\n- *          at the I\/O layer, based on an example file from lzma project\n- *\n- * See Copyright for the status of this software.\n- *\n- * Anders F Bjorklund <afb@users.sourceforge.net>\n- *\/\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-#ifdef LIBXML_LZMA_ENABLED\n-\n-#include <string.h>\n-#include <stdlib.h>\n-#include <errno.h>\n-\n-#ifdef HAVE_SYS_STAT_H\n-#include <sys\/stat.h>\n-#endif\n-#ifdef HAVE_FCNTL_H\n-#include <fcntl.h>\n-#endif\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#elif defined (_WIN32)\n-#include <io.h>\n-#endif\n-#ifdef LIBXML_ZLIB_ENABLED\n-#include <zlib.h>\n-#endif\n-#ifdef LIBXML_LZMA_ENABLED\n-#include <lzma.h>\n-#endif\n-\n-#include \"private\/xzlib.h\"\n-#include <libxml\/xmlmemory.h>\n-\n-\/* values for xz_state how *\/\n-#define LOOK 0                  \/* look for a gzip\/lzma header *\/\n-#define COPY 1                  \/* copy input directly *\/\n-#define GZIP 2                  \/* decompress a gzip stream *\/\n-#define LZMA 3                  \/* decompress a lzma stream *\/\n-\n-\/* internal lzma file state data structure *\/\n-typedef struct {\n-    int mode;                   \/* see lzma modes above *\/\n-    int fd;                     \/* file descriptor *\/\n-    char *path;                 \/* path or fd for error messages *\/\n-    uint64_t pos;               \/* current position in uncompressed data *\/\n-    unsigned int size;          \/* buffer size, zero if not allocated yet *\/\n-    unsigned int want;          \/* requested buffer size, default is BUFSIZ *\/\n-    unsigned char *in;          \/* input buffer *\/\n-    unsigned char *out;         \/* output buffer (double-sized when reading) *\/\n-    unsigned char *next;        \/* next output data to deliver or write *\/\n-    unsigned int have;          \/* amount of output data unused at next *\/\n-    int eof;                    \/* true if end of input file reached *\/\n-    uint64_t start;             \/* where the lzma data started, for rewinding *\/\n-    uint64_t raw;               \/* where the raw data started, for seeking *\/\n-    int how;                    \/* 0: get header, 1: copy, 2: decompress *\/\n-    int direct;                 \/* true if last read direct, false if lzma *\/\n-    \/* seek request *\/\n-    uint64_t skip;              \/* amount to skip (already rewound if backwards) *\/\n-    int seek;                   \/* true if seek request pending *\/\n-    \/* error information *\/\n-    int err;                    \/* error code *\/\n-    char *msg;                  \/* error message *\/\n-    \/* lzma stream *\/\n-    int init;                   \/* is the inflate stream initialized *\/\n-    lzma_stream strm;           \/* stream structure in-place (not a pointer) *\/\n-    char padding1[32];          \/* padding allowing to cope with possible\n-                                   extensions of above structure without\n-                   too much side effect *\/\n-#ifdef LIBXML_ZLIB_ENABLED\n-    \/* zlib inflate or deflate stream *\/\n-    z_stream zstrm;             \/* stream structure in-place (not a pointer) *\/\n-#endif\n-    char padding2[32];          \/* padding allowing to cope with possible\n-                                   extensions of above structure without\n-                   too much side effect *\/\n-} xz_state, *xz_statep;\n-\n-static void\n-xz_error(xz_statep state, int err, const char *msg)\n-{\n-    \/* free previously allocated message and clear *\/\n-    if (state->msg != NULL) {\n-        if (state->err != LZMA_MEM_ERROR)\n-            xmlFree(state->msg);\n-        state->msg = NULL;\n-    }\n-\n-    \/* set error code, and if no message, then done *\/\n-    state->err = err;\n-    if (msg == NULL)\n-        return;\n-\n-    \/* for an out of memory error, save as static string *\/\n-    if (err == LZMA_MEM_ERROR) {\n-        state->msg = (char *) msg;\n-        return;\n-    }\n-\n-    \/* construct error message with path *\/\n-    if ((state->msg =\n-         xmlMalloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {\n-        state->err = LZMA_MEM_ERROR;\n-        state->msg = (char *) \"out of memory\";\n-        return;\n-    }\n-    strcpy(state->msg, state->path);\n-    strcat(state->msg, \": \");\n-    strcat(state->msg, msg);\n-    return;\n-}\n-\n-static void\n-xz_reset(xz_statep state)\n-{\n-    state->have = 0;            \/* no output data available *\/\n-    state->eof = 0;             \/* not at end of file *\/\n-    state->how = LOOK;          \/* look for gzip header *\/\n-    state->direct = 1;          \/* default for empty file *\/\n-    state->seek = 0;            \/* no seek request pending *\/\n-    xz_error(state, LZMA_OK, NULL);     \/* clear error *\/\n-    state->pos = 0;             \/* no uncompressed data yet *\/\n-    state->strm.avail_in = 0;   \/* no input data yet *\/\n-#ifdef LIBXML_ZLIB_ENABLED\n-    state->zstrm.avail_in = 0;  \/* no input data yet *\/\n-#endif\n-}\n-\n-static xzFile\n-xz_open(const char *path, int fd, const char *mode ATTRIBUTE_UNUSED)\n-{\n-    xz_statep state;\n-    off_t offset;\n-\n-    \/* allocate xzFile structure to return *\/\n-    state = xmlMalloc(sizeof(xz_state));\n-    if (state == NULL)\n-        return NULL;\n-    state->size = 0;            \/* no buffers allocated yet *\/\n-    state->want = BUFSIZ;       \/* requested buffer size *\/\n-    state->msg = NULL;          \/* no error message yet *\/\n-    state->init = 0;            \/* initialization of zlib data *\/\n-\n-    \/* save the path name for error messages *\/\n-    state->path = xmlMalloc(strlen(path) + 1);\n-    if (state->path == NULL) {\n-        xmlFree(state);\n-        return NULL;\n-    }\n-    strcpy(state->path, path);\n-\n-    \/* open the file with the appropriate mode (or just use fd) *\/\n-    state->fd = fd != -1 ? fd : open(path,\n-#ifdef O_LARGEFILE\n-                                     O_LARGEFILE |\n-#endif\n-#ifdef O_BINARY\n-                                     O_BINARY |\n-#endif\n-                                     O_RDONLY, 0666);\n-    if (state->fd == -1) {\n-        xmlFree(state->path);\n-        xmlFree(state);\n-        return NULL;\n-    }\n-\n-    \/* save the current position for rewinding (only if reading) *\/\n-    offset = lseek(state->fd, 0, SEEK_CUR);\n-    if (offset == -1)\n-        state->start = 0;\n-    else\n-        state->start = offset;\n-\n-    \/* initialize stream *\/\n-    xz_reset(state);\n-\n-    \/* return stream *\/\n-    return (xzFile) state;\n-}\n-\n-static int\n-xz_compressed(xzFile f) {\n-    xz_statep state;\n-\n-    if (f == NULL)\n-        return(-1);\n-    state = (xz_statep) f;\n-    if (state->init <= 0)\n-        return(-1);\n-\n-    switch (state->how) {\n-        case COPY:\n-        return(0);\n-    case GZIP:\n-#ifdef LIBXML_ZLIB_ENABLED\n-            \/* Don't use lzma for gzip *\/\n-        return(0);\n-#else\n-        return(1);\n-#endif\n-    case LZMA:\n-        return(1);\n-    }\n-    return(-1);\n-}\n-\n-xzFile\n-__libxml2_xzopen(const char *path, const char *mode)\n-{\n-    return xz_open(path, -1, mode);\n-}\n-\n-xzFile\n-__libxml2_xzdopen(const char *path, int fd, const char *mode)\n-{\n-    return xz_open(path, fd, mode);\n-}\n-\n-static int\n-xz_load(xz_statep state, unsigned char *buf, unsigned int len,\n-        unsigned int *have)\n-{\n-    int ret;\n-\n-    *have = 0;\n-    do {\n-        ret = read(state->fd, buf + *have, len - *have);\n-        if (ret <= 0)\n-            break;\n-        *have += ret;\n-    } while (*have < len);\n-    if (ret < 0) {\n-        xz_error(state, -1, strerror(errno));\n-        return -1;\n-    }\n-    if (ret == 0)\n-        state->eof = 1;\n-    return 0;\n-}\n-\n-static int\n-xz_avail(xz_statep state)\n-{\n-    lzma_stream *strm = &(state->strm);\n-\n-    if (state->err != LZMA_OK)\n-        return -1;\n-    if (state->eof == 0) {\n-        \/* avail_in is size_t, which is not necessary sizeof(unsigned) *\/\n-        unsigned tmp = strm->avail_in;\n-\n-        if (xz_load(state, state->in, state->size, &tmp) == -1) {\n-            strm->avail_in = tmp;\n-            return -1;\n-        }\n-        strm->avail_in = tmp;\n-        strm->next_in = state->in;\n-    }\n-    return 0;\n-}\n-\n-#ifdef LIBXML_ZLIB_ENABLED\n-static int\n-xz_avail_zstrm(xz_statep state)\n-{\n-    int ret;\n-    state->strm.avail_in = state->zstrm.avail_in;\n-    state->strm.next_in = state->zstrm.next_in;\n-    ret = xz_avail(state);\n-    state->zstrm.avail_in = (uInt) state->strm.avail_in;\n-    state->zstrm.next_in = (Bytef *) state->strm.next_in;\n-    return ret;\n-}\n-#endif\n-\n-static int\n-is_format_xz(xz_statep state)\n-{\n-    lzma_stream *strm = &(state->strm);\n-\n-    return strm->avail_in >= 6 && memcmp(state->in, \"\\3757zXZ\", 6) == 0;\n-}\n-\n-static int\n-is_format_lzma(xz_statep state)\n-{\n-    lzma_stream *strm = &(state->strm);\n-\n-    lzma_filter filter;\n-    lzma_options_lzma *opt;\n-    uint32_t dict_size;\n-    uint64_t uncompressed_size;\n-    size_t i;\n-\n-    if (strm->avail_in < 13)\n-        return 0;\n-\n-    filter.id = LZMA_FILTER_LZMA1;\n-    if (lzma_properties_decode(&filter, NULL, state->in, 5) != LZMA_OK)\n-        return 0;\n-\n-    opt = filter.options;\n-    dict_size = opt->dict_size;\n-    free(opt); \/* we can't use xmlFree on a string returned by zlib *\/\n-\n-    \/* A hack to ditch tons of false positives: We allow only dictionary\n-     * sizes that are 2^n or 2^n + 2^(n-1) or UINT32_MAX. LZMA_Alone\n-     * created only files with 2^n, but accepts any dictionary size.\n-     * If someone complains, this will be reconsidered.\n-     *\/\n-    if (dict_size != UINT32_MAX) {\n-        uint32_t d;\n-\n-        if (dict_size == 0)\n-            return 0;\n-\n-        d = dict_size - 1;\n-        d |= d >> 2;\n-        d |= d >> 3;\n-        d |= d >> 4;\n-        d |= d >> 8;\n-        d |= d >> 16;\n-        ++d;\n-        if (d != dict_size || dict_size == 0)\n-            return 0;\n-    }\n-\n-    \/* Another hack to ditch false positives: Assume that if the\n-     * uncompressed size is known, it must be less than 256 GiB.\n-     * Again, if someone complains, this will be reconsidered.\n-     *\/\n-    uncompressed_size = 0;\n-    for (i = 0; i < 8; ++i)\n-        uncompressed_size |= (uint64_t) (state->in[5 + i]) << (i * 8);\n-\n-    if (uncompressed_size != UINT64_MAX\n-        && uncompressed_size > (UINT64_C(1) << 38))\n-        return 0;\n-\n-    return 1;\n-}\n-\n-#ifdef LIBXML_ZLIB_ENABLED\n-\n-\/* Get next byte from input, or -1 if end or error. *\/\n-#define NEXT() ((strm->avail_in == 0 && xz_avail(state) == -1) ? -1 : \\\n-                (strm->avail_in == 0 ? -1 : \\\n-                 (strm->avail_in--, *(strm->next_in)++)))\n-\/* Same thing, but from zstrm *\/\n-#define NEXTZ() ((strm->avail_in == 0 && xz_avail_zstrm(state) == -1) ? -1 : \\\n-                (strm->avail_in == 0 ? -1 : \\\n-                 (strm->avail_in--, *(strm->next_in)++)))\n-\n-\/* Get a four-byte little-endian integer and return 0 on success and the value\n-   in *ret.  Otherwise -1 is returned and *ret is not modified. *\/\n-static int\n-gz_next4(xz_statep state, unsigned long *ret)\n-{\n-    int ch;\n-    unsigned long val;\n-    z_streamp strm = &(state->zstrm);\n-\n-    val = NEXTZ();\n-    val += (unsigned) NEXTZ() << 8;\n-    val += (unsigned long) NEXTZ() << 16;\n-    ch = NEXTZ();\n-    if (ch == -1)\n-        return -1;\n-    val += (unsigned long) ch << 24;\n-    *ret = val;\n-    return 0;\n-}\n-#endif\n-\n-static int\n-xz_head(xz_statep state)\n-{\n-    lzma_stream *strm = &(state->strm);\n-    lzma_stream init = LZMA_STREAM_INIT;\n-    int flags;\n-    unsigned len;\n-\n-    \/* Avoid unused variable warning if features are disabled. *\/\n-    (void) flags;\n-    (void) len;\n-\n-    \/* allocate read buffers and inflate memory *\/\n-    if (state->size == 0) {\n-        \/* allocate buffers *\/\n-        state->in = xmlMalloc(state->want);\n-        state->out = xmlMalloc(state->want << 1);\n-        if (state->in == NULL || state->out == NULL) {\n-            if (state->out != NULL)\n-                xmlFree(state->out);\n-            if (state->in != NULL)\n-                xmlFree(state->in);\n-            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n-            return -1;\n-        }\n-        state->size = state->want;\n-\n-        \/* allocate decoder memory *\/\n-        state->strm = init;\n-        state->strm.avail_in = 0;\n-        state->strm.next_in = NULL;\n-        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {\n-            xmlFree(state->out);\n-            xmlFree(state->in);\n-            state->size = 0;\n-            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n-            return -1;\n-        }\n-#ifdef LIBXML_ZLIB_ENABLED\n-        \/* allocate inflate memory *\/\n-        state->zstrm.zalloc = Z_NULL;\n-        state->zstrm.zfree = Z_NULL;\n-        state->zstrm.opaque = Z_NULL;\n-        state->zstrm.avail_in = 0;\n-        state->zstrm.next_in = Z_NULL;\n-        if (state->init == 0) {\n-            if (inflateInit2(&(state->zstrm), -15) != Z_OK) {\/* raw inflate *\/\n-                xmlFree(state->out);\n-                xmlFree(state->in);\n-                state->size = 0;\n-                xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n-                return -1;\n-            }\n-            state->init = 1;\n-        }\n-#endif\n-    }\n-\n-    \/* get some data in the input buffer *\/\n-    if (strm->avail_in == 0) {\n-        if (xz_avail(state) == -1)\n-            return -1;\n-        if (strm->avail_in == 0)\n-            return 0;\n-    }\n-\n-    \/* look for the xz magic header bytes *\/\n-    if (is_format_xz(state) || is_format_lzma(state)) {\n-        state->how = LZMA;\n-        state->direct = 0;\n-        return 0;\n-    }\n-#ifdef LIBXML_ZLIB_ENABLED\n-    \/* look for the gzip magic header bytes 31 and 139 *\/\n-    if (strm->next_in[0] == 31) {\n-        strm->avail_in--;\n-        strm->next_in++;\n-        if (strm->avail_in == 0 && xz_avail(state) == -1)\n-            return -1;\n-        if (strm->avail_in && strm->next_in[0] == 139) {\n-            \/* we have a gzip header, woo hoo! *\/\n-            strm->avail_in--;\n-            strm->next_in++;\n-\n-            \/* skip rest of header *\/\n-            if (NEXT() != 8) {  \/* compression method *\/\n-                xz_error(state, LZMA_DATA_ERROR,\n-                         \"unknown compression method\");\n-                return -1;\n-            }\n-            flags = NEXT();\n-            if (flags & 0xe0) { \/* reserved flag bits *\/\n-                xz_error(state, LZMA_DATA_ERROR,\n-                         \"unknown header flags set\");\n-                return -1;\n-            }\n-            NEXT();             \/* modification time *\/\n-            NEXT();\n-            NEXT();\n-            NEXT();\n-            NEXT();             \/* extra flags *\/\n-            NEXT();             \/* operating system *\/\n-            if (flags & 4) {    \/* extra field *\/\n-                len = (unsigned) NEXT();\n-                len += (unsigned) NEXT() << 8;\n-                while (len--)\n-                    if (NEXT() < 0)\n-                        break;\n-            }\n-            if (flags & 8)      \/* file name *\/\n-                while (NEXT() > 0) ;\n-            if (flags & 16)     \/* comment *\/\n-                while (NEXT() > 0) ;\n-            if (flags & 2) {    \/* header crc *\/\n-                NEXT();\n-                NEXT();\n-            }\n-            \/* an unexpected end of file is not checked for here -- it will be\n-             * noticed on the first request for uncompressed data *\/\n-\n-            \/* set up for decompression *\/\n-            inflateReset(&state->zstrm);\n-            state->zstrm.adler = crc32(0L, Z_NULL, 0);\n-            state->how = GZIP;\n-            state->direct = 0;\n-            return 0;\n-        } else {\n-            \/* not a gzip file -- save first byte (31) and fall to raw i\/o *\/\n-            state->out[0] = 31;\n-            state->have = 1;\n-        }\n-    }\n-#endif\n-\n-    \/* doing raw i\/o, save start of raw data for seeking, copy any leftover\n-     * input to output -- this assumes that the output buffer is larger than\n-     * the input buffer, which also assures space for gzungetc() *\/\n-    state->raw = state->pos;\n-    state->next = state->out;\n-    if (strm->avail_in) {\n-        memcpy(state->next + state->have, strm->next_in, strm->avail_in);\n-        state->have += strm->avail_in;\n-        strm->avail_in = 0;\n-    }\n-    state->how = COPY;\n-    state->direct = 1;\n-    return 0;\n-}\n-\n-static int\n-xz_decomp(xz_statep state)\n-{\n-    int ret;\n-    unsigned had;\n-    unsigned long crc, len;\n-    lzma_stream *strm = &(state->strm);\n-\n-    lzma_action action = LZMA_RUN;\n-\n-    \/* Avoid unused variable warning if features are disabled. *\/\n-    (void) crc;\n-    (void) len;\n-\n-    \/* fill output buffer up to end of deflate stream *\/\n-    had = strm->avail_out;\n-    do {\n-        \/* get more input for inflate() *\/\n-        if (strm->avail_in == 0 && xz_avail(state) == -1)\n-            return -1;\n-        if (strm->avail_in == 0) {\n-            xz_error(state, LZMA_DATA_ERROR, \"unexpected end of file\");\n-            return -1;\n-        }\n-        if (state->eof)\n-            action = LZMA_FINISH;\n-\n-        \/* decompress and handle errors *\/\n-#ifdef LIBXML_ZLIB_ENABLED\n-        if (state->how == GZIP) {\n-            state->zstrm.avail_in = (uInt) state->strm.avail_in;\n-            state->zstrm.next_in = (Bytef *) state->strm.next_in;\n-            state->zstrm.avail_out = (uInt) state->strm.avail_out;\n-            state->zstrm.next_out = (Bytef *) state->strm.next_out;\n-            ret = inflate(&state->zstrm, Z_NO_FLUSH);\n-            if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {\n-                xz_error(state, Z_STREAM_ERROR,\n-                         \"internal error: inflate stream corrupt\");\n-                return -1;\n-            }\n-            \/*\n-             * FIXME: Remapping a couple of error codes and falling through\n-             * to the LZMA error handling looks fragile.\n-             *\/\n-            if (ret == Z_MEM_ERROR)\n-                ret = LZMA_MEM_ERROR;\n-            if (ret == Z_DATA_ERROR)\n-                ret = LZMA_DATA_ERROR;\n-            if (ret == Z_STREAM_END)\n-                ret = LZMA_STREAM_END;\n-            state->strm.avail_in = state->zstrm.avail_in;\n-            state->strm.next_in = state->zstrm.next_in;\n-            state->strm.avail_out = state->zstrm.avail_out;\n-            state->strm.next_out = state->zstrm.next_out;\n-        } else                  \/* state->how == LZMA *\/\n-#endif\n-            ret = lzma_code(strm, action);\n-        if (ret == LZMA_MEM_ERROR) {\n-            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n-            return -1;\n-        }\n-        if (ret == LZMA_DATA_ERROR) {\n-            xz_error(state, LZMA_DATA_ERROR, \"compressed data error\");\n-            return -1;\n-        }\n-        if (ret == LZMA_PROG_ERROR) {\n-            xz_error(state, LZMA_PROG_ERROR, \"compression error\");\n-            return -1;\n-        }\n-        if ((state->how != GZIP) &&\n-            (ret != LZMA_OK) && (ret != LZMA_STREAM_END)) {\n-            xz_error(state, ret, \"lzma error\");\n-            return -1;\n-        }\n-    } while (strm->avail_out && ret != LZMA_STREAM_END);\n-\n-    \/* update available output and crc check value *\/\n-    state->have = had - strm->avail_out;\n-    state->next = strm->next_out - state->have;\n-#ifdef LIBXML_ZLIB_ENABLED\n-    state->zstrm.adler =\n-        crc32(state->zstrm.adler, state->next, state->have);\n-#endif\n-\n-    if (ret == LZMA_STREAM_END) {\n-#ifdef LIBXML_ZLIB_ENABLED\n-        if (state->how == GZIP) {\n-            if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {\n-                xz_error(state, LZMA_DATA_ERROR, \"unexpected end of file\");\n-                return -1;\n-            }\n-            if (crc != state->zstrm.adler) {\n-                xz_error(state, LZMA_DATA_ERROR, \"incorrect data check\");\n-                return -1;\n-            }\n-            if (len != (state->zstrm.total_out & 0xffffffffL)) {\n-                xz_error(state, LZMA_DATA_ERROR, \"incorrect length check\");\n-                return -1;\n-            }\n-            state->strm.avail_in = 0;\n-            state->strm.next_in = NULL;\n-            state->strm.avail_out = 0;\n-            state->strm.next_out = NULL;\n-        } else\n-#endif\n-        if (strm->avail_in != 0 || !state->eof) {\n-            xz_error(state, LZMA_DATA_ERROR, \"trailing garbage\");\n-            return -1;\n-        }\n-        state->how = LOOK;      \/* ready for next stream, once have is 0 (leave\n-                                 * state->direct unchanged to remember how) *\/\n-    }\n-\n-    \/* good decompression *\/\n-    return 0;\n-}\n-\n-static int\n-xz_make(xz_statep state)\n-{\n-    lzma_stream *strm = &(state->strm);\n-\n-    if (state->how == LOOK) {   \/* look for lzma \/ gzip header *\/\n-        if (xz_head(state) == -1)\n-            return -1;\n-        if (state->have)        \/* got some data from xz_head() *\/\n-            return 0;\n-    }\n-    if (state->how == COPY) {   \/* straight copy *\/\n-        if (xz_load(state, state->out, state->size << 1, &(state->have)) ==\n-            -1)\n-            return -1;\n-        state->next = state->out;\n-    } else if (state->how == LZMA || state->how == GZIP) {      \/* decompress *\/\n-        strm->avail_out = state->size << 1;\n-        strm->next_out = state->out;\n-        if (xz_decomp(state) == -1)\n-            return -1;\n-    }\n-    return 0;\n-}\n-\n-static int\n-xz_skip(xz_statep state, uint64_t len)\n-{\n-    unsigned n;\n-\n-    \/* skip over len bytes or reach end-of-file, whichever comes first *\/\n-    while (len)\n-        \/* skip over whatever is in output buffer *\/\n-        if (state->have) {\n-            n = (uint64_t) state->have > len ?\n-                (unsigned) len : state->have;\n-            state->have -= n;\n-            state->next += n;\n-            state->pos += n;\n-            len -= n;\n-        }\n-\n-    \/* output buffer empty -- return if we're at the end of the input *\/\n-        else if (state->eof && state->strm.avail_in == 0)\n-            break;\n-\n-    \/* need more data to skip -- load up output buffer *\/\n-        else {\n-            \/* get more output, looking for header if required *\/\n-            if (xz_make(state) == -1)\n-                return -1;\n-        }\n-    return 0;\n-}\n-\n-int\n-__libxml2_xzcompressed(xzFile f) {\n-    xz_head(f);\n-\n-    return xz_compressed(f);\n-}\n-\n-int\n-__libxml2_xzread(xzFile file, void *buf, unsigned len)\n-{\n-    unsigned got, n;\n-    xz_statep state;\n-    lzma_stream *strm;\n-\n-    \/* get internal structure *\/\n-    if (file == NULL)\n-        return -1;\n-    state = (xz_statep) file;\n-    strm = &(state->strm);\n-\n-    \/* check that we're reading and that there's no error *\/\n-    if (state->err != LZMA_OK)\n-        return -1;\n-\n-    \/* since an int is returned, make sure len fits in one, otherwise return\n-     * with an error (this avoids the flaw in the interface) *\/\n-    if ((int) len < 0) {\n-        xz_error(state, LZMA_BUF_ERROR,\n-                 \"requested length does not fit in int\");\n-        return -1;\n-    }\n-\n-    \/* if len is zero, avoid unnecessary operations *\/\n-    if (len == 0)\n-        return 0;\n-\n-    \/* process a skip request *\/\n-    if (state->seek) {\n-        state->seek = 0;\n-        if (xz_skip(state, state->skip) == -1)\n-            return -1;\n-    }\n-\n-    \/* get len bytes to buf, or less than len if at the end *\/\n-    got = 0;\n-    do {\n-        \/* first just try copying data from the output buffer *\/\n-        if (state->have) {\n-            n = state->have > len ? len : state->have;\n-            memcpy(buf, state->next, n);\n-            state->next += n;\n-            state->have -= n;\n-        }\n-\n-        \/* output buffer empty -- return if we're at the end of the input *\/\n-        else if (state->eof && strm->avail_in == 0)\n-            break;\n-\n-        \/* need output data -- for small len or new stream load up our output\n-         * buffer *\/\n-        else if (state->how == LOOK || len < (state->size << 1)) {\n-            \/* get more output, looking for header if required *\/\n-            if (xz_make(state) == -1)\n-                return -1;\n-            continue;           \/* no progress yet -- go back to memcpy() above *\/\n-            \/* the copy above assures that we will leave with space in the\n-             * output buffer, allowing at least one gzungetc() to succeed *\/\n-        }\n-\n-        \/* large len -- read directly into user buffer *\/\n-        else if (state->how == COPY) {  \/* read directly *\/\n-            if (xz_load(state, buf, len, &n) == -1)\n-                return -1;\n-        }\n-\n-        \/* large len -- decompress directly into user buffer *\/\n-        else {                  \/* state->how == LZMA *\/\n-            strm->avail_out = len;\n-            strm->next_out = buf;\n-            if (xz_decomp(state) == -1)\n-                return -1;\n-            n = state->have;\n-            state->have = 0;\n-        }\n-\n-        \/* update progress *\/\n-        len -= n;\n-        buf = (char *) buf + n;\n-        got += n;\n-        state->pos += n;\n-    } while (len);\n-\n-    \/* return number of bytes read into user buffer (will fit in int) *\/\n-    return (int) got;\n-}\n-\n-int\n-__libxml2_xzclose(xzFile file)\n-{\n-    int ret;\n-    xz_statep state;\n-\n-    \/* get internal structure *\/\n-    if (file == NULL)\n-        return LZMA_DATA_ERROR;\n-    state = (xz_statep) file;\n-\n-    \/* free memory and close file *\/\n-    if (state->size) {\n-        lzma_end(&(state->strm));\n-#ifdef LIBXML_ZLIB_ENABLED\n-        if (state->init == 1)\n-            inflateEnd(&(state->zstrm));\n-        state->init = 0;\n-#endif\n-        xmlFree(state->out);\n-        xmlFree(state->in);\n-    }\n-    xmlFree(state->path);\n-    if ((state->msg != NULL) && (state->err != LZMA_MEM_ERROR))\n-        xmlFree(state->msg);\n-    ret = close(state->fd);\n-    xmlFree(state);\n-    return ret ? ret : LZMA_OK;\n-}\n-#endif \/* LIBXML_LZMA_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xzlib.c","additions":0,"deletions":824,"binary":false,"changes":824,"status":"deleted"},{"patch":"@@ -1,598 +0,0 @@\n-cmake_minimum_required(VERSION 3.18)\n-\n-file(STRINGS \"configure.ac\" CONFIGURE_AC_LINES)\n-foreach(line ${CONFIGURE_AC_LINES})\n-\tif(line MATCHES [[^m4_define\\(\\[(MAJOR|MINOR|MICRO)_VERSION\\],[ \\t]*\\[([0-9]+)\\]\\)$]])\n-\t\tset(LIBXSLT_${CMAKE_MATCH_1}_VERSION ${CMAKE_MATCH_2})\n-        elseif(line MATCHES \"^LIBEXSLT_(MAJOR|MINOR|MICRO)_VERSION=([0-9]+)$\")\n-\t\tset(LIBEXSLT_${CMAKE_MATCH_1}_VERSION ${CMAKE_MATCH_2})\n-\tendif()\n-endforeach()\n-\n-set(LIBXSLT_DOTTED_VERSION \"${LIBXSLT_MAJOR_VERSION}.${LIBXSLT_MINOR_VERSION}.${LIBXSLT_MICRO_VERSION}\")\n-math(EXPR LIBXSLT_VERSION_NUMBER \"${LIBXSLT_MAJOR_VERSION} * 10000 + ${LIBXSLT_MINOR_VERSION} * 100 + ${LIBXSLT_MICRO_VERSION}\")\n-set(LIBXSLT_VERSION_EXTRA \"\")\n-\n-set(LIBEXSLT_DOTTED_VERSION ${LIBEXSLT_MAJOR_VERSION}.${LIBEXSLT_MINOR_VERSION}.${LIBEXSLT_MICRO_VERSION})\n-math(EXPR LIBEXSLT_VERSION_NUMBER \"${LIBEXSLT_MAJOR_VERSION} * 10000 + ${LIBEXSLT_MINOR_VERSION} * 100 + ${LIBEXSLT_MICRO_VERSION}\")\n-set(LIBEXSLT_VERSION_EXTRA \"\")\n-\n-set(VERSION ${LIBXSLT_DOTTED_VERSION})\n-set(LIBEXSLT_VERSION ${LIBEXSLT_DOTTED_VERSION})\n-\n-project(libxslt1 VERSION ${VERSION} LANGUAGES C)\n-\n-list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR})\n-\n-include(CheckCSourceCompiles)\n-include(CheckFunctionExists)\n-include(CheckIncludeFiles)\n-include(CheckLibraryExists)\n-include(CheckLinkerFlag)\n-include(CheckSymbolExists)\n-include(CMakePackageConfigHelpers)\n-include(GNUInstallDirs)\n-\n-if(NOT TARGET LibXml2)\n-\tfind_package(LibXml2 CONFIG REQUIRED)\n-endif()\n-\n-option(BUILD_SHARED_LIBS \"Build shared libraries\" ON)\n-option(LIBXSLT_WITH_DEBUGGER \"Add the debugging support\" OFF)\n-option(LIBXSLT_WITH_CRYPTO \"Add crypto support to exslt\" OFF)\n-option(LIBXSLT_WITH_MODULES \"Add plugin extension support\" OFF)\n-option(LIBXSLT_WITH_PROFILER \"Add the profiling support\" ON)\n-option(LIBXSLT_WITH_PROGRAMS \"Build programs\" ON)\n-option(LIBXSLT_WITH_PYTHON \"Build Python bindings\" ON)\n-option(LIBXSLT_WITH_TESTS \"Build tests\" ON)\n-option(LIBXSLT_WITH_THREADS \"Add multithread support\" ON)\n-set(LIBXSLT_WITH_TRIO OFF)\n-option(LIBXSLT_WITH_XSLT_DEBUG \"Add the debugging code\" OFF)\n-\n-if(NOT BUILD_SHARED_LIBS)\n-\tset(LIBXSLT_WITH_MODULES OFF)\n-endif()\n-\n-if(LIBXSLT_WITH_CRYPTO AND NOT WIN32)\n-\tfind_package(Gcrypt REQUIRED)\n-        set(HAVE_GCRYPT 1)\n-endif()\n-\n-if(LIBXSLT_WITH_PYTHON)\n-\tcheck_include_files(unistd.h HAVE_UNISTD_H)\n-\tcheck_symbol_exists(F_GETFL fcntl.h HAVE_F_GETFL)\n-\tif(WIN32 OR (HAVE_UNISTD_H AND HAVE_F_GETFL))\n-\t\tfind_package(Python COMPONENTS Interpreter Development REQUIRED)\n-\telse()\n-\t\tfind_package(Python2 COMPONENTS Interpreter Development REQUIRED)\n-\t\tadd_library(Python::Python ALIAS Python2::Python)\n-\t\tset(Python_EXECUTABLE ${Python2_EXECUTABLE})\n-\t\tset(Python_SITEARCH ${Python2_SITEARCH})\n-\tendif()\n-\t#set(LIBXSLT_PYTHON_INSTALL_DIR ${Python_SITEARCH} CACHE PATH \"Python bindings install directory\")\n-\tset(LIBXSLT_PYTHON_INSTALL_DIR \"${CMAKE_INSTALL_PREFIX}\/python\" CACHE PATH \"Python bindings install directory\")\n-endif()\n-\n-if(LIBXSLT_WITH_THREADS)\n-\tfind_package(Threads REQUIRED)\n-endif()\n-\n-foreach(VARIABLE IN ITEMS WITH_CRYPTO WITH_DEBUGGER WITH_MODULES WITH_PROFILER WITH_PYTHON WITH_TRIO WITH_XSLT_DEBUG)\n-\tif(LIBXSLT_${VARIABLE})\n-\t\tset(${VARIABLE} 1)\n-\telse()\n-\t\tset(${VARIABLE} 0)\n-\tendif()\n-endforeach()\n-\n-if(LIBXSLT_WITH_MODULES)\n-    set(MODULE_EXTENSION \"${CMAKE_SHARED_LIBRARY_SUFFIX}\")\n-endif()\n-\n-if(LIBXSLT_WITH_CRYPTO AND NOT WIN32)\n-\tlist(APPEND CMAKE_REQUIRED_LIBRARIES Gcrypt::Gcrypt)\n-endif()\n-\n-if(LIBXSLT_WITH_THREADS)\n-\tlist(APPEND CMAKE_REQUIRED_LIBRARIES Threads::Threads)\n-endif()\n-\n-if(MSVC)\n-\tconfigure_file(libxslt\/win32config.h config.h COPYONLY)\n-\tconfigure_file(libxslt\/win32config.h win32config.h COPYONLY)\n-else()\n-\tif(UNIX)\n-\t\tset(CMAKE_REQUIRED_LIBRARIES m)\n-\tendif()\n-\tcheck_function_exists(clock_gettime HAVE_CLOCK_GETTIME)\n-\tcheck_function_exists(ftime HAVE_FTIME)\n-\tcheck_function_exists(gettimeofday HAVE_GETTIMEOFDAY)\n-\tcheck_function_exists(gmtime_r HAVE_GMTIME_R)\n-\tcheck_include_files(inttypes.h HAVE_INTTYPES_H)\n-\tcheck_library_exists(pthread pthread_join \"\" HAVE_LIBPTHREAD)\n-\tcheck_include_files(locale.h HAVE_LOCALE_H)\n-\tcheck_function_exists(localtime_r HAVE_LOCALTIME_R)\n-\tcheck_include_files(pthread.h HAVE_PTHREAD_H)\n-\tcheck_function_exists(snprintf HAVE_SNPRINTF)\n-\tcheck_function_exists(stat HAVE_STAT)\n-\tcheck_function_exists(strxfrm_l HAVE_STRXFRM_L)\n-\tcheck_include_files(sys\/select.h HAVE_SYS_SELECT_H)\n-\tcheck_include_files(sys\/stat.h HAVE_SYS_STAT_H)\n-\tcheck_include_files(sys\/timeb.h HAVE_SYS_TIMEB_H)\n-\tcheck_include_files(sys\/time.h HAVE_SYS_TIME_H)\n-\tcheck_include_files(sys\/types.h HAVE_SYS_TYPES_H)\n-\tcheck_include_files(unistd.h HAVE_UNISTD_H)\n-\tcheck_function_exists(vsnprintf HAVE_VSNPRINTF)\n-\tcheck_include_files(xlocale.h HAVE_XLOCALE_H)\n-\tcheck_function_exists(_stat HAVE__STAT)\n-\tset(LT_OBJDIR \".libs\/\")\n-\tset(PACKAGE \"libxslt\")\n-\tset(PACKAGE_BUGREPORT \"xml@gnome.org\")\n-\tset(PACKAGE_NAME \"libxslt\")\n-\tset(PACKAGE_STRING \"libxslt ${LIBXSLT_DOTTED_VERSION}\")\n-\tset(PACKAGE_TARNAME \"libxslt\")\n-\tset(PACKAGE_URL \"https:\/\/gitlab.gnome.org\/GNOME\/libxslt\")\n-\tset(PACKAGE_VERSION ${LIBXSLT_DOTTED_VERSION})\n-\tset(_ALL_SOURCE ON)\n-\tset(_GNU_SOURCE ON)\n-\tset(_POSIX_PTHREAD_SEMANTICS ON)\n-\tset(_TANDEM_SOURCE ON)\n-\tcheck_c_source_compiles(\"\n-\t\t#define __EXTENSIONS__ 1\n-\t\tint main() { return 0; }\n-\t\" __EXTENSIONS__)\n-\tcheck_include_files(minix\/config.h HAVE_MINIX_CONFIG_H)\n-\tif(HAVE_MINIX_CONFIG_H)\n-\t\tset(_MINIX ON)\n-\t\tset(_POSIX_1_SOURCE ON)\n-\t\tset(_POSIX_SOURCE ON)\n-\tendif()\n-\tconfigure_file(config.h.cmake.in config.h)\n-endif()\n-\n-configure_file(libexslt\/exsltconfig.h.in libexslt\/exsltconfig.h)\n-configure_file(libxslt\/xsltconfig.h.in libxslt\/xsltconfig.h)\n-\n-set(\n-\tLIBXSLT_HDRS\n-\tlibxslt\/attributes.h\n-\tlibxslt\/documents.h\n-\tlibxslt\/extensions.h\n-\tlibxslt\/extra.h\n-\tlibxslt\/functions.h\n-\tlibxslt\/imports.h\n-\tlibxslt\/keys.h\n-\tlibxslt\/namespaces.h\n-\tlibxslt\/numbersInternals.h\n-\tlibxslt\/pattern.h\n-\tlibxslt\/preproc.h\n-\tlibxslt\/security.h\n-\tlibxslt\/templates.h\n-\tlibxslt\/transform.h\n-\tlibxslt\/variables.h\n-\tlibxslt\/xslt.h\n-\t${CMAKE_CURRENT_BINARY_DIR}\/libxslt\/xsltconfig.h\n-\tlibxslt\/xsltexports.h\n-\tlibxslt\/xsltInternals.h\n-\tlibxslt\/xsltlocale.h\n-\tlibxslt\/xsltutils.h\n-)\n-\n-set(\n-\tLIBXSLT_SRCS\n-\tlibxslt\/attributes.c\n-\tlibxslt\/attrvt.c\n-\tlibxslt\/documents.c\n-\tlibxslt\/extensions.c\n-\tlibxslt\/extra.c\n-\tlibxslt\/functions.c\n-\tlibxslt\/imports.c\n-\tlibxslt\/keys.c\n-\tlibxslt\/namespaces.c\n-\tlibxslt\/numbers.c\n-\tlibxslt\/pattern.c\n-\tlibxslt\/preproc.c\n-\tlibxslt\/security.c\n-\tlibxslt\/templates.c\n-\tlibxslt\/transform.c\n-\tlibxslt\/variables.c\n-\tlibxslt\/xslt.c\n-\tlibxslt\/xsltlocale.c\n-\tlibxslt\/xsltutils.c\n-)\n-\n-add_library(LibXslt ${LIBXSLT_HDRS} ${LIBXSLT_SRCS})\n-add_library(LibXslt::LibXslt ALIAS LibXslt)\n-\n-if(NOT BUILD_SHARED_LIBS)\n-\ttarget_compile_definitions(LibXslt INTERFACE LIBXSLT_STATIC)\n-endif()\n-\n-if(CMAKE_C_COMPILER_ID MATCHES \"Clang\" OR CMAKE_C_COMPILER_ID STREQUAL \"GNU\")\n-\tset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wall -Wextra -Wshadow \\\n--Wpointer-arith -Wcast-align -Wwrite-strings -Waggregate-return \\\n--Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Winline \\\n--Wredundant-decls -Wno-long-long -Wno-format-extra-args\")\n-\n-\tif(BUILD_SHARED_LIBS AND UNIX AND NOT APPLE)\n-\t\tcheck_linker_flag(C \"LINKER:--undefined-version\" FLAG_UNDEFINED_VERSION)\n-\t\tif (FLAG_UNDEFINED_VERSION)\n-\t\t\ttarget_link_options(LibXslt PRIVATE \"LINKER:--undefined-version\")\n-\t\tendif()\n-\t\ttarget_link_options(LibXslt PRIVATE \"LINKER:--version-script=${CMAKE_CURRENT_SOURCE_DIR}\/libxslt\/libxslt.syms\")\n-\tendif()\n-endif()\n-\n-target_include_directories(\n-\tLibXslt\n-\tPUBLIC\n-\t$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>\n-\t$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n-\t$<INSTALL_INTERFACE:$<INSTALL_PREFIX>\/${CMAKE_INSTALL_INCLUDEDIR}>\n-)\n-\n-target_link_libraries(LibXslt PUBLIC LibXml2::LibXml2)\n-\n-if(LIBXSLT_WITH_MODULES)\n-\ttarget_link_libraries(LibXslt PRIVATE ${CMAKE_DL_LIBS})\n-\tset(MODULE_LIBS ${CMAKE_DL_LIBS})\n-endif()\n-\n-if(UNIX)\n-\ttarget_link_libraries(LibXslt PRIVATE m)\n-\tset(LIBM \"-lm\")\n-endif()\n-\n-set_target_properties(\n-\tLibXslt\n-\tPROPERTIES\n-\tIMPORT_PREFIX lib\n-\tOUTPUT_NAME xslt\n-\tPOSITION_INDEPENDENT_CODE ON\n-\tPREFIX lib\n-\tVERSION ${PROJECT_VERSION}\n-\tSOVERSION ${LIBXSLT_MAJOR_VERSION}\n-)\n-\n-if(MSVC)\n-\tif(BUILD_SHARED_LIBS)\n-\t\tset_target_properties(\n-\t\t\tLibXslt\n-\t\t\tPROPERTIES\n-\t\t\tDEBUG_POSTFIX d\n-\t\t)\n-\telse()\n-\t\tset_target_properties(\n-\t\t\tLibXslt\n-\t\t\tPROPERTIES\n-\t\t\tDEBUG_POSTFIX sd\n-\t\t\tMINSIZEREL_POSTFIX s\n-\t\t\tRELEASE_POSTFIX s\n-\t\t\tRELWITHDEBINFO_POSTFIX s\n-\t\t)\n-\tendif()\n-endif()\n-\n-install(FILES ${LIBXSLT_HDRS} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\/libxslt COMPONENT development)\n-\n-install(\n-\tTARGETS\tLibXslt\n-\tEXPORT LibXslt\n-\tARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT development\n-\tLIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT runtime NAMELINK_COMPONENT development\n-\tRUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT runtime\n-)\n-\n-if(MSVC AND BUILD_SHARED_LIBS)\n-\tinstall(FILES $<TARGET_PDB_FILE:LibXslt> DESTINATION ${CMAKE_INSTALL_BINDIR} CONFIGURATIONS Debug RelWithDebInfo COMPONENT debug)\n-endif()\n-\n-set(\n-\tLIBEXSLT_HDRS\n-\tlibexslt\/exslt.h\n-\t${CMAKE_CURRENT_BINARY_DIR}\/libexslt\/exsltconfig.h\n-\tlibexslt\/exsltexports.h\n-)\n-\n-set(\n-\tLIBEXSLT_SRCS\n-\tlibexslt\/common.c\n-\tlibexslt\/crypto.c\n-\tlibexslt\/date.c\n-\tlibexslt\/dynamic.c\n-\tlibexslt\/exslt.c\n-\tlibexslt\/functions.c\n-\tlibexslt\/libexslt.h\n-\tlibexslt\/math.c\n-\tlibexslt\/saxon.c\n-\tlibexslt\/sets.c\n-\tlibexslt\/strings.c\n-)\n-\n-add_library(LibExslt ${LIBEXSLT_HDRS} ${LIBEXSLT_SRCS})\n-add_library(LibXslt::LibExslt ALIAS LibExslt)\n-\n-if(NOT BUILD_SHARED_LIBS)\n-\ttarget_compile_definitions(LibExslt INTERFACE LIBEXSLT_STATIC)\n-endif()\n-\n-target_include_directories(\n-\tLibExslt\n-\tPUBLIC\n-\t$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>\n-\t$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n-\t$<INSTALL_INTERFACE:$<INSTALL_PREFIX>\/${CMAKE_INSTALL_INCLUDEDIR}>\n-)\n-\n-if(LIBXSLT_WITH_CRYPTO AND NOT WIN32)\n-\ttarget_link_libraries(LibExslt PRIVATE Gcrypt::Gcrypt)\n-\tset(LIBGCRYPT_LIBS \"-lgcrypt\")\n-endif()\n-\n-if(UNIX)\n-\ttarget_link_libraries(LibExslt PRIVATE m)\n-\tset(LIBM \"-lm\")\n-endif()\n-\n-target_link_libraries(LibExslt PUBLIC LibXslt LibXml2::LibXml2)\n-\n-set_target_properties(\n-\tLibExslt\n-\tPROPERTIES\n-\tIMPORT_PREFIX lib\n-\tOUTPUT_NAME exslt\n-\tPOSITION_INDEPENDENT_CODE ON\n-\tPREFIX lib\n-\tVERSION ${LIBEXSLT_VERSION}\n-\tSOVERSION ${LIBEXSLT_MAJOR_VERSION}\n-)\n-\n-if(MSVC)\n-\tif(BUILD_SHARED_LIBS)\n-\t\tset_target_properties(\n-\t\t\tLibExslt\n-\t\t\tPROPERTIES\n-\t\t\tDEBUG_POSTFIX d\n-\t\t)\n-\telse()\n-\t\tset_target_properties(\n-\t\t\tLibExslt\n-\t\t\tPROPERTIES\n-\t\t\tDEBUG_POSTFIX sd\n-\t\t\tMINSIZEREL_POSTFIX s\n-\t\t\tRELEASE_POSTFIX s\n-\t\t\tRELWITHDEBINFO_POSTFIX s\n-\t\t)\n-\tendif()\n-endif()\n-\n-install(FILES ${LIBEXSLT_HDRS} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\/libexslt COMPONENT development)\n-\n-install(\n-\tTARGETS\tLibExslt\n-\tEXPORT LibXslt\n-\tARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT development\n-\tLIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT runtime NAMELINK_COMPONENT development\n-\tRUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT runtime\n-)\n-\n-if(MSVC AND BUILD_SHARED_LIBS)\n-\tinstall(FILES $<TARGET_PDB_FILE:LibExslt> DESTINATION ${CMAKE_INSTALL_BINDIR} CONFIGURATIONS Debug RelWithDebInfo COMPONENT debug)\n-endif()\n-\n-if(LIBXSLT_WITH_PROGRAMS)\n-\tadd_executable(xsltproc xsltproc\/xsltproc.c)\n-\tadd_executable(LibXslt::xsltproc ALIAS xsltproc)\n-\ttarget_include_directories(xsltproc PRIVATE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>)\n-\ttarget_link_libraries(xsltproc LibExslt LibXslt)\n-\tinstall(TARGETS xsltproc EXPORT LibXslt RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT programs)\n-endif ()\n-\n-if(LIBXSLT_WITH_TESTS)\n-\tenable_testing()\n-\n-\tadd_executable(runtest tests\/runtest.c)\n-\ttarget_link_libraries(runtest LibXslt LibExslt)\n-\tadd_test(\n-\t\tNAME runtest COMMAND runtest\n-\t\tWORKING_DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}\/tests\"\n-\t)\n-\n-\tif (LIBXSLT_WITH_MODULES)\n-\t\tadd_library(testplugin SHARED tests\/testplugin.c)\n-\t\ttarget_link_libraries(testplugin LibExslt LibXslt LibXml2::LibXml2)\n-\t\tset_target_properties(\n-\t\t\ttestplugin PROPERTIES\n-\t\t\tPREFIX \"\"\n-\t\t\tOUTPUT_NAME xmlsoft_org_xslt_testplugin\n-\t\t)\n-\t\t# There must be an easier way...\n-\t\tget_cmake_property(MULTI_CONFIG GENERATOR_IS_MULTI_CONFIG)\n-\t\tif (MULTI_CONFIG)\n-\t\t\tset(PLUGINS_PATH ${PROJECT_BINARY_DIR}\/$<CONFIG>)\n-\t\telse()\n-\t\t\tset(PLUGINS_PATH ${PROJECT_BINARY_DIR})\n-\t\tendif()\n-\t\tset_tests_properties(\n-\t\t\truntest PROPERTIES\n-\t\t\tENVIRONMENT LIBXSLT_PLUGINS_PATH=${PLUGINS_PATH}\n-\t\t)\n-\tendif()\n-\n-\tif(Threads_FOUND)\n-\t\tadd_executable(testThreads xsltproc\/testThreads.c)\n-\t\ttarget_link_libraries(testThreads LibXslt LibExslt Threads::Threads)\n-\t\tadd_test(NAME testThreads COMMAND testThreads)\n-\tendif()\n-endif()\n-\n-if(LIBXSLT_WITH_PYTHON)\n-\tset(ENV{SRCDIR} ${CMAKE_CURRENT_SOURCE_DIR}\/python)\n-\texecute_process(\n-\t\tCOMMAND\n-\t\t${Python_EXECUTABLE}\n-\t\t${CMAKE_CURRENT_SOURCE_DIR}\/python\/generator.py\n-\t\t${CMAKE_CURRENT_SOURCE_DIR}\/doc\/libxslt-api.xml\n-\t\t${CMAKE_CURRENT_SOURCE_DIR}\/python\/libxslt-python-api.xml\n-\t\tWORKING_DIRECTORY\n-\t\t${CMAKE_CURRENT_BINARY_DIR}\n-\t)\n-\tunset(ENV{SRCDIR})\n-\tfile(READ python\/libxsl.py LIBXSL_PY)\n-\tfile(WRITE ${CMAKE_CURRENT_BINARY_DIR}\/libxslt.py.in \"${LIBXSL_PY}\")\n-\tfile(READ ${CMAKE_CURRENT_BINARY_DIR}\/libxsltclass.py LIBXSLTCLASS_PY)\n-\tfile(APPEND ${CMAKE_CURRENT_BINARY_DIR}\/libxslt.py.in \"${LIBXSLTCLASS_PY}\")\n-\tconfigure_file(${CMAKE_CURRENT_BINARY_DIR}\/libxslt.py.in libxslt.py COPYONLY)\n-\tadd_library(\n-\t\tLibXsltMod SHARED\n-\t\tlibxslt-py.c\n-\t\tlibxslt-py.h\n-\t\tpython\/libxml_wrap.h\n-\t\tpython\/libxslt.c\n-\t\tpython\/libxslt_wrap.h\n-\t\tpython\/types.c\n-\t)\n-\ttarget_include_directories(\n-\t\tLibXsltMod\n-\t\tPUBLIC\n-\t\t$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}\/python>\n-\t)\n-\ttarget_link_libraries(LibXsltMod LibXslt LibExslt Python::Python)\n-\tset_target_properties(\n-\t\tLibXsltMod\n-\t\tPROPERTIES\n-\t\tIMPORT_PREFIX lib\n-\t\tOUTPUT_NAME xsltmod\n-\t\tPREFIX lib\n-\t\tVERSION ${PROJECT_VERSION}\n-\t)\n-\tif (WIN32)\n-\t\tset_target_properties(LibXsltMod PROPERTIES SUFFIX \".pyd\")\n-\tendif()\n-\tinstall(\n-\t\tTARGETS\tLibXsltMod\n-\t\tARCHIVE DESTINATION ${LIBXSLT_PYTHON_INSTALL_DIR} COMPONENT development\n-\t\tLIBRARY DESTINATION ${LIBXSLT_PYTHON_INSTALL_DIR} COMPONENT runtime NAMELINK_COMPONENT development\n-\t\tRUNTIME DESTINATION ${LIBXSLT_PYTHON_INSTALL_DIR} COMPONENT runtime\n-\t)\n-\tif(MSVC AND BUILD_SHARED_LIBS)\n-\t\tinstall(FILES $<TARGET_PDB_FILE:LibXsltMod> DESTINATION ${LIBXSLT_PYTHON_INSTALL_DIR} CONFIGURATIONS Debug RelWithDebInfo COMPONENT debug)\n-\tendif()\n-\tinstall(FILES ${CMAKE_CURRENT_BINARY_DIR}\/libxslt.py DESTINATION ${LIBXSLT_PYTHON_INSTALL_DIR} COMPONENT runtime)\n-endif()\n-\n-install(FILES libexslt\/libexslt.3 DESTINATION ${CMAKE_INSTALL_MANDIR}\/man3 COMPONENT documentation)\n-install(FILES libxslt\/libxslt.3 DESTINATION ${CMAKE_INSTALL_MANDIR}\/man3 COMPONENT documentation)\n-if(LIBXSLT_WITH_PROGRAMS)\n-\tinstall(FILES doc\/xsltproc.1 DESTINATION ${CMAKE_INSTALL_MANDIR}\/man1 COMPONENT documentation)\n-endif()\n-install(DIRECTORY doc\/ DESTINATION ${CMAKE_INSTALL_DATADIR}\/doc\/libxslt COMPONENT documentation PATTERN Makefile.* EXCLUDE)\n-\n-if(LIBXSLT_WITH_CRYPTO AND NOT WIN32)\n-\tinstall(FILES FindGcrypt.cmake DESTINATION ${CMAKE_INSTALL_LIBDIR}\/cmake\/libxslt-${PROJECT_VERSION} COMPONENT development)\n-endif()\n-\n-configure_package_config_file(\n-\tlibxslt-config.cmake.cmake.in libxslt-config.cmake\n-\tINSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}\/cmake\/libxslt-${PROJECT_VERSION}\n-)\n-\n-install(\n-\tFILES ${CMAKE_CURRENT_BINARY_DIR}\/libxslt-config.cmake\n-\tDESTINATION ${CMAKE_INSTALL_LIBDIR}\/cmake\/libxslt-${PROJECT_VERSION}\n-\tCOMPONENT development\n-)\n-\n-write_basic_package_version_file(\n-\t${CMAKE_CURRENT_BINARY_DIR}\/libxslt-config-version.cmake\n-\tVERSION ${PROJECT_VERSION}\n-        COMPATIBILITY SameMajorVersion\n-)\n-\n-install(\n-\tFILES ${CMAKE_CURRENT_BINARY_DIR}\/libxslt-config-version.cmake\n-\tDESTINATION ${CMAKE_INSTALL_LIBDIR}\/cmake\/libxslt-${PROJECT_VERSION}\n-\tCOMPONENT development\n-)\n-\n-install(\n-\tEXPORT LibXslt\n-\tDESTINATION ${CMAKE_INSTALL_LIBDIR}\/cmake\/libxslt-${PROJECT_VERSION}\n-\tNAMESPACE LibXslt::\n-\tFILE libxslt-export.cmake\n-\tCOMPONENT development\n-)\n-\n-set(LIBXSLT_DEFAULT_PLUGINS_PATH \"\\${libdir}\/libxslt-plugins\")\n-set(XSLT_INCLUDEDIR \"-I\\${includedir}\")\n-set(XSLT_LIBDIR \"-L\\${libdir}\")\n-set(XSLT_LIBS \"-lxslt -lxml2\")\n-set(XSLT_PRIVATE_LIBS \"${MODULE_LIBS} ${LIBM}\")\n-\n-set(EXSLT_INCLUDEDIR \"-I\\${includedir}\")\n-set(EXSLT_LIBDIR \"-L\\${libdir}\")\n-set(EXSLT_PRIVATE_LIBS \"${XSLT_PRIVATE_LIBS} ${LIBGCRYPT_LIBS} ${LIBM}\")\n-\n-file(RELATIVE_PATH PACKAGE_RELATIVE_PATH \"${CMAKE_INSTALL_FULL_LIBDIR}\/pkgconfig\" \"${CMAKE_INSTALL_PREFIX}\")\n-string(REGEX REPLACE \"\/$\" \"\" PACKAGE_RELATIVE_PATH \"${PACKAGE_RELATIVE_PATH}\")\n-\n-if(WIN32)\n-    set(prefix \"\\${pcfiledir}\/${PACKAGE_RELATIVE_PATH}\")\n-else()\n-    set(prefix \"${CMAKE_INSTALL_PREFIX}\")\n-endif()\n-set(exec_prefix \"\\${prefix}\")\n-set(libdir \"\\${prefix}\/${CMAKE_INSTALL_LIBDIR}\")\n-set(includedir \"\\${prefix}\/${CMAKE_INSTALL_INCLUDEDIR}\")\n-configure_file(libxslt.pc.in libxslt.pc @ONLY)\n-install(FILES ${CMAKE_CURRENT_BINARY_DIR}\/libxslt.pc DESTINATION ${CMAKE_INSTALL_LIBDIR}\/pkgconfig COMPONENT development)\n-configure_file(libexslt.pc.in libexslt.pc @ONLY)\n-install(FILES ${CMAKE_CURRENT_BINARY_DIR}\/libexslt.pc DESTINATION ${CMAKE_INSTALL_LIBDIR}\/pkgconfig COMPONENT development)\n-\n-set(prefix \"\\$(cd \\\"\\$(dirname \\\"\\$0\\\")\\\"; pwd -P)\/..\")\n-configure_file(xslt-config.in xslt-config @ONLY)\n-install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}\/xslt-config DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT development)\n-\n-set(XSLT_INCLUDEDIR \"-I${CMAKE_INSTALL_FULL_INCLUDEDIR}\")\n-set(XSLT_LIBDIR \"-L${CMAKE_INSTALL_FULL_LIBDIR}\")\n-configure_file(xsltConf.sh.in xsltConf.sh @ONLY)\n-install(FILES ${CMAKE_CURRENT_BINARY_DIR}\/xsltConf.sh DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT development)\n-\n-set(CPACK_COMPONENT_DEVELOPMENT_DEPENDS runtime)\n-set(CPACK_COMPONENT_PROGRAMS_DEPENDS runtime)\n-set(CPACK_DEB_COMPONENT_INSTALL ON)\n-set(CPACK_DEBIAN_DEVELOPMENT_PACKAGE_DEPENDS \"${PACKAGE_TARNAME}\")\n-set(CPACK_DEBIAN_DEVELOPMENT_PACKAGE_NAME \"${PACKAGE_TARNAME}${LIBXSLT_MAJOR_VERSION}-dev\")\n-set(CPACK_DEBIAN_DEVELOPMENT_PACKAGE_SECTION \"libdevel\")\n-set(CPACK_DEBIAN_PACKAGE_HOMEPAGE ${PACKAGE_URL})\n-set(CPACK_DEBIAN_PACKAGE_NAME ${PACKAGE_TARNAME})\n-set(CPACK_DEBIAN_PACKAGE_SECTION \"devel\")\n-set(CPACK_DEBIAN_PROGRAMS_PACKAGE_DEPENDS \"${PACKAGE_TARNAME}\")\n-set(CPACK_DEBIAN_PROGRAMS_PACKAGE_NAME \"${PACKAGE_TARNAME}-utils\")\n-set(CPACK_DEBIAN_PROGRAMS_PACKAGE_SECTION \"utils\")\n-set(CPACK_DEBIAN_RUNTIME_PACKAGE_NAME ${PACKAGE_TARNAME})\n-set(CPACK_DEBIAN_RUNTIME_PACKAGE_RECOMMENDS \"${PACKAGE_TARNAME}-utils\")\n-set(CPACK_DEBIAN_RUNTIME_PACKAGE_SECTION \"libs\")\n-set(CPACK_NSIS_PACKAGE_NAME ${PACKAGE_STRING})\n-set(CPACK_NSIS_URL_INFO_ABOUT ${PACKAGE_URL})\n-set(CPACK_PACKAGE_CONTACT ${PACKAGE_BUGREPORT})\n-set(CPACK_PACKAGE_DISPLAY_NAME ${PACKAGE_STRING})\n-set(CPACK_PACKAGE_INSTALL_DIRECTORY \"${PACKAGE_TARNAME}-${PACKAGE_VERSION}\")\n-set(CPACK_PACKAGE_NAME ${PACKAGE_TARNAME})\n-set(CPACK_PACKAGE_VERSION ${PACKAGE_VERSION})\n-set(CPACK_PACKAGE_VERSION_MAJOR ${LIBXSLT_MAJOR_VERSION})\n-set(CPACK_PACKAGE_VERSION_MINOR ${LIBXSLT_MINOR_VERSION})\n-set(CPACK_PACKAGE_VERSION_PATCH ${LIBXSLT_MICRO_VERSION})\n-set(CPACK_RESOURCE_FILE_LICENSE ${CMAKE_CURRENT_SOURCE_DIR}\/Copyright)\n-set(CPACK_RPM_COMPONENT_INSTALL ON)\n-set(CPACK_RPM_development_PACKAGE_NAME \"${PACKAGE_NAME}-devel\")\n-set(CPACK_RPM_development_PACKAGE_REQUIRES \"${PACKAGE_NAME}\")\n-set(CPACK_RPM_PACKAGE_GROUP \"Development\/Libraries\")\n-set(CPACK_RPM_PACKAGE_NAME ${PACKAGE_TARNAME})\n-set(CPACK_RPM_PACKAGE_URL ${PACKAGE_URL})\n-set(CPACK_RPM_programs_PACKAGE_NAME \"${PACKAGE_NAME}-utils\")\n-set(CPACK_RPM_programs_PACKAGE_REQUIRES \"${PACKAGE_NAME}\")\n-set(CPACK_RPM_runtime_PACKAGE_NAME \"${PACKAGE_NAME}\")\n-set(CPACK_RPM_runtime_PACKAGE_SUGGESTS \"${PACKAGE_NAME}-utils\")\n-\n-include(CPack)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/CMakeLists.txt","additions":0,"deletions":598,"binary":false,"changes":598,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-ACLOCAL_AMFLAGS = -I m4\n-\n-SUBDIRS = libxslt libexslt xsltproc doc tests\n-if WITH_PYTHON\n-SUBDIRS += python\n-endif\n-\n-DIST_SUBDIRS = libxslt libexslt xsltproc python doc tests\n-\n-confexecdir=$(libdir)\n-confexec_DATA = xsltConf.sh\n-\n-bin_SCRIPTS = xslt-config\n-\n-dist-hook: cleanup\n-\ttouch $(distdir)\/doc\/*.xml\n-\ttouch $(distdir)\/doc\/EXSLT\/*.xml\n-\ttouch $(distdir)\/libxslt\/*.syms\n-\t(cd $(srcdir) ; tar -cf - win32 vms examples) | (cd $(distdir); tar xf -)\n-\n-EXTRA_DIST = xsltConf.sh.in \\\n-             FEATURES TODO Copyright \\\n-\t     CMakeLists.txt config.h.cmake.in libxslt-config.cmake.in libxslt-config.cmake.cmake.in\n-\n-## We create xsltConf.sh here and not from configure because we want\n-## to get the paths expanded correctly.  Macros like srcdir are given\n-## the value NONE in configure if the user doesn't specify them (this\n-## is an autoconf feature, not a bug).\n-\n-xsltConf.sh: xsltConf.sh.in Makefile\n-## Use sed and then mv to avoid problems if the user interrupts.\n-\tsed -e 's?\\@XSLT_LIBDIR\\@?$(XSLT_LIBDIR)?g' \\\n-\t    -e 's?\\@XSLT_INCLUDEDIR\\@?$(XSLT_INCLUDEDIR)?g' \\\n-\t    -e 's?\\@VERSION\\@?$(VERSION)?g' \\\n-\t    -e 's?\\@XSLT_LIBS\\@?$(XSLT_LIBS) $(EXTRA_LIBS)?g' \\\n-\t    -e 's?\\@XSLT_PRIVATE_LIBS\\@?$(XSLT_PRIVATE_LIBS)?g' \\\n-\t       < $(srcdir)\/xsltConf.sh.in > xsltConf.tmp \\\n-\t&& mv xsltConf.tmp xsltConf.sh\n-\n-CLEANFILES = xsltConf.sh\n-\n-cleanup:\n-\t-@(find . -name .\\#\\* -exec rm {} \\;)\n-\n-pkgconfigdir=$(libdir)\/pkgconfig\n-pkgconfig_DATA = libxslt.pc libexslt.pc\n-\n-cmakedir = $(libdir)\/cmake\/libxslt\n-dist_cmake_DATA = FindGcrypt.cmake\n-cmake_DATA = libxslt-config.cmake\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/Makefile.am","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,224 +0,0 @@\n-\/* config.h.in.  Generated from configure.ac by autoheader.  *\/\n-\n-\/* Define to 1 if you have the 'clock_gettime' function. *\/\n-#undef HAVE_CLOCK_GETTIME\n-\n-\/* Define to 1 if you have the <dlfcn.h> header file. *\/\n-#undef HAVE_DLFCN_H\n-\n-\/* Define to 1 if you have the 'ftime' function. *\/\n-#undef HAVE_FTIME\n-\n-\/* Define if gcrypt library is available. *\/\n-#undef HAVE_GCRYPT\n-\n-\/* Define to 1 if you have the 'gettimeofday' function. *\/\n-#undef HAVE_GETTIMEOFDAY\n-\n-\/* Define to 1 if you have the 'gmtime_r' function. *\/\n-#undef HAVE_GMTIME_R\n-\n-\/* Define to 1 if you have the <inttypes.h> header file. *\/\n-#undef HAVE_INTTYPES_H\n-\n-\/* Define if pthread library is there (-lpthread) *\/\n-#undef HAVE_LIBPTHREAD\n-\n-\/* Define to 1 if you have the <locale.h> header file. *\/\n-#undef HAVE_LOCALE_H\n-\n-\/* Define to 1 if you have the 'localtime_r' function. *\/\n-#undef HAVE_LOCALTIME_R\n-\n-\/* Define to 1 if you have the <minix\/config.h> header file. *\/\n-#undef HAVE_MINIX_CONFIG_H\n-\n-\/* Define if <pthread.h> is there *\/\n-#undef HAVE_PTHREAD_H\n-\n-\/* Define to 1 if you have the 'snprintf' function. *\/\n-#undef HAVE_SNPRINTF\n-\n-\/* Define to 1 if you have the 'stat' function. *\/\n-#undef HAVE_STAT\n-\n-\/* Define to 1 if you have the <stdint.h> header file. *\/\n-#undef HAVE_STDINT_H\n-\n-\/* Define to 1 if you have the <stdio.h> header file. *\/\n-#undef HAVE_STDIO_H\n-\n-\/* Define to 1 if you have the <stdlib.h> header file. *\/\n-#undef HAVE_STDLIB_H\n-\n-\/* Define to 1 if you have the <strings.h> header file. *\/\n-#undef HAVE_STRINGS_H\n-\n-\/* Define to 1 if you have the <string.h> header file. *\/\n-#undef HAVE_STRING_H\n-\n-\/* Define to 1 if you have the 'strxfrm_l' function. *\/\n-#undef HAVE_STRXFRM_L\n-\n-\/* Define to 1 if you have the <sys\/select.h> header file. *\/\n-#undef HAVE_SYS_SELECT_H\n-\n-\/* Define to 1 if you have the <sys\/stat.h> header file. *\/\n-#undef HAVE_SYS_STAT_H\n-\n-\/* Define to 1 if you have the <sys\/timeb.h> header file. *\/\n-#undef HAVE_SYS_TIMEB_H\n-\n-\/* Define to 1 if you have the <sys\/time.h> header file. *\/\n-#undef HAVE_SYS_TIME_H\n-\n-\/* Define to 1 if you have the <sys\/types.h> header file. *\/\n-#undef HAVE_SYS_TYPES_H\n-\n-\/* Define to 1 if you have the <unistd.h> header file. *\/\n-#undef HAVE_UNISTD_H\n-\n-\/* Define to 1 if you have the 'vsnprintf' function. *\/\n-#undef HAVE_VSNPRINTF\n-\n-\/* Define to 1 if you have the <wchar.h> header file. *\/\n-#undef HAVE_WCHAR_H\n-\n-\/* Define to 1 if you have the <xlocale.h> header file. *\/\n-#undef HAVE_XLOCALE_H\n-\n-\/* Define to 1 if you have the '_stat' function. *\/\n-#undef HAVE__STAT\n-\n-\/* Define to the sub-directory where libtool stores uninstalled libraries. *\/\n-#undef LT_OBJDIR\n-\n-\/* plugin file extension *\/\n-#undef MODULE_EXTENSION\n-\n-\/* Name of package *\/\n-#undef PACKAGE\n-\n-\/* Define to the address where bug reports for this package should be sent. *\/\n-#undef PACKAGE_BUGREPORT\n-\n-\/* Define to the full name of this package. *\/\n-#undef PACKAGE_NAME\n-\n-\/* Define to the full name and version of this package. *\/\n-#undef PACKAGE_STRING\n-\n-\/* Define to the one symbol short name of this package. *\/\n-#undef PACKAGE_TARNAME\n-\n-\/* Define to the home page for this package. *\/\n-#undef PACKAGE_URL\n-\n-\/* Define to the version of this package. *\/\n-#undef PACKAGE_VERSION\n-\n-\/* Define to 1 if all of the C89 standard headers exist (not just the ones\n-   required in a freestanding environment). This macro is provided for\n-   backward compatibility; new code need not use it. *\/\n-#undef STDC_HEADERS\n-\n-\/* Enable extensions on AIX, Interix, z\/OS.  *\/\n-#ifndef _ALL_SOURCE\n-# undef _ALL_SOURCE\n-#endif\n-\/* Enable general extensions on macOS.  *\/\n-#ifndef _DARWIN_C_SOURCE\n-# undef _DARWIN_C_SOURCE\n-#endif\n-\/* Enable general extensions on Solaris.  *\/\n-#ifndef __EXTENSIONS__\n-# undef __EXTENSIONS__\n-#endif\n-\/* Enable GNU extensions on systems that have them.  *\/\n-#ifndef _GNU_SOURCE\n-# undef _GNU_SOURCE\n-#endif\n-\/* Enable X\/Open compliant socket functions that do not require linking\n-   with -lxnet on HP-UX 11.11.  *\/\n-#ifndef _HPUX_ALT_XOPEN_SOCKET_API\n-# undef _HPUX_ALT_XOPEN_SOCKET_API\n-#endif\n-\/* Identify the host operating system as Minix.\n-   This macro does not affect the system headers' behavior.\n-   A future release of Autoconf may stop defining this macro.  *\/\n-#ifndef _MINIX\n-# undef _MINIX\n-#endif\n-\/* Enable general extensions on NetBSD.\n-   Enable NetBSD compatibility extensions on Minix.  *\/\n-#ifndef _NETBSD_SOURCE\n-# undef _NETBSD_SOURCE\n-#endif\n-\/* Enable OpenBSD compatibility extensions on NetBSD.\n-   Oddly enough, this does nothing on OpenBSD.  *\/\n-#ifndef _OPENBSD_SOURCE\n-# undef _OPENBSD_SOURCE\n-#endif\n-\/* Define to 1 if needed for POSIX-compatible behavior.  *\/\n-#ifndef _POSIX_SOURCE\n-# undef _POSIX_SOURCE\n-#endif\n-\/* Define to 2 if needed for POSIX-compatible behavior.  *\/\n-#ifndef _POSIX_1_SOURCE\n-# undef _POSIX_1_SOURCE\n-#endif\n-\/* Enable POSIX-compatible threading on Solaris.  *\/\n-#ifndef _POSIX_PTHREAD_SEMANTICS\n-# undef _POSIX_PTHREAD_SEMANTICS\n-#endif\n-\/* Enable extensions specified by ISO\/IEC TS 18661-5:2014.  *\/\n-#ifndef __STDC_WANT_IEC_60559_ATTRIBS_EXT__\n-# undef __STDC_WANT_IEC_60559_ATTRIBS_EXT__\n-#endif\n-\/* Enable extensions specified by ISO\/IEC TS 18661-1:2014.  *\/\n-#ifndef __STDC_WANT_IEC_60559_BFP_EXT__\n-# undef __STDC_WANT_IEC_60559_BFP_EXT__\n-#endif\n-\/* Enable extensions specified by ISO\/IEC TS 18661-2:2015.  *\/\n-#ifndef __STDC_WANT_IEC_60559_DFP_EXT__\n-# undef __STDC_WANT_IEC_60559_DFP_EXT__\n-#endif\n-\/* Enable extensions specified by C23 Annex F.  *\/\n-#ifndef __STDC_WANT_IEC_60559_EXT__\n-# undef __STDC_WANT_IEC_60559_EXT__\n-#endif\n-\/* Enable extensions specified by ISO\/IEC TS 18661-4:2015.  *\/\n-#ifndef __STDC_WANT_IEC_60559_FUNCS_EXT__\n-# undef __STDC_WANT_IEC_60559_FUNCS_EXT__\n-#endif\n-\/* Enable extensions specified by C23 Annex H and ISO\/IEC TS 18661-3:2015.  *\/\n-#ifndef __STDC_WANT_IEC_60559_TYPES_EXT__\n-# undef __STDC_WANT_IEC_60559_TYPES_EXT__\n-#endif\n-\/* Enable extensions specified by ISO\/IEC TR 24731-2:2010.  *\/\n-#ifndef __STDC_WANT_LIB_EXT2__\n-# undef __STDC_WANT_LIB_EXT2__\n-#endif\n-\/* Enable extensions specified by ISO\/IEC 24747:2009.  *\/\n-#ifndef __STDC_WANT_MATH_SPEC_FUNCS__\n-# undef __STDC_WANT_MATH_SPEC_FUNCS__\n-#endif\n-\/* Enable extensions on HP NonStop.  *\/\n-#ifndef _TANDEM_SOURCE\n-# undef _TANDEM_SOURCE\n-#endif\n-\/* Enable X\/Open extensions.  Define to 500 only if necessary\n-   to make mbstate_t available.  *\/\n-#ifndef _XOPEN_SOURCE\n-# undef _XOPEN_SOURCE\n-#endif\n-\n-\n-\/* Version number of package *\/\n-#undef VERSION\n-\n-\/* Define if debugging support is enabled *\/\n-#undef WITH_DEBUGGER\n-\n-\/* Define if profiling support is enabled *\/\n-#undef WITH_PROFILER\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/config.h.in","additions":0,"deletions":224,"binary":false,"changes":224,"status":"deleted"},{"patch":"@@ -1,587 +0,0 @@\n-dnl Process this file with autoconf to produce a configuration script.\n-AC_PREREQ(2.63)\n-\n-m4_define([MAJOR_VERSION], [1])\n-m4_define([MINOR_VERSION], [1])\n-m4_define([MICRO_VERSION], [44])\n-\n-AC_INIT([libxslt], [MAJOR_VERSION.MINOR_VERSION.MICRO_VERSION])\n-AC_CONFIG_SRCDIR([libxslt\/xslt.c])\n-AC_CONFIG_HEADERS(config.h)\n-AC_CONFIG_MACRO_DIR([m4])\n-AC_CANONICAL_HOST\n-AC_USE_SYSTEM_EXTENSIONS\n-\n-dnl\n-dnl libxslt is the main part of the package\n-dnl libexslt is an extension\n-dnl\n-LIBXSLT_MAJOR_VERSION=MAJOR_VERSION\n-LIBXSLT_MINOR_VERSION=MINOR_VERSION\n-LIBXSLT_MICRO_VERSION=MICRO_VERSION\n-LIBEXSLT_MAJOR_VERSION=0\n-LIBEXSLT_MINOR_VERSION=8\n-LIBEXSLT_MICRO_VERSION=25\n-LIBXML_REQUIRED_VERSION=2.6.27\n-\n-\n-LIBXSLT_VERSION=$LIBXSLT_MAJOR_VERSION.$LIBXSLT_MINOR_VERSION.$LIBXSLT_MICRO_VERSION\n-LIBXSLT_VERSION_INFO=`expr $LIBXSLT_MAJOR_VERSION + $LIBXSLT_MINOR_VERSION`:$LIBXSLT_MICRO_VERSION:$LIBXSLT_MINOR_VERSION\n-\n-LIBXSLT_VERSION_NUMBER=`expr $LIBXSLT_MAJOR_VERSION \\* 10000 + $LIBXSLT_MINOR_VERSION \\* 100 + $LIBXSLT_MICRO_VERSION`\n-LIBXSLT_MAJOR_MINOR_VERSION=$LIBXSLT_MAJOR_VERSION.$LIBXSLT_MINOR_VERSION\n-\n-if test -d .git ; then\n-  extra=`git describe | sed 's+LIBXSLT[[0-9.]]*-++'`\n-  echo extra=$extra\n-  if test \"$extra\" != \"\"\n-  then\n-      LIBXSLT_VERSION_EXTRA=\"-GIT$extra\"\n-      LIBEXSLT_VERSION_EXTRA=\"-GIT$extra\"\n-  fi\n-fi\n-\n-AC_SUBST(LIBXSLT_MAJOR_VERSION)\n-AC_SUBST(LIBXSLT_MINOR_VERSION)\n-AC_SUBST(LIBXSLT_MICRO_VERSION)\n-AC_SUBST(LIBXSLT_VERSION)\n-AC_SUBST(LIBXSLT_VERSION_INFO)\n-AC_SUBST(LIBXSLT_VERSION_NUMBER)\n-AC_SUBST(LIBXSLT_VERSION_EXTRA)\n-AC_SUBST(LIBXSLT_MAJOR_MINOR_VERSION)\n-\n-dnl\n-dnl libexslt is an extension library\n-dnl\n-\n-LIBEXSLT_VERSION=$LIBEXSLT_MAJOR_VERSION.$LIBEXSLT_MINOR_VERSION.$LIBEXSLT_MICRO_VERSION\n-LIBEXSLT_VERSION_INFO=`expr $LIBEXSLT_MAJOR_VERSION + $LIBEXSLT_MINOR_VERSION`:$LIBEXSLT_MICRO_VERSION:$LIBEXSLT_MINOR_VERSION\n-\n-LIBEXSLT_VERSION_NUMBER=`expr $LIBEXSLT_MAJOR_VERSION \\* 10000 + $LIBEXSLT_MINOR_VERSION \\* 100 + $LIBEXSLT_MICRO_VERSION`\n-\n-AC_SUBST(LIBEXSLT_MAJOR_VERSION)\n-AC_SUBST(LIBEXSLT_MINOR_VERSION)\n-AC_SUBST(LIBEXSLT_MICRO_VERSION)\n-AC_SUBST(LIBEXSLT_VERSION)\n-AC_SUBST(LIBEXSLT_VERSION_INFO)\n-AC_SUBST(LIBEXSLT_VERSION_NUMBER)\n-AC_SUBST(LIBEXSLT_VERSION_EXTRA)\n-\n-AM_INIT_AUTOMAKE([1.16.3 foreign no-dist-gzip dist-xz])\n-AM_MAINTAINER_MODE([enable])\n-AM_SILENT_RULES([yes])\n-\n-dnl\n-dnl Check the environment\n-dnl\n-\n-AC_PROG_CC\n-AC_PROG_INSTALL\n-AC_PROG_CPP\n-AC_PATH_PROG(XMLLINT, xmllint, \/usr\/bin\/xmllint)\n-AC_PATH_PROG(XSLTPROC, xsltproc, \/usr\/bin\/xsltproc)\n-PKG_PROG_PKG_CONFIG\n-\n-LT_INIT([disable-static win32-dll])\n-LT_LIB_M\n-\n-\n-AC_CHECK_HEADERS(sys\/types.h sys\/time.h unistd.h)\n-\n-dnl\n-dnl if the system support linker version scripts for symbol versioning\n-dnl then add it\n-dnl\n-AC_MSG_CHECKING([how to pass version script to the linker ($LD)])\n-VERSION_SCRIPT_FLAGS=none\n-if $LD --help 2>&1 | grep \"version-script\" >\/dev\/null 2>\/dev\/null; then\n-    dnl lld 16 defaults to --no-undefined-version but the version script\n-    dnl can contain symbols disabled by configuration options.\n-    VERSION_SCRIPT_FLAGS=''\n-    AX_APPEND_LINK_FLAGS([-Wl,--undefined-version], [VERSION_SCRIPT_FLAGS])\n-    AX_APPEND_FLAG([-Wl,--version-script=], [VERSION_SCRIPT_FLAGS])\n-elif $LD --help 2>&1 | grep \"M mapfile\" >\/dev\/null 2>\/dev\/null; then\n-    VERSION_SCRIPT_FLAGS=\"-Wl,-M -Wl,\"\n-fi\n-AC_MSG_RESULT([$VERSION_SCRIPT_FLAGS])\n-AC_SUBST(VERSION_SCRIPT_FLAGS)\n-AM_CONDITIONAL([USE_VERSION_SCRIPT], [test \"$VERSION_SCRIPT_FLAGS\" != none])\n-\n-dnl Look for pthread.h, needed for testThreads\n-case $host in\n-  *-mingw*) ;;\n-  *)\n-WITH_THREADS=0\n-THREAD_LIBS=\"\"\n-AC_CHECK_HEADER(pthread.h,\n-    AC_CHECK_LIB(pthread, pthread_join,[\n-       AC_DEFINE([HAVE_LIBPTHREAD], [], [Define if pthread library is there (-lpthread)])\n-       AC_DEFINE([HAVE_PTHREAD_H], [], [Define if <pthread.h> is there])\n-       WITH_THREADS=\"1\"\n-       THREAD_LIBS=\"-lpthread\"]))\n-  ;;\n-esac\n-\n-AC_SUBST(WITH_THREADS)\n-AC_SUBST(THREAD_LIBS)\n-\n-dnl\n-dnl Detect supported locale\n-dnl\n-\n-AC_CHECK_HEADERS([locale.h xlocale.h])\n-AC_CHECK_FUNCS([strxfrm_l])\n-\n-dnl\n-dnl Math detection\n-dnl\n-\n-AC_CHECK_HEADERS(sys\/timeb.h sys\/stat.h sys\/select.h)\n-AC_CHECK_FUNCS(stat _stat)\n-\n-AC_CHECK_FUNCS(gettimeofday)\n-AC_CHECK_FUNCS(localtime_r gmtime_r ftime)\n-\n-dnl Checking the standard string functions availability\n-AC_CHECK_FUNCS(snprintf vsnprintf,,\n-               NEED_TRIO=1)\n-\n-dnl Checking for POSIX timers\n-AC_CHECK_FUNCS(clock_gettime, [], [\n-  AC_CHECK_LIB(rt, clock_gettime, [\n-    AC_DEFINE(HAVE_CLOCK_GETTIME, 1)\n-    EXTRA_LIBS=\"$EXTRA_LIBS -lrt\"\n-  ])\n-])\n-\n-dnl\n-dnl Check for trio string functions\n-dnl\n-\n-if test \"${NEED_TRIO}\" = \"1\" ; then\n-    echo Reusing trio library for string functions\n-    WITH_TRIO=1\n-else    \n-    WITH_TRIO=0\n-fi\n-AC_SUBST(WITH_TRIO)\n-\n-dnl\n-dnl Some packages need to be checked against version numbers so we\n-dnl define a function here for later use\n-dnl\n-AC_DEFUN([VERSION_TO_NUMBER],\n-[`$1 | sed -e 's\/libxml \/\/' | awk 'BEGIN { FS = \".\"; } { printf \"%d\", ([$]1 * 1000 + [$]2) * 1000 + [$]3;}'`])\n-\n-dnl\n-dnl Perl is just needed for generating some data for XSLtmark\n-dnl\n-\n-AC_CHECK_PROG(PERL, perl, perl, false)\n-AM_CONDITIONAL(WITH_PERL, test \"$PERL\" != \"false\")\n-\n-dnl\n-dnl check for python\n-dnl\n-\n-AC_ARG_WITH(python,\n-[  --with-python           build Python bindings (on)])\n-\n-AS_IF([test \"x$with_python\" != \"xno\"], [\n-    AM_PATH_PYTHON\n-    PKG_CHECK_MODULES([PYTHON], [python-${PYTHON_VERSION}])\n-    case \"$host\" in\n-        *-*-cygwin* | *-*-mingw* | *-*-msys* )\n-            PYTHON_LDFLAGS=\"-no-undefined -shrext .pyd\"\n-            ;;\n-    esac\n-])\n-AC_SUBST(PYTHON_LDFLAGS)\n-AM_CONDITIONAL([WITH_PYTHON], [test \"x$with_python\" != \"xno\"])\n-\n-AC_ARG_WITH(crypto, [  --with-crypto           Add crypto support to exslt (off)])\n-WITH_CRYPTO=0\n-CRYPTO_TESTDIR=\n-if test \"$with_crypto\" != \"yes\" ; then\n-    LIBGCRYPT_CFLAGS=\"\"\n-    LIBGCRYPT_LIBS=\"\"\n-else\n-echo Enabling crypto support\n-case $host in\n-  *-mingw*)\n-    dnl Use only native crypto-API for mingw* hosts\n-    dnl TODO: to implement --with-crypto=foo to allow switch between\n-    dnl crypto libraries\n-    WITH_CRYPTO=1\n-    CRYPTO_TESTDIR=crypto\n-    ;;\n-  *)\n-    AC_PATH_TOOL(LIBGCRYPT_CONFIG, libgcrypt-config, no)\n-    if test \"$LIBGCRYPT_CONFIG\" != \"no\" ; then\n-      LIBGCRYPT_VERSION=`$LIBGCRYPT_CONFIG --version`\n-      if test VERSION_TO_NUMBER(echo $LIBGCRYPT_VERSION) -lt VERSION_TO_NUMBER(echo \"1.1.42\")\n-      then\n-        LIBGCRYPT_CFLAGS=\"\"\n-        LIBGCRYPT_LIBS=\"\"\n-        echo 'gcrypt library version < 1.1.42 - Crypto extensions will not be available.'\n-      else\n-        LIBGCRYPT_CFLAGS=`$LIBGCRYPT_CONFIG $libgcrypt_config_args --cflags`\n-        LIBGCRYPT_LIBS=`$LIBGCRYPT_CONFIG $libgcrypt_config_args --libs`\n-        AC_DEFINE(HAVE_GCRYPT, 1, [Define if gcrypt library is available.])\n-        echo 'Crypto extensions will be available.'\n-        WITH_CRYPTO=1\n-        CRYPTO_TESTDIR=crypto\n-      fi\n-    else\n-      PKG_CHECK_MODULES([LIBGCRYPT], [libgcrypt >= 1.1.42], [\n-          AC_DEFINE(HAVE_GCRYPT, 1, [Define if gcrypt library is available.])\n-          echo 'Crypto extensions will be available.'\n-          WITH_CRYPTO=1\n-          CRYPTO_TESTDIR=crypt\n-      ], [\n-          LIBGCRYPT_CFLAGS=\"\"\n-          LIBGCRYPT_LIBS=\"\"\n-          echo 'Crypto extensions will not be available. Install libgcrypt >= 1.1.42 and reconfigure to make available.'\n-      ])\n-    fi\n-esac\n-fi\n-AC_SUBST(WITH_CRYPTO)\n-AC_SUBST(CRYPTO_TESTDIR)\n-AC_SUBST(LIBGCRYPT_CFLAGS)\n-AC_SUBST(LIBGCRYPT_LIBS)\n-\n-AC_ARG_WITH(debug, [  --with-debug            Add the debugging code (on)])\n-if test \"$with_debug\" != \"yes\" ; then\n-    WITH_XSLT_DEBUG=0\n-else    \n-    echo Enabling debug support\n-    WITH_XSLT_DEBUG=1\n-fi\n-AC_SUBST(WITH_XSLT_DEBUG)\n-\n-dnl \n-dnl Is debugger support requested\n-dnl\n-AC_ARG_WITH(debugger, [  --with-debugger        Add the debugging support (on)])\n-if test \"$with_debugger\" != \"yes\" ; then\n-    WITH_DEBUGGER=0\n-else\n-    echo Enabling debugger\n-    WITH_DEBUGGER=1\n-    AC_DEFINE([WITH_DEBUGGER],[], [Define if debugging support is enabled])\n-fi\n-AC_SUBST(WITH_DEBUGGER)\n-\n-dnl\n-dnl Is profiler support requested\n-dnl\n-AC_ARG_WITH(profiler, [  --with-profiler        Add the profiling support (on)])\n-if test \"$with_profiler\" = \"no\" ; then\n-    echo Disabling profiler\n-    WITH_PROFILER=0\n-else\n-    echo Enabling profiler\n-    WITH_PROFILER=1\n-    AC_DEFINE([WITH_PROFILER],[], [Define if profiling support is enabled])\n-fi\n-AC_SUBST(WITH_PROFILER)\n-\n-dnl\n-dnl The following new parameters were added to offer\n-dnl the ability to specify the location of the libxml\n-dnl library during linking and compilation.\n-dnl\n-dnl original work - Mathieu Lacage 30\/03\/2000\n-dnl some tweaking - David Hrdeman 30\/10\/2001\n-dnl\n-\n-LIBXML_CONFIG_PREFIX=\"\"\n-LIBXML_SRC=\"\"\n-\n-AC_ARG_WITH(libxml-prefix,\n-        [  --with-libxml-prefix=[PFX]\t\tSpecify location of libxml config],\n-\tLIBXML_CONFIG_PREFIX=$withval\n-)\n-        \n-AC_ARG_WITH(libxml-include-prefix,\n-        [  --with-libxml-include-prefix=[PFX]\tSpecify location of libxml headers],\n-        LIBXML_CFLAGS=\"-I$withval\"\n-)\n-\n-AC_ARG_WITH(libxml-libs-prefix,\n-        [  --with-libxml-libs-prefix=[PFX]\tSpecify location of libxml libs],\n-        LIBXML_LIBS=\"-L$withval\"\n-)\n-\n-AC_ARG_WITH(libxml-src,\n-\t[  --with-libxml-src=[DIR]              For libxml thats not installed yet (sets all three above)],\n-\tLIBXML_SRC=\"$withval\"\n-)\n-AC_SUBST(LIBXML_SRC)\n-\n-dnl\n-dnl where is xml2-config\n-dnl\n-\n-AC_SUBST(LIBXML_REQUIRED_VERSION)\n-if test \"x$LIBXML_CONFIG_PREFIX\" != \"x\"\n-then\n-\tAC_PATH_TOOL([XML_CONFIG], [xml2-config], [false], [${LIBXML_CONFIG_PREFIX}\/bin])\n-else\n-\tAC_PATH_TOOL([XML_CONFIG], [xml2-config], [false])\n-fi\n-\n-dnl\n-dnl imported from libxml2, c.f. #77827 \n-dnl\n-if test \"${GCC}\" != \"yes\" ; then\n-    case \"${host}\" in\n-          *-*-hpux* )\n-\t       AM_CFLAGS=\"${AM_CFLAGS} -Wp,-H30000\"\n-\t       ;;\n-          *-dec-osf* )\n-               AM_CFLAGS=\"${AM_CFLAGS} -ieee\"\n-               ;;\n-    esac\n-else\n-    AM_CFLAGS=\"${AM_CFLAGS} -Wall -Wextra -Wshadow -Wpointer-arith -Wcast-align -Wwrite-strings -Waggregate-return -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Winline -Wredundant-decls\"\n-    case \"${host}\" in\n-          alpha*-*-linux* )\n-\t       AM_CFLAGS=\"${AM_CFLAGS} -mieee\"\n-\t       ;;\n-\t  alpha*-*-osf* )\n-\t       AM_CFLAGS=\"${AM_CFLAGS} -mieee\"\n-\t       ;;\n-    esac\n-fi\n-\n-dnl\n-dnl Check which type of library to build. Default to building shared and static.\n-dnl\n-\n-build_shared_libs=\"yes\"\n-build_static_libs=\"yes\"\n-xml_config_dynamic=\n-\n-if test \"$enable_shared\" = \"no\"; then\n-    build_shared_libs=\"no\"\n-fi\n-\n-if test \"$enable_static\" = \"no\"; then\n-    build_static_libs=\"no\"\n-fi\n-\n-if test \"$build_shared_libs\" = \"no\" && test \"$build_static_libs\" = \"no\"; then\n-    build_static_libs=\"yes\"\n-fi\n-\n-dnl\n-dnl Override other variables if LIBXML_SRC is set\n-dnl\n-\n-if test \"x$LIBXML_SRC\" != \"x\"; then\n-    CWD=`pwd`\n-    if cd $LIBXML_SRC; then\n-        LIBXML_SRC=`pwd`\n-        XML_CONFIG=\"${LIBXML_SRC}\/xml2-config\"\n-        LIBXML_CFLAGS=\"-I${LIBXML_SRC}\/include\"\n-        if test \"$build_static_libs\" = \"no\"; then\n-            if $XML_CONFIG --help | grep -q '\\--dynamic'; then\n-                xml_config_dynamic=--dynamic\n-            fi\n-        fi\n-        LIBXML_LIBS=\"-L${LIBXML_SRC} `$XML_CONFIG --libs $xml_config_dynamic`\"\n-        cd $CWD\n-    else\n-        AC_MSG_ERROR([libxml source dir not found (${LIBXML_SRC}), typo?])\n-    fi\n-fi\n-\n-dnl\n-dnl Try pkg-config first if nothing is set\n-dnl\n-\n-if test \"x$LIBXML_CONFIG_PREFIX\" = \"x\" && test \"x$LIBXML_LIBS\" = \"x\"; then\n-    if test \"$build_shared_libs\" = \"yes\"; then\n-        PKG_CHECK_MODULES([LIBXML], [libxml-2.0 >= $LIBXML_REQUIRED_VERSION],\n-                          [ ], [ ])\n-    else\n-        PKG_CHECK_MODULES_STATIC([LIBXML], [libxml-2.0 >= $LIBXML_REQUIRED_VERSION],\n-        [ ], [ ])\n-    fi\n-fi\n-\n-dnl\n-dnl make sure xml2-config is executable,\n-dnl test version and init our variables\n-dnl\n-\n-if test \"x$LIBXML_LIBS\" = \"x\" && ${XML_CONFIG} --libs > \/dev\/null 2>&1\n-then\n-    AC_MSG_CHECKING(for libxml libraries >= $LIBXML_REQUIRED_VERSION)\n-    XMLVERS=`$XML_CONFIG --version`\n-    if test VERSION_TO_NUMBER(echo $XMLVERS) -ge VERSION_TO_NUMBER(echo $LIBXML_REQUIRED_VERSION); then\n-        AC_MSG_RESULT($XMLVERS found)\n-    else\n-        AC_MSG_ERROR(Version $XMLVERS found. You need at least libxml2 $LIBXML_REQUIRED_VERSION for this version of libxslt)\n-    fi\n-\n-    if test \"$build_static_libs\" = \"no\"; then\n-        if $XML_CONFIG --help | grep -q '\\--dynamic'; then\n-            xml_config_dynamic=--dynamic\n-        fi\n-    fi\n-    LIBXML_LIBS=\"`$XML_CONFIG --libs $xml_config_dynamic`\"\n-    LIBXML_CFLAGS=\"`$XML_CONFIG --cflags`\"\n-fi\n-\n-if test \"x$LIBXML_LIBS\" = \"x\"\n-then\n-\tAC_MSG_ERROR([Could not find libxml2 anywhere.])\n-fi\n-\n-AM_CFLAGS=\"$AM_CFLAGS $LIBXML_CFLAGS\"\n-\n-\n-AC_ARG_WITH(plugins,\n-[  --with-plugins          Add plugin extension support (off)])\n-if test \"$with_plugins\" = \"\"\n-then\n-    with_plugins=no\n-fi\n-\n-AC_MSG_CHECKING([whether shared libraries will be built (required for plugins)])\n-if test \"$build_shared_libs\" = \"no\" && test \"$with_plugins\" = \"yes\"; then\n-\t AC_MSG_RESULT(no)\n-\t AC_MSG_WARN([Disabling plugin support.])\n-\t AC_MSG_WARN([Plugins require that shared libraries be built.])\n-\t with_plugins=no\n-else\n-\t AC_MSG_RESULT(yes)\n-fi\n-\n-if test \"$with_plugins\" = \"yes\" ; then\n-    WITH_MODULES=1\n-\n-    case \"$host\" in\n-        *-*-cygwin* | *-*-mingw* | *-*-msys* )\n-            AC_DEFINE([MODULE_EXTENSION], [\".dll\"], [plugin file extension])\n-            ;;\n-        *)\n-            AC_DEFINE([MODULE_EXTENSION], [\".so\"], [plugin file extension])\n-\t    ;;\n-    esac\n-\n-    case \"$host\" in\n-        *-*-mingw*)\n-            ;;\n-        *)\n-            _libs=$LIBS\n-            AC_SEARCH_LIBS([dlopen], [dl], [\n-                WITH_MODULES=1\n-                if test \"$ac_cv_search_dlopen\" != \"none required\"; then\n-                    MODULE_LIBS=$ac_cv_search_dlopen\n-                fi], [\n-                    AC_MSG_ERROR([dlopen or equivalent not found])\n-                ])\n-            LIBS=$_libs\n-\t    ;;\n-    esac\n-\n-    dnl\n-    dnl setup default module path\n-    dnl\n-    expanded_libdir=$(\n-        test \"x$prefix\" = xNONE && prefix=\"$ac_default_prefix\"\n-        test \"x$exec_prefix\" = xNONE && exec_prefix=\"$prefix\"\n-        while test \"$libdir_old\" != \"$libdir\"; do\n-          libdir_old=\"$libdir\"\n-          eval libdir=\"$libdir\"\n-        done\n-        echo \"$libdir\"\n-    )\n-    LIBXSLT_DEFAULT_PLUGINS_PATH=\"$expanded_libdir\/libxslt-plugins\"\n-    AC_SUBST(LIBXSLT_DEFAULT_PLUGINS_PATH)\n-else\n-    WITH_MODULES=\"0\"\n-fi\n-\n-AC_SUBST(WITH_MODULES)\n-AM_CONDITIONAL(WITH_MODULES, test \"$WITH_MODULES\" = \"1\")\n-\n-AC_SUBST(XML_CONFIG)\n-AC_SUBST(LIBXML_LIBS)\n-AC_SUBST(LIBXML_CFLAGS)\n-\n-XSLT_LIBDIR='-L${libdir}'\n-XSLT_INCLUDEDIR='-I${includedir}'\n-XSLT_LIBS=\"-lxslt $LIBXML_LIBS\"\n-XSLT_PRIVATE_LIBS=\"$MODULE_LIBS $LIBM\"\n-AC_SUBST(XSLT_LIBDIR)\n-AC_SUBST(XSLT_INCLUDEDIR)\n-AC_SUBST(XSLT_LIBS)\n-AC_SUBST(XSLT_PRIVATE_LIBS)\n-\n-LIBXSLT_CFLAGS=\"\"\n-LIBEXSLT_CFLAGS=\"\"\n-case ${host} in\n-    *-*-mingw* | *-*-cygwin* | *-*-msvc* )\n-        # If the host is Windows, and shared libraries are disabled, we\n-        # need to add -DLIBXML_STATIC to AM_CFLAGS in order for linking to\n-        # work properly (without it, xmlexports.h would force the use of\n-        # DLL imports, which obviously aren't present in a static\n-        # library).\n-        if test \"x$enable_shared\" = \"xno\"; then\n-           LIBXSLT_CFLAGS=\"$LIBXSLT_CFLAGS -DLIBXSLT_STATIC\"\n-           LIBEXSLT_CFLAGS=\"$LIBEXSLT_CFLAGS -DLIBEXSLT_STATIC\"\n-           AM_CFLAGS=\"$AM_CFLAGS -DLIBXSLT_STATIC -DLIBEXSLT_STATIC\"\n-        fi\n-        ;;\n-esac\n-AC_SUBST(LIBXSLT_CFLAGS)\n-AC_SUBST(LIBEXSLT_CFLAGS)\n-\n-AC_SUBST(AM_CFLAGS)\n-\n-EXSLT_LIBDIR='-L${libdir}'\n-EXSLT_INCLUDEDIR='-I${includedir}'\n-EXSLT_PRIVATE_LIBS=\"$XSLT_PRIVATE_LIBS $LIBGCRYPT_LIBS\"\n-AC_SUBST(EXSLT_LIBDIR)\n-AC_SUBST(EXSLT_INCLUDEDIR)\n-AC_SUBST(EXSLT_PRIVATE_LIBS)\n-\n-AC_SUBST(EXTRA_LIBS)\n-\n-dnl for the spec file\n-RELDATE=`date +'%a %b %e %Y'`\n-AC_SUBST(RELDATE)\n-\n-\n-AC_CONFIG_FILES([\n-Makefile\n-libxslt.pc\n-libexslt.pc\n-libxslt-config.cmake\n-libxslt\/Makefile\n-libxslt\/xsltconfig.h\n-libexslt\/Makefile\n-libexslt\/exsltconfig.h\n-xsltproc\/Makefile\n-python\/Makefile\n-python\/setup.py\n-python\/tests\/Makefile\n-tests\/Makefile\n-tests\/xmlspec\/Makefile\n-tests\/multiple\/Makefile\n-tests\/xinclude\/Makefile\n-tests\/XSLTMark\/Makefile\n-tests\/docbook\/Makefile\n-tests\/fuzz\/Makefile\n-doc\/Makefile\n-doc\/devhelp\/Makefile\n-doc\/EXSLT\/devhelp\/Makefile\n-])\n-AC_CONFIG_FILES([xslt-config], [chmod +x xslt-config])\n-\n-AC_OUTPUT\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/configure.ac","additions":0,"deletions":587,"binary":false,"changes":587,"status":"deleted"},{"patch":"@@ -1,13 +0,0 @@\n-prefix=@prefix@\n-exec_prefix=@exec_prefix@\n-libdir=@libdir@\n-includedir=@includedir@\n-\n-\n-Name: libexslt\n-Version: @LIBEXSLT_VERSION@\n-Description: EXSLT Extension library\n-Requires: libxml-2.0, libxslt\n-Cflags: @EXSLT_INCLUDEDIR@ @LIBEXSLT_CFLAGS@\n-Libs: @EXSLT_LIBDIR@ -lexslt\n-Libs.private: @EXSLT_PRIVATE_LIBS@\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt.pc.in","additions":0,"deletions":13,"binary":false,"changes":13,"status":"deleted"},{"patch":"@@ -1,124 +0,0 @@\n-#define IN_LIBEXSLT\n-#include \"libexslt\/libexslt.h\"\n-\n-#include <libxml\/tree.h>\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-\n-#include <libxslt\/xsltutils.h>\n-#include <libxslt\/xsltInternals.h>\n-#include <libxslt\/extensions.h>\n-#include <libxslt\/transform.h>\n-#include <libxslt\/extra.h>\n-#include <libxslt\/preproc.h>\n-\n-#include \"exslt.h\"\n-\n-static void\n-exsltNodeSetFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    if (xmlXPathStackIsNodeSet (ctxt)) {\n-    xsltFunctionNodeSet (ctxt, nargs);\n-    return;\n-    } else {\n-    xmlDocPtr fragment;\n-    xsltTransformContextPtr tctxt = xsltXPathGetTransformContext(ctxt);\n-    xmlNodePtr txt;\n-    xmlChar *strval;\n-    xmlXPathObjectPtr obj;\n-    \/*\n-    * SPEC EXSLT:\n-    * \"You can also use this function to turn a string into a text\n-    * node, which is helpful if you want to pass a string to a\n-    * function that only accepts a node-set.\"\n-    *\/\n-    fragment = xsltCreateRVT(tctxt);\n-    if (fragment == NULL) {\n-        xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"exsltNodeSetFunction: Failed to create a tree fragment.\\n\");\n-        tctxt->state = XSLT_STATE_STOPPED;\n-        return;\n-    }\n-    xsltRegisterLocalRVT(tctxt, fragment);\n-\n-    strval = xmlXPathPopString (ctxt);\n-\n-    txt = xmlNewDocText (fragment, strval);\n-    xmlAddChild((xmlNodePtr) fragment, txt);\n-    obj = xmlXPathNewNodeSet(txt);\n-    if (obj == NULL) {\n-        xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"exsltNodeSetFunction: Failed to create a node set object.\\n\");\n-        tctxt->state = XSLT_STATE_STOPPED;\n-    }\n-    if (strval != NULL)\n-        xmlFree (strval);\n-\n-    valuePush (ctxt, obj);\n-    }\n-}\n-\n-static void\n-exsltObjectTypeFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlXPathObjectPtr obj, ret;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    obj = valuePop(ctxt);\n-\n-    switch (obj->type) {\n-    case XPATH_STRING:\n-    ret = xmlXPathNewCString(\"string\");\n-    break;\n-    case XPATH_NUMBER:\n-    ret = xmlXPathNewCString(\"number\");\n-    break;\n-    case XPATH_BOOLEAN:\n-    ret = xmlXPathNewCString(\"boolean\");\n-    break;\n-    case XPATH_NODESET:\n-    ret = xmlXPathNewCString(\"node-set\");\n-    break;\n-    case XPATH_XSLT_TREE:\n-    ret = xmlXPathNewCString(\"RTF\");\n-    break;\n-    case XPATH_USERS:\n-    ret = xmlXPathNewCString(\"external\");\n-    break;\n-    default:\n-    xsltGenericError(xsltGenericErrorContext,\n-        \"object-type() invalid arg\\n\");\n-    ctxt->error = XPATH_INVALID_TYPE;\n-    xmlXPathFreeObject(obj);\n-    return;\n-    }\n-    xmlXPathFreeObject(obj);\n-    valuePush(ctxt, ret);\n-}\n-\n-\n-\/**\n- * exsltCommonRegister:\n- *\n- * Registers the EXSLT - Common module\n- *\/\n-\n-void\n-exsltCommonRegister (void) {\n-    xsltRegisterExtModuleFunction((const xmlChar *) \"node-set\",\n-                  EXSLT_COMMON_NAMESPACE,\n-                  exsltNodeSetFunction);\n-    xsltRegisterExtModuleFunction((const xmlChar *) \"object-type\",\n-                  EXSLT_COMMON_NAMESPACE,\n-                  exsltObjectTypeFunction);\n-    xsltRegisterExtModuleElement((const xmlChar *) \"document\",\n-                 EXSLT_COMMON_NAMESPACE,\n-                 xsltDocumentComp,\n-                 xsltDocumentElem);\n-}\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/common.c","additions":0,"deletions":124,"binary":false,"changes":124,"status":"deleted"},{"patch":"@@ -1,806 +0,0 @@\n-#define IN_LIBEXSLT\n-#include \"libexslt\/libexslt.h\"\n-\n-#include <libxml\/tree.h>\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/encoding.h>\n-#include <libxml\/uri.h>\n-#include <libxml\/threads.h>\n-\n-#include <libxslt\/xsltutils.h>\n-#include <libxslt\/xsltInternals.h>\n-#include <libxslt\/extensions.h>\n-\n-#include \"exslt.h\"\n-\n-#ifdef EXSLT_CRYPTO_ENABLED\n-\n-#define HASH_DIGEST_LENGTH 32\n-#define MD5_DIGEST_LENGTH 16\n-#define SHA1_DIGEST_LENGTH 20\n-\n-\/* gcrypt rc4 can do 256 bit keys, but cryptoapi limit\n-   seems to be 128 for the default provider *\/\n-#define RC4_KEY_LENGTH 128\n-\n-\/* The following routines have been declared static - this should be\n-   reviewed to consider whether we want to expose them to the API\n-   exsltCryptoBin2Hex\n-   exsltCryptoHex2Bin\n-   exsltCryptoGcryptInit\n-   exsltCryptoGcryptHash\n-   exsltCryptoGcryptRc4Encrypt\n-   exsltCryptoGcryptRC4Decrypt\n-*\/\n-\n-\/**\n- * exsltCryptoBin2Hex:\n- * @bin: binary blob to convert\n- * @binlen: length of binary blob\n- * @hex: buffer to store hex version of blob\n- * @hexlen: length of buffer to store hex version of blob\n- *\n- * Helper function which encodes a binary blob as hex.\n- *\/\n-static void\n-exsltCryptoBin2Hex (const unsigned char *bin, int binlen,\n-            unsigned char *hex, int hexlen) {\n-    static const char bin2hex[] = { '0', '1', '2', '3',\n-    '4', '5', '6', '7',\n-    '8', '9', 'a', 'b',\n-    'c', 'd', 'e', 'f'\n-    };\n-\n-    unsigned char lo, hi;\n-    int i, pos;\n-    for (i = 0, pos = 0; (i < binlen && pos < hexlen); i++) {\n-    lo = bin[i] & 0xf;\n-    hi = bin[i] >> 4;\n-    hex[pos++] = bin2hex[hi];\n-    hex[pos++] = bin2hex[lo];\n-    }\n-\n-    hex[pos] = '\\0';\n-}\n-\n-\/**\n- * exsltCryptoHex2Bin:\n- * @hex: hex version of blob to convert\n- * @hexlen: length of hex buffer\n- * @bin: destination binary buffer\n- * @binlen: length of binary buffer\n- *\n- * Helper function which decodes a hex blob to binary\n- *\/\n-static int\n-exsltCryptoHex2Bin (const unsigned char *hex, int hexlen,\n-            unsigned char *bin, int binlen) {\n-    int i = 0, j = 0;\n-    unsigned char lo, hi, result, tmp;\n-\n-    while (i < hexlen && j < binlen) {\n-    hi = lo = 0;\n-\n-    tmp = hex[i++];\n-    if (tmp >= '0' && tmp <= '9')\n-        hi = tmp - '0';\n-    else if (tmp >= 'a' && tmp <= 'f')\n-        hi = 10 + (tmp - 'a');\n-\n-    tmp = hex[i++];\n-    if (tmp >= '0' && tmp <= '9')\n-        lo = tmp - '0';\n-    else if (tmp >= 'a' && tmp <= 'f')\n-        lo = 10 + (tmp - 'a');\n-\n-    result = hi << 4;\n-    result += lo;\n-    bin[j++] = result;\n-    }\n-\n-    return j;\n-}\n-\n-#if defined(_WIN32)\n-\n-#define HAVE_CRYPTO\n-#define PLATFORM_HASH    exsltCryptoCryptoApiHash\n-#define PLATFORM_RC4_ENCRYPT exsltCryptoCryptoApiRc4Encrypt\n-#define PLATFORM_RC4_DECRYPT exsltCryptoCryptoApiRc4Decrypt\n-#define PLATFORM_MD4 CALG_MD4\n-#define PLATFORM_MD5 CALG_MD5\n-#define PLATFORM_SHA1 CALG_SHA1\n-\n-#include <windows.h>\n-#include <wincrypt.h>\n-#ifdef _MSC_VER\n-#pragma comment(lib, \"advapi32.lib\")\n-#endif\n-\n-static void\n-exsltCryptoCryptoApiReportError (xmlXPathParserContextPtr ctxt,\n-                 int line) {\n-    char *lpMsgBuf;\n-    DWORD dw = GetLastError ();\n-\n-    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n-           FORMAT_MESSAGE_FROM_SYSTEM, NULL, dw,\n-           MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),\n-           (LPSTR)&lpMsgBuf, 0, NULL);\n-\n-    xsltTransformError (xsltXPathGetTransformContext (ctxt), NULL, NULL,\n-            \"exslt:crypto error (line %d). %s\", line,\n-            lpMsgBuf);\n-    LocalFree (lpMsgBuf);\n-}\n-\n-static HCRYPTHASH\n-exsltCryptoCryptoApiCreateHash (xmlXPathParserContextPtr ctxt,\n-                HCRYPTPROV hCryptProv, ALG_ID algorithm,\n-                const unsigned char *msg, unsigned int msglen,\n-                char *dest, unsigned int destlen)\n-{\n-    HCRYPTHASH hHash = 0;\n-    DWORD dwHashLen = destlen;\n-\n-    if (!CryptCreateHash (hCryptProv, algorithm, 0, 0, &hHash)) {\n-    exsltCryptoCryptoApiReportError (ctxt, __LINE__);\n-    return 0;\n-    }\n-\n-    if (!CryptHashData (hHash, msg, msglen, 0)) {\n-    exsltCryptoCryptoApiReportError (ctxt, __LINE__);\n-    goto fail;\n-    }\n-\n-    if (!CryptGetHashParam (hHash, HP_HASHVAL, (BYTE *) dest, &dwHashLen, 0)) {\n-    exsltCryptoCryptoApiReportError (ctxt, __LINE__);\n-    goto fail;\n-    }\n-\n-  fail:\n-    return hHash;\n-}\n-\n-\/**\n- * exsltCryptoCryptoApiHash:\n- * @ctxt: an XPath parser context\n- * @algorithm: hashing algorithm to use\n- * @msg: text to be hashed\n- * @msglen: length of text to be hashed\n- * @dest: buffer to place hash result\n- *\n- * Helper function which hashes a message using MD4, MD5, or SHA1.\n- * Uses Win32 CryptoAPI.\n- *\/\n-static void\n-exsltCryptoCryptoApiHash (xmlXPathParserContextPtr ctxt,\n-              ALG_ID algorithm, const char *msg,\n-              unsigned long msglen,\n-              char dest[HASH_DIGEST_LENGTH]) {\n-    HCRYPTPROV hCryptProv;\n-    HCRYPTHASH hHash;\n-\n-    if (!CryptAcquireContext (&hCryptProv, NULL, NULL, PROV_RSA_FULL,\n-                  CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {\n-    exsltCryptoCryptoApiReportError (ctxt, __LINE__);\n-    return;\n-    }\n-\n-    hHash = exsltCryptoCryptoApiCreateHash (ctxt, hCryptProv,\n-                        algorithm, (unsigned char *) msg,\n-                                            msglen, dest, HASH_DIGEST_LENGTH);\n-    if (0 != hHash) {\n-    CryptDestroyHash (hHash);\n-    }\n-\n-    CryptReleaseContext (hCryptProv, 0);\n-}\n-\n-static void\n-exsltCryptoCryptoApiRc4Encrypt (xmlXPathParserContextPtr ctxt,\n-                const unsigned char *key,\n-                const unsigned char *msg, int msglen,\n-                unsigned char *dest, int destlen) {\n-    HCRYPTPROV hCryptProv;\n-    HCRYPTKEY hKey;\n-    HCRYPTHASH hHash;\n-    DWORD dwDataLen;\n-    char hash[HASH_DIGEST_LENGTH];\n-\n-    if (msglen > destlen) {\n-    xsltTransformError (xsltXPathGetTransformContext (ctxt), NULL,\n-                NULL,\n-                \"exslt:crypto : internal error exsltCryptoCryptoApiRc4Encrypt dest buffer too small.\\n\");\n-    return;\n-    }\n-\n-    if (!CryptAcquireContext (&hCryptProv, NULL, NULL, PROV_RSA_FULL,\n-                  CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {\n-    exsltCryptoCryptoApiReportError (ctxt, __LINE__);\n-    return;\n-    }\n-\n-    hHash = exsltCryptoCryptoApiCreateHash (ctxt, hCryptProv,\n-                        CALG_SHA1, key,\n-                        RC4_KEY_LENGTH, hash,\n-                        HASH_DIGEST_LENGTH);\n-\n-    if (!CryptDeriveKey\n-    (hCryptProv, CALG_RC4, hHash, 0x00800000, &hKey)) {\n-    exsltCryptoCryptoApiReportError (ctxt, __LINE__);\n-    goto fail;\n-    }\n-\/* Now encrypt data. *\/\n-    dwDataLen = msglen;\n-    memcpy (dest, msg, msglen);\n-    if (!CryptEncrypt (hKey, 0, TRUE, 0, dest, &dwDataLen, msglen)) {\n-    exsltCryptoCryptoApiReportError (ctxt, __LINE__);\n-    goto fail;\n-    }\n-\n-  fail:\n-    if (0 != hHash) {\n-    CryptDestroyHash (hHash);\n-    }\n-\n-    CryptDestroyKey (hKey);\n-    CryptReleaseContext (hCryptProv, 0);\n-}\n-\n-static void\n-exsltCryptoCryptoApiRc4Decrypt (xmlXPathParserContextPtr ctxt,\n-                const unsigned char *key,\n-                const unsigned char *msg, int msglen,\n-                unsigned char *dest, int destlen) {\n-    HCRYPTPROV hCryptProv;\n-    HCRYPTKEY hKey;\n-    HCRYPTHASH hHash;\n-    DWORD dwDataLen;\n-    char hash[HASH_DIGEST_LENGTH];\n-\n-    if (msglen > destlen) {\n-    xsltTransformError (xsltXPathGetTransformContext (ctxt), NULL,\n-                NULL,\n-                \"exslt:crypto : internal error exsltCryptoCryptoApiRc4Encrypt dest buffer too small.\\n\");\n-    return;\n-    }\n-\n-    if (!CryptAcquireContext (&hCryptProv, NULL, NULL, PROV_RSA_FULL,\n-                  CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {\n-    exsltCryptoCryptoApiReportError (ctxt, __LINE__);\n-    return;\n-    }\n-\n-    hHash = exsltCryptoCryptoApiCreateHash (ctxt, hCryptProv,\n-                        CALG_SHA1, key,\n-                        RC4_KEY_LENGTH, hash,\n-                        HASH_DIGEST_LENGTH);\n-\n-    if (!CryptDeriveKey\n-    (hCryptProv, CALG_RC4, hHash, 0x00800000, &hKey)) {\n-    exsltCryptoCryptoApiReportError (ctxt, __LINE__);\n-    goto fail;\n-    }\n-\/* Now encrypt data. *\/\n-    dwDataLen = msglen;\n-    memcpy (dest, msg, msglen);\n-    if (!CryptDecrypt (hKey, 0, TRUE, 0, dest, &dwDataLen)) {\n-    exsltCryptoCryptoApiReportError (ctxt, __LINE__);\n-    goto fail;\n-    }\n-\n-  fail:\n-    if (0 != hHash) {\n-    CryptDestroyHash (hHash);\n-    }\n-\n-    CryptDestroyKey (hKey);\n-    CryptReleaseContext (hCryptProv, 0);\n-}\n-\n-#endif \/* defined(_WIN32) *\/\n-\n-#if defined(HAVE_GCRYPT)\n-\n-#define HAVE_CRYPTO\n-#define PLATFORM_HASH    exsltCryptoGcryptHash\n-#define PLATFORM_RC4_ENCRYPT exsltCryptoGcryptRc4Encrypt\n-#define PLATFORM_RC4_DECRYPT exsltCryptoGcryptRc4Decrypt\n-#define PLATFORM_MD4 GCRY_MD_MD4\n-#define PLATFORM_MD5 GCRY_MD_MD5\n-#define PLATFORM_SHA1 GCRY_MD_SHA1\n-\n-#ifdef HAVE_SYS_TYPES_H\n-# include <sys\/types.h>\n-#endif\n-\n-#ifdef HAVE_SYS_SELECT_H\n-#include <sys\/select.h>        \/* needed by gcrypt.h 4 Jul 04 *\/\n-#endif\n-#include <gcrypt.h>\n-\n-static void\n-exsltCryptoGcryptInit (void) {\n-    static int gcrypt_init;\n-    xmlLockLibrary ();\n-\n-    if (!gcrypt_init) {\n-\/* The function `gcry_check_version' must be called before any other\n-     function in the library, because it initializes the thread support\n-     subsystem in Libgcrypt. To achieve this in all generality, it is\n-     necessary to synchronize the call to this function with all other calls\n-     to functions in the library, using the synchronization mechanisms\n-     available in your thread library. (from gcrypt.info)\n-*\/\n-    gcry_check_version (GCRYPT_VERSION);\n-    gcrypt_init = 1;\n-    }\n-\n-    xmlUnlockLibrary ();\n-}\n-\n-\/**\n- * exsltCryptoGcryptHash:\n- * @ctxt: an XPath parser context\n- * @algorithm: hashing algorithm to use\n- * @msg: text to be hashed\n- * @msglen: length of text to be hashed\n- * @dest: buffer to place hash result\n- *\n- * Helper function which hashes a message using MD4, MD5, or SHA1.\n- * using gcrypt\n- *\/\n-static void\n-exsltCryptoGcryptHash (xmlXPathParserContextPtr ctxt ATTRIBUTE_UNUSED,\n-\/* changed the enum to int *\/\n-               int algorithm, const char *msg,\n-               unsigned long msglen,\n-               char dest[HASH_DIGEST_LENGTH]) {\n-    exsltCryptoGcryptInit ();\n-    gcry_md_hash_buffer (algorithm, dest, msg, msglen);\n-}\n-\n-static void\n-exsltCryptoGcryptRc4Encrypt (xmlXPathParserContextPtr ctxt,\n-                 const unsigned char *key,\n-                 const unsigned char *msg, int msglen,\n-                 unsigned char *dest, int destlen) {\n-    gcry_cipher_hd_t cipher;\n-    gcry_error_t rc = 0;\n-\n-    exsltCryptoGcryptInit ();\n-\n-    rc = gcry_cipher_open (&cipher, GCRY_CIPHER_ARCFOUR,\n-               GCRY_CIPHER_MODE_STREAM, 0);\n-    if (rc) {\n-    xsltTransformError (xsltXPathGetTransformContext (ctxt), NULL,\n-                NULL,\n-                \"exslt:crypto internal error %s (gcry_cipher_open)\\n\",\n-                gcry_strerror (rc));\n-    }\n-\n-    rc = gcry_cipher_setkey (cipher, key, RC4_KEY_LENGTH);\n-    if (rc) {\n-    xsltTransformError (xsltXPathGetTransformContext (ctxt), NULL,\n-                NULL,\n-                \"exslt:crypto internal error %s (gcry_cipher_setkey)\\n\",\n-                gcry_strerror (rc));\n-    }\n-\n-    rc = gcry_cipher_encrypt (cipher, (unsigned char *) dest, destlen,\n-                  (const unsigned char *) msg, msglen);\n-    if (rc) {\n-    xsltTransformError (xsltXPathGetTransformContext (ctxt), NULL,\n-                NULL,\n-                \"exslt:crypto internal error %s (gcry_cipher_encrypt)\\n\",\n-                gcry_strerror (rc));\n-    }\n-\n-    gcry_cipher_close (cipher);\n-}\n-\n-static void\n-exsltCryptoGcryptRc4Decrypt (xmlXPathParserContextPtr ctxt,\n-                 const unsigned char *key,\n-                 const unsigned char *msg, int msglen,\n-                 unsigned char *dest, int destlen) {\n-    gcry_cipher_hd_t cipher;\n-    gcry_error_t rc = 0;\n-\n-    exsltCryptoGcryptInit ();\n-\n-    rc = gcry_cipher_open (&cipher, GCRY_CIPHER_ARCFOUR,\n-               GCRY_CIPHER_MODE_STREAM, 0);\n-    if (rc) {\n-    xsltTransformError (xsltXPathGetTransformContext (ctxt), NULL,\n-                NULL,\n-                \"exslt:crypto internal error %s (gcry_cipher_open)\\n\",\n-                gcry_strerror (rc));\n-    }\n-\n-    rc = gcry_cipher_setkey (cipher, key, RC4_KEY_LENGTH);\n-    if (rc) {\n-    xsltTransformError (xsltXPathGetTransformContext (ctxt), NULL,\n-                NULL,\n-                \"exslt:crypto internal error %s (gcry_cipher_setkey)\\n\",\n-                gcry_strerror (rc));\n-    }\n-\n-    rc = gcry_cipher_decrypt (cipher, (unsigned char *) dest, destlen,\n-                  (const unsigned char *) msg, msglen);\n-    if (rc) {\n-    xsltTransformError (xsltXPathGetTransformContext (ctxt), NULL,\n-                NULL,\n-                \"exslt:crypto internal error %s (gcry_cipher_decrypt)\\n\",\n-                gcry_strerror (rc));\n-    }\n-\n-    gcry_cipher_close (cipher);\n-}\n-\n-#endif \/* defined(HAVE_GCRYPT) *\/\n-\n-#if defined(HAVE_CRYPTO)\n-\n-\/**\n- * exsltCryptoPopString:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * Helper function which checks for and returns first string argument and its\n- * length in bytes.\n- *\/\n-static int\n-exsltCryptoPopString (xmlXPathParserContextPtr ctxt, int nargs,\n-              xmlChar ** str) {\n-\n-    int str_len = 0;\n-\n-    if ((nargs < 1) || (nargs > 2)) {\n-    xmlXPathSetArityError (ctxt);\n-    return 0;\n-    }\n-\n-    *str = xmlXPathPopString (ctxt);\n-    str_len = xmlStrlen (*str);\n-\n-    if (str_len == 0) {\n-    xmlXPathReturnEmptyString (ctxt);\n-    xmlFree (*str);\n-    return 0;\n-    }\n-\n-    return str_len;\n-}\n-\n-\/**\n- * exsltCryptoMd4Function:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * computes the md4 hash of a string and returns as hex\n- *\/\n-static void\n-exsltCryptoMd4Function (xmlXPathParserContextPtr ctxt, int nargs) {\n-\n-    int str_len = 0;\n-    xmlChar *str = NULL, *ret = NULL;\n-    unsigned char hash[HASH_DIGEST_LENGTH];\n-    unsigned char hex[MD5_DIGEST_LENGTH * 2 + 1];\n-\n-    str_len = exsltCryptoPopString (ctxt, nargs, &str);\n-    if (str_len == 0)\n-    return;\n-\n-    PLATFORM_HASH (ctxt, PLATFORM_MD4, (const char *) str, str_len,\n-           (char *) hash);\n-    exsltCryptoBin2Hex (hash, sizeof (hash) - 1, hex, sizeof (hex) - 1);\n-\n-    ret = xmlStrdup ((xmlChar *) hex);\n-    xmlXPathReturnString (ctxt, ret);\n-\n-    if (str != NULL)\n-    xmlFree (str);\n-}\n-\n-\/**\n- * exsltCryptoMd5Function:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * computes the md5 hash of a string and returns as hex\n- *\/\n-static void\n-exsltCryptoMd5Function (xmlXPathParserContextPtr ctxt, int nargs) {\n-\n-    int str_len = 0;\n-    xmlChar *str = NULL, *ret = NULL;\n-    unsigned char hash[HASH_DIGEST_LENGTH];\n-    unsigned char hex[MD5_DIGEST_LENGTH * 2 + 1];\n-\n-    str_len = exsltCryptoPopString (ctxt, nargs, &str);\n-    if (str_len == 0)\n-    return;\n-\n-    PLATFORM_HASH (ctxt, PLATFORM_MD5, (const char *) str, str_len,\n-           (char *) hash);\n-    exsltCryptoBin2Hex (hash, sizeof (hash) - 1, hex, sizeof (hex) - 1);\n-\n-    ret = xmlStrdup ((xmlChar *) hex);\n-    xmlXPathReturnString (ctxt, ret);\n-\n-    if (str != NULL)\n-    xmlFree (str);\n-}\n-\n-\/**\n- * exsltCryptoSha1Function:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * computes the sha1 hash of a string and returns as hex\n- *\/\n-static void\n-exsltCryptoSha1Function (xmlXPathParserContextPtr ctxt, int nargs) {\n-\n-    int str_len = 0;\n-    xmlChar *str = NULL, *ret = NULL;\n-    unsigned char hash[HASH_DIGEST_LENGTH];\n-    unsigned char hex[SHA1_DIGEST_LENGTH * 2 + 1];\n-\n-    str_len = exsltCryptoPopString (ctxt, nargs, &str);\n-    if (str_len == 0)\n-    return;\n-\n-    PLATFORM_HASH (ctxt, PLATFORM_SHA1, (const char *) str, str_len,\n-           (char *) hash);\n-    exsltCryptoBin2Hex (hash, sizeof (hash) - 1, hex, sizeof (hex) - 1);\n-\n-    ret = xmlStrdup ((xmlChar *) hex);\n-    xmlXPathReturnString (ctxt, ret);\n-\n-    if (str != NULL)\n-    xmlFree (str);\n-}\n-\n-\/**\n- * exsltCryptoRc4EncryptFunction:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * computes the sha1 hash of a string and returns as hex\n- *\/\n-static void\n-exsltCryptoRc4EncryptFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-\n-    int key_len = 0;\n-    int str_len = 0, bin_len = 0, hex_len = 0;\n-    xmlChar *key = NULL, *str = NULL, *padkey = NULL;\n-    xmlChar *bin = NULL, *hex = NULL;\n-    xsltTransformContextPtr tctxt = NULL;\n-\n-    if (nargs != 2) {\n-    xmlXPathSetArityError (ctxt);\n-    return;\n-    }\n-    tctxt = xsltXPathGetTransformContext(ctxt);\n-\n-    str = xmlXPathPopString (ctxt);\n-    str_len = xmlStrlen (str);\n-\n-    if (str_len == 0) {\n-    xmlXPathReturnEmptyString (ctxt);\n-    xmlFree (str);\n-    return;\n-    }\n-\n-    key = xmlXPathPopString (ctxt);\n-    key_len = xmlStrlen (key);\n-\n-    if (key_len == 0) {\n-    xmlXPathReturnEmptyString (ctxt);\n-    xmlFree (key);\n-    xmlFree (str);\n-    return;\n-    }\n-\n-    padkey = xmlMallocAtomic (RC4_KEY_LENGTH + 1);\n-    if (padkey == NULL) {\n-    xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"exsltCryptoRc4EncryptFunction: Failed to allocate padkey\\n\");\n-    tctxt->state = XSLT_STATE_STOPPED;\n-    xmlXPathReturnEmptyString (ctxt);\n-    goto done;\n-    }\n-    memset(padkey, 0, RC4_KEY_LENGTH + 1);\n-\n-    if ((key_len > RC4_KEY_LENGTH) || (key_len < 0)) {\n-    xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"exsltCryptoRc4EncryptFunction: key size too long or key broken\\n\");\n-    tctxt->state = XSLT_STATE_STOPPED;\n-    xmlXPathReturnEmptyString (ctxt);\n-    goto done;\n-    }\n-    memcpy (padkey, key, key_len);\n-\n-\/* encrypt it *\/\n-    bin_len = str_len;\n-    bin = xmlStrdup (str);\n-    if (bin == NULL) {\n-    xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"exsltCryptoRc4EncryptFunction: Failed to allocate string\\n\");\n-    tctxt->state = XSLT_STATE_STOPPED;\n-    xmlXPathReturnEmptyString (ctxt);\n-    goto done;\n-    }\n-    PLATFORM_RC4_ENCRYPT (ctxt, padkey, str, str_len, bin, bin_len);\n-\n-\/* encode it *\/\n-    hex_len = str_len * 2 + 1;\n-    hex = xmlMallocAtomic (hex_len);\n-    if (hex == NULL) {\n-    xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"exsltCryptoRc4EncryptFunction: Failed to allocate result\\n\");\n-    tctxt->state = XSLT_STATE_STOPPED;\n-    xmlXPathReturnEmptyString (ctxt);\n-    goto done;\n-    }\n-\n-    exsltCryptoBin2Hex (bin, str_len, hex, hex_len);\n-    xmlXPathReturnString (ctxt, hex);\n-\n-done:\n-    if (key != NULL)\n-    xmlFree (key);\n-    if (str != NULL)\n-    xmlFree (str);\n-    if (padkey != NULL)\n-    xmlFree (padkey);\n-    if (bin != NULL)\n-    xmlFree (bin);\n-}\n-\n-\/**\n- * exsltCryptoRc4DecryptFunction:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * computes the sha1 hash of a string and returns as hex\n- *\/\n-static void\n-exsltCryptoRc4DecryptFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-\n-    int key_len = 0;\n-    int str_len = 0, bin_len = 0, ret_len = 0;\n-    xmlChar *key = NULL, *str = NULL, *padkey = NULL, *bin =\n-    NULL, *ret = NULL;\n-    xsltTransformContextPtr tctxt = NULL;\n-\n-    if (nargs != 2) {\n-    xmlXPathSetArityError (ctxt);\n-    return;\n-    }\n-    tctxt = xsltXPathGetTransformContext(ctxt);\n-\n-    str = xmlXPathPopString (ctxt);\n-    str_len = xmlStrlen (str);\n-\n-    if (str_len == 0) {\n-    xmlXPathReturnEmptyString (ctxt);\n-    xmlFree (str);\n-    return;\n-    }\n-\n-    key = xmlXPathPopString (ctxt);\n-    key_len = xmlStrlen (key);\n-\n-    if (key_len == 0) {\n-    xmlXPathReturnEmptyString (ctxt);\n-    xmlFree (key);\n-    xmlFree (str);\n-    return;\n-    }\n-\n-    padkey = xmlMallocAtomic (RC4_KEY_LENGTH + 1);\n-    if (padkey == NULL) {\n-    xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"exsltCryptoRc4EncryptFunction: Failed to allocate padkey\\n\");\n-    tctxt->state = XSLT_STATE_STOPPED;\n-    xmlXPathReturnEmptyString (ctxt);\n-    goto done;\n-    }\n-    memset(padkey, 0, RC4_KEY_LENGTH + 1);\n-    if ((key_len > RC4_KEY_LENGTH) || (key_len < 0)) {\n-    xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"exsltCryptoRc4EncryptFunction: key size too long or key broken\\n\");\n-    tctxt->state = XSLT_STATE_STOPPED;\n-    xmlXPathReturnEmptyString (ctxt);\n-    goto done;\n-    }\n-    memcpy (padkey, key, key_len);\n-\n-\/* decode hex to binary *\/\n-    bin_len = str_len;\n-    bin = xmlMallocAtomic (bin_len);\n-    if (bin == NULL) {\n-    xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"exsltCryptoRc4EncryptFunction: Failed to allocate string\\n\");\n-    tctxt->state = XSLT_STATE_STOPPED;\n-    xmlXPathReturnEmptyString (ctxt);\n-    goto done;\n-    }\n-    ret_len = exsltCryptoHex2Bin (str, str_len, bin, bin_len);\n-\n-\/* decrypt the binary blob *\/\n-    ret = xmlMallocAtomic (ret_len + 1);\n-    if (ret == NULL) {\n-    xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"exsltCryptoRc4EncryptFunction: Failed to allocate result\\n\");\n-    tctxt->state = XSLT_STATE_STOPPED;\n-    xmlXPathReturnEmptyString (ctxt);\n-    goto done;\n-    }\n-    PLATFORM_RC4_DECRYPT (ctxt, padkey, bin, ret_len, ret, ret_len);\n-    ret[ret_len] = 0;\n-\n-    if (xmlCheckUTF8(ret) == 0) {\n-    xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"exsltCryptoRc4DecryptFunction: Invalid UTF-8\\n\");\n-        xmlFree(ret);\n-    xmlXPathReturnEmptyString(ctxt);\n-    } else {\n-        xmlXPathReturnString(ctxt, ret);\n-    }\n-\n-done:\n-    if (key != NULL)\n-    xmlFree (key);\n-    if (str != NULL)\n-    xmlFree (str);\n-    if (padkey != NULL)\n-    xmlFree (padkey);\n-    if (bin != NULL)\n-    xmlFree (bin);\n-}\n-\n-\/**\n- * exsltCryptoRegister:\n- *\n- * Registers the EXSLT - Crypto module\n- *\/\n-\n-void\n-exsltCryptoRegister (void) {\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"md4\",\n-                   EXSLT_CRYPTO_NAMESPACE,\n-                   exsltCryptoMd4Function);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"md5\",\n-                   EXSLT_CRYPTO_NAMESPACE,\n-                   exsltCryptoMd5Function);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"sha1\",\n-                   EXSLT_CRYPTO_NAMESPACE,\n-                   exsltCryptoSha1Function);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"rc4_encrypt\",\n-                   EXSLT_CRYPTO_NAMESPACE,\n-                   exsltCryptoRc4EncryptFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"rc4_decrypt\",\n-                   EXSLT_CRYPTO_NAMESPACE,\n-                   exsltCryptoRc4DecryptFunction);\n-}\n-\n-#else\n-\/**\n- * exsltCryptoRegister:\n- *\n- * Registers the EXSLT - Crypto module\n- *\/\n-void\n-exsltCryptoRegister (void) {\n-}\n-\n-#endif \/* defined(HAVE_CRYPTO) *\/\n-\n-#endif \/* EXSLT_CRYPTO_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/crypto.c","additions":0,"deletions":806,"binary":false,"changes":806,"status":"deleted"},{"patch":"@@ -1,3956 +0,0 @@\n-\/*\n- * date.c: Implementation of the EXSLT -- Dates and Times module\n- *\n- * References:\n- *   http:\/\/www.exslt.org\/date\/date.html\n- *\n- * See Copyright for the status of this software.\n- *\n- * Authors:\n- *   Charlie Bozeman <cbozeman@HiWAAY.net>\n- *   Thomas Broyer <tbroyer@ltgt.net>\n- *\n- * TODO:\n- * elements:\n- *   date-format\n- * functions:\n- *   format-date\n- *   parse-date\n- *   sum\n- *\/\n-\n-#define IN_LIBEXSLT\n-#include \"libexslt\/libexslt.h\"\n-\n-#if defined(HAVE_LOCALTIME_R) && defined(__GLIBC__)    \/* _POSIX_SOURCE required by gnu libc *\/\n-#ifndef _AIX51        \/* but on AIX we're not using gnu libc *\/\n-#define _POSIX_SOURCE\n-#endif\n-#endif\n-\n-#include <libxml\/tree.h>\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-\n-#include <libxslt\/xsltutils.h>\n-#include <libxslt\/xsltInternals.h>\n-#include <libxslt\/extensions.h>\n-\n-#include \"exslt.h\"\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include <limits.h>\n-#include <errno.h>\n-#include <math.h>\n-\n-\/* needed to get localtime_r on Solaris *\/\n-#ifdef __sun\n-#ifndef __EXTENSIONS__\n-#define __EXTENSIONS__\n-#endif\n-#endif\n-\n-#include <time.h>\n-\n-#if defined(_MSC_VER) && _MSC_VER >= 1400 || \\\n-    defined(_WIN32) && \\\n-    defined(__MINGW64_VERSION_MAJOR) && __MINGW64_VERSION_MAJOR >= 4\n-  #define HAVE_MSVCRT\n-#endif\n-\n-\/*\n- * types of date and\/or time (from schema datatypes)\n- *   somewhat ordered from least specific to most specific (i.e.\n- *   most truncated to least truncated).\n- *\/\n-typedef enum {\n-    EXSLT_UNKNOWN  =    0,\n-    XS_TIME        =    1,       \/* time is left-truncated *\/\n-    XS_GDAY        = (XS_TIME   << 1),\n-    XS_GMONTH      = (XS_GDAY   << 1),\n-    XS_GMONTHDAY   = (XS_GMONTH | XS_GDAY),\n-    XS_GYEAR       = (XS_GMONTH << 1),\n-    XS_GYEARMONTH  = (XS_GYEAR  | XS_GMONTH),\n-    XS_DATE        = (XS_GYEAR  | XS_GMONTH | XS_GDAY),\n-    XS_DATETIME    = (XS_DATE   | XS_TIME)\n-} exsltDateType;\n-\n-\/* Date value *\/\n-typedef struct _exsltDateVal exsltDateVal;\n-typedef exsltDateVal *exsltDateValPtr;\n-struct _exsltDateVal {\n-    exsltDateType    type;\n-    long        year;\n-    unsigned int    mon    :4;    \/* 1 <=  mon    <= 12   *\/\n-    unsigned int    day    :5;    \/* 1 <=  day    <= 31   *\/\n-    unsigned int    hour    :5;    \/* 0 <=  hour   <= 23   *\/\n-    unsigned int    min    :6;    \/* 0 <=  min    <= 59    *\/\n-    double        sec;\n-    unsigned int    tz_flag    :1;    \/* is tzo explicitely set? *\/\n-    signed int        tzo    :12;    \/* -1440 <= tzo <= 1440 currently only -840 to +840 are needed *\/\n-};\n-\n-\/* Duration value *\/\n-typedef struct _exsltDateDurVal exsltDateDurVal;\n-typedef exsltDateDurVal *exsltDateDurValPtr;\n-struct _exsltDateDurVal {\n-    long    mon;    \/* mon stores years also *\/\n-    long    day;\n-    double    sec;    \/* sec stores min and hour also\n-               0 <= sec < SECS_PER_DAY *\/\n-};\n-\n-\/****************************************************************\n- *                                *\n- *        Convenience macros and functions        *\n- *                                *\n- ****************************************************************\/\n-\n-#define IS_TZO_CHAR(c)                        \\\n-    ((c == 0) || (c == 'Z') || (c == '+') || (c == '-'))\n-\n-#define VALID_ALWAYS(num)    (num >= 0)\n-#define VALID_MONTH(mon)        ((mon >= 1) && (mon <= 12))\n-\/* VALID_DAY should only be used when month is unknown *\/\n-#define VALID_DAY(day)          ((day >= 1) && (day <= 31))\n-#define VALID_HOUR(hr)          ((hr >= 0) && (hr <= 23))\n-#define VALID_MIN(min)          ((min >= 0) && (min <= 59))\n-#define VALID_SEC(sec)          ((sec >= 0) && (sec < 60))\n-#define VALID_TZO(tzo)          ((tzo > -1440) && (tzo < 1440))\n-#define IS_LEAP(y)                        \\\n-    (((y & 3) == 0) && ((y % 25 != 0) || ((y & 15) == 0)))\n-\n-static const long daysInMonth[12] =\n-    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n-static const long daysInMonthLeap[12] =\n-    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n-\n-#define MAX_DAYINMONTH(yr,mon)                                  \\\n-        (IS_LEAP(yr) ? daysInMonthLeap[mon - 1] : daysInMonth[mon - 1])\n-\n-#define VALID_MDAY(dt)                        \\\n-    (IS_LEAP(dt->year) ?                        \\\n-        (dt->day <= daysInMonthLeap[dt->mon - 1]) :            \\\n-        (dt->day <= daysInMonth[dt->mon - 1]))\n-\n-#define VALID_DATE(dt)                        \\\n-    (VALID_MONTH(dt->mon) && VALID_MDAY(dt))\n-\n-\/*\n-    hour and min structure vals are unsigned, so normal macros give\n-    warnings on some compilers.\n-*\/\n-#define VALID_TIME(dt)                        \\\n-    ((dt->hour <=23 ) && (dt->min <= 59) &&            \\\n-     VALID_SEC(dt->sec) && VALID_TZO(dt->tzo))\n-\n-#define VALID_DATETIME(dt)                    \\\n-    (VALID_DATE(dt) && VALID_TIME(dt))\n-\n-#define SECS_PER_MIN            60\n-#define MINS_PER_HOUR           60\n-#define HOURS_PER_DAY           24\n-#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)\n-#define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)\n-#define MINS_PER_DAY            (HOURS_PER_DAY * MINS_PER_HOUR)\n-#define DAYS_PER_EPOCH          (400 * 365 + 100 - 4 + 1)\n-#define YEARS_PER_EPOCH         400\n-\n-static const long dayInYearByMonth[12] =\n-    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };\n-static const long dayInLeapYearByMonth[12] =\n-    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335 };\n-\n-#define DAY_IN_YEAR(day, month, year)                \\\n-        ((IS_LEAP(year) ?                    \\\n-                dayInLeapYearByMonth[month - 1] :        \\\n-                dayInYearByMonth[month - 1]) + day)\n-\n-#define YEAR_MAX LONG_MAX\n-#define YEAR_MIN (-LONG_MAX + 1)\n-\n-\/**\n- * _exsltDateParseGYear:\n- * @dt:  pointer to a date structure\n- * @str: pointer to the string to analyze\n- *\n- * Parses a xs:gYear without time zone and fills in the appropriate\n- * field of the @dt structure. @str is updated to point just after the\n- * xs:gYear. It is supposed that @dt->year is big enough to contain\n- * the year.\n- *\n- * According to XML Schema Part 2, the year \"0000\" is an illegal year value\n- * which probably means that the year preceding AD 1 is BC 1. Internally,\n- * we allow a year 0 and adjust the value when parsing and formatting.\n- *\n- * Returns 0 or the error code\n- *\/\n-static int\n-_exsltDateParseGYear (exsltDateValPtr dt, const xmlChar **str)\n-{\n-    const xmlChar *cur = *str, *firstChar;\n-    int isneg = 0, digcnt = 0;\n-\n-    if (((*cur < '0') || (*cur > '9')) &&\n-    (*cur != '-') && (*cur != '+'))\n-    return -1;\n-\n-    if (*cur == '-') {\n-    isneg = 1;\n-    cur++;\n-    }\n-\n-    firstChar = cur;\n-\n-    while ((*cur >= '0') && (*cur <= '9')) {\n-        if (dt->year >= YEAR_MAX \/ 10) \/* Not really exact *\/\n-            return -1;\n-    dt->year = dt->year * 10 + (*cur - '0');\n-    cur++;\n-    digcnt++;\n-    }\n-\n-    \/* year must be at least 4 digits (CCYY); over 4\n-     * digits cannot have a leading zero. *\/\n-    if ((digcnt < 4) || ((digcnt > 4) && (*firstChar == '0')))\n-    return 1;\n-\n-    if (dt->year == 0)\n-    return 2;\n-\n-    \/* The internal representation of negative years is continuous. *\/\n-    if (isneg)\n-    dt->year = -dt->year + 1;\n-\n-    *str = cur;\n-\n-#ifdef DEBUG_EXSLT_DATE\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"Parsed year %04ld\\n\", dt->year);\n-#endif\n-\n-    return 0;\n-}\n-\n-\/**\n- * exsltFormatGYear:\n- * @cur: a pointer to a pointer to an allocated buffer\n- * @end: a pointer to the end of @cur buffer\n- * @yr:  the year to format\n- *\n- * Formats @yr in xsl:gYear format. Result is appended to @cur and\n- * @cur is updated to point after the xsl:gYear.\n- *\/\n-static void\n-exsltFormatGYear(xmlChar **cur, xmlChar *end, long yr)\n-{\n-    long year;\n-    xmlChar tmp_buf[100], *tmp = tmp_buf, *tmp_end = tmp_buf + 99;\n-\n-    if (yr <= 0 && *cur < end) {\n-        *(*cur)++ = '-';\n-    }\n-\n-    year = (yr <= 0) ? -yr + 1 : yr;\n-    \/* result is in reverse-order *\/\n-    while (year > 0 && tmp < tmp_end) {\n-        *tmp++ = '0' + (xmlChar)(year % 10);\n-        year \/= 10;\n-    }\n-\n-    \/* virtually adds leading zeros *\/\n-    while ((tmp - tmp_buf) < 4)\n-        *tmp++ = '0';\n-\n-    \/* restore the correct order *\/\n-    while (tmp > tmp_buf && *cur < end) {\n-        tmp--;\n-        *(*cur)++ = *tmp;\n-    }\n-}\n-\n-\/**\n- * PARSE_2_DIGITS:\n- * @num:  the integer to fill in\n- * @cur:  an #xmlChar *\n- * @func: validation function for the number\n- * @invalid: an integer\n- *\n- * Parses a 2-digits integer and updates @num with the value. @cur is\n- * updated to point just after the integer.\n- * In case of error, @invalid is set to %TRUE, values of @num and\n- * @cur are undefined.\n- *\/\n-#define PARSE_2_DIGITS(num, cur, func, invalid)            \\\n-    if ((cur[0] < '0') || (cur[0] > '9') ||            \\\n-        (cur[1] < '0') || (cur[1] > '9'))            \\\n-        invalid = 1;                    \\\n-    else {                            \\\n-        int val;                        \\\n-        val = (cur[0] - '0') * 10 + (cur[1] - '0');        \\\n-        if (!func(val))                    \\\n-            invalid = 2;                    \\\n-        else                        \\\n-            num = val;                    \\\n-    }                            \\\n-    cur += 2;\n-\n-\/**\n- * exsltFormat2Digits:\n- * @cur: a pointer to a pointer to an allocated buffer\n- * @end: a pointer to the end of @cur buffer\n- * @num: the integer to format\n- *\n- * Formats a 2-digits integer. Result is appended to @cur and\n- * @cur is updated to point after the integer.\n- *\/\n-static void\n-exsltFormat2Digits(xmlChar **cur, xmlChar *end, unsigned int num)\n-{\n-    if (*cur < end)\n-        *(*cur)++ = '0' + ((num \/ 10) % 10);\n-    if (*cur < end)\n-        *(*cur)++ = '0' + (num % 10);\n-}\n-\n-\/**\n- * PARSE_FLOAT:\n- * @num:  the double to fill in\n- * @cur:  an #xmlChar *\n- * @invalid: an integer\n- *\n- * Parses a float and updates @num with the value. @cur is\n- * updated to point just after the float. The float must have a\n- * 2-digits integer part and may or may not have a decimal part.\n- * In case of error, @invalid is set to %TRUE, values of @num and\n- * @cur are undefined.\n- *\/\n-#define PARSE_FLOAT(num, cur, invalid)                \\\n-    PARSE_2_DIGITS(num, cur, VALID_ALWAYS, invalid);    \\\n-    if (!invalid && (*cur == '.')) {            \\\n-        double mult = 1;                        \\\n-        cur++;                        \\\n-        if ((*cur < '0') || (*cur > '9'))            \\\n-        invalid = 1;                    \\\n-        while ((*cur >= '0') && (*cur <= '9')) {        \\\n-        mult \/= 10;                    \\\n-        num += (*cur - '0') * mult;            \\\n-        cur++;                        \\\n-        }                            \\\n-    }\n-\n-\/**\n- * _exsltDateParseGMonth:\n- * @dt:  pointer to a date structure\n- * @str: pointer to the string to analyze\n- *\n- * Parses a xs:gMonth without time zone and fills in the appropriate\n- * field of the @dt structure. @str is updated to point just after the\n- * xs:gMonth.\n- *\n- * Returns 0 or the error code\n- *\/\n-static int\n-_exsltDateParseGMonth (exsltDateValPtr dt, const xmlChar **str)\n-{\n-    const xmlChar *cur = *str;\n-    int ret = 0;\n-\n-    PARSE_2_DIGITS(dt->mon, cur, VALID_MONTH, ret);\n-    if (ret != 0)\n-    return ret;\n-\n-    *str = cur;\n-\n-#ifdef DEBUG_EXSLT_DATE\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"Parsed month %02i\\n\", dt->mon);\n-#endif\n-\n-    return 0;\n-}\n-\n-\/**\n- * _exsltDateParseGDay:\n- * @dt:  pointer to a date structure\n- * @str: pointer to the string to analyze\n- *\n- * Parses a xs:gDay without time zone and fills in the appropriate\n- * field of the @dt structure. @str is updated to point just after the\n- * xs:gDay.\n- *\n- * Returns 0 or the error code\n- *\/\n-static int\n-_exsltDateParseGDay (exsltDateValPtr dt, const xmlChar **str)\n-{\n-    const xmlChar *cur = *str;\n-    int ret = 0;\n-\n-    PARSE_2_DIGITS(dt->day, cur, VALID_DAY, ret);\n-    if (ret != 0)\n-    return ret;\n-\n-    *str = cur;\n-\n-#ifdef DEBUG_EXSLT_DATE\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"Parsed day %02i\\n\", dt->day);\n-#endif\n-\n-    return 0;\n-}\n-\n-\/**\n- * exsltFormatYearMonthDay:\n- * @cur: a pointer to a pointer to an allocated buffer\n- * @end: a pointer to the end of @cur buffer\n- * @dt:  the #exsltDateVal to format\n- *\n- * Formats @dt in xsl:date format. Result is appended to @cur and\n- * @cur is updated to point after the xsl:date.\n- *\/\n-static void\n-exsltFormatYearMonthDay(xmlChar **cur, xmlChar *end, const exsltDateValPtr dt)\n-{\n-    exsltFormatGYear(cur, end, dt->year);\n-    if (*cur < end)\n-        *(*cur)++ = '-';\n-    exsltFormat2Digits(cur, end, dt->mon);\n-    if (*cur < end)\n-        *(*cur)++ = '-';\n-    exsltFormat2Digits(cur, end, dt->day);\n-}\n-\n-\/**\n- * _exsltDateParseTime:\n- * @dt:  pointer to a date structure\n- * @str: pointer to the string to analyze\n- *\n- * Parses a xs:time without time zone and fills in the appropriate\n- * fields of the @dt structure. @str is updated to point just after the\n- * xs:time.\n- * In case of error, values of @dt fields are undefined.\n- *\n- * Returns 0 or the error code\n- *\/\n-static int\n-_exsltDateParseTime (exsltDateValPtr dt, const xmlChar **str)\n-{\n-    const xmlChar *cur = *str;\n-    unsigned int hour = 0; \/* use temp var in case str is not xs:time *\/\n-    int ret = 0;\n-\n-    PARSE_2_DIGITS(hour, cur, VALID_HOUR, ret);\n-    if (ret != 0)\n-    return ret;\n-\n-    if (*cur != ':')\n-    return 1;\n-    cur++;\n-\n-    \/* the ':' insures this string is xs:time *\/\n-    dt->hour = hour;\n-\n-    PARSE_2_DIGITS(dt->min, cur, VALID_MIN, ret);\n-    if (ret != 0)\n-    return ret;\n-\n-    if (*cur != ':')\n-    return 1;\n-    cur++;\n-\n-    PARSE_FLOAT(dt->sec, cur, ret);\n-    if (ret != 0)\n-    return ret;\n-\n-    if (!VALID_TIME(dt))\n-    return 2;\n-\n-    *str = cur;\n-\n-#ifdef DEBUG_EXSLT_DATE\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"Parsed time %02i:%02i:%02.f\\n\",\n-             dt->hour, dt->min, dt->sec);\n-#endif\n-\n-    return 0;\n-}\n-\n-\/**\n- * _exsltDateParseTimeZone:\n- * @dt:  pointer to a date structure\n- * @str: pointer to the string to analyze\n- *\n- * Parses a time zone without time zone and fills in the appropriate\n- * field of the @dt structure. @str is updated to point just after the\n- * time zone.\n- *\n- * Returns 0 or the error code\n- *\/\n-static int\n-_exsltDateParseTimeZone (exsltDateValPtr dt, const xmlChar **str)\n-{\n-    const xmlChar *cur;\n-    int ret = 0;\n-\n-    if (str == NULL)\n-    return -1;\n-    cur = *str;\n-    switch (*cur) {\n-    case 0:\n-    dt->tz_flag = 0;\n-    dt->tzo = 0;\n-    break;\n-\n-    case 'Z':\n-    dt->tz_flag = 1;\n-    dt->tzo = 0;\n-    cur++;\n-    break;\n-\n-    case '+':\n-    case '-': {\n-    int isneg = 0, tmp = 0;\n-    isneg = (*cur == '-');\n-\n-    cur++;\n-\n-    PARSE_2_DIGITS(tmp, cur, VALID_HOUR, ret);\n-    if (ret != 0)\n-        return ret;\n-\n-    if (*cur != ':')\n-        return 1;\n-    cur++;\n-\n-    dt->tzo = tmp * 60;\n-\n-    PARSE_2_DIGITS(tmp, cur, VALID_MIN, ret);\n-    if (ret != 0)\n-        return ret;\n-\n-    dt->tzo += tmp;\n-    if (isneg)\n-        dt->tzo = - dt->tzo;\n-\n-    if (!VALID_TZO(dt->tzo))\n-        return 2;\n-\n-    break;\n-      }\n-    default:\n-    return 1;\n-    }\n-\n-    *str = cur;\n-\n-#ifdef DEBUG_EXSLT_DATE\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"Parsed time zone offset (%s) %i\\n\",\n-             dt->tz_flag ? \"explicit\" : \"implicit\", dt->tzo);\n-#endif\n-\n-    return 0;\n-}\n-\n-\/**\n- * exsltFormatTimeZone:\n- * @cur: a pointer to a pointer to an allocated buffer\n- * @end: a pointer to the end of @cur buffer\n- * @tzo: the timezone offset to format\n- *\n- * Formats @tzo timezone. Result is appended to @cur and\n- * @cur is updated to point after the timezone.\n- *\/\n-static void\n-exsltFormatTimeZone(xmlChar **cur, xmlChar *end, int tzo)\n-{\n-    if (tzo == 0) {\n-        if (*cur < end)\n-            *(*cur)++ = 'Z';\n-    } else {\n-        unsigned int aTzo = (tzo < 0) ? -tzo : tzo;\n-        unsigned int tzHh = aTzo \/ 60, tzMm = aTzo % 60;\n-        if (*cur < end)\n-            *(*cur)++ = (tzo < 0) ? '-' : '+';\n-        exsltFormat2Digits(cur, end, tzHh);\n-        if (*cur < end)\n-            *(*cur)++ = ':';\n-        exsltFormat2Digits(cur, end, tzMm);\n-    }\n-}\n-\n-\/****************************************************************\n- *                                *\n- *    XML Schema Dates\/Times Datatypes Handling        *\n- *                                *\n- ****************************************************************\/\n-\n-\/**\n- * exsltDateCreateDate:\n- * @type:       type to create\n- *\n- * Creates a new #exsltDateVal, uninitialized.\n- *\n- * Returns the #exsltDateValPtr\n- *\/\n-static exsltDateValPtr\n-exsltDateCreateDate (exsltDateType type)\n-{\n-    exsltDateValPtr ret;\n-\n-    ret = (exsltDateValPtr) xmlMalloc(sizeof(exsltDateVal));\n-    if (ret == NULL) {\n-    xsltGenericError(xsltGenericErrorContext,\n-             \"exsltDateCreateDate: out of memory\\n\");\n-    return (NULL);\n-    }\n-    memset (ret, 0, sizeof(exsltDateVal));\n-\n-    ret->mon = 1;\n-    ret->day = 1;\n-\n-    if (type != EXSLT_UNKNOWN)\n-        ret->type = type;\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateFreeDate:\n- * @date: an #exsltDateValPtr\n- *\n- * Frees up the @date\n- *\/\n-static void\n-exsltDateFreeDate (exsltDateValPtr date) {\n-    if (date == NULL)\n-    return;\n-\n-    xmlFree(date);\n-}\n-\n-\/**\n- * exsltDateCreateDuration:\n- *\n- * Creates a new #exsltDateDurVal, uninitialized.\n- *\n- * Returns the #exsltDateDurValPtr\n- *\/\n-static exsltDateDurValPtr\n-exsltDateCreateDuration (void)\n-{\n-    exsltDateDurValPtr ret;\n-\n-    ret = (exsltDateDurValPtr) xmlMalloc(sizeof(exsltDateDurVal));\n-    if (ret == NULL) {\n-    xsltGenericError(xsltGenericErrorContext,\n-             \"exsltDateCreateDuration: out of memory\\n\");\n-    return (NULL);\n-    }\n-    memset (ret, 0, sizeof(exsltDateDurVal));\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateFreeDuration:\n- * @date: an #exsltDateDurValPtr\n- *\n- * Frees up the @duration\n- *\/\n-static void\n-exsltDateFreeDuration (exsltDateDurValPtr duration) {\n-    if (duration == NULL)\n-    return;\n-\n-    xmlFree(duration);\n-}\n-\n-\/**\n- * exsltDateCurrent:\n- *\n- * Returns the current date and time.\n- *\/\n-static exsltDateValPtr\n-exsltDateCurrent (void)\n-{\n-    struct tm localTm, gmTm;\n-#if !defined(HAVE_GMTIME_R) && !defined(HAVE_MSVCRT)\n-    struct tm *tb = NULL;\n-#endif\n-    time_t secs;\n-    int local_s, gm_s;\n-    exsltDateValPtr ret;\n-    char *source_date_epoch;\n-    int override = 0;\n-\n-    ret = exsltDateCreateDate(XS_DATETIME);\n-    if (ret == NULL)\n-        return NULL;\n-\n-    \/*\n-     * Allow the date and time to be set externally by an exported\n-     * environment variable to enable reproducible builds.\n-     *\/\n-    source_date_epoch = getenv(\"SOURCE_DATE_EPOCH\");\n-    if (source_date_epoch) {\n-        errno = 0;\n-    secs = (time_t) strtol (source_date_epoch, NULL, 10);\n-    if (errno == 0) {\n-#ifdef HAVE_MSVCRT\n-        struct tm *gm = gmtime_s(&localTm, &secs) ? NULL : &localTm;\n-        if (gm != NULL)\n-            override = 1;\n-#elif HAVE_GMTIME_R\n-        if (gmtime_r(&secs, &localTm) != NULL)\n-            override = 1;\n-#else\n-        tb = gmtime(&secs);\n-        if (tb != NULL) {\n-            localTm = *tb;\n-        override = 1;\n-        }\n-#endif\n-        }\n-    }\n-\n-    if (override == 0) {\n-    \/* get current time *\/\n-    secs    = time(NULL);\n-\n-#ifdef HAVE_MSVCRT\n-    localtime_s(&localTm, &secs);\n-#elif HAVE_LOCALTIME_R\n-    localtime_r(&secs, &localTm);\n-#else\n-    localTm = *localtime(&secs);\n-#endif\n-    }\n-\n-    \/* get real year, not years since 1900 *\/\n-    ret->year = localTm.tm_year + 1900;\n-\n-    ret->mon  = localTm.tm_mon + 1;\n-    ret->day  = localTm.tm_mday;\n-    ret->hour = localTm.tm_hour;\n-    ret->min  = localTm.tm_min;\n-\n-    \/* floating point seconds *\/\n-    ret->sec  = (double) localTm.tm_sec;\n-\n-    \/* determine the time zone offset from local to gm time *\/\n-#ifdef HAVE_MSVCRT\n-    gmtime_s(&gmTm, &secs);\n-#elif HAVE_GMTIME_R\n-    gmtime_r(&secs, &gmTm);\n-#else\n-    tb = gmtime(&secs);\n-    if (tb == NULL)\n-        return NULL;\n-    gmTm = *tb;\n-#endif\n-    ret->tz_flag = 0;\n-#if 0\n-    ret->tzo = (((ret->day * 1440) +\n-                 (ret->hour * 60) +\n-                  ret->min) -\n-                ((gmTm.tm_mday * 1440) + (gmTm.tm_hour * 60) +\n-                  gmTm.tm_min));\n-#endif\n-    local_s = localTm.tm_hour * SECS_PER_HOUR +\n-        localTm.tm_min * SECS_PER_MIN +\n-        localTm.tm_sec;\n-\n-    gm_s = gmTm.tm_hour * SECS_PER_HOUR +\n-        gmTm.tm_min * SECS_PER_MIN +\n-        gmTm.tm_sec;\n-\n-    if (localTm.tm_year < gmTm.tm_year) {\n-    ret->tzo = -((SECS_PER_DAY - local_s) + gm_s)\/60;\n-    } else if (localTm.tm_year > gmTm.tm_year) {\n-    ret->tzo = ((SECS_PER_DAY - gm_s) + local_s)\/60;\n-    } else if (localTm.tm_mon < gmTm.tm_mon) {\n-    ret->tzo = -((SECS_PER_DAY - local_s) + gm_s)\/60;\n-    } else if (localTm.tm_mon > gmTm.tm_mon) {\n-    ret->tzo = ((SECS_PER_DAY - gm_s) + local_s)\/60;\n-    } else if (localTm.tm_mday < gmTm.tm_mday) {\n-    ret->tzo = -((SECS_PER_DAY - local_s) + gm_s)\/60;\n-    } else if (localTm.tm_mday > gmTm.tm_mday) {\n-    ret->tzo = ((SECS_PER_DAY - gm_s) + local_s)\/60;\n-    } else  {\n-    ret->tzo = (local_s - gm_s)\/60;\n-    }\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateParse:\n- * @dateTime:  string to analyze\n- *\n- * Parses a date\/time string\n- *\n- * Returns a newly built #exsltDateValPtr of NULL in case of error\n- *\/\n-static exsltDateValPtr\n-exsltDateParse (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt;\n-    int ret;\n-    const xmlChar *cur = dateTime;\n-\n-#define RETURN_TYPE_IF_VALID(t)                    \\\n-    if (IS_TZO_CHAR(*cur)) {                    \\\n-    ret = _exsltDateParseTimeZone(dt, &cur);        \\\n-    if (ret == 0) {                        \\\n-        if (*cur != 0)                    \\\n-        goto error;                    \\\n-        dt->type = t;                    \\\n-        return dt;                        \\\n-    }                            \\\n-    }\n-\n-    if (dateTime == NULL)\n-    return NULL;\n-\n-    if ((*cur != '-') && (*cur < '0') && (*cur > '9'))\n-    return NULL;\n-\n-    dt = exsltDateCreateDate(EXSLT_UNKNOWN);\n-    if (dt == NULL)\n-    return NULL;\n-\n-    if ((cur[0] == '-') && (cur[1] == '-')) {\n-    \/*\n-     * It's an incomplete date (xs:gMonthDay, xs:gMonth or\n-     * xs:gDay)\n-     *\/\n-    cur += 2;\n-\n-    \/* is it an xs:gDay? *\/\n-    if (*cur == '-') {\n-      ++cur;\n-        ret = _exsltDateParseGDay(dt, &cur);\n-        if (ret != 0)\n-        goto error;\n-\n-        RETURN_TYPE_IF_VALID(XS_GDAY);\n-\n-        goto error;\n-    }\n-\n-    \/*\n-     * it should be an xs:gMonthDay or xs:gMonth\n-     *\/\n-    ret = _exsltDateParseGMonth(dt, &cur);\n-    if (ret != 0)\n-        goto error;\n-\n-    if (*cur != '-')\n-        goto error;\n-    cur++;\n-\n-    \/* is it an xs:gMonth? *\/\n-    if (*cur == '-') {\n-        cur++;\n-        RETURN_TYPE_IF_VALID(XS_GMONTH);\n-        goto error;\n-    }\n-\n-    \/* it should be an xs:gMonthDay *\/\n-    ret = _exsltDateParseGDay(dt, &cur);\n-    if (ret != 0)\n-        goto error;\n-\n-    RETURN_TYPE_IF_VALID(XS_GMONTHDAY);\n-\n-    goto error;\n-    }\n-\n-    \/*\n-     * It's a right-truncated date or an xs:time.\n-     * Try to parse an xs:time then fallback on right-truncated dates.\n-     *\/\n-    if ((*cur >= '0') && (*cur <= '9')) {\n-    ret = _exsltDateParseTime(dt, &cur);\n-    if (ret == 0) {\n-        \/* it's an xs:time *\/\n-        RETURN_TYPE_IF_VALID(XS_TIME);\n-    }\n-    }\n-\n-    \/* fallback on date parsing *\/\n-    cur = dateTime;\n-\n-    ret = _exsltDateParseGYear(dt, &cur);\n-    if (ret != 0)\n-    goto error;\n-\n-    \/* is it an xs:gYear? *\/\n-    RETURN_TYPE_IF_VALID(XS_GYEAR);\n-\n-    if (*cur != '-')\n-    goto error;\n-    cur++;\n-\n-    ret = _exsltDateParseGMonth(dt, &cur);\n-    if (ret != 0)\n-    goto error;\n-\n-    \/* is it an xs:gYearMonth? *\/\n-    RETURN_TYPE_IF_VALID(XS_GYEARMONTH);\n-\n-    if (*cur != '-')\n-    goto error;\n-    cur++;\n-\n-    ret = _exsltDateParseGDay(dt, &cur);\n-    if ((ret != 0) || !VALID_DATE(dt))\n-    goto error;\n-\n-    \/* is it an xs:date? *\/\n-    RETURN_TYPE_IF_VALID(XS_DATE);\n-\n-    if (*cur != 'T')\n-    goto error;\n-    cur++;\n-\n-    \/* it should be an xs:dateTime *\/\n-    ret = _exsltDateParseTime(dt, &cur);\n-    if (ret != 0)\n-    goto error;\n-\n-    ret = _exsltDateParseTimeZone(dt, &cur);\n-    if ((ret != 0) || (*cur != 0) || !VALID_DATETIME(dt))\n-    goto error;\n-\n-    dt->type = XS_DATETIME;\n-\n-    return dt;\n-\n-error:\n-    if (dt != NULL)\n-    exsltDateFreeDate(dt);\n-    return NULL;\n-}\n-\n-\/**\n- * exsltDateParseDuration:\n- * @duration:  string to analyze\n- *\n- * Parses a duration string\n- *\n- * Returns a newly built #exsltDateDurValPtr of NULL in case of error\n- *\/\n-static exsltDateDurValPtr\n-exsltDateParseDuration (const xmlChar *duration)\n-{\n-    const xmlChar  *cur = duration;\n-    exsltDateDurValPtr dur;\n-    int isneg = 0;\n-    unsigned int seq = 0;\n-    long days, secs = 0;\n-    double sec_frac = 0.0;\n-\n-    if (duration == NULL)\n-    return NULL;\n-\n-    if (*cur == '-') {\n-        isneg = 1;\n-        cur++;\n-    }\n-\n-    \/* duration must start with 'P' (after sign) *\/\n-    if (*cur++ != 'P')\n-    return NULL;\n-\n-    if (*cur == 0)\n-    return NULL;\n-\n-    dur = exsltDateCreateDuration();\n-    if (dur == NULL)\n-    return NULL;\n-\n-    while (*cur != 0) {\n-        long           num = 0;\n-        size_t         has_digits = 0;\n-        int            has_frac = 0;\n-        const xmlChar  desig[] = {'Y', 'M', 'D', 'H', 'M', 'S'};\n-\n-        \/* input string should be empty or invalid date\/time item *\/\n-        if (seq >= sizeof(desig))\n-            goto error;\n-\n-        \/* T designator must be present for time items *\/\n-        if (*cur == 'T') {\n-            if (seq > 3)\n-                goto error;\n-            cur++;\n-            seq = 3;\n-        } else if (seq == 3)\n-            goto error;\n-\n-        \/* Parse integral part. *\/\n-        while (*cur >= '0' && *cur <= '9') {\n-            long digit = *cur - '0';\n-\n-            if (num > LONG_MAX \/ 10)\n-                goto error;\n-            num *= 10;\n-            if (num > LONG_MAX - digit)\n-                goto error;\n-            num += digit;\n-\n-            has_digits = 1;\n-            cur++;\n-        }\n-\n-        if (*cur == '.') {\n-            \/* Parse fractional part. *\/\n-            double mult = 1.0;\n-            cur++;\n-            has_frac = 1;\n-            while (*cur >= '0' && *cur <= '9') {\n-                mult \/= 10.0;\n-                sec_frac += (*cur - '0') * mult;\n-                has_digits = 1;\n-                cur++;\n-            }\n-        }\n-\n-        while (*cur != desig[seq]) {\n-            seq++;\n-            \/* No T designator or invalid char. *\/\n-            if (seq == 3 || seq == sizeof(desig))\n-                goto error;\n-        }\n-        cur++;\n-\n-        if (!has_digits || (has_frac && (seq != 5)))\n-            goto error;\n-\n-        switch (seq) {\n-            case 0:\n-                \/* Year *\/\n-                if (num > LONG_MAX \/ 12)\n-                    goto error;\n-                dur->mon = num * 12;\n-                break;\n-            case 1:\n-                \/* Month *\/\n-                if (dur->mon > LONG_MAX - num)\n-                    goto error;\n-                dur->mon += num;\n-                break;\n-            case 2:\n-                \/* Day *\/\n-                dur->day = num;\n-                break;\n-            case 3:\n-                \/* Hour *\/\n-                days = num \/ HOURS_PER_DAY;\n-                if (dur->day > LONG_MAX - days)\n-                    goto error;\n-                dur->day += days;\n-                secs = (num % HOURS_PER_DAY) * SECS_PER_HOUR;\n-                break;\n-            case 4:\n-                \/* Minute *\/\n-                days = num \/ MINS_PER_DAY;\n-                if (dur->day > LONG_MAX - days)\n-                    goto error;\n-                dur->day += days;\n-                secs += (num % MINS_PER_DAY) * SECS_PER_MIN;\n-                break;\n-            case 5:\n-                \/* Second *\/\n-                days = num \/ SECS_PER_DAY;\n-                if (dur->day > LONG_MAX - days)\n-                    goto error;\n-                dur->day += days;\n-                secs += num % SECS_PER_DAY;\n-                break;\n-        }\n-\n-        seq++;\n-    }\n-\n-    days = secs \/ SECS_PER_DAY;\n-    if (dur->day > LONG_MAX - days)\n-        goto error;\n-    dur->day += days;\n-    dur->sec = (secs % SECS_PER_DAY) + sec_frac;\n-\n-    if (isneg) {\n-        dur->mon = -dur->mon;\n-        dur->day = -dur->day;\n-        if (dur->sec != 0.0) {\n-            dur->sec = SECS_PER_DAY - dur->sec;\n-            dur->day -= 1;\n-        }\n-    }\n-\n-#ifdef DEBUG_EXSLT_DATE\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"Parsed duration %f\\n\", dur->sec);\n-#endif\n-\n-    return dur;\n-\n-error:\n-    if (dur != NULL)\n-    exsltDateFreeDuration(dur);\n-    return NULL;\n-}\n-\n-static void\n-exsltFormatLong(xmlChar **cur, xmlChar *end, long num) {\n-    xmlChar buf[20];\n-    int i = 0;\n-\n-    while (i < 20) {\n-        buf[i++] = '0' + num % 10;\n-        num \/= 10;\n-        if (num == 0)\n-            break;\n-    }\n-\n-    while (i > 0) {\n-        if (*cur < end)\n-            *(*cur)++ = buf[--i];\n-    }\n-}\n-\n-static void\n-exsltFormatNanoseconds(xmlChar **cur, xmlChar *end, long nsecs) {\n-    long p10, digit;\n-\n-    if (nsecs > 0) {\n-        if (*cur < end)\n-            *(*cur)++ = '.';\n-        p10 = 100000000;\n-        while (nsecs > 0) {\n-            digit = nsecs \/ p10;\n-            if (*cur < end)\n-                *(*cur)++ = '0' + digit;\n-            nsecs -= digit * p10;\n-            p10 \/= 10;\n-        }\n-    }\n-}\n-\n-\/**\n- * exsltDateFormatDuration:\n- * @dur: an #exsltDateDurValPtr\n- *\n- * Formats the duration.\n- *\n- * Returns a newly allocated string, or NULL in case of error\n- *\/\n-static xmlChar *\n-exsltDateFormatDuration (const exsltDateDurValPtr dur)\n-{\n-    xmlChar buf[100], *cur = buf, *end = buf + 99;\n-    double secs, tmp;\n-    long days, months, intSecs, nsecs;\n-\n-    if (dur == NULL)\n-    return NULL;\n-\n-    \/* quick and dirty check *\/\n-    if ((dur->sec == 0.0) && (dur->day == 0) && (dur->mon == 0))\n-        return xmlStrdup((xmlChar*)\"P0D\");\n-\n-    secs   = dur->sec;\n-    days   = dur->day;\n-    months = dur->mon;\n-\n-    *cur = '\\0';\n-    if (days < 0) {\n-        if (secs != 0.0) {\n-            secs = SECS_PER_DAY - secs;\n-            days += 1;\n-        }\n-        days = -days;\n-        *cur = '-';\n-    }\n-    if (months < 0) {\n-        months = -months;\n-        *cur = '-';\n-    }\n-    if (*cur == '-')\n-    cur++;\n-\n-    *cur++ = 'P';\n-\n-    if (months >= 12) {\n-        long years = months \/ 12;\n-\n-        months -= years * 12;\n-        exsltFormatLong(&cur, end, years);\n-        if (cur < end)\n-            *cur++ = 'Y';\n-    }\n-\n-    if (months != 0) {\n-        exsltFormatLong(&cur, end, months);\n-        if (cur < end)\n-            *cur++ = 'M';\n-    }\n-\n-    if (days != 0) {\n-        exsltFormatLong(&cur, end, days);\n-        if (cur < end)\n-            *cur++ = 'D';\n-    }\n-\n-    tmp = floor(secs);\n-    intSecs = (long) tmp;\n-    \/* Round to nearest to avoid issues with floating point precision *\/\n-    nsecs = (long) floor((secs - tmp) * 1000000000 + 0.5);\n-    if (nsecs >= 1000000000) {\n-        nsecs -= 1000000000;\n-        intSecs += 1;\n-    }\n-\n-    if ((intSecs > 0) || (nsecs > 0)) {\n-        if (cur < end)\n-            *cur++ = 'T';\n-\n-        if (intSecs >= SECS_PER_HOUR) {\n-            long hours = intSecs \/ SECS_PER_HOUR;\n-\n-            intSecs -= hours * SECS_PER_HOUR;\n-            exsltFormatLong(&cur, end, hours);\n-            if (cur < end)\n-                *cur++ = 'H';\n-        }\n-\n-        if (intSecs >= SECS_PER_MIN) {\n-            long mins = intSecs \/ SECS_PER_MIN;\n-\n-            intSecs -= mins * SECS_PER_MIN;\n-            exsltFormatLong(&cur, end, mins);\n-            if (cur < end)\n-                *cur++ = 'M';\n-        }\n-\n-        if ((intSecs > 0) || (nsecs > 0)) {\n-            exsltFormatLong(&cur, end, intSecs);\n-            exsltFormatNanoseconds(&cur, end, nsecs);\n-            if (cur < end)\n-                *cur++ = 'S';\n-        }\n-    }\n-\n-    *cur = 0;\n-\n-    return xmlStrdup(buf);\n-}\n-\n-static void\n-exsltFormatTwoDigits(xmlChar **cur, xmlChar *end, int num) {\n-    if (num < 0 || num >= 100)\n-        return;\n-    if (*cur < end)\n-        *(*cur)++ = '0' + num \/ 10;\n-    if (*cur < end)\n-        *(*cur)++ = '0' + num % 10;\n-}\n-\n-static void\n-exsltFormatTime(xmlChar **cur, xmlChar *end, exsltDateValPtr dt) {\n-    double tmp;\n-    long intSecs, nsecs;\n-\n-    exsltFormatTwoDigits(cur, end, dt->hour);\n-    if (*cur < end)\n-        *(*cur)++ = ':';\n-\n-    exsltFormatTwoDigits(cur, end, dt->min);\n-    if (*cur < end)\n-        *(*cur)++ = ':';\n-\n-    tmp = floor(dt->sec);\n-    intSecs = (long) tmp;\n-    \/*\n-     * Round to nearest to avoid issues with floating point precision,\n-     * but don't carry over so seconds stay below 60.\n-     *\/\n-    nsecs = (long) floor((dt->sec - tmp) * 1000000000 + 0.5);\n-    if (nsecs > 999999999)\n-        nsecs = 999999999;\n-    exsltFormatTwoDigits(cur, end, intSecs);\n-    exsltFormatNanoseconds(cur, end, nsecs);\n-}\n-\n-\/**\n- * exsltDateFormatDateTime:\n- * @dt: an #exsltDateValPtr\n- *\n- * Formats @dt in xs:dateTime format.\n- *\n- * Returns a newly allocated string, or NULL in case of error\n- *\/\n-static xmlChar *\n-exsltDateFormatDateTime (const exsltDateValPtr dt)\n-{\n-    xmlChar buf[100], *cur = buf, *end = buf + 99;\n-\n-    if ((dt == NULL) ||    !VALID_DATETIME(dt))\n-    return NULL;\n-\n-    exsltFormatYearMonthDay(&cur, end, dt);\n-    if (cur < end)\n-        *cur++ = 'T';\n-    exsltFormatTime(&cur, end, dt);\n-    exsltFormatTimeZone(&cur, end, dt->tzo);\n-    *cur = 0;\n-\n-    return xmlStrdup(buf);\n-}\n-\n-\/**\n- * exsltDateFormatDate:\n- * @dt: an #exsltDateValPtr\n- *\n- * Formats @dt in xs:date format.\n- *\n- * Returns a newly allocated string, or NULL in case of error\n- *\/\n-static xmlChar *\n-exsltDateFormatDate (const exsltDateValPtr dt)\n-{\n-    xmlChar buf[100], *cur = buf, *end = buf + 99;\n-\n-    if ((dt == NULL) || !VALID_DATETIME(dt))\n-    return NULL;\n-\n-    exsltFormatYearMonthDay(&cur, end, dt);\n-    if (dt->tz_flag || (dt->tzo != 0)) {\n-        exsltFormatTimeZone(&cur, end, dt->tzo);\n-    }\n-    *cur = 0;\n-\n-    return xmlStrdup(buf);\n-}\n-\n-\/**\n- * exsltDateFormatTime:\n- * @dt: an #exsltDateValPtr\n- *\n- * Formats @dt in xs:time format.\n- *\n- * Returns a newly allocated string, or NULL in case of error\n- *\/\n-static xmlChar *\n-exsltDateFormatTime (const exsltDateValPtr dt)\n-{\n-    xmlChar buf[100], *cur = buf, *end = buf + 99;\n-\n-    if ((dt == NULL) || !VALID_TIME(dt))\n-    return NULL;\n-\n-    exsltFormatTime(&cur, end, dt);\n-    if (dt->tz_flag || (dt->tzo != 0)) {\n-        exsltFormatTimeZone(&cur, end, dt->tzo);\n-    }\n-    *cur = 0;\n-\n-    return xmlStrdup(buf);\n-}\n-\n-\/**\n- * exsltDateFormat:\n- * @dt: an #exsltDateValPtr\n- *\n- * Formats @dt in the proper format.\n- * Note: xs:gmonth and xs:gday are not formatted as there are no\n- * routines that output them.\n- *\n- * Returns a newly allocated string, or NULL in case of error\n- *\/\n-static xmlChar *\n-exsltDateFormat (const exsltDateValPtr dt)\n-{\n-    if (dt == NULL)\n-    return NULL;\n-\n-    switch (dt->type) {\n-    case XS_DATETIME:\n-        return exsltDateFormatDateTime(dt);\n-    case XS_DATE:\n-        return exsltDateFormatDate(dt);\n-    case XS_TIME:\n-        return exsltDateFormatTime(dt);\n-    default:\n-        break;\n-    }\n-\n-    if (dt->type & XS_GYEAR) {\n-        xmlChar buf[100], *cur = buf, *end = buf + 99;\n-\n-        exsltFormatGYear(&cur, end, dt->year);\n-        if (dt->type == XS_GYEARMONTH) {\n-            if (cur < end)\n-            *cur++ = '-';\n-            exsltFormat2Digits(&cur, end, dt->mon);\n-        }\n-\n-        if (dt->tz_flag || (dt->tzo != 0)) {\n-            exsltFormatTimeZone(&cur, end, dt->tzo);\n-        }\n-        *cur = 0;\n-        return xmlStrdup(buf);\n-    }\n-\n-    return NULL;\n-}\n-\n-\/**\n- * _exsltDateCastYMToDays:\n- * @dt: an #exsltDateValPtr\n- *\n- * Convert mon and year of @dt to total number of days. Take the\n- * number of years since (or before) 1 AD and add the number of leap\n- * years. This is a function  because negative\n- * years must be handled a little differently.\n- *\n- * Returns number of days.\n- *\/\n-static long\n-_exsltDateCastYMToDays (const exsltDateValPtr dt)\n-{\n-    long ret;\n-\n-    if (dt->year <= 0)\n-        ret = ((dt->year-1) * 365) +\n-              (((dt->year)\/4)-((dt->year)\/100)+\n-               ((dt->year)\/400)) +\n-              DAY_IN_YEAR(0, dt->mon, dt->year) - 1;\n-    else\n-        ret = ((dt->year-1) * 365) +\n-              (((dt->year-1)\/4)-((dt->year-1)\/100)+\n-               ((dt->year-1)\/400)) +\n-              DAY_IN_YEAR(0, dt->mon, dt->year);\n-\n-    return ret;\n-}\n-\n-\/**\n- * TIME_TO_NUMBER:\n- * @dt:  an #exsltDateValPtr\n- *\n- * Calculates the number of seconds in the time portion of @dt.\n- *\n- * Returns seconds.\n- *\/\n-#define TIME_TO_NUMBER(dt)                              \\\n-    ((double)((dt->hour * SECS_PER_HOUR) +   \\\n-              (dt->min * SECS_PER_MIN)) + dt->sec)\n-\n-\/**\n- * _exsltDateTruncateDate:\n- * @dt: an #exsltDateValPtr\n- * @type: dateTime type to set to\n- *\n- * Set @dt to truncated @type.\n- *\n- * Returns 0 success, non-zero otherwise.\n- *\/\n-static int\n-_exsltDateTruncateDate (exsltDateValPtr dt, exsltDateType type)\n-{\n-    if (dt == NULL)\n-        return 1;\n-\n-    if ((type & XS_TIME) != XS_TIME) {\n-        dt->hour = 0;\n-        dt->min  = 0;\n-        dt->sec  = 0.0;\n-    }\n-\n-    if ((type & XS_GDAY) != XS_GDAY)\n-        dt->day = 1;\n-\n-    if ((type & XS_GMONTH) != XS_GMONTH)\n-        dt->mon = 1;\n-\n-    if ((type & XS_GYEAR) != XS_GYEAR)\n-        dt->year = 0;\n-\n-    dt->type = type;\n-\n-    return 0;\n-}\n-\n-\/**\n- * _exsltDayInWeek:\n- * @yday: year day (1-366)\n- * @yr: year\n- *\n- * Determine the day-in-week from @yday and @yr. 0001-01-01 was\n- * a Monday so all other days are calculated from there. Take the\n- * number of years since (or before) add the number of leap years and\n- * the day-in-year and mod by 7. This is a function  because negative\n- * years must be handled a little differently.\n- *\n- * Returns day in week (Sunday = 0).\n- *\/\n-static long\n-_exsltDateDayInWeek(long yday, long yr)\n-{\n-    long ret;\n-\n-    if (yr <= 0) {\n-        \/* Compute modulus twice to avoid integer overflow *\/\n-        ret = ((yr%7-2 + ((yr\/4)-(yr\/100)+(yr\/400)) + yday) % 7);\n-        if (ret < 0)\n-            ret += 7;\n-    } else\n-        ret = (((yr%7-1) + (((yr-1)\/4)-((yr-1)\/100)+((yr-1)\/400)) + yday) % 7);\n-\n-    return ret;\n-}\n-\n-\/**\n- * _exsltDateAdd:\n- * @dt: an #exsltDateValPtr\n- * @dur: an #exsltDateDurValPtr\n- *\n- * Compute a new date\/time from @dt and @dur. This function assumes @dt\n- * is either #XS_DATETIME, #XS_DATE, #XS_GYEARMONTH, or #XS_GYEAR.\n- *\n- * Returns date\/time pointer or NULL.\n- *\/\n-static exsltDateValPtr\n-_exsltDateAdd (exsltDateValPtr dt, exsltDateDurValPtr dur)\n-{\n-    exsltDateValPtr ret;\n-    long carry, temp;\n-    double sum;\n-\n-    if ((dt == NULL) || (dur == NULL))\n-        return NULL;\n-\n-    ret = exsltDateCreateDate(dt->type);\n-    if (ret == NULL)\n-        return NULL;\n-\n-    \/*\n-     * Note that temporary values may need more bits than the values in\n-     * bit field.\n-     *\/\n-\n-    \/* month *\/\n-    temp  = dt->mon + dur->mon % 12;\n-    carry = dur->mon \/ 12;\n-    if (temp < 1) {\n-        temp  += 12;\n-        carry -= 1;\n-    }\n-    else if (temp > 12) {\n-        temp  -= 12;\n-        carry += 1;\n-    }\n-    ret->mon = temp;\n-\n-    \/*\n-     * year (may be modified later)\n-     *\n-     * Add epochs from dur->day now to avoid overflow later and to speed up\n-     * pathological cases.\n-     *\/\n-    carry += (dur->day \/ DAYS_PER_EPOCH) * YEARS_PER_EPOCH;\n-    if ((carry > 0 && dt->year > YEAR_MAX - carry) ||\n-        (carry < 0 && dt->year < YEAR_MIN - carry)) {\n-        \/* Overflow *\/\n-        exsltDateFreeDate(ret);\n-        return NULL;\n-    }\n-    ret->year = dt->year + carry;\n-\n-    \/* time zone *\/\n-    ret->tzo     = dt->tzo;\n-    ret->tz_flag = dt->tz_flag;\n-\n-    \/* seconds *\/\n-    sum    = dt->sec + dur->sec;\n-    ret->sec = fmod(sum, 60.0);\n-    carry  = (long)(sum \/ 60.0);\n-\n-    \/* minute *\/\n-    temp  = dt->min + carry % 60;\n-    carry = carry \/ 60;\n-    if (temp >= 60) {\n-        temp  -= 60;\n-        carry += 1;\n-    }\n-    ret->min = temp;\n-\n-    \/* hours *\/\n-    temp  = dt->hour + carry % 24;\n-    carry = carry \/ 24;\n-    if (temp >= 24) {\n-        temp  -= 24;\n-        carry += 1;\n-    }\n-    ret->hour = temp;\n-\n-    \/* days *\/\n-    if (dt->day > MAX_DAYINMONTH(ret->year, ret->mon))\n-        temp = MAX_DAYINMONTH(ret->year, ret->mon);\n-    else if (dt->day < 1)\n-        temp = 1;\n-    else\n-        temp = dt->day;\n-\n-    temp += dur->day % DAYS_PER_EPOCH + carry;\n-\n-    while (1) {\n-        if (temp < 1) {\n-            if (ret->mon > 1) {\n-                ret->mon -= 1;\n-            }\n-            else {\n-                if (ret->year == YEAR_MIN) {\n-                    exsltDateFreeDate(ret);\n-                    return NULL;\n-                }\n-                ret->mon   = 12;\n-                ret->year -= 1;\n-            }\n-            temp += MAX_DAYINMONTH(ret->year, ret->mon);\n-        } else if (temp > (long)MAX_DAYINMONTH(ret->year, ret->mon)) {\n-            temp -= MAX_DAYINMONTH(ret->year, ret->mon);\n-            if (ret->mon < 12) {\n-                ret->mon += 1;\n-            }\n-            else {\n-                if (ret->year == YEAR_MAX) {\n-                    exsltDateFreeDate(ret);\n-                    return NULL;\n-                }\n-                ret->mon   = 1;\n-                ret->year += 1;\n-            }\n-        } else\n-            break;\n-    }\n-\n-    ret->day = temp;\n-\n-    \/*\n-     * adjust the date\/time type to the date values\n-     *\/\n-    if (ret->type != XS_DATETIME) {\n-        if ((ret->hour) || (ret->min) || (ret->sec))\n-            ret->type = XS_DATETIME;\n-        else if (ret->type != XS_DATE) {\n-            if (ret->day != 1)\n-                ret->type = XS_DATE;\n-            else if ((ret->type != XS_GYEARMONTH) && (ret->mon != 1))\n-                ret->type = XS_GYEARMONTH;\n-        }\n-    }\n-\n-    return ret;\n-}\n-\n-\/**\n- * _exsltDateDifference:\n- * @x: an #exsltDateValPtr\n- * @y: an #exsltDateValPtr\n- * @flag: force difference in days\n- *\n- * Calculate the difference between @x and @y as a duration\n- * (i.e. y - x). If the @flag is set then even if the least specific\n- * format of @x or @y is xs:gYear or xs:gYearMonth.\n- *\n- * Returns a duration pointer or NULL.\n- *\/\n-static exsltDateDurValPtr\n-_exsltDateDifference (exsltDateValPtr x, exsltDateValPtr y, int flag)\n-{\n-    exsltDateDurValPtr ret;\n-\n-    if ((x == NULL) || (y == NULL))\n-        return NULL;\n-\n-    if (((x->type < XS_GYEAR) || (x->type > XS_DATETIME)) ||\n-        ((y->type < XS_GYEAR) || (y->type > XS_DATETIME)))\n-        return NULL;\n-\n-    \/*\n-     * the operand with the most specific format must be converted to\n-     * the same type as the operand with the least specific format.\n-     *\/\n-    if (x->type != y->type) {\n-        if (x->type < y->type) {\n-            _exsltDateTruncateDate(y, x->type);\n-        } else {\n-            _exsltDateTruncateDate(x, y->type);\n-        }\n-    }\n-\n-    ret = exsltDateCreateDuration();\n-    if (ret == NULL)\n-        return NULL;\n-\n-    if (((x->type == XS_GYEAR) || (x->type == XS_GYEARMONTH)) && (!flag)) {\n-        \/* compute the difference in months *\/\n-        if ((x->year >= LONG_MAX \/ 24) || (x->year <= LONG_MIN \/ 24) ||\n-            (y->year >= LONG_MAX \/ 24) || (y->year <= LONG_MIN \/ 24)) {\n-            \/* Possible overflow. *\/\n-            exsltDateFreeDuration(ret);\n-            return NULL;\n-        }\n-        ret->mon = (y->year - x->year) * 12 + (y->mon - x->mon);\n-    } else {\n-        long carry;\n-\n-        if ((x->year > LONG_MAX \/ 731) || (x->year < LONG_MIN \/ 731) ||\n-            (y->year > LONG_MAX \/ 731) || (y->year < LONG_MIN \/ 731)) {\n-            \/* Possible overflow. *\/\n-            exsltDateFreeDuration(ret);\n-            return NULL;\n-        }\n-\n-        ret->sec  = TIME_TO_NUMBER(y) - TIME_TO_NUMBER(x);\n-        ret->sec += (x->tzo - y->tzo) * SECS_PER_MIN;\n-        carry    = (long)floor(ret->sec \/ SECS_PER_DAY);\n-        ret->sec  = ret->sec - carry * SECS_PER_DAY;\n-\n-        ret->day  = _exsltDateCastYMToDays(y) - _exsltDateCastYMToDays(x);\n-        ret->day += y->day - x->day;\n-        ret->day += carry;\n-    }\n-\n-    return ret;\n-}\n-\n-\/**\n- * _exsltDateAddDurCalc\n- * @ret: an exsltDateDurValPtr for the return value:\n- * @x: an exsltDateDurValPtr for the first operand\n- * @y: an exsltDateDurValPtr for the second operand\n- *\n- * Add two durations, catering for possible negative values.\n- * The sum is placed in @ret.\n- *\n- * Returns 1 for success, 0 if error detected.\n- *\/\n-static int\n-_exsltDateAddDurCalc (exsltDateDurValPtr ret, exsltDateDurValPtr x,\n-              exsltDateDurValPtr y)\n-{\n-    \/* months *\/\n-    if ((x->mon > 0 && y->mon >  LONG_MAX - x->mon) ||\n-        (x->mon < 0 && y->mon <= LONG_MIN - x->mon)) {\n-        \/* Overflow *\/\n-        return 0;\n-    }\n-    ret->mon = x->mon + y->mon;\n-\n-    \/* days *\/\n-    if ((x->day > 0 && y->day >  LONG_MAX - x->day) ||\n-        (x->day < 0 && y->day <= LONG_MIN - x->day)) {\n-        \/* Overflow *\/\n-        return 0;\n-    }\n-    ret->day = x->day + y->day;\n-\n-    \/* seconds *\/\n-    ret->sec = x->sec + y->sec;\n-    if (ret->sec >= SECS_PER_DAY) {\n-        if (ret->day == LONG_MAX) {\n-            \/* Overflow *\/\n-            return 0;\n-        }\n-        ret->sec -= SECS_PER_DAY;\n-        ret->day += 1;\n-    }\n-\n-    \/*\n-     * are the results indeterminate? i.e. how do you subtract days from\n-     * months or years?\n-     *\/\n-    if (ret->day >= 0) {\n-        if (((ret->day > 0) || (ret->sec > 0)) && (ret->mon < 0))\n-            return 0;\n-    }\n-    else {\n-        if (ret->mon > 0)\n-            return 0;\n-    }\n-    return 1;\n-}\n-\n-\/**\n- * _exsltDateAddDuration:\n- * @x: an #exsltDateDurValPtr\n- * @y: an #exsltDateDurValPtr\n- *\n- * Compute a new duration from @x and @y.\n- *\n- * Returns a duration pointer or NULL.\n- *\/\n-static exsltDateDurValPtr\n-_exsltDateAddDuration (exsltDateDurValPtr x, exsltDateDurValPtr y)\n-{\n-    exsltDateDurValPtr ret;\n-\n-    if ((x == NULL) || (y == NULL))\n-        return NULL;\n-\n-    ret = exsltDateCreateDuration();\n-    if (ret == NULL)\n-        return NULL;\n-\n-    if (_exsltDateAddDurCalc(ret, x, y))\n-        return ret;\n-\n-    exsltDateFreeDuration(ret);\n-    return NULL;\n-}\n-\n-\/****************************************************************\n- *                                *\n- *        EXSLT - Dates and Times functions        *\n- *                                *\n- ****************************************************************\/\n-\n-\/**\n- * exsltDateDateTime:\n- *\n- * Implements the EXSLT - Dates and Times date-time() function:\n- *     string date:date-time()\n- *\n- * Returns the current date and time as a date\/time string.\n- *\/\n-static xmlChar *\n-exsltDateDateTime (void)\n-{\n-    xmlChar *ret = NULL;\n-    exsltDateValPtr cur;\n-\n-    cur = exsltDateCurrent();\n-    if (cur != NULL) {\n-    ret = exsltDateFormatDateTime(cur);\n-    exsltDateFreeDate(cur);\n-    }\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateDate:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times date() function:\n- *     string date:date (string?)\n- *\n- * Returns the date specified in the date\/time string given as the\n- * argument.  If no argument is given, then the current local\n- * date\/time, as returned by date:date-time is used as a default\n- * argument.\n- * The date\/time string specified as an argument must be a string in\n- * the format defined as the lexical representation of either\n- * xs:dateTime or xs:date.  If the argument is not in either of these\n- * formats, returns NULL.\n- *\/\n-static xmlChar *\n-exsltDateDate (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt = NULL;\n-    xmlChar *ret = NULL;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    if (dt == NULL)\n-        return NULL;\n-    } else {\n-    dt = exsltDateParse(dateTime);\n-    if (dt == NULL)\n-        return NULL;\n-    if ((dt->type != XS_DATETIME) && (dt->type != XS_DATE)) {\n-        exsltDateFreeDate(dt);\n-        return NULL;\n-    }\n-    }\n-\n-    ret = exsltDateFormatDate(dt);\n-    exsltDateFreeDate(dt);\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateTime:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times time() function:\n- *     string date:time (string?)\n- *\n- * Returns the time specified in the date\/time string given as the\n- * argument.  If no argument is given, then the current local\n- * date\/time, as returned by date:date-time is used as a default\n- * argument.\n- * The date\/time string specified as an argument must be a string in\n- * the format defined as the lexical representation of either\n- * xs:dateTime or xs:time.  If the argument is not in either of these\n- * formats, returns NULL.\n- *\/\n-static xmlChar *\n-exsltDateTime (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt = NULL;\n-    xmlChar *ret = NULL;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    if (dt == NULL)\n-        return NULL;\n-    } else {\n-    dt = exsltDateParse(dateTime);\n-    if (dt == NULL)\n-        return NULL;\n-    if ((dt->type != XS_DATETIME) && (dt->type != XS_TIME)) {\n-        exsltDateFreeDate(dt);\n-        return NULL;\n-    }\n-    }\n-\n-    ret = exsltDateFormatTime(dt);\n-    exsltDateFreeDate(dt);\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateYear:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times year() function\n- *    number date:year (string?)\n- * Returns the year of a date as a number.  If no argument is given,\n- * then the current local date\/time, as returned by date:date-time is\n- * used as a default argument.\n- * The date\/time string specified as the first argument must be a\n- * right-truncated string in the format defined as the lexical\n- * representation of xs:dateTime in one of the formats defined in [XML\n- * Schema Part 2: Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- *  - xs:gYearMonth (CCYY-MM)\n- *  - xs:gYear (CCYY)\n- * If the date\/time string is not in one of these formats, then NaN is\n- * returned.\n- *\/\n-static double\n-exsltDateYear (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt;\n-    long year;\n-    double ret;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    if (dt == NULL)\n-        return NAN;\n-    } else {\n-    dt = exsltDateParse(dateTime);\n-    if (dt == NULL)\n-        return NAN;\n-    if ((dt->type != XS_DATETIME) && (dt->type != XS_DATE) &&\n-        (dt->type != XS_GYEARMONTH) && (dt->type != XS_GYEAR)) {\n-        exsltDateFreeDate(dt);\n-        return NAN;\n-    }\n-    }\n-\n-    year = dt->year;\n-    if (year <= 0) year -= 1; \/* Adjust for missing year 0. *\/\n-    ret = (double) year;\n-    exsltDateFreeDate(dt);\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateLeapYear:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times leap-year() function:\n- *    boolean date:leap-yea (string?)\n- * Returns true if the year given in a date is a leap year.  If no\n- * argument is given, then the current local date\/time, as returned by\n- * date:date-time is used as a default argument.\n- * The date\/time string specified as the first argument must be a\n- * right-truncated string in the format defined as the lexical\n- * representation of xs:dateTime in one of the formats defined in [XML\n- * Schema Part 2: Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- *  - xs:gYearMonth (CCYY-MM)\n- *  - xs:gYear (CCYY)\n- * If the date\/time string is not in one of these formats, then NaN is\n- * returned.\n- *\/\n-static xmlXPathObjectPtr\n-exsltDateLeapYear (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt = NULL;\n-    xmlXPathObjectPtr ret;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    } else {\n-    dt = exsltDateParse(dateTime);\n-    if ((dt != NULL) &&\n-            (dt->type != XS_DATETIME) && (dt->type != XS_DATE) &&\n-        (dt->type != XS_GYEARMONTH) && (dt->type != XS_GYEAR)) {\n-        exsltDateFreeDate(dt);\n-        dt = NULL;\n-    }\n-    }\n-\n-    if (dt == NULL) {\n-        ret = xmlXPathNewFloat(NAN);\n-    }\n-    else {\n-        ret = xmlXPathNewBoolean(IS_LEAP(dt->year));\n-        exsltDateFreeDate(dt);\n-    }\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateMonthInYear:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times month-in-year() function:\n- *    number date:month-in-year (string?)\n- * Returns the month of a date as a number.  If no argument is given,\n- * then the current local date\/time, as returned by date:date-time is\n- * used the default argument.\n- * The date\/time string specified as the argument is a left or\n- * right-truncated string in the format defined as the lexical\n- * representation of xs:dateTime in one of the formats defined in [XML\n- * Schema Part 2: Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- *  - xs:gYearMonth (CCYY-MM)\n- *  - xs:gMonth (--MM--)\n- *  - xs:gMonthDay (--MM-DD)\n- * If the date\/time string is not in one of these formats, then NaN is\n- * returned.\n- *\/\n-static double\n-exsltDateMonthInYear (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt;\n-    double ret;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    if (dt == NULL)\n-        return NAN;\n-    } else {\n-    dt = exsltDateParse(dateTime);\n-    if (dt == NULL)\n-        return NAN;\n-    if ((dt->type != XS_DATETIME) && (dt->type != XS_DATE) &&\n-        (dt->type != XS_GYEARMONTH) && (dt->type != XS_GMONTH) &&\n-        (dt->type != XS_GMONTHDAY)) {\n-        exsltDateFreeDate(dt);\n-        return NAN;\n-    }\n-    }\n-\n-    ret = (double) dt->mon;\n-    exsltDateFreeDate(dt);\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateMonthName:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Time month-name() function\n- *    string date:month-name (string?)\n- * Returns the full name of the month of a date.  If no argument is\n- * given, then the current local date\/time, as returned by\n- * date:date-time is used the default argument.\n- * The date\/time string specified as the argument is a left or\n- * right-truncated string in the format defined as the lexical\n- * representation of xs:dateTime in one of the formats defined in [XML\n- * Schema Part 2: Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- *  - xs:gYearMonth (CCYY-MM)\n- *  - xs:gMonth (--MM--)\n- * If the date\/time string is not in one of these formats, then an\n- * empty string ('') is returned.\n- * The result is an English month name: one of 'January', 'February',\n- * 'March', 'April', 'May', 'June', 'July', 'August', 'September',\n- * 'October', 'November' or 'December'.\n- *\/\n-static const xmlChar *\n-exsltDateMonthName (const xmlChar *dateTime)\n-{\n-    static const xmlChar monthNames[13][10] = {\n-        { 0 },\n-    { 'J', 'a', 'n', 'u', 'a', 'r', 'y', 0 },\n-    { 'F', 'e', 'b', 'r', 'u', 'a', 'r', 'y', 0 },\n-    { 'M', 'a', 'r', 'c', 'h', 0 },\n-    { 'A', 'p', 'r', 'i', 'l', 0 },\n-    { 'M', 'a', 'y', 0 },\n-    { 'J', 'u', 'n', 'e', 0 },\n-    { 'J', 'u', 'l', 'y', 0 },\n-    { 'A', 'u', 'g', 'u', 's', 't', 0 },\n-    { 'S', 'e', 'p', 't', 'e', 'm', 'b', 'e', 'r', 0 },\n-    { 'O', 'c', 't', 'o', 'b', 'e', 'r', 0 },\n-    { 'N', 'o', 'v', 'e', 'm', 'b', 'e', 'r', 0 },\n-    { 'D', 'e', 'c', 'e', 'm', 'b', 'e', 'r', 0 }\n-    };\n-    double month;\n-    int index = 0;\n-    month = exsltDateMonthInYear(dateTime);\n-    if (!xmlXPathIsNaN(month) && (month >= 1.0) && (month <= 12.0))\n-      index = (int) month;\n-    return monthNames[index];\n-}\n-\n-\/**\n- * exsltDateMonthAbbreviation:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Time month-abbreviation() function\n- *    string date:month-abbreviation (string?)\n- * Returns the abbreviation of the month of a date.  If no argument is\n- * given, then the current local date\/time, as returned by\n- * date:date-time is used the default argument.\n- * The date\/time string specified as the argument is a left or\n- * right-truncated string in the format defined as the lexical\n- * representation of xs:dateTime in one of the formats defined in [XML\n- * Schema Part 2: Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- *  - xs:gYearMonth (CCYY-MM)\n- *  - xs:gMonth (--MM--)\n- * If the date\/time string is not in one of these formats, then an\n- * empty string ('') is returned.\n- * The result is an English month abbreviation: one of 'Jan', 'Feb',\n- * 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov' or\n- * 'Dec'.\n- *\/\n-static const xmlChar *\n-exsltDateMonthAbbreviation (const xmlChar *dateTime)\n-{\n-    static const xmlChar monthAbbreviations[13][4] = {\n-        { 0 },\n-    { 'J', 'a', 'n', 0 },\n-    { 'F', 'e', 'b', 0 },\n-    { 'M', 'a', 'r', 0 },\n-    { 'A', 'p', 'r', 0 },\n-    { 'M', 'a', 'y', 0 },\n-    { 'J', 'u', 'n', 0 },\n-    { 'J', 'u', 'l', 0 },\n-    { 'A', 'u', 'g', 0 },\n-    { 'S', 'e', 'p', 0 },\n-    { 'O', 'c', 't', 0 },\n-    { 'N', 'o', 'v', 0 },\n-    { 'D', 'e', 'c', 0 }\n-    };\n-    double month;\n-    int index = 0;\n-    month = exsltDateMonthInYear(dateTime);\n-    if (!xmlXPathIsNaN(month) && (month >= 1.0) && (month <= 12.0))\n-      index = (int) month;\n-    return monthAbbreviations[index];\n-}\n-\n-\/**\n- * exsltDateWeekInYear:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times week-in-year() function\n- *    number date:week-in-year (string?)\n- * Returns the week of the year as a number.  If no argument is given,\n- * then the current local date\/time, as returned by date:date-time is\n- * used as the default argument.  For the purposes of numbering,\n- * counting follows ISO 8601: week 1 in a year is the week containing\n- * the first Thursday of the year, with new weeks beginning on a\n- * Monday.\n- * The date\/time string specified as the argument is a right-truncated\n- * string in the format defined as the lexical representation of\n- * xs:dateTime in one of the formats defined in [XML Schema Part 2:\n- * Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- * If the date\/time string is not in one of these formats, then NaN is\n- * returned.\n- *\/\n-static double\n-exsltDateWeekInYear (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt;\n-    long diy, diw, year, ret;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    if (dt == NULL)\n-        return NAN;\n-    } else {\n-    dt = exsltDateParse(dateTime);\n-    if (dt == NULL)\n-        return NAN;\n-    if ((dt->type != XS_DATETIME) && (dt->type != XS_DATE)) {\n-        exsltDateFreeDate(dt);\n-        return NAN;\n-    }\n-    }\n-\n-    diy = DAY_IN_YEAR(dt->day, dt->mon, dt->year);\n-\n-    \/*\n-     * Determine day-in-week (0=Sun, 1=Mon, etc.) then adjust so Monday\n-     * is the first day-in-week\n-     *\/\n-    diw = (_exsltDateDayInWeek(diy, dt->year) + 6) % 7;\n-\n-    \/* ISO 8601 adjustment, 3 is Thu *\/\n-    diy += (3 - diw);\n-    if(diy < 1) {\n-    year = dt->year - 1;\n-    if(year == 0) year--;\n-    diy = DAY_IN_YEAR(31, 12, year) + diy;\n-    } else if (diy > (long)DAY_IN_YEAR(31, 12, dt->year)) {\n-    diy -= DAY_IN_YEAR(31, 12, dt->year);\n-    }\n-\n-    ret = ((diy - 1) \/ 7) + 1;\n-\n-    exsltDateFreeDate(dt);\n-\n-    return (double) ret;\n-}\n-\n-\/**\n- * exsltDateWeekInMonth:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times week-in-month() function\n- *    number date:week-in-month (string?)\n- * The date:week-in-month function returns the week in a month of a\n- * date as a number. If no argument is given, then the current local\n- * date\/time, as returned by date:date-time is used the default\n- * argument. For the purposes of numbering, the first day of the month\n- * is in week 1 and new weeks begin on a Monday (so the first and last\n- * weeks in a month will often have less than 7 days in them).\n- * The date\/time string specified as the argument is a right-truncated\n- * string in the format defined as the lexical representation of\n- * xs:dateTime in one of the formats defined in [XML Schema Part 2:\n- * Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- * If the date\/time string is not in one of these formats, then NaN is\n- * returned.\n- *\/\n-static double\n-exsltDateWeekInMonth (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt;\n-    long fdiy, fdiw, ret;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    if (dt == NULL)\n-        return NAN;\n-    } else {\n-    dt = exsltDateParse(dateTime);\n-    if (dt == NULL)\n-        return NAN;\n-    if ((dt->type != XS_DATETIME) && (dt->type != XS_DATE)) {\n-        exsltDateFreeDate(dt);\n-        return NAN;\n-    }\n-    }\n-\n-    fdiy = DAY_IN_YEAR(1, dt->mon, dt->year);\n-    \/*\n-     * Determine day-in-week (0=Sun, 1=Mon, etc.) then adjust so Monday\n-     * is the first day-in-week\n-     *\/\n-    fdiw = (_exsltDateDayInWeek(fdiy, dt->year) + 6) % 7;\n-\n-    ret = ((dt->day + fdiw - 1) \/ 7) + 1;\n-\n-    exsltDateFreeDate(dt);\n-\n-    return (double) ret;\n-}\n-\n-\/**\n- * exsltDateDayInYear:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times day-in-year() function\n- *    number date:day-in-year (string?)\n- * Returns the day of a date in a year as a number.  If no argument is\n- * given, then the current local date\/time, as returned by\n- * date:date-time is used the default argument.\n- * The date\/time string specified as the argument is a right-truncated\n- * string in the format defined as the lexical representation of\n- * xs:dateTime in one of the formats defined in [XML Schema Part 2:\n- * Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- * If the date\/time string is not in one of these formats, then NaN is\n- * returned.\n- *\/\n-static double\n-exsltDateDayInYear (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt;\n-    long ret;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    if (dt == NULL)\n-        return NAN;\n-    } else {\n-    dt = exsltDateParse(dateTime);\n-    if (dt == NULL)\n-        return NAN;\n-    if ((dt->type != XS_DATETIME) && (dt->type != XS_DATE)) {\n-        exsltDateFreeDate(dt);\n-        return NAN;\n-    }\n-    }\n-\n-    ret = DAY_IN_YEAR(dt->day, dt->mon, dt->year);\n-\n-    exsltDateFreeDate(dt);\n-\n-    return (double) ret;\n-}\n-\n-\/**\n- * exsltDateDayInMonth:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times day-in-month() function:\n- *    number date:day-in-month (string?)\n- * Returns the day of a date as a number.  If no argument is given,\n- * then the current local date\/time, as returned by date:date-time is\n- * used the default argument.\n- * The date\/time string specified as the argument is a left or\n- * right-truncated string in the format defined as the lexical\n- * representation of xs:dateTime in one of the formats defined in [XML\n- * Schema Part 2: Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- *  - xs:gMonthDay (--MM-DD)\n- *  - xs:gDay (---DD)\n- * If the date\/time string is not in one of these formats, then NaN is\n- * returned.\n- *\/\n-static double\n-exsltDateDayInMonth (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt;\n-    double ret;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    if (dt == NULL)\n-        return NAN;\n-    } else {\n-    dt = exsltDateParse(dateTime);\n-    if (dt == NULL)\n-        return NAN;\n-    if ((dt->type != XS_DATETIME) && (dt->type != XS_DATE) &&\n-        (dt->type != XS_GMONTHDAY) && (dt->type != XS_GDAY)) {\n-        exsltDateFreeDate(dt);\n-        return NAN;\n-    }\n-    }\n-\n-    ret = (double) dt->day;\n-    exsltDateFreeDate(dt);\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateDayOfWeekInMonth:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times day-of-week-in-month() function:\n- *    number date:day-of-week-in-month (string?)\n- * Returns the day-of-the-week in a month of a date as a number\n- * (e.g. 3 for the 3rd Tuesday in May).  If no argument is\n- * given, then the current local date\/time, as returned by\n- * date:date-time is used the default argument.\n- * The date\/time string specified as the argument is a right-truncated\n- * string in the format defined as the lexical representation of\n- * xs:dateTime in one of the formats defined in [XML Schema Part 2:\n- * Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- * If the date\/time string is not in one of these formats, then NaN is\n- * returned.\n- *\/\n-static double\n-exsltDateDayOfWeekInMonth (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt;\n-    long ret;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    if (dt == NULL)\n-        return NAN;\n-    } else {\n-    dt = exsltDateParse(dateTime);\n-    if (dt == NULL)\n-        return NAN;\n-    if ((dt->type != XS_DATETIME) && (dt->type != XS_DATE)) {\n-        exsltDateFreeDate(dt);\n-        return NAN;\n-    }\n-    }\n-\n-    ret = ((dt->day -1) \/ 7) + 1;\n-\n-    exsltDateFreeDate(dt);\n-\n-    return (double) ret;\n-}\n-\n-\/**\n- * exsltDateDayInWeek:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times day-in-week() function:\n- *    number date:day-in-week (string?)\n- * Returns the day of the week given in a date as a number.  If no\n- * argument is given, then the current local date\/time, as returned by\n- * date:date-time is used the default argument.\n- * The date\/time string specified as the argument is a left or\n- * right-truncated string in the format defined as the lexical\n- * representation of xs:dateTime in one of the formats defined in [XML\n- * Schema Part 2: Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- * If the date\/time string is not in one of these formats, then NaN is\n- * returned.\n- * The numbering of days of the week starts at 1 for Sunday, 2 for\n- * Monday and so on up to 7 for Saturday.\n- *\/\n-static double\n-exsltDateDayInWeek (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt;\n-    long diy, ret;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    if (dt == NULL)\n-        return NAN;\n-    } else {\n-    dt = exsltDateParse(dateTime);\n-    if (dt == NULL)\n-        return NAN;\n-    if ((dt->type != XS_DATETIME) && (dt->type != XS_DATE)) {\n-        exsltDateFreeDate(dt);\n-        return NAN;\n-    }\n-    }\n-\n-    diy = DAY_IN_YEAR(dt->day, dt->mon, dt->year);\n-\n-    ret = _exsltDateDayInWeek(diy, dt->year) + 1;\n-\n-    exsltDateFreeDate(dt);\n-\n-    return (double) ret;\n-}\n-\n-\/**\n- * exsltDateDayName:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Time day-name() function\n- *    string date:day-name (string?)\n- * Returns the full name of the day of the week of a date.  If no\n- * argument is given, then the current local date\/time, as returned by\n- * date:date-time is used the default argument.\n- * The date\/time string specified as the argument is a left or\n- * right-truncated string in the format defined as the lexical\n- * representation of xs:dateTime in one of the formats defined in [XML\n- * Schema Part 2: Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- * If the date\/time string is not in one of these formats, then an\n- * empty string ('') is returned.\n- * The result is an English day name: one of 'Sunday', 'Monday',\n- * 'Tuesday', 'Wednesday', 'Thursday' or 'Friday'.\n- *\/\n-static const xmlChar *\n-exsltDateDayName (const xmlChar *dateTime)\n-{\n-    static const xmlChar dayNames[8][10] = {\n-        { 0 },\n-    { 'S', 'u', 'n', 'd', 'a', 'y', 0 },\n-    { 'M', 'o', 'n', 'd', 'a', 'y', 0 },\n-    { 'T', 'u', 'e', 's', 'd', 'a', 'y', 0 },\n-    { 'W', 'e', 'd', 'n', 'e', 's', 'd', 'a', 'y', 0 },\n-    { 'T', 'h', 'u', 'r', 's', 'd', 'a', 'y', 0 },\n-    { 'F', 'r', 'i', 'd', 'a', 'y', 0 },\n-    { 'S', 'a', 't', 'u', 'r', 'd', 'a', 'y', 0 }\n-    };\n-    double day;\n-    int index = 0;\n-    day = exsltDateDayInWeek(dateTime);\n-    if(!xmlXPathIsNaN(day) && (day >= 1.0) && (day <= 7.0))\n-      index = (int) day;\n-    return dayNames[index];\n-}\n-\n-\/**\n- * exsltDateDayAbbreviation:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Time day-abbreviation() function\n- *    string date:day-abbreviation (string?)\n- * Returns the abbreviation of the day of the week of a date.  If no\n- * argument is given, then the current local date\/time, as returned by\n- * date:date-time is used the default argument.\n- * The date\/time string specified as the argument is a left or\n- * right-truncated string in the format defined as the lexical\n- * representation of xs:dateTime in one of the formats defined in [XML\n- * Schema Part 2: Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- * If the date\/time string is not in one of these formats, then an\n- * empty string ('') is returned.\n- * The result is a three-letter English day abbreviation: one of\n- * 'Sun', 'Mon', 'Tue', 'Wed', 'Thu' or 'Fri'.\n- *\/\n-static const xmlChar *\n-exsltDateDayAbbreviation (const xmlChar *dateTime)\n-{\n-    static const xmlChar dayAbbreviations[8][4] = {\n-        { 0 },\n-    { 'S', 'u', 'n', 0 },\n-    { 'M', 'o', 'n', 0 },\n-    { 'T', 'u', 'e', 0 },\n-    { 'W', 'e', 'd', 0 },\n-    { 'T', 'h', 'u', 0 },\n-    { 'F', 'r', 'i', 0 },\n-    { 'S', 'a', 't', 0 }\n-    };\n-    double day;\n-    int index = 0;\n-    day = exsltDateDayInWeek(dateTime);\n-    if(!xmlXPathIsNaN(day) && (day >= 1.0) && (day <= 7.0))\n-      index = (int) day;\n-    return dayAbbreviations[index];\n-}\n-\n-\/**\n- * exsltDateHourInDay:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times day-in-month() function:\n- *    number date:day-in-month (string?)\n- * Returns the hour of the day as a number.  If no argument is given,\n- * then the current local date\/time, as returned by date:date-time is\n- * used the default argument.\n- * The date\/time string specified as the argument is a left or\n- * right-truncated string in the format defined as the lexical\n- * representation of xs:dateTime in one of the formats defined in [XML\n- * Schema Part 2: Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:time (hh:mm:ss)\n- * If the date\/time string is not in one of these formats, then NaN is\n- * returned.\n- *\/\n-static double\n-exsltDateHourInDay (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt;\n-    double ret;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    if (dt == NULL)\n-        return NAN;\n-    } else {\n-    dt = exsltDateParse(dateTime);\n-    if (dt == NULL)\n-        return NAN;\n-    if ((dt->type != XS_DATETIME) && (dt->type != XS_TIME)) {\n-        exsltDateFreeDate(dt);\n-        return NAN;\n-    }\n-    }\n-\n-    ret = (double) dt->hour;\n-    exsltDateFreeDate(dt);\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateMinuteInHour:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times day-in-month() function:\n- *    number date:day-in-month (string?)\n- * Returns the minute of the hour as a number.  If no argument is\n- * given, then the current local date\/time, as returned by\n- * date:date-time is used the default argument.\n- * The date\/time string specified as the argument is a left or\n- * right-truncated string in the format defined as the lexical\n- * representation of xs:dateTime in one of the formats defined in [XML\n- * Schema Part 2: Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:time (hh:mm:ss)\n- * If the date\/time string is not in one of these formats, then NaN is\n- * returned.\n- *\/\n-static double\n-exsltDateMinuteInHour (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt;\n-    double ret;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    if (dt == NULL)\n-        return NAN;\n-    } else {\n-    dt = exsltDateParse(dateTime);\n-    if (dt == NULL)\n-        return NAN;\n-    if ((dt->type != XS_DATETIME) && (dt->type != XS_TIME)) {\n-        exsltDateFreeDate(dt);\n-        return NAN;\n-    }\n-    }\n-\n-    ret = (double) dt->min;\n-    exsltDateFreeDate(dt);\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateSecondInMinute:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times second-in-minute() function:\n- *    number date:day-in-month (string?)\n- * Returns the second of the minute as a number.  If no argument is\n- * given, then the current local date\/time, as returned by\n- * date:date-time is used the default argument.\n- * The date\/time string specified as the argument is a left or\n- * right-truncated string in the format defined as the lexical\n- * representation of xs:dateTime in one of the formats defined in [XML\n- * Schema Part 2: Datatypes].  The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:time (hh:mm:ss)\n- * If the date\/time string is not in one of these formats, then NaN is\n- * returned.\n- *\n- * Returns the second or NaN.\n- *\/\n-static double\n-exsltDateSecondInMinute (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt;\n-    double ret;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    if (dt == NULL)\n-        return NAN;\n-    } else {\n-    dt = exsltDateParse(dateTime);\n-    if (dt == NULL)\n-        return NAN;\n-    if ((dt->type != XS_DATETIME) && (dt->type != XS_TIME)) {\n-        exsltDateFreeDate(dt);\n-        return NAN;\n-    }\n-    }\n-\n-    ret = dt->sec;\n-    exsltDateFreeDate(dt);\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateAdd:\n- * @xstr: date\/time string\n- * @ystr: date\/time string\n- *\n- * Implements the date:add (string,string) function which returns the\n- * date\/time * resulting from adding a duration to a date\/time.\n- * The first argument (@xstr) must be right-truncated date\/time\n- * strings in one of the formats defined in [XML Schema Part 2:\n- * Datatypes]. The permitted formats are as follows:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- *  - xs:gYearMonth (CCYY-MM)\n- *  - xs:gYear (CCYY)\n- * The second argument (@ystr) is a string in the format defined for\n- * xs:duration in [3.2.6 duration] of [XML Schema Part 2: Datatypes].\n- * The return value is a right-truncated date\/time strings in one of\n- * the formats defined in [XML Schema Part 2: Datatypes] and listed\n- * above. This value is calculated using the algorithm described in\n- * [Appendix E Adding durations to dateTimes] of [XML Schema Part 2:\n- * Datatypes].\n-\n- * Returns date\/time string or NULL.\n- *\/\n-static xmlChar *\n-exsltDateAdd (const xmlChar *xstr, const xmlChar *ystr)\n-{\n-    exsltDateValPtr dt, res;\n-    exsltDateDurValPtr dur;\n-    xmlChar     *ret;\n-\n-    if ((xstr == NULL) || (ystr == NULL))\n-        return NULL;\n-\n-    dt = exsltDateParse(xstr);\n-    if (dt == NULL)\n-        return NULL;\n-    else if ((dt->type < XS_GYEAR) || (dt->type > XS_DATETIME)) {\n-        exsltDateFreeDate(dt);\n-        return NULL;\n-    }\n-\n-    dur = exsltDateParseDuration(ystr);\n-    if (dur == NULL) {\n-        exsltDateFreeDate(dt);\n-        return NULL;\n-    }\n-\n-    res = _exsltDateAdd(dt, dur);\n-\n-    exsltDateFreeDate(dt);\n-    exsltDateFreeDuration(dur);\n-\n-    if (res == NULL)\n-        return NULL;\n-\n-    ret = exsltDateFormat(res);\n-    exsltDateFreeDate(res);\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateAddDuration:\n- * @xstr:      first duration string\n- * @ystr:      second duration string\n- *\n- * Implements the date:add-duration (string,string) function which returns\n- * the duration resulting from adding two durations together.\n- * Both arguments are strings in the format defined for xs:duration\n- * in [3.2.6 duration] of [XML Schema Part 2: Datatypes]. If either\n- * argument is not in this format, the function returns an empty string\n- * ('').\n- * The return value is a string in the format defined for xs:duration\n- * in [3.2.6 duration] of [XML Schema Part 2: Datatypes].\n- * The durations can usually be added by summing the numbers given for\n- * each of the components in the durations. However, if the durations\n- * are differently signed, then this sometimes results in durations\n- * that are impossible to express in this syntax (e.g. 'P1M' + '-P1D').\n- * In these cases, the function returns an empty string ('').\n- *\n- * Returns duration string or NULL.\n- *\/\n-static xmlChar *\n-exsltDateAddDuration (const xmlChar *xstr, const xmlChar *ystr)\n-{\n-    exsltDateDurValPtr x, y, res;\n-    xmlChar     *ret;\n-\n-    if ((xstr == NULL) || (ystr == NULL))\n-        return NULL;\n-\n-    x = exsltDateParseDuration(xstr);\n-    if (x == NULL)\n-        return NULL;\n-\n-    y = exsltDateParseDuration(ystr);\n-    if (y == NULL) {\n-        exsltDateFreeDuration(x);\n-        return NULL;\n-    }\n-\n-    res = _exsltDateAddDuration(x, y);\n-\n-    exsltDateFreeDuration(x);\n-    exsltDateFreeDuration(y);\n-\n-    if (res == NULL)\n-        return NULL;\n-\n-    ret = exsltDateFormatDuration(res);\n-    exsltDateFreeDuration(res);\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateSumFunction:\n- * @ns:      a node set of duration strings\n- *\n- * The date:sum function adds a set of durations together.\n- * The string values of the nodes in the node set passed as an argument\n- * are interpreted as durations and added together as if using the\n- * date:add-duration function. (from exslt.org)\n- *\n- * The return value is a string in the format defined for xs:duration\n- * in [3.2.6 duration] of [XML Schema Part 2: Datatypes].\n- * The durations can usually be added by summing the numbers given for\n- * each of the components in the durations. However, if the durations\n- * are differently signed, then this sometimes results in durations\n- * that are impossible to express in this syntax (e.g. 'P1M' + '-P1D').\n- * In these cases, the function returns an empty string ('').\n- *\n- * Returns duration string or NULL.\n- *\/\n-static void\n-exsltDateSumFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlNodeSetPtr ns;\n-    void *user = NULL;\n-    xmlChar *tmp;\n-    exsltDateDurValPtr x, total;\n-    xmlChar *ret;\n-    int i;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError (ctxt);\n-    return;\n-    }\n-\n-    \/* We need to delay the freeing of value->user *\/\n-    if ((ctxt->value != NULL) && ctxt->value->boolval != 0) {\n-    user = ctxt->value->user;\n-    ctxt->value->boolval = 0;\n-    ctxt->value->user = NULL;\n-    }\n-\n-    ns = xmlXPathPopNodeSet (ctxt);\n-    if (xmlXPathCheckError (ctxt))\n-    return;\n-\n-    if ((ns == NULL) || (ns->nodeNr == 0)) {\n-    xmlXPathReturnEmptyString (ctxt);\n-    if (ns != NULL)\n-        xmlXPathFreeNodeSet (ns);\n-    return;\n-    }\n-\n-    total = exsltDateCreateDuration ();\n-    if (total == NULL) {\n-        xmlXPathFreeNodeSet (ns);\n-        return;\n-    }\n-\n-    for (i = 0; i < ns->nodeNr; i++) {\n-    int result;\n-    tmp = xmlXPathCastNodeToString (ns->nodeTab[i]);\n-    if (tmp == NULL) {\n-        xmlXPathFreeNodeSet (ns);\n-        exsltDateFreeDuration (total);\n-        return;\n-    }\n-\n-    x = exsltDateParseDuration (tmp);\n-    if (x == NULL) {\n-        xmlFree (tmp);\n-        exsltDateFreeDuration (total);\n-        xmlXPathFreeNodeSet (ns);\n-        xmlXPathReturnEmptyString (ctxt);\n-        return;\n-    }\n-\n-    result = _exsltDateAddDurCalc(total, total, x);\n-\n-    exsltDateFreeDuration (x);\n-    xmlFree (tmp);\n-    if (!result) {\n-        exsltDateFreeDuration (total);\n-        xmlXPathFreeNodeSet (ns);\n-        xmlXPathReturnEmptyString (ctxt);\n-        return;\n-    }\n-    }\n-\n-    ret = exsltDateFormatDuration (total);\n-    exsltDateFreeDuration (total);\n-\n-    xmlXPathFreeNodeSet (ns);\n-    if (user != NULL)\n-    xmlFreeNodeList ((xmlNodePtr) user);\n-\n-    if (ret == NULL)\n-    xmlXPathReturnEmptyString (ctxt);\n-    else\n-    xmlXPathReturnString (ctxt, ret);\n-}\n-\n-\/**\n- * exsltDateSeconds:\n- * @dateTime: a date\/time string\n- *\n- * Implements the EXSLT - Dates and Times seconds() function:\n- *    number date:seconds(string?)\n- * The date:seconds function returns the number of seconds specified\n- * by the argument string. If no argument is given, then the current\n- * local date\/time, as returned by exsltDateCurrent() is used as the\n- * default argument. If the date\/time string is a xs:duration, then the\n- * years and months must be zero (or not present). Parsing a duration\n- * converts the fields to seconds. If the date\/time string is not a\n- * duration (and not null), then the legal formats are:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date     (CCYY-MM-DD)\n- *  - xs:gYearMonth (CCYY-MM)\n- *  - xs:gYear      (CCYY)\n- * In these cases the difference between the @dateTime and\n- * 1970-01-01T00:00:00Z is calculated and converted to seconds.\n- *\n- * Note that there was some confusion over whether \"difference\" meant\n- * that a dateTime of 1970-01-01T00:00:01Z should be a positive one or\n- * a negative one.  After correspondence with exslt.org, it was determined\n- * that the intent of the specification was to have it positive.  The\n- * coding was modified in July 2003 to reflect this.\n- *\n- * Returns seconds or Nan.\n- *\/\n-static double\n-exsltDateSeconds (const xmlChar *dateTime)\n-{\n-    exsltDateValPtr dt;\n-    exsltDateDurValPtr dur = NULL;\n-    double ret = NAN;\n-\n-    if (dateTime == NULL) {\n-    dt = exsltDateCurrent();\n-    if (dt == NULL)\n-        return NAN;\n-    } else {\n-        dt = exsltDateParse(dateTime);\n-        if (dt == NULL)\n-            dur = exsltDateParseDuration(dateTime);\n-    }\n-\n-    if ((dt != NULL) && (dt->type >= XS_GYEAR)) {\n-        exsltDateValPtr y;\n-        exsltDateDurValPtr diff;\n-\n-        \/*\n-         * compute the difference between the given (or current) date\n-         * and epoch date\n-         *\/\n-        y = exsltDateCreateDate(XS_DATETIME);\n-        if (y != NULL) {\n-            y->year = 1970;\n-            y->mon  = 1;\n-            y->day  = 1;\n-            y->tz_flag = 1;\n-\n-            diff = _exsltDateDifference(y, dt, 1);\n-            if (diff != NULL) {\n-                ret = (double)diff->day * SECS_PER_DAY + diff->sec;\n-                exsltDateFreeDuration(diff);\n-            }\n-            exsltDateFreeDate(y);\n-        }\n-\n-    } else if ((dur != NULL) && (dur->mon == 0)) {\n-        ret = (double)dur->day * SECS_PER_DAY + dur->sec;\n-    }\n-\n-    if (dt != NULL)\n-        exsltDateFreeDate(dt);\n-    if (dur != NULL)\n-        exsltDateFreeDuration(dur);\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateDifference:\n- * @xstr: date\/time string\n- * @ystr: date\/time string\n- *\n- * Implements the date:difference (string,string) function which returns\n- * the duration between the first date and the second date. If the first\n- * date occurs before the second date, then the result is a positive\n- * duration; if it occurs after the second date, the result is a\n- * negative duration.  The two dates must both be right-truncated\n- * date\/time strings in one of the formats defined in [XML Schema Part\n- * 2: Datatypes]. The date\/time with the most specific format (i.e. the\n- * least truncation) is converted into the same format as the date with\n- * the least specific format (i.e. the most truncation). The permitted\n- * formats are as follows, from most specific to least specific:\n- *  - xs:dateTime (CCYY-MM-DDThh:mm:ss)\n- *  - xs:date (CCYY-MM-DD)\n- *  - xs:gYearMonth (CCYY-MM)\n- *  - xs:gYear (CCYY)\n- * If either of the arguments is not in one of these formats,\n- * date:difference returns the empty string ('').\n- * The difference between the date\/times is returned as a string in the\n- * format defined for xs:duration in [3.2.6 duration] of [XML Schema\n- * Part 2: Datatypes].\n- * If the date\/time string with the least specific format is in either\n- * xs:gYearMonth or xs:gYear format, then the number of days, hours,\n- * minutes and seconds in the duration string must be equal to zero.\n- * (The format of the string will be PnYnM.) The number of months\n- * specified in the duration must be less than 12.\n- * Otherwise, the number of years and months in the duration string\n- * must be equal to zero. (The format of the string will be\n- * PnDTnHnMnS.) The number of seconds specified in the duration string\n- * must be less than 60; the number of minutes must be less than 60;\n- * the number of hours must be less than 24.\n- *\n- * Returns duration string or NULL.\n- *\/\n-static xmlChar *\n-exsltDateDifference (const xmlChar *xstr, const xmlChar *ystr)\n-{\n-    exsltDateValPtr x, y;\n-    exsltDateDurValPtr dur;\n-    xmlChar *ret = NULL;\n-\n-    if ((xstr == NULL) || (ystr == NULL))\n-        return NULL;\n-\n-    x = exsltDateParse(xstr);\n-    if (x == NULL)\n-        return NULL;\n-\n-    y = exsltDateParse(ystr);\n-    if (y == NULL) {\n-        exsltDateFreeDate(x);\n-        return NULL;\n-    }\n-\n-    if (((x->type < XS_GYEAR) || (x->type > XS_DATETIME)) ||\n-        ((y->type < XS_GYEAR) || (y->type > XS_DATETIME)))  {\n-    exsltDateFreeDate(x);\n-    exsltDateFreeDate(y);\n-        return NULL;\n-    }\n-\n-    dur = _exsltDateDifference(x, y, 0);\n-\n-    exsltDateFreeDate(x);\n-    exsltDateFreeDate(y);\n-\n-    if (dur == NULL)\n-        return NULL;\n-\n-    ret = exsltDateFormatDuration(dur);\n-    exsltDateFreeDuration(dur);\n-\n-    return ret;\n-}\n-\n-\/**\n- * exsltDateDuration:\n- * @number: a xmlChar string\n- *\n- * Implements the The date:duration function returns a duration string\n- * representing the number of seconds specified by the argument string.\n- * If no argument is given, then the result of calling date:seconds\n- * without any arguments is used as a default argument.\n- * The duration is returned as a string in the format defined for\n- * xs:duration in [3.2.6 duration] of [XML Schema Part 2: Datatypes].\n- * The number of years and months in the duration string must be equal\n- * to zero. (The format of the string will be PnDTnHnMnS.) The number\n- * of seconds specified in the duration string must be less than 60;\n- * the number of minutes must be less than 60; the number of hours must\n- * be less than 24.\n- * If the argument is Infinity, -Infinity or NaN, then date:duration\n- * returns an empty string ('').\n- *\n- * Returns duration string or NULL.\n- *\/\n-static xmlChar *\n-exsltDateDuration (const xmlChar *number)\n-{\n-    exsltDateDurValPtr dur;\n-    double       secs, days;\n-    xmlChar     *ret;\n-\n-    if (number == NULL)\n-        secs = exsltDateSeconds(number);\n-    else\n-        secs = xmlXPathCastStringToNumber(number);\n-\n-    if (xmlXPathIsNaN(secs))\n-        return NULL;\n-\n-    days = floor(secs \/ SECS_PER_DAY);\n-    if ((days <= (double)LONG_MIN) || (days >= (double)LONG_MAX))\n-        return NULL;\n-\n-    dur = exsltDateCreateDuration();\n-    if (dur == NULL)\n-        return NULL;\n-\n-    dur->day = (long)days;\n-    dur->sec = secs - days * SECS_PER_DAY;\n-\n-    ret = exsltDateFormatDuration(dur);\n-    exsltDateFreeDuration(dur);\n-\n-    return ret;\n-}\n-\n-\/****************************************************************\n- *                                *\n- *        Wrappers for use by the XPath engine        *\n- *                                *\n- ****************************************************************\/\n-\n-\/**\n- * exsltDateDateTimeFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateDateTime() for use by the XPath engine.\n- *\/\n-static void\n-exsltDateDateTimeFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *ret;\n-\n-    if (nargs != 0) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    ret = exsltDateDateTime();\n-    if (ret == NULL)\n-        xmlXPathReturnEmptyString(ctxt);\n-    else\n-        xmlXPathReturnString(ctxt, ret);\n-}\n-\n-\/**\n- * exsltDateDateFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateDate() for use by the XPath engine.\n- *\/\n-static void\n-exsltDateDateFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *ret, *dt = NULL;\n-\n-    if ((nargs < 0) || (nargs > 1)) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    if (nargs == 1) {\n-    dt = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlXPathSetTypeError(ctxt);\n-        return;\n-    }\n-    }\n-\n-    ret = exsltDateDate(dt);\n-\n-    if (ret == NULL) {\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"{http:\/\/exslt.org\/dates-and-times}date: \"\n-             \"invalid date or format %s\\n\", dt);\n-    xmlXPathReturnEmptyString(ctxt);\n-    } else {\n-    xmlXPathReturnString(ctxt, ret);\n-    }\n-\n-    if (dt != NULL)\n-    xmlFree(dt);\n-}\n-\n-\/**\n- * exsltDateTimeFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateTime() for use by the XPath engine.\n- *\/\n-static void\n-exsltDateTimeFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *ret, *dt = NULL;\n-\n-    if ((nargs < 0) || (nargs > 1)) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    if (nargs == 1) {\n-    dt = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlXPathSetTypeError(ctxt);\n-        return;\n-    }\n-    }\n-\n-    ret = exsltDateTime(dt);\n-\n-    if (ret == NULL) {\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"{http:\/\/exslt.org\/dates-and-times}time: \"\n-             \"invalid date or format %s\\n\", dt);\n-    xmlXPathReturnEmptyString(ctxt);\n-    } else {\n-    xmlXPathReturnString(ctxt, ret);\n-    }\n-\n-    if (dt != NULL)\n-    xmlFree(dt);\n-}\n-\n-\/**\n- * exsltDateYearFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateYear() for use by the XPath engine.\n- *\/\n-static void\n-exsltDateYearFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *dt = NULL;\n-    double ret;\n-\n-    if ((nargs < 0) || (nargs > 1)) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    if (nargs == 1) {\n-    dt = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlXPathSetTypeError(ctxt);\n-        return;\n-    }\n-    }\n-\n-    ret = exsltDateYear(dt);\n-\n-    if (dt != NULL)\n-    xmlFree(dt);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltDateLeapYearFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateLeapYear() for use by the XPath engine.\n- *\/\n-static void\n-exsltDateLeapYearFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *dt = NULL;\n-    xmlXPathObjectPtr ret;\n-\n-    if ((nargs < 0) || (nargs > 1)) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    if (nargs == 1) {\n-    dt = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlXPathSetTypeError(ctxt);\n-        return;\n-    }\n-    }\n-\n-    ret = exsltDateLeapYear(dt);\n-\n-    if (dt != NULL)\n-    xmlFree(dt);\n-\n-    valuePush(ctxt, ret);\n-}\n-\n-#define X_IN_Y(x, y)                        \\\n-static void                            \\\n-exsltDate##x##In##y##Function (xmlXPathParserContextPtr ctxt,    \\\n-                  int nargs) {            \\\n-    xmlChar *dt = NULL;                        \\\n-    double ret;                            \\\n-                                \\\n-    if ((nargs < 0) || (nargs > 1)) {                \\\n-    xmlXPathSetArityError(ctxt);                \\\n-    return;                            \\\n-    }                                \\\n-                                \\\n-    if (nargs == 1) {                        \\\n-    dt = xmlXPathPopString(ctxt);                \\\n-    if (xmlXPathCheckError(ctxt)) {                \\\n-        xmlXPathSetTypeError(ctxt);                \\\n-        return;                        \\\n-    }                            \\\n-    }                                \\\n-                                \\\n-    ret = exsltDate##x##In##y(dt);                \\\n-                                \\\n-    if (dt != NULL)                        \\\n-    xmlFree(dt);                        \\\n-                                \\\n-    xmlXPathReturnNumber(ctxt, ret);                \\\n-}\n-\n-\/**\n- * exsltDateMonthInYearFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateMonthInYear() for use by the XPath engine.\n- *\/\n-X_IN_Y(Month,Year)\n-\n-\/**\n- * exsltDateMonthNameFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateMonthName() for use by the XPath engine.\n- *\/\n-static void\n-exsltDateMonthNameFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *dt = NULL;\n-    const xmlChar *ret;\n-\n-    if ((nargs < 0) || (nargs > 1)) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    if (nargs == 1) {\n-    dt = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlXPathSetTypeError(ctxt);\n-        return;\n-    }\n-    }\n-\n-    ret = exsltDateMonthName(dt);\n-\n-    if (dt != NULL)\n-    xmlFree(dt);\n-\n-    if (ret == NULL)\n-    xmlXPathReturnEmptyString(ctxt);\n-    else\n-    xmlXPathReturnString(ctxt, xmlStrdup(ret));\n-}\n-\n-\/**\n- * exsltDateMonthAbbreviationFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateMonthAbbreviation() for use by the XPath engine.\n- *\/\n-static void\n-exsltDateMonthAbbreviationFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *dt = NULL;\n-    const xmlChar *ret;\n-\n-    if ((nargs < 0) || (nargs > 1)) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    if (nargs == 1) {\n-    dt = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlXPathSetTypeError(ctxt);\n-        return;\n-    }\n-    }\n-\n-    ret = exsltDateMonthAbbreviation(dt);\n-\n-    if (dt != NULL)\n-    xmlFree(dt);\n-\n-    if (ret == NULL)\n-    xmlXPathReturnEmptyString(ctxt);\n-    else\n-    xmlXPathReturnString(ctxt, xmlStrdup(ret));\n-}\n-\n-\/**\n- * exsltDateWeekInYearFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateWeekInYear() for use by the XPath engine.\n- *\/\n-X_IN_Y(Week,Year)\n-\n-\/**\n- * exsltDateWeekInMonthFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateWeekInMonthYear() for use by the XPath engine.\n- *\/\n-X_IN_Y(Week,Month)\n-\n-\/**\n- * exsltDateDayInYearFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateDayInYear() for use by the XPath engine.\n- *\/\n-X_IN_Y(Day,Year)\n-\n-\/**\n- * exsltDateDayInMonthFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateDayInMonth() for use by the XPath engine.\n- *\/\n-X_IN_Y(Day,Month)\n-\n-\/**\n- * exsltDateDayOfWeekInMonthFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDayOfWeekInMonth() for use by the XPath engine.\n- *\/\n-X_IN_Y(DayOfWeek,Month)\n-\n-\/**\n- * exsltDateDayInWeekFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateDayInWeek() for use by the XPath engine.\n- *\/\n-X_IN_Y(Day,Week)\n-\n-\/**\n- * exsltDateDayNameFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateDayName() for use by the XPath engine.\n- *\/\n-static void\n-exsltDateDayNameFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *dt = NULL;\n-    const xmlChar *ret;\n-\n-    if ((nargs < 0) || (nargs > 1)) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    if (nargs == 1) {\n-    dt = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlXPathSetTypeError(ctxt);\n-        return;\n-    }\n-    }\n-\n-    ret = exsltDateDayName(dt);\n-\n-    if (dt != NULL)\n-    xmlFree(dt);\n-\n-    if (ret == NULL)\n-    xmlXPathReturnEmptyString(ctxt);\n-    else\n-    xmlXPathReturnString(ctxt, xmlStrdup(ret));\n-}\n-\n-\/**\n- * exsltDateMonthDayFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateDayAbbreviation() for use by the XPath engine.\n- *\/\n-static void\n-exsltDateDayAbbreviationFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *dt = NULL;\n-    const xmlChar *ret;\n-\n-    if ((nargs < 0) || (nargs > 1)) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    if (nargs == 1) {\n-    dt = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlXPathSetTypeError(ctxt);\n-        return;\n-    }\n-    }\n-\n-    ret = exsltDateDayAbbreviation(dt);\n-\n-    if (dt != NULL)\n-    xmlFree(dt);\n-\n-    if (ret == NULL)\n-    xmlXPathReturnEmptyString(ctxt);\n-    else\n-    xmlXPathReturnString(ctxt, xmlStrdup(ret));\n-}\n-\n-\n-\/**\n- * exsltDateHourInDayFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateHourInDay() for use by the XPath engine.\n- *\/\n-X_IN_Y(Hour,Day)\n-\n-\/**\n- * exsltDateMinuteInHourFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateMinuteInHour() for use by the XPath engine.\n- *\/\n-X_IN_Y(Minute,Hour)\n-\n-\/**\n- * exsltDateSecondInMinuteFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateSecondInMinute() for use by the XPath engine.\n- *\/\n-X_IN_Y(Second,Minute)\n-\n-\/**\n- * exsltDateSecondsFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateSeconds() for use by the XPath engine.\n- *\/\n-static void\n-exsltDateSecondsFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *str = NULL;\n-    double   ret;\n-\n-    if (nargs > 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    if (nargs == 1) {\n-    str = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlXPathSetTypeError(ctxt);\n-        return;\n-    }\n-    }\n-\n-    ret = exsltDateSeconds(str);\n-    if (str != NULL)\n-    xmlFree(str);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltDateAddFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps exsltDateAdd() for use by the XPath processor.\n- *\/\n-static void\n-exsltDateAddFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *ret, *xstr, *ystr;\n-\n-    if (nargs != 2) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ystr = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    xstr = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlFree(ystr);\n-    return;\n-    }\n-\n-    ret = exsltDateAdd(xstr, ystr);\n-\n-    xmlFree(ystr);\n-    xmlFree(xstr);\n-\n-    if (ret == NULL)\n-        xmlXPathReturnEmptyString(ctxt);\n-    else\n-    xmlXPathReturnString(ctxt, ret);\n-}\n-\n-\/**\n- * exsltDateAddDurationFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps exsltDateAddDuration() for use by the XPath processor.\n- *\/\n-static void\n-exsltDateAddDurationFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *ret, *xstr, *ystr;\n-\n-    if (nargs != 2) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ystr = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    xstr = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlFree(ystr);\n-    return;\n-    }\n-\n-    ret = exsltDateAddDuration(xstr, ystr);\n-\n-    xmlFree(ystr);\n-    xmlFree(xstr);\n-\n-    if (ret == NULL)\n-        xmlXPathReturnEmptyString(ctxt);\n-    else\n-    xmlXPathReturnString(ctxt, ret);\n-}\n-\n-\/**\n- * exsltDateDifferenceFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps exsltDateDifference() for use by the XPath processor.\n- *\/\n-static void\n-exsltDateDifferenceFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *ret, *xstr, *ystr;\n-\n-    if (nargs != 2) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ystr = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    xstr = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlFree(ystr);\n-    return;\n-    }\n-\n-    ret = exsltDateDifference(xstr, ystr);\n-\n-    xmlFree(ystr);\n-    xmlFree(xstr);\n-\n-    if (ret == NULL)\n-        xmlXPathReturnEmptyString(ctxt);\n-    else\n-    xmlXPathReturnString(ctxt, ret);\n-}\n-\n-\/**\n- * exsltDateDurationFunction:\n- * @ctxt: an XPath parser context\n- * @nargs : the number of arguments\n- *\n- * Wraps exsltDateDuration() for use by the XPath engine\n- *\/\n-static void\n-exsltDateDurationFunction (xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *ret;\n-    xmlChar *number = NULL;\n-\n-    if ((nargs < 0) || (nargs > 1)) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    if (nargs == 1) {\n-    number = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlXPathSetTypeError(ctxt);\n-        return;\n-    }\n-    }\n-\n-    ret = exsltDateDuration(number);\n-\n-    if (number != NULL)\n-    xmlFree(number);\n-\n-    if (ret == NULL)\n-    xmlXPathReturnEmptyString(ctxt);\n-    else\n-    xmlXPathReturnString(ctxt, ret);\n-}\n-\n-\/**\n- * exsltDateRegister:\n- *\n- * Registers the EXSLT - Dates and Times module\n- *\/\n-void\n-exsltDateRegister (void)\n-{\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"add\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateAddFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"add-duration\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateAddDurationFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"date\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateDateFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"date-time\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateDateTimeFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"day-abbreviation\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateDayAbbreviationFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"day-in-month\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateDayInMonthFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"day-in-week\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateDayInWeekFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"day-in-year\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateDayInYearFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"day-name\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateDayNameFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"day-of-week-in-month\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateDayOfWeekInMonthFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"difference\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateDifferenceFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"duration\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateDurationFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"hour-in-day\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateHourInDayFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"leap-year\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateLeapYearFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"minute-in-hour\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateMinuteInHourFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"month-abbreviation\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateMonthAbbreviationFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"month-in-year\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateMonthInYearFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"month-name\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateMonthNameFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"second-in-minute\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateSecondInMinuteFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"seconds\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateSecondsFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"sum\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateSumFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"time\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateTimeFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"week-in-month\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateWeekInMonthFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"week-in-year\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateWeekInYearFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"year\",\n-                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                   exsltDateYearFunction);\n-}\n-\n-\/**\n- * exsltDateXpathCtxtRegister:\n- *\n- * Registers the EXSLT - Dates and Times module for use outside XSLT\n- *\/\n-int\n-exsltDateXpathCtxtRegister (xmlXPathContextPtr ctxt, const xmlChar *prefix)\n-{\n-    if (ctxt\n-        && prefix\n-        && !xmlXPathRegisterNs(ctxt,\n-                               prefix,\n-                               (const xmlChar *) EXSLT_DATE_NAMESPACE)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"add\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateAddFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"add-duration\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateAddDurationFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"date\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateDateFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"date-time\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateDateTimeFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"day-abbreviation\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateDayAbbreviationFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"day-in-month\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateDayInMonthFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"day-in-week\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateDayInWeekFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"day-in-year\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateDayInYearFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"day-name\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateDayNameFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"day-of-week-in-month\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateDayOfWeekInMonthFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"difference\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateDifferenceFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"duration\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateDurationFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"hour-in-day\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateHourInDayFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"leap-year\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateLeapYearFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"minute-in-hour\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateMinuteInHourFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"month-abbreviation\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateMonthAbbreviationFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"month-in-year\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateMonthInYearFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"month-name\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateMonthNameFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"second-in-minute\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateSecondInMinuteFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"seconds\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateSecondsFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"sum\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateSumFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"time\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateTimeFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"week-in-month\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateWeekInMonthFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"week-in-year\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateWeekInYearFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"year\",\n-                                   (const xmlChar *) EXSLT_DATE_NAMESPACE,\n-                                   exsltDateYearFunction)) {\n-        return 0;\n-    }\n-    return -1;\n-}\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/date.c","additions":0,"deletions":3956,"binary":false,"changes":3956,"status":"deleted"},{"patch":"@@ -1,296 +0,0 @@\n-\/*\n- * dynamic.c: Implementation of the EXSLT -- Dynamic module\n- *\n- * References:\n- *   http:\/\/www.exslt.org\/dyn\/dyn.html\n- *\n- * See Copyright for the status of this software.\n- *\n- * Authors:\n- *   Mark Vakoc <mark_vakoc@jdedwards.com>\n- *   Thomas Broyer <tbroyer@ltgt.net>\n- *\n- * TODO:\n- * elements:\n- * functions:\n- *    min\n- *    max\n- *    sum\n- *    map\n- *    closure\n- *\/\n-\n-#define IN_LIBEXSLT\n-#include \"libexslt\/libexslt.h\"\n-\n-#include <libxml\/tree.h>\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-\n-#include <libxslt\/xsltutils.h>\n-#include <libxslt\/xsltInternals.h>\n-#include <libxslt\/extensions.h>\n-\n-#include \"exslt.h\"\n-\n-\/**\n- * exsltDynEvaluateFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Evaluates the string as an XPath expression and returns the result\n- * value, which may be a boolean, number, string, node set, result tree\n- * fragment or external object.\n- *\/\n-\n-static void\n-exsltDynEvaluateFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlChar *str = NULL;\n-    xmlXPathObjectPtr ret = NULL;\n-\n-    if (ctxt == NULL)\n-        return;\n-    if (nargs != 1) {\n-        xsltPrintErrorContext(xsltXPathGetTransformContext(ctxt), NULL, NULL);\n-        xsltGenericError(xsltGenericErrorContext,\n-            \"dyn:evalute() : invalid number of args %d\\n\", nargs);\n-        ctxt->error = XPATH_INVALID_ARITY;\n-        return;\n-    }\n-    str = xmlXPathPopString(ctxt);\n-    \/* return an empty node-set if an empty string is passed in *\/\n-    if (!str||!xmlStrlen(str)) {\n-        if (str) xmlFree(str);\n-        valuePush(ctxt,xmlXPathNewNodeSet(NULL));\n-        return;\n-    }\n-#if LIBXML_VERSION >= 20911\n-        \/*\n-         * Recursive evaluation can grow the call stack quickly.\n-         *\/\n-        ctxt->context->depth += 5;\n-#endif\n-    ret = xmlXPathEval(str,ctxt->context);\n-#if LIBXML_VERSION >= 20911\n-        ctxt->context->depth -= 5;\n-#endif\n-    if (ret)\n-        valuePush(ctxt,ret);\n-    else {\n-        xsltGenericError(xsltGenericErrorContext,\n-            \"dyn:evaluate() : unable to evaluate expression '%s'\\n\",str);\n-        valuePush(ctxt,xmlXPathNewNodeSet(NULL));\n-    }\n-    xmlFree(str);\n-    return;\n-}\n-\n-\/**\n- * exsltDynMapFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Evaluates the string as an XPath expression and returns the result\n- * value, which may be a boolean, number, string, node set, result tree\n- * fragment or external object.\n- *\/\n-\n-static void\n-exsltDynMapFunction(xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xmlChar *str = NULL;\n-    xmlNodeSetPtr nodeset = NULL;\n-    xsltTransformContextPtr tctxt;\n-    xmlXPathCompExprPtr comp = NULL;\n-    xmlXPathObjectPtr ret = NULL;\n-    xmlDocPtr oldDoc, container = NULL;\n-    xmlNodePtr oldNode;\n-    int oldContextSize;\n-    int oldProximityPosition;\n-    int i, j;\n-\n-\n-    if (nargs != 2) {\n-        xmlXPathSetArityError(ctxt);\n-        return;\n-    }\n-    str = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-        goto cleanup;\n-\n-    nodeset = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-        goto cleanup;\n-\n-    ret = xmlXPathNewNodeSet(NULL);\n-    if (ret == NULL) {\n-        xsltGenericError(xsltGenericErrorContext,\n-                         \"exsltDynMapFunction: ret == NULL\\n\");\n-        goto cleanup;\n-    }\n-\n-    tctxt = xsltXPathGetTransformContext(ctxt);\n-    if (tctxt == NULL) {\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-          \"dyn:map : internal error tctxt == NULL\\n\");\n-    goto cleanup;\n-    }\n-\n-    if (str == NULL || !xmlStrlen(str) ||\n-        !(comp = xmlXPathCtxtCompile(tctxt->xpathCtxt, str)))\n-        goto cleanup;\n-\n-    oldDoc = ctxt->context->doc;\n-    oldNode = ctxt->context->node;\n-    oldContextSize = ctxt->context->contextSize;\n-    oldProximityPosition = ctxt->context->proximityPosition;\n-\n-        \/**\n-     * since we really don't know we're going to be adding node(s)\n-     * down the road we create the RVT regardless\n-     *\/\n-    container = xsltCreateRVT(tctxt);\n-    if (container == NULL) {\n-    xsltTransformError(tctxt, NULL, NULL,\n-          \"dyn:map : internal error container == NULL\\n\");\n-    goto cleanup;\n-    }\n-    xsltRegisterLocalRVT(tctxt, container);\n-    if (nodeset && nodeset->nodeNr > 0) {\n-        xmlXPathNodeSetSort(nodeset);\n-        ctxt->context->contextSize = nodeset->nodeNr;\n-        ctxt->context->proximityPosition = 0;\n-        for (i = 0; i < nodeset->nodeNr; i++) {\n-            xmlXPathObjectPtr subResult = NULL;\n-            xmlNodePtr cur = nodeset->nodeTab[i];\n-\n-            ctxt->context->proximityPosition++;\n-            ctxt->context->node = cur;\n-\n-            if (cur->type == XML_NAMESPACE_DECL) {\n-                \/*\n-                * The XPath module sets the owner element of a ns-node on\n-                * the ns->next field.\n-                *\/\n-                cur = (xmlNodePtr) ((xmlNsPtr) cur)->next;\n-                if ((cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {\n-                    xsltGenericError(xsltGenericErrorContext,\n-                        \"Internal error in exsltDynMapFunction: \"\n-                        \"Cannot retrieve the doc of a namespace node.\\n\");\n-                    continue;\n-                }\n-                ctxt->context->doc = cur->doc;\n-            } else {\n-                ctxt->context->doc = cur->doc;\n-            }\n-\n-            subResult = xmlXPathCompiledEval(comp, ctxt->context);\n-            if (subResult != NULL) {\n-                switch (subResult->type) {\n-                    case XPATH_NODESET:\n-                        if (subResult->nodesetval != NULL)\n-                            for (j = 0; j < subResult->nodesetval->nodeNr;\n-                                 j++)\n-                                xmlXPathNodeSetAdd(ret->nodesetval,\n-                                                   subResult->nodesetval->\n-                                                   nodeTab[j]);\n-                        break;\n-                    case XPATH_BOOLEAN:\n-                        if (container != NULL) {\n-                            xmlNodePtr newChildNode =\n-                                xmlNewTextChild((xmlNodePtr) container, NULL,\n-                                                BAD_CAST \"boolean\",\n-                                                BAD_CAST (subResult->\n-                                                boolval ? \"true\" : \"\"));\n-                            if (newChildNode != NULL) {\n-                                newChildNode->ns =\n-                                    xmlNewNs(newChildNode,\n-                                             BAD_CAST\n-                                             \"http:\/\/exslt.org\/common\",\n-                                             BAD_CAST \"exsl\");\n-                                xmlXPathNodeSetAddUnique(ret->nodesetval,\n-                                                         newChildNode);\n-                            }\n-                        }\n-                        break;\n-                    case XPATH_NUMBER:\n-                        if (container != NULL) {\n-                            xmlChar *val =\n-                                xmlXPathCastNumberToString(subResult->\n-                                                           floatval);\n-                            xmlNodePtr newChildNode =\n-                                xmlNewTextChild((xmlNodePtr) container, NULL,\n-                                                BAD_CAST \"number\", val);\n-                            if (val != NULL)\n-                                xmlFree(val);\n-\n-                            if (newChildNode != NULL) {\n-                                newChildNode->ns =\n-                                    xmlNewNs(newChildNode,\n-                                             BAD_CAST\n-                                             \"http:\/\/exslt.org\/common\",\n-                                             BAD_CAST \"exsl\");\n-                                xmlXPathNodeSetAddUnique(ret->nodesetval,\n-                                                         newChildNode);\n-                            }\n-                        }\n-                        break;\n-                    case XPATH_STRING:\n-                        if (container != NULL) {\n-                            xmlNodePtr newChildNode =\n-                                xmlNewTextChild((xmlNodePtr) container, NULL,\n-                                                BAD_CAST \"string\",\n-                                                subResult->stringval);\n-                            if (newChildNode != NULL) {\n-                                newChildNode->ns =\n-                                    xmlNewNs(newChildNode,\n-                                             BAD_CAST\n-                                             \"http:\/\/exslt.org\/common\",\n-                                             BAD_CAST \"exsl\");\n-                                xmlXPathNodeSetAddUnique(ret->nodesetval,\n-                                                         newChildNode);\n-                            }\n-                        }\n-                        break;\n-            default:\n-                        break;\n-                }\n-                xmlXPathFreeObject(subResult);\n-            }\n-        }\n-    }\n-    ctxt->context->doc = oldDoc;\n-    ctxt->context->node = oldNode;\n-    ctxt->context->contextSize = oldContextSize;\n-    ctxt->context->proximityPosition = oldProximityPosition;\n-\n-\n-  cleanup:\n-    \/* restore the xpath context *\/\n-    if (comp != NULL)\n-        xmlXPathFreeCompExpr(comp);\n-    if (nodeset != NULL)\n-        xmlXPathFreeNodeSet(nodeset);\n-    if (str != NULL)\n-        xmlFree(str);\n-    valuePush(ctxt, ret);\n-    return;\n-}\n-\n-\n-\/**\n- * exsltDynRegister:\n- *\n- * Registers the EXSLT - Dynamic module\n- *\/\n-\n-void\n-exsltDynRegister (void) {\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"evaluate\",\n-                   EXSLT_DYNAMIC_NAMESPACE,\n-                   exsltDynEvaluateFunction);\n-  xsltRegisterExtModuleFunction ((const xmlChar *) \"map\",\n-                   EXSLT_DYNAMIC_NAMESPACE,\n-                   exsltDynMapFunction);\n-\n-}\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/dynamic.c","additions":0,"deletions":296,"binary":false,"changes":296,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-#define IN_LIBEXSLT\n-#include \"libexslt\/libexslt.h\"\n-\n-#include <libxslt\/extensions.h>\n-\n-#include <libexslt\/exsltconfig.h>\n-#include \"exslt.h\"\n-\n-const char *exsltLibraryVersion = LIBEXSLT_VERSION_STRING\n-                LIBEXSLT_VERSION_EXTRA;\n-const int exsltLibexsltVersion = LIBEXSLT_VERSION;\n-const int exsltLibxsltVersion = LIBXSLT_VERSION;\n-const int exsltLibxmlVersion = LIBXML_VERSION;\n-\n-\/**\n- * exsltRegisterAll:\n- *\n- * Registers all available EXSLT extensions\n- *\/\n-void\n-exsltRegisterAll (void) {\n-    xsltInitGlobals();\n-    exsltCommonRegister();\n-#ifdef EXSLT_CRYPTO_ENABLED\n-    exsltCryptoRegister();\n-#endif\n-    exsltMathRegister();\n-    exsltSetsRegister();\n-    exsltFuncRegister();\n-    exsltStrRegister();\n-    exsltDateRegister();\n-    exsltSaxonRegister();\n-    exsltDynRegister();\n-}\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/exslt.c","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Summary: main header file\n- *\n- * Copy: See Copyright for the status of this software.\n- *\/\n-\n-\n-#ifndef __EXSLT_H__\n-#define __EXSLT_H__\n-\n-#include <libxml\/tree.h>\n-#include <libxml\/xpath.h>\n-#include \"exsltexports.h\"\n-#include <libexslt\/exsltconfig.h>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-EXSLTPUBVAR const char *exsltLibraryVersion;\n-EXSLTPUBVAR const int exsltLibexsltVersion;\n-EXSLTPUBVAR const int exsltLibxsltVersion;\n-EXSLTPUBVAR const int exsltLibxmlVersion;\n-\n-\/**\n- * EXSLT_COMMON_NAMESPACE:\n- *\n- * Namespace for EXSLT common functions\n- *\/\n-#define EXSLT_COMMON_NAMESPACE ((const xmlChar *) \"http:\/\/exslt.org\/common\")\n-\/**\n- * EXSLT_CRYPTO_NAMESPACE:\n- *\n- * Namespace for EXSLT crypto functions\n- *\/\n-#define EXSLT_CRYPTO_NAMESPACE ((const xmlChar *) \"http:\/\/exslt.org\/crypto\")\n-\/**\n- * EXSLT_MATH_NAMESPACE:\n- *\n- * Namespace for EXSLT math functions\n- *\/\n-#define EXSLT_MATH_NAMESPACE ((const xmlChar *) \"http:\/\/exslt.org\/math\")\n-\/**\n- * EXSLT_SETS_NAMESPACE:\n- *\n- * Namespace for EXSLT set functions\n- *\/\n-#define EXSLT_SETS_NAMESPACE ((const xmlChar *) \"http:\/\/exslt.org\/sets\")\n-\/**\n- * EXSLT_FUNCTIONS_NAMESPACE:\n- *\n- * Namespace for EXSLT functions extension functions\n- *\/\n-#define EXSLT_FUNCTIONS_NAMESPACE ((const xmlChar *) \"http:\/\/exslt.org\/functions\")\n-\/**\n- * EXSLT_STRINGS_NAMESPACE:\n- *\n- * Namespace for EXSLT strings functions\n- *\/\n-#define EXSLT_STRINGS_NAMESPACE ((const xmlChar *) \"http:\/\/exslt.org\/strings\")\n-\/**\n- * EXSLT_DATE_NAMESPACE:\n- *\n- * Namespace for EXSLT date functions\n- *\/\n-#define EXSLT_DATE_NAMESPACE ((const xmlChar *) \"http:\/\/exslt.org\/dates-and-times\")\n-\/**\n- * EXSLT_DYNAMIC_NAMESPACE:\n- *\n- * Namespace for EXSLT dynamic functions\n- *\/\n-#define EXSLT_DYNAMIC_NAMESPACE ((const xmlChar *) \"http:\/\/exslt.org\/dynamic\")\n-\n-\/**\n- * SAXON_NAMESPACE:\n- *\n- * Namespace for SAXON extensions functions\n- *\/\n-#define SAXON_NAMESPACE ((const xmlChar *) \"http:\/\/icl.com\/saxon\")\n-\n-EXSLTPUBFUN void EXSLTCALL exsltCommonRegister (void);\n-#ifdef EXSLT_CRYPTO_ENABLED\n-EXSLTPUBFUN void EXSLTCALL exsltCryptoRegister (void);\n-#endif\n-EXSLTPUBFUN void EXSLTCALL exsltMathRegister (void);\n-EXSLTPUBFUN void EXSLTCALL exsltSetsRegister (void);\n-EXSLTPUBFUN void EXSLTCALL exsltFuncRegister (void);\n-EXSLTPUBFUN void EXSLTCALL exsltStrRegister (void);\n-EXSLTPUBFUN void EXSLTCALL exsltDateRegister (void);\n-EXSLTPUBFUN void EXSLTCALL exsltSaxonRegister (void);\n-EXSLTPUBFUN void EXSLTCALL exsltDynRegister(void);\n-\n-EXSLTPUBFUN void EXSLTCALL exsltRegisterAll (void);\n-\n-EXSLTPUBFUN int EXSLTCALL exsltDateXpathCtxtRegister (xmlXPathContextPtr ctxt,\n-                                                      const xmlChar *prefix);\n-EXSLTPUBFUN int EXSLTCALL exsltMathXpathCtxtRegister (xmlXPathContextPtr ctxt,\n-                                                      const xmlChar *prefix);\n-EXSLTPUBFUN int EXSLTCALL exsltSetsXpathCtxtRegister (xmlXPathContextPtr ctxt,\n-                                                      const xmlChar *prefix);\n-EXSLTPUBFUN int EXSLTCALL exsltStrXpathCtxtRegister (xmlXPathContextPtr ctxt,\n-                                                     const xmlChar *prefix);\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-#endif \/* __EXSLT_H__ *\/\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/exslt.h","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * exsltconfig.h: compile-time version information for the EXSLT library\n- *\n- * See Copyright for the status of this software.\n- *\n- * daniel@veillard.com\n- *\/\n-\n-#ifndef __XML_EXSLTCONFIG_H__\n-#define __XML_EXSLTCONFIG_H__\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-\/**\n- * LIBEXSLT_DOTTED_VERSION:\n- *\n- * the version string like \"1.2.3\"\n- *\/\n-#define LIBEXSLT_DOTTED_VERSION \"@LIBEXSLT_VERSION@\"\n-\n-\/**\n- * LIBEXSLT_VERSION:\n- *\n- * the version number: 1.2.3 value is 10203\n- *\/\n-#define LIBEXSLT_VERSION 825\n-\n-\/**\n- * LIBEXSLT_VERSION_STRING:\n- *\n- * the version number string, 1.2.3 value is \"10203\"\n- *\/\n-#define LIBEXSLT_VERSION_STRING \"825\"\n-\n-\/**\n- * LIBEXSLT_VERSION_EXTRA:\n- *\n- * extra version information, used to show a Git commit description\n- *\/\n-#define    LIBEXSLT_VERSION_EXTRA \"\"\n-\n-\/**\n- * WITH_CRYPTO:\n- *\n- * Whether crypto support is configured into exslt\n- *\/\n-#if 1\n-#define EXSLT_CRYPTO_ENABLED\n-#endif\n-\n-\/**\n- * ATTRIBUTE_UNUSED:\n- *\n- * This macro is used to flag unused function parameters to GCC\n- *\/\n-#ifdef __GNUC__\n-#ifndef ATTRIBUTE_UNUSED\n-#define ATTRIBUTE_UNUSED __attribute__((unused))\n-#endif\n-#else\n-#define ATTRIBUTE_UNUSED\n-#endif\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif \/* __XML_EXSLTCONFIG_H__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/exsltconfig.h","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * exsltconfig.h: compile-time version information for the EXSLT library\n- *\n- * See Copyright for the status of this software.\n- *\n- * daniel@veillard.com\n- *\/\n-\n-#ifndef __XML_EXSLTCONFIG_H__\n-#define __XML_EXSLTCONFIG_H__\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-\/**\n- * LIBEXSLT_DOTTED_VERSION:\n- *\n- * the version string like \"1.2.3\"\n- *\/\n-#define LIBEXSLT_DOTTED_VERSION \"@LIBEXSLT_VERSION@\"\n-\n-\/**\n- * LIBEXSLT_VERSION:\n- *\n- * the version number: 1.2.3 value is 10203\n- *\/\n-#define LIBEXSLT_VERSION @LIBEXSLT_VERSION_NUMBER@\n-\n-\/**\n- * LIBEXSLT_VERSION_STRING:\n- *\n- * the version number string, 1.2.3 value is \"10203\"\n- *\/\n-#define LIBEXSLT_VERSION_STRING \"@LIBEXSLT_VERSION_NUMBER@\"\n-\n-\/**\n- * LIBEXSLT_VERSION_EXTRA:\n- *\n- * extra version information, used to show a Git commit description\n- *\/\n-#define\tLIBEXSLT_VERSION_EXTRA \"@LIBEXSLT_VERSION_EXTRA@\"\n-\n-\/**\n- * WITH_CRYPTO:\n- *\n- * Whether crypto support is configured into exslt\n- *\/\n-#if @WITH_CRYPTO@\n-#define EXSLT_CRYPTO_ENABLED\n-#endif\n-\n-\/**\n- * ATTRIBUTE_UNUSED:\n- *\n- * This macro is used to flag unused function parameters to GCC\n- *\/\n-#ifdef __GNUC__\n-#ifndef ATTRIBUTE_UNUSED\n-#define ATTRIBUTE_UNUSED __attribute__((unused))\n-#endif\n-#else\n-#define ATTRIBUTE_UNUSED\n-#endif\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif \/* __XML_EXSLTCONFIG_H__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/exsltconfig.h.in","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Summary: macros for marking symbols as exportable\/importable.\n- *\n- * Copy: See Copyright for the status of this software.\n- *\/\n-\n-#ifndef __EXSLT_EXPORTS_H__\n-#define __EXSLT_EXPORTS_H__\n-\n-#if defined(_WIN32) || defined(__CYGWIN__)\n-\/** DOC_DISABLE *\/\n-\n-#ifdef LIBEXSLT_STATIC\n-  #define EXSLTPUBLIC\n-#elif defined(IN_LIBEXSLT)\n-  #define EXSLTPUBLIC __declspec(dllexport)\n-#else\n-  #define EXSLTPUBLIC __declspec(dllimport)\n-#endif\n-\n-#define EXSLTCALL __cdecl\n-\n-\/** DOC_ENABLE *\/\n-#else \/* not Windows *\/\n-\n-\/**\n- * EXSLTPUBLIC:\n- *\n- * Macro which declares a public symbol\n- *\/\n-#define EXSLTPUBLIC\n-\n-\/**\n- * EXSLTCALL:\n- *\n- * Macro which declares the calling convention for exported functions\n- *\/\n-#define EXSLTCALL\n-\n-#endif \/* platform switch *\/\n-\n-\/*\n- * EXSLTPUBFUN:\n- *\n- * Macro which declares an exportable function\n- *\/\n-#define EXSLTPUBFUN EXSLTPUBLIC\n-\n-\/**\n- * EXSLTPUBVAR:\n- *\n- * Macro which declares an exportable variable\n- *\/\n-#define EXSLTPUBVAR EXSLTPUBLIC extern\n-\n-\/* Compatibility *\/\n-#if !defined(LIBEXSLT_PUBLIC)\n-#define LIBEXSLT_PUBLIC EXSLTPUBVAR\n-#endif\n-\n-#endif \/* __EXSLT_EXPORTS_H__ *\/\n-\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/exsltexports.h","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -1,832 +0,0 @@\n-#define IN_LIBEXSLT\n-#include \"libexslt\/libexslt.h\"\n-\n-#include <string.h>\n-\n-#include <libxml\/tree.h>\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-#include <libxml\/hash.h>\n-#include <libxml\/debugXML.h>\n-\n-#include <libxslt\/xsltutils.h>\n-#include <libxslt\/variables.h>\n-#include <libxslt\/xsltInternals.h>\n-#include <libxslt\/extensions.h>\n-#include <libxslt\/transform.h>\n-#include <libxslt\/imports.h>\n-\n-#include \"exslt.h\"\n-\n-typedef struct _exsltFuncFunctionData exsltFuncFunctionData;\n-struct _exsltFuncFunctionData {\n-    int nargs;            \/* number of arguments to the function *\/\n-    xmlNodePtr content;        \/* the func:fuction template content *\/\n-};\n-\n-typedef struct _exsltFuncData exsltFuncData;\n-struct _exsltFuncData {\n-    xmlHashTablePtr funcs;    \/* pointer to the stylesheet module data *\/\n-    xmlXPathObjectPtr result;    \/* returned by func:result *\/\n-    xsltStackElemPtr ctxtVar;   \/* context variable *\/\n-    int error;            \/* did an error occur? *\/\n-};\n-\n-typedef struct _exsltFuncResultPreComp exsltFuncResultPreComp;\n-struct _exsltFuncResultPreComp {\n-    xsltElemPreComp comp;\n-    xmlXPathCompExprPtr select;\n-    xmlNsPtr *nsList;\n-    int nsNr;\n-};\n-\n-\/* Used for callback function in exsltInitFunc *\/\n-typedef struct _exsltFuncImportRegData exsltFuncImportRegData;\n-struct _exsltFuncImportRegData {\n-    xsltTransformContextPtr ctxt;\n-    xmlHashTablePtr hash;\n-};\n-\n-static void exsltFuncFunctionFunction (xmlXPathParserContextPtr ctxt,\n-                       int nargs);\n-static exsltFuncFunctionData *exsltFuncNewFunctionData(void);\n-\n-\/*static const xmlChar *exsltResultDataID = (const xmlChar *) \"EXSLT Result\";*\/\n-\n-\/**\n- * exsltFuncRegisterFunc:\n- * @func:  the #exsltFuncFunctionData for the function\n- * @ctxt:  an XSLT transformation context\n- * @URI:  the function namespace URI\n- * @name: the function name\n- *\n- * Registers a function declared by a func:function element\n- *\/\n-static void\n-exsltFuncRegisterFunc (void *payload, void *vctxt,\n-               const xmlChar *URI, const xmlChar *name,\n-               ATTRIBUTE_UNUSED const xmlChar *ignored) {\n-    exsltFuncFunctionData *data = (exsltFuncFunctionData *) payload;\n-    xsltTransformContextPtr ctxt = (xsltTransformContextPtr) vctxt;\n-\n-    if ((data == NULL) || (ctxt == NULL) || (URI == NULL) || (name == NULL))\n-    return;\n-\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"exsltFuncRegisterFunc: register {%s}%s\\n\",\n-             URI, name);\n-    xsltRegisterExtFunction(ctxt, name, URI,\n-                exsltFuncFunctionFunction);\n-}\n-\n-\/*\n- * exsltFuncRegisterImportFunc\n- * @data:    the exsltFuncFunctionData for the function\n- * @ch:         structure containing context and hash table\n- * @URI:     the function namespace URI\n- * @name:    the function name\n- *\n- * Checks if imported function is already registered in top-level\n- * stylesheet.  If not, copies function data and registers function\n- *\/\n-static void\n-exsltFuncRegisterImportFunc (void *payload, void *vctxt,\n-                 const xmlChar *URI, const xmlChar *name,\n-                 ATTRIBUTE_UNUSED const xmlChar *ignored) {\n-    exsltFuncFunctionData *data = (exsltFuncFunctionData *) payload;\n-    exsltFuncImportRegData *ch = (exsltFuncImportRegData *) vctxt;\n-    exsltFuncFunctionData *func=NULL;\n-\n-    if ((data == NULL) || (ch == NULL) || (URI == NULL) || (name == NULL))\n-            return;\n-\n-    if (ch->ctxt == NULL || ch->hash == NULL)\n-    return;\n-\n-    \/* Check if already present *\/\n-    func = (exsltFuncFunctionData*)xmlHashLookup2(ch->hash, URI, name);\n-    if (func == NULL) {        \/* Not yet present - copy it in *\/\n-    func = exsltFuncNewFunctionData();\n-        if (func == NULL)\n-            return;\n-    memcpy(func, data, sizeof(exsltFuncFunctionData));\n-    if (xmlHashAddEntry2(ch->hash, URI, name, func) < 0) {\n-        xsltGenericError(xsltGenericErrorContext,\n-            \"Failed to register function {%s}%s\\n\",\n-            URI, name);\n-            xmlFree(func);\n-    } else {        \/* Do the registration *\/\n-        xsltGenericDebug(xsltGenericDebugContext,\n-                \"exsltFuncRegisterImportFunc: register {%s}%s\\n\",\n-            URI, name);\n-        xsltRegisterExtFunction(ch->ctxt, name, URI,\n-            exsltFuncFunctionFunction);\n-    }\n-    }\n-}\n-\n-\/**\n- * exsltFuncInit:\n- * @ctxt: an XSLT transformation context\n- * @URI: the namespace URI for the extension\n- *\n- * Initializes the EXSLT - Functions module.\n- * Called at transformation-time; merges all\n- * functions declared in the import tree taking\n- * import precedence into account, i.e. overriding\n- * functions with lower import precedence.\n- *\n- * Returns the data for this transformation\n- *\/\n-static void *\n-exsltFuncInit (xsltTransformContextPtr ctxt, const xmlChar *URI) {\n-    exsltFuncData *ret;\n-    xsltStylesheetPtr tmp;\n-    exsltFuncImportRegData ch;\n-    xmlHashTablePtr hash;\n-\n-    ret = (exsltFuncData *) xmlMalloc (sizeof(exsltFuncData));\n-    if (ret == NULL) {\n-    xsltGenericError(xsltGenericErrorContext,\n-             \"exsltFuncInit: not enough memory\\n\");\n-    return(NULL);\n-    }\n-    memset(ret, 0, sizeof(exsltFuncData));\n-\n-    ret->result = NULL;\n-    ret->error = 0;\n-\n-    ch.hash = (xmlHashTablePtr) xsltStyleGetExtData(ctxt->style, URI);\n-    ret->funcs = ch.hash;\n-    xmlHashScanFull(ch.hash, exsltFuncRegisterFunc, ctxt);\n-    tmp = ctxt->style;\n-    ch.ctxt = ctxt;\n-    while ((tmp=xsltNextImport(tmp))!=NULL) {\n-    hash = xsltGetExtInfo(tmp, URI);\n-    if (hash != NULL) {\n-        xmlHashScanFull(hash, exsltFuncRegisterImportFunc, &ch);\n-    }\n-    }\n-\n-    return(ret);\n-}\n-\n-\/**\n- * exsltFuncShutdown:\n- * @ctxt: an XSLT transformation context\n- * @URI: the namespace URI for the extension\n- * @data: the module data to free up\n- *\n- * Shutdown the EXSLT - Functions module\n- * Called at transformation-time.\n- *\/\n-static void\n-exsltFuncShutdown (xsltTransformContextPtr ctxt ATTRIBUTE_UNUSED,\n-           const xmlChar *URI ATTRIBUTE_UNUSED,\n-           void *vdata) {\n-    exsltFuncData *data = (exsltFuncData *) vdata;\n-\n-    if (data != NULL) {\n-        if (data->result != NULL)\n-            xmlXPathFreeObject(data->result);\n-        xmlFree(data);\n-    }\n-}\n-\n-\/**\n- * exsltFuncStyleInit:\n- * @style: an XSLT stylesheet\n- * @URI: the namespace URI for the extension\n- *\n- * Allocates the stylesheet data for EXSLT - Function\n- * Called at compile-time.\n- *\n- * Returns the allocated data\n- *\/\n-static void *\n-exsltFuncStyleInit (xsltStylesheetPtr style ATTRIBUTE_UNUSED,\n-            const xmlChar *URI ATTRIBUTE_UNUSED) {\n-    return xmlHashCreate(1);\n-}\n-\n-static void\n-exsltFuncFreeDataEntry(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {\n-    xmlFree(payload);\n-}\n-\n-\/**\n- * exsltFuncStyleShutdown:\n- * @style: an XSLT stylesheet\n- * @URI: the namespace URI for the extension\n- * @data: the stylesheet data to free up\n- *\n- * Shutdown the EXSLT - Function module\n- * Called at compile-time.\n- *\/\n-static void\n-exsltFuncStyleShutdown (xsltStylesheetPtr style ATTRIBUTE_UNUSED,\n-            const xmlChar *URI ATTRIBUTE_UNUSED,\n-            void *vdata) {\n-    xmlHashTablePtr data = (xmlHashTablePtr) vdata;\n-    xmlHashFree(data, exsltFuncFreeDataEntry);\n-}\n-\n-\/**\n- * exsltFuncNewFunctionData:\n- *\n- * Allocates an #exslFuncFunctionData object\n- *\n- * Returns the new structure\n- *\/\n-static exsltFuncFunctionData *\n-exsltFuncNewFunctionData (void) {\n-    exsltFuncFunctionData *ret;\n-\n-    ret = (exsltFuncFunctionData *) xmlMalloc (sizeof(exsltFuncFunctionData));\n-    if (ret == NULL) {\n-    xsltGenericError(xsltGenericErrorContext,\n-             \"exsltFuncNewFunctionData: not enough memory\\n\");\n-    return (NULL);\n-    }\n-    memset(ret, 0, sizeof(exsltFuncFunctionData));\n-\n-    ret->nargs = 0;\n-    ret->content = NULL;\n-\n-    return(ret);\n-}\n-\n-\/**\n- * exsltFreeFuncResultPreComp:\n- * @comp:  the #exsltFuncResultPreComp to free up\n- *\n- * Deallocates an #exsltFuncResultPreComp\n- *\/\n-static void\n-exsltFreeFuncResultPreComp (xsltElemPreCompPtr ecomp) {\n-    exsltFuncResultPreComp *comp = (exsltFuncResultPreComp *) ecomp;\n-\n-    if (comp == NULL)\n-    return;\n-\n-    if (comp->select != NULL)\n-    xmlXPathFreeCompExpr (comp->select);\n-    if (comp->nsList != NULL)\n-        xmlFree(comp->nsList);\n-    xmlFree(comp);\n-}\n-\n-\/**\n- * exsltFuncFunctionFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Evaluates the func:function element that defines the called function.\n- *\/\n-static void\n-exsltFuncFunctionFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlXPathObjectPtr oldResult, ret;\n-    exsltFuncData *data;\n-    exsltFuncFunctionData *func;\n-    xmlNodePtr paramNode, oldInsert, oldXPNode, fake;\n-    int oldBase, newBase;\n-    void *oldCtxtVar;\n-    xsltStackElemPtr params = NULL, param;\n-    xsltTransformContextPtr tctxt = xsltXPathGetTransformContext(ctxt);\n-    int i;\n-    xmlXPathObjectPtr *args = NULL;\n-\n-    \/*\n-     * retrieve func:function template\n-     *\/\n-    data = (exsltFuncData *) xsltGetExtData (tctxt,\n-                         EXSLT_FUNCTIONS_NAMESPACE);\n-    oldResult = data->result;\n-    data->result = NULL;\n-\n-    func = (exsltFuncFunctionData*) xmlHashLookup2 (data->funcs,\n-                            ctxt->context->functionURI,\n-                            ctxt->context->function);\n-    if (func == NULL) {\n-        \/* Should never happen *\/\n-        xsltGenericError(xsltGenericErrorContext,\n-                         \"{%s}%s: not found\\n\",\n-                         ctxt->context->functionURI, ctxt->context->function);\n-        ctxt->error = XPATH_UNKNOWN_FUNC_ERROR;\n-        return;\n-    }\n-\n-    \/*\n-     * params handling\n-     *\/\n-    if (nargs > func->nargs) {\n-    xsltGenericError(xsltGenericErrorContext,\n-             \"{%s}%s: called with too many arguments\\n\",\n-             ctxt->context->functionURI, ctxt->context->function);\n-    ctxt->error = XPATH_INVALID_ARITY;\n-    return;\n-    }\n-    if (func->content != NULL) {\n-    paramNode = func->content->prev;\n-    }\n-    else\n-    paramNode = NULL;\n-    if ((paramNode == NULL) && (func->nargs != 0)) {\n-    xsltGenericError(xsltGenericErrorContext,\n-             \"exsltFuncFunctionFunction: nargs != 0 and \"\n-             \"param == NULL\\n\");\n-    return;\n-    }\n-\n-    \/*\n-    * When a function is called recursively during evaluation of its\n-    * arguments, the recursion check in xsltApplySequenceConstructor\n-    * isn't reached.\n-    *\/\n-    if (tctxt->depth >= tctxt->maxTemplateDepth) {\n-        xsltTransformError(tctxt, NULL, NULL,\n-            \"exsltFuncFunctionFunction: Potentially infinite recursion \"\n-            \"detected in function {%s}%s.\\n\",\n-            ctxt->context->functionURI, ctxt->context->function);\n-        tctxt->state = XSLT_STATE_STOPPED;\n-        return;\n-    }\n-    tctxt->depth++;\n-\n-    \/* Evaluating templates can change the XPath context node. *\/\n-    oldXPNode = tctxt->xpathCtxt->node;\n-\n-    fake = xmlNewDocNode(tctxt->output, NULL,\n-             (const xmlChar *)\"fake\", NULL);\n-    if (fake == NULL)\n-        goto error;\n-    \/*\n-     * We have a problem with the evaluation of function parameters.\n-     * The original library code did not evaluate XPath expressions until\n-     * the last moment.  After version 1.1.17 of the libxslt, the logic\n-     * of other parts of the library was changed, and the evaluation of\n-     * XPath expressions within parameters now takes place as soon as the\n-     * parameter is parsed\/evaluated (xsltParseStylesheetCallerParam).\n-     * This means that the parameters need to be evaluated in lexical\n-     * order (since a variable is \"in scope\" as soon as it is declared).\n-     * However, on entry to this routine, the values (from the caller) are\n-     * in reverse order (held on the XPath context variable stack).  To\n-     * accomplish what is required, I have added code to pop the XPath\n-     * objects off of the stack at the beginning and save them, then use\n-     * them (in the reverse order) as the params are evaluated.  This\n-     * requires an xmlMalloc\/xmlFree for each param set by the caller,\n-     * which is not very nice.  There is probably a much better solution\n-     * (like change other code to delay the evaluation).\n-     *\/\n-    \/*\n-     * In order to give the function params and variables a new 'scope'\n-     * we change varsBase in the context.\n-     *\/\n-    newBase = tctxt->varsNr;\n-    \/* If there are any parameters *\/\n-    if (paramNode != NULL) {\n-        if (nargs > 0) {\n-            args = (xmlXPathObjectPtr *) xmlMalloc(sizeof(*args) * nargs);\n-            if (args == NULL)\n-                goto error;\n-            \/* Fetch the stored argument values from the caller *\/\n-            for (i = nargs - 1; i >= 0; i--) {\n-                args[i] = valuePop(ctxt);\n-            }\n-        }\n-\n-    \/*\n-     * Prepare to process params in reverse order.  First, go to\n-     * the beginning of the param chain.\n-     *\/\n-    for (i = 1; i <= func->nargs; i++) {\n-        if (paramNode->prev == NULL)\n-            break;\n-        paramNode = paramNode->prev;\n-    }\n-    \/*\n-     * i has total # params found, nargs is number which are present\n-     * as arguments from the caller\n-     * Calculate the number of un-set parameters\n-     *\/\n-    for (i = 0; i < func->nargs; i++) {\n-        param = xsltParseStylesheetCallerParam (tctxt, paramNode);\n-            if (param == NULL) {\n-                xsltLocalVariablePop(tctxt, newBase, -2);\n-            xsltFreeStackElemList(params);\n-                for (; i < nargs; i++)\n-                    xmlXPathFreeObject(args[i]);\n-                goto error;\n-            }\n-        if (i < nargs) {    \/* if parameter value set *\/\n-        param->computed = 1;\n-        if (param->value != NULL)\n-            xmlXPathFreeObject(param->value);\n-        param->value = args[i];\n-        }\n-        xsltLocalVariablePush(tctxt, param, -1);\n-        param->next = params;\n-        params = param;\n-        paramNode = paramNode->next;\n-    }\n-    }\n-    \/*\n-     * Actual processing. The context variable is cleared and restored\n-     * when func:result is evaluated.\n-     *\/\n-    oldBase = tctxt->varsBase;\n-    oldInsert = tctxt->insert;\n-    oldCtxtVar = data->ctxtVar;\n-    data->ctxtVar = tctxt->contextVariable;\n-    tctxt->varsBase = newBase;\n-    tctxt->insert = fake;\n-    tctxt->contextVariable = NULL;\n-    xsltApplyOneTemplate (tctxt, tctxt->node,\n-              func->content, NULL, NULL);\n-    xsltLocalVariablePop(tctxt, tctxt->varsBase, -2);\n-    tctxt->insert = oldInsert;\n-    tctxt->contextVariable = data->ctxtVar;\n-    tctxt->varsBase = oldBase;    \/* restore original scope *\/\n-    data->ctxtVar = oldCtxtVar;\n-    if (params != NULL)\n-    xsltFreeStackElemList(params);\n-    tctxt->xpathCtxt->node = oldXPNode;\n-\n-    if (data->error != 0)\n-        goto error;\n-\n-    if (data->result != NULL) {\n-    ret = data->result;\n-        \/*\n-        * IMPORTANT: This enables previously tree fragments marked as\n-        * being results of a function, to be garbage-collected after\n-        * the calling process exits.\n-        *\/\n-        xsltFlagRVTs(tctxt, ret, XSLT_RVT_LOCAL);\n-    } else\n-    ret = xmlXPathNewCString(\"\");\n-\n-    data->result = oldResult;\n-\n-    \/*\n-     * It is an error if the instantiation of the template results in\n-     * the generation of result nodes.\n-     *\/\n-    if (fake->children != NULL) {\n-    xsltGenericError(xsltGenericErrorContext,\n-             \"{%s}%s: cannot write to result tree while \"\n-             \"executing a function\\n\",\n-             ctxt->context->functionURI, ctxt->context->function);\n-        xmlXPathFreeObject(ret);\n-    goto error;\n-    }\n-    valuePush(ctxt, ret);\n-\n-error:\n-    xmlFree(args);\n-    xmlFreeNode(fake);\n-    tctxt->depth--;\n-}\n-\n-\n-static void\n-exsltFuncFunctionComp (xsltStylesheetPtr style, xmlNodePtr inst) {\n-    xmlChar *name, *prefix;\n-    xmlNsPtr ns;\n-    xmlHashTablePtr data;\n-    exsltFuncFunctionData *func;\n-\n-    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n-    return;\n-\n-    {\n-    xmlChar *qname;\n-\n-    qname = xmlGetProp(inst, (const xmlChar *) \"name\");\n-    name = xmlSplitQName2 (qname, &prefix);\n-    xmlFree(qname);\n-    }\n-    if ((name == NULL) || (prefix == NULL)) {\n-    xsltGenericError(xsltGenericErrorContext,\n-             \"func:function: not a QName\\n\");\n-    if (name != NULL)\n-        xmlFree(name);\n-    return;\n-    }\n-    \/* namespace lookup *\/\n-    ns = xmlSearchNs (inst->doc, inst, prefix);\n-    if (ns == NULL) {\n-    xsltGenericError(xsltGenericErrorContext,\n-             \"func:function: undeclared prefix %s\\n\",\n-             prefix);\n-    xmlFree(name);\n-    xmlFree(prefix);\n-    return;\n-    }\n-    xmlFree(prefix);\n-\n-    xsltParseTemplateContent(style, inst);\n-\n-    \/*\n-     * Create function data\n-     *\/\n-    func = exsltFuncNewFunctionData();\n-    if (func == NULL) {\n-        xmlFree(name);\n-        return;\n-    }\n-    func->content = inst->children;\n-    while (IS_XSLT_ELEM(func->content) &&\n-       IS_XSLT_NAME(func->content, \"param\")) {\n-    func->content = func->content->next;\n-    func->nargs++;\n-    }\n-\n-    \/*\n-     * Register the function data such that it can be retrieved\n-     * by exslFuncFunctionFunction\n-     *\/\n-#ifdef XSLT_REFACTORED\n-    \/*\n-    * Ensure that the hash table will be stored in the *current*\n-    * stylesheet level in order to correctly evaluate the\n-    * import precedence.\n-    *\/\n-    data = (xmlHashTablePtr)\n-    xsltStyleStylesheetLevelGetExtData(style,\n-        EXSLT_FUNCTIONS_NAMESPACE);\n-#else\n-    data = (xmlHashTablePtr)\n-    xsltStyleGetExtData (style, EXSLT_FUNCTIONS_NAMESPACE);\n-#endif\n-    if (data == NULL) {\n-    xsltGenericError(xsltGenericErrorContext,\n-             \"exsltFuncFunctionComp: no stylesheet data\\n\");\n-    xmlFree(name);\n-        xmlFree(func);\n-    return;\n-    }\n-\n-    if (xmlHashAddEntry2 (data, ns->href, name, func) < 0) {\n-    xsltTransformError(NULL, style, inst,\n-        \"Failed to register function {%s}%s\\n\",\n-             ns->href, name);\n-    style->errors++;\n-        xmlFree(func);\n-    } else {\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"exsltFuncFunctionComp: register {%s}%s\\n\",\n-             ns->href, name);\n-    }\n-    xmlFree(name);\n-}\n-\n-static xsltElemPreCompPtr\n-exsltFuncResultComp (xsltStylesheetPtr style, xmlNodePtr inst,\n-             xsltTransformFunction function) {\n-    xmlNodePtr test;\n-    xmlChar *sel;\n-    exsltFuncResultPreComp *ret;\n-\n-    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n-        return (NULL);\n-\n-    \/*\n-     * \"Validity\" checking\n-     *\/\n-    \/* it is an error to have any following sibling elements aside\n-     * from the xsl:fallback element.\n-     *\/\n-    for (test = inst->next; test != NULL; test = test->next) {\n-    if (test->type != XML_ELEMENT_NODE)\n-        continue;\n-    if (IS_XSLT_ELEM(test) && IS_XSLT_NAME(test, \"fallback\"))\n-        continue;\n-    xsltGenericError(xsltGenericErrorContext,\n-             \"exsltFuncResultElem: only xsl:fallback is \"\n-             \"allowed to follow func:result\\n\");\n-    style->errors++;\n-    return (NULL);\n-    }\n-    \/* it is an error for a func:result element to not be a descendant\n-     * of func:function.\n-     * it is an error if a func:result occurs within a func:result\n-     * element.\n-     * it is an error if instanciating the content of a variable\n-     * binding element (i.e. xsl:variable, xsl:param) results in the\n-     * instanciation of a func:result element.\n-     *\/\n-    for (test = inst->parent; test != NULL; test = test->parent) {\n-    if (IS_XSLT_ELEM(test) &&\n-        IS_XSLT_NAME(test, \"stylesheet\")) {\n-        xsltGenericError(xsltGenericErrorContext,\n-                 \"func:result element not a descendant \"\n-                 \"of a func:function\\n\");\n-        style->errors++;\n-        return (NULL);\n-    }\n-    if ((test->ns != NULL) &&\n-        (xmlStrEqual(test->ns->href, EXSLT_FUNCTIONS_NAMESPACE))) {\n-        if (xmlStrEqual(test->name, (const xmlChar *) \"function\")) {\n-        break;\n-        }\n-        if (xmlStrEqual(test->name, (const xmlChar *) \"result\")) {\n-        xsltGenericError(xsltGenericErrorContext,\n-                 \"func:result element not allowed within\"\n-                 \" another func:result element\\n\");\n-            style->errors++;\n-        return (NULL);\n-        }\n-    }\n-    if (IS_XSLT_ELEM(test) &&\n-        (IS_XSLT_NAME(test, \"variable\") ||\n-         IS_XSLT_NAME(test, \"param\"))) {\n-        xsltGenericError(xsltGenericErrorContext,\n-                 \"func:result element not allowed within\"\n-                 \" a variable binding element\\n\");\n-            style->errors++;\n-        return (NULL);\n-    }\n-    }\n-\n-    \/*\n-     * Precomputation\n-     *\/\n-    ret = (exsltFuncResultPreComp *)\n-    xmlMalloc (sizeof(exsltFuncResultPreComp));\n-    if (ret == NULL) {\n-    xsltPrintErrorContext(NULL, NULL, NULL);\n-        xsltGenericError(xsltGenericErrorContext,\n-                         \"exsltFuncResultComp : malloc failed\\n\");\n-        style->errors++;\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(exsltFuncResultPreComp));\n-\n-    xsltInitElemPreComp ((xsltElemPreCompPtr) ret, style, inst, function,\n-         exsltFreeFuncResultPreComp);\n-    ret->select = NULL;\n-\n-    \/*\n-     * Precompute the select attribute\n-     *\/\n-    sel = xmlGetNsProp(inst, (const xmlChar *) \"select\", NULL);\n-    if (sel != NULL) {\n-    ret->select = xsltXPathCompileFlags(style, sel, 0);\n-    xmlFree(sel);\n-    }\n-    \/*\n-     * Precompute the namespace list\n-     *\/\n-    ret->nsList = xmlGetNsList(inst->doc, inst);\n-    if (ret->nsList != NULL) {\n-        int i = 0;\n-        while (ret->nsList[i] != NULL)\n-        i++;\n-    ret->nsNr = i;\n-    }\n-    return ((xsltElemPreCompPtr) ret);\n-}\n-\n-static void\n-exsltFuncResultElem (xsltTransformContextPtr ctxt,\n-                 xmlNodePtr node ATTRIBUTE_UNUSED, xmlNodePtr inst,\n-             xsltElemPreCompPtr ecomp) {\n-    exsltFuncResultPreComp *comp = (exsltFuncResultPreComp *) ecomp;\n-    exsltFuncData *data;\n-    xmlXPathObjectPtr ret;\n-\n-\n-    \/* It is an error if instantiating the content of the\n-     * func:function element results in the instantiation of more than\n-     * one func:result elements.\n-     *\/\n-    data = (exsltFuncData *) xsltGetExtData (ctxt, EXSLT_FUNCTIONS_NAMESPACE);\n-    if (data == NULL) {\n-    xsltGenericError(xsltGenericErrorContext,\n-             \"exsltFuncReturnElem: data == NULL\\n\");\n-    return;\n-    }\n-    if (data->result != NULL) {\n-    xsltGenericError(xsltGenericErrorContext,\n-             \"func:result already instanciated\\n\");\n-    data->error = 1;\n-    return;\n-    }\n-    \/*\n-     * Restore context variable, so that it will receive the function\n-     * result RVTs.\n-     *\/\n-    ctxt->contextVariable = data->ctxtVar;\n-    \/*\n-     * Processing\n-     *\/\n-    if (comp->select != NULL) {\n-    xmlNsPtr *oldXPNsList;\n-    int oldXPNsNr;\n-    xmlNodePtr oldXPContextNode;\n-    \/* If the func:result element has a select attribute, then the\n-     * value of the attribute must be an expression and the\n-     * returned value is the object that results from evaluating\n-     * the expression. In this case, the content must be empty.\n-     *\/\n-    if (inst->children != NULL) {\n-        xsltGenericError(xsltGenericErrorContext,\n-                 \"func:result content must be empty if\"\n-                 \" the function has a select attribute\\n\");\n-        data->error = 1;\n-        return;\n-    }\n-    oldXPNsList = ctxt->xpathCtxt->namespaces;\n-    oldXPNsNr = ctxt->xpathCtxt->nsNr;\n-    oldXPContextNode = ctxt->xpathCtxt->node;\n-\n-    ctxt->xpathCtxt->namespaces = comp->nsList;\n-    ctxt->xpathCtxt->nsNr = comp->nsNr;\n-        ctxt->xpathCtxt->node = ctxt->node;\n-\n-    ret = xmlXPathCompiledEval(comp->select, ctxt->xpathCtxt);\n-\n-    ctxt->xpathCtxt->node = oldXPContextNode;\n-    ctxt->xpathCtxt->nsNr = oldXPNsNr;\n-    ctxt->xpathCtxt->namespaces = oldXPNsList;\n-\n-    if (ret == NULL) {\n-        xsltGenericError(xsltGenericErrorContext,\n-                 \"exsltFuncResultElem: ret == NULL\\n\");\n-        return;\n-    }\n-    \/*\n-    * Mark it as a function result in order to avoid garbage\n-    * collecting of tree fragments before the function exits.\n-    *\/\n-    xsltFlagRVTs(ctxt, ret, XSLT_RVT_FUNC_RESULT);\n-    } else if (inst->children != NULL) {\n-    \/* If the func:result element does not have a select attribute\n-     * and has non-empty content (i.e. the func:result element has\n-     * one or more child nodes), then the content of the\n-     * func:result element specifies the value.\n-     *\/\n-    xmlNodePtr oldInsert;\n-    xmlDocPtr container;\n-\n-    container = xsltCreateRVT(ctxt);\n-    if (container == NULL) {\n-        xsltGenericError(xsltGenericErrorContext,\n-                 \"exsltFuncResultElem: out of memory\\n\");\n-        data->error = 1;\n-        return;\n-    }\n-        \/* Mark as function result. *\/\n-        xsltRegisterLocalRVT(ctxt, container);\n-        container->compression = XSLT_RVT_FUNC_RESULT;\n-\n-    oldInsert = ctxt->insert;\n-    ctxt->insert = (xmlNodePtr) container;\n-    xsltApplyOneTemplate (ctxt, ctxt->node,\n-                  inst->children, NULL, NULL);\n-    ctxt->insert = oldInsert;\n-\n-    ret = xmlXPathNewValueTree((xmlNodePtr) container);\n-    if (ret == NULL) {\n-        xsltGenericError(xsltGenericErrorContext,\n-                 \"exsltFuncResultElem: ret == NULL\\n\");\n-        data->error = 1;\n-    } else {\n-            \/*\n-             * This stops older libxml2 versions from freeing the nodes\n-             * in the tree.\n-             *\/\n-        ret->boolval = 0;\n-    }\n-    } else {\n-    \/* If the func:result element has empty content and does not\n-     * have a select attribute, then the returned value is an\n-     * empty string.\n-     *\/\n-    ret = xmlXPathNewCString(\"\");\n-    }\n-    data->result = ret;\n-}\n-\n-\/**\n- * exsltFuncRegister:\n- *\n- * Registers the EXSLT - Functions module\n- *\/\n-void\n-exsltFuncRegister (void) {\n-    xsltRegisterExtModuleFull (EXSLT_FUNCTIONS_NAMESPACE,\n-               exsltFuncInit,\n-               exsltFuncShutdown,\n-               exsltFuncStyleInit,\n-               exsltFuncStyleShutdown);\n-\n-    xsltRegisterExtModuleTopLevel ((const xmlChar *) \"function\",\n-                   EXSLT_FUNCTIONS_NAMESPACE,\n-                   exsltFuncFunctionComp);\n-    xsltRegisterExtModuleElement ((const xmlChar *) \"result\",\n-              EXSLT_FUNCTIONS_NAMESPACE,\n-              exsltFuncResultComp,\n-              exsltFuncResultElem);\n-}\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/functions.c","additions":0,"deletions":832,"binary":false,"changes":832,"status":"deleted"},{"patch":"@@ -1,270 +0,0 @@\n-.TH LIBEXSLT 3 \"04 November 2003\" libxslt\n-.SH NAME\n-libexslt \\- extension library for XSLT\n-.SH SYNOPSIS\n-.B #include <libexslt\/exslt.h>\n-.sp\n-.B void exsltCommonRegister(void);\n-.br\n-.B void exsltDateRegister(void);\n-.br\n-.B void exsltDynRegister(void);\n-.br\n-.B void exsltFuncRegister(void);\n-.br\n-.B void exsltMathRegister(void);\n-.br\n-.B void exsltSetsRegister(void);\n-.br\n-.B void exsltStrRegister(void);\n-.br\n-.B void exsltRegisterAll(void);\n-.br\n-.B void exsltSaxonRegister(void);\n-.SH DESCRIPTION\n-The \n-.B libexslt\n-library is used to provide extensions to\n-.SM XSLT\n-functions. These extensions come from the\n-.SM EXSLT\n-project <http:\/\/www.exslt.org\/>\n-.LP\n-.SH USAGE\n-To make use of these functions in\n-.SM XSLT\n-the appropriate namespace must be defined on the\n-.B xsl:stylesheet\n-element.  To enable support for them in \n-.BR libxslt (3)\n-you must call the appropriate functions (listed in the\n-.B SYNOPSIS\n-section) to register the extensions.  The\n-.I xslt-config\n-shell script can be used to obtain the necessary flags for\n-the pre-processor and linker.\n-The supported extensions are:\n-.SS COMMON\n-.TP 2.2i\n-Namespace: http:\/\/exslt.org\/common\n-.TP 2.2i\n-See http:\/\/www.exslt.org\/exsl\/index.html for a description.\n-.TP 2.2i\n-.B node-set()\n-convert the given RTF into a node-set.\n-.TP\n-.B object-type()\n-returns the type of the given argument.\n-.TP\n-.B document\n-Create multiple output documents. See http:\/\/www.exslt.org\/exsl\/elements\/document\/index.html\n-\n-.SS MATH\n-.TP 2.2i\n-Namespace: http:\/\/exslt.org\/math\n-.TP 2.2i\n-See http:\/\/www.exslt.org\/math\/index.html for a description.\n-.TP 2.2i\n-.B min()\n-returns the minimum value of the given node-set\n-.TP\n-.B max()\n-returns the maximum value of the given node-set\n-.TP\n-.B highest()\n-returns the nodes in the node-set whose value is the maximum value for the node-set.\n-.TP\n-.B lowest()\n-returns the nodes in the node-set whose value is the minimum value for the node-set.\n-.TP\n-.B constant()\n-returns a number value of the given constant with the given precision. The constants are PI, E, SQRRT2, LN2, LN10, LOG2E, and SQRT1_2.\n-.TP\n-.B random()\n-returns a random number between 0 and 1 inclusive.\n-.TP\n-.B abs()\n-returns the absolute value of the argument.\n-.TP\n-.B sqrt()\n-returns the square root of the argument.\n-.TP\n-.B power()\n-returns the power base and power arguments.\n-.TP\n-.B log()\n-returns the natural log of the argument.\n-.TP\n-.B sin()\n-returns the sine of the argument.\n-.TP\n-.B cos()\n-returns the cosine of the argument.\n-.TP\n-.B tan()\n-returns the tangent of the argument.\n-.TP\n-.B asin()\n-returns the arc sine of the argument.\n-.TP\n-.B acos()\n-returns the arc cosine of the argument.\n-.TP\n-.B atan()\n-returns the arc tangent of the argument.\n-.TP\n-.B atan2()\n-returns the arc tangent function of the y\/x arguments.\n-.TP\n-.B exp()\n-returns the exponential function of the argument.\n-\n-.SS SETS\n-.TP 2.2i\n-Namespace: http:\/\/exslt.org\/sets\n-.TP 2.2i\n-See http:\/\/www.exslt.org\/set\/index.html for a description.\n-.TP 2.2i\n-.B difference()\n-returns the difference between the two given node-sets.\n-.TP\n-.B intersection()\n-returns a node-set of the nodes within both given node-sets.\n-.TP\n-.B distinct()\n-returns a node-set of all nodes in the first argument that are not in the seconds argument.\n-.TP\n-.B has-same-node()\n-returns TRUE if there is an intersection between the two given node-sets.\n-.TP\n-.B leading()\n-returns a node-set of all nodes in the first argument that precede the first node in the second argument.\n-.TP\n-.B trailing()\n-returns a node-set of all nodes in the first argument that follow the first node in the second argument.\n-\n-.SS \"DATES and TIMES\"\n-.TP 2.2i\n-Namespace: http:\/\/exslt.org\/dates-and-times\n-.TP 2.2i\n-See http:\/\/www.exslt.org\/date\/date.html for a description.\n-.TP 2.2i\n-.B date-time()\n-returns the current date and time as a date\/time string.\n-.TP\n-.B date()\n-returns the date specified in the given date\/time string.\n-.TP\n-.B time()\n-returns the time specified in the date\/time string given as the argument.\n-.TP\n-.B year()\n-returns the year of a date as a number.\n-.TP\n-.B leap-year()\n-returns true if the year given in a date is a leap year.\n-.TP\n-.B month-in-year()\n-returns the month of a date as a number.\n-.TP\n-.B month-name()\n-returns the full name of the month of a date.\n-.TP\n-.B month-abbreviation()\n-returns the abbreviation of the month of a date.\n-.TP\n-.B week-in-year()\n-returns the week of the year as a number.\n-.TP\n-.B week-in-month()\n-returns the week in a month of a date as a number.\n-.TP\n-.B day-in-year()\n-returns the month of a date as a number.\n-.TP\n-.B day-in-month()\n-returns the day of a date as a number.\n-.TP\n-.B day-of-week-in-month()\n-returns the day-of-the-week in a month of a date as a number.\n-.TP\n-.B day-in-week()\n-returns the day of the week given in a date as a number.\n-.TP\n-.B day-name()\n-returns the full name of the day of the week of a date.\n-.TP\n-.B day-abbreviation()\n-returns the abbreviation of the day of the week of a date.\n-.TP\n-.B hour-in-day()\n-returns the hour of the day as a number.\n-.TP\n-.B minute-in-hour()\n-returns the minute of the hour as a number.\n-.TP\n-.B second-in-minute()\n-returns the second of the minute as a number.\n-.TP\n-.B seconds()\n-returns the number of seconds specified by the argument string.\n-.TP\n-.B add()\n-returns the date\/time resulting from adding a duration to a date\/time. \n-.TP\n-.B add-duration()\n-returns the duration resulting from adding two given durations together. \n-.TP\n-.B difference()\n-returns the duration between the first date and the second date.\n-.TP\n-.B duration()\n-returns a duration string that represents the given number of seconds since 1970-01-01T00:00:00.\n-\n-.SS STRINGS\n-.TP 2.2i\n-Namespace: http:\/\/exslt.org\/strings\n-.TP 2.2i\n-See http:\/\/www.exslt.org\/str\/index.html for a description.\n-.TP 2.2i\n-.B tokenize()\n-returns a node set of token elements, each containing one token from the string.\n-.TP\n-.B padding()\n-returns a string padded to a certain length.\n-.TP\n-.B align()\n-returns a string aligned within another string.\n-.TP\n-.B concat()\n-returns the concatenation of the string values of the nodes in that node set.\n-\n-.SS FUNCTIONS\n-.TP 2.2i\n-Namespace: http:\/\/exslt.org\/functions\n-.TP 2.2i\n-See http:\/\/www.exslt.org\/func\/index.html for a description.\n-.TP 2.2i\n-.B function\n-declares an extension function.\n-.TP\n-.B result\n-returns the result of an extension function declared in function().\n-.SH FILES\n-.TP\n-.I \/usr\/bin\/xslt-config\n-shell script giving pre-processor and linker flags.\n-.TP\n-.I \/usr\/lib\/libexslt.a\n-static library\n-.TP\n-.I \/usr\/lib\/libexslt.so\n-sharable library\n-.SH AUTHORS\n-Manual page by Heiko W. Rupp (hwr@pilhuhn.de)\n-.SH \"SEE ALSO\"\n-.BR libxml (3), \n-.BR libxslt (3), \n-.BR xmllint (1)\n-.BR xsltproc (1), \n-.\\\" end of manual page\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/libexslt.3","additions":0,"deletions":270,"binary":false,"changes":270,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * libexslt.h: internal header only used during the compilation of libexslt\n- *\n- * See COPYRIGHT for the status of this software\n- *\n- * Author: daniel@veillard.com\n- *\/\n-\n-#ifndef __XSLT_LIBEXSLT_H__\n-#define __XSLT_LIBEXSLT_H__\n-\n-#if defined(_WIN32) && !defined (__MINGW32__)\n-#include <win32config.h>\n-#else\n-#include \"config.h\"\n-#endif\n-\n-#include <libxslt\/xsltconfig.h>\n-#include <libxml\/xmlversion.h>\n-\n-#if !defined LIBEXSLT_PUBLIC\n-#if (defined (__CYGWIN__) || defined _MSC_VER) && !defined IN_LIBEXSLT && !defined LIBEXSLT_STATIC\n-#define LIBEXSLT_PUBLIC __declspec(dllimport)\n-#else\n-#define LIBEXSLT_PUBLIC\n-#endif\n-#endif\n-\n-#ifdef __GNUC__\n-#define ATTRIBUTE_UNUSED __attribute__((unused))\n-#else\n-#define ATTRIBUTE_UNUSED\n-#endif\n-\n-#endif \/* ! __XSLT_LIBEXSLT_H__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/libexslt.h","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,1173 +0,0 @@\n-#define IN_LIBEXSLT\n-#include \"libexslt\/libexslt.h\"\n-\n-#include <libxml\/tree.h>\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-\n-#include <libxslt\/xsltutils.h>\n-#include <libxslt\/xsltInternals.h>\n-#include <libxslt\/extensions.h>\n-\n-#include <math.h>\n-#include <stdlib.h>\n-\n-#include \"exslt.h\"\n-\n-\/**\n- * exsltMathMin:\n- * @ns:  a node-set\n- *\n- * Implements the EXSLT - Math min() function:\n- *    number math:min (node-set)\n- *\n- * Returns the minimum value of the nodes passed as the argument, or\n- *         NAN if @ns is NULL or empty or if one of the nodes\n- *         turns into NaN.\n- *\/\n-static double\n-exsltMathMin (xmlNodeSetPtr ns) {\n-    double ret, cur;\n-    int i;\n-\n-    if ((ns == NULL) || (ns->nodeNr == 0))\n-    return(NAN);\n-    ret = xmlXPathCastNodeToNumber(ns->nodeTab[0]);\n-    if (xmlXPathIsNaN(ret))\n-    return(NAN);\n-    for (i = 1; i < ns->nodeNr; i++) {\n-    cur = xmlXPathCastNodeToNumber(ns->nodeTab[i]);\n-    if (xmlXPathIsNaN(cur))\n-        return(NAN);\n-    if (cur < ret)\n-        ret = cur;\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathMinFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathMin for use by the XPath processor.\n- *\/\n-static void\n-exsltMathMinFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlNodeSetPtr ns;\n-    double ret;\n-    void *user = NULL;\n-\n-    if (nargs != 1) {\n-    xsltGenericError(xsltGenericErrorContext,\n-             \"math:min: invalid number of arguments\\n\");\n-    ctxt->error = XPATH_INVALID_ARITY;\n-    return;\n-    }\n-    \/* We need to delay the freeing of value->user *\/\n-    if ((ctxt->value != NULL) && (ctxt->value->boolval != 0)) {\n-        user = ctxt->value->user;\n-    ctxt->value->boolval = 0;\n-    ctxt->value->user = NULL;\n-    }\n-    ns = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathMin(ns);\n-\n-    xmlXPathFreeNodeSet(ns);\n-    if (user != NULL)\n-        xmlFreeNodeList((xmlNodePtr)user);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathMax:\n- * @ns:  a node-set\n- *\n- * Implements the EXSLT - Math max() function:\n- *    number math:max (node-set)\n- *\n- * Returns the maximum value of the nodes passed as arguments, or\n- *         NAN if @ns is NULL or empty or if one of the nodes\n- *         turns into NaN.\n- *\/\n-static double\n-exsltMathMax (xmlNodeSetPtr ns) {\n-    double ret, cur;\n-    int i;\n-\n-    if ((ns == NULL) || (ns->nodeNr == 0))\n-    return(NAN);\n-    ret = xmlXPathCastNodeToNumber(ns->nodeTab[0]);\n-    if (xmlXPathIsNaN(ret))\n-    return(NAN);\n-    for (i = 1; i < ns->nodeNr; i++) {\n-    cur = xmlXPathCastNodeToNumber(ns->nodeTab[i]);\n-    if (xmlXPathIsNaN(cur))\n-        return(NAN);\n-    if (cur > ret)\n-        ret = cur;\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathMaxFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathMax for use by the XPath processor.\n- *\/\n-static void\n-exsltMathMaxFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlNodeSetPtr ns;\n-    double ret;\n-    void *user = NULL;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    \/* We need to delay the freeing of value->user *\/\n-    if ((ctxt->value != NULL) && (ctxt->value->boolval != 0)) {\n-    user = ctxt->value->user;\n-    ctxt->value->boolval = 0;\n-    ctxt->value->user = 0;\n-    }\n-    ns = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathMax(ns);\n-\n-    xmlXPathFreeNodeSet(ns);\n-\n-    if (user != NULL)\n-        xmlFreeNodeList((xmlNodePtr)user);\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathHighest:\n- * @ns:  a node-set\n- *\n- * Implements the EXSLT - Math highest() function:\n- *    node-set math:highest (node-set)\n- *\n- * Returns the nodes in the node-set whose value is the maximum value\n- *         for the node-set.\n- *\/\n-static xmlNodeSetPtr\n-exsltMathHighest (xmlNodeSetPtr ns) {\n-    xmlNodeSetPtr ret = xmlXPathNodeSetCreate(NULL);\n-    double max, cur;\n-    int i;\n-\n-    if ((ns == NULL) || (ns->nodeNr == 0))\n-    return(ret);\n-\n-    max = xmlXPathCastNodeToNumber(ns->nodeTab[0]);\n-    if (xmlXPathIsNaN(max))\n-    return(ret);\n-    else\n-    xmlXPathNodeSetAddUnique(ret, ns->nodeTab[0]);\n-\n-    for (i = 1; i < ns->nodeNr; i++) {\n-    cur = xmlXPathCastNodeToNumber(ns->nodeTab[i]);\n-    if (xmlXPathIsNaN(cur)) {\n-        xmlXPathEmptyNodeSet(ret);\n-        return(ret);\n-    }\n-    if (cur < max)\n-        continue;\n-    if (cur > max) {\n-        max = cur;\n-        xmlXPathEmptyNodeSet(ret);\n-        xmlXPathNodeSetAddUnique(ret, ns->nodeTab[i]);\n-        continue;\n-    }\n-    xmlXPathNodeSetAddUnique(ret, ns->nodeTab[i]);\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathHighestFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathHighest for use by the XPath processor\n- *\/\n-static void\n-exsltMathHighestFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlNodeSetPtr ns, ret;\n-    void *user = NULL;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    \/* We need to delay the freeing of value->user *\/\n-    if ((ctxt->value != NULL) && ctxt->value->boolval != 0) {\n-        user = ctxt->value->user;\n-    ctxt->value->boolval = 0;\n-    ctxt->value->user = NULL;\n-    }\n-    ns = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathHighest(ns);\n-\n-    xmlXPathFreeNodeSet(ns);\n-    if (user != NULL)\n-        xmlFreeNodeList((xmlNodePtr)user);\n-\n-    xmlXPathReturnNodeSet(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathLowest:\n- * @ns:  a node-set\n- *\n- * Implements the EXSLT - Math lowest() function\n- *    node-set math:lowest (node-set)\n- *\n- * Returns the nodes in the node-set whose value is the minimum value\n- *         for the node-set.\n- *\/\n-static xmlNodeSetPtr\n-exsltMathLowest (xmlNodeSetPtr ns) {\n-    xmlNodeSetPtr ret = xmlXPathNodeSetCreate(NULL);\n-    double min, cur;\n-    int i;\n-\n-    if ((ns == NULL) || (ns->nodeNr == 0))\n-    return(ret);\n-\n-    min = xmlXPathCastNodeToNumber(ns->nodeTab[0]);\n-    if (xmlXPathIsNaN(min))\n-    return(ret);\n-    else\n-    xmlXPathNodeSetAddUnique(ret, ns->nodeTab[0]);\n-\n-    for (i = 1; i < ns->nodeNr; i++) {\n-    cur = xmlXPathCastNodeToNumber(ns->nodeTab[i]);\n-    if (xmlXPathIsNaN(cur)) {\n-        xmlXPathEmptyNodeSet(ret);\n-        return(ret);\n-    }\n-        if (cur > min)\n-        continue;\n-    if (cur < min) {\n-        min = cur;\n-        xmlXPathEmptyNodeSet(ret);\n-        xmlXPathNodeSetAddUnique(ret, ns->nodeTab[i]);\n-            continue;\n-    }\n-    xmlXPathNodeSetAddUnique(ret, ns->nodeTab[i]);\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathLowestFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathLowest for use by the XPath processor\n- *\/\n-static void\n-exsltMathLowestFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlNodeSetPtr ns, ret;\n-    void *user = NULL;\n-\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    \/* We need to delay the freeing of value->user *\/\n-    if ((ctxt->value != NULL) && (ctxt->value->boolval != 0)) {\n-        user = ctxt->value->user;\n-    ctxt->value->boolval = 0;\n-    ctxt->value->user = NULL;\n-    }\n-    ns = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathLowest(ns);\n-\n-    xmlXPathFreeNodeSet(ns);\n-    if (user != NULL)\n-        xmlFreeNodeList((xmlNodePtr)user);\n-\n-    xmlXPathReturnNodeSet(ctxt, ret);\n-}\n-\n-\/* math other functions *\/\n-\n-\/* constant values *\/\n-#define EXSLT_PI        (const xmlChar *) \\\n-            \"3.1415926535897932384626433832795028841971693993751\"\n-#define EXSLT_E         (const xmlChar *) \\\n-            \"2.71828182845904523536028747135266249775724709369996\"\n-#define EXSLT_SQRRT2    (const xmlChar *) \\\n-            \"1.41421356237309504880168872420969807856967187537694\"\n-#define EXSLT_LN2       (const xmlChar *) \\\n-            \"0.69314718055994530941723212145817656807550013436025\"\n-#define EXSLT_LN10      (const xmlChar *) \\\n-            \"2.30258509299404568402\"\n-#define EXSLT_LOG2E     (const xmlChar *) \\\n-            \"1.4426950408889634074\"\n-#define EXSLT_SQRT1_2   (const xmlChar *) \\\n-            \"0.70710678118654752440\"\n-\n-\/**\n- * exsltMathConstant\n- * @name: string\n- * @precision:  number\n- *\n- * Implements the EXSLT - Math constant function:\n- *     number math:constant(string, number)\n- *\n- * Returns a number value of the given constant with the given precision or\n- * NAN if name is unknown.\n- * The constants are PI, E, SQRRT2, LN2, LN10, LOG2E, and SQRT1_2\n- *\/\n-static double\n-exsltMathConstant (xmlChar *name, double precision) {\n-    xmlChar *str;\n-    double ret;\n-\n-    if ((name == NULL) || (xmlXPathIsNaN(precision)) || (precision < 1.0)) {\n-        return NAN;\n-    }\n-\n-    if (xmlStrEqual(name, BAD_CAST \"PI\")) {\n-        int len = xmlStrlen(EXSLT_PI);\n-\n-        if (precision <= len)\n-            len = (int)precision;\n-\n-        str = xmlStrsub(EXSLT_PI, 0, len);\n-\n-    } else if (xmlStrEqual(name, BAD_CAST \"E\")) {\n-        int len = xmlStrlen(EXSLT_E);\n-\n-        if (precision <= len)\n-            len = (int)precision;\n-\n-        str = xmlStrsub(EXSLT_E, 0, len);\n-\n-    } else if (xmlStrEqual(name, BAD_CAST \"SQRRT2\")) {\n-        int len = xmlStrlen(EXSLT_SQRRT2);\n-\n-        if (precision <= len)\n-            len = (int)precision;\n-\n-        str = xmlStrsub(EXSLT_SQRRT2, 0, len);\n-\n-    } else if (xmlStrEqual(name, BAD_CAST \"LN2\")) {\n-        int len = xmlStrlen(EXSLT_LN2);\n-\n-        if (precision <= len)\n-            len = (int)precision;\n-\n-        str = xmlStrsub(EXSLT_LN2, 0, len);\n-\n-    } else if (xmlStrEqual(name, BAD_CAST \"LN10\")) {\n-        int len = xmlStrlen(EXSLT_LN10);\n-\n-        if (precision <= len)\n-            len = (int)precision;\n-\n-        str = xmlStrsub(EXSLT_LN10, 0, len);\n-\n-    } else if (xmlStrEqual(name, BAD_CAST \"LOG2E\")) {\n-        int len = xmlStrlen(EXSLT_LOG2E);\n-\n-        if (precision <= len)\n-            len = (int)precision;\n-\n-        str = xmlStrsub(EXSLT_LOG2E, 0, len);\n-\n-    } else if (xmlStrEqual(name, BAD_CAST \"SQRT1_2\")) {\n-        int len = xmlStrlen(EXSLT_SQRT1_2);\n-\n-        if (precision <= len)\n-            len = (int)precision;\n-\n-        str = xmlStrsub(EXSLT_SQRT1_2, 0, len);\n-\n-    } else {\n-    str = NULL;\n-    }\n-    if (str == NULL)\n-        return NAN;\n-    ret = xmlXPathCastStringToNumber(str);\n-    xmlFree(str);\n-    return ret;\n-}\n-\n-\/**\n- * exsltMathConstantFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathConstant for use by the XPath processor.\n- *\/\n-static void\n-exsltMathConstantFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    double   ret;\n-    xmlChar *name;\n-\n-    if (nargs != 2) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ret = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    name = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathConstant(name, ret);\n-    if (name != NULL)\n-    xmlFree(name);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathRandom:\n- *\n- * Implements the EXSLT - Math random() function:\n- *    number math:random ()\n- *\n- * Returns a random number between 0 and 1 inclusive.\n- *\/\n-static double\n-exsltMathRandom (void) {\n-    double ret;\n-    int num;\n-\n-    num = rand();\n-    ret = (double)num \/ (double)RAND_MAX;\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathRandomFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathRandom for use by the XPath processor.\n- *\/\n-static void\n-exsltMathRandomFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    double ret;\n-\n-    if (nargs != 0) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    ret = exsltMathRandom();\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathAbs:\n- * @num:  a double\n- *\n- * Implements the EXSLT - Math abs() function:\n- *    number math:abs (number)\n- *\n- * Returns the absolute value of the argument, or NAN if @num is Nan.\n- *\/\n-static double\n-exsltMathAbs (double num) {\n-    double ret;\n-\n-    if (xmlXPathIsNaN(num))\n-    return(NAN);\n-    ret = fabs(num);\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathAbsFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathAbs for use by the XPath processor.\n- *\/\n-static void\n-exsltMathAbsFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    double ret;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ret = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathAbs(ret);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathSqrt:\n- * @num:  a double\n- *\n- * Implements the EXSLT - Math sqrt() function:\n- *    number math:sqrt (number)\n- *\n- * Returns the square root of the argument, or NAN if @num is Nan.\n- *\/\n-static double\n-exsltMathSqrt (double num) {\n-    double ret;\n-\n-    if (xmlXPathIsNaN(num))\n-    return(NAN);\n-    ret = sqrt(num);\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathSqrtFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathSqrt for use by the XPath processor.\n- *\/\n-static void\n-exsltMathSqrtFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    double ret;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ret = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathSqrt(ret);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathPower:\n- * @base:  a double\n- * @power:  a double\n- *\n- * Implements the EXSLT - Math power() function:\n- *    number math:power (number, number)\n- *\n- * Returns the power base and power arguments, or NAN\n- * if either @base or @power is Nan.\n- *\/\n-static double\n-exsltMathPower (double base, double power) {\n-    double ret;\n-\n-    if ((xmlXPathIsNaN(base) || xmlXPathIsNaN(power)))\n-    return(NAN);\n-    ret = pow(base, power);\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathPower:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathPower for use by the XPath processor.\n- *\/\n-static void\n-exsltMathPowerFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    double ret, base;\n-\n-    if (nargs != 2) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ret = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    \/* power *\/\n-    base = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathPower(base, ret);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathLog:\n- * @num:  a double\n- *\n- * Implements the EXSLT - Math log() function:\n- *    number math:log (number)\n- *\n- * Returns the natural log of the argument, or NAN if @num is Nan.\n- *\/\n-static double\n-exsltMathLog (double num) {\n-    double ret;\n-\n-    if (xmlXPathIsNaN(num))\n-    return(NAN);\n-    ret = log(num);\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathLogFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathLog for use by the XPath processor.\n- *\/\n-static void\n-exsltMathLogFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    double ret;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ret = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathLog(ret);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathSin:\n- * @num:  a double\n- *\n- * Implements the EXSLT - Math sin() function:\n- *    number math:sin (number)\n- *\n- * Returns the sine of the argument, or NAN if @num is Nan.\n- *\/\n-static double\n-exsltMathSin (double num) {\n-    double ret;\n-\n-    if (xmlXPathIsNaN(num))\n-    return(NAN);\n-    ret = sin(num);\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathSinFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathSin for use by the XPath processor.\n- *\/\n-static void\n-exsltMathSinFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    double ret;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ret = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathSin(ret);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathCos:\n- * @num:  a double\n- *\n- * Implements the EXSLT - Math cos() function:\n- *    number math:cos (number)\n- *\n- * Returns the cosine of the argument, or NAN if @num is Nan.\n- *\/\n-static double\n-exsltMathCos (double num) {\n-    double ret;\n-\n-    if (xmlXPathIsNaN(num))\n-    return(NAN);\n-    ret = cos(num);\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathCosFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathCos for use by the XPath processor.\n- *\/\n-static void\n-exsltMathCosFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    double ret;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ret = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathCos(ret);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathTan:\n- * @num:  a double\n- *\n- * Implements the EXSLT - Math tan() function:\n- *    number math:tan (number)\n- *\n- * Returns the tangent of the argument, or NAN if @num is Nan.\n- *\/\n-static double\n-exsltMathTan (double num) {\n-    double ret;\n-\n-    if (xmlXPathIsNaN(num))\n-    return(NAN);\n-    ret = tan(num);\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathTanFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathTan for use by the XPath processor.\n- *\/\n-static void\n-exsltMathTanFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    double ret;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ret = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathTan(ret);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathAsin:\n- * @num:  a double\n- *\n- * Implements the EXSLT - Math asin() function:\n- *    number math:asin (number)\n- *\n- * Returns the arc sine of the argument, or NAN if @num is Nan.\n- *\/\n-static double\n-exsltMathAsin (double num) {\n-    double ret;\n-\n-    if (xmlXPathIsNaN(num))\n-    return(NAN);\n-    ret = asin(num);\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathAsinFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathAsin for use by the XPath processor.\n- *\/\n-static void\n-exsltMathAsinFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    double ret;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ret = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathAsin(ret);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathAcos:\n- * @num:  a double\n- *\n- * Implements the EXSLT - Math acos() function:\n- *    number math:acos (number)\n- *\n- * Returns the arc cosine of the argument, or NAN if @num is Nan.\n- *\/\n-static double\n-exsltMathAcos (double num) {\n-    double ret;\n-\n-    if (xmlXPathIsNaN(num))\n-    return(NAN);\n-    ret = acos(num);\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathAcosFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathAcos for use by the XPath processor.\n- *\/\n-static void\n-exsltMathAcosFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    double ret;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ret = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathAcos(ret);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathAtan:\n- * @num:  a double\n- *\n- * Implements the EXSLT - Math atan() function:\n- *    number math:atan (number)\n- *\n- * Returns the arc tangent of the argument, or NAN if @num is Nan.\n- *\/\n-static double\n-exsltMathAtan (double num) {\n-    double ret;\n-\n-    if (xmlXPathIsNaN(num))\n-    return(NAN);\n-    ret = atan(num);\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathAtanFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathAtan for use by the XPath processor.\n- *\/\n-static void\n-exsltMathAtanFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    double ret;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ret = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathAtan(ret);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathAtan2:\n- * @y:  a double\n- * @x:  a double\n- *\n- * Implements the EXSLT - Math atan2() function:\n- *    number math:atan2 (number, number)\n- *\n- * Returns the arc tangent function of the y\/x arguments, or NAN\n- * if either @y or @x is Nan.\n- *\/\n-static double\n-exsltMathAtan2 (double y, double x) {\n-    double ret;\n-\n-    if ((xmlXPathIsNaN(y) || xmlXPathIsNaN(x)))\n-    return(NAN);\n-    ret = atan2(y, x);\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathAtan2Function:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathAtan2 for use by the XPath processor.\n- *\/\n-static void\n-exsltMathAtan2Function (xmlXPathParserContextPtr ctxt, int nargs) {\n-    double ret, x;\n-\n-    if (nargs != 2) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    x = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    \/* y *\/\n-    ret = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathAtan2(ret, x);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathExp:\n- * @num:  a double\n- *\n- * Implements the EXSLT - Math exp() function:\n- *    number math:exp (number)\n- *\n- * Returns the exponential function of the argument, or NAN if\n- * @num is Nan.\n- *\/\n-static double\n-exsltMathExp (double num) {\n-    double ret;\n-\n-    if (xmlXPathIsNaN(num))\n-    return(NAN);\n-    ret = exp(num);\n-    return(ret);\n-}\n-\n-\/**\n- * exsltMathExpFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #exsltMathExp for use by the XPath processor.\n- *\/\n-static void\n-exsltMathExpFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    double ret;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-    ret = xmlXPathPopNumber(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    ret = exsltMathExp(ret);\n-\n-    xmlXPathReturnNumber(ctxt, ret);\n-}\n-\n-\/**\n- * exsltMathRegister:\n- *\n- * Registers the EXSLT - Math module\n- *\/\n-\n-void\n-exsltMathRegister (void) {\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"min\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathMinFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"max\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathMaxFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"highest\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathHighestFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"lowest\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathLowestFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"constant\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathConstantFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"random\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathRandomFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"abs\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathAbsFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"sqrt\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathSqrtFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"power\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathPowerFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"log\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathLogFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"sin\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathSinFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"cos\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathCosFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"tan\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathTanFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"asin\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathAsinFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"acos\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathAcosFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"atan\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathAtanFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"atan2\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathAtan2Function);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"exp\",\n-                   EXSLT_MATH_NAMESPACE,\n-                   exsltMathExpFunction);\n-}\n-\n-\/**\n- * exsltMathXpathCtxtRegister:\n- *\n- * Registers the EXSLT - Math module for use outside XSLT\n- *\/\n-int\n-exsltMathXpathCtxtRegister (xmlXPathContextPtr ctxt, const xmlChar *prefix)\n-{\n-    if (ctxt\n-        && prefix\n-        && !xmlXPathRegisterNs(ctxt,\n-                               prefix,\n-                               (const xmlChar *) EXSLT_MATH_NAMESPACE)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"min\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathMinFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"max\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathMaxFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"highest\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathHighestFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"lowest\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathLowestFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"random\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathRandomFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"abs\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathAbsFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"sqrt\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathSqrtFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"power\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathPowerFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"log\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathLogFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"sin\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathSinFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"cos\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathCosFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"tan\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathTanFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"asin\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathAsinFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"acos\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathAcosFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"atan\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathAtanFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"atan2\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathAtan2Function)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"exp\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathExpFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"constant\",\n-                                   (const xmlChar *) EXSLT_MATH_NAMESPACE,\n-                                   exsltMathConstantFunction)) {\n-        return 0;\n-    }\n-    return -1;\n-}\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/math.c","additions":0,"deletions":1173,"binary":false,"changes":1173,"status":"deleted"},{"patch":"@@ -1,318 +0,0 @@\n-#define IN_LIBEXSLT\n-#include \"libexslt\/libexslt.h\"\n-\n-#include <libxml\/tree.h>\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/hash.h>\n-\n-#include <libxslt\/xsltutils.h>\n-#include <libxslt\/xsltInternals.h>\n-#include <libxslt\/extensions.h>\n-\n-#include \"exslt.h\"\n-\n-\/**\n- * exsltSaxonInit:\n- * @ctxt: an XSLT transformation context\n- * @URI: the namespace URI for the extension\n- *\n- * Initializes the SAXON module.\n- *\n- * Returns the data for this transformation\n- *\/\n-static void *\n-exsltSaxonInit (xsltTransformContextPtr ctxt ATTRIBUTE_UNUSED,\n-        const xmlChar *URI ATTRIBUTE_UNUSED) {\n-    return xmlHashCreate(1);\n-}\n-\n-static void\n-exsltSaxonFreeCompExprEntry(void *payload,\n-                            const xmlChar *name ATTRIBUTE_UNUSED) {\n-    xmlXPathFreeCompExpr((xmlXPathCompExprPtr) payload);\n-}\n-\n-\/**\n- * exsltSaxonShutdown:\n- * @ctxt: an XSLT transformation context\n- * @URI: the namespace URI for the extension\n- * @data: the module data to free up\n- *\n- * Shutdown the SAXON extension module\n- *\/\n-static void\n-exsltSaxonShutdown (xsltTransformContextPtr ctxt ATTRIBUTE_UNUSED,\n-            const xmlChar *URI ATTRIBUTE_UNUSED,\n-            void *vdata) {\n-    xmlHashTablePtr data = (xmlHashTablePtr) vdata;\n-    xmlHashFree(data, exsltSaxonFreeCompExprEntry);\n-}\n-\n-\n-\/**\n- * exsltSaxonExpressionFunction:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * The supplied string must contain an XPath expression. The result of\n- * the function is a stored expression, which may be supplied as an\n- * argument to other extension functions such as saxon:eval(),\n- * saxon:sum() and saxon:distinct(). The result of the expression will\n- * usually depend on the current node. The expression may contain\n- * references to variables that are in scope at the point where\n- * saxon:expression() is called: these variables will be replaced in\n- * the stored expression with the values they take at the time\n- * saxon:expression() is called, not the values of the variables at\n- * the time the stored expression is evaluated.  Similarly, if the\n- * expression contains namespace prefixes, these are interpreted in\n- * terms of the namespace declarations in scope at the point where the\n- * saxon:expression() function is called, not those in scope where the\n- * stored expression is evaluated.\n- *\n- * TODO: current implementation doesn't conform to SAXON behaviour\n- * regarding context and namespaces.\n- *\/\n-static void\n-exsltSaxonExpressionFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlChar *arg;\n-    xmlXPathCompExprPtr ret;\n-    xmlHashTablePtr hash;\n-    xsltTransformContextPtr tctxt = xsltXPathGetTransformContext(ctxt);\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    arg = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt) || (arg == NULL)) {\n-    xmlXPathSetTypeError(ctxt);\n-    return;\n-    }\n-\n-    hash = (xmlHashTablePtr) xsltGetExtData(tctxt,\n-                        ctxt->context->functionURI);\n-\n-    ret = xmlHashLookup(hash, arg);\n-\n-    if (ret == NULL) {\n-        ret = xmlXPathCtxtCompile(tctxt->xpathCtxt, arg);\n-        if (ret == NULL) {\n-            xmlFree(arg);\n-            xmlXPathSetError(ctxt, XPATH_EXPR_ERROR);\n-            return;\n-        }\n-        if (xmlHashAddEntry(hash, arg, (void *) ret) < 0) {\n-            xmlXPathFreeCompExpr(ret);\n-            xmlFree(arg);\n-            xmlXPathSetError(ctxt, XPATH_MEMORY_ERROR);\n-            return;\n-        }\n-    }\n-\n-    xmlFree(arg);\n-\n-    xmlXPathReturnExternal(ctxt, ret);\n-}\n-\n-\/**\n- * exsltSaxonEvalFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  number of arguments\n- *\n- * Implements de SAXON eval() function:\n- *    object saxon:eval (saxon:stored-expression)\n- * Returns the result of evaluating the supplied stored expression.\n- * A stored expression may be obtained as the result of calling\n- * the saxon:expression() function.\n- * The stored expression is evaluated in the current context, that\n- * is, the context node is the current node, and the context position\n- * and context size are the same as the result of calling position()\n- * or last() respectively.\n- *\/\n-static void\n-exsltSaxonEvalFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-     xmlXPathCompExprPtr expr;\n-     xmlXPathObjectPtr ret;\n-\n-     if (nargs != 1) {\n-      xmlXPathSetArityError(ctxt);\n-      return;\n-     }\n-\n-     if (!xmlXPathStackIsExternal(ctxt)) {\n-      xmlXPathSetTypeError(ctxt);\n-      return;\n-     }\n-\n-     expr = (xmlXPathCompExprPtr) xmlXPathPopExternal(ctxt);\n-\n-     ret = xmlXPathCompiledEval(expr, ctxt->context);\n-     if (ret == NULL) {\n-      xmlXPathSetError(ctxt, XPATH_EXPR_ERROR);\n-      return;\n-     }\n-\n-     valuePush(ctxt, ret);\n-}\n-\n-\/**\n- * exsltSaxonEvaluateFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs: number of arguments\n- *\n- * Implements the SAXON evaluate() function\n- *     object saxon:evaluate (string)\n- * The supplied string must contain an XPath expression. The result of\n- * the function is the result of evaluating the XPath expression. This\n- * is useful where an expression needs to be constructed at run-time or\n- * passed to the stylesheet as a parameter, for example where the sort\n- * key is determined dynamically. The context for the expression (e.g.\n- * which variables and namespaces are available) is exactly the same as\n- * if the expression were written explicitly at this point in the\n- * stylesheet. The function saxon:evaluate(string) is shorthand for\n- * saxon:eval(saxon:expression(string)).\n- *\/\n-static void\n-exsltSaxonEvaluateFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-     if (nargs != 1) {\n-      xmlXPathSetArityError(ctxt);\n-      return;\n-     }\n-\n-     exsltSaxonExpressionFunction(ctxt, 1);\n-     exsltSaxonEvalFunction(ctxt, 1);\n-}\n-\n-\/**\n- * exsltSaxonSystemIdFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs: number of arguments\n- *\n- * Implements the SAXON systemId() function\n- *     string saxon:systemId ()\n- * This function returns the system ID of the document being styled.\n- *\/\n-static void\n-exsltSaxonSystemIdFunction(xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    if (nargs != 0) {\n-        xmlXPathSetArityError(ctxt);\n-        return;\n-    }\n-\n-    if ((ctxt->context) && (ctxt->context->doc) &&\n-        (ctxt->context->doc->URL))\n-    valuePush(ctxt, xmlXPathNewString(ctxt->context->doc->URL));\n-    else\n-    valuePush(ctxt, xmlXPathNewString(BAD_CAST \"\"));\n-}\n-\n-\/**\n- * exsltSaxonLineNumberFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs: number of arguments\n- *\n- * Implements the SAXON line-number() function\n- *     integer saxon:line-number()\n- *\n- * This returns the line number of the context node in the source document\n- * within the entity that contains it. There are no arguments. If line numbers\n- * are not maintained for the current document, the function returns -1. (To\n- * ensure that line numbers are maintained, use the -l option on the command\n- * line)\n- *\n- * The extension has been extended to have the following form:\n- *     integer saxon:line-number([node-set-1])\n- * If a node-set is given, this extension will return the line number of the\n- * node in the argument node-set that is first in document order.\n- *\/\n-static void\n-exsltSaxonLineNumberFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlNodePtr cur = NULL;\n-    xmlXPathObjectPtr obj = NULL;\n-    long lineNo = -1;\n-\n-    if (nargs == 0) {\n-    cur = ctxt->context->node;\n-    } else if (nargs == 1) {\n-    xmlNodeSetPtr nodelist;\n-    int i;\n-\n-    if ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) {\n-        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"saxon:line-number() : invalid arg expecting a node-set\\n\");\n-        ctxt->error = XPATH_INVALID_TYPE;\n-        return;\n-    }\n-\n-    obj = valuePop(ctxt);\n-    nodelist = obj->nodesetval;\n-    if ((nodelist != NULL) && (nodelist->nodeNr > 0)) {\n-            cur = nodelist->nodeTab[0];\n-            for (i = 1;i < nodelist->nodeNr;i++) {\n-                int ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]);\n-                if (ret == -1)\n-                    cur = nodelist->nodeTab[i];\n-            }\n-        }\n-    } else {\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"saxon:line-number() : invalid number of args %d\\n\",\n-        nargs);\n-    ctxt->error = XPATH_INVALID_ARITY;\n-    return;\n-    }\n-\n-    if ((cur != NULL) && (cur->type == XML_NAMESPACE_DECL)) {\n-        \/*\n-        * The XPath module sets the owner element of a ns-node on\n-        * the ns->next field.\n-        *\/\n-        cur = (xmlNodePtr) ((xmlNsPtr) cur)->next;\n-        if (cur == NULL || cur->type != XML_ELEMENT_NODE) {\n-            xsltGenericError(xsltGenericErrorContext,\n-                \"Internal error in exsltSaxonLineNumberFunction: \"\n-                \"Cannot retrieve the doc of a namespace node.\\n\");\n-            cur = NULL;\n-        }\n-    }\n-\n-    if (cur != NULL)\n-        lineNo = xmlGetLineNo(cur);\n-\n-    valuePush(ctxt, xmlXPathNewFloat(lineNo));\n-\n-    xmlXPathFreeObject(obj);\n-}\n-\n-\/**\n- * exsltSaxonRegister:\n- *\n- * Registers the SAXON extension module\n- *\/\n-void\n-exsltSaxonRegister (void) {\n-     xsltRegisterExtModule (SAXON_NAMESPACE,\n-                exsltSaxonInit,\n-                exsltSaxonShutdown);\n-     xsltRegisterExtModuleFunction((const xmlChar *) \"expression\",\n-                   SAXON_NAMESPACE,\n-                   exsltSaxonExpressionFunction);\n-     xsltRegisterExtModuleFunction((const xmlChar *) \"eval\",\n-                   SAXON_NAMESPACE,\n-                   exsltSaxonEvalFunction);\n-     xsltRegisterExtModuleFunction((const xmlChar *) \"evaluate\",\n-                   SAXON_NAMESPACE,\n-                   exsltSaxonEvaluateFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"line-number\",\n-                   SAXON_NAMESPACE,\n-                   exsltSaxonLineNumberFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"systemId\",\n-                   SAXON_NAMESPACE,\n-                   exsltSaxonSystemIdFunction);\n-}\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/saxon.c","additions":0,"deletions":318,"binary":false,"changes":318,"status":"deleted"},{"patch":"@@ -1,320 +0,0 @@\n-#define IN_LIBEXSLT\n-#include \"libexslt\/libexslt.h\"\n-\n-#include <libxml\/tree.h>\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-\n-#include <libxslt\/xsltutils.h>\n-#include <libxslt\/xsltInternals.h>\n-#include <libxslt\/extensions.h>\n-\n-#include \"exslt.h\"\n-\n-\/**\n- * exsltSetsDifferenceFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #xmlXPathDifference for use by the XPath processor\n- *\/\n-static void\n-exsltSetsDifferenceFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlNodeSetPtr arg1, arg2, ret;\n-\n-    if (nargs != 2) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    arg2 = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    arg1 = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlXPathFreeNodeSet(arg2);\n-    return;\n-    }\n-\n-    ret = xmlXPathDifference(arg1, arg2);\n-\n-    if (ret != arg1)\n-    xmlXPathFreeNodeSet(arg1);\n-    xmlXPathFreeNodeSet(arg2);\n-\n-    xmlXPathReturnNodeSet(ctxt, ret);\n-}\n-\n-\/**\n- * exsltSetsIntersectionFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #xmlXPathIntersection for use by the XPath processor\n- *\/\n-static void\n-exsltSetsIntersectionFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlNodeSetPtr arg1, arg2, ret;\n-\n-    if (nargs != 2) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    arg2 = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    arg1 = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlXPathFreeNodeSet(arg2);\n-    return;\n-    }\n-\n-    ret = xmlXPathIntersection(arg1, arg2);\n-\n-    xmlXPathFreeNodeSet(arg1);\n-    xmlXPathFreeNodeSet(arg2);\n-\n-    xmlXPathReturnNodeSet(ctxt, ret);\n-}\n-\n-\/**\n- * exsltSetsDistinctFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #xmlXPathDistinct for use by the XPath processor\n- *\/\n-static void\n-exsltSetsDistinctFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlXPathObjectPtr obj;\n-    xmlNodeSetPtr ns, ret;\n-    int boolval = 0;\n-    void *user = NULL;\n-\n-    if (nargs != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    if (ctxt->value != NULL) {\n-        boolval = ctxt->value->boolval;\n-    user = ctxt->value->user;\n-    ctxt->value->boolval = 0;\n-    ctxt->value->user = NULL;\n-    }\n-    ns = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    \/* !!! must be sorted !!! *\/\n-    ret = xmlXPathDistinctSorted(ns);\n-\n-    if (ret != ns)\n-    xmlXPathFreeNodeSet(ns);\n-\n-    obj = xmlXPathWrapNodeSet(ret);\n-    if (obj != NULL) {\n-        obj->user = user;\n-        obj->boolval = boolval;\n-    }\n-    valuePush(ctxt, obj);\n-}\n-\n-\/**\n- * exsltSetsHasSameNodesFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #xmlXPathHasSameNodes for use by the XPath processor\n- *\/\n-static void\n-exsltSetsHasSameNodesFunction (xmlXPathParserContextPtr ctxt,\n-                  int nargs) {\n-    xmlNodeSetPtr arg1, arg2;\n-    int ret;\n-\n-    if (nargs != 2) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    arg2 = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    arg1 = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-        xmlXPathFreeNodeSet(arg2);\n-    return;\n-    }\n-\n-    ret = xmlXPathHasSameNodes(arg1, arg2);\n-\n-    xmlXPathFreeNodeSet(arg1);\n-    xmlXPathFreeNodeSet(arg2);\n-\n-    xmlXPathReturnBoolean(ctxt, ret);\n-}\n-\n-\/**\n- * exsltSetsLeadingFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #xmlXPathLeading for use by the XPath processor\n- *\/\n-static void\n-exsltSetsLeadingFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlNodeSetPtr arg1, arg2, ret;\n-\n-    if (nargs != 2) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    arg2 = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    arg1 = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-    xmlXPathFreeNodeSet(arg2);\n-    return;\n-    }\n-\n-    \/*  If the second node set is empty, then the first node set is\n-     * returned.\n-     *\/\n-    if (xmlXPathNodeSetIsEmpty(arg2)) {\n-    xmlXPathReturnNodeSet(ctxt, arg1);\n-\n-    xmlXPathFreeNodeSet(arg2);\n-\n-    return;\n-    }\n-    \/* !!! must be sorted *\/\n-    ret = xmlXPathNodeLeadingSorted(arg1, xmlXPathNodeSetItem(arg2, 0));\n-\n-    xmlXPathFreeNodeSet(arg1);\n-    xmlXPathFreeNodeSet(arg2);\n-\n-    xmlXPathReturnNodeSet(ctxt, ret);\n-}\n-\n-\/**\n- * exsltSetsTrailingFunction:\n- * @ctxt:  an XPath parser context\n- * @nargs:  the number of arguments\n- *\n- * Wraps #xmlXPathTrailing for use by the XPath processor\n- *\/\n-static void\n-exsltSetsTrailingFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlNodeSetPtr arg1, arg2, ret;\n-\n-    if (nargs != 2) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    arg2 = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-    return;\n-\n-    arg1 = xmlXPathPopNodeSet(ctxt);\n-    if (xmlXPathCheckError(ctxt)) {\n-    xmlXPathFreeNodeSet(arg2);\n-    return;\n-    }\n-\n-    \/*  If the second node set is empty, then the first node set is\n-     * returned.\n-     *\/\n-    if (xmlXPathNodeSetIsEmpty(arg2)) {\n-    xmlXPathReturnNodeSet(ctxt, arg1);\n-\n-    xmlXPathFreeNodeSet(arg2);\n-\n-    return;\n-    }\n-    \/* !!! mist be sorted *\/\n-    ret = xmlXPathNodeTrailingSorted(arg1, xmlXPathNodeSetItem(arg2, 0));\n-\n-    xmlXPathFreeNodeSet(arg1);\n-    xmlXPathFreeNodeSet(arg2);\n-\n-    xmlXPathReturnNodeSet(ctxt, ret);\n-}\n-\n-\/**\n- * exsltSetsRegister:\n- *\n- * Registers the EXSLT - Sets module\n- *\/\n-\n-void\n-exsltSetsRegister (void) {\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"difference\",\n-                   EXSLT_SETS_NAMESPACE,\n-                   exsltSetsDifferenceFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"intersection\",\n-                   EXSLT_SETS_NAMESPACE,\n-                   exsltSetsIntersectionFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"distinct\",\n-                   EXSLT_SETS_NAMESPACE,\n-                   exsltSetsDistinctFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"has-same-node\",\n-                   EXSLT_SETS_NAMESPACE,\n-                   exsltSetsHasSameNodesFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"leading\",\n-                   EXSLT_SETS_NAMESPACE,\n-                   exsltSetsLeadingFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"trailing\",\n-                   EXSLT_SETS_NAMESPACE,\n-                   exsltSetsTrailingFunction);\n-}\n-\n-\/**\n- * exsltSetsXpathCtxtRegister:\n- *\n- * Registers the EXSLT - Sets module for use outside XSLT\n- *\/\n-int\n-exsltSetsXpathCtxtRegister (xmlXPathContextPtr ctxt, const xmlChar *prefix)\n-{\n-    if (ctxt\n-        && prefix\n-        && !xmlXPathRegisterNs(ctxt,\n-                               prefix,\n-                               (const xmlChar *) EXSLT_SETS_NAMESPACE)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"difference\",\n-                                   (const xmlChar *) EXSLT_SETS_NAMESPACE,\n-                                   exsltSetsDifferenceFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"intersection\",\n-                                   (const xmlChar *) EXSLT_SETS_NAMESPACE,\n-                                   exsltSetsIntersectionFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"distinct\",\n-                                   (const xmlChar *) EXSLT_SETS_NAMESPACE,\n-                                   exsltSetsDistinctFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"has-same-node\",\n-                                   (const xmlChar *) EXSLT_SETS_NAMESPACE,\n-                                   exsltSetsHasSameNodesFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"leading\",\n-                                   (const xmlChar *) EXSLT_SETS_NAMESPACE,\n-                                   exsltSetsLeadingFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"trailing\",\n-                                   (const xmlChar *) EXSLT_SETS_NAMESPACE,\n-                                   exsltSetsTrailingFunction)) {\n-        return 0;\n-    }\n-    return -1;\n-}\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/sets.c","additions":0,"deletions":320,"binary":false,"changes":320,"status":"deleted"},{"patch":"@@ -1,884 +0,0 @@\n-#define IN_LIBEXSLT\n-#include \"libexslt\/libexslt.h\"\n-\n-#include <libxml\/tree.h>\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/encoding.h>\n-#include <libxml\/uri.h>\n-\n-#include <libxslt\/xsltutils.h>\n-#include <libxslt\/xsltInternals.h>\n-#include <libxslt\/extensions.h>\n-\n-#include \"exslt.h\"\n-\n-\/**\n- * exsltStrTokenizeFunction:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * Splits up a string on the characters of the delimiter string and returns a\n- * node set of token elements, each containing one token from the string.\n- *\/\n-static void\n-exsltStrTokenizeFunction(xmlXPathParserContextPtr ctxt, int nargs)\n-{\n-    xsltTransformContextPtr tctxt;\n-    xmlChar *str, *delimiters, *cur;\n-    const xmlChar *token, *delimiter;\n-    xmlNodePtr node;\n-    xmlDocPtr container;\n-    xmlXPathObjectPtr ret = NULL;\n-    int clen;\n-\n-    if ((nargs < 1) || (nargs > 2)) {\n-        xmlXPathSetArityError(ctxt);\n-        return;\n-    }\n-\n-    if (nargs == 2) {\n-        delimiters = xmlXPathPopString(ctxt);\n-        if (xmlXPathCheckError(ctxt))\n-            return;\n-    } else {\n-        delimiters = xmlStrdup((const xmlChar *) \"\\t\\r\\n \");\n-    }\n-    if (delimiters == NULL)\n-        return;\n-\n-    str = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt) || (str == NULL)) {\n-        xmlFree(delimiters);\n-        return;\n-    }\n-\n-    \/* Return a result tree fragment *\/\n-    tctxt = xsltXPathGetTransformContext(ctxt);\n-    if (tctxt == NULL) {\n-        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-          \"exslt:tokenize : internal error tctxt == NULL\\n\");\n-    goto fail;\n-    }\n-\n-    container = xsltCreateRVT(tctxt);\n-    if (container != NULL) {\n-        xsltRegisterLocalRVT(tctxt, container);\n-        ret = xmlXPathNewNodeSet(NULL);\n-        if (ret != NULL) {\n-            for (cur = str, token = str; *cur != 0; cur += clen) {\n-            clen = xmlUTF8Strsize(cur, 1);\n-        if (*delimiters == 0) {    \/* empty string case *\/\n-            xmlChar ctmp;\n-            ctmp = *(cur+clen);\n-            *(cur+clen) = 0;\n-                    node = xmlNewDocRawNode(container, NULL,\n-                                       (const xmlChar *) \"token\", cur);\n-            xmlAddChild((xmlNodePtr) container, node);\n-            xmlXPathNodeSetAddUnique(ret->nodesetval, node);\n-                    *(cur+clen) = ctmp; \/* restore the changed byte *\/\n-                    token = cur + clen;\n-                } else for (delimiter = delimiters; *delimiter != 0;\n-                delimiter += xmlUTF8Strsize(delimiter, 1)) {\n-                    if (!xmlUTF8Charcmp(cur, delimiter)) {\n-                        if (cur == token) {\n-                            \/* discard empty tokens *\/\n-                            token = cur + clen;\n-                            break;\n-                        }\n-                        *cur = 0;    \/* terminate the token *\/\n-                        node = xmlNewDocRawNode(container, NULL,\n-                                           (const xmlChar *) \"token\", token);\n-            xmlAddChild((xmlNodePtr) container, node);\n-            xmlXPathNodeSetAddUnique(ret->nodesetval, node);\n-                        *cur = *delimiter; \/* restore the changed byte *\/\n-                        token = cur + clen;\n-                        break;\n-                    }\n-                }\n-            }\n-            if (token != cur) {\n-        node = xmlNewDocRawNode(container, NULL,\n-                    (const xmlChar *) \"token\", token);\n-                xmlAddChild((xmlNodePtr) container, node);\n-            xmlXPathNodeSetAddUnique(ret->nodesetval, node);\n-            }\n-        }\n-    }\n-\n-fail:\n-    if (str != NULL)\n-        xmlFree(str);\n-    if (delimiters != NULL)\n-        xmlFree(delimiters);\n-    if (ret != NULL)\n-        valuePush(ctxt, ret);\n-    else\n-        valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n-}\n-\n-\/**\n- * exsltStrSplitFunction:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * Splits up a string on a delimiting string and returns a node set of token\n- * elements, each containing one token from the string.\n- *\/\n-static void\n-exsltStrSplitFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n-    xsltTransformContextPtr tctxt;\n-    xmlChar *str, *delimiter, *cur;\n-    const xmlChar *token;\n-    xmlNodePtr node;\n-    xmlDocPtr container;\n-    xmlXPathObjectPtr ret = NULL;\n-    int delimiterLength;\n-\n-    if ((nargs < 1) || (nargs > 2)) {\n-        xmlXPathSetArityError(ctxt);\n-        return;\n-    }\n-\n-    if (nargs == 2) {\n-        delimiter = xmlXPathPopString(ctxt);\n-        if (xmlXPathCheckError(ctxt))\n-            return;\n-    } else {\n-        delimiter = xmlStrdup((const xmlChar *) \" \");\n-    }\n-    if (delimiter == NULL)\n-        return;\n-    delimiterLength = xmlStrlen (delimiter);\n-\n-    str = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt) || (str == NULL)) {\n-        xmlFree(delimiter);\n-        return;\n-    }\n-\n-    \/* Return a result tree fragment *\/\n-    tctxt = xsltXPathGetTransformContext(ctxt);\n-    if (tctxt == NULL) {\n-        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-          \"exslt:tokenize : internal error tctxt == NULL\\n\");\n-    goto fail;\n-    }\n-\n-    \/*\n-    * OPTIMIZE TODO: We are creating an xmlDoc for every split!\n-    *\/\n-    container = xsltCreateRVT(tctxt);\n-    if (container != NULL) {\n-        xsltRegisterLocalRVT(tctxt, container);\n-        ret = xmlXPathNewNodeSet(NULL);\n-        if (ret != NULL) {\n-            for (cur = str, token = str; *cur != 0; cur++) {\n-        if (delimiterLength == 0) {\n-            if (cur != token) {\n-            xmlChar tmp = *cur;\n-            *cur = 0;\n-                        node = xmlNewDocRawNode(container, NULL,\n-                                           (const xmlChar *) \"token\", token);\n-            xmlAddChild((xmlNodePtr) container, node);\n-            xmlXPathNodeSetAddUnique(ret->nodesetval, node);\n-            *cur = tmp;\n-            token++;\n-            }\n-        }\n-        else if (!xmlStrncasecmp(cur, delimiter, delimiterLength)) {\n-            if (cur == token) {\n-            \/* discard empty tokens *\/\n-            cur = cur + delimiterLength - 1;\n-            token = cur + 1;\n-            continue;\n-            }\n-            *cur = 0;\n-            node = xmlNewDocRawNode(container, NULL,\n-                       (const xmlChar *) \"token\", token);\n-            xmlAddChild((xmlNodePtr) container, node);\n-            xmlXPathNodeSetAddUnique(ret->nodesetval, node);\n-            *cur = *delimiter;\n-            cur = cur + delimiterLength - 1;\n-            token = cur + 1;\n-                }\n-            }\n-        if (token != cur) {\n-        node = xmlNewDocRawNode(container, NULL,\n-                   (const xmlChar *) \"token\", token);\n-        xmlAddChild((xmlNodePtr) container, node);\n-        xmlXPathNodeSetAddUnique(ret->nodesetval, node);\n-        }\n-        }\n-    }\n-\n-fail:\n-    if (str != NULL)\n-        xmlFree(str);\n-    if (delimiter != NULL)\n-        xmlFree(delimiter);\n-    if (ret != NULL)\n-        valuePush(ctxt, ret);\n-    else\n-        valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n-}\n-\n-\/**\n- * exsltStrEncodeUriFunction:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * URI-Escapes a string\n- *\/\n-static void\n-exsltStrEncodeUriFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    int escape_all = 1, str_len = 0;\n-    xmlChar *str = NULL, *ret = NULL, *tmp;\n-\n-    if ((nargs < 2) || (nargs > 3)) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    if (nargs >= 3) {\n-        \/* check for UTF-8 if encoding was explicitly given;\n-           we don't support anything else yet *\/\n-        tmp = xmlXPathPopString(ctxt);\n-        if (xmlUTF8Strlen(tmp) != 5 || xmlStrcmp((const xmlChar *)\"UTF-8\",tmp)) {\n-        xmlXPathReturnEmptyString(ctxt);\n-        xmlFree(tmp);\n-        return;\n-    }\n-    xmlFree(tmp);\n-    }\n-\n-    escape_all = xmlXPathPopBoolean(ctxt);\n-\n-    str = xmlXPathPopString(ctxt);\n-    str_len = xmlUTF8Strlen(str);\n-\n-    if (str_len <= 0) {\n-        if (str_len < 0)\n-            xsltGenericError(xsltGenericErrorContext,\n-                             \"exsltStrEncodeUriFunction: invalid UTF-8\\n\");\n-    xmlXPathReturnEmptyString(ctxt);\n-    xmlFree(str);\n-    return;\n-    }\n-\n-    ret = xmlURIEscapeStr(str,(const xmlChar *)(escape_all?\"-_.!~*'()\":\"-_.!~*'();\/?:@&=+$,[]\"));\n-    xmlXPathReturnString(ctxt, ret);\n-\n-    if (str != NULL)\n-    xmlFree(str);\n-}\n-\n-\/**\n- * exsltStrDecodeUriFunction:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * reverses URI-Escaping of a string\n- *\/\n-static void\n-exsltStrDecodeUriFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    int str_len = 0;\n-    xmlChar *str = NULL, *ret = NULL, *tmp;\n-\n-    if ((nargs < 1) || (nargs > 2)) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    if (nargs >= 2) {\n-        \/* check for UTF-8 if encoding was explicitly given;\n-           we don't support anything else yet *\/\n-        tmp = xmlXPathPopString(ctxt);\n-        if (xmlUTF8Strlen(tmp) != 5 || xmlStrcmp((const xmlChar *)\"UTF-8\",tmp)) {\n-        xmlXPathReturnEmptyString(ctxt);\n-        xmlFree(tmp);\n-        return;\n-    }\n-    xmlFree(tmp);\n-    }\n-\n-    str = xmlXPathPopString(ctxt);\n-    str_len = xmlUTF8Strlen(str);\n-\n-    if (str_len <= 0) {\n-        if (str_len < 0)\n-            xsltGenericError(xsltGenericErrorContext,\n-                             \"exsltStrDecodeUriFunction: invalid UTF-8\\n\");\n-    xmlXPathReturnEmptyString(ctxt);\n-    xmlFree(str);\n-    return;\n-    }\n-\n-    ret = (xmlChar *) xmlURIUnescapeString((const char *)str,0,NULL);\n-    if (!xmlCheckUTF8(ret)) {\n-    \/* FIXME: instead of throwing away the whole URI, we should\n-        only discard the invalid sequence(s). How to do that? *\/\n-    xmlXPathReturnEmptyString(ctxt);\n-    xmlFree(str);\n-    xmlFree(ret);\n-    return;\n-    }\n-\n-    xmlXPathReturnString(ctxt, ret);\n-\n-    if (str != NULL)\n-    xmlFree(str);\n-}\n-\n-\/**\n- * exsltStrPaddingFunction:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * Creates a padding string of a certain length.\n- *\/\n-static void\n-exsltStrPaddingFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    int number, str_len = 0, str_size = 0;\n-    double floatval;\n-    xmlChar *str = NULL;\n-    xmlBufferPtr buf;\n-\n-    if ((nargs < 1) || (nargs > 2)) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    if (nargs == 2) {\n-    str = xmlXPathPopString(ctxt);\n-    str_len = xmlUTF8Strlen(str);\n-    str_size = xmlStrlen(str);\n-    }\n-\n-    floatval = xmlXPathPopNumber(ctxt);\n-\n-    if (str_len <= 0) {\n-        if (str_len < 0) {\n-            xsltGenericError(xsltGenericErrorContext,\n-                             \"exsltStrPaddingFunction: invalid UTF-8\\n\");\n-            xmlXPathReturnEmptyString(ctxt);\n-            xmlFree(str);\n-            return;\n-        }\n-    if (str != NULL) xmlFree(str);\n-    str = xmlStrdup((const xmlChar *) \" \");\n-    str_len = 1;\n-    str_size = 1;\n-    }\n-\n-    if (xmlXPathIsNaN(floatval) || floatval < 0.0) {\n-        number = 0;\n-    } else if (floatval >= 100000.0) {\n-        number = 100000;\n-    }\n-    else {\n-        number = (int) floatval;\n-    }\n-\n-    if (number <= 0) {\n-    xmlXPathReturnEmptyString(ctxt);\n-    xmlFree(str);\n-    return;\n-    }\n-\n-    buf = xmlBufferCreateSize(number);\n-    if (buf == NULL) {\n-        xmlXPathSetError(ctxt, XPATH_MEMORY_ERROR);\n-    xmlFree(str);\n-    return;\n-    }\n-    xmlBufferSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);\n-\n-    while (number >= str_len) {\n-        xmlBufferAdd(buf, str, str_size);\n-    number -= str_len;\n-    }\n-    if (number > 0) {\n-    str_size = xmlUTF8Strsize(str, number);\n-        xmlBufferAdd(buf, str, str_size);\n-    }\n-\n-    xmlXPathReturnString(ctxt, xmlBufferDetach(buf));\n-\n-    xmlBufferFree(buf);\n-    if (str != NULL)\n-    xmlFree(str);\n-}\n-\n-\/**\n- * exsltStrAlignFunction:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * Aligns a string within another string.\n- *\/\n-static void\n-exsltStrAlignFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlChar *str, *padding, *alignment, *ret;\n-    int str_l, padding_l;\n-\n-    if ((nargs < 2) || (nargs > 3)) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    if (nargs == 3)\n-    alignment = xmlXPathPopString(ctxt);\n-    else\n-    alignment = NULL;\n-\n-    padding = xmlXPathPopString(ctxt);\n-    str = xmlXPathPopString(ctxt);\n-\n-    str_l = xmlUTF8Strlen (str);\n-    padding_l = xmlUTF8Strlen (padding);\n-\n-    if (str_l < 0 || padding_l < 0) {\n-        xsltGenericError(xsltGenericErrorContext,\n-                         \"exsltStrAlignFunction: invalid UTF-8\\n\");\n-        xmlXPathReturnEmptyString(ctxt);\n-        xmlFree(str);\n-        xmlFree(padding);\n-        xmlFree(alignment);\n-        return;\n-    }\n-\n-    if (str_l == padding_l) {\n-    xmlXPathReturnString (ctxt, str);\n-    xmlFree(padding);\n-    xmlFree(alignment);\n-    return;\n-    }\n-\n-    if (str_l > padding_l) {\n-    ret = xmlUTF8Strndup (str, padding_l);\n-    } else {\n-    if (xmlStrEqual(alignment, (const xmlChar *) \"right\")) {\n-        ret = xmlUTF8Strndup (padding, padding_l - str_l);\n-        ret = xmlStrcat (ret, str);\n-    } else if (xmlStrEqual(alignment, (const xmlChar *) \"center\")) {\n-        int left = (padding_l - str_l) \/ 2;\n-        int right_start;\n-\n-        ret = xmlUTF8Strndup (padding, left);\n-        ret = xmlStrcat (ret, str);\n-\n-        right_start = xmlUTF8Strsize (padding, left + str_l);\n-        ret = xmlStrcat (ret, padding + right_start);\n-    } else {\n-        int str_s;\n-\n-        str_s = xmlUTF8Strsize(padding, str_l);\n-        ret = xmlStrdup (str);\n-        ret = xmlStrcat (ret, padding + str_s);\n-    }\n-    }\n-\n-    xmlXPathReturnString (ctxt, ret);\n-\n-    xmlFree(str);\n-    xmlFree(padding);\n-    xmlFree(alignment);\n-}\n-\n-\/**\n- * exsltStrConcatFunction:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * Takes a node set and returns the concatenation of the string values\n- * of the nodes in that node set.  If the node set is empty, it\n- * returns an empty string.\n- *\/\n-static void\n-exsltStrConcatFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlXPathObjectPtr obj;\n-    xmlBufferPtr buf;\n-    int i;\n-\n-    if (nargs  != 1) {\n-    xmlXPathSetArityError(ctxt);\n-    return;\n-    }\n-\n-    if (!xmlXPathStackIsNodeSet(ctxt)) {\n-    xmlXPathSetTypeError(ctxt);\n-    return;\n-    }\n-\n-    obj = valuePop (ctxt);\n-\n-    if (xmlXPathNodeSetIsEmpty(obj->nodesetval)) {\n-        xmlXPathFreeObject(obj);\n-    xmlXPathReturnEmptyString(ctxt);\n-    return;\n-    }\n-\n-    buf = xmlBufferCreate();\n-    if (buf == NULL) {\n-        xmlXPathSetError(ctxt, XPATH_MEMORY_ERROR);\n-        xmlXPathFreeObject(obj);\n-    return;\n-    }\n-    xmlBufferSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);\n-\n-    for (i = 0; i < obj->nodesetval->nodeNr; i++) {\n-    xmlChar *tmp;\n-    tmp = xmlXPathCastNodeToString(obj->nodesetval->nodeTab[i]);\n-\n-        xmlBufferCat(buf, tmp);\n-\n-    xmlFree(tmp);\n-    }\n-\n-    xmlXPathFreeObject (obj);\n-\n-    xmlXPathReturnString(ctxt, xmlBufferDetach(buf));\n-    xmlBufferFree(buf);\n-}\n-\n-\/**\n- * exsltStrReturnString:\n- * @ctxt: an XPath parser context\n- * @str: a string\n- * @len: length of string\n- *\n- * Returns a string as a node set.\n- *\/\n-static int\n-exsltStrReturnString(xmlXPathParserContextPtr ctxt, const xmlChar *str,\n-                     int len)\n-{\n-    xsltTransformContextPtr tctxt = xsltXPathGetTransformContext(ctxt);\n-    xmlDocPtr container;\n-    xmlNodePtr text_node;\n-    xmlXPathObjectPtr ret;\n-\n-    container = xsltCreateRVT(tctxt);\n-    if (container == NULL) {\n-        xmlXPathSetError(ctxt, XPATH_MEMORY_ERROR);\n-        return(-1);\n-    }\n-    xsltRegisterLocalRVT(tctxt, container);\n-\n-    text_node = xmlNewTextLen(str, len);\n-    if (text_node == NULL) {\n-        xmlXPathSetError(ctxt, XPATH_MEMORY_ERROR);\n-        return(-1);\n-    }\n-    xmlAddChild((xmlNodePtr) container, text_node);\n-\n-    ret = xmlXPathNewNodeSet(text_node);\n-    if (ret == NULL) {\n-        xmlXPathSetError(ctxt, XPATH_MEMORY_ERROR);\n-        return(-1);\n-    }\n-\n-    valuePush(ctxt, ret);\n-\n-    return(0);\n-}\n-\n-\/**\n- * exsltStrReplaceFunction:\n- * @ctxt: an XPath parser context\n- * @nargs: the number of arguments\n- *\n- * Takes a string, and two node sets and returns the string with all strings in\n- * the first node set replaced by all strings in the second node set.\n- *\/\n-static void\n-exsltStrReplaceFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n-    int i, i_empty, n, slen0, rlen0, *slen, *rlen;\n-    void *mem = NULL;\n-    const xmlChar *src, *start;\n-    xmlChar *string, *search_str = NULL, *replace_str = NULL;\n-    xmlChar **search, **replace;\n-    xmlNodeSetPtr search_set = NULL, replace_set = NULL;\n-    xmlBufferPtr buf;\n-\n-    if (nargs  != 3) {\n-        xmlXPathSetArityError(ctxt);\n-        return;\n-    }\n-\n-    \/* get replace argument *\/\n-\n-    if (!xmlXPathStackIsNodeSet(ctxt))\n-        replace_str = xmlXPathPopString(ctxt);\n-    else\n-        replace_set = xmlXPathPopNodeSet(ctxt);\n-\n-    if (xmlXPathCheckError(ctxt))\n-        goto fail_replace;\n-\n-    \/* get search argument *\/\n-\n-    if (!xmlXPathStackIsNodeSet(ctxt)) {\n-        search_str = xmlXPathPopString(ctxt);\n-        n = 1;\n-    }\n-    else {\n-        search_set = xmlXPathPopNodeSet(ctxt);\n-        n = search_set != NULL ? search_set->nodeNr : 0;\n-    }\n-\n-    if (xmlXPathCheckError(ctxt))\n-        goto fail_search;\n-\n-    \/* get string argument *\/\n-\n-    string = xmlXPathPopString(ctxt);\n-    if (xmlXPathCheckError(ctxt))\n-        goto fail_string;\n-\n-    \/* check for empty search node list *\/\n-\n-    if (n <= 0) {\n-        exsltStrReturnString(ctxt, string, xmlStrlen(string));\n-        goto done_empty_search;\n-    }\n-\n-    \/* allocate memory for string pointer and length arrays *\/\n-\n-    if (n == 1) {\n-        search = &search_str;\n-        replace = &replace_str;\n-        slen = &slen0;\n-        rlen = &rlen0;\n-    }\n-    else {\n-        mem = xmlMalloc(2 * n * (sizeof(const xmlChar *) + sizeof(int)));\n-        if (mem == NULL) {\n-            xmlXPathSetError(ctxt, XPATH_MEMORY_ERROR);\n-            goto fail_malloc;\n-        }\n-        search = (xmlChar **) mem;\n-        replace = search + n;\n-        slen = (int *) (replace + n);\n-        rlen = slen + n;\n-    }\n-\n-    \/* process arguments *\/\n-\n-    i_empty = -1;\n-\n-    for (i=0; i<n; ++i) {\n-        if (search_set != NULL) {\n-            search[i] = xmlXPathCastNodeToString(search_set->nodeTab[i]);\n-            if (search[i] == NULL) {\n-                n = i;\n-                goto fail_process_args;\n-            }\n-        }\n-\n-        slen[i] = xmlStrlen(search[i]);\n-        if (i_empty < 0 && slen[i] == 0)\n-            i_empty = i;\n-\n-        if (replace_set != NULL) {\n-            if (i < replace_set->nodeNr) {\n-                replace[i] = xmlXPathCastNodeToString(replace_set->nodeTab[i]);\n-                if (replace[i] == NULL) {\n-                    n = i + 1;\n-                    goto fail_process_args;\n-                }\n-            }\n-            else\n-                replace[i] = NULL;\n-        }\n-        else {\n-            if (i == 0)\n-                replace[i] = replace_str;\n-            else\n-                replace[i] = NULL;\n-        }\n-\n-        if (replace[i] == NULL)\n-            rlen[i] = 0;\n-        else\n-            rlen[i] = xmlStrlen(replace[i]);\n-    }\n-\n-    if (i_empty >= 0 && rlen[i_empty] == 0)\n-        i_empty = -1;\n-\n-    \/* replace operation *\/\n-\n-    buf = xmlBufferCreate();\n-    if (buf == NULL) {\n-        xmlXPathSetError(ctxt, XPATH_MEMORY_ERROR);\n-        goto fail_buffer;\n-    }\n-    xmlBufferSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);\n-    src = string;\n-    start = string;\n-\n-    while (*src != 0) {\n-        int max_len = 0, i_match = 0;\n-\n-        for (i=0; i<n; ++i) {\n-            if (*src == search[i][0] &&\n-                slen[i] > max_len &&\n-                xmlStrncmp(src, search[i], slen[i]) == 0)\n-            {\n-                i_match = i;\n-                max_len = slen[i];\n-            }\n-        }\n-\n-        if (max_len == 0) {\n-            if (i_empty >= 0 && start < src) {\n-                if (xmlBufferAdd(buf, start, src - start) ||\n-                    xmlBufferAdd(buf, replace[i_empty], rlen[i_empty]))\n-                {\n-                    xmlXPathSetError(ctxt, XPATH_MEMORY_ERROR);\n-                    goto fail_buffer_add;\n-                }\n-                start = src;\n-            }\n-\n-            src += xmlUTF8Strsize(src, 1);\n-        }\n-        else {\n-            if ((start < src &&\n-                 xmlBufferAdd(buf, start, src - start)) ||\n-                (rlen[i_match] &&\n-                 xmlBufferAdd(buf, replace[i_match], rlen[i_match])))\n-            {\n-                xmlXPathSetError(ctxt, XPATH_MEMORY_ERROR);\n-                goto fail_buffer_add;\n-            }\n-\n-            src += slen[i_match];\n-            start = src;\n-        }\n-    }\n-\n-    if (start < src && xmlBufferAdd(buf, start, src - start)) {\n-        xmlXPathSetError(ctxt, XPATH_MEMORY_ERROR);\n-        goto fail_buffer_add;\n-    }\n-\n-    \/* create result node set *\/\n-\n-    exsltStrReturnString(ctxt, xmlBufferContent(buf), xmlBufferLength(buf));\n-\n-    \/* clean up *\/\n-\n-fail_buffer_add:\n-    xmlBufferFree(buf);\n-\n-fail_buffer:\n-fail_process_args:\n-    if (search_set != NULL) {\n-        for (i=0; i<n; ++i)\n-            xmlFree(search[i]);\n-    }\n-    if (replace_set != NULL) {\n-        for (i=0; i<n; ++i) {\n-            if (replace[i] != NULL)\n-                xmlFree(replace[i]);\n-        }\n-    }\n-\n-    if (mem != NULL)\n-        xmlFree(mem);\n-\n-fail_malloc:\n-done_empty_search:\n-    xmlFree(string);\n-\n-fail_string:\n-    if (search_set != NULL)\n-        xmlXPathFreeNodeSet(search_set);\n-    else\n-        xmlFree(search_str);\n-\n-fail_search:\n-    if (replace_set != NULL)\n-        xmlXPathFreeNodeSet(replace_set);\n-    else\n-        xmlFree(replace_str);\n-\n-fail_replace:\n-    return;\n-}\n-\n-\/**\n- * exsltStrRegister:\n- *\n- * Registers the EXSLT - Strings module\n- *\/\n-\n-void\n-exsltStrRegister (void) {\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"tokenize\",\n-                   EXSLT_STRINGS_NAMESPACE,\n-                   exsltStrTokenizeFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"split\",\n-                   EXSLT_STRINGS_NAMESPACE,\n-                   exsltStrSplitFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"encode-uri\",\n-                   EXSLT_STRINGS_NAMESPACE,\n-                   exsltStrEncodeUriFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"decode-uri\",\n-                   EXSLT_STRINGS_NAMESPACE,\n-                   exsltStrDecodeUriFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"padding\",\n-                   EXSLT_STRINGS_NAMESPACE,\n-                   exsltStrPaddingFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"align\",\n-                   EXSLT_STRINGS_NAMESPACE,\n-                   exsltStrAlignFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"concat\",\n-                   EXSLT_STRINGS_NAMESPACE,\n-                   exsltStrConcatFunction);\n-    xsltRegisterExtModuleFunction ((const xmlChar *) \"replace\",\n-                   EXSLT_STRINGS_NAMESPACE,\n-                   exsltStrReplaceFunction);\n-}\n-\n-\/**\n- * exsltStrXpathCtxtRegister:\n- *\n- * Registers the EXSLT - Strings module for use outside XSLT\n- *\/\n-int\n-exsltStrXpathCtxtRegister (xmlXPathContextPtr ctxt, const xmlChar *prefix)\n-{\n-    if (ctxt\n-        && prefix\n-        && !xmlXPathRegisterNs(ctxt,\n-                               prefix,\n-                               (const xmlChar *) EXSLT_STRINGS_NAMESPACE)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"encode-uri\",\n-                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n-                                   exsltStrEncodeUriFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"decode-uri\",\n-                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n-                                   exsltStrDecodeUriFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"padding\",\n-                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n-                                   exsltStrPaddingFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"align\",\n-                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n-                                   exsltStrAlignFunction)\n-        && !xmlXPathRegisterFuncNS(ctxt,\n-                                   (const xmlChar *) \"concat\",\n-                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n-                                   exsltStrConcatFunction)) {\n-        return 0;\n-    }\n-    return -1;\n-}\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt\/strings.c","additions":0,"deletions":884,"binary":false,"changes":884,"status":"deleted"},{"patch":"@@ -1,13 +0,0 @@\n-prefix=@prefix@\n-exec_prefix=@exec_prefix@\n-libdir=@libdir@\n-includedir=@includedir@\n-\n-\n-Name: libxslt\n-Version: @VERSION@\n-Description: XSLT library version 2.\n-Requires: libxml-2.0\n-Cflags: @XSLT_INCLUDEDIR@ @LIBXSLT_CFLAGS@\n-Libs: @XSLT_LIBDIR@ -lxslt\n-Libs.private: @XSLT_PRIVATE_LIBS@\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt.pc.in","additions":0,"deletions":13,"binary":false,"changes":13,"status":"deleted"}]}