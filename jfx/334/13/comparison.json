{"files":[{"filename":"modules\/javafx.graphics\/src\/main\/docs\/javafx\/scene\/doc-files\/spotlight.png","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene;\n+\n+import com.sun.javafx.sg.prism.NGNode;\n+import com.sun.javafx.util.Utils;\n+import javafx.scene.SpotLight;\n+import javafx.scene.Node;\n+\n+\/**\n+ * Used to access internal methods of SpotLight.\n+ *\/\n+public class SpotLightHelper extends PointLightHelper {\n+\n+    private static final SpotLightHelper theInstance;\n+    private static SpotLightAccessor spotLightAccessor;\n+\n+    static {\n+        theInstance = new SpotLightHelper();\n+        Utils.forceInit(SpotLight.class);\n+    }\n+\n+    private static SpotLightHelper getInstance() {\n+        return theInstance;\n+    }\n+\n+    public static void initHelper(SpotLight spotLight) {\n+        setHelper(spotLight, getInstance());\n+    }\n+\n+    @Override\n+    protected NGNode createPeerImpl(Node node) {\n+        return spotLightAccessor.doCreatePeer(node);\n+    }\n+\n+    @Override\n+    protected void updatePeerImpl(Node node) {\n+        super.updatePeerImpl(node);\n+        spotLightAccessor.doUpdatePeer(node);\n+    }\n+\n+    public static void setSpotLightAccessor(final SpotLightAccessor newAccessor) {\n+        if (spotLightAccessor != null) {\n+            throw new IllegalStateException(\"Accesor already exists\");\n+        }\n+\n+        spotLightAccessor = newAccessor;\n+    }\n+\n+    public interface SpotLightAccessor {\n+        NGNode doCreatePeer(Node node);\n+        void doUpdatePeer(Node node);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/SpotLightHelper.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -28,0 +28,2 @@\n+import javafx.geometry.Point3D;\n+\n@@ -44,0 +46,12 @@\n+    \/**\n+     * The direction of a {@code SpotLight} that simulates a {@code PointLight}.\n+     * Since the light radiates equaly in all directions, this value is meaningless.\n+     **\/\n+    private static final Point3D SIMULATED_DIRECTION = new Point3D(0, 0, 1);\n+    \/** The inner angle value of a {@code SpotLight} that simulates a {@code PointLight} *\/\n+    private static final float SIMULATED_INNER_ANGLE = 0;\n+    \/** The outer angle value of a {@code SpotLight} that simulates a {@code PointLight} *\/\n+    private static final float SIMULATED_OUTER_ANGLE = 180;\n+    \/** The falloff value of a {@code SpotLight} that simulates a {@code PointLight} *\/\n+    private static final float SIMULATED_FALLOFF = 0;\n+\n@@ -63,0 +77,32 @@\n+    public static Point3D getSimulatedDirection() {\n+        return SIMULATED_DIRECTION;\n+    }\n+\n+    public static float getSimulatedInnerAngle() {\n+        return SIMULATED_INNER_ANGLE;\n+    }\n+\n+    public static float getSimulatedOuterAngle() {\n+        return SIMULATED_OUTER_ANGLE;\n+    }\n+\n+    public static float getSimulatedFalloff() {\n+        return SIMULATED_FALLOFF;\n+    }\n+\n+    public Point3D getDirection() {\n+        return SIMULATED_DIRECTION;\n+    }\n+\n+    public float getInnerAngle() {\n+        return SIMULATED_INNER_ANGLE;\n+    }\n+\n+    public float getOuterAngle() {\n+        return SIMULATED_OUTER_ANGLE;\n+    }\n+\n+    public float getFalloff() {\n+        return SIMULATED_FALLOFF;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/sg\/prism\/NGPointLight.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import com.sun.javafx.util.Utils;\n@@ -109,1 +110,1 @@\n-        int pointLightIdx = 0;\n+        int lightIndex = 0;\n@@ -115,9 +116,15 @@\n-            meshView.setPointLight(pointLightIdx++,\n-                                   (float)cameraPos.x,\n-                                   (float)cameraPos.y,\n-                                   (float)cameraPos.z,\n-                                   1.0f, 1.0f, 1.0f, 1.0f,\n-                                   NGPointLight.getDefaultCa(),\n-                                   NGPointLight.getDefaultLa(),\n-                                   NGPointLight.getDefaultQa(),\n-                                   NGPointLight.getDefaultMaxRange());\n+            meshView.setLight(lightIndex++,\n+                    (float) cameraPos.x,\n+                    (float) cameraPos.y,\n+                    (float) cameraPos.z,\n+                    1.0f, 1.0f, 1.0f, 1.0f,\n+                    NGPointLight.getDefaultCa(),\n+                    NGPointLight.getDefaultLa(),\n+                    NGPointLight.getDefaultQa(),\n+                    NGPointLight.getDefaultMaxRange(),\n+                    (float) NGPointLight.getSimulatedDirection().getX(),\n+                    (float) NGPointLight.getSimulatedDirection().getY(),\n+                    (float) NGPointLight.getSimulatedDirection().getZ(),\n+                    NGPointLight.getSimulatedInnerAngle(),\n+                    NGPointLight.getSimulatedOuterAngle(),\n+                    NGPointLight.getSimulatedFalloff());\n@@ -129,2 +136,1 @@\n-            for (int i = 0; i < g.getLights().length; i++) {\n-                NGLightBase lightBase = g.getLights()[i];\n+            for (NGLightBase lightBase : g.getLights()) {\n@@ -134,40 +140,51 @@\n-                } else if (lightBase.affects(this)) {\n-                    float rL = lightBase.getColor().getRed();\n-                    float gL = lightBase.getColor().getGreen();\n-                    float bL = lightBase.getColor().getBlue();\n-                    \/* TODO: 3D\n-                     * There is a limit on the number of point lights that can affect\n-                     * a 3D shape. (Currently we simply select the first 3)\n-                     * Thus it is important to select the most relevant lights.\n-                     *\n-                     * One such way would be to sort lights according to\n-                     * intensity, which becomes especially relevant when lights\n-                     * are attenuated. Only the most intense set of lights\n-                     * would be set.\n-                     * The approximate intesity a light will have on a given\n-                     * shape, could be defined by:\n-                     *\/\n-\/\/                    \/\/ Where d is distance from point light\n-\/\/                    float attenuationFactor = 1\/(c + cL * d + cQ * d * d);\n-\/\/                    float intensity = rL * 0.299f + gL * 0.587f + bL * 0.114f;\n-\/\/                    intensity *= attenuationFactor;\n-                    if (lightBase instanceof NGPointLight) {\n-                        NGPointLight light = (NGPointLight)lightBase;\n-                        if (rL != 0.0f || gL != 0.0f || bL != 0.0f) {\n-                            Affine3D lightWT = light.getWorldTransform();\n-                            meshView.setPointLight(pointLightIdx++,\n-                                    (float)lightWT.getMxt(),\n-                                    (float)lightWT.getMyt(),\n-                                    (float)lightWT.getMzt(),\n-                                    rL, gL, bL, 1.0f,\n-                                    light.getCa(),\n-                                    light.getLa(),\n-                                    light.getQa(),\n-                                    light.getMaxRange());\n-                        }\n-                    } else if (lightBase instanceof NGAmbientLight) {\n-                        \/\/ Accumulate ambient lights\n-                        ambientRed   += rL;\n-                        ambientGreen += gL;\n-                        ambientBlue  += bL;\n-                    }\n+                }\n+                if (!lightBase.affects(this)) {\n+                    continue;\n+                }\n+                \/\/ Transparent component is ignored\n+                float rL = lightBase.getColor().getRed();\n+                float gL = lightBase.getColor().getGreen();\n+                float bL = lightBase.getColor().getBlue();\n+                \/\/ Black color is ignored\n+                if (rL == 0.0f && gL == 0.0f && bL == 0.0f) {\n+                    continue;\n+                }\n+                \/* TODO: 3D\n+                 * There is a limit on the number of point lights that can affect\n+                 * a 3D shape. (Currently we simply select the first 3)\n+                 * Thus it is important to select the most relevant lights.\n+                 *\n+                 * One such way would be to sort lights according to\n+                 * intensity, which becomes especially relevant when lights\n+                 * are attenuated. Only the most intense set of lights\n+                 * would be set.\n+                 * The approximate intensity a light will have on a given\n+                 * shape, could be defined by:\n+                 *\/\n+\/\/                \/\/ Where d is distance from point light\n+\/\/                float attenuationFactor = 1\/(c + cL * d + cQ * d * d);\n+\/\/                float intensity = rL * 0.299f + gL * 0.587f + bL * 0.114f;\n+\/\/                intensity *= attenuationFactor;\n+                if (lightBase instanceof NGPointLight) {\n+                    var light = (NGPointLight) lightBase;\n+                    Affine3D lightWT = light.getWorldTransform();\n+                    meshView.setLight(lightIndex++,\n+                            (float) lightWT.getMxt(),\n+                            (float) lightWT.getMyt(),\n+                            (float) lightWT.getMzt(),\n+                            rL, gL, bL, 1.0f,\n+                            light.getCa(),\n+                            light.getLa(),\n+                            light.getQa(),\n+                            light.getMaxRange(),\n+                            (float) light.getDirection().getX(),\n+                            (float) light.getDirection().getY(),\n+                            (float) light.getDirection().getZ(),\n+                            light.getInnerAngle(),\n+                            light.getOuterAngle(),\n+                            light.getFalloff());\n+                } else if (lightBase instanceof NGAmbientLight) {\n+                    \/\/ Accumulate ambient lights\n+                    ambientRed   += rL;\n+                    ambientGreen += gL;\n+                    ambientBlue  += bL;\n@@ -176,3 +193,3 @@\n-            ambientRed = saturate(ambientRed);\n-            ambientGreen = saturate(ambientGreen);\n-            ambientBlue = saturate(ambientBlue);\n+            ambientRed = Utils.clamp(0, ambientRed, 1);\n+            ambientGreen = Utils.clamp(0, ambientGreen, 1);\n+            ambientBlue = Utils.clamp(0, ambientBlue, 1);\n@@ -182,6 +199,8 @@\n-        while (pointLightIdx < 3) {\n-                \/\/ Reset any previously set lights\n-                meshView.setPointLight(pointLightIdx++,\n-                        0, 0, 0, \/\/ x y z\n-                        0, 0, 0, 0, \/\/ r g b w\n-                        1, 0, 0, 0); \/\/ ca la qa maxRange\n+\n+        while (lightIndex < 3) { \/\/ Reset any previously set lights\n+            meshView.setLight(lightIndex++,\n+                    0, 0, 0,    \/\/ x y z\n+                    0, 0, 0, 0, \/\/ r g b w\n+                    1, 0, 0, 0, \/\/ ca la qa maxRange\n+                    0, 0, 0,    \/\/ dirX Y Z\n+                    0, 0, 0);   \/\/ inner outer falloff\n@@ -193,5 +212,0 @@\n-    \/\/ Clamp between [0, 1]\n-    private static float saturate(float value) {\n-        return value < 1.0f ? ((value < 0.0f) ? 0.0f : value) : 1.0f;\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/sg\/prism\/NGShape3D.java","additions":81,"deletions":67,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.sg.prism;\n+\n+import com.sun.javafx.geom.Vec3d;\n+\n+import javafx.geometry.Point3D;\n+\n+\/**\n+ * The peer of the {@code SpotLight} class. Holds the default values of {@code SpotLight}'s\n+ * properties and updates the visuals via {@link NGNode#visualsChanged} when one of the current\n+ * values changes. The peer receives its changes by {@link javafx.scene.SpotLight#doUpdatePeer} calls.\n+ *\/\n+public class NGSpotLight extends NGPointLight {\n+\n+    \/** Direction default value *\/\n+    private static final Point3D DEFAULT_DIRECTION = new Point3D(0, 0, 1);\n+    \/** Inner angle default value *\/\n+    private static final float DEFAULT_INNER_ANGLE = 0;\n+    \/** Outer angle default value *\/\n+    private static final float DEFAULT_OUTER_ANGLE = 30;\n+    \/** Falloff default value *\/\n+    private static final float DEFAULT_FALLOFF = 1;\n+\n+    public NGSpotLight() {\n+    }\n+\n+    public static Point3D getDefaultDirection() {\n+        return DEFAULT_DIRECTION;\n+    }\n+\n+    public static float getDefaultInnerAngle() {\n+        return DEFAULT_INNER_ANGLE;\n+    }\n+\n+    public static float getDefaultOuterAngle() {\n+        return DEFAULT_OUTER_ANGLE;\n+    }\n+\n+    public static float getDefaultFalloff() {\n+        return DEFAULT_FALLOFF;\n+    }\n+\n+\n+    private Point3D direction = DEFAULT_DIRECTION;\n+    private final Vec3d effectiveDir = new Vec3d();\n+\n+    @Override\n+    public Point3D getDirection() {\n+        var dir = new Vec3d(direction.getX(), direction.getY(), direction.getZ());\n+        getWorldTransform().deltaTransform(dir, effectiveDir);\n+        return new Point3D(effectiveDir.x, effectiveDir.y, effectiveDir.z);\n+    }\n+\n+    public void setDirection(Point3D direction) {\n+        if (!this.direction.equals(direction)) {\n+            this.direction = direction;\n+            visualsChanged();\n+        }\n+    }\n+\n+\n+    private float innerAngle = DEFAULT_INNER_ANGLE;\n+\n+    @Override\n+    public float getInnerAngle() {\n+        return innerAngle;\n+    }\n+\n+    public void setInnerAngle(float innerAngle) {\n+        if (this.innerAngle != innerAngle) {\n+            this.innerAngle = innerAngle;\n+            visualsChanged();\n+        }\n+    }\n+\n+\n+    private float outerAngle = DEFAULT_OUTER_ANGLE;\n+\n+    @Override\n+    public float getOuterAngle() {\n+        return outerAngle;\n+    }\n+\n+    public void setOuterAngle(float outerAngle) {\n+        if (this.outerAngle != outerAngle) {\n+            this.outerAngle = outerAngle;\n+            visualsChanged();\n+        }\n+    }\n+\n+\n+    private float falloff = DEFAULT_FALLOFF;\n+\n+    @Override\n+    public float getFalloff() {\n+        return falloff;\n+    }\n+\n+    public void setFalloff(float falloff) {\n+        if (this.falloff != falloff) {\n+            this.falloff = falloff;\n+            visualsChanged();\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/sg\/prism\/NGSpotLight.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,4 +49,3 @@\n-    public void setPointLight(int index,\n-            float x, float y, float z,\n-            float r, float g, float b, float w,\n-            float ca, float la, float qa, float maxRange);\n+    public void setLight(int index, float x, float y, float z, float r, float g, float b, float w,\n+            float ca, float la, float qa, float maxRange, float dirX, float dirY, float dirZ,\n+            float innerAngle, float outerAngle, float falloff);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/MeshView.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -428,3 +428,3 @@\n-    private static native void nSetPointLight(long pContext, long nativeMeshView,\n-            int index, float x, float y, float z, float r, float g, float b, float w,\n-            float ca, float la, float qa, float maxRange);\n+    private static native void nSetLight(long pContext, long nativeMeshView,\n+            int index, float x, float y, float z, float r, float g, float b, float w, float ca, float la, float qa,\n+            float maxRange, float dirX, float dirY, float dirZ, float innerAngle, float outerAngle, float falloff);\n@@ -555,3 +555,5 @@\n-    void setPointLight(long nativeMeshView, int index, float x, float y, float z,\n-            float r, float g, float b, float w, float ca, float la, float qa, float maxRange) {\n-        nSetPointLight(pContext, nativeMeshView, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);\n+    void setLight(long nativeMeshView, int index, float x, float y, float z, float r, float g, float b, float w,\n+            float ca, float la, float qa, float maxRange, float dirX, float dirY, float dirZ,\n+            float innerAngle, float outerAngle, float falloff) {\n+        nSetLight(pContext, nativeMeshView, index, x, y, z, r, g, b, w,  ca, la, qa, maxRange,\n+                dirX, dirY, dirZ, innerAngle, outerAngle, falloff);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/d3d\/D3DContext.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,2 +84,3 @@\n-    public void setPointLight(int index, float x, float y, float z, float r, float g, float b, float w,\n-            float ca, float la, float qa, float maxRange) {\n+    public void setLight(int index, float x, float y, float z, float r, float g, float b, float w,\n+            float ca, float la, float qa, float maxRange, float dirX, float dirY, float dirZ,\n+            float innerAngle, float outerAngle, float falloff) {\n@@ -88,1 +89,2 @@\n-            context.setPointLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);\n+            context.setLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange,\n+                    dirX, dirY, dirZ, innerAngle, outerAngle, falloff);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/d3d\/D3DMeshView.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -452,3 +452,5 @@\n-    void setPointLight(long nativeHandle, int index, float x, float y, float z, float r, float g, float b, float w,\n-            float ca, float la, float qa, float maxRange) {\n-        glContext.setPointLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);\n+    void setLight(long nativeHandle, int index, float x, float y, float z, float r, float g, float b, float w,\n+            float ca, float la, float qa, float maxRange, float dirX, float dirY, float dirZ,\n+            float innerAngle, float outerAngle, float falloff) {\n+        glContext.setLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange, dirX, dirY, dirZ,\n+                innerAngle, outerAngle, falloff);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2Context.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+    float dirX, dirY, dirZ;\n+    float innerAngle, outerAngle, falloff;\n@@ -37,8 +39,9 @@\n-    ES2Light(float ix, float iy, float iz, float ir, float ig, float ib, float iw, float ca, float la, float qa, float maxRange) {\n-        x = ix;\n-        y = iy;\n-        z = iz;\n-        r = ir;\n-        g = ig;\n-        b = ib;\n-        w = iw;\n+    ES2Light(float x, float y, float z, float r, float g, float b, float w, float ca, float la, float qa,\n+            float maxRange, float dirX, float dirY, float dirZ, float innerAngle, float outerAngle, float falloff) {\n+        this.x = x;\n+        this.y = y;\n+        this.z = z;\n+        this.r = r;\n+        this.g = g;\n+        this.b = b;\n+        this.w = w;\n@@ -49,0 +52,10 @@\n+        this.dirX = dirX;\n+        this.dirY = dirY;\n+        this.dirZ = dirZ;\n+        this.innerAngle = innerAngle;\n+        this.outerAngle = outerAngle;\n+        this.falloff = falloff;\n+    }\n+\n+    boolean isPointLight() {\n+        return falloff == 0 && outerAngle == 180;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2Light.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,2 +104,3 @@\n-    public void setPointLight(int index, float x, float y, float z, float r, float g, float b, float w,\n-            float ca, float la, float qa, float maxRange) {\n+    public void setLight(int index, float x, float y, float z, float r, float g, float b, float w,\n+            float ca, float la, float qa, float maxRange, float dirX, float dirY, float dirZ,\n+            float innerAngle, float outerAngle, float falloff) {\n@@ -108,2 +109,4 @@\n-            lights[index] = new ES2Light(x, y, z, r, g, b, w, ca, la, qa, maxRange);\n-            context.setPointLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);\n+            lights[index] = new ES2Light(x, y, z, r, g, b, w, ca, la, qa, maxRange, dirX, dirY, dirZ, innerAngle,\n+                        outerAngle, falloff);\n+            context.setLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange, dirX, dirY, dirZ,\n+                    innerAngle, outerAngle, falloff);\n@@ -113,1 +116,1 @@\n-    ES2Light[] getPointLights() {\n+    ES2Light[] getLights() {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2MeshView.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-        for (ES2Light light : meshView.getPointLights()) {\n+        for (ES2Light light : meshView.getLights()) {\n@@ -206,2 +206,2 @@\n-        int i = 0;\n-        for (ES2Light light : meshView.getPointLights()) {\n+        for (int i = 0; i < meshView.getLights().length; i++) {\n+            ES2Light light = meshView.getLights()[i];\n@@ -209,5 +209,1 @@\n-                shader.setConstant(\"lights[\" + i + \"].pos\", light.x, light.y, light.z, light.w);\n-                shader.setConstant(\"lights[\" + i + \"].color\", light.r, light.g, light.b);\n-                shader.setConstant(\"lights[\" + i + \"].attn\", light.ca, light.la, light.qa);\n-                shader.setConstant(\"lights[\" + i + \"].range\", light.maxRange);\n-                i++;\n+                setLightConstants(i, shader, light);\n@@ -217,0 +213,25 @@\n+\n+    private static void setLightConstants(int i, ES2Shader shader, ES2Light light) {\n+        shader.setConstant(\"lights[\" + i + \"].pos\", light.x, light.y, light.z, light.w);\n+        shader.setConstant(\"lights[\" + i + \"].color\", light.r, light.g, light.b);\n+        shader.setConstant(\"lights[\" + i + \"].attn\", light.ca, light.la, light.qa);\n+        shader.setConstant(\"lights[\" + i + \"].range\", light.maxRange);\n+        if (light.isPointLight()) {\n+            shader.setConstant(\"lights[\" + i + \"].dir\", 0f, 0f, 1f);\n+            shader.setConstant(\"lights[\" + i + \"].cosOuter\", -1f); \/\/ cos(180)\n+            shader.setConstant(\"lights[\" + i + \"].denom\", 2f);     \/\/ cos(0) - cos(180)\n+            shader.setConstant(\"lights[\" + i + \"].falloff\", 0f);\n+        } else {\n+            float dirX = light.dirX;\n+            float dirY = light.dirY;\n+            float dirZ = light.dirZ;\n+            float length = (float) Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);\n+            shader.setConstant(\"lights[\" + i + \"].dir\", dirX \/ length, dirY \/ length, dirZ \/ length);\n+            \/\/ preparing for: I = pow((cosAngle - cosOuter) \/ (cosInner - cosOuter), falloff);\n+            float cosOuter = (float) Math.cos(Math.toRadians(light.outerAngle));\n+            float cosInner = (float) Math.cos(Math.toRadians(light.innerAngle));\n+            shader.setConstant(\"lights[\" + i + \"].cosOuter\", cosOuter);\n+            shader.setConstant(\"lights[\" + i + \"].denom\", cosInner - cosOuter);\n+            shader.setConstant(\"lights[\" + i + \"].falloff\", light.falloff);\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2PhongShader.java","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -254,3 +254,3 @@\n-    private static native void nSetPointLight(long nativeCtxInfo, long nativeMeshViewInfo,\n-            int index, float x, float y, float z, float r, float g, float b, float w,\n-            float ca, float la, float qa, float maxRange);\n+    private static native void nSetLight(long nativeCtxInfo, long nativeMeshViewInfo,\n+            int index, float x, float y, float z, float r, float g, float b, float w, float ca, float la, float qa,\n+            float maxRange, float dirX, float dirY, float dirZ, float innerAngle, float outerAngle, float falloff);\n@@ -812,3 +812,5 @@\n-    void setPointLight(long nativeMeshViewInfo, int index, float x, float y, float z, float r, float g, float b, float w,\n-            float ca, float la, float qa, float maxRange) {\n-        nSetPointLight(nativeCtxInfo, nativeMeshViewInfo, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);\n+    void setLight(long nativeMeshViewInfo, int index, float x, float y, float z, float r, float g, float b, float w,\n+            float ca, float la, float qa, float maxRange, float dirX, float dirY, float dirZ,\n+            float innerAngle, float outerAngle, float falloff) {\n+        nSetLight(nativeCtxInfo, nativeMeshViewInfo, index, x, y, z, r, g, b, w, ca, la, qa, maxRange,\n+                dirX, dirY, dirZ, innerAngle, outerAngle, falloff);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/GLContext.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene;\n+\n+import com.sun.javafx.scene.DirtyBits;\n+import com.sun.javafx.scene.NodeHelper;\n+import com.sun.javafx.scene.SpotLightHelper;\n+import com.sun.javafx.sg.prism.NGNode;\n+import com.sun.javafx.sg.prism.NGSpotLight;\n+\n+import javafx.beans.property.DoubleProperty;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.geometry.Point3D;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.PhongMaterial;\n+\n+\/**\n+ * A {@code PointLight} that radiates light in a cone in a specific direction. The direction of the {@code SpotLight} is\n+ * defined by the {@link #directionProperty() direction} property.\n+ * <p>\n+ * The light cone is defined by 3 factors: an {@link #innerAngleProperty() inner angle}, an {@link #outerAngleProperty()\n+ * outer angle}, and a {@link #falloffProperty() falloff} factor. For a point whose angle to the light is {@code a}, if\n+ * {@code a < innerAngle} then that point receives maximum illumination, if {@code a > outerAngle} then that point\n+ * receives no illumination, and if {@code innerAngle <= a <= outerAngle} then the illumination is determined by the\n+ * formula\n+ * <pre>I = pow((cos(a) - cos(outer)) \/ (cos(inner) - cos(outer)), falloff)<\/pre>\n+ * which represents a drop in illumination from the inner angle to the outer angle. {@code falloff} determines the\n+ * behavior of the drop. The valid ranges for these properties are {@code 0 <= innerAngle <= outerAngle <= 180} and\n+ * {@code falloff >= 0}; values outside either of these ranges can produce unexpected results.\n+ * <p>\n+ * <img src=\"doc-files\/spotlight.png\" alt=\"Image of the Spotlight\">\n+ *\n+ * @since 17\n+ * @see PhongMaterial\n+ *\/\n+public class SpotLight extends PointLight {\n+    static {\n+        SpotLightHelper.setSpotLightAccessor(new SpotLightHelper.SpotLightAccessor() {\n+            @Override\n+            public NGNode doCreatePeer(Node node) {\n+                return ((SpotLight) node).doCreatePeer();\n+            }\n+\n+            @Override\n+            public void doUpdatePeer(Node node) {\n+                ((SpotLight) node).doUpdatePeer();\n+            }\n+        });\n+    }\n+\n+    {\n+        \/\/ To initialize the class helper at the beginning each constructor of this class\n+        SpotLightHelper.initHelper(this);\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@code SpotLight} class with a default {@code Color.WHITE} light source.\n+     *\/\n+    public SpotLight() {\n+        super();\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@code SpotLight} class using the specified color.\n+     *\n+     * @param color the color of the light source\n+     *\/\n+    public SpotLight(Color color) {\n+        super(color);\n+    }\n+\n+\n+    \/**\n+     * The direction the spotlight is facing. The vector need not be normalized.\n+     *\n+     * @defaultValue {@code Point3D(0, 0, 1)}\n+     *\/\n+    private ObjectProperty<Point3D> direction;\n+\n+    public final void setDirection(Point3D value) {\n+        directionProperty().set(value);\n+    }\n+\n+    private static final Point3D DEFAULT_DIRECTION = NGSpotLight.getDefaultDirection();\n+\n+    public final Point3D getDirection() {\n+        return direction == null ? DEFAULT_DIRECTION : direction.get();\n+    }\n+\n+    public final ObjectProperty<Point3D> directionProperty() {\n+        if (direction == null) {\n+            direction = new SimpleObjectProperty<>(this, \"direction\", DEFAULT_DIRECTION) {\n+                @Override\n+                protected void invalidated() {\n+                    NodeHelper.markDirty(SpotLight.this, DirtyBits.NODE_LIGHT);\n+                }\n+            };\n+        }\n+        return direction;\n+    }\n+\n+\n+    \/**\n+     * The angle of the spotlight's inner cone. Surfaces whose angle to the light's origin is less than this angle\n+     * receive the full light's intensity. At larger angles, the light intensity starts to drop. The valid range is\n+     * {@code 0 <= innerAngle <= outerAngle}; values outside of this range can produce unexpected results.\n+     *\n+     * @defaultValue 0\n+     *\/\n+    private DoubleProperty innerAngle;\n+\n+    public final void setInnerAngle(double value) {\n+        innerAngleProperty().set(value);\n+    }\n+\n+    private static final double DEFAULT_INNER_ANGLE = NGSpotLight.getDefaultInnerAngle();\n+\n+    public final double getInnerAngle() {\n+        return innerAngle == null ? DEFAULT_INNER_ANGLE : innerAngle.get();\n+    }\n+\n+    public final DoubleProperty innerAngleProperty() {\n+        if (innerAngle == null) {\n+            innerAngle = getLightDoubleProperty(\"innerAngle\", DEFAULT_INNER_ANGLE);\n+        }\n+        return innerAngle;\n+    }\n+\n+\n+    \/**\n+     * The angle of the spotlight's outer cone. Surfaces whose angle to the light's origin is greater than this angle\n+     * receive no light. At smaller angles, the light intensity starts to increase. The valid range is\n+     * {@code innerAngle <= outerAngle <= 180}; values outside of this range can produce unexpected results.\n+     *\n+     * @defaultValue 30\n+     *\/\n+    private DoubleProperty outerAngle;\n+\n+    public final void setOuterAngle(double value) {\n+        outerAngleProperty().set(value);\n+    }\n+\n+    private static final double DEFAULT_OUTER_ANGLE = NGSpotLight.getDefaultOuterAngle();\n+\n+    public final double getOuterAngle() {\n+        return outerAngle == null ? DEFAULT_OUTER_ANGLE : outerAngle.get();\n+    }\n+\n+    public final DoubleProperty outerAngleProperty() {\n+        if (outerAngle == null) {\n+            outerAngle = getLightDoubleProperty(\"outerAngle\", DEFAULT_OUTER_ANGLE);\n+        }\n+        return outerAngle;\n+    }\n+\n+\n+    \/**\n+     * The intensity falloff factor of the spotlight's outer cone. Surfaces whose angle to the light's origin is greater\n+     * than the inner angle but less than the outer angle receive partial intensity governed by this factor. The larger\n+     * the falloff, the sharper the drop in intensity from the inner cone. A falloff factor of 1 gives a linear drop in\n+     * intensity, values greater than 1 give a convex drop, and values smaller than 1 give a concave drop. The valid\n+     * range is {@code 0 <= falloff}; values outside of this range can produce unexpected results.\n+     *\n+     * @defaultValue 1\n+     *\/\n+    private DoubleProperty falloff;\n+\n+    public final void setFalloff(double value) {\n+        falloffProperty().set(value);\n+    }\n+\n+    private static final double DEFAULT_FALLOFF = NGSpotLight.getDefaultFalloff();\n+\n+    public final double getFalloff() {\n+        return falloff == null ? DEFAULT_FALLOFF : falloff.get();\n+    }\n+\n+    public final DoubleProperty falloffProperty() {\n+        if (falloff == null) {\n+            falloff = getLightDoubleProperty(\"falloff\", DEFAULT_FALLOFF);\n+        }\n+        return falloff;\n+    }\n+\n+    \/*\n+     * Note: This method MUST only be called via its accessor method.\n+     *\/\n+    private NGNode doCreatePeer() {\n+        return new NGSpotLight();\n+    }\n+\n+    private void doUpdatePeer() {\n+        if (isDirty(DirtyBits.NODE_LIGHT)) {\n+            NGSpotLight peer = getPeer();\n+            peer.setDirection(getDirection());\n+            peer.setInnerAngle((float) getInnerAngle());\n+            peer.setOuterAngle((float) getOuterAngle());\n+            peer.setFalloff((float) getFalloff());\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/SpotLight.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -514,2 +514,2 @@\n- * Method:    nSetPointLight\n- * Signature: (JJIFFFFFFF)V\n+ * Method:    nSetLight\n+ * Signature: (JJIFFFFFFFFFFFFFFFFF)V\n@@ -517,1 +517,1 @@\n-JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nSetPointLight\n+JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nSetLight\n@@ -520,1 +520,2 @@\n-        jfloat ca, jfloat la, jfloat qa, jfloat range)\n+        jfloat ca, jfloat la, jfloat qa, jfloat range,\n+        jfloat dirX, jfloat dirY, jfloat dirZ, jfloat innerAngle, jfloat outerAngle, jfloat falloff)\n@@ -522,1 +523,1 @@\n-    TraceLn(NWT_TRACE_INFO, \"D3DContext_nSetPointLight\");\n+    TraceLn(NWT_TRACE_INFO, \"D3DContext_nSetLight\");\n@@ -525,1 +526,1 @@\n-    meshView->setPointLight(index, x, y, z, r, g, b, w, ca, la, qa, range);\n+    meshView->setLight(index, x, y, z, r, g, b, w, ca, la, qa, range, dirX, dirY, dirZ, innerAngle, outerAngle, falloff);\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DContext.cc","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,13 +37,14 @@\n-D3DLight::D3DLight() {\n-    color[0] = 0;\n-    color[1] = 0;\n-    color[2] = 0;\n-    position[0] = 0;\n-    position[1] = 0;\n-    position[2] = 0;\n-    position[3] = 0; \/\/ padding since SetPixelShaderConstantF only takes vec4f; position[3] is unused\n-    w = 0;\n-    attenuation[0] = 1;\n-    attenuation[1] = 0;\n-    attenuation[2] = 0;\n-    maxRange = 0;\n+D3DLight::D3DLight() :\n+    color(),\n+    position(),\n+    w(0),\n+    attenuation(),\n+    maxRange(0),\n+    direction(),\n+    innerAngle(0),\n+    outerAngle(0),\n+    falloff(0)\n+    {}\n+\n+bool D3DLight::isPointLight() {\n+    return falloff == 0 && outerAngle == 180;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DLight.cc","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+    bool isPointLight();\n@@ -39,2 +40,2 @@\n-\/\/  void setRange(float r);\n-    float position[4]; \/\/ Only need x, y, z. The last float is needed for padding when upload to shader.\n+\n+    float position[3];\n@@ -45,0 +46,4 @@\n+    float direction[3];\n+    float innerAngle;\n+    float outerAngle;\n+    float falloff;\n@@ -51,1 +56,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DLight.h","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+#define _USE_MATH_DEFINES\n+#include <math.h>\n@@ -40,1 +42,0 @@\n-\n@@ -75,3 +76,3 @@\n-void D3DMeshView::setPointLight(int index, float x, float y, float z,\n-        float r, float g, float b, float w,\n-        float ca, float la, float qa, float maxRange) {\n+void D3DMeshView::setLight(int index, float x, float y, float z, float r, float g, float b, float w,\n+        float ca, float la, float qa, float maxRange,\n+        float dirX, float dirY, float dirZ, float innerAngle, float outerAngle, float falloff) {\n@@ -79,12 +80,19 @@\n-    if (index >= 0 && index <= 2) {\n-        lights[index].position[0] = x;\n-        lights[index].position[1] = y;\n-        lights[index].position[2] = z;\n-        lights[index].color[0] = r;\n-        lights[index].color[1] = g;\n-        lights[index].color[2] = b;\n-        lights[index].w = w;\n-        lights[index].attenuation[0] = ca;\n-        lights[index].attenuation[1] = la;\n-        lights[index].attenuation[2] = qa;\n-        lights[index].maxRange = maxRange;\n+    if (index >= 0 && index <= MAX_NUM_LIGHTS - 1) {\n+        D3DLight& light = lights[index];\n+        light.position[0] = x;\n+        light.position[1] = y;\n+        light.position[2] = z;\n+        light.color[0] = r;\n+        light.color[1] = g;\n+        light.color[2] = b;\n+        light.w = w;\n+        light.attenuation[0] = ca;\n+        light.attenuation[1] = la;\n+        light.attenuation[2] = qa;\n+        light.maxRange = maxRange;\n+        light.direction[0] = dirX;\n+        light.direction[1] = dirY;\n+        light.direction[2] = dirZ;\n+        light.innerAngle = innerAngle;\n+        light.outerAngle = outerAngle;\n+        light.falloff = falloff;\n@@ -101,1 +109,1 @@\n-    for (int i = 0; i != 3; ++i)\n+    for (int i = 0; i != MAX_NUM_LIGHTS; ++i)\n@@ -140,1 +148,1 @@\n-    for (int i = 0; i < 3; i++) {\n+    for (int i = 0; i < MAX_NUM_LIGHTS; i++) {\n@@ -144,0 +152,25 @@\n+    float lighsNormDirection[MAX_NUM_LIGHTS * 4]; \/\/ 3 lights x (3 coords + 1 padding)\n+    for (int i = 0, d = 0; i < MAX_NUM_LIGHTS; i++) {\n+        if (lights[i].isPointLight()) {\n+            lighsNormDirection[d++] = 0;\n+            lighsNormDirection[d++] = 0;\n+            lighsNormDirection[d++] = 1;\n+            lighsNormDirection[d++] = 0;\n+        } else {\n+            float dirX = lights[i].direction[0];\n+            float dirY = lights[i].direction[1];\n+            float dirZ = lights[i].direction[2];\n+            float length = sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);\n+            lighsNormDirection[d++] = dirX \/ length;\n+            lighsNormDirection[d++] = dirY \/ length;\n+            lighsNormDirection[d++] = dirZ \/ length;\n+            lighsNormDirection[d++] = 0;\n+        }\n+    }\n+\n+    status = SUCCEEDED(device->SetVertexShaderConstantF(VSR_DIRS, lighsNormDirection, MAX_NUM_LIGHTS));\n+    if (!status) {\n+        cout << \"D3DMeshView.render() - SetVertexShaderConstantF (VSR_DIRS) failed !!!\" << endl;\n+        return;\n+    }\n+\n@@ -162,4 +195,5 @@\n-    float lightsColor[12];       \/\/ 3 lights x (3 color + 1 padding)\n-    float lightsAttenuation[12]; \/\/ 3 lights x (3 attenuation factors + 1 padding)\n-    float lightsRange[12];       \/\/ 3 lights x (1 maxRange + 3 padding)\n-    for (int i = 0, c = 0, a = 0, r = 0; i < 3; i++) {\n+    float lightsColor[MAX_NUM_LIGHTS * 4];        \/\/ 3 lights x (3 color + 1 padding)\n+    float lightsAttenuation[MAX_NUM_LIGHTS * 4];  \/\/ 3 lights x (3 attenuation factors + 1 padding)\n+    float lightsRange[MAX_NUM_LIGHTS * 4];        \/\/ 3 lights x (1 maxRange + 3 padding)\n+    float spotLightsFactors[MAX_NUM_LIGHTS * 4];  \/\/ 3 lights x (2 angles + 1 falloff + 1 padding)\n+    for (int i = 0, c = 0, a = 0, r = 0, s = 0; i < MAX_NUM_LIGHTS; i++) {\n@@ -181,0 +215,15 @@\n+\n+        if (lights[i].isPointLight()) {\n+            spotLightsFactors[s++] = -1; \/\/ cos(180)\n+            spotLightsFactors[s++] = 2;  \/\/ cos(0) - cos(180)\n+            spotLightsFactors[s++] = 0;\n+            spotLightsFactors[s++] = 0;\n+        } else {\n+            \/\/ preparing for: I = pow((cosAngle - cosOuter) \/ (cosInner - cosOuter), falloff)\n+            float cosInner = cos(lights[i].innerAngle * M_PI \/ 180);\n+            float cosOuter = cos(lights[i].outerAngle * M_PI \/ 180);\n+            spotLightsFactors[s++] = cosOuter;\n+            spotLightsFactors[s++] = cosInner - cosOuter;\n+            spotLightsFactors[s++] = lights[i].falloff;\n+            spotLightsFactors[s++] = 0;\n+        }\n@@ -182,1 +231,2 @@\n-    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHTCOLOR, lightsColor, 3));\n+\n+    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHTCOLOR, lightsColor, MAX_NUM_LIGHTS));\n@@ -184,1 +234,1 @@\n-        cout << \"D3DMeshView.render() - SetPixelShaderConstantF (PSR_LIGHTCOLOR) failed !!!\" << endl;\n+        cout << \"D3DMeshView.render() - SetPixelShaderConstantF(PSR_LIGHTCOLOR) failed !!!\" << endl;\n@@ -187,1 +237,2 @@\n-    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHT_ATTENUATION, lightsAttenuation, 3));\n+\n+    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHT_ATTENUATION, lightsAttenuation, MAX_NUM_LIGHTS));\n@@ -189,1 +240,1 @@\n-        cout << \"D3DMeshView.render() - SetPixelShaderConstantF (PSR_LIGHT_ATTENUATION) failed !!!\" << endl;\n+        cout << \"D3DMeshView.render() - SetPixelShaderConstantF(PSR_LIGHT_ATTENUATION) failed !!!\" << endl;\n@@ -192,1 +243,2 @@\n-    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHT_RANGE, lightsRange, 3));\n+\n+    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHT_RANGE, lightsRange, MAX_NUM_LIGHTS));\n@@ -194,1 +246,7 @@\n-        cout << \"D3DMeshView.render() - SetPixelShaderConstantF (PSR_LIGHT_RANGE) failed !!!\" << endl;\n+        cout << \"D3DMeshView.render() - SetPixelShaderConstantF(PSR_LIGHT_RANGE) failed !!!\" << endl;\n+        return;\n+    }\n+\n+    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_SPOTLIGHT_FACTORS, spotLightsFactors, MAX_NUM_LIGHTS));\n+    if (!status) {\n+        cout << \"D3DMeshView.render() - SetPixelShaderConstantF(PSR_SPOTLIGHT_FACTORS) failed !!!\" << endl;\n@@ -237,1 +295,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DMeshView.cc","additions":87,"deletions":30,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+#define MAX_NUM_LIGHTS 3\n+\n@@ -42,1 +44,1 @@\n-    void setPointLight(int index, float x, float y, float z,\n+    void setLight(int index, float x, float y, float z,\n@@ -44,1 +46,3 @@\n-        float ca, float la, float qa, float maxRange);\n+        float ca, float la, float qa, float maxRange,\n+        float dirX, float dirY, float dirZ,\n+        float innerAngle, float outerAngle, float falloff);\n@@ -52,1 +56,1 @@\n-    D3DLight lights[3];\n+    D3DLight lights[MAX_NUM_LIGHTS];\n@@ -61,1 +65,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DMeshView.h","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+\/\/ 5 light directions\n+#define VSR_DIRS 20\n@@ -37,1 +39,1 @@\n-#define VSR_AMBIENTCOLOR 20\n+#define VSR_AMBIENTCOLOR 25\n@@ -39,1 +41,1 @@\n-#define VSR_WORLDMATRIX 30\n+#define VSR_WORLDMATRIX 35\n@@ -45,3 +47,4 @@\n-#define PSR_LIGHTCOLOR 4        \/\/ 3 lights + 2 reserve\n-#define PSR_LIGHT_ATTENUATION 9 \/\/ 3 lights + 2 reserve\n-#define PSR_LIGHT_RANGE 14      \/\/ 3 lights + 2 reserve\n+#define PSR_LIGHTCOLOR 4         \/\/ 3 lights + 2 reserve\n+#define PSR_LIGHT_ATTENUATION 9  \/\/ 3 lights + 2 reserve\n+#define PSR_LIGHT_RANGE 14       \/\/ 3 lights + 2 reserve\n+#define PSR_SPOTLIGHT_FACTORS 19 \/\/ 3 lights + 2 reserve\n@@ -112,1 +115,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DPhongShader.h","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-    phong(n, nEye, sPower, lSpace.lights, diff, spec, 0, nSpecular);\n+    phong(n, nEye, sPower, lSpace.lights, lSpace.lightDirs, diff, spec, 0, nSpecular);\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/Mtl1PS.hlsl","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-static const int numMaxLights = 5;\n+static const int numMaxLights = 3;\n@@ -32,3 +32,4 @@\n-float4 gLightColor[numMaxLights] : register(c4); \/\/ [c4 .. c8]\n-float4 gLightAttenuation[numMaxLights] : register(c9); \/\/ [c9 .. c13]\n-float4 gLightRange[numMaxLights] : register(c14); \/\/ [c14 .. c18]\n+float4 gLightColor[numMaxLights] : register(c4);\n+float4 gLightAttenuation[numMaxLights] : register(c9);\n+float4 gLightRange[numMaxLights] : register(c14);\n+float4 gSpotLightFactors[numMaxLights] : register(c19); \/\/ {cos(outer), cos(inner) - cos(outer), falloff, _}\n@@ -36,1 +37,1 @@\n-float4 gSomethingElse : register(c19);\n+float4 gSomethingElse : register(c24);\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/psConstants.h","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,4 +61,61 @@\n-void phong(\n-    float3 n, float3 e, float power, in float4 L[LocalBump::nLights],\n-    in out float3 d, in out float3 s, int _s, int _e)\n-{\n+\/\/ Because pow(0, 0) is undefined (https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/direct3dhlsl\/dx-graphics-hlsl-pow),\n+\/\/ we need special treatment for falloff == 0 cases\n+float computeSpotlightFactor(float3 l, float3 lightDir, float cosOuter, float denom, float falloff) {\n+    if (falloff == 0 && cosOuter == -1) { \/\/ point light optimization (cosOuter == -1 is outerAngle == 180)\n+        return 1;\n+    }\n+    float cosAngle = dot(normalize(-lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0) {\n+        return pow(saturate(cutoff \/ denom), falloff);\n+    }\n+    return cutoff >= 0 ? 1 : 0;\n+}\n+\n+float computeSpotlightFactor2(float3 l, float3 lightDir, float cosOuter, float denom, float falloff) {\n+    if (falloff != 0) {\n+        float cosAngle = dot(normalize(-lightDir), l);\n+        float cutoff = cosAngle - cosOuter;\n+        return pow(saturate(cutoff \/ denom), falloff);\n+    }\n+    if (cosOuter == -1) {  \/\/ point light optimization (cosOuter == -1 is outerAngle == 180)\n+        return 1;\n+    }\n+    float cosAngle = dot(normalize(-lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    return cutoff >= 0 ? 1 : 0;\n+}\n+\n+float computeSpotlightFactor3(float3 l, float3 lightDir, float cosOuter, float denom, float falloff) {\n+    float cosAngle = dot(normalize(-lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0) {\n+        return pow(saturate(cutoff \/ denom), falloff);\n+    }\n+    return cutoff >= 0 ? 1 : 0;\n+}\n+\n+void computeLight(float i, float3 n, float3 refl, float specPower, float3 L, float3 lightDir, in out float3 d, in out float3 s) {\n+    float dist = length(L);\n+    if (dist > gLightRange[i].x) {\n+        return;\n+    }\n+    float3 l = normalize(L);\n+\n+    float cosOuter = gSpotLightFactors[i].x;\n+    float denom = gSpotLightFactors[i].y;\n+    float falloff = gSpotLightFactors[i].z;\n+    float spotlightFactor = computeSpotlightFactor3(l, lightDir, cosOuter, denom, falloff);\n+\n+    float ca = gLightAttenuation[i].x;\n+    float la = gLightAttenuation[i].y;\n+    float qa = gLightAttenuation[i].z;\n+    float invAttnFactor = ca + la * dist + qa * dist * dist;\n+\n+    float3 attenuatedColor = gLightColor[i].xyz * spotlightFactor \/ invAttnFactor;\n+    d += saturate(dot(n, l)) * attenuatedColor;\n+    s += pow(saturate(dot(-refl, l)), specPower) * attenuatedColor;\n+}\n+\n+void phong(float3 n, float3 e, float specPower, in float4 L[LocalBump::nLights], in float4 lightDirs[LocalBump::nLights],\n+        in out float3 d, in out float3 s, int _s, int _e) {\n@@ -67,11 +124,1 @@\n-        float dist = length(L[i].xyz);\n-        if (dist <= gLightRange[i].x) {\n-            float ca = gLightAttenuation[i].x;\n-            float la = gLightAttenuation[i].y;\n-            float qa = gLightAttenuation[i].z;\n-            float3 attenuatedColor = gLightColor[i].xyz \/ (ca + la * dist + qa * dist * dist);\n-\n-            float3 l = normalize(L[i].xyz);\n-            d += saturate(dot(n, l)) * attenuatedColor;\n-            s += pow(saturate(dot(-refl, l)), power) * attenuatedColor;\n-        }\n+        computeLight(i, n, refl, specPower, L[i].xyz, lightDirs[i].xyz, d, s);\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/psMath.h","additions":63,"deletions":16,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020 Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,4 @@\n-    float3  eye             : texcoord2;\n-    float4  lights[nLights] : texcoord3; \/\/ 3, 4,5 [6]\n-    float3  debug           : texcoord7;\n+    float3 eye               : texcoord2;\n+    float4 lights[nLights]   : texcoord3; \/\/ 3, 4, 5 [6]\n+    float4 lightDirs[nLights] : texcoord7; \/\/ 7, 8, 9 [10]\n+\/\/    float3 debug             : texcoord11;\n@@ -42,1 +43,1 @@\n-    float   oFog  : fog;\n+    float   oFog : fog;\n@@ -52,1 +53,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/vs2ps.h","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-float4x4    mViewProj   : register (c0);\n+float4x4    mViewProj   : register(c0);\n@@ -49,3 +49,4 @@\n-Light       sLights[5]   : register(c10);\n-float4      gAmbinet         : register (c20);\n-float4      gAmbinetData[10] : register (c20);\n+Light       sLights[5]        : register(c10);\n+float4      gLightsNormDir[5] : register(c20);\n+float4      gAmbinet          : register(c25);\n+float4      gAmbinetData[10]  : register(c25);\n@@ -54,2 +55,2 @@\n-float4x3    mWorld                : register (c30);\n-float4x3    mBones[MAX_BONES]     : register (c30);\n+float4x3    mWorld            : register(c35);\n+float4x3    mBones[MAX_BONES] : register(c35);\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/vsConstants.h","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,1 @@\n+        float3 D = gLightsNormDir[k].xyz;\n@@ -78,0 +79,1 @@\n+        r.lBump.lightDirs[k] = float4(getLocalVector(D, n), 1);\n@@ -82,1 +84,1 @@\n-    \/\/ r.Debug = r.Pos;\n+\/\/    r.Debug = r.Pos;\n@@ -84,1 +86,1 @@\n-    r.lBump.debug = n[0];\n+\/\/    r.lBump.debug = n[0];\n@@ -91,2 +93,0 @@\n-\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/vsMath.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2117,12 +2117,18 @@\n-    meshViewInfo->pointLightIndex = 0;\n-    meshViewInfo->pointLightColor[0] = 0;\n-    meshViewInfo->pointLightColor[1] = 0;\n-    meshViewInfo->pointLightColor[2] = 0;\n-    meshViewInfo->pointLightPosition[0] = 0;\n-    meshViewInfo->pointLightPosition[1] = 0;\n-    meshViewInfo->pointLightPosition[2] = 0;\n-    meshViewInfo->pointLightWeight = 0;\n-    meshViewInfo->pointLightAttenuation[0] = 1;\n-    meshViewInfo->pointLightAttenuation[1] = 0;\n-    meshViewInfo->pointLightAttenuation[2] = 0;\n-    meshViewInfo->pointLightMaxRange = 0;\n+    meshViewInfo->lightIndex = 0;\n+    meshViewInfo->lightColor[0] = 0;\n+    meshViewInfo->lightColor[1] = 0;\n+    meshViewInfo->lightColor[2] = 0;\n+    meshViewInfo->lightPosition[0] = 0;\n+    meshViewInfo->lightPosition[1] = 0;\n+    meshViewInfo->lightPosition[2] = 0;\n+    meshViewInfo->lightWeight = 0;\n+    meshViewInfo->lightAttenuation[0] = 1;\n+    meshViewInfo->lightAttenuation[1] = 0;\n+    meshViewInfo->lightAttenuation[2] = 0;\n+    meshViewInfo->lightMaxRange = 0;\n+    meshViewInfo->lightDir[0] = 1;\n+    meshViewInfo->lightDir[1] = 0;\n+    meshViewInfo->lightDir[2] = 0;\n+    meshViewInfo->lightInnerAngle = 0;\n+    meshViewInfo->lightOuterAngle = 0;\n+    meshViewInfo->lightFalloff = 0;\n@@ -2267,2 +2273,2 @@\n- * Method:    nSetPointLight\n- * Signature: (JJIFFFFFFF)V\n+ * Method:    nSetLight\n+ * Signature: (JJIFFFFFFFFFFFFFFFFF)V\n@@ -2270,1 +2276,1 @@\n-JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetPointLight\n+JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetLight\n@@ -2273,1 +2279,2 @@\n-        jfloat ca, jfloat la, jfloat qa, jfloat maxRange)\n+        jfloat ca, jfloat la, jfloat qa, jfloat maxRange, jfloat dirX, jfloat dirY, jfloat dirZ,\n+        jfloat innerAngle, jfloat outerAngle, jfloat falloff)\n@@ -2281,12 +2288,18 @@\n-    meshViewInfo->pointLightIndex = index;\n-    meshViewInfo->pointLightPosition[0] = x;\n-    meshViewInfo->pointLightPosition[1] = y;\n-    meshViewInfo->pointLightPosition[2] = z;\n-    meshViewInfo->pointLightColor[0] = r;\n-    meshViewInfo->pointLightColor[1] = g;\n-    meshViewInfo->pointLightColor[2] = b;\n-    meshViewInfo->pointLightWeight = w;\n-    meshViewInfo->pointLightAttenuation[0] = ca;\n-    meshViewInfo->pointLightAttenuation[1] = la;\n-    meshViewInfo->pointLightAttenuation[2] = qa;\n-    meshViewInfo->pointLightMaxRange = maxRange;\n+    meshViewInfo->lightIndex = index;\n+    meshViewInfo->lightPosition[0] = x;\n+    meshViewInfo->lightPosition[1] = y;\n+    meshViewInfo->lightPosition[2] = z;\n+    meshViewInfo->lightColor[0] = r;\n+    meshViewInfo->lightColor[1] = g;\n+    meshViewInfo->lightColor[2] = b;\n+    meshViewInfo->lightWeight = w;\n+    meshViewInfo->lightAttenuation[0] = ca;\n+    meshViewInfo->lightAttenuation[1] = la;\n+    meshViewInfo->lightAttenuation[2] = qa;\n+    meshViewInfo->lightMaxRange = maxRange;\n+    meshViewInfo->lightDir[0] = dirX;\n+    meshViewInfo->lightDir[1] = dirY;\n+    meshViewInfo->lightDir[2] = dirZ;\n+    meshViewInfo->lightInnerAngle = innerAngle;\n+    meshViewInfo->lightOuterAngle = outerAngle;\n+    meshViewInfo->lightFalloff = falloff;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-es2\/GLContext.c","additions":41,"deletions":28,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -379,6 +379,10 @@\n-    GLuint pointLightIndex;\n-    GLfloat pointLightWeight;\n-    GLfloat pointLightPosition[3];\n-    GLfloat pointLightColor[3];\n-    GLfloat pointLightAttenuation[3];\n-    GLfloat pointLightMaxRange;\n+    GLuint lightIndex;\n+    GLfloat lightColor[3];\n+    GLfloat lightPosition[3];\n+    GLfloat lightWeight;\n+    GLfloat lightAttenuation[3];\n+    GLfloat lightMaxRange;\n+    GLfloat lightDir[3];\n+    GLfloat lightInnerAngle;\n+    GLfloat lightOuterAngle;\n+    GLfloat lightFalloff;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-es2\/PrismES2Defs.h","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,4 @@\n+    vec3 dir;\n+    float cosOuter;\n+    float denom; \/\/ cosInner - cosOuter\n+    float falloff;\n@@ -46,0 +50,1 @@\n+varying vec4 lightTangentSpaceDirections[3];\n@@ -100,0 +105,9 @@\n+    vec3 D = lights[0].dir.xyz;\n+    lightTangentSpaceDirections[0] = vec4( getLocalVector(D,tangentFrame), 1.0);\n+\n+    D = lights[1].dir.xyz;\n+    lightTangentSpaceDirections[1] = vec4( getLocalVector(D,tangentFrame), 1.0);\n+\n+    D = lights[2].dir.xyz;\n+    lightTangentSpaceDirections[2] = vec4( getLocalVector(D,tangentFrame), 1.0);\n+\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main.vert","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+    vec3 dir;\n+    float cosOuter;\n+    float denom; \/\/ cosInner - cosOuter\n+    float falloff;\n@@ -70,0 +74,57 @@\n+varying vec4 lightTangentSpaceDirections[3];\n+\n+\/\/ Because pow(0, 0) is undefined (https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/direct3dhlsl\/dx-graphics-hlsl-pow),\n+\/\/ we need special treatment for falloff == 0 cases\n+float computeSpotlightFactor(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    if (falloff == 0.0 && cosOuter == -1.0) { \/\/ point light optimization (cosOuter == -1 is outerAngle == 180)\n+        return 1.0;\n+    }\n+    float cosAngle = dot(normalize(-lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0.0) {\n+        return pow(clamp(cutoff \/ denom, 0.0, 1.0), falloff);\n+    }\n+    return cutoff >= 0.0 ? 1.0 : 0.0;\n+}\n+\n+float computeSpotlightFactor2(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    if (falloff != 0.0) {\n+        float cosAngle = dot(normalize(-lightDir), l);\n+        float cutoff = cosAngle - cosOuter;\n+        return pow(clamp(cutoff \/ denom, 0.0, 1.0), falloff);\n+    }\n+    if (cosOuter == -1.0) {  \/\/ point light optimization (cosOuter == -1 is outerAngle == 180)\n+        return 1.0;\n+    }\n+    float cosAngle = dot(normalize(-lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    return cutoff >= 0.0 ? 1.0 : 0.0;\n+}\n+\n+float computeSpotlightFactor3(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    float cosAngle = dot(normalize(-lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0.0) {\n+        return pow(clamp(cutoff \/ denom, 0.0, 1.0), falloff);\n+    }\n+    return cutoff >= 0.0 ? 1.0 : 0.0;\n+}\n+\n+void computeLight(int i, vec3 n, vec3 refl, float specPower, out vec3 d, out vec3 s) {\n+    Light light = lights[i];\n+    vec3 pos = lightTangentSpacePositions[i].xyz;\n+    float dist = length(pos);\n+    if (dist > light.range) {\n+        return;\n+    }\n+    vec3 l = normalize(pos);\n+\n+    vec3 lightDir = lightTangentSpaceDirections[i].xyz;\n+    float spotlightFactor = computeSpotlightFactor3(l, lightDir, light.cosOuter, light.denom, light.falloff);\n+\n+    float invAttnFactor = light.attn.x + light.attn.y * dist + light.attn.z * dist * dist;\n+\n+    vec3 attenuatedColor = light.color.rgb * spotlightFactor \/ invAttnFactor;\n+    d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;\n+    s += pow(clamp(dot(-refl, l), 0.0, 1.0), specPower) * attenuatedColor;\n+}\n@@ -77,0 +138,3 @@\n+    vec3 n = apply_normal();\n+    vec3 refl = reflect(normalize(eyePos), n);\n+\n@@ -81,0 +145,1 @@\n+    float power = specular.a;\n@@ -82,6 +147,1 @@\n-    float maxRange = lights[0].range;\n-    float dist = length(lightTangentSpacePositions[0].xyz);\n-    if (dist <= maxRange) {\n-        vec3 n = apply_normal();\n-        vec3 refl = reflect(normalize(eyePos), n);\n-        vec3 l = normalize(lightTangentSpacePositions[0].xyz);\n+    computeLight(0, n, refl, power, d, s);\n@@ -89,6 +149,0 @@\n-        float power = specular.a;\n-\n-        vec3 attenuatedColor = (lights[0].color).rgb \/ (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);\n-        d = clamp(dot(n, l), 0.0, 1.0) * attenuatedColor;\n-        s = pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n-    }\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main1Light.frag","additions":66,"deletions":12,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+    vec3 dir;\n+    float cosOuter;\n+    float denom; \/\/ cosInner - cosOuter\n+    float falloff;\n@@ -70,0 +74,57 @@\n+varying vec4 lightTangentSpaceDirections[3];\n+\n+\/\/ Because pow(0, 0) is undefined (https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/direct3dhlsl\/dx-graphics-hlsl-pow),\n+\/\/ we need special treatment for falloff == 0 cases\n+float computeSpotlightFactor(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    if (falloff == 0.0 && cosOuter == -1.0) { \/\/ point light optimization (cosOuter == -1 is outerAngle == 180)\n+        return 1.0;\n+    }\n+    float cosAngle = dot(normalize(-lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0.0) {\n+        return pow(clamp(cutoff \/ denom, 0.0, 1.0), falloff);\n+    }\n+    return cutoff >= 0.0 ? 1.0 : 0.0;\n+}\n+\n+float computeSpotlightFactor2(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    if (falloff != 0.0) {\n+        float cosAngle = dot(normalize(-lightDir), l);\n+        float cutoff = cosAngle - cosOuter;\n+        return pow(clamp(cutoff \/ denom, 0.0, 1.0), falloff);\n+    }\n+    if (cosOuter == -1.0) {  \/\/ point light optimization (cosOuter == -1 is outerAngle == 180)\n+        return 1.0;\n+    }\n+    float cosAngle = dot(normalize(-lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    return cutoff >= 0.0 ? 1.0 : 0.0;\n+}\n+\n+float computeSpotlightFactor3(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    float cosAngle = dot(normalize(-lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0.0) {\n+        return pow(clamp(cutoff \/ denom, 0.0, 1.0), falloff);\n+    }\n+    return cutoff >= 0.0 ? 1.0 : 0.0;\n+}\n+\n+void computeLight(int i, vec3 n, vec3 refl, float specPower, out vec3 d, out vec3 s) {\n+    Light light = lights[i];\n+    vec3 pos = lightTangentSpacePositions[i].xyz;\n+    float dist = length(pos);\n+    if (dist > light.range) {\n+        return;\n+    }\n+    vec3 l = normalize(pos);\n+\n+    vec3 lightDir = lightTangentSpaceDirections[i].xyz;\n+    float spotlightFactor = computeSpotlightFactor3(l, lightDir, light.cosOuter, light.denom, light.falloff);\n+\n+    float invAttnFactor = light.attn.x + light.attn.y * dist + light.attn.z * dist * dist;\n+\n+    vec3 attenuatedColor = light.color.rgb * spotlightFactor \/ invAttnFactor;\n+    d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;\n+    s += pow(clamp(dot(-refl, l), 0.0, 1.0), specPower) * attenuatedColor;\n+}\n@@ -86,8 +147,2 @@\n-    float maxRange = lights[0].range;\n-    float dist = length(lightTangentSpacePositions[0].xyz);\n-    if (dist <= maxRange) {\n-        vec3 l = normalize(lightTangentSpacePositions[0].xyz);\n-        vec3 attenuatedColor = (lights[0].color).rgb \/ (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);\n-        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;\n-        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n-    }\n+    computeLight(0, n, refl, power, d, s);\n+    computeLight(1, n, refl, power, d, s);\n@@ -95,8 +150,0 @@\n-    maxRange = lights[1].range;\n-    dist = length(lightTangentSpacePositions[1].xyz);\n-    if (dist <= maxRange) {\n-        vec3 l = normalize(lightTangentSpacePositions[1].xyz);\n-        vec3 attenuatedColor = (lights[1].color).rgb \/ (lights[1].attn.x + lights[1].attn.y * dist + lights[1].attn.z * dist * dist);\n-        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;\n-        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n-    }\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main2Lights.frag","additions":63,"deletions":16,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+    vec3 dir;\n+    float cosOuter;\n+    float denom; \/\/ cosInner - cosOuter\n+    float falloff;\n@@ -70,0 +74,57 @@\n+varying vec4 lightTangentSpaceDirections[3];\n+\n+\/\/ Because pow(0, 0) is undefined (https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/direct3dhlsl\/dx-graphics-hlsl-pow),\n+\/\/ we need special treatment for falloff == 0 cases\n+float computeSpotlightFactor(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    if (falloff == 0.0 && cosOuter == -1.0) { \/\/ point light optimization (cosOuter == -1 is outerAngle == 180)\n+        return 1.0;\n+    }\n+    float cosAngle = dot(normalize(-lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0.0) {\n+        return pow(clamp(cutoff \/ denom, 0.0, 1.0), falloff);\n+    }\n+    return cutoff >= 0.0 ? 1.0 : 0.0;\n+}\n+\n+float computeSpotlightFactor2(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    if (falloff != 0.0) {\n+        float cosAngle = dot(normalize(-lightDir), l);\n+        float cutoff = cosAngle - cosOuter;\n+        return pow(clamp(cutoff \/ denom, 0.0, 1.0), falloff);\n+    }\n+    if (cosOuter == -1.0) {  \/\/ point light optimization (cosOuter == -1 is outerAngle == 180)\n+        return 1.0;\n+    }\n+    float cosAngle = dot(normalize(-lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    return cutoff >= 0.0 ? 1.0 : 0.0;\n+}\n+\n+float computeSpotlightFactor3(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    float cosAngle = dot(normalize(-lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0.0) {\n+        return pow(clamp(cutoff \/ denom, 0.0, 1.0), falloff);\n+    }\n+    return cutoff >= 0.0 ? 1.0 : 0.0;\n+}\n+\n+void computeLight(int i, vec3 n, vec3 refl, float specPower, out vec3 d, out vec3 s) {\n+    Light light = lights[i];\n+    vec3 pos = lightTangentSpacePositions[i].xyz;\n+    float dist = length(pos);\n+    if (dist > light.range) {\n+        return;\n+    }\n+    vec3 l = normalize(pos);\n+\n+    vec3 lightDir = lightTangentSpaceDirections[i].xyz;\n+    float spotlightFactor = computeSpotlightFactor2(l, lightDir, light.cosOuter, light.denom, light.falloff);\n+\n+    float invAttnFactor = light.attn.x + light.attn.y * dist + light.attn.z * dist * dist;\n+\n+    vec3 attenuatedColor = light.color.rgb * spotlightFactor \/ invAttnFactor;\n+    d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;\n+    s += pow(clamp(dot(-refl, l), 0.0, 1.0), specPower) * attenuatedColor;\n+}\n@@ -86,26 +147,3 @@\n-    float maxRange = lights[0].range;\n-    float dist = length(lightTangentSpacePositions[0].xyz);\n-    if (dist <= maxRange) {\n-        vec3 l = normalize(lightTangentSpacePositions[0].xyz);\n-        vec3 attenuatedColor = (lights[0].color).rgb \/ (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);\n-        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;\n-        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n-    }\n-\n-    maxRange = lights[1].range;\n-    dist = length(lightTangentSpacePositions[1].xyz);\n-    if (dist <= maxRange) {\n-        vec3 l = normalize(lightTangentSpacePositions[1].xyz);\n-        vec3 attenuatedColor = (lights[1].color).rgb \/ (lights[1].attn.x + lights[1].attn.y * dist + lights[1].attn.z * dist * dist);\n-        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;\n-        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n-    }\n-\n-    maxRange = lights[2].range;\n-    dist = length(lightTangentSpacePositions[2].xyz);\n-    if (dist <= maxRange) {\n-        vec3 l = normalize(lightTangentSpacePositions[2].xyz);\n-        vec3 attenuatedColor = (lights[2].color).rgb \/ (lights[2].attn.x + lights[2].attn.y * dist + lights[2].attn.z * dist * dist);\n-        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;\n-        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n-    }\n+    computeLight(0, n, refl, power, d, s);\n+    computeLight(1, n, refl, power, d, s);\n+    computeLight(2, n, refl, power, d, s);\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main3Lights.frag","additions":64,"deletions":26,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import javafx.beans.binding.Bindings;\n@@ -29,0 +30,1 @@\n+import javafx.geometry.Point3D;\n@@ -30,0 +32,1 @@\n+import javafx.scene.SpotLight;\n@@ -35,0 +38,1 @@\n+import javafx.scene.transform.Rotate;\n@@ -43,1 +47,1 @@\n-    protected VBox addLightControls(PointLight light) {\n+    protected VBox addPointLightControls(PointLight light) {\n@@ -45,1 +49,1 @@\n-        var range = createSliderControl(\"range\", light.maxRangeProperty(), 0, 100, light.getMaxRange());\n+        var range = createSliderControl(\"range\", light.maxRangeProperty(), 0, 500, 150);\n@@ -47,2 +51,2 @@\n-        var lc = createSliderControl(\"linear\", light.linearAttenuationProperty(), -1, 1, light.getLinearAttenuation());\n-        var qc = createSliderControl(\"quadratic\", light.quadraticAttenuationProperty(), -1, 1, light.getQuadraticAttenuation());\n+        var lc = createSliderControl(\"linear\", light.linearAttenuationProperty(), -0.1, 0.1, light.getLinearAttenuation());\n+        var qc = createSliderControl(\"quadratic\", light.quadraticAttenuationProperty(), -0.01, 0.01, light.getQuadraticAttenuation());\n@@ -53,0 +57,29 @@\n+    @Override\n+    protected VBox addSpotLightControls(SpotLight light) {\n+        var vbox = addPointLightControls(light);\n+        var ia = createSliderControl(\"inner\", light.innerAngleProperty(), 0, 180, light.getInnerAngle());\n+        var oa = createSliderControl(\"outer\", light.outerAngleProperty(), 0, 180, light.getOuterAngle());\n+        var fo = createSliderControl(\"falloff\", light.falloffProperty(), -5, 5, light.getFalloff());\n+\n+        var transX = new Rotate(0, Rotate.X_AXIS);\n+        var transY = new Rotate(0, Rotate.Y_AXIS);\n+        var transZ = new Rotate(0, Rotate.Z_AXIS);\n+        light.getTransforms().addAll(transX, transY, transZ);\n+        var rotX = createSliderControl(\"rot x\", transX.angleProperty(), -180, 180, 0);\n+        var rotY = createSliderControl(\"rot y\", transY.angleProperty(), -180, 180, 0);\n+        var rotZ = createSliderControl(\"rot z\", transZ.angleProperty(), -180, 180, 0);\n+\n+        var sliderX = createSlider(-5, 5, light.getDirection().getX());\n+        var sliderY = createSlider(-5, 5, light.getDirection().getY());\n+        var sliderZ = createSlider(-5, 5, light.getDirection().getZ());\n+        light.directionProperty().bind(Bindings.createObjectBinding(() ->\n+            new Point3D(sliderX.getValue(), sliderY.getValue(), sliderZ.getValue()),\n+            sliderX.valueProperty(), sliderY.valueProperty(), sliderZ.valueProperty()));\n+        var dirX = createSliderControl(\"dir x\", sliderX);\n+        var dirY = createSliderControl(\"dir y\", sliderY);\n+        var dirZ = createSliderControl(\"dir z\", sliderZ);\n+\n+        vbox.getChildren().addAll(ia, oa, fo, rotX, rotY, rotZ, dirX, dirY, dirZ);\n+        return vbox;\n+    }\n+\n@@ -54,4 +87,11 @@\n-        var slider = new Slider(min, max, start);\n-        slider.setShowTickMarks(true);\n-        slider.setShowTickLabels(true);\n-        property.bindBidirectional(slider.valueProperty());\n+        var slider = createSlider(min, max, start);\n+        property.bind(slider.valueProperty());\n+        return createSliderControl(name, slider);\n+    }\n+\n+    private HBox createSliderControl(String name, Slider slider) {\n+        var tf = createTextField(slider);\n+        return new HBox(5, new Label(name), slider, tf);\n+    }\n+\n+    private TextField createTextField(Slider slider) {\n@@ -61,1 +101,8 @@\n-        return new HBox(5, new Label(name), slider, tf);\n+        return tf;\n+    }\n+\n+    private Slider createSlider(double min, double max, double start) {\n+        var slider = new Slider(min, max, start);\n+        slider.setShowTickMarks(true);\n+        slider.setShowTickLabels(true);\n+        return slider;\n","filename":"tests\/performance\/3DLighting\/attenuation\/AttenLightingSample.java","additions":56,"deletions":9,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    public DoubleProperty yPan = new SimpleDoubleProperty(-10);\n+    public DoubleProperty yPan = new SimpleDoubleProperty();\n@@ -54,0 +54,1 @@\n+    public DoubleProperty isoRotationSensitivity = new SimpleDoubleProperty(1);\n@@ -147,0 +148,2 @@\n+            } else if (e.getButton() == MouseButton.MIDDLE) {\n+                swivle(deltaY);\n@@ -173,0 +176,4 @@\n+\n+    private void swivle(double amount) {\n+        isometricAngle.set(isometricAngle.get() - amount * isoRotationSensitivity.get());\n+    }\n","filename":"tests\/performance\/3DLighting\/attenuation\/CameraScene3D.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+import javafx.scene.Group;\n+import javafx.scene.LightBase;\n+import javafx.scene.Node;\n@@ -33,0 +36,1 @@\n+import javafx.scene.SpotLight;\n@@ -35,0 +39,1 @@\n+import javafx.scene.shape.Box;\n@@ -36,1 +41,0 @@\n-import javafx.scene.shape.Shape3D;\n@@ -39,0 +43,1 @@\n+import javafx.scene.transform.Rotate;\n@@ -42,4 +47,2 @@\n-    private final PointLight light1 = new PointLight(Color.RED);\n-    private final PointLight light2 = new PointLight(Color.BLUE);\n-    private final PointLight light3 = new PointLight(Color.MAGENTA);\n-    final PointLight[] lights = {light1, light2, light3};\n+    private final static double LIGHT_Z_DIST = 50;\n+    private final static double LIGHT_X_DIST = 50;\n@@ -47,1 +50,9 @@\n-    private Shape3D currentShape;\n+    private final PointLight pointLight1 = new PointLight(Color.RED);\n+    private final PointLight pointLight2 = new PointLight(Color.BLUE);\n+    private final PointLight pointLight3 = new PointLight(Color.MAGENTA);\n+    private final SpotLight spotLight1 = new SpotLight(Color.RED);\n+    private final SpotLight spotLight2 = new SpotLight(Color.BLUE);\n+    private final SpotLight spotLight3 = new SpotLight(Color.MAGENTA);\n+    final LightBase[] lights = {pointLight1, pointLight2, pointLight3, spotLight1, spotLight2, spotLight3};\n+\n+    private Node currentShape;\n@@ -56,1 +67,1 @@\n-            light.setTranslateZ(-50);\n+            light.setTranslateZ(-LIGHT_Z_DIST);\n@@ -62,1 +73,1 @@\n-            rootGroup.getChildren().addAll(light, lightRep);\n+            rootGroup.getChildren().addAll(light , lightRep);\n@@ -64,5 +75,12 @@\n-        light1.setTranslateX(40);\n-        light2.setTranslateX(-40);\n-        light1.setUserData(\"RED\");\n-        light2.setUserData(\"BLUE\");\n-        light3.setUserData(\"MAGENTA\");\n+\n+        pointLight1.setTranslateX(LIGHT_X_DIST);\n+        spotLight1.setTranslateX(LIGHT_X_DIST);\n+        pointLight2.setTranslateX(-LIGHT_X_DIST);\n+        spotLight2.setTranslateX(-LIGHT_X_DIST);\n+\n+        pointLight1.setUserData(\"RED\");\n+        pointLight2.setUserData(\"BLUE\");\n+        pointLight3.setUserData(\"MAGENTA\");\n+        spotLight1.setUserData(\"RED\");\n+        spotLight2.setUserData(\"BLUE\");\n+        spotLight3.setUserData(\"MAGENTA\");\n@@ -74,0 +92,13 @@\n+    Group createBoxes() {\n+        var front = new Box(200, 200, 1);\n+        var back = new Box(200, 200, 1);\n+        var side = new Box(200, 200, 1);\n+        side.setRotationAxis(Rotate.Y_AXIS);\n+        side.setRotate(90);\n+        side.setTranslateX(LIGHT_Z_DIST * 2);\n+        side.setTranslateZ(-LIGHT_Z_DIST);\n+        front.setTranslateZ(LIGHT_Z_DIST);\n+        back.setTranslateZ(-LIGHT_Z_DIST * 3);\n+        return new Group(front, back, side);\n+    }\n+\n@@ -115,1 +146,1 @@\n-    void switchTo(Shape3D node) {\n+    void switchTo(Node node) {\n","filename":"tests\/performance\/3DLighting\/attenuation\/Environment.java","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-        double elapsedSeconds = (double) elapsedTime \/ 1e9;\n-        double totalElapsedSeconds = (double) totalElapsedTime \/ 1e9;\n+        double elapsedSeconds = elapsedTime \/ 1e9;\n+        double totalElapsedSeconds = totalElapsedTime \/ 1e9;\n","filename":"tests\/performance\/3DLighting\/attenuation\/FPSCounter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+import javafx.beans.binding.When;\n+import javafx.scene.Group;\n+import javafx.scene.LightBase;\n+import javafx.scene.Node;\n@@ -33,0 +37,1 @@\n+import javafx.scene.SpotLight;\n@@ -36,1 +41,1 @@\n-import javafx.scene.control.Separator;\n+import javafx.scene.control.ScrollPane;\n@@ -38,0 +43,1 @@\n+import javafx.scene.control.TitledPane;\n@@ -41,1 +47,3 @@\n-import javafx.scene.shape.Shape3D;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.PhongMaterial;\n+import javafx.scene.shape.Box;\n@@ -62,3 +70,3 @@\n-        var subdivisionSlider = new Slider(10, 200, 60);\n-        subdivisionSlider.setMajorTickUnit(10);\n-        setupSlier(subdivisionSlider);\n+        var sphereControls = createSphereControls();\n+        var meshControls = createMeshControls();\n+        var boxesControls = createBoxesControls();\n@@ -66,2 +74,2 @@\n-        var subdivisionLabel = new Label();\n-        subdivisionLabel.textProperty().bindBidirectional(subdivisionSlider.valueProperty(), new NumberStringConverter(\"#\"));\n+        var playButton = new Button(\"Start\");\n+        playButton.setOnAction(e -> startMeasurement());\n@@ -69,2 +77,13 @@\n-        var sphere = new Button(\"Sphere\");\n-        sphere.setOnAction(e -> switchTo(environment.createSphere((int) subdivisionSlider.getValue())));\n+        var stopButton = new Button(\"Stop\");\n+        stopButton.setOnAction(e -> stopMeasurement());\n+\n+        var controls = new VBox(3, sphereControls, meshControls, boxesControls, new HBox(5, playButton, stopButton));\n+        for (var light : environment.lights) {\n+            VBox vBox = null;\n+            if (light instanceof SpotLight) {\n+                vBox = addSpotLightControls((SpotLight) light);\n+            } else if (light instanceof PointLight) {\n+                vBox = addPointLightControls((PointLight) light);\n+            }\n+            controls.getChildren().add(new TitledPane(light.getUserData() + \" \" + light.getClass().getSimpleName(), vBox));\n+        }\n@@ -72,2 +91,11 @@\n-        var quadSlider = new Slider(500, 10_000, 1000);\n-        quadSlider.setMajorTickUnit(500);\n+        var hBox = new HBox(new ScrollPane(controls), environment);\n+        HBox.setHgrow(environment, Priority.ALWAYS);\n+        stage.setScene(new Scene(hBox));\n+        stage.setWidth(1100);\n+        stage.setHeight(735);\n+        stage.show();\n+    }\n+\n+    private HBox createMeshControls() {\n+        var quadSlider = new Slider(100, 5000, 1000);\n+        quadSlider.setMajorTickUnit(100);\n@@ -82,1 +110,0 @@\n-        var sphereBox = new HBox(sphere, subdivisionSlider, subdivisionLabel);\n@@ -84,0 +111,2 @@\n+        return meshBox;\n+    }\n@@ -85,4 +114,4 @@\n-        var controls = new VBox(sphereBox, meshBox);\n-        for (var light : environment.lights) {\n-            controls.getChildren().add(addLightControls(light));\n-        }\n+    private HBox createSphereControls() {\n+        var subdivisionSlider = new Slider(10, 1000, 60);\n+        subdivisionSlider.setMajorTickUnit(50);\n+        setupSlier(subdivisionSlider);\n@@ -90,6 +119,22 @@\n-        var hBox = new HBox(controls, environment);\n-        HBox.setHgrow(environment, Priority.ALWAYS);\n-        stage.setScene(new Scene(hBox));\n-        stage.setWidth(1100);\n-        stage.setHeight(735);\n-        stage.show();\n+        var subdivisionLabel = new Label();\n+        subdivisionLabel.textProperty().bindBidirectional(subdivisionSlider.valueProperty(), new NumberStringConverter(\"#\"));\n+\n+        var sphere = new Button(\"Sphere\");\n+        sphere.setOnAction(e -> switchTo(environment.createSphere((int) subdivisionSlider.getValue())));\n+\n+        var sphereBox = new HBox(sphere, subdivisionSlider, subdivisionLabel);\n+        return sphereBox;\n+    }\n+\n+    private HBox createBoxesControls() {\n+        var box = new Button(\"Boxes (static)\");\n+        var specular = new CheckBox(\"Specular\");\n+        var specularBinding = new When(specular.selectedProperty()).then(Color.WHITE).otherwise(Color.BLACK);\n+        var mat = new PhongMaterial(Color.WHITE);\n+        mat.specularColorProperty().bind(specularBinding);\n+        box.setOnAction(e -> {\n+            Group boxes = environment.createBoxes();\n+            boxes.getChildren().forEach(n -> ((Box) n).setMaterial(mat));\n+            switchTo(boxes);\n+        });\n+        return new HBox(5, box, specular);\n@@ -105,1 +150,9 @@\n-    protected VBox addLightControls(PointLight light) {\n+    protected VBox addPointLightControls(PointLight light) {\n+        return addLightControls(light);\n+    }\n+\n+    protected VBox addSpotLightControls(SpotLight light) {\n+        return addLightControls(light);\n+    }\n+\n+    protected VBox addLightControls(LightBase light) {\n@@ -107,1 +160,0 @@\n-        lightOn.setSelected(true);\n@@ -109,1 +161,1 @@\n-        return new VBox(new Separator(), new Label(light.getUserData() + \" light\"), lightOn);\n+        return new VBox(lightOn);\n@@ -121,3 +173,2 @@\n-    private void switchTo(Shape3D node) {\n-        fpsCouner.stop();\n-        fpsCouner.reset();\n+    private void switchTo(Node node) {\n+        stopMeasurement();\n@@ -126,0 +177,3 @@\n+    }\n+\n+    private void startMeasurement() {\n@@ -130,0 +184,6 @@\n+    private void stopMeasurement() {\n+        fpsCouner.stop();\n+        fpsCouner.reset();\n+        animation.stop();\n+    }\n+\n","filename":"tests\/performance\/3DLighting\/attenuation\/LightingSample.java","additions":88,"deletions":28,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.lighting3D;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.junit.AfterClass;\n+\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.scene.Group;\n+import javafx.scene.LightBase;\n+import javafx.scene.Scene;\n+import javafx.scene.image.WritableImage;\n+import javafx.scene.shape.Box;\n+import javafx.stage.Stage;\n+import javafx.stage.WindowEvent;\n+\n+\/\/ Since there appears to be a bug in snapshot with subscene, we are taking a snapshot of the scene and not\n+\/\/ the box, so the center of the box will be at the top left, (0, 0), of the image, and the light is\n+\/\/ straight in front. Without attenuation, at (0, 0) it will give its full color.\n+\/\/\n+\/\/       x\n+\/\/  -----------\n+\/\/  |         \/\n+\/\/  |        \/     d - the distance of the light from the object\n+\/\/  |       \/      x - the horizontal distance of the sample point on the object\n+\/\/  |      \/       a - the angle to the sample point\n+\/\/ d|     \/\n+\/\/  |    \/         tan(a) = x\/d\n+\/\/  |   \/          cos(a) = cos(atan(x\/d)) = 1 \/ sqrt((x\/d)^2 + 1)\n+\/\/  |a \/\n+\/\/  | \/\n+\/\/  |\/\n+\/\/\n+public class LightingTest {\n+\n+    \/\/ 1d\/255 is the smallest color resolution, but we use 10d\/255 to avoid precision problems\n+    protected static final double DELTA = 10d\/255;\n+    protected static final String FAIL_MESSAGE = \"Wrong color value\";\n+\n+    protected static final int LIGTH_DIST = 60;\n+\n+    protected static LightBase light;\n+\n+    private static final Box BOX = new Box(150, 150, 1);\n+\n+    protected static CountDownLatch startupLatch;\n+    private static Stage stage;\n+\n+    public static class TestApp extends Application {\n+\n+        @Override\n+        public void start(Stage mainStage) {\n+            stage = mainStage;\n+            light.setTranslateZ(-LIGTH_DIST);\n+            stage.setScene(new Scene(new Group(light, BOX)));\n+            stage.addEventHandler(WindowEvent.WINDOW_SHOWN, e -> Platform.runLater(startupLatch::countDown));\n+            stage.show();\n+        }\n+    }\n+\n+    protected WritableImage snapshot() {\n+        return BOX.getScene().snapshot(null);\n+    }\n+\n+    protected double calculateLambertTerm(double x) {\n+        return Math.cos(Math.atan(x\/LIGTH_DIST));\n+    }\n+\n+    @AfterClass\n+    public static void teardown() {\n+        Platform.runLater(() -> {\n+            stage.hide();\n+            Platform.exit();\n+        });\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/lighting3D\/LightingTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import static org.junit.Assert.assertEquals;\n@@ -30,1 +31,0 @@\n-import static org.junit.Assert.assertEquals;\n@@ -35,1 +35,0 @@\n-import org.junit.AfterClass;\n@@ -43,1 +42,0 @@\n-import javafx.scene.Group;\n@@ -45,1 +43,0 @@\n-import javafx.scene.Scene;\n@@ -47,3 +44,0 @@\n-import javafx.scene.shape.Box;\n-import javafx.stage.Stage;\n-import javafx.stage.WindowEvent;\n@@ -52,1 +46,4 @@\n-public class PointLightAttenuationTest {\n+public class PointLightAttenuationTest extends LightingTest {\n+\n+    \/\/ X coordinates for the point used in Lambert tests\n+    private static final int[] LAMBERT_SAMPLE_DISTS = new int[] {0, 30, 60};\n@@ -54,4 +51,2 @@\n-    \/\/ 1d\/255 is the smallest color resolution, but we use 10d\/255 to avoid precision problems\n-    private static final double DELTA = 10d\/255;\n-    private static final int LIGTH_DIST = 60;\n-    private static final int SAMPLE_DIST = 60;\n+    \/\/ X coordinate for the point used in attenuation tests\n+    private static final int ATTN_SAMPLE_DIST = LIGTH_DIST;\n@@ -59,4 +54,1 @@\n-    private static CountDownLatch startupLatch;\n-    private static Stage stage;\n-    private static PointLight light = new PointLight(Color.BLUE);\n-    private static Box box = new Box(150, 150, 1);\n+    private static final PointLight LIGHT = new PointLight(Color.BLUE);\n@@ -71,2 +63,3 @@\n-        new Thread(() -> Application.launch(TestApp.class, (String[])null)).start();\n-        assertTrue(\"Timeout waiting for FX runtime to start\", startupLatch.await(15, TimeUnit.SECONDS));\n+        LightingTest.light = LIGHT;\n+        new Thread(() -> Application.launch(TestApp.class, (String[]) null)).start();\n+        assertTrue(\"Timeout waiting for FX runtime to start\", startupLatch.await(5, TimeUnit.SECONDS));\n@@ -78,0 +71,3 @@\n+        LIGHT.setLinearAttenuation(0);\n+        LIGHT.setQuadraticAttenuation(0);\n+        LIGHT.setMaxRange(Double.POSITIVE_INFINITY);\n@@ -80,12 +76,10 @@\n-    public static class TestApp extends Application {\n-\n-        @Override\n-        public void start(Stage mainStage) {\n-            stage = mainStage;\n-            light.setTranslateZ(-LIGTH_DIST);\n-            var root = new Group(light, box);\n-            var scene = new Scene(root);\n-            stage.setScene(scene);\n-            stage.addEventHandler(WindowEvent.WINDOW_SHOWN, e -> Platform.runLater(startupLatch::countDown));\n-            stage.show();\n-        }\n+    \/\/ The Lambert term is dot(N,L) = cos(a)\n+    @Test\n+    public void testLambert() {\n+        Util.runAndWait(() -> {\n+            var snapshot = snapshot();\n+            for (int x : LAMBERT_SAMPLE_DISTS) {\n+                double sampledBlue = snapshot.getPixelReader().getColor(x, 0).getBlue();\n+                assertEquals(FAIL_MESSAGE + \" for \" + x, calculateLambertTerm(x), sampledBlue, DELTA);\n+            }\n+        });\n@@ -97,38 +91,27 @@\n-            \/\/ Since there appears to be a bug in snapshot with subscene, we are taking a snapshot of the scene and not\n-            \/\/ the box, so the center of the box will be at the top left, (0, 0), of the image, and the light is\n-            \/\/ straight in front. Without attenuation, at (0, 0) it will give its full color. At (SAMPLE_DIST, 0) and\n-            \/\/ LIGTH_DIST == SAMPLE_DIST, it will give cos(45) = 1\/sqrt(2) of its color.\n-            var snapshot = box.getScene().snapshot(null);\n-            double nonAttenBlueCenter = snapshot.getPixelReader().getColor(0, 0).getBlue();\n-            double nonAttenBlueDiag = snapshot.getPixelReader().getColor(SAMPLE_DIST, 0).getBlue();\n-            assertEquals(\"Wrong color value\", 1, nonAttenBlueCenter, DELTA);\n-            assertEquals(\"Wrong color value\", 1\/Math.sqrt(2), nonAttenBlueDiag, DELTA);\n-\n-            double diagDist = Math.sqrt(LIGTH_DIST * LIGTH_DIST + SAMPLE_DIST * SAMPLE_DIST);\n-\n-            light.setLinearAttenuation(0.01);\n-            double attnCenter = 1 \/ (1 + 0.01 * LIGTH_DIST);\n-            double attnDiag = 1 \/ (1 + 0.01 * diagDist);\n-            snapshot = box.getScene().snapshot(null);\n-            double attenBlueCenter = snapshot.getPixelReader().getColor(0, 0).getBlue();\n-            double attenBlueDiag = snapshot.getPixelReader().getColor(SAMPLE_DIST, 0).getBlue();\n-            assertEquals(\"Wrong color value\", nonAttenBlueCenter * attnCenter, attenBlueCenter, DELTA);\n-            assertEquals(\"Wrong color value\", nonAttenBlueDiag * attnDiag, attenBlueDiag, DELTA);\n-\n-            light.setLinearAttenuation(0);\n-            light.setQuadraticAttenuation(0.01);\n-            attnCenter = 1 \/ (1 + 0.01 * LIGTH_DIST * LIGTH_DIST);\n-            attnDiag = 1 \/ (1 + 0.01 * diagDist * diagDist);\n-            snapshot = box.getScene().snapshot(null);\n-            attenBlueCenter = snapshot.getPixelReader().getColor(0, 0).getBlue();\n-            attenBlueDiag = snapshot.getPixelReader().getColor(SAMPLE_DIST, 0).getBlue();\n-            assertEquals(\"Wrong color value\", nonAttenBlueCenter * attnCenter, attenBlueCenter, DELTA);\n-            assertEquals(\"Wrong color value\", nonAttenBlueDiag * attnDiag, attenBlueDiag, DELTA);\n-\n-            light.setQuadraticAttenuation(0);\n-            light.setMaxRange((LIGTH_DIST + diagDist) \/ 2);\n-            snapshot = box.getScene().snapshot(null);\n-            nonAttenBlueCenter = snapshot.getPixelReader().getColor(0, 0).getBlue();\n-            nonAttenBlueDiag = snapshot.getPixelReader().getColor(SAMPLE_DIST, 0).getBlue();\n-            assertEquals(\"Wrong color value, should be in range\", 1, nonAttenBlueCenter, DELTA);\n-            assertEquals(\"Wrong color value, should be out of range\", 0, nonAttenBlueDiag, DELTA);\n+            double diagDist = Math.sqrt(LIGTH_DIST * LIGTH_DIST + ATTN_SAMPLE_DIST * ATTN_SAMPLE_DIST);\n+            double lambertCenter = calculateLambertTerm(0);\n+            double lambertSample = calculateLambertTerm(ATTN_SAMPLE_DIST);\n+\n+            LIGHT.setLinearAttenuation(0.01);\n+            var snapshot = snapshot();\n+\n+            double attn = calculateAttenuationFactor(LIGTH_DIST);\n+            double sampledBlue = snapshot.getPixelReader().getColor(0, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, lambertCenter * attn, sampledBlue, DELTA);\n+\n+            attn = calculateAttenuationFactor(diagDist);\n+            sampledBlue = snapshot.getPixelReader().getColor(ATTN_SAMPLE_DIST, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, lambertSample * attn, sampledBlue, DELTA);\n+\n+\n+            LIGHT.setLinearAttenuation(0);\n+            LIGHT.setQuadraticAttenuation(0.01);\n+            snapshot = snapshot();\n+\n+            attn = calculateAttenuationFactor(LIGTH_DIST);\n+            sampledBlue = snapshot.getPixelReader().getColor(0, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, lambertCenter * attn, sampledBlue, DELTA);\n+\n+            attn = calculateAttenuationFactor(diagDist);\n+            sampledBlue = snapshot.getPixelReader().getColor(ATTN_SAMPLE_DIST, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, lambertSample * attn, sampledBlue, DELTA);\n@@ -138,5 +121,12 @@\n-    @AfterClass\n-    public static void teardown() {\n-        Platform.runLater(() -> {\n-            stage.hide();\n-            Platform.exit();\n+    @Test\n+    public void testRange() {\n+        Util.runAndWait(() -> {\n+            double diagDist = Math.sqrt(LIGTH_DIST * LIGTH_DIST + ATTN_SAMPLE_DIST * ATTN_SAMPLE_DIST);\n+            LIGHT.setMaxRange((LIGTH_DIST + diagDist) \/ 2);\n+            var snapshot = snapshot();\n+\n+            double sampledBlue = snapshot.getPixelReader().getColor(0, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE + \", should be in range\", 1, sampledBlue, DELTA);\n+\n+            sampledBlue = snapshot.getPixelReader().getColor(ATTN_SAMPLE_DIST, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE + \", should be out of range\", 0, sampledBlue, DELTA);\n@@ -145,0 +135,5 @@\n+\n+    private double calculateAttenuationFactor(double dist) {\n+        return 1 \/ (LIGHT.getConstantAttenuation() + LIGHT.getLinearAttenuation() * dist\n+                      + LIGHT.getQuadraticAttenuation() * dist * dist);\n+    }\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/lighting3D\/PointLightAttenuationTest.java","additions":69,"deletions":74,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.lighting3D;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assume.assumeTrue;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import javafx.application.Application;\n+import javafx.application.ConditionalFeature;\n+import javafx.application.Platform;\n+import javafx.scene.SpotLight;\n+import javafx.scene.paint.Color;\n+import test.util.Util;\n+\n+public class SpotLightAttenuationTest extends LightingTest {\n+\n+    \/\/ Angles for points used in spotlight factor tests\n+    private static final double INNER_ANGLE = 20;\n+    private static final double OUTER_ANGLE = 40;\n+    private static final int INSIDE_ANGLE_SAMPLE = 18;\n+    private static final int MIDDLE_ANGLE_SAMPLE = 30;\n+    private static final int OUTSIDE_ANGLE_SAMPLE = 42;\n+\n+    private static final double[] FALLOFF_FACTORS = new double[] {0.5, 1, 1};\n+\n+    private static final SpotLight LIGHT = new SpotLight(Color.BLUE);\n+\n+    public static void main(String[] args) throws Exception {\n+        initFX();\n+    }\n+\n+    @BeforeClass\n+    public static void initFX() throws Exception {\n+        startupLatch = new CountDownLatch(1);\n+        LightingTest.light = LIGHT;\n+        new Thread(() -> Application.launch(TestApp.class, (String[]) null)).start();\n+        assertTrue(\"Timeout waiting for FX runtime to start\", startupLatch.await(5, TimeUnit.SECONDS));\n+    }\n+\n+    @Before\n+    public void setupEach() {\n+        assumeTrue(Platform.isSupported(ConditionalFeature.SCENE3D));\n+    }\n+\n+    @Test\n+    public void testSpotlightAttenuation() {\n+        Util.runAndWait(() -> {\n+            LIGHT.setInnerAngle(INNER_ANGLE);\n+            LIGHT.setOuterAngle(OUTER_ANGLE);\n+            for (double falloff : FALLOFF_FACTORS) {\n+                LIGHT.setFalloff(falloff);\n+                var snapshot = snapshot();\n+\n+                int innerX = angleToDist(INSIDE_ANGLE_SAMPLE);\n+                double spotFactor = 1;\n+                double sampledBlue = snapshot.getPixelReader().getColor(innerX, 0).getBlue();\n+                assertEquals(FAIL_MESSAGE, calculateLambertTerm(innerX) * spotFactor, sampledBlue, DELTA);\n+\n+                int middleX = angleToDist(MIDDLE_ANGLE_SAMPLE);\n+                spotFactor = calculateSpotlightFactor(MIDDLE_ANGLE_SAMPLE);\n+                sampledBlue = snapshot.getPixelReader().getColor(middleX, 0).getBlue();\n+                assertEquals(FAIL_MESSAGE, calculateLambertTerm(middleX) * spotFactor, sampledBlue, DELTA);\n+\n+                int outerX = angleToDist(OUTSIDE_ANGLE_SAMPLE);\n+                spotFactor = 0;\n+                sampledBlue = snapshot.getPixelReader().getColor(outerX, 0).getBlue();\n+                assertEquals(FAIL_MESSAGE, calculateLambertTerm(outerX) * spotFactor, sampledBlue, DELTA);\n+            }\n+        });\n+    }\n+\n+    \/\/ I = pow((cosAngle - cosOuter) \/ (cosInner - cosOuter), falloff)\n+    private double calculateSpotlightFactor(double degrees) {\n+        double numerator = degCos(degrees) - degCos(LIGHT.getOuterAngle());\n+        double denom = degCos(LIGHT.getInnerAngle()) - degCos(LIGHT.getOuterAngle());\n+        return Math.pow(numerator \/ denom, LIGHT.getFalloff());\n+    }\n+\n+    private double degCos(double degrees) {\n+        return Math.cos(Math.toRadians(degrees));\n+    }\n+\n+    private int angleToDist(double degrees) {\n+        return (int) (LIGTH_DIST * Math.tan(Math.toRadians(degrees)));\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/lighting3D\/SpotLightAttenuationTest.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"}]}