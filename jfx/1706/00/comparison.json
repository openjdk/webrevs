{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.lang.ref.WeakReference;\n@@ -50,1 +49,0 @@\n-import com.sun.javafx.scene.control.IDisconnectable;\n@@ -72,2 +70,0 @@\n-\n-    private WeakReference<TreeItem<T>> weakRootRef;\n@@ -75,1 +71,1 @@\n-    private IDisconnectable rootListener;\n+    private final EventHandler<TreeItem.TreeModificationEvent<T>> rootListener;\n@@ -101,2 +97,0 @@\n-        setRoot(getSkinnable().getRoot());\n-\n@@ -134,1 +128,37 @@\n-        lh.addChangeListener(control.rootProperty(), (ev) -> {\n+        rootListener = (ch) -> {\n+            if (ch.wasAdded() && ch.wasRemoved() && ch.getAddedSize() == ch.getRemovedSize()) {\n+                \/\/ Fix for JDK-8114432, where the children of a TreeItem were changing,\n+                \/\/ but because the overall item count was staying the same, there was\n+                \/\/ no event being fired to the skin to be informed that the items\n+                \/\/ had changed. So, here we just watch for the case where the number\n+                \/\/ of items being added is equal to the number of items being removed.\n+                markItemCountDirty();\n+                control.requestLayout();\n+            } else if (ch.getEventType().equals(TreeItem.valueChangedEvent())) {\n+                \/\/ Fix for JDK-8114657 and JDK-8114610.\n+                requestRebuildCells();\n+            } else {\n+                \/\/ Fix for JDK-8115929. We are checking to see if the event coming\n+                \/\/ from the TreeItem root is an event where the count has changed.\n+                EventType<?> eventType = ch.getEventType();\n+                while (eventType != null) {\n+                    if (eventType.equals(TreeItem.<T>expandedItemCountChangeEvent())) {\n+                        markItemCountDirty();\n+                        control.requestLayout();\n+                        break;\n+                    }\n+                    eventType = eventType.getSuperType();\n+                }\n+            }\n+\n+            \/\/ fix for JDK-8094887\n+            control.edit(-1, null);\n+        };\n+\n+        lh.addChangeListener(control.rootProperty(), true, (src, prev, root) -> {\n+            if (prev != null) {\n+                prev.removeEventHandler(TreeItem.<T>treeNotificationEvent(), rootListener);\n+            }\n+            if (root != null) {\n+                root.addEventHandler(TreeItem.<T>treeNotificationEvent(), rootListener);\n+            }\n@@ -136,2 +166,2 @@\n-            getSkinnable().edit(-1, null);\n-            setRoot(getSkinnable().getRoot());\n+            control.edit(-1, null);\n+            updateItemCount();\n@@ -144,2 +174,5 @@\n-            if (! getSkinnable().isShowRoot() && getRoot() != null) {\n-                getRoot().setExpanded(true);\n+            if (!control.isShowRoot()) {\n+                TreeItem<T> root = control.getRoot();\n+                if (root != null) {\n+                    root.setExpanded(true);\n+                }\n@@ -158,0 +191,2 @@\n+\n+        updateItemCount();\n@@ -172,5 +207,0 @@\n-        if (rootListener != null) {\n-            rootListener.disconnect();\n-            rootListener = null;\n-        }\n-\n@@ -282,46 +312,0 @@\n-    private TreeItem<T> getRoot() {\n-        return weakRootRef == null ? null : weakRootRef.get();\n-    }\n-    private void setRoot(TreeItem<T> newRoot) {\n-        if (rootListener != null) {\n-            rootListener.disconnect();\n-            rootListener = null;\n-        }\n-        weakRootRef = new WeakReference<>(newRoot);\n-        if (getRoot() != null) {\n-            \/\/ TODO I wonder if it might be possible for the root ref to get collected between these two lines\n-            \/\/ which would throw an NPE.  Perhaps we should simply use newRoot instance instead of getRoot().\n-            rootListener = ListenerHelper.get(this).addEventHandler(getRoot(), TreeItem.<T>treeNotificationEvent(), e -> {\n-                if (e.wasAdded() && e.wasRemoved() && e.getAddedSize() == e.getRemovedSize()) {\n-                    \/\/ Fix for JDK-8114432, where the children of a TreeItem were changing,\n-                    \/\/ but because the overall item count was staying the same, there was\n-                    \/\/ no event being fired to the skin to be informed that the items\n-                    \/\/ had changed. So, here we just watch for the case where the number\n-                    \/\/ of items being added is equal to the number of items being removed.\n-                    markItemCountDirty();\n-                    getSkinnable().requestLayout();\n-                } else if (e.getEventType().equals(TreeItem.valueChangedEvent())) {\n-                    \/\/ Fix for JDK-8114657 and JDK-8114610.\n-                    requestRebuildCells();\n-                } else {\n-                    \/\/ Fix for JDK-8115929. We are checking to see if the event coming\n-                    \/\/ from the TreeItem root is an event where the count has changed.\n-                    EventType<?> eventType = e.getEventType();\n-                    while (eventType != null) {\n-                        if (eventType.equals(TreeItem.<T>expandedItemCountChangeEvent())) {\n-                            markItemCountDirty();\n-                            getSkinnable().requestLayout();\n-                            break;\n-                        }\n-                        eventType = eventType.getSuperType();\n-                    }\n-                }\n-\n-                \/\/ fix for JDK-8094887\n-                getSkinnable().edit(-1, null);\n-            });\n-        }\n-\n-        updateItemCount();\n-    }\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TreeTableViewSkin.java","additions":48,"deletions":64,"binary":false,"changes":112,"status":"modified"}]}