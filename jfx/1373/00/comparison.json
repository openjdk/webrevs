{"files":[{"patch":"@@ -74,2 +74,0 @@\n-    GdkKeymapKey *keys;\n-    gint n_keys;\n@@ -79,3 +77,2 @@\n-    gdk_keymap_get_entries_for_keyval(gdk_keymap_get_default(),\n-            gdk_keyval, &keys, &n_keys);\n-    if (n_keys < 1) {\n+    int keycode = find_gdk_keycode_for_keyval(gdk_keyval);\n+    if (keycode == -1) {\n@@ -84,1 +81,0 @@\n-\n@@ -86,1 +82,1 @@\n-                      keys[0].keycode,\n+                      keycode,\n@@ -89,1 +85,0 @@\n-    g_free(keys);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassRobot.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include <map>\n+\n@@ -35,0 +37,2 @@\n+\n+\/\/ Map from keyval to Java KeyCode\n@@ -37,0 +41,13 @@\n+\/\/ There may be more than one mapping from a keyvalue to a Java KeyCode in the\n+\/\/ keymap. That can produce unpredictable results when a Robot tries to work\n+\/\/ backward from KeyCode to keyvalue. This map is consulted first to resolve\n+\/\/ the ambiguity.\n+static std::map<jint, guint32> robot_java_to_keyval;\n+\n+\/\/ As the user types we build a map from character to Java KeyCode. We use\n+\/\/ this map in getKeyCodeForChar which ensures we only reference keys that\n+\/\/ are on the user's keyboard. GDK calls that query the GdkKeymap are slow\n+\/\/ (they scan all the maps each time) and can return keys not present on the\n+\/\/ keyboard.\n+static std::map<guint32, jint> char_to_java_code;\n+\n@@ -227,0 +244,21 @@\n+\n+    \/\/ Used by ISO keyboards\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(ISO_Level3_Shift), com_sun_glass_events_KeyEvent_VK_ALT_GRAPH);\n+\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_ENTER]   = GLASS_GDK_KEY_CONSTANT(Return);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_CLEAR]   = GLASS_GDK_KEY_CONSTANT(Clear);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_PAGE_UP] = GLASS_GDK_KEY_CONSTANT(Page_Up);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_END]     = GLASS_GDK_KEY_CONSTANT(End);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_HOME]    = GLASS_GDK_KEY_CONSTANT(Home);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_LEFT]    = GLASS_GDK_KEY_CONSTANT(Left);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_UP]      = GLASS_GDK_KEY_CONSTANT(Up);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_RIGHT]   = GLASS_GDK_KEY_CONSTANT(Right);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_DOWN]    = GLASS_GDK_KEY_CONSTANT(Down);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_DELETE]  = GLASS_GDK_KEY_CONSTANT(Delete);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_BACK_SLASH] = GLASS_GDK_KEY_CONSTANT(backslash);\n+    \/\/ This works on all keyboards, both ISO and ANSI.\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_ALT_GRAPH]  = GLASS_GDK_KEY_CONSTANT(ISO_Level3_Shift);\n+}\n+\n+static void keys_changed_signal(GdkKeymap* k, gpointer data) {\n+    char_to_java_code.clear();\n@@ -233,0 +271,9 @@\n+\n+        GdkKeymap* gdk_keymap = gdk_keymap_get_for_display(gdk_display_get_default());\n+\n+        \/\/ The documented signal emitted when the keyboard layout changes\n+        g_signal_connect(G_OBJECT(gdk_keymap), \"keys-changed\",\n+                         G_CALLBACK(keys_changed_signal), nullptr);\n+        \/\/ On some versions of X11 this is the actual signal emitted\n+        g_signal_connect(G_OBJECT(gdk_keymap), \"keys_changed\",\n+                         G_CALLBACK(keys_changed_signal), nullptr);\n@@ -242,0 +289,15 @@\n+\/\/ For a given keypress event we update the char => KeyCode map multiple times\n+\/\/ each with a different shift level encoded in the state argument.\n+static void record_character(GdkKeymap *keymap, GdkEventKey *e, guint state, jint javaKeyCode) {\n+    guint keyValue;\n+\n+    if (gdk_keymap_translate_keyboard_state(keymap, e->hardware_keycode,\n+                                            static_cast<GdkModifierType>(state), e->group,\n+                                            &keyValue, NULL, NULL, NULL)) {\n+        guint32 ucs = gdk_keyval_to_unicode(keyValue);\n+        if (ucs) {\n+            char_to_java_code[ucs] = javaKeyCode;\n+        }\n+    };\n+}\n+\n@@ -247,0 +309,1 @@\n+    GdkKeymap* gdk_keymap = gdk_keymap_get_for_display(gdk_display_get_default());\n@@ -248,1 +311,1 @@\n-    gdk_keymap_translate_keyboard_state(gdk_keymap_get_default(),\n+    gdk_keymap_translate_keyboard_state(gdk_keymap,\n@@ -263,1 +326,1 @@\n-        keyValue = gdk_keymap_lookup_key(gdk_keymap_get_default(), &kk);\n+        keyValue = gdk_keymap_lookup_key(gdk_keymap, &kk);\n@@ -269,0 +332,11 @@\n+    \/\/ If this mapped to a Java code record which characters are\n+    \/\/ generated at different shift levels.\n+    if (key) {\n+        \/\/ Unshifted and Shift\n+        record_character(gdk_keymap, e, state, key);\n+        record_character(gdk_keymap, e, (state | GDK_SHIFT_MASK), key);\n+        \/\/ AltGr and Shift+AltGr\n+        record_character(gdk_keymap, e, (state | GDK_MOD5_MASK), key);\n+        record_character(gdk_keymap, e, (state | GDK_MOD5_MASK | GDK_SHIFT_MASK), key);\n+    }\n+\n@@ -274,0 +348,6 @@\n+\n+    auto i = robot_java_to_keyval.find(code);\n+    if (i != robot_java_to_keyval.end()) {\n+        return i->second;\n+    }\n+\n@@ -287,0 +367,97 @@\n+static bool keyval_requires_numlock(gint keyval) {\n+    switch (keyval) {\n+        case GDK_KEY_KP_Equal:\n+        case GDK_KEY_KP_Multiply:\n+        case GDK_KEY_KP_Add:\n+        case GDK_KEY_KP_Subtract:\n+        case GDK_KEY_KP_Decimal:\n+        case GDK_KEY_KP_Separator:\n+        case GDK_KEY_KP_Divide:\n+        case GDK_KEY_KP_0:\n+        case GDK_KEY_KP_1:\n+        case GDK_KEY_KP_2:\n+        case GDK_KEY_KP_3:\n+        case GDK_KEY_KP_4:\n+        case GDK_KEY_KP_5:\n+        case GDK_KEY_KP_6:\n+        case GDK_KEY_KP_7:\n+        case GDK_KEY_KP_8:\n+        case GDK_KEY_KP_9:\n+            return true;\n+        default:\n+            return false;\n+    }\n+}\n+\n+\/\/ This routine is given a set of GdkKeymap entries which can generate a specific keyval\n+\/\/ and finds the entry that generates that keyval on the correct layout (group) at shift\n+\/\/ level 0.\n+static gint search_keys(GdkKeymap *keymap, GdkKeymapKey *keys, gint n_keys, guint search_keyval, int search_group, bool requires_num_lock) {\n+    gint result = -1;\n+\n+    GdkModifierType state = (GdkModifierType)0;\n+    if (requires_num_lock) {\n+        state = GDK_MOD2_MASK;\n+    }\n+    for (gint i = 0; i < n_keys; ++i)\n+    {\n+        guint keyval = 0;\n+        if (gdk_keymap_translate_keyboard_state(keymap, keys[i].keycode, state, search_group,\n+                                                &keyval, nullptr, nullptr, nullptr)) {\n+            if (keyval == search_keyval) {\n+                result = keys[i].keycode;\n+                break;\n+            }\n+        }\n+    }\n+    return result;\n+}\n+\n+extern \"C\" {\n+    static gint get_current_keyboard_group();\n+}\n+\n+gint find_gdk_keycode_for_keyval(gint keyval) {\n+    GdkKeymapKey *keys = nullptr;\n+    gint n_keys = 0;\n+    GdkKeymap* keymap = gdk_keymap_get_for_display(gdk_display_get_default());\n+\n+    \/\/ The routine get_glass_key assigns a Java KeyCode to a key event. For\n+    \/\/ the Robot we need to reverse that process.\n+    \/\/\n+    \/\/ GDK assigns different keyvals to upper and lower case letters.\n+    \/\/ get_glass_key turns off the Shift modifier and uses the lower-case\n+    \/\/ letter.\n+    keyval = gdk_keyval_to_lower(keyval);\n+\n+    \/\/ When looking for a key code on the numeric keypad we have to manually\n+    \/\/ apply the correct modifier.\n+    bool requires_num_lock = keyval_requires_numlock(keyval);\n+\n+    \/\/ Retrieve all the keymap entries that can generate this keyval. This\n+    \/\/ includes entries on all layouts (groups) and shift levels. It is up\n+    \/\/ to us to find an entry that's on the current group and at shift level\n+    \/\/ 0 (which is what get_glass_key uses).\n+    if (!gdk_keymap_get_entries_for_keyval(keymap, keyval, &keys, &n_keys)) {\n+        return -1;\n+    }\n+\n+    gint group = get_current_keyboard_group();\n+    gint result = search_keys(keymap, keys, n_keys, keyval, group, requires_num_lock);\n+    if (result < 0 && group != 0) {\n+        \/\/ Accelerators involving the characters A-Z must work even on\n+        \/\/ non-Latin layouts. If get_glass_key can't map to a Java key code\n+        \/\/ on the current layout it switches to layout 0 seeking a Latin\n+        \/\/ mapping. This is wrong in two ways: layout 0 might not be Latin\n+        \/\/ and even if it is Latin it should only be used for finding\n+        \/\/ KeyCodes A-Z. For compatibility this routine continues to use\n+        \/\/ group 0 but does impose the A-Z restriction.\n+        if (keyval >= GDK_KEY_a && keyval <= GDK_KEY_z) {\n+            result = search_keys(keymap, keys, n_keys, keyval, 0, requires_num_lock);\n+        }\n+    }\n+\n+    g_free(keys);\n+    return result;\n+}\n+\n@@ -337,0 +514,10 @@\n+    auto i = char_to_java_code.find(*ucs_char);\n+    if (i != char_to_java_code.end()) {\n+        g_free(ucs_char);\n+        return i->second;\n+    }\n+\n+    \/\/ If we don't find the character in the map fall back to the old logic\n+    \/\/ for compatibility. It is incorrect because it ignores the keyboard\n+    \/\/ layout but it can handle characters like space and A-Z on Latin\n+    \/\/ layouts.\n@@ -368,0 +555,15 @@\n+\/*\n+  * Determine which keyboard layout is active. This is the group\n+  * number in the Xkb state. There is no direct way to query this\n+  * in Gdk.\n+  *\/\n+ static gint get_current_keyboard_group() {\n+     Display* display = gdk_x11_display_get_xdisplay(gdk_display_get_default());\n+     if (isXkbAvailable(display)) {\n+         XkbStateRec xkbState;\n+         XkbGetState(display, XkbUseCoreKbd, &xkbState);\n+         return xkbState.group;\n+     }\n+     return -1;\n+ }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_key.cpp","additions":204,"deletions":2,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-\n+gint find_gdk_keycode_for_keyval(gint keyval);\n@@ -39,1 +39,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_key.h","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -266,0 +266,1 @@\n+                add(KeyCode.ALT_GRAPH);\n@@ -402,4 +403,0 @@\n-            \/* Include one combination that involves Option\/AltGr *\/\n-            final String altGrSeven = (onMac ? \"|\" : \"{\");\n-            final String decimalCharacter = (onLinux ? \".\" : \",\");\n-\n@@ -431,1 +428,8 @@\n-            builder.add(KeyCode.DECIMAL,     decimalCharacter);\n+            \/\/ On Linux the German keypad produces a comma and is encoded by\n+            \/\/ both the OS and JavaFX as SEPARATOR. There is a DECIMAL key but\n+            \/\/ it doesn't correspond to the physical key on the keyboard.\n+            if (onLinux) {\n+                builder.add(KeyCode.SEPARATOR, \",\");\n+            } else {\n+                builder.add(KeyCode.DECIMAL, \",\");\n+            }\n@@ -706,1 +710,1 @@\n-                case DIVIDE, MULTIPLY, SUBTRACT, ADD, DECIMAL:\n+                case DIVIDE, MULTIPLY, SUBTRACT, ADD, DECIMAL, SEPARATOR:\n","filename":"tests\/manual\/events\/KeyboardTest.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"}]}