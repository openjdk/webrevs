{"files":[{"patch":"@@ -43,1 +43,2 @@\n-     * Indicates a nested notification was aborted early, meaning that not\n+     * Indicates a nested notification was aborted early because the new value\n+     * was modified during the loop to equal the old value. This means that not\n@@ -45,1 +46,2 @@\n-     * were called.\n+     * were called and so there may be confusion as to the current value is now\n+     * for some listeners.\n@@ -47,4 +49,2 @@\n-     * This happens when a listener changes the current value to the same\n-     * value as the old value at the current notification level. An abort\n-     * may indicate a problem with multiple listeners changing values that\n-     * are not converging to a mutually agreed value.\n+     * An abort may indicate a problem with multiple listeners changing values\n+     * that are not converging to a mutually agreed value.\n@@ -142,3 +142,1 @@\n-                newValue = observableValue.getValue();\n-\n-                valueObtained(newValue);\n+                if (!wasLocked && progress == NESTED_NOTIFICATION_ABORTED) {\n@@ -146,1 +144,5 @@\n-                if (Objects.equals(newValue, oldValue)) {\n+                    \/*\n+                     * Non-convergence detected at the top-level loop. Exit early here as further\n+                     * notifications will otherwise overwrite the progress value making this problem\n+                     * go undetected.\n+                     *\/\n@@ -148,1 +150,2 @@\n-                    if (progress == NESTED_NOTIFICATION_ABORTED) {\n+                    break;\n+                }\n@@ -150,11 +153,1 @@\n-                        \/*\n-                         * A nested notification occurred, which did not complete normally\n-                         * AND the value was reset to the previous value. This means that\n-                         * at least one listener is now unaware of the correct latest value.\n-                         * Previous implementations would notify such listeners with an\n-                         * incorrect old value and the same new value again, and if this\n-                         * triggered further modifications would cause a stack overflow.\n-                         *\n-                         * As we don't want to notify listeners with bad values to trigger\n-                         * the unavoidable stack overflow, we instead throw an exception here.\n-                         *\/\n+                newValue = observableValue.getValue();\n@@ -162,2 +155,1 @@\n-                        throw new StackOverflowError(\"non-converging value detected in value modifying listeners on \" + observableValue + \"; value was reset twice to: \" + oldValue);\n-                    }\n+                valueObtained(newValue);\n@@ -165,0 +157,1 @@\n+                if (Objects.equals(newValue, oldValue)) {\n@@ -184,5 +177,20 @@\n-             * This is a top level notification (as when it started the notification, it wasn't\n-             * locked). If a nested notification was aborted for any reason, it means that the\n-             * value was being modified by multiple listeners that could not reach consensus.\n-             * A StackOverflowError is thrown to indicate a serious issue (and to mimic similar\n-             * cases that do result in a real StackOverflowError).\n+             * The is the top level notification call, which has been notifying listeners\n+             * of value X. A nested loop occurred that was notifying listeners of a different\n+             * value Y was aborted. This means:\n+             *\n+             * - The top level loop notified its listeners up to index i with value X\n+             * - At least one listener was not notified in the nested loop with value Y\n+             *   while it was already notified in this loop with value X (in other\n+             *   words, it did not notify all listeners up to index i)\n+             *\n+             * This is a conflict, as at least one listener received X but did not\n+             * receive Y, and this call (the top level one) will not rectify this as\n+             * it already completed notifications. For example, a listener with\n+             * index 2 triggered a nested notification (i == 2), but this notification\n+             * was aborted at index 1, then the listener at index 2 received X (from\n+             * the top level loop) but never received Y from the nested loop.\n+             *\n+             * If it was not a top level notification, there is a chance that the\n+             * listeners involved may still converge as the notification process is\n+             * still ongoing, which is why this is only an error when there is no\n+             * further chance that the values may converge:\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ListenerList.java","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -292,0 +292,4 @@\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                records.add(\"CL3: changed from \" + o + \" to \" + n);\n+            });\n+\n@@ -294,1 +298,1 @@\n-            assertEquals(\"non-converging value detected in value modifying listeners on LongProperty [value: 2]; value was reset twice to: 2\", e.getMessage());\n+            assertEquals(\"non-converging value detected in value modifying listeners on LongProperty [value: 2]; value was reset twice to: 0\", e.getMessage());\n@@ -299,2 +303,1 @@\n-         * that will never agree. This variant results in an actual\n-         * StackOverflowError, which for now is just fine.\n+         * that will never agree.\n@@ -346,0 +349,52 @@\n+        \/**\n+         * A variant of the non-convergence test with three listeners\n+         * that will never agree and an additional observing listener.\n+         *\/\n+        @Test\n+        void shouldDetectNonConvergence_3() {\n+            LongProperty property = new SimpleLongProperty(1);\n+\n+            L list = create(il1, il2);\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL1: changed from \" + o + \" to \" + n);\n+\n+                if (v < 20) {\n+                    property.set(20);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL2: changed from \" + o + \" to \" + n);\n+\n+                if (v < 30) {\n+                    property.set(30);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL3: changed from \" + o + \" to \" + n);\n+\n+                if (v > 10) {\n+                    property.set(10);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                records.add(\"CL4: changed from \" + o + \" to \" + n);\n+            });\n+\n+            StackOverflowError e = assertThrows(StackOverflowError.class, () -> notifyListeners(list, property, 0));\n+\n+            assertEquals(\"non-converging value detected in value modifying listeners on LongProperty [value: 30]; value was reset twice to: 0\", e.getMessage());\n+        }\n+\n@@ -351,1 +406,1 @@\n-        void shouldDetectNonConvergence_3() {\n+        void shouldDetectNonConvergence_4() {\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ListenerListTestBase.java","additions":59,"deletions":4,"binary":false,"changes":63,"status":"modified"}]}