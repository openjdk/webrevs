{"files":[{"patch":"@@ -35,3 +35,2 @@\n- * Extension of {@link ListenerListBase} which given an {@link ObservableValue}\n- * and its old value provides the means to notify all contained listeners\n- * with a depth first approach.\n+ * Extension of {@link ListenerListBase}, which allows an {@link ObservableValue}\n+ * and its old value to notify all contained listeners with a depth first approach.\n@@ -93,0 +92,1 @@\n+            \/\/ skip if this listener was removed during a notification:\n@@ -110,7 +110,2 @@\n-            ChangeListener<T> listener = getChangeListener(i);\n-\n-            if (listener == null) {\n-                continue;\n-            }\n-\n-            \/\/ only get the latest value if this is the first loop or a nested notification occurred:\n+            \/\/ only get the latest value if this is the first loop or a nested notification occurred;\n+            \/\/ do this before skipping listeners as this will fail if the first listener was skipped otherwise\n@@ -127,0 +122,7 @@\n+            ChangeListener<T> listener = getChangeListener(i);\n+\n+            \/\/ skip if this listener was removed during a notification:\n+            if (listener == null) {\n+                continue;\n+            }\n+\n@@ -134,1 +136,2 @@\n-        \/\/ communicate to a higher level loop that a nested notification occurred:\n+        \/\/ communicate to a higher level loop that a nested notification completed (if\n+        \/\/ there is a higher loop):\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ListenerList.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -31,3 +31,2 @@\n- * Extension of {@link ListenerList} which given an {@link ObservableValue}\n- * provides the means to notify all contained listeners with a depth first\n- * approach.<p>\n+ * Extension of {@link ListenerList} which allows an {@link ObservableValue}\n+ * to notify all contained listeners with a depth first approach.<p>\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/OldValueCachingListenerList.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-            list.putLatestValue(null);  \/\/ clear to avoid references\n+            list.putLatestValue(null);  \/\/ clear old value cache to avoid references\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/OldValueCachingListenerManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,6 +28,0 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertNotEquals;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assertions.fail;\n-\n@@ -36,0 +30,1 @@\n+import java.util.HashSet;\n@@ -40,0 +35,1 @@\n+import java.util.Set;\n@@ -46,4 +42,0 @@\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n@@ -64,0 +56,10 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n@@ -117,1 +119,1 @@\n-        for(int[] counts : new Combinations(PATTERN)) {\n+        for (int[] counts : new Combinations(PATTERN)) {\n@@ -136,1 +138,1 @@\n-        for(int[] counts : new Combinations(PATTERN)) {\n+        for (int[] counts : new Combinations(PATTERN)) {\n@@ -148,1 +150,1 @@\n-            if(changeListenerCount == 0) {\n+            if (changeListenerCount == 0) {\n@@ -179,1 +181,1 @@\n-            for(int[] counts : new Combinations(PATTERN)) {\n+            for (int[] counts : new Combinations(PATTERN)) {\n@@ -196,1 +198,1 @@\n-                if(changeListenerCount == 0) {\n+                if (changeListenerCount == 0) {\n@@ -242,1 +244,2 @@\n-            if(current.equals(value2)) {\n+\n+            if (current.equals(value2)) {\n@@ -254,1 +257,1 @@\n-        assertConsistentChangeSequence(records, value1, value1);\n+        assertConsistentChangeSequence(records, value1, value1, Set.of(value1, value2));\n@@ -272,1 +275,37 @@\n-            if(current.equals(value2)) {\n+\n+            if (current.equals(value2)) {\n+                valueSetter.accept(value1);\n+            }\n+        });\n+\n+        \/*\n+         * Start test:\n+         *\/\n+\n+        valueSetter.accept(value2);\n+\n+        assertConsistentChangeSequence(records, value1, value2, Set.of(value1, value2));\n+    }\n+\n+    \/*\n+     * Tests if the embedded ObservableValue sends sensible change events when a nested change occurs\n+     * and the first listener was removed.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldSendCorrectNestedEventsWhenFirstListenerRemoved(Action<T> action, T value1, T value2, Consumer<T> valueSetter) {\n+        List<Record> records = new ArrayList<>();\n+\n+        \/*\n+         * Create three listeners, with the \"middle\" one removing the first listener and modifying the\n+         * value back to value1.\n+         *\/\n+\n+        ChangeListener<? super T> firstListener = (obs, old, current) -> records.add(new Record.Change(\"A\", old, current));\n+\n+        action.addListener(firstListener);\n+        action.addListener((obs, old, current) -> {\n+            records.add(new Record.Change(\"B\", old, current));\n+\n+            if (Objects.equals(current, value2)) {\n+                action.removeListener(firstListener);\n@@ -276,0 +315,1 @@\n+        action.addListener((obs, old, current) -> records.add(new Record.Change(\"C\", old, current)));\n@@ -283,1 +323,1 @@\n-        assertConsistentChangeSequence(records, value1, value2);\n+        assertConsistentChangeSequence(records, value1, value1, Set.of(value1, value2));\n@@ -302,1 +342,1 @@\n-        for(int i = 0; i < 100; i++) {\n+        for (int i = 0; i < 100; i++) {\n@@ -327,1 +367,1 @@\n-        for(int i = 0; i < 100; i++) {\n+        for (int i = 0; i < 100; i++) {\n@@ -354,1 +394,1 @@\n-        for(int i = 0; i < 12; i++) {\n+        for (int i = 0; i < 12; i++) {\n@@ -381,1 +421,1 @@\n-        for(int i = 0; i < 100; i++) {\n+        for (int i = 0; i < 100; i++) {\n@@ -406,1 +446,1 @@\n-        for(int i = 0; i < 100; i++) {\n+        for (int i = 0; i < 100; i++) {\n@@ -432,1 +472,1 @@\n-        for(int i = 0; i < 12; i++) {\n+        for (int i = 0; i < 12; i++) {\n@@ -443,1 +483,1 @@\n-    private void assertCalls(Consumer<Integer> step, AtomicInteger calls, int... expectedCalls) {\n+    private static void assertCalls(Consumer<Integer> step, AtomicInteger calls, int... expectedCalls) {\n@@ -696,2 +736,4 @@\n-    private static void assertConsistentChangeSequence(List<Record> records, Object expectedFirstValue, Object expectedLastValue) {\n-        for(String identifier : records.stream().map(Record::identifier).distinct().toList()) {\n+    private static void assertConsistentChangeSequence(List<Record> records, Object expectedFirstValue, Object expectedLastValue, Set<Object> inputValidValues) {\n+        Set<Object> validValues = new HashSet<>(inputValidValues);  \/\/ convert to regular set as Set#of is being obnoxious about calling contains(null)\n+\n+        for (String identifier : records.stream().map(Record::identifier).distinct().toList()) {\n@@ -701,2 +743,2 @@\n-            for (Record record : filtered) {\n-                if (record instanceof Record.Change c) {\n+            for (Record r : filtered) {\n+                if (r instanceof Record.Change c) {\n@@ -710,4 +752,8 @@\n-            for (Record record : filtered) {\n-                if (previous != null) {\n-                    if (record instanceof Record.Change c) {\n-                        if(previous instanceof Record.Change pc) {\n+            for (Record r : filtered) {\n+                if (r instanceof Record.Change c) {\n+                    \/\/ Checks if values make sense at all:\n+                    assertTrue(validValues.contains(c.old), c + \" has an unexpected old value; valid values are \" + validValues);\n+                    assertTrue(validValues.contains(c.current), c + \" has an unexpected current value; valid values are \" + validValues);\n+\n+                    if (previous != null) {\n+                        if (previous instanceof Record.Change pc) {\n@@ -719,1 +765,1 @@\n-                previous = record;\n+                previous = r;\n@@ -735,1 +781,1 @@\n-            if(!Objects.equals(expectedFirstValue, expectedLastValue) && changesOnly.isEmpty()) {\n+            if (!Objects.equals(expectedFirstValue, expectedLastValue) && changesOnly.isEmpty()) {\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/ObservableValueTest.java","additions":82,"deletions":36,"binary":false,"changes":118,"status":"modified"}]}