{"files":[{"patch":"@@ -60,0 +60,1 @@\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n@@ -67,1 +68,10 @@\n-    private static final int[] PATTERN = new int[] {1, 2, 0, 50, 3, 7};\n+\n+    \/**\n+     * These are counts for the number of listeners added to a property\n+     * or binding. The test code switches between these numbers, and checks\n+     * if all listeners function as expected. Various combinations are used\n+     * here as the implementation also switches between various states\n+     * depending on the number of listeners attached, so some exhaustive\n+     * checking is needed to ensure all works correct.\n+     *\/\n+    private static final int[] LISTENER_COUNTS = new int[] {1, 2, 0, 50, 3, 7};\n@@ -70,1 +80,10 @@\n-     * ObservableValue cases to test:\n+     * ObservableValue cases to test. There is a case for each type of\n+     * property and binding (for good coverage and to ensure they all\n+     * work correctly and nothing was missed). Each case uses two\n+     * values that it switches between to see if a change and\/or\n+     * invalidation occurs as expected.\n+     *\n+     * The binding variants also have two helper functions, one that\n+     * creates a binding derived from the main observable (which will\n+     * be tested against) and one that modifies the original observable\n+     * (as the binding can't be modified directly).\n@@ -90,1 +109,7 @@\n-            Case.of(new SimpleObjectProperty<>(), \"A!\", \"B!\", p -> Bindings.createObjectBinding(() -> (p.get() + \"!\").intern(), p), (p, v) -> p.setValue(v.substring(0, 1).intern())),  \/\/ intern() used to make sure ObjectBinding equality check works for this test\n+            Case.of(\n+                new SimpleObjectProperty<>(),\n+                \"A!\",\n+                \"B!\",\n+                p -> Bindings.createObjectBinding(() -> (p.get() + \"!\").intern(), p),\n+                (p, v) -> p.setValue(v.substring(0, 1).intern()) \/\/ intern() used to make sure ObjectBinding equality check works for this test\n+            ),\n@@ -96,1 +121,2 @@\n-        return cases.stream().map(c -> Arguments.of(new Action<>(c.observableValue), c.primaryValue, c.alternativeValue, c.valueSetter));\n+        return cases.stream()\n+            .map(c -> Arguments.of(new Action<>(c.observableValue), c.primaryValue, c.alternativeValue, c.valueSetter));\n@@ -119,3 +145,3 @@\n-        for (int[] counts : new Combinations(PATTERN)) {\n-            int invalidationListenerCount = counts[0];\n-            int changeListenerCount = counts[1];\n+        for (ListenerCounts counts : new Combinations(LISTENER_COUNTS)) {\n+            \/\/ set up a specific combination of invalidation and change listeners:\n+            action.setListenerCounts(counts);\n@@ -123,1 +149,4 @@\n-            action.setListenerCounts(invalidationListenerCount, changeListenerCount);\n+            \/*\n+             * Remove some listeners that were never added; nothing is expected, so only an\n+             * exception thrown here is a failure.\n+             *\/\n@@ -125,2 +154,2 @@\n-            action.removeListener(obs -> {});\n-            action.removeListener((obs, old, current) -> {});\n+            assertDoesNotThrow(() -> action.removeListener(obs -> {}));\n+            assertDoesNotThrow(() -> action.removeListener((obs, old, current) -> {}));\n@@ -138,3 +167,3 @@\n-        for (int[] counts : new Combinations(PATTERN)) {\n-            int invalidationListenerCount = counts[0];\n-            int changeListenerCount = counts[1];\n+        for (ListenerCounts counts : new Combinations(LISTENER_COUNTS)) {\n+            int invalidationListenerCount = counts.invalidationListeners;\n+            int changeListenerCount = counts.changeListeners;\n@@ -142,1 +171,2 @@\n-            action.setListenerCounts(invalidationListenerCount, changeListenerCount);\n+            \/\/ set up a specific combination of invalidation and change listeners:\n+            action.setListenerCounts(counts);\n@@ -152,1 +182,1 @@\n-                action.assertEvents();  \/\/ when there are no change listeners, setting a different value (while invalid) should not trigger any events\n+                action.assertNoEvents();  \/\/ no change listeners, and already invalid, expect nothing\n@@ -156,1 +186,1 @@\n-            action.assertEvents();\n+            action.assertNoEvents();\n@@ -159,1 +189,1 @@\n-            action.assertEvents();\n+            action.assertNoEvents();\n@@ -162,1 +192,1 @@\n-            action.assertEvents();\n+            action.assertNoEvents();\n@@ -175,1 +205,0 @@\n-        AtomicInteger exceptions = new AtomicInteger();\n@@ -177,0 +206,1 @@\n+        AtomicInteger exceptions = new AtomicInteger();\n@@ -179,0 +209,1 @@\n+            \/\/ Temporarily replace exception handler in order to check for thrown exceptions:\n@@ -181,3 +212,3 @@\n-            for (int[] counts : new Combinations(PATTERN)) {\n-                int invalidationListenerCount = counts[0];\n-                int changeListenerCount = counts[1];\n+            for (ListenerCounts counts : new Combinations(LISTENER_COUNTS)) {\n+                int invalidationListenerCount = counts.invalidationListeners;\n+                int changeListenerCount = counts.changeListeners;\n@@ -187,1 +218,2 @@\n-                action.setThrowingListenerCounts(invalidationListenerCount, changeListenerCount);\n+                \/\/ set up a specific combination of invalidation and change listeners:\n+                action.setThrowingListenerCounts(counts);\n@@ -200,1 +232,1 @@\n-                    action.assertEvents();  \/\/ when there are no change listeners, setting a different value (while invalid) should not trigger any events\n+                    action.assertNoEvents();  \/\/ no change listeners, and already invalid, expect nothing\n@@ -205,1 +237,1 @@\n-                action.assertEvents();\n+                action.assertNoEvents();\n@@ -209,1 +241,1 @@\n-                action.assertEvents();\n+                action.assertNoEvents();\n@@ -213,1 +245,1 @@\n-                action.assertEvents();\n+                action.assertNoEvents();\n@@ -235,1 +267,1 @@\n-        List<Record> records = new ArrayList<>();\n+        List<Change> changes = new ArrayList<>();\n@@ -241,1 +273,1 @@\n-        action.addListener((obs, old, current) -> records.add(new Record.Change(\"A\", old, current)));\n+        action.addListener((obs, old, current) -> changes.add(new Change(\"A\", old, current)));\n@@ -243,1 +275,1 @@\n-            records.add(new Record.Change(\"B\", old, current));\n+            changes.add(new Change(\"B\", old, current));\n@@ -249,1 +281,1 @@\n-        action.addListener((obs, old, current) -> records.add(new Record.Change(\"C\", old, current)));\n+        action.addListener((obs, old, current) -> changes.add(new Change(\"C\", old, current)));\n@@ -257,1 +289,1 @@\n-        assertConsistentChangeSequence(records, value1, value1, Set.of(value1, value2));\n+        assertConsistentChangeSequence(changes, value1, value1, Set.of(value1, value2));\n@@ -267,1 +299,1 @@\n-        List<Record> records = new ArrayList<>();\n+        List<Change> changes = new ArrayList<>();\n@@ -274,1 +306,1 @@\n-            records.add(new Record.Change(\"B\", old, current));\n+            changes.add(new Change(\"B\", old, current));\n@@ -287,1 +319,1 @@\n-        assertConsistentChangeSequence(records, value1, value2, Set.of(value1, value2));\n+        assertConsistentChangeSequence(changes, value1, value2, Set.of(value1, value2));\n@@ -297,1 +329,1 @@\n-        List<Record> records = new ArrayList<>();\n+        List<Change> changes = new ArrayList<>();\n@@ -304,1 +336,1 @@\n-        ChangeListener<? super T> firstListener = (obs, old, current) -> records.add(new Record.Change(\"A\", old, current));\n+        ChangeListener<? super T> firstListener = (obs, old, current) -> changes.add(new Change(\"A\", old, current));\n@@ -308,1 +340,1 @@\n-            records.add(new Record.Change(\"B\", old, current));\n+            changes.add(new Change(\"B\", old, current));\n@@ -315,1 +347,1 @@\n-        action.addListener((obs, old, current) -> records.add(new Record.Change(\"C\", old, current)));\n+        action.addListener((obs, old, current) -> changes.add(new Change(\"C\", old, current)));\n@@ -323,1 +355,1 @@\n-        assertConsistentChangeSequence(records, value1, value1, Set.of(value1, value2));\n+        assertConsistentChangeSequence(changes, value1, value1, Set.of(value1, value2));\n@@ -484,1 +516,1 @@\n-        for(int i = 0; i < expectedCalls.length; i++) {\n+        for (int i = 0; i < expectedCalls.length; i++) {\n@@ -493,1 +525,1 @@\n-        private final List<String> records = new ArrayList<>();\n+        private final List<String> eventRecords = new ArrayList<>();\n@@ -525,2 +557,14 @@\n-        void setListenerCounts(int invalidationListenerCount, int changeListenerCount) {\n-            for(int i = invalidationListeners.size() - 1; i >= invalidationListenerCount; --i) {\n+        \/**\n+         * Sets the number of listeners to the given values. This function will add\n+         * more listeners if the number of listeners is lower than the given value, and\n+         * will remove listeners if the number of listeners is higher than the given value.\n+         * The end result is that the exact number of listeners given is present on the\n+         * {@link ObservableValue} currently under test.\n+         *\n+         * @param counts the number of invalidation and change listeners, cannot be {@code null}\n+         *\/\n+        void setListenerCounts(ListenerCounts counts) {\n+            int invalidationListenerCount = counts.invalidationListeners;\n+            int changeListenerCount = counts.changeListeners;\n+\n+            for (int i = invalidationListeners.size() - 1; i >= invalidationListenerCount; --i) {\n@@ -533,1 +577,1 @@\n-            for(int i = changeListeners.size() - 1; i >= changeListenerCount; --i) {\n+            for (int i = changeListeners.size() - 1; i >= changeListenerCount; --i) {\n@@ -540,1 +584,1 @@\n-            for(int i = invalidationListeners.size(); i < invalidationListenerCount; i++) {\n+            for (int i = invalidationListeners.size(); i < invalidationListenerCount; i++) {\n@@ -543,3 +587,1 @@\n-                InvalidationListener invalidationListener = obs -> {\n-                    records.add(\"Invalidation of \" + j);\n-                };\n+                InvalidationListener invalidationListener = obs -> eventRecords.add(\"Invalidation of \" + j);\n@@ -551,1 +593,1 @@\n-            for(int i = changeListeners.size(); i < changeListenerCount; i++) {\n+            for (int i = changeListeners.size(); i < changeListenerCount; i++) {\n@@ -554,3 +596,2 @@\n-                ChangeListener<Object> changeListener = (obs, old, current) -> {\n-                    records.add(\"Change of \" + j + \" from \" + old + \" to \" + current);\n-                };\n+                ChangeListener<Object> changeListener = (obs, old, current) ->\n+                    eventRecords.add(\"Change of \" + j + \" from \" + old + \" to \" + current);\n@@ -563,2 +604,14 @@\n-        void setThrowingListenerCounts(int invalidationListenerCount, int changeListenerCount) {\n-            for(int i = invalidationListeners.size() - 1; i >= invalidationListenerCount; --i) {\n+        \/**\n+         * Sets the number of throwing listeners to the given values. This function will add\n+         * more listeners if the number of listeners is lower than the given value, and\n+         * will remove listeners if the number of listeners is higher than the given value.\n+         * The end result is that the exact number of listeners given is present on the\n+         * {@link ObservableValue} currently under test.\n+         *\n+         * @param counts the number of invalidation and change listeners, cannot be {@code null}\n+         *\/\n+        void setThrowingListenerCounts(ListenerCounts counts) {\n+            int invalidationListenerCount = counts.invalidationListeners;\n+            int changeListenerCount = counts.changeListeners;\n+\n+            for (int i = invalidationListeners.size() - 1; i >= invalidationListenerCount; --i) {\n@@ -571,1 +624,1 @@\n-            for(int i = changeListeners.size() - 1; i >= changeListenerCount; --i) {\n+            for (int i = changeListeners.size() - 1; i >= changeListenerCount; --i) {\n@@ -578,1 +631,1 @@\n-            for(int i = invalidationListeners.size(); i < invalidationListenerCount; i++) {\n+            for (int i = invalidationListeners.size(); i < invalidationListenerCount; i++) {\n@@ -582,2 +635,2 @@\n-                    records.add(\"Invalidation of \" + j);\n-                    throw new RuntimeException(\"boo\");\n+                    eventRecords.add(\"Invalidation of \" + j);\n+                    throw new RuntimeException(\"this listener throws an exception\");\n@@ -590,1 +643,1 @@\n-            for(int i = changeListeners.size(); i < changeListenerCount; i++) {\n+            for (int i = changeListeners.size(); i < changeListenerCount; i++) {\n@@ -594,2 +647,2 @@\n-                    records.add(\"Change of \" + j + \" from \" + old + \" to \" + current);\n-                    throw new RuntimeException(\"boo\");\n+                    eventRecords.add(\"Change of \" + j + \" from \" + old + \" to \" + current);\n+                    throw new RuntimeException(\"this listener throws an exception\");\n@@ -603,0 +656,24 @@\n+        \/**\n+         * Asserts that no events occurred at all since the last\n+         * check.\n+         *\/\n+        void assertNoEvents() {\n+            assertEvents();  \/\/ called without any expected templates\n+        }\n+\n+        \/**\n+         * Asserts that the given events occurred. If no events are given, then\n+         * checks if no events occurred. The events are stored as strings and follow\n+         * the formats:\n+         *\n+         * <ul>\n+         * <li>{@code Change of (property) from (old value) to (new value)}<\/li>\n+         * <li>{@code Invalidation of (property)}<\/li>\n+         * <\/ul>\n+         *\n+         * <p>The place holders {@code %c} and {@code %i} indicate the property\n+         * involved, so to verify that <b>all<\/b> change listeners changed from 2 to 5, pass\n+         * the template: {@code Change of %c from 2 to 5}\n+         *\n+         * @param expectedTemplates expected event templates, cannot be {@code null} but can be empty\n+         *\/\n@@ -604,2 +681,2 @@\n-            for(String expectedTemplate : expectedTemplates) {\n-                if(expectedTemplate == null) {\n+            for (String expectedTemplate : expectedTemplates) {\n+                if (expectedTemplate == null) {\n@@ -609,2 +686,2 @@\n-                if(expectedTemplate.contains(\"%c\")) {\n-                    if(changeListeners.isEmpty()) {\n+                if (expectedTemplate.contains(\"%c\")) {\n+                    if (changeListeners.isEmpty()) {\n@@ -614,1 +691,1 @@\n-                    for(int i = 0; i < changeListeners.size(); i++) {\n+                    for (int i = 0; i < changeListeners.size(); i++) {\n@@ -616,1 +693,1 @@\n-                        assertTrue(records.remove(expected), () -> \"Expected \\\"\" + expected + \"\\\" but found none for: \" + this);\n+                        assertTrue(eventRecords.remove(expected), () -> \"Expected \\\"\" + expected + \"\\\" but found none for: \" + this);\n@@ -619,2 +696,2 @@\n-                else if(expectedTemplate.contains(\"%i\")) {\n-                    if(invalidationListeners.isEmpty()) {\n+                else if (expectedTemplate.contains(\"%i\")) {\n+                    if (invalidationListeners.isEmpty()) {\n@@ -624,1 +701,1 @@\n-                    for(int i = 0; i < invalidationListeners.size(); i++) {\n+                    for (int i = 0; i < invalidationListeners.size(); i++) {\n@@ -626,1 +703,1 @@\n-                        assertTrue(records.remove(expected), () -> \"Expected \\\"\" + expected + \"\\\" but found none for: \" + this);\n+                        assertTrue(eventRecords.remove(expected), () -> \"Expected \\\"\" + expected + \"\\\" but found none for: \" + this);\n@@ -631,2 +708,2 @@\n-            if(!records.isEmpty()) {\n-                fail(\"Did not expect: \" + records + \" for: \" + this);\n+            if (!eventRecords.isEmpty()) {\n+                fail(\"Did not expect: \" + eventRecords + \" for: \" + this);\n@@ -642,0 +719,10 @@\n+    \/**\n+     * Defines a test case for a specific property or binding type. To make a valid\n+     * test case there are two different valid values needed (to trigger a change)\n+     * and a way to change the value of the property or binding involved. For properties\n+     * this is a straight-forward setter call, while for bindings this involves creating\n+     * a helper base property that can be modified to affect the binding's value.\n+     *\n+     * @param <P> the property or binding type\n+     * @param <T> the value type it can hold\n+     *\/\n@@ -648,1 +735,14 @@\n-        public Case(P property, T primaryValue, T alternativeValue, Function<P, ObservableValue<? super T>> modifier, BiConsumer<P, T> valueSetter) {\n+        \/**\n+         * Creates a new test case.\n+         *\n+         * @param property a (base) property to hold values, for property tests this is the property tested against;\n+         *   for bindings, this is the property bound against and manipulated to change the binding value\n+         * @param primaryValue a valid value for the property\n+         * @param alternativeValue an alternative valid value for the property\n+         * @param creator creates the observable value to manipulate; this will be the same as the property for\n+         *   property tests, for bindings it will be a derived value from the base property given\n+         * @param valueSetter a function that changes the value of the property; this is just the setter for\n+         *   property tests, while for bindings it changes the base property in such a way that it undoes the\n+         *   effect of the binding (ie. if the binding added 2 to an integer property, the setter must subtract 2)\n+         *\/\n+        Case(P property, T primaryValue, T alternativeValue, Function<P, ObservableValue<? super T>> creator, BiConsumer<P, T> valueSetter) {\n@@ -652,1 +752,1 @@\n-            this.observableValue = modifier.apply(property);\n+            this.observableValue = creator.apply(property);\n@@ -657,0 +757,3 @@\n+        \/*\n+         * Static convenience method to create a binding test case:\n+         *\/\n@@ -661,0 +764,3 @@\n+        \/*\n+         * Static convenience method to create a property test case:\n+         *\/\n@@ -671,7 +777,1 @@\n-    private static class Combinations implements Iterable<int[]> {\n-        private final int[] values;\n-\n-        public Combinations(int[] values) {\n-            this.values = values;\n-        }\n-\n+    record Combinations(int[] values) implements Iterable<ListenerCounts> {\n@@ -679,1 +779,1 @@\n-        public Iterator<int[]> iterator() {\n+        public Iterator<ListenerCounts> iterator() {\n@@ -684,1 +784,1 @@\n-    private static class Combinator implements Iterator<int[]> {\n+    private static class Combinator implements Iterator<ListenerCounts> {\n@@ -703,2 +803,2 @@\n-        public int[] next() {\n-            if(!hasNext()) {\n+        public ListenerCounts next() {\n+            if (!hasNext()) {\n@@ -708,1 +808,1 @@\n-            int[] next = new int[] {values[x], values[(y + s) % m]};\n+            ListenerCounts next = new ListenerCounts(values[x], values[(y + s) % m]);\n@@ -710,1 +810,1 @@\n-            if(++s == m) {\n+            if (++s == m) {\n@@ -713,1 +813,1 @@\n-                if(++x == m) {\n+                if (++x == m) {\n@@ -723,2 +823,1 @@\n-    sealed interface Record {\n-        String identifier();\n+    record ListenerCounts(int invalidationListeners, int changeListeners) {}\n@@ -726,7 +825,11 @@\n-        record Added(String identifier) implements Record {}\n-        record Removed(String identifier) implements Record {}\n-        record Change(String identifier, Object old, Object current) implements Record {\n-            @Override\n-            public String toString() {\n-                return \"[\" + identifier + \": Changed from \" + old + \" to \" + current + \"]\";\n-            }\n+    \/**\n+     * A record of a change event received by a specific listener.\n+     *\n+     * @param identifier a listener identifier\n+     * @param old the old (previous) value received\n+     * @param current the current value (new value) received\n+     *\/\n+    record Change(String identifier, Object old, Object current) {\n+        @Override\n+        public String toString() {\n+            return \"[\" + identifier + \": Changed from \" + old + \" to \" + current + \"]\";\n@@ -736,1 +839,16 @@\n-    private static void assertConsistentChangeSequence(List<Record> records, Object expectedFirstValue, Object expectedLastValue, Set<Object> inputValidValues) {\n+    \/**\n+     * Given a list of changes that occurred, verifies that these changes follow the following\n+     * rules:\n+     *\n+     * <ul>\n+     * <li>Each change changes the value to a different value (old value != new value)<\/li>\n+     * <li>Each change has an old value equal to the previous' change new value<\/li>\n+     * <li>Each change changes to one of the expected valid input values given<\/li>\n+     * <\/ul>\n+     *\n+     * @param changes a list of changes, cannot be {@code null}\n+     * @param expectedFirstValue first value the property held\n+     * @param expectedLastValue last value the property should hold\n+     * @param inputValidValues allowed valid values\n+     *\/\n+    private static void assertConsistentChangeSequence(List<Change> changes, Object expectedFirstValue, Object expectedLastValue, Set<Object> inputValidValues) {\n@@ -739,2 +857,4 @@\n-        for (String identifier : records.stream().map(Record::identifier).distinct().toList()) {\n-            List<Record> filtered = records.stream().filter(c -> c.identifier().equals(identifier)).toList();\n+        \/\/ loop over all unique listeners (given by identifier):\n+        for (String identifier : changes.stream().map(Change::identifier).distinct().toList()) {\n+            \/\/ filter change list for the specific listener being checked:\n+            List<Change> filtered = changes.stream().filter(c -> c.identifier().equals(identifier)).toList();\n@@ -743,4 +863,2 @@\n-            for (Record r : filtered) {\n-                if (r instanceof Record.Change c) {\n-                    assertNotEquals(c.old, c.current, c + \" was not a change!\");\n-                }\n+            for (Change c : filtered) {\n+                assertNotEquals(c.old, c.current, c + \" was not a change!\");\n@@ -749,1 +867,1 @@\n-            Record previous = null;\n+            Change previous = null;\n@@ -752,11 +870,7 @@\n-            for (Record r : filtered) {\n-                if (r instanceof Record.Change c) {\n-                    \/\/ Checks if values make sense at all:\n-                    assertTrue(validValues.contains(c.old), c + \" has an unexpected old value; valid values are \" + validValues);\n-                    assertTrue(validValues.contains(c.current), c + \" has an unexpected current value; valid values are \" + validValues);\n-\n-                    if (previous != null) {\n-                        if (previous instanceof Record.Change pc) {\n-                            assertEquals(c.old, pc.current, pc + \" was followed by \" + c + \" with incorrect old value\");\n-                        }\n-                    }\n+            for (Change c : filtered) {\n+                \/\/ Checks if values make sense at all:\n+                assertTrue(validValues.contains(c.old), c + \" has an unexpected old value; valid values are \" + validValues);\n+                assertTrue(validValues.contains(c.current), c + \" has an unexpected current value; valid values are \" + validValues);\n+\n+                if (previous != null) {\n+                    assertEquals(c.old, previous.current, previous + \" was followed by \" + c + \" with incorrect old value\");\n@@ -765,1 +879,1 @@\n-                previous = r;\n+                previous = c;\n@@ -768,6 +882,2 @@\n-            List<Record.Change> changesOnly = filtered.stream()\n-                .filter(Record.Change.class::isInstance)\n-                .map(Record.Change.class::cast)\n-                .toList();\n-\n-            changesOnly.stream()\n+            \/\/ ensure old value of first change matches expected initial value:\n+            changes.stream()\n@@ -775,1 +885,1 @@\n-                .ifPresent(c -> c.old.equals(expectedFirstValue));\n+                .ifPresent(c -> assertEquals(c.old, expectedFirstValue));\n@@ -777,1 +887,2 @@\n-            changesOnly.stream()\n+            \/\/ ensure new value of last change matches expected last value:\n+            changes.stream()\n@@ -779,1 +890,1 @@\n-                .ifPresent(c -> c.current.equals(expectedLastValue));\n+                .ifPresent(c -> assertEquals(c.current, expectedLastValue));\n@@ -781,1 +892,2 @@\n-            if (!Objects.equals(expectedFirstValue, expectedLastValue) && changesOnly.isEmpty()) {\n+            \/\/ ensure there were changes if the first and last value were different:\n+            if (!Objects.equals(expectedFirstValue, expectedLastValue) && changes.isEmpty()) {\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/ObservableValueTest.java","additions":241,"deletions":129,"binary":false,"changes":370,"status":"modified"}]}