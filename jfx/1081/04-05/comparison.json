{"files":[{"patch":"@@ -42,0 +42,20 @@\n+    \/**\n+     * Indicates a nested notification was aborted early, meaning that not\n+     * all intended listeners (up to the maximum set by the higher level loop)\n+     * were called.\n+     *\n+     * This happens when a listener changes the current value to the same\n+     * value as the old value at the current notification level. An abort\n+     * may indicate a problem with multiple listeners changing values that\n+     * are not converging to a mutually agreed value.\n+     *\/\n+    private static final int NESTED_NOTIFICATION_ABORTED = -2;\n+\n+    \/**\n+     * Indicates a nested notification completed normally. After a nested\n+     * notification (aborted or not), the current value is re-read so listeners\n+     * not notified yet at the current level receive the newly updated current\n+     * value.\n+     *\/\n+    private static final int NESTED_NOTIFICATION_COMPLETED = -1;\n+\n@@ -49,1 +69,1 @@\n-     * actually occurred.<p>\n+     * actually occurred if if it completed normally or was aborted early.<p>\n@@ -52,4 +72,5 @@\n-     * listeners notified in a higher level loop (minus one), while\n-     * when its negative (-1) it indicates to a higher level loop that\n-     * a nested notification occurred, requiring, for example, a refresh\n-     * of the current value and a new equals check.\n+     * listeners notified in a higher level loop (minus one), while the constants\n+     * {@link #NESTED_NOTIFICATION_ABORTED} and {@link #NESTED_NOTIFICATION_COMPLETED}\n+     * indicate to a higher level loop that a nested notification occurred,\n+     * requiring, for example, a refresh of the current value and a new equals\n+     * check.\n@@ -109,1 +130,1 @@\n-        progress = -1;  \/\/ reset progress to ensure latest value is queried at least once\n+        progress = NESTED_NOTIFICATION_COMPLETED;  \/\/ reset progress to ensure latest value is queried at least once\n@@ -126,1 +147,21 @@\n-                    break;\n+\n+                    if (progress == NESTED_NOTIFICATION_ABORTED) {\n+\n+                        \/*\n+                         * A nested notification occurred, which did not complete normally\n+                         * AND the value was reset to the previous value. This means that\n+                         * at least one listener is now unaware of the correct latest value.\n+                         * Previous implementations would notify such listeners with an\n+                         * incorrect old value and the same new value again, and if this\n+                         * triggered further modifications would cause a stack overflow.\n+                         *\n+                         * As we don't want to notify listeners with bad values to trigger\n+                         * the unavoidable stack overflow, we instead throw an exception here.\n+                         *\/\n+\n+                        throw new StackOverflowError(\"non-converging value detected in value modifying listeners on \" + observableValue + \"; value was reset twice to: \" + oldValue);\n+                    }\n+\n+                    progress = NESTED_NOTIFICATION_ABORTED;  \/\/ Indicate an early exit before notifying all listeners intended at this level\n+\n+                    return wasLocked ? false : unlock();\n@@ -137,0 +178,16 @@\n+        if (progress == NESTED_NOTIFICATION_ABORTED) {\n+            if (wasLocked) {  \/\/ Is this also a nested notification?\n+                return false;  \/\/ progress left unchanged, so the ABORT is communicated to the next higher level loop\n+            }\n+\n+            \/*\n+             * This is a top level notification (as when it started the notification, it wasn't\n+             * locked). If a nested notification was aborted for any reason, it means that the\n+             * value was being modified by multiple listeners that could not reach consensus.\n+             * A StackOverflowError is thrown to indicate a serious issue (and to mimic similar\n+             * cases that do result in a real StackOverflowError).\n+             *\/\n+\n+            throw new StackOverflowError(\"non-converging value detected in value modifying listeners on \" + observableValue + \"; value was reset twice to: \" + oldValue);\n+        }\n+\n@@ -139,1 +196,1 @@\n-        progress = -1;\n+        progress = NESTED_NOTIFICATION_COMPLETED;\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ListenerList.java","additions":65,"deletions":8,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -45,0 +47,1 @@\n+\n@@ -254,0 +257,113 @@\n+        \/**\n+         * This tests add two change listeners that will never agree\n+         * on the final value (one sets the value to 2, the other to 3).\n+         * In previous implementations which would notify listeners in\n+         * all cases, even when their value didn't change, this would\n+         * automatically result in a StackOverflowError, alerting the user\n+         * of serious problems.\n+         *\n+         * This implementation has to specifically detect problematic use of\n+         * multiple value modifying listeners in order to alert the user.\n+         *\/\n+        @Test\n+        void shouldDetectNonConvergence() {\n+            LongProperty property = new SimpleLongProperty(1);\n+\n+            L list = create(il1, il2);\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL1: changed from \" + o + \" to \" + n);\n+\n+                property.set(2);\n+                notifyListeners(list, property, v);\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL2: changed from \" + o + \" to \" + n);\n+\n+                property.set(3);\n+                notifyListeners(list, property, v);\n+            });\n+\n+            StackOverflowError e = assertThrows(StackOverflowError.class, () -> notifyListeners(list, property, 0));\n+\n+            assertEquals(\"non-converging value detected in value modifying listeners on LongProperty [value: 2]; value was reset twice to: 2\", e.getMessage());\n+        }\n+\n+        \/**\n+         * A variant of the non-convergence test with three listeners\n+         * that will never agree. This variant results in an actual\n+         * StackOverflowError, which for now is just fine.\n+         *\/\n+        @Test\n+        void shouldDetectNonConvergence_2() {\n+            LongProperty property = new SimpleLongProperty(1);\n+\n+            L list = create(il1, il2);\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL1: changed from \" + o + \" to \" + n);\n+\n+                if (v < 20) {\n+                    property.set(20);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL2: changed from \" + o + \" to \" + n);\n+\n+                if (v < 30) {\n+                    property.set(30);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL3: changed from \" + o + \" to \" + n);\n+\n+                if (v > 10) {\n+                    property.set(10);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            StackOverflowError e = assertThrows(StackOverflowError.class, () -> notifyListeners(list, property, 0));\n+\n+            assertEquals(\"non-converging value detected in value modifying listeners on LongProperty [value: 30]; value was reset twice to: 0\", e.getMessage());\n+        }\n+\n+        \/**\n+         * A single listener that keeps changing values. This variant results in an actual\n+         * StackOverflowError.\n+         *\/\n+        @Test\n+        void shouldDetectNonConvergence_3() {\n+            LongProperty property = new SimpleLongProperty(1);\n+\n+            L list = create(il1, il2);\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL1: changed from \" + o + \" to \" + n);\n+\n+                property.set(5 + (v % 3));\n+                notifyListeners(list, property, v);\n+            });\n+\n+            StackOverflowError e = assertThrows(StackOverflowError.class, () -> notifyListeners(list, property, 0));\n+\n+            assertNull(e.getMessage());  \/\/ this was an actual StackOverflowError, and so has no message\n+        }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ListenerListTestBase.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"modified"}]}