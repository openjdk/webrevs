{"files":[{"patch":"@@ -0,0 +1,391 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.binding;\n+\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+\/**\n+ * Helper to manage an array as a data and size field in order to save\n+ * space overhead introduced by a dedicated class.<p>\n+ *\n+ * To use this class, subclass it and store an instance of this class in a\n+ * static field. Then just call methods on the array manager supplying the\n+ * instance each time.\n+ *\n+ * @param <I> the type of the instance providing the array\n+ * @param <E> the type of the elements in the array\n+ *\/\n+public abstract class ArrayManager<I, E> {\n+\n+    \/**\n+     * The minimum array size. (3 is a good number considering it would use exactly 24 bytes\n+     * with compressed oops with wasted space due to alignment issues).\n+     *\/\n+    private static final int MINIMUM_SIZE = 3;\n+\n+    \/**\n+     * The type of the elements in the array, in order to allocate arrays\n+     * of the correct type.\n+     *\/\n+    private final Class<E> elementType;\n+\n+    \/**\n+     * Constructs a new instance.\n+     *\n+     * @param elementType the type of the elements in the array, cannot be {@code null}\n+     * @throws NullPointerException when any of the parameters are {@code null}\n+     *\/\n+    public ArrayManager(Class<E> elementType) {\n+        this.elementType = Objects.requireNonNull(elementType);\n+    }\n+\n+    \/**\n+     * Gets the array under management.\n+     *\n+     * @param instance the instance it is located in, cannot be {@code null}\n+     * @return the array under management, can be {@code null}\n+     *\/\n+    protected abstract E[] getArray(I instance);\n+\n+    \/**\n+     * Sets the array under management.\n+     *\n+     * @param instance the instance it is located in, cannot be {@code null}\n+     * @param array the array to set, can be {@code null}\n+     *\/\n+    protected abstract void setArray(I instance, E[] array);\n+\n+    \/**\n+     * Gets the occupied slots of the array under management.\n+     *\n+     * @param instance the instance it is located in, cannot be {@code null}\n+     * @return the occupied slots of the array under management\n+     *\/\n+    protected abstract int getOccupiedSlots(I instance);\n+\n+    \/**\n+     * Sets the occupied slots of the array under management.\n+     *\n+     * @param instance the instance it is located in, cannot be {@code null}\n+     * @param occupiedSlots the occupied slots of the array to set\n+     *\/\n+    protected abstract void setOccupiedSlots(I instance, int occupiedSlots);\n+\n+    \/**\n+     * Adds an element at the end of the array, growing the arrow if necessary.\n+     * If the array needs to be grown, this function will call {@link #compact(Object, Object[])}\n+     * first to reclaim any space before deciding to grow the array.\n+     *\n+     * @param instance a reference to the instance where the array is stored, cannot be {@code null}\n+     * @param element an element to add, can be {@code null}\n+     * @throws NullPointerException when the given instance was {@code null}\n+     *\/\n+    public void add(I instance, E element) {\n+        E[] array = getArray(instance);\n+        int occupiedSlots = getOccupiedSlots(instance);\n+\n+        if (array == null) {\n+            setArray(instance, array = allocateArray(MINIMUM_SIZE));\n+            setOccupiedSlots(instance, occupiedSlots + 1);\n+\n+            array[0] = element;\n+\n+            return;\n+        }\n+\n+        int newSize = calculateOptimalSize(array.length, occupiedSlots + 1);\n+\n+        assert newSize >= array.length : newSize + \" >= \" + array.length;\n+\n+        if (newSize > array.length) {\n+            occupiedSlots -= compact(instance, array);\n+\n+            int optimalSize = calculateOptimalSize(array.length, occupiedSlots + 1);\n+\n+            if (optimalSize != array.length) {\n+                setArray(instance, array = Arrays.copyOf(array, optimalSize));\n+            }\n+        }\n+\n+        setOccupiedSlots(instance, occupiedSlots + 1);\n+\n+        array[occupiedSlots] = element;\n+    }\n+\n+    \/**\n+     * Finds the first occurrence of the given element in the array, and if\n+     * found, returns its index. If not found, -1 is returned.<p>\n+     *\n+     * This method does not modify the array fields.\n+     *\n+     * @param instance a reference to the instance where the array is stored, cannot be {@code null}\n+     * @param element an element to locate, can be {@code null}\n+     * @return the index of the first occurrence of the given element, or -1 if no such element was present\n+     * @throws NullPointerException when the given instance was {@code null}\n+     *\/\n+    public int indexOf(I instance, E element) {\n+        E[] array = getArray(instance);\n+        int occupiedSlots = getOccupiedSlots(instance);\n+\n+        for (int i = 0; i < occupiedSlots; i++) {\n+            if (Objects.equals(element, array[i])) {\n+                return i;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    \/**\n+     * Removes the element at the given index from the array.\n+     *\n+     * @param instance a reference to the instance where the array is stored, cannot be {@code null}\n+     * @param index an index to remove, cannot be negative, or greater than or equal to the number of occupied slots\n+     * @return the element that was removed, can be {@code null} if the element at the given index was {@code null}\n+     * @throws NullPointerException when the given instance was {@code null}\n+     * @throws IndexOutOfBoundsException when the given index was out of range\n+     *\/\n+    public E remove(I instance, int index) {\n+        E[] array = getArray(instance);\n+        int occupiedSlots = getOccupiedSlots(instance);\n+\n+        Objects.checkIndex(index, occupiedSlots--);\n+\n+        E oldElement = array[index];\n+        int newSize = calculateOptimalSize(array.length, occupiedSlots);\n+\n+        assert newSize <= array.length : newSize + \" <= \" + array.length;\n+\n+        setOccupiedSlots(instance, occupiedSlots);\n+\n+        if (newSize == array.length) {\n+            if (index < occupiedSlots) {\n+                System.arraycopy(array, index + 1, array, index, occupiedSlots - index);\n+            }\n+\n+            array[occupiedSlots] = null;\n+        }\n+        else if (newSize == 0) {\n+            setArray(instance, null);\n+        }\n+        else {\n+            E[] newArray = allocateArray(newSize);\n+\n+            System.arraycopy(array, 0, newArray, 0, index);\n+\n+            if (index < occupiedSlots) {\n+                System.arraycopy(array, index + 1, newArray, index, occupiedSlots - index);\n+            }\n+\n+            setArray(instance, newArray);\n+        }\n+\n+        return oldElement;\n+    }\n+\n+    \/**\n+     * Returns the element at the given index from the array.<p>\n+     *\n+     * This method does not modify the array fields.\n+     *\n+     * @param instance a reference to the instance where the array is stored, cannot be {@code null}\n+     * @param index an index, cannot be negative, or greater than or equal to the number of occupied slots\n+     * @return the element at the given index, can be {@code null} if the element at the given index was {@code null}\n+     * @throws NullPointerException when the given instance was {@code null}\n+     * @throws IndexOutOfBoundsException when the given index was out of range\n+     *\/\n+    public E get(I instance, int index) {\n+        E[] array = getArray(instance);\n+        int occupiedSlots = getOccupiedSlots(instance);\n+\n+        Objects.checkIndex(index, occupiedSlots);\n+\n+        return array[index];\n+    }\n+\n+    \/**\n+     * Sets the element at the given index to the given element.<p>\n+     *\n+     * This method does not modify the array fields.\n+     *\n+     * @param instance a reference to the instance where the array is stored, cannot be {@code null}\n+     * @param index an index to set, cannot be negative, or greater than or equal to the number of occupied slots\n+     * @param element an element to set, can be {@code null}\n+     * @return the element that was previously at the given index, can be {@code null} if the element at the given index was {@code null}\n+     * @throws NullPointerException when the given instance was {@code null}\n+     * @throws IndexOutOfBoundsException when the given index was out of range\n+     *\/\n+    public E set(I instance, int index, E element) {\n+        E[] array = getArray(instance);\n+        int occupiedSlots = getOccupiedSlots(instance);\n+\n+        Objects.checkIndex(index, occupiedSlots);\n+\n+        E oldElement = array[index];\n+        array[index] = element;\n+\n+        return oldElement;\n+    }\n+\n+    \/**\n+     * Removes all of the elements of the array provided by the given instance\n+     * that satisfy the given predicate. If the predicate throws errors or\n+     * exceptions, these are relayed to the caller, and the state of the array\n+     * will be undefined.\n+     *\n+     * @param instance a reference to the instance where the array is stored, cannot be {@code null}\n+     * @param filter a predicate which returns {@code true} for elements to be removed\n+     * @return {@code true} if any elements were removed\n+     * @throws NullPointerException if the specified filter is null\n+     *\/\n+    public boolean removeIf(I instance, Predicate<E> filter) {\n+        Objects.requireNonNull(filter);\n+        E[] array = getArray(instance);\n+\n+        if (array == null) {\n+            return false;\n+        }\n+\n+        int occupiedSlots = getOccupiedSlots(instance);\n+        int shift = 0;\n+\n+        for (int i = 0; i < occupiedSlots; i++) {\n+            if (filter.test(array[i])) {\n+                shift++;\n+            }\n+            else if (shift > 0) {\n+                array[i - shift] = array[i];\n+                array[i] = null;\n+            }\n+        }\n+\n+        if (shift == 0) {\n+            return false;\n+        }\n+\n+        int newLength = calculateOptimalSize(array.length, occupiedSlots - shift);\n+\n+        if (newLength == 0) {\n+            setArray(instance, null);\n+        }\n+        else if (newLength != array.length) {\n+            array = Arrays.copyOf(array, newLength);\n+\n+            setArray(instance, array);\n+        }\n+\n+        setOccupiedSlots(instance, occupiedSlots - shift);\n+\n+        return true;\n+    }\n+\n+    \/**\n+     * Called when all slots in the array are occupied and the\n+     * array would need to be grown. If compaction was possible,\n+     * return the amount of slots reclaimed. The freed up slots\n+     * must be the last slots in the array after this call\n+     * completes.<p>\n+     *\n+     * Note: it is not allowed to change the array fields during this call;\n+     * doing so will result in undefined behavior. Only the array's content\n+     * may be changed.<p>\n+     *\n+     * By default, no compaction takes place and this method returns\n+     * 0 to indicate no slots were reclaimed.<p>\n+     *\n+     * @param instance a reference to the instance where the array is stored, cannot be {@code null}\n+     * @param array an array to compact, never {@code null}\n+     * @return the number of slots reclaimed, never negative\n+     *\/\n+    protected int compact(I instance, E[] array) {\n+        return 0;  \/\/ no compaction took place\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private E[] allocateArray(int size) {\n+        return (E[]) Array.newInstance(elementType, size);\n+    }\n+\n+    private static int calculateOptimalSize(int size, int needed) {\n+\n+        \/*\n+         * Keeps the array in an optimal range. The current size\n+         * is used to calculate the bottom end of the range.\n+         *\n+         * If needed is within that range, the size returned is\n+         * the same as the current size, otherwise a new size is\n+         * suggested.\n+         *\n+         * When the minimum size of the array is 3 (MINIMUM_SIZE),\n+         * then the resizing algorithm used here always uses specific\n+         * sizes: 3, 7, 13, 22, 36, etc...\n+         *\n+         * When the maximum size is exceeded, the next larger size\n+         * which would fit needed is returned. When the amount needed\n+         * is smaller than or equal to the middle point between the\n+         * previous smaller size and its previous smaller size, then\n+         * the next smaller size which would fit needed is returned.\n+         *\n+         * This makes the ranges: [1..3], [2..7], [6..13], [11..22], [18..36], [30..57]\n+         *\n+         * The overlap is intended to avoid resizing too often.\n+         *\/\n+\n+        if (needed == 0) {\n+            return 0;\n+        }\n+\n+        int mid = decrease(size);\n+        int min = decrease(mid);\n+        int max = size;\n+\n+        while (needed <= (min + mid) \/ 2) {\n+            max = mid;\n+            mid = min;\n+            min = decrease(min);\n+        }\n+\n+        while (needed > max) {\n+            max = increase(max);\n+        }\n+\n+        return max;\n+    }\n+\n+    \/\/ note: must be the exact inverse of increase, so the array sizes used\n+    \/\/ are always the same values.\n+    private static int decrease(int size) {\n+        return (int)(((size - MINIMUM_SIZE) * 2L + (MINIMUM_SIZE - 1)) \/ 3);\n+    }\n+\n+    private static int increase(int size) {\n+        return (int)(size * 3L \/ 2 + MINIMUM_SIZE);\n+    }\n+}\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ArrayManager.java","additions":391,"deletions":0,"binary":false,"changes":391,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.binding;\n+\n+import java.util.Objects;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+\/**\n+ * Extension of {@link ListenerListBase}, which allows an {@link ObservableValue}\n+ * and its old value to notify all contained listeners with a depth first approach.\n+ *\n+ * @param <T> the type of the values the observable provides\n+ *\/\n+public class ListenerList<T> extends ListenerListBase {\n+\n+    \/**\n+     * Indicates a nested notification was aborted early because the new value\n+     * was modified during the loop to equal the old value. This means that not\n+     * all intended listeners (up to the maximum set by the higher level loop)\n+     * were called and so there may be confusion as to the current value is now\n+     * for some listeners.\n+     *\n+     * An abort may indicate a problem with multiple listeners changing values\n+     * that are not converging to a mutually agreed value.\n+     *\/\n+    private static final int NESTED_NOTIFICATION_ABORTED = -2;\n+\n+    \/**\n+     * Indicates a nested notification completed normally. After a nested\n+     * notification (aborted or not), the current value is re-read so listeners\n+     * not notified yet at the current level receive the newly updated current\n+     * value.\n+     *\/\n+    private static final int NESTED_NOTIFICATION_COMPLETED = -1;\n+\n+    \/**\n+     * This field is only used during notifications, and only relevant\n+     * when nested notifications occur. It is used for communicating\n+     * information between the different nesting levels. To deeper\n+     * nesting levels it contains the number of listeners that have\n+     * been notified in higher level loops, while deeper nesting levels\n+     * communicate to higher level loops whether a nested notification\n+     * actually occurred if it completed normally or was aborted early.<p>\n+     *\n+     * When its value is zero or positive, it indicates the number of\n+     * listeners notified in a higher level loop (minus one), while the constants\n+     * {@link #NESTED_NOTIFICATION_ABORTED} and {@link #NESTED_NOTIFICATION_COMPLETED}\n+     * indicate to a higher level loop that a nested notification occurred,\n+     * requiring, for example, a refresh of the current value and a new equals\n+     * check.\n+     *\/\n+    private int progress;\n+\n+    \/**\n+     * Creates a new instance with two listeners.\n+     *\n+     * @param listener1 a listener, cannot be {@code null}\n+     * @param listener2 a listener, cannot be {@code null}\n+     * @throws NullPointerException when any parameter is {@code null}\n+     *\/\n+    public ListenerList(Object listener1, Object listener2) {\n+        super(listener1, listener2);\n+    }\n+\n+    \/**\n+     * Notifies all listeners using the given observable value as source.\n+     *\n+     * @param observableValue an {@link ObservableValue}, cannot be {@code null}\n+     * @param oldValue the value held by the observable before it was changed, can be {@code null}\n+     * @return {@code true} if the listener list is not locked, and it was modified during\n+     *     notification otherwise {@code false}\n+     *\/\n+    public boolean notifyListeners(ObservableValue<? extends T> observableValue, T oldValue) {\n+        boolean wasLocked = isLocked();\n+\n+        if (!wasLocked) {\n+            lock();\n+        }\n+\n+        int initialProgress = progress;  \/\/ save as it will be modified soon\n+        int invalidationListenersSize = invalidationListenersSize();\n+        int maxInvalidations = wasLocked ? Math.min(initialProgress + 1, invalidationListenersSize) : invalidationListenersSize;\n+\n+        for (int i = 0; i < maxInvalidations; i++) {\n+            InvalidationListener listener = getInvalidationListener(i);\n+\n+            \/\/ skip if this listener was removed during a notification:\n+            if (listener == null) {\n+                continue;\n+            }\n+\n+            \/\/ communicate to a lower level loop (if triggered) how many listeners were notified so far:\n+            progress = i;\n+\n+            \/\/ call invalidation listener (and perhaps a nested notification):\n+            callInvalidationListener(observableValue, listener);\n+        }\n+\n+        int changeListenersSize = changeListenersSize();\n+        int maxChanges = wasLocked ? Math.min(initialProgress + 1 - invalidationListenersSize, changeListenersSize) : changeListenersSize;\n+\n+        T newValue = null;\n+\n+        progress = NESTED_NOTIFICATION_COMPLETED;  \/\/ reset progress to ensure latest value is queried at least once\n+\n+        for (int i = 0; i < maxChanges; i++) {\n+            ChangeListener<T> listener = getChangeListener(i);\n+\n+            \/\/ skip if this listener was removed during a notification:\n+            if (listener == null) {\n+                continue;\n+            }\n+\n+            \/\/ only get the latest value if this is the first loop or a nested notification occurred\n+            if (progress < 0) {\n+                newValue = observableValue.getValue();\n+\n+                valueObtained(newValue);\n+\n+                if (Objects.equals(newValue, oldValue)) {\n+                    progress = NESTED_NOTIFICATION_ABORTED;  \/\/ Indicate an early exit before notifying all listeners intended at this level\n+\n+                    return wasLocked ? false : unlock();\n+                }\n+            }\n+\n+            \/\/ communicate to a lower level loop (if triggered) how many listeners were notified so far:\n+            progress = i + invalidationListenersSize;\n+\n+            \/\/ call change listener (and perhaps a nested notification updating progress field):\n+            callChangeListener(observableValue, listener, oldValue, newValue);\n+\n+            if (progress == NESTED_NOTIFICATION_ABORTED) {\n+\n+                \/*\n+                 * Non-convergence detected: The listener just notified above of value X\n+                 * triggered a change to Y. The nested notification loop informing earlier\n+                 * listeners of Y was aborted because another listener changed the value\n+                 * back to X.\n+                 *\n+                 * Since listeners are only called when the old value is the last provided new\n+                 * value, and not when old == new, the listener that forced Y may incorrectly\n+                 * assume the value is still Y, leading to potential inconsistencies.\n+                 * Repeated changes between X and Y would normally cause a StackOverflowError.\n+                 * This conflicting listener behavior will be reported to the user:\n+                 *\/\n+\n+                throw new StackOverflowError(\"non-converging value detected in value modifying listeners on \" + observableValue + \"; original value was: \" + oldValue);\n+            }\n+        }\n+\n+        \/\/ communicate to a higher level loop that a nested notification completed (if\n+        \/\/ there is a higher loop):\n+        progress = NESTED_NOTIFICATION_COMPLETED;\n+\n+        return wasLocked ? false : unlock();\n+    }\n+\n+    \/**\n+     * Called during notifications when a new value was obtained from the\n+     * involved {@link ObservableValue}.<p>\n+     *\n+     * This is useful when this value needs to be kept track of.\n+     *\n+     * @param value the value that was obtained, can be {@code null}\n+     *\/\n+    protected void valueObtained(T value) {\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ListenerList.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,456 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.binding;\n+\n+import java.util.Objects;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.WeakListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+\/**\n+ * Manages a mix of invalidation and change listeners, which can be locked in\n+ * place for iteration while allowing modifications to take place.<p>\n+ *\n+ * While locked, listeners that were removed are set to {@code null}, and listeners\n+ * that were added are tracked separately. While locked, the size methods do not reflect\n+ * any modifications made, and so care must be taken to skip {@code null}s when getting a\n+ * listener by index.<p>\n+ *\n+ * While unlocked, the size methods always accurately reflect the actual number of\n+ * listeners in the list, and {@code null} is never returned when getting a listener by\n+ * index.<p>\n+ *\n+ * This class supports {@link WeakListener}s, and removes any garbage collected\n+ * listeners at a time of its choosing.\n+ *\/\n+public abstract class ListenerListBase {\n+\n+    \/**\n+     * This a variant of {@link ArrayManager} with an implemented {@link #compact(ListenerListBase, T[])}\n+     * method. The compaction is only allowed while its associated {@link ListenerListBase} is unlocked.<p>\n+     *\n+     * This handles compacting elements that are {@code null}, as well as elements that implement\n+     * {@link WeakListener} that were garbage collected in the mean time.\n+     *\n+     * @param <T> the element type\n+     *\/\n+    private static abstract class CompactingArrayManager<T> extends ArrayManager<ListenerListBase, T> {\n+\n+        CompactingArrayManager(Class<T> elementType) {\n+            super(elementType);\n+        }\n+\n+        @Override\n+        protected int compact(ListenerListBase instance, T[] array) {\n+            if (instance.isLocked()) {\n+                return 0;\n+            }\n+\n+            int shift = 0;\n+\n+            for (int i = 0; i < array.length; i++) {\n+                T element = array[i];\n+\n+                if (element == null || (element instanceof WeakListener wl && wl.wasGarbageCollected())) {\n+                    shift++;\n+                    array[i] = null;\n+                    continue;\n+                }\n+\n+                if (shift > 0) {\n+                    array[i - shift] = element;\n+                    array[i] = null;\n+                }\n+            }\n+\n+            return shift;\n+        }\n+    }\n+\n+    private static final ArrayManager<ListenerListBase, InvalidationListener> INVALIDATION_LISTENERS = new CompactingArrayManager<>(InvalidationListener.class) {\n+        @Override\n+        protected InvalidationListener[] getArray(ListenerListBase instance) {\n+            return instance.invalidationListeners;\n+        }\n+\n+        @Override\n+        protected void setArray(ListenerListBase instance, InvalidationListener[] array) {\n+            instance.invalidationListeners = array;\n+        }\n+\n+        @Override\n+        protected int getOccupiedSlots(ListenerListBase instance) {\n+            return instance.invalidationListenersCount;\n+        }\n+\n+        @Override\n+        protected void setOccupiedSlots(ListenerListBase instance, int occupiedSlots) {\n+            instance.invalidationListenersCount = occupiedSlots;\n+        }\n+    };\n+\n+    private static final ArrayManager<ListenerListBase, Object> CHANGE_LISTENERS = new CompactingArrayManager<>(Object.class) {\n+        @Override\n+        protected Object[] getArray(ListenerListBase instance) {\n+            return instance.changeListeners;\n+        }\n+\n+        @Override\n+        protected void setArray(ListenerListBase instance, Object[] array) {\n+            instance.changeListeners = array;\n+        }\n+\n+        @Override\n+        protected int getOccupiedSlots(ListenerListBase instance) {\n+            return instance.changeListenersCount;\n+        }\n+\n+        @Override\n+        protected void setOccupiedSlots(ListenerListBase instance, int occupiedSlots) {\n+            instance.changeListenersCount = occupiedSlots;\n+        }\n+    };\n+\n+    \/*\n+     * The following four fields are used for tracking invalidation and change listeners. When the\n+     * list is unlocked, these arrays hold what you'd expect (InvalidationListeners and ChangeListeners\n+     * respectively).\n+     *\n+     * While the list is locked, any new listeners (regardless what kind) are always added to the\n+     * change listener array first, in order to not disturb the indices of any listeners that existed\n+     * before (the indices remain stable). Any added listeners are invisible, and cannot be obtained\n+     * via the public methods of this class (the sizes of the lists remain the same while locked, and\n+     * the result of accessing an index of an added listener which would exceed the size returned is\n+     * undefined).\n+     *\n+     * Similarly, while the list is locked, any removed listeners do not alter the indices of this\n+     * list; instead removed listeners are set to null.\n+     *\n+     * Only after unlocking are any InvalidationListeners that do not belong in the change listener\n+     * array moved to the invalidation listener array, and nulled elements are removed.\n+     *\/\n+\n+    private InvalidationListener[] invalidationListeners;\n+    private int invalidationListenersCount;\n+    private Object[] changeListeners;\n+    private int changeListenersCount;\n+\n+    \/**\n+     * Indicates whether the list is locked, and if so, what the total size\n+     * of the two lists was at the time of locking. A non-negative value\n+     * indicates the list is locked, while -1 indicates the list is\n+     * not locked.\n+     *\/\n+    private int lockedSize = -1;\n+\n+    \/**\n+     * Indicates whether a list currently contains any {@code null}s, and\n+     * how many. This is always zero when unlocked.\n+     *\/\n+    private int nulledListenerCount;\n+\n+    \/**\n+     * Creates a new instance with two listeners.\n+     *\n+     * @param listener1 a listener, cannot be {@code null}\n+     * @param listener2 a listener, cannot be {@code null}\n+     * @throws NullPointerException when any parameter is {@code null}\n+     *\/\n+    public ListenerListBase(Object listener1, Object listener2) {\n+        Objects.requireNonNull(listener1);\n+        Objects.requireNonNull(listener2);\n+\n+        if (listener1 instanceof InvalidationListener il) {\n+            INVALIDATION_LISTENERS.add(this, il);\n+        }\n+        else {\n+            CHANGE_LISTENERS.add(this, listener1);\n+        }\n+\n+        if (listener2 instanceof InvalidationListener il) {\n+            INVALIDATION_LISTENERS.add(this, il);\n+        }\n+        else {\n+            CHANGE_LISTENERS.add(this, listener2);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the total number of listeners in this list. This accurately\n+     * reflects added and removed listeners even while the list is locked.\n+     *\n+     * @return the total number of listeners in this list, never negative\n+     *\/\n+    public final int totalListeners() {\n+        return invalidationListenersCount + changeListenersCount - nulledListenerCount;\n+    }\n+\n+    \/**\n+     * Returns the number of invalidation listeners. While the list is\n+     * locked this may include some listeners that were set to {@code null}.\n+     *\n+     * @return the number of invalidation listeners, never negative\n+     *\/\n+    public final int invalidationListenersSize() {\n+        return invalidationListenersCount;\n+    }\n+\n+    \/**\n+     * Returns the number of change listeners. While the list is\n+     * locked this may include some listeners that were set to {@code null}.\n+     *\n+     * @return the number of change listeners, never negative\n+     *\/\n+    public final int changeListenersSize() {\n+        return isLocked() ? lockedSize - invalidationListenersCount : changeListenersCount;\n+    }\n+\n+    \/**\n+     * Gets the {@link InvalidationListener} at the given index. This can be {@code null} if the\n+     * list is locked and the listener was removed in the mean time.<p>\n+     *\n+     * Note: the behavior when calling this method with an index outside the valid range is\n+     * <b>undefined<\/b>!\n+     *\n+     * @param index an index, cannot be negative and must be less than {@link #invalidationListenersSize()}\n+     * @return the listener at the given index, or {@code null}\n+     *\/\n+    public final InvalidationListener getInvalidationListener(int index) {\n+        assertInvalidationListenerIndex(index);\n+\n+        return invalidationListeners[index];\n+    }\n+\n+    \/**\n+     * Gets the {@link ChangeListener} at the given index. This can be {@code null} if the\n+     * list is locked and the listener was removed in the mean time.<p>\n+     *\n+     * Note: the behavior when calling this method with an index outside the valid range is\n+     * <b>undefined<\/b>!\n+     *\n+     * @param index an index, cannot be negative and must be less than {@link #changeListenersSize()}\n+     * @return the listener at the given index, or {@code null}\n+     *\/\n+    public final <T> ChangeListener<T> getChangeListener(int index) {\n+        assertChangeListenerIndex(index);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ChangeListener<T> cl = (ChangeListener<T>) changeListeners[index];\n+\n+        return cl;\n+    }\n+\n+    \/**\n+     * Adds a listener to this list. If the list is locked, this listener won't show\n+     * up until unlocked, nor will the lists size change.\n+     *\n+     * @param listener a listener, cannot be {@code null}\n+     *\/\n+    public final void add(Object listener) {\n+        Objects.requireNonNull(listener);\n+\n+        if (isLocked() || listener instanceof ChangeListener) {\n+            CHANGE_LISTENERS.add(this, listener);  \/\/ even invalidation listeners go into this list when locked!\n+        }\n+        else {\n+            INVALIDATION_LISTENERS.add(this, (InvalidationListener) listener);\n+        }\n+    }\n+\n+    \/**\n+     * Removes a listener from this list. If the list is locked, the removed\n+     * listener is set to {@code null}. When iterating, {@code null}s must be\n+     * skipped.\n+     *\n+     * @param listener a listener to remove, cannot be {@code null}\n+     *\/\n+    public final void remove(Object listener) {\n+        Objects.requireNonNull(listener);\n+\n+        int index = listener instanceof InvalidationListener il ? INVALIDATION_LISTENERS.indexOf(this, il) : -1;\n+\n+        if (index >= 0) {\n+            if (isLocked()) {\n+                INVALIDATION_LISTENERS.set(this, index, null);\n+\n+                nulledListenerCount++;\n+            }\n+            else {\n+                INVALIDATION_LISTENERS.remove(this, index);\n+            }\n+        }\n+        else {\n+            index = CHANGE_LISTENERS.indexOf(this, listener);\n+\n+            if (index >= 0) {\n+                if (!isLocked() || index >= lockedSize - invalidationListenersCount) {\n+                    CHANGE_LISTENERS.remove(this, index);  \/\/ not locked, or was added during lock, so can just remove directly\n+                }\n+                else {\n+                    CHANGE_LISTENERS.set(this, index, null);\n+\n+                    nulledListenerCount++;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Unlocks this listener list, making any listeners available that were added\n+     * while locked, and removes any empty slots from listeners that were removed while\n+     * locked.\n+     *\n+     * @return {@code true} if the list was modified while it was locked, otherwise {@code false}\n+     *\/\n+    protected final boolean unlock() {\n+        assertLocked();\n+\n+        boolean containsNulls = nulledListenerCount > 0;\n+\n+        \/\/ if there were no nulls and no additions...\n+        if (!containsNulls && invalidationListenersCount + changeListenersCount <= lockedSize) {\n+            lockedSize = -1;\n+\n+            return false;\n+        }\n+\n+        for (int i = lockedSize - invalidationListenersCount; i < changeListenersCount; i++) {\n+            Object listener = CHANGE_LISTENERS.get(this, i);\n+\n+            if (listener instanceof InvalidationListener il) {\n+                INVALIDATION_LISTENERS.add(this, il);\n+                CHANGE_LISTENERS.set(this, i, null);\n+\n+                containsNulls = true;\n+            }\n+        }\n+\n+        if (containsNulls) {\n+\n+            \/*\n+             * Note: only nulls are removed here. Expired weak listeners are not removed\n+             * as this would mean the listener count could change unexpectedly at the end\n+             * of a notification without going through an addListener\/removeListener call\n+             * which may be overridden to track listeners. A scenario that would be troubling\n+             * is:\n+             *\n+             * - A notification starts\n+             * - An unrelated listener removes itself while list is locked (which will trigger this\n+             *   clean-up code later); this goes through the normal add\/removeListener channel\n+             * - The notification ends\n+             * - While unlocking, a weak listener is determined to be expired\n+             *   - Removing this weak listener would not go through proper channels and thus\n+             *     code that overrides add\/removeListener would be unaware of the change\n+             *\n+             * Therefore, weak listeners will only be actively removed when another listener\n+             * is being added or removed as the caller will then be expecting a change in the\n+             * listener count, albeit higher than just the one listener being added or removed.\n+             * Callers already should be aware that removing a listener may not change the count\n+             * (if the listener didn't exist), so manually checking the new count after such a\n+             * call must be done already.\n+             *\/\n+\n+            INVALIDATION_LISTENERS.removeIf(this, Objects::isNull);\n+            CHANGE_LISTENERS.removeIf(this, Objects::isNull);\n+\n+            nulledListenerCount = 0;\n+        }\n+\n+        lockedSize = -1;\n+\n+        return true;\n+    }\n+\n+    \/**\n+     * Locks this list.\n+     *\/\n+    protected final void lock() {\n+        assertNotLocked();\n+\n+        this.lockedSize = invalidationListenersCount + changeListenersCount;\n+    }\n+\n+    \/**\n+     * Checks whether this list is locked.\n+     *\n+     * @return {@code true} if locked, otherwise {@code false}\n+     *\/\n+    protected final boolean isLocked() {\n+        return lockedSize >= 0;\n+    }\n+\n+    \/**\n+     * Checks whether this list has any change listeners. Note: this does not\n+     * update while locked.\n+     *\n+     * @return {@code true} if there were change listeners, otherwise {@code false}\n+     *\/\n+    public final boolean hasChangeListeners() {\n+        return totalSize() > invalidationListenersCount;\n+    }\n+\n+    private int totalSize() {\n+        return isLocked() ? lockedSize : invalidationListenersCount + changeListenersCount;\n+    }\n+\n+    private void assertInvalidationListenerIndex(int index) {\n+        assert index < invalidationListenersCount : index + \" >= \" + invalidationListenersCount + \", results would be undefined\";\n+    }\n+\n+    private void assertChangeListenerIndex(int index) {\n+        assert index < (isLocked() ? lockedSize - invalidationListenersCount : changeListenersCount)\n+            : index + \" >= \" + (isLocked() ? lockedSize - invalidationListenersCount : changeListenersCount) + \", results would be undefined\";\n+    }\n+\n+    private void assertLocked() {\n+        assert isLocked() : \"wasn't locked\";\n+    }\n+\n+    private void assertNotLocked() {\n+        assert !isLocked() : \"already locked\";\n+        assert nulledListenerCount == 0 : \"nulledListenerCount must be zero when not locked\";\n+    }\n+\n+    static final void callInvalidationListener(ObservableValue<?> instance, InvalidationListener listener) {\n+        try {\n+            listener.invalidated(instance);\n+        }\n+        catch (Exception e) {\n+            Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+        }\n+    }\n+\n+    static final <T> void callChangeListener(ObservableValue<? extends T> instance, ChangeListener<T> changeListener, T oldValue, T newValue) {\n+        try {\n+            changeListener.changed(instance, oldValue, newValue);\n+        }\n+        catch (Exception e) {\n+            Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ListenerListBase.java","additions":456,"deletions":0,"binary":false,"changes":456,"status":"added"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.binding;\n+\n+import java.util.Objects;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+\/**\n+ * Manages a single data field of type {@link Object} to store zero,\n+ * one or more {@link InvalidationListener}s and {@link ChangeListener}s. This\n+ * helps to minimize the storage requirements for keeping track of these\n+ * listeners.<p>\n+ *\n+ * When there are no listeners, the field will be {@code null}. When there is\n+ * only a single invalidation listener or change listener, the field will contain\n+ * only that listener. When there is more than one listener, the field will hold\n+ * a {@link ListenerList}. It is recommended to never inspect this field directly\n+ * but always use this manager to interact with it.\n+ *\n+ * @param <T> the type of the values\n+ * @param <I> the type of the instance providing listener data\n+ *\/\n+public abstract class ListenerManager<T, I extends ObservableValue<? extends T>> extends ListenerManagerBase<T, I> {\n+\n+    \/**\n+     * Adds an invalidation listener.\n+     *\n+     * @param instance the instance to which the listeners belong, cannot be {@code null}\n+     * @param listener a listener to add, cannot be {@code null}\n+     * @throws NullPointerException when any argument is {@code null}\n+     *\/\n+    public void addListener(I instance, InvalidationListener listener) {\n+        Objects.requireNonNull(listener);\n+\n+        instance.getValue();  \/\/ always trigger validation when adding an invalidation listener (required by tests)\n+\n+        switch (getData(instance)) {\n+            case null -> setData(instance, listener);\n+            case ListenerList<?> list -> list.add(listener);\n+            case Object data -> setData(instance, new ListenerList<>(data, listener));\n+        }\n+    }\n+\n+    \/**\n+     * Adds a change listener.\n+     *\n+     * @param instance the instance to which the listeners belong, cannot be {@code null}\n+     * @param listener a listener to add, cannot be {@code null}\n+     * @throws NullPointerException when any argument is {@code null}\n+     *\/\n+    public void addListener(I instance, ChangeListener<? super T> listener) {\n+        Objects.requireNonNull(listener);\n+\n+        instance.getValue();  \/\/ always trigger validation when adding a change listener (required by tests)\n+\n+        switch (getData(instance)) {\n+            case null -> setData(instance, listener);\n+            case ListenerList<?> list -> list.add(listener);\n+            case Object data -> setData(instance, new ListenerList<>(data, listener));\n+        }\n+    }\n+\n+    \/**\n+     * Removes a listener.\n+     *\n+     * @param instance the instance to which the listeners belong, cannot be {@code null}\n+     * @param listener a listener to remove, cannot be {@code null}\n+     * @return {@code true} if there are no more listeners registered after this call completes, otherwise {@code false}\n+     * @throws NullPointerException when any argument is {@code null}\n+     *\/\n+    public boolean removeListener(I instance, Object listener) {\n+        Objects.requireNonNull(listener);\n+\n+        Object data = getData(instance);\n+\n+        if (data == null) {\n+            return true;\n+        }\n+\n+        if (data.equals(listener)) {\n+            setData(instance, null);\n+\n+            return true;\n+        }\n+\n+        if (data instanceof ListenerList<?> list) {\n+            list.remove(listener);\n+\n+            updateAfterRemoval(instance, list);\n+\n+            return list.totalListeners() == 0;\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Notifies the listeners managed in the given instance.\n+     *\n+     * @param instance the instance to which the listeners belong, cannot be {@code null}\n+     * @param oldValue the previous value before this change occurred, can be {@code null}\n+     * @param listenerData the listener data associated with the instance,\n+     *   can be {@code null} which means there are no listeners to notify\n+     * @throws NullPointerException when {@code instance} is {@code null}\n+     *\/\n+    public void fireValueChanged(I instance, T oldValue, Object listenerData) {\n+        if (listenerData instanceof ListenerList) {\n+            @SuppressWarnings(\"unchecked\")\n+            ListenerList<T> list = (ListenerList<T>)listenerData;\n+\n+            callMultipleListeners(instance, list, oldValue);\n+        }\n+        else if (listenerData instanceof InvalidationListener il) {\n+            ListenerListBase.callInvalidationListener(instance, il);\n+        }\n+        else if (listenerData instanceof ChangeListener) {\n+            @SuppressWarnings(\"unchecked\")\n+            ChangeListener<T> cl = (ChangeListener<T>) listenerData;\n+            T newValue = instance.getValue();  \/\/ Required as an earlier listener may have changed the value, and current value is always needed\n+\n+            if (!Objects.equals(newValue, oldValue)) {\n+                ListenerListBase.callChangeListener(instance, cl, oldValue, newValue);\n+            }\n+        }\n+    }\n+\n+    private void callMultipleListeners(I instance, ListenerList<T> list, T oldValue) {\n+        boolean modified = list.notifyListeners(instance, oldValue);\n+\n+        if (modified) {  \/\/ if modified, compact the data field if possible\n+            updateAfterRemoval(instance, list);\n+        }\n+    }\n+\n+    private void updateAfterRemoval(I instance, ListenerList<?> list) {\n+        int invalidationListenersSize = list.invalidationListenersSize();\n+        int changeListenersSize = list.changeListenersSize();\n+\n+        if (invalidationListenersSize + changeListenersSize <= 1) {\n+            if (invalidationListenersSize == 1) {\n+                setData(instance, list.getInvalidationListener(0));\n+            }\n+            else if (changeListenersSize == 1) {\n+                setData(instance, list.getChangeListener(0));\n+            }\n+            else {\n+                setData(instance, null);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ListenerManager.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.binding;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+\/**\n+ * Base class for managing a single data field of type {@link Object} to store zero,\n+ * one or more {@link InvalidationListener}s and {@link ChangeListener}s. This\n+ * helps to minimize the storage requirements for keeping track of these\n+ * listeners.\n+ *\n+ * @param <T> the type of the values\n+ * @param <I> the type of the instance providing listener data\n+ *\/\n+public abstract class ListenerManagerBase<T, I extends ObservableValue<? extends T>> {\n+\n+    \/**\n+     * Gets the listener data under management.\n+     *\n+     * @param instance the instance it is located in, cannot be {@code null}\n+     * @return the listener data, can be {@code null}\n+     * @throws NullPointerException when {@code instance} is {@code null}\n+     *\/\n+    protected abstract Object getData(I instance);\n+\n+    \/**\n+     * Sets the listener data under management.\n+     *\n+     * @param instance the instance it is located in, cannot be {@code null}\n+     * @param data the data to set, can be {@code null}\n+     * @throws NullPointerException when {@code instance} is {@code null}\n+     *\/\n+    protected abstract void setData(I instance, Object data);\n+\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ListenerManagerBase.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.binding;\n+\n+import javafx.beans.value.ObservableValue;\n+\n+\/**\n+ * Extension of {@link ListenerList} which allows an {@link ObservableValue}\n+ * to notify all contained listeners with a depth first approach.<p>\n+ *\n+ * Note: this listener list stores the latest value for use as the old value when\n+ * notifying change listeners. It is recommended to use {@link ListenerList} if\n+ * the old value can be provided in some other way as it is more efficient.\n+ *\n+ * @param <T> the type of the values the observable provides\n+ *\/\n+public class OldValueCachingListenerList<T> extends ListenerList<T> {\n+\n+    private T latestValue;\n+\n+    \/**\n+     * Creates a new instance with two listeners.\n+     *\n+     * @param listener1 a listener, cannot be {@code null}\n+     * @param listener2 a listener, cannot be {@code null}\n+     * @throws NullPointerException when any parameter is {@code null}\n+     *\/\n+    public OldValueCachingListenerList(Object listener1, Object listener2) {\n+        super(listener1, listener2);\n+    }\n+\n+    \/**\n+     * Returns the latest value stored.\n+     *\n+     * @return the latest value stored, can be {@code null}\n+     *\/\n+    public final T getLatestValue() {\n+        return latestValue;\n+    }\n+\n+    \/**\n+     * Stores the latest value.\n+     *\n+     * @param value a value to store, can be {@code null}\n+     *\/\n+    public final void putLatestValue(T value) {\n+        this.latestValue = value;\n+    }\n+\n+    \/**\n+     * Notifies all listeners using the given observable value as source.\n+     *\n+     * @param observableValue an {@link ObservableValue}, cannot be {@code null}\n+     * @return {@code true} if the listener list is not locked, and it was modified during\n+     *     notification otherwise {@code false}\n+     *\/\n+    public boolean notifyListeners(ObservableValue<? extends T> observableValue) {\n+        return notifyListeners(observableValue, getLatestValue());\n+    }\n+\n+    @Override\n+    protected final void valueObtained(T value) {\n+        putLatestValue(value);\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/OldValueCachingListenerList.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.binding;\n+\n+import java.util.Objects;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+\/**\n+ * Manages a single data field of type {@link Object} to store zero,\n+ * one or more {@link InvalidationListener}s and {@link ChangeListener}s. This\n+ * helps to minimize the storage requirements for keeping track of these\n+ * listeners.<p>\n+ *\n+ * When there are no listeners, the field will be {@code null}. When there is\n+ * only a single invalidation listener, the field will contain only that\n+ * listener (change listeners are wrapped to track old value). When there is more\n+ * than one listener, the field will hold an {@link OldValueCachingListenerList}. It\n+ * is recommended to never inspect this field directly but always use this manager to\n+ * interact with it.<p>\n+ *\n+ * This is a variant of {@link ListenerManager} which caches the latest value for\n+ * cases where the latest value prior to the change (ie. the old value) cannot be\n+ * provided by the caller itself. This means that a single {@link ChangeListener}\n+ * will require a wrapper to track this value, and that an extra field is needed\n+ * within listener list. If possible use {@link ListenerManager}, as it has less\n+ * storage requirements and is faster.\n+ *\n+ * @param <T> the type of the values\n+ * @param <I> the type of the instance providing listener data\n+ *\/\n+public abstract class OldValueCachingListenerManager<T, I extends ObservableValue<? extends T>> extends ListenerManagerBase<T, I> {\n+\n+    \/**\n+     * Adds an invalidation listener.\n+     *\n+     * @param instance the instance to which the listeners belong, cannot be {@code null}\n+     * @param listener a listener to add, cannot be {@code null}\n+     * @throws NullPointerException when any argument is {@code null}\n+     *\/\n+    public void addListener(I instance, InvalidationListener listener) {\n+        Objects.requireNonNull(listener);\n+\n+        instance.getValue();  \/\/ always trigger validation when adding an invalidation listener (required by tests)\n+\n+        switch (getData(instance)) {\n+            case null -> setData(instance, listener);\n+            case OldValueCachingListenerList<?> list -> list.add(listener);\n+            case ChangeListenerWrapper<?> wrapper -> {\n+                OldValueCachingListenerList<Object> list = new OldValueCachingListenerList<>(wrapper.listener, listener);\n+\n+                list.putLatestValue(wrapper.latestValue);\n+                setData(instance, list);\n+            }\n+            case Object data -> setData(instance, new OldValueCachingListenerList<>(data, listener));\n+        }\n+    }\n+\n+    \/**\n+     * Adds a change listener.\n+     *\n+     * @param instance the instance to which the listeners belong, cannot be {@code null}\n+     * @param listener a listener to add, cannot be {@code null}\n+     * @throws NullPointerException when any argument is {@code null}\n+     *\/\n+    public void addListener(I instance, ChangeListener<? super T> listener) {\n+        Objects.requireNonNull(listener);\n+\n+        switch (getData(instance)) {\n+            case null -> setData(instance, new ChangeListenerWrapper<>(listener, instance.getValue()));\n+            case OldValueCachingListenerList<?> genericList -> {\n+                @SuppressWarnings(\"unchecked\")\n+                OldValueCachingListenerList<T> list = (OldValueCachingListenerList<T>) genericList;\n+\n+                if (!list.hasChangeListeners()) {\n+                    list.putLatestValue(instance.getValue());\n+                }\n+\n+                list.add(listener);\n+            }\n+            case ChangeListenerWrapper<?> wrapper -> {\n+                OldValueCachingListenerList<Object> list = new OldValueCachingListenerList<>(wrapper.listener, listener);\n+\n+                list.putLatestValue(wrapper.latestValue);\n+\n+                setData(instance, list);\n+            }\n+            case Object data -> {\n+                OldValueCachingListenerList<T> list = new OldValueCachingListenerList<>(data, listener);\n+\n+                list.putLatestValue(instance.getValue());\n+\n+                setData(instance, list);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Removes a listener.\n+     *\n+     * @param instance the instance to which the listeners belong, cannot be {@code null}\n+     * @param listener a listener to remove, cannot be {@code null}\n+     * @throws NullPointerException when any argument is {@code null}\n+     *\/\n+    public void removeListener(I instance, Object listener) {\n+        Objects.requireNonNull(listener);\n+\n+        Object data = getData(instance);\n+\n+        if (data == null || data.equals(listener) || (data instanceof ChangeListenerWrapper<?> wrapper && wrapper.listener.equals(listener))) {\n+            setData(instance, null);  \/\/ TODO not needed when already null\n+        }\n+        else if (data instanceof OldValueCachingListenerList) {\n+            @SuppressWarnings(\"unchecked\")\n+            OldValueCachingListenerList<T> list = (OldValueCachingListenerList<T>) data;\n+\n+            list.remove(listener);\n+\n+            updateAfterRemoval(instance, list);\n+        }\n+    }\n+\n+    \/**\n+     * Notifies the listeners managed in the given instance.<p>\n+     *\n+     * @param instance the instance to which the listeners belong, cannot be {@code null}\n+     * @param listenerData the listener data associated with the instance,\n+     *   can be {@code null} which means there are no listeners to notify\n+     * @throws NullPointerException when {@code instance} is {@code null}\n+     *\/\n+    public void fireValueChanged(I instance, Object listenerData) {\n+        if (listenerData instanceof OldValueCachingListenerList) {\n+            @SuppressWarnings(\"unchecked\")\n+            OldValueCachingListenerList<T> list = (OldValueCachingListenerList<T>) listenerData;\n+\n+            callMultipleListeners(instance, list);\n+        }\n+        else if (listenerData instanceof InvalidationListener il) {\n+            ListenerListBase.callInvalidationListener(instance, il);\n+        }\n+        else if (listenerData instanceof ChangeListenerWrapper) {\n+            @SuppressWarnings(\"unchecked\")\n+            ChangeListenerWrapper<T> clw = (ChangeListenerWrapper<T>) listenerData;\n+\n+            callWrappedChangeListener(instance, clw);\n+        }\n+    }\n+\n+    private void callMultipleListeners(I instance, OldValueCachingListenerList<T> list) {\n+        boolean modified = list.notifyListeners(instance);\n+\n+        if (modified) {  \/\/ if modified, compact the data field if possible\n+            updateAfterRemoval(instance, list);\n+        }\n+    }\n+\n+    private void callWrappedChangeListener(I instance, ChangeListenerWrapper<T> changeListenerWrapper) {\n+        T oldValue = changeListenerWrapper.getLatestValue();\n+        T newValue = instance.getValue();\n+\n+        \/\/ Latest value must be stored even if it was \"equals\", as it may be a different reference\n+        changeListenerWrapper.putLatestValue(newValue);\n+\n+        if (!Objects.equals(newValue, oldValue)) {\n+            ListenerListBase.callChangeListener(instance, changeListenerWrapper, oldValue, newValue);\n+        }\n+    }\n+\n+    private static class ChangeListenerWrapper<T> implements ChangeListener<T> {\n+\n+        private final ChangeListener<T> listener;\n+\n+        private T latestValue;\n+\n+        ChangeListenerWrapper(ChangeListener<T> listener, T latestValue) {\n+            this.listener = listener;\n+            this.latestValue = latestValue;\n+        }\n+\n+        T getLatestValue() {\n+            return latestValue;\n+        }\n+\n+        void putLatestValue(T value) {\n+            this.latestValue = value;\n+        }\n+\n+        @Override\n+        public void changed(ObservableValue<? extends T> observable, T oldValue, T newValue) {\n+            listener.changed(observable, oldValue, newValue);\n+        }\n+    }\n+\n+    private void updateAfterRemoval(I instance, OldValueCachingListenerList<T> list) {\n+        int invalidationListenersSize = list.invalidationListenersSize();\n+        int changeListenersSize = list.changeListenersSize();\n+\n+        if (invalidationListenersSize + changeListenersSize <= 1) {\n+            if (invalidationListenersSize == 1) {\n+                setData(instance, list.getInvalidationListener(0));\n+            }\n+            else if (changeListenersSize == 1) {\n+                setData(instance, new ChangeListenerWrapper<>(list.getChangeListener(0), list.getLatestValue()));\n+            }\n+            else {\n+                setData(instance, null);\n+            }\n+        }\n+        else if (!list.hasChangeListeners()) {\n+            list.putLatestValue(null);  \/\/ clear old value cache to avoid references\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/OldValueCachingListenerManager.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.ListenerManager;\n@@ -62,0 +62,12 @@\n+    private static final ListenerManager<Boolean, BooleanBinding> LISTENER_MANAGER = new ListenerManager<>() {\n+        @Override\n+        protected Object getData(BooleanBinding instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(BooleanBinding instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n@@ -78,1 +90,1 @@\n-    private ExpressionHelper<Boolean> helper = null;\n+    private Object listenerData;\n@@ -82,1 +94,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -87,1 +99,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -92,1 +104,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -97,1 +109,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -178,0 +190,2 @@\n+            boolean oldValue = value;\n+\n@@ -180,1 +194,2 @@\n-            ExpressionHelper.fireValueChangedEvent(helper);\n+\n+            LISTENER_MANAGER.fireValueChanged(this, oldValue, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/BooleanBinding.java","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.ListenerManager;\n@@ -114,0 +114,12 @@\n+    private static final ListenerManager<Number, DoubleBinding> LISTENER_MANAGER = new ListenerManager<>() {\n+        @Override\n+        protected Object getData(DoubleBinding instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(DoubleBinding instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n@@ -124,1 +136,1 @@\n-    private ExpressionHelper<Number> helper = null;\n+    private Object listenerData;\n@@ -134,1 +146,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -139,1 +151,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -144,1 +156,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -149,1 +161,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -230,0 +242,2 @@\n+            double oldValue = value;\n+\n@@ -232,1 +246,2 @@\n-            ExpressionHelper.fireValueChangedEvent(helper);\n+\n+            LISTENER_MANAGER.fireValueChanged(this, oldValue, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/DoubleBinding.java","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.ListenerManager;\n@@ -64,0 +64,12 @@\n+    private static final ListenerManager<Number, FloatBinding> LISTENER_MANAGER = new ListenerManager<>() {\n+        @Override\n+        protected Object getData(FloatBinding instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(FloatBinding instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n@@ -74,1 +86,1 @@\n-    private ExpressionHelper<Number> helper = null;\n+    private Object listenerData;\n@@ -84,1 +96,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -89,1 +101,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -94,1 +106,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -99,1 +111,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -178,0 +190,2 @@\n+            float oldValue = value;\n+\n@@ -180,1 +194,2 @@\n-            ExpressionHelper.fireValueChangedEvent(helper);\n+\n+            LISTENER_MANAGER.fireValueChanged(this, oldValue, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/FloatBinding.java","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.ListenerManager;\n@@ -64,0 +64,12 @@\n+    private static final ListenerManager<Number, IntegerBinding> LISTENER_MANAGER = new ListenerManager<>() {\n+        @Override\n+        protected Object getData(IntegerBinding instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(IntegerBinding instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n@@ -74,1 +86,1 @@\n-    private ExpressionHelper<Number> helper = null;\n+    private Object listenerData;\n@@ -84,1 +96,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -89,1 +101,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -94,1 +106,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -99,1 +111,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -180,0 +192,2 @@\n+            int oldValue = value;\n+\n@@ -182,1 +196,2 @@\n-            ExpressionHelper.fireValueChangedEvent(helper);\n+\n+            LISTENER_MANAGER.fireValueChanged(this, oldValue, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/IntegerBinding.java","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import com.sun.javafx.binding.BindingHelperObserver;\n+import com.sun.javafx.binding.ListenerManager;\n+\n@@ -34,3 +37,0 @@\n-import com.sun.javafx.binding.BindingHelperObserver;\n-import com.sun.javafx.binding.ExpressionHelper;\n-\n@@ -64,0 +64,12 @@\n+    private static final ListenerManager<Number, LongBinding> LISTENER_MANAGER = new ListenerManager<>() {\n+        @Override\n+        protected Object getData(LongBinding instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(LongBinding instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n@@ -74,1 +86,1 @@\n-    private ExpressionHelper<Number> helper = null;\n+    private Object listenerData;\n@@ -84,1 +96,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -89,1 +101,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -94,1 +106,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -99,1 +111,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -180,0 +192,2 @@\n+            long oldValue = value;\n+\n@@ -182,1 +196,2 @@\n-            ExpressionHelper.fireValueChangedEvent(helper);\n+\n+            LISTENER_MANAGER.fireValueChanged(this, oldValue, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/LongBinding.java","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.ListenerManager;\n@@ -64,0 +64,12 @@\n+    private static final ListenerManager<Object, ObjectBinding<?>> LISTENER_MANAGER = new ListenerManager<>() {\n+        @Override\n+        protected Object getData(ObjectBinding<?> instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(ObjectBinding<?> instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n@@ -75,1 +87,1 @@\n-    private ExpressionHelper<T> helper = null;\n+    private Object listenerData;\n@@ -86,1 +98,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -91,2 +103,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n-        observed = helper != null;\n+        observed = !LISTENER_MANAGER.removeListener(this, listener);\n@@ -98,1 +109,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, (ChangeListener<Object>) listener);\n@@ -103,2 +114,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n-        observed = helper != null;\n+        observed = !LISTENER_MANAGER.removeListener(this, listener);\n@@ -190,0 +200,2 @@\n+            T oldValue = value;\n+\n@@ -192,1 +204,2 @@\n-            ExpressionHelper.fireValueChangedEvent(helper);\n+\n+            LISTENER_MANAGER.fireValueChanged(this, oldValue, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/ObjectBinding.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.ListenerManager;\n@@ -63,0 +63,12 @@\n+    private static final ListenerManager<String, StringBinding> LISTENER_MANAGER = new ListenerManager<>() {\n+        @Override\n+        protected Object getData(StringBinding instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(StringBinding instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n@@ -73,1 +85,1 @@\n-    private ExpressionHelper<String> helper = null;\n+    private Object listenerData;\n@@ -83,1 +95,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -88,1 +100,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -93,1 +105,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -98,1 +110,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -179,0 +191,2 @@\n+            String oldValue = value;\n+\n@@ -181,1 +195,2 @@\n-            ExpressionHelper.fireValueChangedEvent(helper);\n+\n+            LISTENER_MANAGER.fireValueChanged(this, oldValue, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/StringBinding.java","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,2 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n+\n@@ -52,0 +53,12 @@\n+    private static final OldValueCachingListenerManager<Boolean, BooleanPropertyBase> LISTENER_MANAGER = new OldValueCachingListenerManager<>() {\n+        @Override\n+        protected Object getData(BooleanPropertyBase instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(BooleanPropertyBase instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n@@ -56,1 +69,1 @@\n-    private ExpressionHelper<Boolean> helper = null;\n+    private Object listenerData;\n@@ -76,1 +89,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -81,1 +94,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -86,1 +99,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -91,1 +104,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -104,1 +117,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/BooleanPropertyBase.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,2 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n+\n@@ -55,0 +56,12 @@\n+    private static final OldValueCachingListenerManager<Number, DoublePropertyBase> LISTENER_MANAGER = new OldValueCachingListenerManager<>() {\n+        @Override\n+        protected Object getData(DoublePropertyBase instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(DoublePropertyBase instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n@@ -59,1 +72,1 @@\n-    private ExpressionHelper<Number> helper = null;\n+    private Object listenerData;\n@@ -79,1 +92,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -84,1 +97,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -89,1 +102,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -94,1 +107,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -107,1 +120,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/DoublePropertyBase.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,2 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n+\n@@ -55,0 +56,12 @@\n+    private static final OldValueCachingListenerManager<Number, FloatPropertyBase> LISTENER_MANAGER = new OldValueCachingListenerManager<>() {\n+        @Override\n+        protected Object getData(FloatPropertyBase instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(FloatPropertyBase instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n@@ -59,1 +72,1 @@\n-    private ExpressionHelper<Number> helper = null;\n+    private Object listenerData;\n@@ -79,1 +92,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -84,1 +97,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -89,1 +102,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -94,1 +107,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -107,1 +120,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/FloatPropertyBase.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,2 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n+\n@@ -55,0 +56,12 @@\n+    private static final OldValueCachingListenerManager<Number, IntegerPropertyBase> LISTENER_MANAGER = new OldValueCachingListenerManager<>() {\n+        @Override\n+        protected Object getData(IntegerPropertyBase instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(IntegerPropertyBase instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n@@ -59,1 +72,1 @@\n-    private ExpressionHelper<Number> helper = null;\n+    private Object listenerData;\n@@ -79,1 +92,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -84,1 +97,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -89,1 +102,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -94,1 +107,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -107,1 +120,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/IntegerPropertyBase.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,2 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n+\n@@ -55,0 +56,12 @@\n+    private static final OldValueCachingListenerManager<Number, LongPropertyBase> LISTENER_MANAGER = new OldValueCachingListenerManager<>() {\n+        @Override\n+        protected Object getData(LongPropertyBase instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(LongPropertyBase instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n@@ -59,1 +72,1 @@\n-    private ExpressionHelper<Number> helper = null;\n+    private Object listenerData;\n@@ -79,1 +92,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -84,1 +97,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -89,1 +102,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -94,1 +107,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -107,1 +120,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/LongPropertyBase.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n+\n@@ -54,0 +55,12 @@\n+    private static final OldValueCachingListenerManager<Object, ObjectPropertyBase<?>> LISTENER_MANAGER = new OldValueCachingListenerManager<>() {\n+        @Override\n+        protected Object getData(ObjectPropertyBase<?> instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(ObjectPropertyBase<?> instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n@@ -58,1 +71,1 @@\n-    private ExpressionHelper<T> helper = null;\n+    private Object listenerData;\n@@ -78,1 +91,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -83,1 +96,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -88,1 +101,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, (ChangeListener<Object>) listener);\n@@ -93,1 +106,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -106,1 +119,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ObjectPropertyBase.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n@@ -41,0 +41,6 @@\n+    private static final OldValueCachingListenerManager<Boolean, ReadOnlyBooleanPropertyBase> LISTENER_MANAGER =\n+        new OldValueCachingListenerManager<>() {\n+            @Override\n+            protected Object getData(ReadOnlyBooleanPropertyBase instance) {\n+                return instance.listenerData;\n+            }\n@@ -42,1 +48,7 @@\n-    ExpressionHelper<Boolean> helper;\n+            @Override\n+            protected void setData(ReadOnlyBooleanPropertyBase instance, Object data) {\n+                instance.listenerData = data;\n+            }\n+        };\n+\n+    Object listenerData;\n@@ -52,1 +64,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -57,1 +69,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -62,1 +74,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -67,1 +79,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -78,1 +90,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyBooleanPropertyBase.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n+\n@@ -31,2 +33,0 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n-\n@@ -41,0 +41,12 @@\n+    private static final OldValueCachingListenerManager<Number, ReadOnlyDoublePropertyBase> LISTENER_MANAGER =\n+        new OldValueCachingListenerManager<>() {\n+            @Override\n+            protected Object getData(ReadOnlyDoublePropertyBase instance) {\n+                return instance.listenerData;\n+            }\n+\n+            @Override\n+            protected void setData(ReadOnlyDoublePropertyBase instance, Object data) {\n+                instance.listenerData = data;\n+            }\n+        };\n@@ -42,1 +54,1 @@\n-    ExpressionHelper<Number> helper;\n+    Object listenerData;\n@@ -52,1 +64,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -57,1 +69,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -62,1 +74,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -67,1 +79,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -78,1 +90,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyDoublePropertyBase.java","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n@@ -41,0 +41,6 @@\n+    private static final OldValueCachingListenerManager<Number, ReadOnlyFloatPropertyBase> LISTENER_MANAGER =\n+        new OldValueCachingListenerManager<>() {\n+            @Override\n+            protected Object getData(ReadOnlyFloatPropertyBase instance) {\n+                return instance.listenerData;\n+            }\n@@ -42,1 +48,7 @@\n-    ExpressionHelper<Number> helper;\n+            @Override\n+            protected void setData(ReadOnlyFloatPropertyBase instance, Object data) {\n+                instance.listenerData = data;\n+            }\n+        };\n+\n+    Object listenerData;\n@@ -52,1 +64,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -57,1 +69,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -62,1 +74,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -67,1 +79,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -78,1 +90,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyFloatPropertyBase.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n@@ -41,0 +41,6 @@\n+    private static final OldValueCachingListenerManager<Number, ReadOnlyIntegerPropertyBase> LISTENER_MANAGER =\n+        new OldValueCachingListenerManager<>() {\n+            @Override\n+            protected Object getData(ReadOnlyIntegerPropertyBase instance) {\n+                return instance.listenerData;\n+            }\n@@ -42,1 +48,7 @@\n-    ExpressionHelper<Number> helper;\n+            @Override\n+            protected void setData(ReadOnlyIntegerPropertyBase instance, Object data) {\n+                instance.listenerData = data;\n+            }\n+        };\n+\n+    Object listenerData;\n@@ -52,1 +64,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -57,1 +69,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -62,1 +74,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -67,1 +79,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -78,1 +90,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyIntegerPropertyBase.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n@@ -41,0 +41,6 @@\n+    private static final OldValueCachingListenerManager<Number, ReadOnlyLongPropertyBase> LISTENER_MANAGER =\n+        new OldValueCachingListenerManager<>() {\n+            @Override\n+            protected Object getData(ReadOnlyLongPropertyBase instance) {\n+                return instance.listenerData;\n+            }\n@@ -42,1 +48,7 @@\n-    ExpressionHelper<Number> helper;\n+            @Override\n+            protected void setData(ReadOnlyLongPropertyBase instance, Object data) {\n+                instance.listenerData = data;\n+            }\n+        };\n+\n+    Object listenerData;\n@@ -52,1 +64,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -57,1 +69,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -62,1 +74,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -67,1 +79,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -78,1 +90,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyLongPropertyBase.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n@@ -43,0 +43,6 @@\n+    private static final OldValueCachingListenerManager<Object, ReadOnlyObjectPropertyBase<?>> LISTENER_MANAGER =\n+        new OldValueCachingListenerManager<>() {\n+            @Override\n+            protected Object getData(ReadOnlyObjectPropertyBase<?> instance) {\n+                return instance.listenerData;\n+            }\n@@ -44,1 +50,7 @@\n-    ExpressionHelper<T> helper;\n+            @Override\n+            protected void setData(ReadOnlyObjectPropertyBase<?> instance, Object data) {\n+                instance.listenerData = data;\n+            }\n+        };\n+\n+    Object listenerData;\n@@ -54,1 +66,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -59,1 +71,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -64,1 +76,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, (ChangeListener<Object>) listener);\n@@ -69,1 +81,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -80,1 +92,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyObjectPropertyBase.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n@@ -41,0 +41,6 @@\n+    private static final OldValueCachingListenerManager<String, ReadOnlyStringPropertyBase> LISTENER_MANAGER =\n+        new OldValueCachingListenerManager<>() {\n+            @Override\n+            protected Object getData(ReadOnlyStringPropertyBase instance) {\n+                return instance.listenerData;\n+            }\n@@ -42,1 +48,7 @@\n-    ExpressionHelper<String> helper;\n+            @Override\n+            protected void setData(ReadOnlyStringPropertyBase instance, Object data) {\n+                instance.listenerData = data;\n+            }\n+        };\n+\n+    Object listenerData;\n@@ -52,1 +64,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -57,1 +69,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -62,1 +74,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -67,1 +79,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -78,1 +90,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyStringPropertyBase.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n+\n@@ -52,0 +53,12 @@\n+    private static final OldValueCachingListenerManager<String, StringPropertyBase> LISTENER_MANAGER = new OldValueCachingListenerManager<>() {\n+        @Override\n+        protected Object getData(StringPropertyBase instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(StringPropertyBase instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n@@ -56,1 +69,1 @@\n-    private ExpressionHelper<String> helper = null;\n+    private Object listenerData;\n@@ -76,1 +89,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -81,1 +94,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -86,1 +99,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -91,1 +104,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -104,1 +117,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/StringPropertyBase.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n+\n@@ -44,1 +45,13 @@\n-    private ExpressionHelper<T> helper;\n+    private static final OldValueCachingListenerManager<Object, ObservableValueBase<?>> LISTENER_MANAGER = new OldValueCachingListenerManager<>() {\n+        @Override\n+        protected Object getData(ObservableValueBase<?> instance) {\n+            return instance.listenerData;\n+        }\n+\n+        @Override\n+        protected void setData(ObservableValueBase<?> instance, Object data) {\n+            instance.listenerData = data;\n+        }\n+    };\n+\n+    private Object listenerData;\n@@ -57,1 +70,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, listener);\n@@ -65,1 +78,1 @@\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n+        LISTENER_MANAGER.addListener(this, (ChangeListener<Object>) listener);\n@@ -73,1 +86,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -81,1 +94,1 @@\n-        helper = ExpressionHelper.removeListener(helper, listener);\n+        LISTENER_MANAGER.removeListener(this, listener);\n@@ -92,1 +105,1 @@\n-        ExpressionHelper.fireValueChangedEvent(helper);\n+        LISTENER_MANAGER.fireValueChanged(this, listenerData);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/ObservableValueBase.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,335 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.binding;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiFunction;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import com.sun.javafx.binding.ArrayManager;\n+\n+public class ArrayManagerTest {\n+\n+    private final ArrayManager<ArrayManagerTest, String> manager = new ArrayManager<>(String.class) {\n+        protected int compact(ArrayManagerTest instance, String[] array) {\n+            return compacter.apply(instance, array);\n+        }\n+\n+        @Override\n+        public String[] getArray(ArrayManagerTest instance) {\n+            return instance.array;\n+        }\n+\n+        @Override\n+        public void setArray(ArrayManagerTest instance, String[] array) {\n+            instance.array = array;\n+        }\n+\n+        @Override\n+        public int getOccupiedSlots(ArrayManagerTest instance) {\n+            return instance.size;\n+        }\n+\n+        @Override\n+        public void setOccupiedSlots(ArrayManagerTest instance, int occupiedSlots) {\n+            instance.size = occupiedSlots;\n+        }\n+    };\n+\n+    private BiFunction<ArrayManagerTest, String[], Integer> compacter = (instance, array) -> 0;\n+    private String[] array;\n+    private int size;\n+\n+    @Test\n+    void constructorShouldRejectNullArguments() {\n+        assertThrows(NullPointerException.class, () -> new ArrayManager<>(null) {\n+            @Override\n+            protected Object[] getArray(Object instance) {\n+                return null;\n+            }\n+\n+            @Override\n+            protected void setArray(Object instance, Object[] array) {\n+            }\n+\n+            @Override\n+            protected int getOccupiedSlots(Object instance) {\n+                return 0;\n+            }\n+\n+            @Override\n+            protected void setOccupiedSlots(Object instance, int occupiedSlots) {\n+            }\n+        });\n+    }\n+\n+    @Nested\n+    class WhenEmpty {\n+\n+        @Test\n+        void getShouldRejectAccessingIllegalIndices() {\n+            assertThrows(IndexOutOfBoundsException.class, () -> manager.get(ArrayManagerTest.this, 0));\n+            assertThrows(IndexOutOfBoundsException.class, () -> manager.get(ArrayManagerTest.this, 1));\n+            assertThrows(IndexOutOfBoundsException.class, () -> manager.get(ArrayManagerTest.this, -1));\n+        }\n+\n+        @Test\n+        void removeShouldRejectRemovingIllegalIndices() {\n+            assertThrows(IndexOutOfBoundsException.class, () -> manager.remove(ArrayManagerTest.this, 0));\n+            assertThrows(IndexOutOfBoundsException.class, () -> manager.remove(ArrayManagerTest.this, 1));\n+            assertThrows(IndexOutOfBoundsException.class, () -> manager.remove(ArrayManagerTest.this, -1));\n+        }\n+\n+        @Test\n+        void setShouldRejectSettingIllegalIndices() {\n+            assertThrows(IndexOutOfBoundsException.class, () -> manager.set(ArrayManagerTest.this, 0, \"A\"));\n+            assertThrows(IndexOutOfBoundsException.class, () -> manager.set(ArrayManagerTest.this, 1, \"A\"));\n+            assertThrows(IndexOutOfBoundsException.class, () -> manager.set(ArrayManagerTest.this, -1, \"A\"));\n+        }\n+\n+        @Test\n+        void indexOfShouldNotFindAnything() {\n+            assertEquals(-1, manager.indexOf(ArrayManagerTest.this, \"A\"));\n+            assertEquals(-1, manager.indexOf(ArrayManagerTest.this, null));\n+            assertEquals(-1, manager.indexOf(ArrayManagerTest.this, \"\"));\n+        }\n+\n+        @Test\n+        void removeIfShouldNotRemoveAnything() {\n+            assertFalse(manager.removeIf(ArrayManagerTest.this, s -> true));\n+\n+            assertEquals(0, size);\n+        }\n+\n+        @Test\n+        void addShouldAddElements() {\n+           assertEquals(0, size);\n+           manager.add(ArrayManagerTest.this, \"A\");\n+           assertEquals(1, size);\n+           manager.add(ArrayManagerTest.this, null);\n+           assertEquals(2, size);\n+           manager.add(ArrayManagerTest.this, \"\");\n+           assertEquals(3, size);\n+        }\n+\n+        @Test\n+        void compactShouldBeCalledWhenGrowingANonEmptyArray() {\n+            AtomicBoolean called = new AtomicBoolean();\n+\n+            compacter = (instance, array) -> { called.set(true); return 0; };\n+\n+            manager.add(ArrayManagerTest.this, \"A\");\n+\n+            assertNotNull(array);\n+            assertFalse(called.get());\n+\n+            manager.add(ArrayManagerTest.this, \"B\");\n+            manager.add(ArrayManagerTest.this, \"C\");\n+            manager.add(ArrayManagerTest.this, \"D\");  \/\/ triggers grow with default settings\n+\n+            assertTrue(called.get());\n+        }\n+\n+        @Nested\n+        class AndSomeElementsAreAdded {\n+            {\n+                manager.add(ArrayManagerTest.this, \"A\");\n+                manager.add(ArrayManagerTest.this, \"B\");\n+                manager.add(ArrayManagerTest.this, \"C\");\n+                manager.add(ArrayManagerTest.this, \"D\");\n+                manager.add(ArrayManagerTest.this, \"E\");\n+            }\n+\n+            @Test\n+            void shouldContainsThoseElementsInInsertionOrder() {\n+                assertElements(\"A\", \"B\", \"C\", \"D\", \"E\");\n+            }\n+\n+            @Test\n+            void removeShouldRemoveElements() {\n+                assertEquals(\"C\", manager.remove(ArrayManagerTest.this, 2));\n+                assertElements(\"A\", \"B\", \"D\", \"E\");\n+                assertEquals(7, array.length);\n+\n+                assertEquals(\"D\", manager.remove(ArrayManagerTest.this, 2));\n+                assertElements(\"A\", \"B\", \"E\");\n+                assertEquals(7, array.length);\n+\n+                assertEquals(\"A\", manager.remove(ArrayManagerTest.this, 0));\n+                assertElements(\"B\", \"E\");\n+                assertEquals(7, array.length);\n+\n+                assertEquals(\"E\", manager.remove(ArrayManagerTest.this, 1));  \/\/ triggers shrink\n+                assertElements(\"B\");\n+                assertEquals(3, array.length);\n+\n+                assertEquals(\"B\", manager.remove(ArrayManagerTest.this, 0));  \/\/ triggers empty\n+                assertElements();\n+                assertNull(array);\n+            }\n+\n+            @Test\n+            void removeShouldRemoveElements_2() {  \/\/ for coverage of remove from end, and shrink case with elements that must be moved\n+                assertEquals(\"C\", manager.remove(ArrayManagerTest.this, 2));\n+                assertElements(\"A\", \"B\", \"D\", \"E\");\n+                assertEquals(7, array.length);\n+\n+                assertEquals(\"E\", manager.remove(ArrayManagerTest.this, 3));\n+                assertElements(\"A\", \"B\", \"D\");\n+                assertEquals(7, array.length);\n+\n+                assertEquals(\"A\", manager.remove(ArrayManagerTest.this, 0));\n+                assertElements(\"B\", \"D\");\n+                assertEquals(7, array.length);\n+\n+                assertEquals(\"B\", manager.remove(ArrayManagerTest.this, 0));  \/\/ triggers shrink\n+                assertElements(\"D\");\n+                assertEquals(3, array.length);\n+\n+                assertEquals(\"D\", manager.remove(ArrayManagerTest.this, 0));  \/\/ triggers empty\n+                assertElements();\n+                assertNull(array);\n+            }\n+\n+            @Test\n+            void removeIfShouldNotRemoveAnythingWhenNothingMatched() {\n+                assertFalse(manager.removeIf(ArrayManagerTest.this, s -> s.compareTo(\"F\") > 0));\n+            }\n+\n+            @Test\n+            void removeIfShouldRemoveElementsFromEnd() {\n+                assertTrue(manager.removeIf(ArrayManagerTest.this, s -> s.compareTo(\"C\") > 0));\n+\n+                assertEquals(3, size);\n+                assertEquals(manager.get(ArrayManagerTest.this, 0), \"A\");\n+                assertEquals(manager.get(ArrayManagerTest.this, 1), \"B\");\n+                assertEquals(manager.get(ArrayManagerTest.this, 2), \"C\");\n+            }\n+\n+            @Test\n+            void removeIfShouldRemoveElementsFromBeginning() {\n+                assertTrue(manager.removeIf(ArrayManagerTest.this, s -> s.compareTo(\"C\") < 0));\n+\n+                assertEquals(3, size);\n+                assertEquals(manager.get(ArrayManagerTest.this, 0), \"C\");\n+                assertEquals(manager.get(ArrayManagerTest.this, 1), \"D\");\n+                assertEquals(manager.get(ArrayManagerTest.this, 2), \"E\");\n+            }\n+\n+            @Test\n+            void removeIfShouldAllocateNewArrayIfNeeded() {\n+                assertEquals(7, array.length);\n+\n+                assertTrue(manager.removeIf(ArrayManagerTest.this, s -> s.compareTo(\"E\") < 0));\n+\n+                assertEquals(1, size);\n+                assertEquals(manager.get(ArrayManagerTest.this, 0), \"E\");\n+                assertEquals(3, array.length);\n+            }\n+\n+            @Test\n+            void removeIfShouldReturnEmptyArrayWhenAllRemoved() {\n+                assertEquals(7, array.length);\n+\n+                assertTrue(manager.removeIf(ArrayManagerTest.this, s -> s.compareTo(\"F\") < 0));\n+\n+                assertEquals(0, size);\n+                assertNull(array);\n+            }\n+\n+            @Test\n+            void indexOfShouldBeAbleToFindElements() {\n+                assertEquals(2, manager.indexOf(ArrayManagerTest.this, \"C\"));\n+                assertEquals(-1, manager.indexOf(ArrayManagerTest.this, null));\n+\n+                manager.add(ArrayManagerTest.this, null);\n+\n+                assertEquals(5, manager.indexOf(ArrayManagerTest.this, null));\n+            }\n+\n+            @Test\n+            void setShouldBeAbleToReplaceElements() {\n+                manager.set(ArrayManagerTest.this, 2, \"c\");\n+                manager.set(ArrayManagerTest.this, 4, null);\n+\n+                assertElements(\"A\", \"B\", \"c\", \"D\", null);\n+            }\n+\n+            @Test\n+            void shouldShrinkArrayWhenCompactionIsVeryEffective() {\n+                AtomicBoolean called = new AtomicBoolean();\n+\n+                compacter = (instance, array) -> { called.set(true); return 7; };  \/\/ 7 out of 7 compacted\n+\n+                assertEquals(7, array.length);\n+\n+                manager.add(ArrayManagerTest.this, \"F\");\n+                manager.add(ArrayManagerTest.this, \"G\");\n+                manager.add(ArrayManagerTest.this, \"H\");  \/\/ triggers grow with default settings\n+\n+                assertTrue(called.get());\n+                assertEquals(3, array.length);\n+                assertElements(\"H\");\n+            }\n+\n+            @Test\n+            void shouldKeepArrayWhenCompactionReclaimsSpace() {\n+                AtomicBoolean called = new AtomicBoolean();\n+\n+                compacter = (instance, array) -> { called.set(true); return 1; };\n+\n+                assertEquals(7, array.length);\n+\n+                manager.add(ArrayManagerTest.this, \"F\");\n+                manager.add(ArrayManagerTest.this, \"G\");\n+                manager.add(ArrayManagerTest.this, \"H\");  \/\/ triggers grow with default settings\n+\n+                assertTrue(called.get());\n+                assertEquals(7, array.length);\n+                assertElements(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"H\");    \/\/ G was dropped by compacter\n+            }\n+        }\n+    }\n+\n+    void assertElements(String... expecteds) {\n+        for (int i = 0; i < expecteds.length; i++) {\n+            String expected = expecteds[i];\n+\n+            assertEquals(expected, manager.get(ArrayManagerTest.this, i));\n+        }\n+\n+        assertEquals(expecteds.length, size);\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ArrayManagerTest.java","additions":335,"deletions":0,"binary":false,"changes":335,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.ArrayList;\n@@ -32,0 +33,3 @@\n+\n+import com.sun.javafx.binding.ListenerListBase;\n+\n@@ -73,0 +77,13 @@\n+        if (helper instanceof InvalidationListener il) {\n+            return List.of(il);\n+        }\n+        if (helper instanceof ListenerListBase list) {\n+            List<InvalidationListener> listeners = new ArrayList<>();\n+\n+            for (int i = 0; i < list.invalidationListenersSize(); i++) {\n+                listeners.add(list.getInvalidationListener(i));\n+            }\n+\n+            return listeners;\n+        }\n+\n@@ -139,0 +156,23 @@\n+\n+        if (helper instanceof ChangeListener) {\n+            try {\n+                Field field = Class.forName(\"com.sun.javafx.binding.OldValueCachingListenerManager$ChangeListenerWrapper\").getDeclaredField(\"listener\");\n+\n+                field.setAccessible(true);\n+\n+                return List.of((ChangeListener<T>) field.get(helper));\n+            }\n+            catch(Exception e) {}\n+\n+            return List.of((ChangeListener<T>) helper);\n+        }\n+        if (helper instanceof ListenerListBase list) {\n+            List<ChangeListener<? super T>> listeners = new ArrayList<>();\n+\n+            for (int i = 0; i < list.changeListenersSize(); i++) {\n+                listeners.add(list.getChangeListener(i));\n+            }\n+\n+            return listeners;\n+        }\n+\n@@ -346,1 +386,9 @@\n-            } catch (Exception ex) { }\n+            } catch (Exception ex) {\n+                try {\n+                    Field field = clazz.getDeclaredField(\"listenerData\");\n+                    field.setAccessible(true);\n+                    return field.get(bean);\n+                }\n+                catch(Exception ex2) {\n+                }\n+            }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ExpressionHelperUtility.java","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,590 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.binding;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.sun.javafx.binding.ListenerList;\n+import com.sun.javafx.binding.ListenerListBase;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.Observable;\n+import javafx.beans.WeakListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+public class ListenerListBaseTest {\n+    private final InvalidationListener il1 = obs -> {};\n+    private final ChangeListener<?> cl1 = (obs, o, n) -> {};\n+    private final InvalidationListener il2 = obs -> {};\n+    private final ChangeListener<?> cl2 = (obs, o, n) -> {};\n+\n+    private static class AccessibleListenerListBase extends ListenerListBase {\n+        AccessibleListenerListBase(Object listener1, Object listener2) {\n+            super(listener1, listener2);\n+        }\n+\n+        public void accessibleLock() {\n+            lock();\n+        }\n+\n+        public boolean accessibleUnlock() {\n+            return unlock();\n+        }\n+\n+        public Object get(int index) {\n+            return index < invalidationListenersSize() ? getInvalidationListener(index) : getChangeListener(index - invalidationListenersSize());\n+        }\n+    }\n+\n+    @Test\n+    void shouldConstructListWithInvalidationBeforeChangeListeners() {\n+        AccessibleListenerListBase list = new AccessibleListenerListBase(cl1, il1);\n+\n+        assertEquals(il1, list.get(0));\n+        assertEquals(cl1, list.get(1));\n+\n+        list = new AccessibleListenerListBase(il1, cl1);\n+\n+        assertEquals(il1, list.get(0));\n+        assertEquals(cl1, list.get(1));\n+    }\n+\n+    @Test\n+    void shouldRejectAddNullListeners() {\n+        AccessibleListenerListBase list = new AccessibleListenerListBase(cl1, il1);\n+\n+        assertThrows(NullPointerException.class, () -> list.add(null));\n+    }\n+\n+    @Test\n+    void shouldRejectUnlockedWhenNotLocked() {\n+        AccessibleListenerListBase list = new AccessibleListenerListBase(cl1, il1);\n+\n+        assertThrows(AssertionError.class, () -> list.accessibleUnlock());\n+\n+        list.accessibleLock();\n+        list.accessibleUnlock();\n+\n+        assertThrows(AssertionError.class, () -> list.accessibleUnlock());\n+    }\n+\n+    @Test\n+    void shouldRejectLockWhenLocked() {\n+        AccessibleListenerListBase list = new AccessibleListenerListBase(cl1, il1);\n+\n+        list.accessibleLock();\n+\n+        assertThrows(AssertionError.class, () -> list.accessibleLock());\n+\n+        list.accessibleUnlock();\n+        list.accessibleLock();\n+    }\n+\n+    @Test\n+    void shouldAllowRemovingAllListeners() {\n+        ListenerList<?> list = new ListenerList<>(cl1, il1);\n+\n+        assertEquals(1, list.invalidationListenersSize());\n+        assertEquals(1, list.changeListenersSize());\n+        assertEquals(2, list.totalListeners());\n+        assertTrue(list.hasChangeListeners());\n+\n+        list.remove(cl1);\n+\n+        assertEquals(1, list.invalidationListenersSize());\n+        assertEquals(0, list.changeListenersSize());\n+        assertEquals(1, list.totalListeners());\n+        assertFalse(list.hasChangeListeners());\n+\n+        list.remove(il1);\n+\n+        assertEquals(0, list.invalidationListenersSize());\n+        assertEquals(0, list.changeListenersSize());\n+        assertEquals(0, list.totalListeners());\n+        assertFalse(list.hasChangeListeners());\n+\n+        list.remove(cl1);\n+        list.remove(il1);\n+    }\n+\n+    @Test\n+    void shouldUpdateTotalListenersWhileLocked() {\n+        AccessibleListenerListBase list = new AccessibleListenerListBase(cl1, il1);\n+\n+        list.accessibleLock();\n+\n+        assertEquals(1, list.invalidationListenersSize());\n+        assertEquals(1, list.changeListenersSize());\n+        assertEquals(2, list.totalListeners());\n+        assertTrue(list.hasChangeListeners());\n+\n+        list.remove(cl1);\n+\n+        assertEquals(1, list.invalidationListenersSize());\n+        assertEquals(1, list.changeListenersSize());\n+        assertEquals(1, list.totalListeners());\n+        assertTrue(list.hasChangeListeners());\n+\n+        list.remove(il1);\n+\n+        assertEquals(1, list.invalidationListenersSize());\n+        assertEquals(1, list.changeListenersSize());\n+        assertEquals(0, list.totalListeners());\n+        assertTrue(list.hasChangeListeners());\n+\n+        list.accessibleUnlock();\n+\n+        assertEquals(0, list.invalidationListenersSize());\n+        assertEquals(0, list.changeListenersSize());\n+        assertEquals(0, list.totalListeners());\n+        assertFalse(list.hasChangeListeners());\n+    }\n+\n+    @Test\n+    void shouldNeverSilentlyRemoveWeakListeners() {\n+\n+        \/*\n+         * Weak listeners should only ever be removed as part of a\n+         * add or remove listener call (although more listeners can be removed\n+         * than just the given one during such a call). It should never\n+         * happen during the unlock operation as the listener count then\n+         * changes unexpectedly. This is also the behavior of the old\n+         * ExpressionHelper.\n+         *\n+         * WeakListeners that remove themselves during notification are\n+         * not a problem as this always goes through a removeListener call.\n+         *\/\n+\n+        AccessibleListenerListBase list = new AccessibleListenerListBase(cl1, il1);\n+        WeakInvalidationListener weakListener = new WeakInvalidationListener(\"\");\n+\n+        list.add(weakListener);  \/\/ add the listener that should NOT be removed during cleanup\n+\n+        list.accessibleLock();\n+\n+        \/\/ make a change to the list so it will trigger a cleanup during unlock\n+        list.remove(cl1);  \/\/ nulls out cl1, forcing a cleanup during unlock\n+\n+        weakListener.setGarbageCollected(true);\n+\n+        list.accessibleUnlock();\n+\n+        \/\/ Ensure the unlock did not remove the weak listener even though it is no longer needed\n+        assertEquals(2, list.invalidationListenersSize());\n+        assertEquals(0, list.changeListenersSize());\n+        assertEquals(2, list.totalListeners());\n+        assertListeners(list, List.of(il1, weakListener));\n+\n+        for(int i = 0; i < 100; i++) {\n+            list.add(il2);\n+        }\n+\n+        assertEquals(101, list.totalListeners());  \/\/ Not 102 as weak listener was removed during a compaction step\n+    }\n+\n+    @Test\n+    void hasChangeListenersShouldReturnCorrectState() {\n+        ListenerList<?> list = new ListenerList<>(cl1, il1);\n+\n+        assertTrue(list.hasChangeListeners());\n+\n+        list.remove(cl1);\n+\n+        assertFalse(list.hasChangeListeners());\n+\n+        ListenerList<?> list2 = new ListenerList<>(il1, il2);\n+\n+        assertFalse(list2.hasChangeListeners());\n+    }\n+\n+    @Test\n+    void hasChangeListenersShouldReturnCorrectStateWhileLocked_2() {\n+        AccessibleListenerListBase list = new AccessibleListenerListBase(il1, il2);\n+\n+        list.accessibleLock();\n+\n+        assertFalse(list.hasChangeListeners());  \/\/ TODO is this what we want???? This is mainly tracked so we know when to update\/clear old value...\n+\n+        list.add(cl1);\n+\n+        assertFalse(list.hasChangeListeners());\n+    }\n+\n+    @Test\n+    void shouldKeepInvalidationAndChangeListenersSeparated() {\n+        AccessibleListenerListBase list = new AccessibleListenerListBase(cl1, il1);\n+        Random rnd = new Random(1);\n+\n+        for(int i = 0; i < 10000; i++) {\n+            list.add(rnd.nextBoolean() ? il1 : cl1);\n+        }\n+\n+        assertEquals(10002, list.invalidationListenersSize() + list.changeListenersSize());\n+        assertListenerSeparation(list);\n+    }\n+\n+    @Test\n+    void shouldKeepInvalidationAndChangeListenersSeparatedAndInOrderWhenSomeAreRemovedOrExpired() {\n+        Random rnd = new Random(1);\n+        List<Object> addedListeners = new ArrayList<>();\n+        AccessibleListenerListBase list = new AccessibleListenerListBase(new WeakInvalidationListener(\"0\"), new WeakChangeListener(\"1\"));\n+\n+        addedListeners.add(list.get(0));\n+        addedListeners.add(list.get(1));\n+\n+        for(int i = 2; i < 10000; i++) {\n+            Object listener = rnd.nextBoolean() ? new WeakInvalidationListener(\"\" + i) : new WeakChangeListener(\"\" + i);\n+\n+            addedListeners.add(listener);\n+            list.add(listener);\n+\n+            double nextDouble = rnd.nextDouble();\n+\n+            if(nextDouble < 0.05) {\n+                list.remove(addedListeners.remove(rnd.nextInt(addedListeners.size())));\n+            }\n+            else if(nextDouble < 0.15) {\n+                if(list.get(rnd.nextInt(list.invalidationListenersSize() + list.changeListenersSize())) instanceof SettableWeakListener swl) {\n+                    swl.setGarbageCollected(true);\n+                }\n+            }\n+        }\n+\n+        \/\/ the exact size is not known, as it would depend on how many listeners have expired and\n+        \/\/ when the last resize was done to clean expired elements\n+\n+        assertListenerSeparation(list);\n+\n+        List<Object> separatedListeners =\n+            Stream.concat(\n+                addedListeners.stream().filter(InvalidationListener.class::isInstance),\n+                addedListeners.stream().filter(ChangeListener.class::isInstance)\n+            )\n+            .toList();\n+\n+        for(int i = 0; i < list.invalidationListenersSize() + list.changeListenersSize(); i++) {\n+            Object listener = list.get(i);\n+\n+            assertTrue(separatedListeners.contains(listener));\n+\n+            \/\/ assert that all indices are smaller than the ones in the separated added listeners, as some\n+            \/\/ may have been garbage collected\n+            assertTrue(i <= separatedListeners.indexOf(listener), i + \" should be <= \" + separatedListeners.indexOf(listener));\n+        }\n+    }\n+\n+    @Test\n+    void shouldKeepInvalidationAndChangeListenersSeparatedAndInOrderWhileLockedAndWhenSomeAreRemoved() {\n+        Random rnd = new Random(1);\n+        List<Object> addedListeners = new ArrayList<>();\n+        AccessibleListenerListBase list = new AccessibleListenerListBase(new WeakInvalidationListener(\"0\"), new WeakChangeListener(\"1\"));\n+\n+        addedListeners.add(list.get(0));\n+        addedListeners.add(list.get(1));\n+\n+        \/\/ Add some listeners first before the lock:\n+        for(int i = 2; i < 1000; i++) {\n+            Object listener = rnd.nextBoolean() ? new WeakInvalidationListener(\"\" + i) : new WeakChangeListener(\"\" + i);\n+\n+            addedListeners.add(listener);\n+            list.add(listener);\n+        }\n+\n+        list.accessibleLock();\n+\n+        for(int i = 1000; i < 10000; i++) {\n+            Object listener = rnd.nextBoolean() ? new WeakInvalidationListener(\"\" + i) : new WeakChangeListener(\"\" + i);\n+\n+            addedListeners.add(listener);\n+            list.add(listener);\n+\n+            double nextDouble = rnd.nextDouble();\n+\n+            if(nextDouble < 0.05) {\n+                list.remove(addedListeners.remove(rnd.nextInt(addedListeners.size())));\n+            }\n+            else if(nextDouble < 0.15) {\n+                if(addedListeners.get(rnd.nextInt(addedListeners.size())) instanceof SettableWeakListener swl) {\n+                    swl.setGarbageCollected(true);\n+                }\n+            }\n+        }\n+\n+        list.accessibleUnlock();\n+\n+        \/\/ the exact size is not known, as it would depend on how many listeners have expired and\n+        \/\/ when the last resize was done to clean expired elements\n+\n+        assertListenerSeparation(list);\n+\n+        List<Object> separatedListeners =\n+            Stream.concat(\n+                addedListeners.stream().filter(InvalidationListener.class::isInstance),\n+                addedListeners.stream().filter(ChangeListener.class::isInstance)\n+            )\n+            .toList();\n+\n+        int skips = 0;\n+\n+        for(int i = 0; i < list.invalidationListenersSize() + list.changeListenersSize(); i++) {\n+            Object listener = list.get(i);\n+\n+            if (listener == null) {\n+                skips++;\n+                continue;\n+            }\n+\n+            assertTrue(separatedListeners.contains(listener), \"expected \" + listener + \" to be have been added before\");\n+\n+            \/\/ assert that all indices are smaller than the ones in the separated added listeners, as some\n+            \/\/ may have been garbage collected; don't count nulls\n+            assertTrue(i - skips <= separatedListeners.indexOf(listener), i + \" - \" + skips + \" should be <= \" + separatedListeners.indexOf(listener));\n+        }\n+\n+        \/\/ Add some more listeners after unlock to trigger compaction:\n+        for(int i = 10000; i < 20000; i++) {\n+            Object listener = rnd.nextBoolean() ? new WeakInvalidationListener(\"\" + i) : new WeakChangeListener(\"\" + i);\n+\n+            addedListeners.add(listener);\n+            list.add(listener);\n+        }\n+\n+        assertListenerSeparation(list);\n+\n+        separatedListeners =\n+            Stream.concat(\n+                addedListeners.stream().filter(InvalidationListener.class::isInstance),\n+                addedListeners.stream().filter(ChangeListener.class::isInstance)\n+            )\n+            .filter(l -> l instanceof WeakListener wl && !wl.wasGarbageCollected())\n+            .collect(Collectors.toCollection(ArrayList::new));  \/\/ going to modify it in a bit\n+\n+        \/\/ after compaction, can now assert exact order and contents:\n+        assertListeners(list, separatedListeners);\n+\n+        \/\/ remove many listeners to trigger a shrink:\n+        for(int i = 0; i < 10000; i++) {\n+            list.remove(separatedListeners.remove(rnd.nextInt(separatedListeners.size())));\n+        }\n+\n+        \/\/ verify again:\n+        assertListeners(list, separatedListeners);\n+    }\n+\n+    @Test\n+    void additionsShouldNotShowUpWhileLocked() {\n+        AccessibleListenerListBase list = new AccessibleListenerListBase(cl1, il1);\n+\n+        assertEquals(1, list.invalidationListenersSize());\n+        assertEquals(1, list.changeListenersSize());\n+        assertEquals(2, list.totalListeners());\n+\n+        list.accessibleLock();\n+\n+        list.add(il2);\n+        list.add(cl2);\n+\n+        assertEquals(1, list.invalidationListenersSize());\n+        assertEquals(1, list.changeListenersSize());\n+        assertEquals(4, list.totalListeners());\n+        assertEquals(il1, list.get(0));\n+        assertEquals(cl1, list.get(1));\n+        assertThrows(AssertionError.class, () -> list.get(2));  \/\/ reject attempts to bypass lock\n+\n+        list.accessibleUnlock();\n+\n+        assertEquals(2, list.invalidationListenersSize());\n+        assertEquals(2, list.changeListenersSize());\n+        assertEquals(4, list.totalListeners());\n+\n+        assertListeners(list, List.of(il1, il2, cl1, cl2));\n+    }\n+\n+    @Test\n+    void removalsShouldBecomeNullsWhileLocked() {\n+        AccessibleListenerListBase list = new AccessibleListenerListBase(cl1, il1);\n+\n+        assertEquals(1, list.invalidationListenersSize());\n+        assertEquals(1, list.changeListenersSize());\n+        assertEquals(2, list.totalListeners());\n+\n+        list.add(il2);\n+        list.add(cl2);\n+\n+        assertEquals(2, list.invalidationListenersSize());\n+        assertEquals(2, list.changeListenersSize());\n+        assertEquals(4, list.totalListeners());\n+        assertListeners(list, List.of(il1, il2, cl1, cl2));\n+\n+        list.accessibleLock();\n+\n+        assertEquals(2, list.invalidationListenersSize());\n+        assertEquals(2, list.changeListenersSize());\n+        assertEquals(4, list.totalListeners());\n+        assertListeners(list, List.of(il1, il2, cl1, cl2));\n+\n+        list.remove(il1);\n+\n+        assertEquals(2, list.invalidationListenersSize());\n+        assertEquals(2, list.changeListenersSize());\n+        assertEquals(3, list.totalListeners());\n+        assertListeners(list, List.of(il2, cl1, cl2));\n+\n+        list.remove(cl1);\n+\n+        assertEquals(2, list.invalidationListenersSize());\n+        assertEquals(2, list.changeListenersSize());\n+        assertEquals(2, list.totalListeners());\n+        assertListeners(list, List.of(il2, cl2));\n+\n+        assertEquals(null, list.get(0));\n+        assertEquals(il2, list.get(1));\n+        assertEquals(null, list.get(2));\n+        assertEquals(cl2, list.get(3));\n+\n+        list.accessibleUnlock();\n+\n+        assertEquals(1, list.invalidationListenersSize());\n+        assertEquals(1, list.changeListenersSize());\n+        assertEquals(2, list.totalListeners());\n+        assertListeners(list, List.of(il2, cl2));\n+    }\n+\n+    private void assertListenerSeparation(AccessibleListenerListBase list) {\n+        boolean foundChange = false;\n+\n+        for(int i = 0; i < list.invalidationListenersSize() + list.changeListenersSize(); i++) {\n+            if(list.get(i) instanceof ChangeListener) {\n+                foundChange = true;\n+            }\n+            else if(foundChange && list.get(i) != null) {\n+                fail(\"Found an invalidation listener at index \" + i + \" after a change listener was seen\");\n+            }\n+        }\n+    }\n+\n+    private void assertListeners(AccessibleListenerListBase list, List<Object> expectedListeners) {\n+        assertListenerSeparation(list);\n+\n+        int j = 0;\n+        int x = 0;\n+\n+        for(int i = 0; i < list.invalidationListenersSize() + list.changeListenersSize(); i++) {\n+            Object listener = list.get(i);\n+\n+            if(listener == null) {\n+                x++;\n+                continue;\n+            }\n+\n+            if(j >= expectedListeners.size()) {\n+                fail(\"Listener at index \" + i + \" (with \" + x + \" nulls skipped) is listener \" + (i - x) + \", but only \" + expectedListeners.size() + \" were expected: \" + listener);\n+            }\n+\n+            assertEquals(expectedListeners.get(j), listener, \"Listener at index \" + i + \" (with \" + x + \" nulls skipped) did not match listener at index \" + j);\n+            j++;\n+        }\n+\n+        if(j != expectedListeners.size()) {\n+            fail(\"Only \" + j + \" listeners were found, but \" + expectedListeners.size() + \" were expected\");\n+        }\n+    }\n+\n+    interface SettableWeakListener extends WeakListener {\n+        void setGarbageCollected(boolean gc);\n+    }\n+\n+    static class WeakInvalidationListener implements InvalidationListener, SettableWeakListener {\n+        private final String name;\n+\n+        private boolean wasGarbageCollected;\n+\n+        public WeakInvalidationListener(String name) {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public void setGarbageCollected(boolean gc) {\n+            this.wasGarbageCollected = gc;\n+        }\n+\n+        @Override\n+        public boolean wasGarbageCollected() {\n+            return wasGarbageCollected;\n+        }\n+\n+        @Override\n+        public void invalidated(Observable observable) {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"IL[\" + name + \"]\";\n+        }\n+    }\n+\n+    static class WeakChangeListener implements ChangeListener<Object>, SettableWeakListener {\n+        private final String name;\n+\n+        private boolean wasGarbageCollected;\n+\n+        public WeakChangeListener(String name) {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public void setGarbageCollected(boolean gc) {\n+            this.wasGarbageCollected = gc;\n+        }\n+\n+        @Override\n+        public boolean wasGarbageCollected() {\n+            return wasGarbageCollected;\n+        }\n+\n+        @Override\n+        public void changed(ObservableValue<? extends Object> observable, Object oldValue, Object newValue) {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"CL[\" + name + \"]\";\n+        }\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ListenerListBaseTest.java","additions":590,"deletions":0,"binary":false,"changes":590,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.binding;\n+\n+import com.sun.javafx.binding.ListenerList;\n+\n+import javafx.beans.value.ObservableValue;\n+\n+public class ListenerListTest extends ListenerListTestBase<ListenerList<Object>> {\n+\n+    @Override\n+    protected ListenerList<Object> create(Object listener1, Object listener2) {\n+        return new ListenerList<>(listener1, listener2);\n+    }\n+\n+    @Override\n+    protected <T> void notifyListeners(ListenerList<Object> list, ObservableValue<? extends T> property, T oldValue) {\n+        list.notifyListeners(property, oldValue);\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ListenerListTest.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,677 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.binding;\n+\n+import com.sun.javafx.binding.ListenerList;\n+import com.sun.javafx.binding.ListenerListBase;\n+\n+import java.lang.Thread.UncaughtExceptionHandler;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.LongProperty;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleLongProperty;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.beans.property.StringProperty;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/**\n+ * Base test class suitable for testing {@link ListenerList} and {@link com.sun.javafx.binding.OldValueCachingListenerList}.\n+ *\n+ * @param <L> the class to test\n+ *\/\n+public abstract class ListenerListTestBase<L extends ListenerListBase> {\n+    private final List<String> records = new ArrayList<>();\n+    private final InvalidationListener il1 = obs -> records.add(\"IL1: invalidated\");\n+    private final InvalidationListener il2 = obs -> records.add(\"IL2: invalidated\");\n+    private final ChangeListener<?> cl1 = (obs, o, n) -> records.add(\"CL1: changed from \" + o + \" to \" + n);\n+    private final ChangeListener<?> cl2 = (obs, o, n) -> records.add(\"CL2: changed from \" + o + \" to \" + n);\n+\n+    private int getterCalled;\n+\n+    private final StringProperty property = new SimpleStringProperty(\"-\") {\n+        @Override\n+        public String get() {\n+            getterCalled++;\n+\n+            return super.get();\n+        }\n+    };\n+\n+    protected abstract L create(Object listener1, Object listener2);\n+    protected abstract <T> void notifyListeners(L list, ObservableValue<? extends T> property, T oldValue);\n+\n+    @Test\n+    void shouldNotifyAllListeners() {\n+        L list = create(cl1, il1);\n+\n+        list.add(cl2);\n+        list.add(il2);\n+\n+        property.set(\"A\");\n+        notifyListeners(list, property, \"-\");\n+\n+        assertRecords(\n+            \"IL1: invalidated\",\n+            \"IL2: invalidated\",\n+            \"CL1: changed from - to A\",\n+            \"CL2: changed from - to A\"\n+        );\n+    }\n+\n+    @Test\n+    void shouldNotifyAllListenersEvenWhenTheyThrowExceptions() {\n+        InvalidationListener il1 = obs -> { records.add(\"IL1: invalidated\"); throw new RuntimeException(); };\n+        InvalidationListener il2 = obs -> { records.add(\"IL2: invalidated\"); throw new RuntimeException(); };\n+        ChangeListener<?> cl1 = (obs, o, n) -> { records.add(\"CL1: changed from \" + o + \" to \" + n); throw new RuntimeException(); };\n+        ChangeListener<?> cl2 = (obs, o, n) -> { records.add(\"CL2: changed from \" + o + \" to \" + n); throw new RuntimeException(); };\n+\n+        L list = create(cl1, il1);\n+\n+        list.add(cl2);\n+        list.add(il2);\n+\n+        \/\/ Replace exception handler to reduce log spam during test:\n+        UncaughtExceptionHandler oldExceptionHandler = Thread.currentThread().getUncaughtExceptionHandler();\n+\n+        try {\n+            AtomicInteger exceptions = new AtomicInteger();\n+            Thread.currentThread().setUncaughtExceptionHandler((t, e) -> exceptions.addAndGet(1));\n+\n+            property.set(\"A\");\n+            notifyListeners(list, property, \"-\");\n+\n+            assertRecords(\n+                \"IL1: invalidated\",\n+                \"IL2: invalidated\",\n+                \"CL1: changed from - to A\",\n+                \"CL2: changed from - to A\"\n+            );\n+\n+            assertEquals(4, exceptions.get());\n+        }\n+        finally {\n+            Thread.currentThread().setUncaughtExceptionHandler(oldExceptionHandler);\n+        }\n+    }\n+\n+    @Nested\n+    class WhenListenersAreAddedOrRemovedDuringANotification {\n+\n+        @Test\n+        void shouldNotNotifyListenersThatWereRemovedBeforeBeingCalled() {\n+            L list = create(cl1, il1);\n+\n+            list.add((InvalidationListener) obs -> list.remove(cl2));\n+            list.add((InvalidationListener) obs -> list.remove(il2));\n+            list.add(cl2);\n+            list.add(il2);\n+\n+            property.set(\"A\");\n+            notifyListeners(list, property, \"-\");\n+\n+            assertRecords(\n+                \"IL1: invalidated\",\n+                \"CL1: changed from - to A\"\n+            );\n+        }\n+\n+        @Test\n+        void shouldNotNotifyListenersNextTimeWhenTheyWereRemovedAfterTheyWereCalled() {\n+            L list = create(cl1, il1);\n+\n+            list.add(cl2);\n+            list.add(il2);\n+            list.add((ChangeListener<String>) (obs, o, n) -> list.remove(cl2));\n+            list.add((ChangeListener<String>) (obs, o, n) -> list.remove(il2));\n+\n+            property.set(\"A\");\n+            notifyListeners(list, property, \"-\");\n+\n+            assertRecords(\n+                \"IL1: invalidated\",\n+                \"IL2: invalidated\",\n+                \"CL1: changed from - to A\",\n+                \"CL2: changed from - to A\"\n+            );\n+\n+            property.set(\"B\");\n+            notifyListeners(list, property, \"A\");\n+\n+            assertRecords(\n+                \"IL1: invalidated\",\n+                \"CL1: changed from A to B\"\n+            );\n+        }\n+\n+        @Test\n+        void shouldNotNotifyAnyListenersAddedUntilNextNotification() {\n+            L list = create(cl1, il1);\n+\n+            list.add((InvalidationListener) obs -> list.add((ChangeListener<String>) (obs2, o, n) -> records.add(\"CL3: changed from \" + o + \" to \" + n)));\n+            list.add((InvalidationListener) obs -> list.add((InvalidationListener) obs2 -> records.add(\"IL3: invalidated\")));\n+            list.add(cl2);\n+            list.add(il2);\n+\n+            property.set(\"A\");\n+            notifyListeners(list, property, \"-\");\n+\n+            assertRecords(\n+                \"IL1: invalidated\",\n+                \"IL2: invalidated\",\n+                \"CL1: changed from - to A\",\n+                \"CL2: changed from - to A\"\n+            );\n+\n+            property.set(\"B\");\n+            notifyListeners(list, property, \"A\");\n+\n+            assertRecords(\n+                \"IL1: invalidated\",\n+                \"IL2: invalidated\",\n+                \"IL3: invalidated\",\n+                \"CL1: changed from A to B\",\n+                \"CL2: changed from A to B\",\n+                \"CL3: changed from A to B\"\n+            );\n+        }\n+    }\n+\n+    @Test\n+    void shouldNotGetCurrentValueWhenThereAreNoChangeListeners() {\n+        L list = create(il1, il2);\n+\n+        assertEquals(0, getterCalled);\n+\n+        notifyListeners(list, property, \"-\");\n+\n+        assertRecords(\n+            \"IL1: invalidated\",\n+            \"IL2: invalidated\"\n+        );\n+\n+        assertEquals(0, getterCalled);\n+    }\n+\n+    @Test\n+    void shouldNotGetCurrentValueWhenChangeListenersWereRemovedBeforeBeingCalled() {\n+        L list = create(il1, cl1);\n+\n+        list.add((InvalidationListener) obs -> list.remove(cl1));\n+\n+        assertEquals(0, getterCalled);\n+\n+        notifyListeners(list, property, \"-\");\n+\n+        assertRecords(\n+            \"IL1: invalidated\"\n+        );\n+\n+        assertEquals(0, getterCalled);\n+    }\n+\n+    @Nested\n+    class WhenANestedChangeOccurs {\n+\n+        @Test\n+        void shouldAllowSimpleVetoingOfValue() {\n+            BooleanProperty property = new SimpleBooleanProperty(true);\n+\n+            L list = create(il1, il2);\n+\n+            list.add((ChangeListener<Boolean>) (obs, o, n) -> {\n+                records.add(\"CL1: changed from \" + o + \" to \" + n);\n+            });\n+\n+            list.add((ChangeListener<Boolean>) (obs, o, n) -> {\n+                records.add(\"CL2: changed from \" + o + \" to \" + n);\n+\n+                if (n) {  \/\/ This check is normally done by the property\n+                    property.set(false);\n+                    notifyListeners(list, property, n);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Boolean>) (obs, o, n) -> {\n+                records.add(\"CL3: changed from \" + o + \" to \" + n);\n+            });\n+\n+            list.remove(il1);\n+            list.remove(il2);\n+\n+            notifyListeners(list, property, false);  \/\/ triggers change from false to true\n+\n+            \/\/assertConsistentChangeSequence(false);\n+            assertEquals(4, records.size());  \/\/ 2 at top level, 2 nested, third listener not notified (unchanged)\n+        }\n+\n+        @Test\n+        void shouldAllowSimpleVetoingOfValue_2() {\n+            StringProperty property = new SimpleStringProperty(\"B\");\n+\n+            L list = create(il1, il2);\n+\n+            list.add((ChangeListener<String>) (obs, o, n) -> {\n+                records.add(\"CL1: changed from \" + o + \" to \" + n);\n+            });\n+\n+            list.add((ChangeListener<String>) (obs, o, n) -> {\n+                records.add(\"CL2: changed from \" + o + \" to \" + n);\n+\n+                if (!n.equals(\"A\")) {  \/\/ This check is normally done by the property\n+                    property.set(\"A\");\n+                    notifyListeners(list, property, n);\n+                }\n+            });\n+\n+            list.add((ChangeListener<String>) (obs, o, n) -> {\n+                records.add(\"CL3: changed from \" + o + \" to \" + n);\n+            });\n+\n+            list.remove(il1);\n+            list.remove(il2);\n+\n+            notifyListeners(list, property, \"A\");  \/\/ triggers change from A to B\n+\n+            assertConsistentChangeSequence(\"A\");\n+            assertEquals(4, records.size());  \/\/ 2 at top level, 2 nested, third listener not notified (unchanged)\n+        }\n+\n+        \/**\n+         * This tests add two change listeners that will never agree\n+         * on the final value (one sets the value to 2, the other to 3).\n+         * In previous implementations which would notify listeners in\n+         * all cases, even when their value didn't change, this would\n+         * automatically result in a StackOverflowError, alerting the user\n+         * of serious problems.\n+         *\n+         * This implementation has to specifically detect problematic use of\n+         * multiple value modifying listeners in order to alert the user.\n+         *\/\n+        @Test\n+        void shouldDetectNonConvergence() {\n+            LongProperty property = new SimpleLongProperty(1);\n+\n+            L list = create(il1, il2);\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL1: changed from \" + o + \" to \" + n);\n+\n+                if (v != 2) {  \/\/ This check is normally done by the property\n+                    property.set(2);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL2: changed from \" + o + \" to \" + n);\n+\n+                if (v != 3) {  \/\/ This check is normally done by the property\n+                    property.set(3);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                records.add(\"CL3: changed from \" + o + \" to \" + n);\n+            });\n+\n+            StackOverflowError e = assertThrows(StackOverflowError.class, () -> notifyListeners(list, property, 0));\n+\n+            assertEquals(\"non-converging value detected in value modifying listeners on LongProperty [value: 2]; original value was: 0\", e.getMessage());\n+        }\n+\n+        \/**\n+         * A variant of the non-convergence test with three listeners\n+         * that will never agree.\n+         *\/\n+        @Test\n+        void shouldDetectNonConvergence_2() {\n+            LongProperty property = new SimpleLongProperty(1);\n+\n+            L list = create(il1, il2);\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL1: changed from \" + o + \" to \" + n);\n+\n+                if (v < 20) {\n+                    property.set(20);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL2: changed from \" + o + \" to \" + n);\n+\n+                if (v < 30) {\n+                    property.set(30);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL3: changed from \" + o + \" to \" + n);\n+\n+                if (v > 10) {\n+                    property.set(10);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            StackOverflowError e = assertThrows(StackOverflowError.class, () -> notifyListeners(list, property, 0));\n+\n+            assertEquals(\"non-converging value detected in value modifying listeners on LongProperty [value: 30]; original value was: 0\", e.getMessage());\n+        }\n+\n+        \/**\n+         * A variant of the non-convergence test with three listeners\n+         * that will never agree and an additional observing listener.\n+         *\/\n+        @Test\n+        void shouldDetectNonConvergence_3() {\n+            LongProperty property = new SimpleLongProperty(1);\n+\n+            L list = create(il1, il2);\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL1: changed from \" + o + \" to \" + n);\n+\n+                if (v < 20) {\n+                    property.set(20);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL2: changed from \" + o + \" to \" + n);\n+\n+                if (v < 30) {\n+                    property.set(30);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL3: changed from \" + o + \" to \" + n);\n+\n+                if (v > 10) {\n+                    property.set(10);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                records.add(\"CL4: changed from \" + o + \" to \" + n);\n+            });\n+\n+            StackOverflowError e = assertThrows(StackOverflowError.class, () -> notifyListeners(list, property, 0));\n+\n+            assertEquals(\"non-converging value detected in value modifying listeners on LongProperty [value: 30]; original value was: 0\", e.getMessage());\n+        }\n+\n+        \/**\n+         * A single listener that keeps changing values. This variant results in an actual\n+         * StackOverflowError.\n+         *\/\n+        @Test\n+        void shouldDetectNonConvergence_4() {\n+            LongProperty property = new SimpleLongProperty(1);\n+\n+            L list = create(il1, il2);\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL1: changed from \" + o + \" to \" + n);\n+\n+                property.set(5 + (v % 3));\n+                notifyListeners(list, property, v);\n+            });\n+\n+            StackOverflowError e = assertThrows(StackOverflowError.class, () -> notifyListeners(list, property, 0));\n+\n+            assertNull(e.getMessage());  \/\/ this was an actual StackOverflowError, and so has no message\n+        }\n+\n+        \/**\n+         * This test adds four change listeners that can't easily agree on their final\n+         * value. They're looking for a number divisible by 2, 3, 5 and 7, and will keep\n+         * incrementing the value by 1 until they all agree. The final value should be\n+         * 210, which matches the above criteria.\n+         *\/\n+        @Test\n+        void shouldSendChangesThatMakeSense() {\n+            LongProperty property = new SimpleLongProperty(1);\n+            L list = create(il1, il2);\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL1: changed from \" + o + \" to \" + n);\n+\n+                if (v % 5 != 0) {\n+                    property.set(v + 1);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL2: changed from \" + o + \" to \" + n);\n+\n+                if (v % 2 != 0) {\n+                    property.set(v + 1);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL3: changed from \" + o + \" to \" + n);\n+\n+                if (v % 3 != 0) {\n+                    property.set(v + 1);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL4: changed from \" + o + \" to \" + n);\n+\n+                if (v % 7 != 0) {\n+                    property.set(v + 1);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            notifyListeners(list, property, 0);\n+\n+            assertConsistentChangeSequence(\"210\");\n+            assertEquals(700, records.size());  \/\/ it should be 280 changes + 420 invalidations; 420 because 210 changes * 2 invalidation listeners\n+        }\n+\n+        \/**\n+         * This test adds a mix of listeners that can't easily agree on their final\n+         * value. They're looking for a number divisible by 2, 3, 5 and 7, and will keep\n+         * incrementing the value by 1 until they all agree. The final value should be\n+         * 210, which matches the above criteria.\n+         *\/\n+        @Test\n+        void shouldSendChangesThatMakeSense_VariantAMixOfListeners() {\n+            LongProperty property = new SimpleLongProperty(1);\n+            L list = create(il1, il2);\n+\n+            list.add((InvalidationListener) obs -> {\n+                long v = property.get();  \/\/ act as change listener\n+\n+                records.add(\"IL3: current value \" + v);\n+\n+                if (v % 5 != 0) {\n+                    property.set(v + 1);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((InvalidationListener) obs -> {\n+                long v = property.get();  \/\/ act as change listener\n+\n+                records.add(\"IL4: current value \" + v);\n+\n+                if (v % 2 != 0) {\n+                    property.set(v + 1);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL3: changed from \" + o + \" to \" + n);\n+\n+                if (v % 3 != 0) {\n+                    property.set(v + 1);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            list.add((ChangeListener<Number>) (obs, o, n) -> {\n+                long v = n.longValue();\n+\n+                records.add(\"CL4: changed from \" + o + \" to \" + n);\n+\n+                if (v % 7 != 0) {\n+                    property.set(v + 1);\n+                    notifyListeners(list, property, v);\n+                }\n+            });\n+\n+            notifyListeners(list, property, 0);\n+\n+            assertConsistentChangeSequence(\"210\");\n+\n+            \/*\n+             * The total of 700 comes from:\n+             * - 210 changes per invalidation listener for the first two listeners that do nothing (il1, il2)\n+             * - 280 changes total for all listeners that trigger nested changes (regardless of listener type)\n+             *\/\n+\n+            assertEquals(700, records.size());\n+        }\n+    }\n+\n+\n+    private void assertRecords(String... expected) {\n+        assertEquals(Arrays.asList(expected), records);\n+        records.clear();\n+    }\n+\n+    private Pattern PATTERN = Pattern.compile(\"(?<listener>.*): changed from (?<old>.*) to (?<new>.*)\");\n+    private Pattern INVALIDATION_PATTERN = Pattern.compile(\"(?<listener>.*): current value (?<current>.*)\");\n+\n+    \/**\n+     * This method checks that all changes follow the following rules:\n+     * - The old and new value cannot be equal\n+     * - The previous new value must be equal to the old value\n+     * - The final value is the one that is expected\n+     *\n+     * @param expectedFinalValue the final value that is expected\n+     *\/\n+    private void assertConsistentChangeSequence(String expectedFinalValue) {\n+        Map<String, String> oldValues = new HashMap<>();\n+\n+        for (String record : records) {\n+            Matcher matcher = PATTERN.matcher(record);\n+\n+            if (matcher.matches()) {\n+                String name = matcher.group(\"listener\");\n+                String o = matcher.group(\"old\");\n+                String n = matcher.group(\"new\");\n+\n+                assertNotEquals(o, n, \"Listener \" + name + \" received a change that wasn't a change: \" + record);\n+\n+                if (oldValues.containsKey(name)) {\n+                    assertEquals(o, oldValues.get(name), \"Listener \" + name + \" received an incorrect old value; expected \" + oldValues.get(name) + \" but was: \" + record);\n+                }\n+\n+                oldValues.put(name, n);\n+            }\n+        }\n+\n+        for (String record : records) {\n+            Matcher matcher = INVALIDATION_PATTERN.matcher(record);\n+\n+            if (matcher.matches()) {\n+                String name = matcher.group(\"listener\");\n+                String c = matcher.group(\"current\");\n+\n+                oldValues.put(name, c);\n+            }\n+        }\n+\n+        for (Entry<String, String> entry : oldValues.entrySet()) {\n+            assertEquals(expectedFinalValue, entry.getValue(), \"Listener \" + entry.getKey() + \" had as final value: \" + entry.getValue() + \", but expected was: \" + expectedFinalValue);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ListenerListTestBase.java","additions":677,"deletions":0,"binary":false,"changes":677,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.binding;\n+\n+import com.sun.javafx.binding.ListenerManager;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+public class ListenerManagerTest implements ObservableValue<String> {\n+    private final List<String> notifications = new ArrayList<>();\n+\n+    private final ChangeListener<String> cl1 = (obs, o, n) -> notifications.add(\"CL1: \" + o + \" -> \" + n);\n+    private final ChangeListener<String> cl2 = (obs, o, n) -> notifications.add(\"CL2: \" + o + \" -> \" + n);\n+\n+    private Object data;\n+    private String value = \"0\";\n+\n+    private final ListenerManager<String, ListenerManagerTest> helper = new ListenerManager<>() {\n+        @Override\n+        protected Object getData(ListenerManagerTest instance) {\n+            return data;\n+        }\n+\n+        @Override\n+        protected void setData(ListenerManagerTest instance, Object data) {\n+            ListenerManagerTest.this.data = data;\n+        }\n+    };\n+\n+    @Test\n+    void shouldNotifyChangeListeners() {\n+        value = \"A\";\n+\n+        helper.fireValueChanged(this, \"0\", data);  \/\/ checks if passing null data works fine\n+\n+        assertEquals(List.of(), notifications);  \/\/ expect nothing, as there are no listeners\n+\n+        helper.addListener(this, cl1);\n+\n+        assertNotNull(data);\n+\n+        value = \"B\";\n+\n+        helper.fireValueChanged(this, \"A\", data);\n+\n+        assertEquals(List.of(\"CL1: A -> B\"), notifications);\n+\n+        helper.addListener(this, cl2);\n+\n+        notifications.clear();\n+        value = \"C\";\n+\n+        helper.fireValueChanged(this, \"B\", data);\n+\n+        assertEquals(List.of(\"CL1: B -> C\", \"CL2: B -> C\"), notifications);\n+\n+        helper.removeListener(this, cl1);\n+\n+        notifications.clear();\n+        value = \"D\";\n+\n+        helper.fireValueChanged(this, \"C\", data);\n+\n+        assertEquals(List.of(\"CL2: C -> D\"), notifications);\n+\n+        notifications.clear();\n+        value = \"E\";\n+\n+        helper.fireValueChanged(this, \"D\", data);\n+\n+        assertEquals(List.of(\"CL2: D -> E\"), notifications);\n+    }\n+\n+    @Override\n+    public void addListener(InvalidationListener listener) {\n+    }\n+\n+    @Override\n+    public void removeListener(InvalidationListener listener) {\n+    }\n+\n+    @Override\n+    public void addListener(ChangeListener<? super String> listener) {\n+    }\n+\n+    @Override\n+    public void removeListener(ChangeListener<? super String> listener) {\n+    }\n+\n+    @Override\n+    public String getValue() {\n+        return value;\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ListenerManagerTest.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.binding;\n+\n+import com.sun.javafx.binding.OldValueCachingListenerList;\n+\n+import javafx.beans.value.ObservableValue;\n+\n+public class OldValueCachingListenerListTest extends ListenerListTestBase<OldValueCachingListenerList<?>> {\n+\n+    @Override\n+    protected OldValueCachingListenerList<?> create(Object listener1, Object listener2) {\n+        return new OldValueCachingListenerList<>(listener1, listener2);\n+    }\n+\n+    @Override\n+    protected <T> void notifyListeners(OldValueCachingListenerList<?> list, ObservableValue<? extends T> property, T oldValue) {\n+        @SuppressWarnings(\"unchecked\")\n+        OldValueCachingListenerList<T> oldValueCachingListenerList = (OldValueCachingListenerList<T>) list;\n+\n+        oldValueCachingListenerList.putLatestValue(oldValue);\n+        oldValueCachingListenerList.notifyListeners(property);\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/OldValueCachingListenerListTest.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.binding;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.sun.javafx.binding.OldValueCachingListenerManager;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+public class OldValueCachingListenerManagerTest implements ObservableValue<String> {\n+    private final List<String> notifications = new ArrayList<>();\n+\n+    private final ChangeListener<String> cl1 = (obs, o, n) -> notifications.add(\"CL1: \" + o + \" -> \" + n);\n+    private final ChangeListener<String> cl2 = (obs, o, n) -> notifications.add(\"CL2: \" + o + \" -> \" + n);\n+\n+    private Object data;\n+    private String value = \"0\";\n+\n+    private final OldValueCachingListenerManager<String, OldValueCachingListenerManagerTest> helper = new OldValueCachingListenerManager<>() {\n+        @Override\n+        protected Object getData(OldValueCachingListenerManagerTest instance) {\n+            return data;\n+        }\n+\n+        @Override\n+        protected void setData(OldValueCachingListenerManagerTest instance, Object data) {\n+            OldValueCachingListenerManagerTest.this.data = data;\n+        }\n+    };\n+\n+    @Test\n+    void shouldNotifyChangeListeners() {\n+        value = \"A\";\n+\n+        helper.fireValueChanged(this, data);  \/\/ checks if passing null data works fine\n+\n+        assertEquals(List.of(), notifications);  \/\/ expect nothing, as there are no listeners\n+\n+        helper.addListener(this, cl1);\n+\n+        assertNotNull(data);\n+\n+        value = \"B\";\n+\n+        helper.fireValueChanged(this, data);\n+\n+        assertEquals(List.of(\"CL1: A -> B\"), notifications);\n+\n+        helper.addListener(this, cl2);\n+\n+        notifications.clear();\n+        value = \"C\";\n+\n+        helper.fireValueChanged(this, data);\n+\n+        assertEquals(List.of(\"CL1: B -> C\", \"CL2: B -> C\"), notifications);\n+\n+        helper.removeListener(this, cl1);\n+\n+        notifications.clear();\n+        value = \"D\";\n+\n+        helper.fireValueChanged(this, data);\n+\n+        assertEquals(List.of(\"CL2: C -> D\"), notifications);\n+\n+        notifications.clear();\n+        value = \"E\";\n+\n+        helper.fireValueChanged(this, data);\n+\n+        assertEquals(List.of(\"CL2: D -> E\"), notifications);\n+    }\n+\n+    @Override\n+    public void addListener(InvalidationListener listener) {\n+    }\n+\n+    @Override\n+    public void removeListener(InvalidationListener listener) {\n+    }\n+\n+    @Override\n+    public void addListener(ChangeListener<? super String> listener) {\n+    }\n+\n+    @Override\n+    public void removeListener(ChangeListener<? super String> listener) {\n+    }\n+\n+    @Override\n+    public String getValue() {\n+        return value;\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/OldValueCachingListenerManagerTest.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,786 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.beans;\n+\n+import java.lang.Thread.UncaughtExceptionHandler;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.Observable;\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.Property;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.beans.property.SimpleFloatProperty;\n+import javafx.beans.property.SimpleIntegerProperty;\n+import javafx.beans.property.SimpleLongProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class ObservableValueTest {\n+    private static final int[] PATTERN = new int[] {1, 2, 0, 50, 3, 7};\n+\n+    \/*\n+     * ObservableValue cases to test:\n+     *\/\n+    static Stream<Arguments> inputs() {\n+        List<Case<?, ?>> cases = List.of(\n+            \/\/ cases for properties:\n+            Case.of(new SimpleBooleanProperty(), true, false),\n+            Case.of(new SimpleIntegerProperty(), 42, 47),\n+            Case.of(new SimpleLongProperty(), 42L, 47L),\n+            Case.of(new SimpleFloatProperty(), 0.5f, 1.0f),\n+            Case.of(new SimpleDoubleProperty(), 0.5, 1.0),\n+            Case.of(new SimpleStringProperty(), \"A\", \"B\"),\n+            Case.of(new SimpleObjectProperty<>(), \"A\", \"B\"),\n+\n+            \/\/ cases for bindings:\n+            Case.of(new SimpleBooleanProperty(), false, true, p -> p.not(), (p, v) -> p.setValue(!v)),\n+            Case.of(new SimpleIntegerProperty(), 42, 47, p -> p.add(2), (p, v) -> p.setValue(v.intValue() - 2)),\n+            Case.of(new SimpleLongProperty(), 42L, 47L, p -> p.add(2), (p, v) -> p.setValue(v.longValue() - 2)),\n+            Case.of(new SimpleFloatProperty(), 0.5f, 1.0f, p -> p.add(2), (p, v) -> p.setValue(v.floatValue() - 2)),\n+            Case.of(new SimpleDoubleProperty(), 0.5, 1.0, p -> p.add(2), (p, v) -> p.setValue(v.doubleValue() - 2)),\n+            Case.of(new SimpleStringProperty(), \"A!\", \"B!\", p -> p.concat(\"!\"), (p, v) -> p.setValue(v.substring(0, 1))),\n+            Case.of(new SimpleObjectProperty<>(), \"A!\", \"B!\", p -> Bindings.createObjectBinding(() -> (p.get() + \"!\").intern(), p), (p, v) -> p.setValue(v.substring(0, 1).intern())),  \/\/ intern() used to make sure ObjectBinding equality check works for this test\n+\n+            \/\/ cases for lazy bindings:\n+            Case.of(new SimpleObjectProperty<>(), 10, 12, p -> p.map(x -> x * 2), (p, v) -> p.setValue(v \/ 2))\n+        );\n+\n+        return cases.stream().map(c -> Arguments.of(new Action<>(c.observableValue), c.primaryValue, c.alternativeValue, c.valueSetter));\n+    }\n+\n+    \/*\n+     * Tests if the embedded ObservableValue correctly rejects null listener add\/removals.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldRejectNullListener(Action<T> action) {\n+        assertThrows(NullPointerException.class, () -> action.addListener((InvalidationListener)null));\n+        assertThrows(NullPointerException.class, () -> action.addListener((ChangeListener<T>)null));\n+        assertThrows(NullPointerException.class, () -> action.removeListener((InvalidationListener)null));\n+        assertThrows(NullPointerException.class, () -> action.removeListener((ChangeListener<T>)null));\n+    }\n+\n+    \/*\n+     * Tests if the embedded ObservableValue correctly ignores removal of non-existing listeners, regardless\n+     * of how many listeners are currently registered. As the same ObservableValue is used throughout the\n+     * test, also stresses the add\/remove listener code.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldIgnoreRemovingNonExistingListener(Action<T> action) {\n+        for (int[] counts : new Combinations(PATTERN)) {\n+            int invalidationListenerCount = counts[0];\n+            int changeListenerCount = counts[1];\n+\n+            action.setListenerCounts(invalidationListenerCount, changeListenerCount);\n+\n+            action.removeListener(obs -> {});\n+            action.removeListener((obs, old, current) -> {});\n+        }\n+    }\n+\n+    \/*\n+     * Tests if the embedded ObservableValue sends the correct Change and Invalidation events with various\n+     * combinations of invalidation and change listeners. As the same ObservableValue is used throughout the\n+     * test, also stresses the add\/remove listener code.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldSendCorrectEventsWithSeveralInvalidationAndChangeListeners(Action<T> action, T value1, T value2, Consumer<T> valueSetter) {\n+        for (int[] counts : new Combinations(PATTERN)) {\n+            int invalidationListenerCount = counts[0];\n+            int changeListenerCount = counts[1];\n+\n+            action.setListenerCounts(invalidationListenerCount, changeListenerCount);\n+\n+            valueSetter.accept(value2);\n+            action.assertEvents(\n+                changeListenerCount == 0 ? null : \"Change of %c from \" + value1 + \" to \" + value2,\n+                invalidationListenerCount == 0 ? null : \"Invalidation of %i\"\n+            );\n+\n+            if (changeListenerCount == 0) {\n+                valueSetter.accept(value1);\n+                action.assertEvents();  \/\/ when there are no change listeners, setting a different value (while invalid) should not trigger any events\n+            }\n+\n+            valueSetter.accept(value2);\n+            action.assertEvents();\n+\n+            assertEquals(value2, action.getValue());\n+            action.assertEvents();\n+\n+            valueSetter.accept(value2);\n+            action.assertEvents();\n+\n+            valueSetter.accept(value1);\n+            action.assertEvents(\n+                changeListenerCount == 0 ? null : \"Change of %c from \" + value2 + \" to \" + value1,\n+                invalidationListenerCount == 0 ? null : \"Invalidation of %i\"\n+            );\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldSendCorrectEventsWithSeveralInvalidationAndChangeListenersThatThrowExceptions(Action<T> action, T value1, T value2, Consumer<T> valueSetter) {\n+        AtomicInteger exceptions = new AtomicInteger();\n+        UncaughtExceptionHandler oldExceptionHandler = Thread.currentThread().getUncaughtExceptionHandler();\n+\n+        try {\n+            Thread.currentThread().setUncaughtExceptionHandler((t, e) -> exceptions.addAndGet(1));\n+\n+            for (int[] counts : new Combinations(PATTERN)) {\n+                int invalidationListenerCount = counts[0];\n+                int changeListenerCount = counts[1];\n+\n+                exceptions.set(0);\n+\n+                action.setThrowingListenerCounts(invalidationListenerCount, changeListenerCount);\n+\n+                assertEquals(0, exceptions.getAndSet(0));\n+\n+                valueSetter.accept(value2);\n+                action.assertEvents(\n+                    changeListenerCount == 0 ? null : \"Change of %c from \" + value1 + \" to \" + value2,\n+                    invalidationListenerCount == 0 ? null : \"Invalidation of %i\"\n+                );\n+                assertEquals(changeListenerCount + invalidationListenerCount, exceptions.getAndSet(0));\n+\n+                if (changeListenerCount == 0) {\n+                    valueSetter.accept(value1);\n+                    action.assertEvents();  \/\/ when there are no change listeners, setting a different value (while invalid) should not trigger any events\n+                    assertEquals(0, exceptions.getAndSet(0));\n+                }\n+\n+                valueSetter.accept(value2);\n+                action.assertEvents();\n+                assertEquals(0, exceptions.getAndSet(0));\n+\n+                assertEquals(value2, action.getValue());\n+                action.assertEvents();\n+                assertEquals(0, exceptions.getAndSet(0));\n+\n+                valueSetter.accept(value2);\n+                action.assertEvents();\n+                assertEquals(0, exceptions.getAndSet(0));\n+\n+                valueSetter.accept(value1);\n+                action.assertEvents(\n+                    changeListenerCount == 0 ? null : \"Change of %c from \" + value2 + \" to \" + value1,\n+                    invalidationListenerCount == 0 ? null : \"Invalidation of %i\"\n+                );\n+                assertEquals(changeListenerCount + invalidationListenerCount, exceptions.getAndSet(0));\n+            }\n+        }\n+        finally {\n+            Thread.currentThread().setUncaughtExceptionHandler(oldExceptionHandler);\n+        }\n+    }\n+\n+    \/*\n+     * Tests if the embedded ObservableValue sends sensible change events when a nested change occurs.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldSendCorrectNestedEvents(Action<T> action, T value1, T value2, Consumer<T> valueSetter) {\n+        List<Record> records = new ArrayList<>();\n+\n+        \/*\n+         * Create three listeners, with the \"middle\" one modifying the value back to value1.\n+         *\/\n+\n+        action.addListener((obs, old, current) -> records.add(new Record.Change(\"A\", old, current)));\n+        action.addListener((obs, old, current) -> {\n+            records.add(new Record.Change(\"B\", old, current));\n+\n+            if (current.equals(value2)) {\n+                valueSetter.accept(value1);\n+            }\n+        });\n+        action.addListener((obs, old, current) -> records.add(new Record.Change(\"C\", old, current)));\n+\n+        \/*\n+         * Start test:\n+         *\/\n+\n+        valueSetter.accept(value2);\n+\n+        assertConsistentChangeSequence(records, value1, value1, Set.of(value1, value2));\n+    }\n+\n+    \/*\n+     * Tests if the embedded ObservableValue sends sensible change events when a nested change occurs\n+     * when there is only one listener.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldSendCorrectNestedEventsWithOneListener(Action<T> action, T value1, T value2, Consumer<T> valueSetter) {\n+        List<Record> records = new ArrayList<>();\n+\n+        \/*\n+         * Create one listener, which modifies the value back to value1.\n+         *\/\n+\n+        action.addListener((obs, old, current) -> {\n+            records.add(new Record.Change(\"B\", old, current));\n+\n+            if (current.equals(value2)) {\n+                valueSetter.accept(value1);\n+            }\n+        });\n+\n+        \/*\n+         * Start test:\n+         *\/\n+\n+        valueSetter.accept(value2);\n+\n+        assertConsistentChangeSequence(records, value1, value2, Set.of(value1, value2));\n+    }\n+\n+    \/*\n+     * Tests if the embedded ObservableValue sends sensible change events when a nested change occurs\n+     * and the first listener was removed.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldSendCorrectNestedEventsWhenFirstListenerRemoved(Action<T> action, T value1, T value2, Consumer<T> valueSetter) {\n+        List<Record> records = new ArrayList<>();\n+\n+        \/*\n+         * Create three listeners, with the \"middle\" one removing the first listener and modifying the\n+         * value back to value1.\n+         *\/\n+\n+        ChangeListener<? super T> firstListener = (obs, old, current) -> records.add(new Record.Change(\"A\", old, current));\n+\n+        action.addListener(firstListener);\n+        action.addListener((obs, old, current) -> {\n+            records.add(new Record.Change(\"B\", old, current));\n+\n+            if (Objects.equals(current, value2)) {\n+                action.removeListener(firstListener);\n+                valueSetter.accept(value1);\n+            }\n+        });\n+        action.addListener((obs, old, current) -> records.add(new Record.Change(\"C\", old, current)));\n+\n+        \/*\n+         * Start test:\n+         *\/\n+\n+        valueSetter.accept(value2);\n+\n+        assertConsistentChangeSequence(records, value1, value1, Set.of(value1, value2));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldOnlyNotifyNonRemovedChangeListeners(Action<T> action, T value1, T value2, Consumer<T> valueSetter) {\n+        AtomicInteger calls = new AtomicInteger();\n+\n+        ChangeListener<T> changeListener = new ChangeListener<>() {\n+            @Override\n+            public void changed(ObservableValue<? extends T> obs, T old, T current) {\n+                calls.addAndGet(1);\n+\n+                action.removeListener(this);\n+                action.removeListener(this);\n+                action.addListener(this);\n+            }\n+        };\n+\n+        for (int i = 0; i < 100; i++) {\n+            action.addListener(changeListener);\n+        }\n+\n+        assertCalls(\n+            i -> valueSetter.accept(action.getValue().equals(value1) ? value2 : value1),\n+            calls,\n+            new int[] {50, 25, 13, 6, 3, 2, 1, 1, 1}  \/\/ won't reach 0 as a new listener is added each time\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldOnlyNotifyNonRemovedChangeListeners_2(Action<T> action, T value1, T value2, Consumer<T> valueSetter) {\n+        AtomicInteger calls = new AtomicInteger();\n+\n+        ChangeListener<T> changeListener = new ChangeListener<>() {\n+            @Override\n+            public void changed(ObservableValue<? extends T> obs, T old, T current) {\n+                if (calls.getAndAdd(1) % 2 == 0) {\n+                    action.removeListener(this);\n+                }\n+            }\n+        };\n+\n+        for (int i = 0; i < 100; i++) {\n+            action.addListener(changeListener);\n+        }\n+\n+        assertCalls(\n+            i -> valueSetter.accept(action.getValue().equals(value1) ? value2 : value1),\n+            calls,\n+            new int[] {100, 50, 25, 12, 6, 3, 1, 0}\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldOnlyNotifyNonRemovedChangeListeners_3(Action<T> action, T value1, T value2, Consumer<T> valueSetter) {\n+        AtomicInteger calls = new AtomicInteger();\n+\n+        ChangeListener<T> changeListener = new ChangeListener<>() {\n+            @Override\n+            public void changed(ObservableValue<? extends T> obs, T old, T current) {\n+                if (calls.getAndAdd(1) == 0) {\n+                    action.removeListener(this);\n+                    action.removeListener(this);\n+                    action.removeListener(this);\n+                }\n+            }\n+        };\n+\n+        for (int i = 0; i < 12; i++) {\n+            action.addListener(changeListener);\n+        }\n+\n+        assertCalls(\n+            i -> valueSetter.accept(action.getValue().equals(value1) ? value2 : value1),\n+            calls,\n+            new int[] {10, 7, 4, 1, 0}\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldOnlyNotifyNonRemovedInvalidationListeners(Action<T> action, T value1, T value2, Consumer<T> valueSetter) {\n+        AtomicInteger calls = new AtomicInteger();\n+\n+        InvalidationListener invalidationListener = new InvalidationListener() {\n+            @Override\n+            public void invalidated(Observable obs) {\n+                calls.addAndGet(1);\n+\n+                action.removeListener(this);\n+                action.removeListener(this);\n+                action.addListener(this);\n+            }\n+        };\n+\n+        for (int i = 0; i < 100; i++) {\n+            action.addListener(invalidationListener);\n+        }\n+\n+        assertCalls(\n+            i -> valueSetter.accept(action.getValue().equals(value1) ? value2 : value1),\n+            calls,\n+            new int[] {50, 25, 13, 6, 3, 2, 1, 1, 1}  \/\/ won't reach 0 as a new listener is added each time\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldOnlyNotifyNonRemovedInvalidationListeners_2(Action<T> action, T value1, T value2, Consumer<T> valueSetter) {\n+        AtomicInteger calls = new AtomicInteger();\n+\n+        InvalidationListener invalidationListener = new InvalidationListener() {\n+            @Override\n+            public void invalidated(Observable obs) {\n+                if (calls.getAndAdd(1) % 2 == 0) {\n+                    action.removeListener(this);\n+                }\n+            }\n+        };\n+\n+        for (int i = 0; i < 100; i++) {\n+            action.addListener(invalidationListener);\n+        }\n+\n+        assertCalls(\n+            i -> valueSetter.accept(action.getValue().equals(value1) ? value2 : value1),\n+            calls,\n+            new int[] {100, 50, 25, 12, 6, 3, 1, 0}\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldOnlyNotifyNonRemovedInvalidationListeners_3(Action<T> action, T value1, T value2, Consumer<T> valueSetter) {\n+        AtomicInteger calls = new AtomicInteger();\n+        InvalidationListener listener = new InvalidationListener() {\n+            @Override\n+            public void invalidated(Observable obs) {\n+                if (calls.getAndAdd(1) == 0) {\n+                    action.removeListener(this);\n+                    action.removeListener(this);\n+                    action.removeListener(this);\n+                }\n+            }\n+        };\n+\n+        for (int i = 0; i < 12; i++) {\n+            action.addListener(listener);\n+        }\n+\n+        assertCalls(\n+            i -> valueSetter.accept(action.getValue().equals(value1) ? value2 : value1),\n+            calls,\n+            new int[] {10, 7, 4, 1, 0}\n+        );\n+    }\n+\n+    private static void assertCalls(Consumer<Integer> step, AtomicInteger calls, int... expectedCalls) {\n+        for(int i = 0; i < expectedCalls.length; i++) {\n+            step.accept(i);\n+            assertEquals(expectedCalls[i], calls.getAndSet(0));\n+        }\n+    }\n+\n+    static class Action<T> implements ObservableValue<T> {\n+        private final List<InvalidationListener> invalidationListeners = new ArrayList<>();\n+        private final List<ChangeListener<Object>> changeListeners = new ArrayList<>();\n+        private final List<String> records = new ArrayList<>();\n+        private final ObservableValue<T> observableValue;\n+\n+        Action(ObservableValue<T> observableValue) {\n+            this.observableValue = observableValue;\n+        }\n+\n+        @Override\n+        public void addListener(InvalidationListener listener) {\n+            observableValue.addListener(listener);\n+        }\n+\n+        @Override\n+        public void addListener(ChangeListener<? super T> listener) {\n+            observableValue.addListener(listener);\n+        }\n+\n+        @Override\n+        public void removeListener(InvalidationListener listener) {\n+            observableValue.removeListener(listener);\n+        }\n+\n+        @Override\n+        public void removeListener(ChangeListener<? super T> listener) {\n+            observableValue.removeListener(listener);\n+        }\n+\n+        @Override\n+        public T getValue() {\n+            return observableValue.getValue();\n+        }\n+\n+        void setListenerCounts(int invalidationListenerCount, int changeListenerCount) {\n+            for(int i = invalidationListeners.size() - 1; i >= invalidationListenerCount; --i) {\n+                InvalidationListener invalidationListener = invalidationListeners.get(i);\n+\n+                invalidationListeners.remove(invalidationListener);\n+                observableValue.removeListener(invalidationListener);\n+            }\n+\n+            for(int i = changeListeners.size() - 1; i >= changeListenerCount; --i) {\n+                ChangeListener<Object> changeListener = changeListeners.get(i);\n+\n+                changeListeners.remove(changeListener);\n+                observableValue.removeListener(changeListener);\n+            }\n+\n+            for(int i = invalidationListeners.size(); i < invalidationListenerCount; i++) {\n+                int j = i;\n+\n+                InvalidationListener invalidationListener = obs -> {\n+                    records.add(\"Invalidation of \" + j);\n+                };\n+\n+                invalidationListeners.add(invalidationListener);\n+                observableValue.addListener(invalidationListener);\n+            }\n+\n+            for(int i = changeListeners.size(); i < changeListenerCount; i++) {\n+                int j = i;\n+\n+                ChangeListener<Object> changeListener = (obs, old, current) -> {\n+                    records.add(\"Change of \" + j + \" from \" + old + \" to \" + current);\n+                };\n+\n+                changeListeners.add(changeListener);\n+                observableValue.addListener(changeListener);\n+            }\n+        }\n+\n+        void setThrowingListenerCounts(int invalidationListenerCount, int changeListenerCount) {\n+            for(int i = invalidationListeners.size() - 1; i >= invalidationListenerCount; --i) {\n+                InvalidationListener invalidationListener = invalidationListeners.get(i);\n+\n+                invalidationListeners.remove(invalidationListener);\n+                observableValue.removeListener(invalidationListener);\n+            }\n+\n+            for(int i = changeListeners.size() - 1; i >= changeListenerCount; --i) {\n+                ChangeListener<Object> changeListener = changeListeners.get(i);\n+\n+                changeListeners.remove(changeListener);\n+                observableValue.removeListener(changeListener);\n+            }\n+\n+            for(int i = invalidationListeners.size(); i < invalidationListenerCount; i++) {\n+                int j = i;\n+\n+                InvalidationListener invalidationListener = obs -> {\n+                    records.add(\"Invalidation of \" + j);\n+                    throw new RuntimeException(\"boo\");\n+                };\n+\n+                invalidationListeners.add(invalidationListener);\n+                observableValue.addListener(invalidationListener);\n+            }\n+\n+            for(int i = changeListeners.size(); i < changeListenerCount; i++) {\n+                int j = i;\n+\n+                ChangeListener<Object> changeListener = (obs, old, current) -> {\n+                    records.add(\"Change of \" + j + \" from \" + old + \" to \" + current);\n+                    throw new RuntimeException(\"boo\");\n+                };\n+\n+                changeListeners.add(changeListener);\n+                observableValue.addListener(changeListener);\n+            }\n+        }\n+\n+        void assertEvents(String... expectedTemplates) {\n+            for(String expectedTemplate : expectedTemplates) {\n+                if(expectedTemplate == null) {\n+                    continue;\n+                }\n+\n+                if(expectedTemplate.contains(\"%c\")) {\n+                    if(changeListeners.isEmpty()) {\n+                        fail(\"Expected \\\"\" + expectedTemplate + \"\\\" to match at least once, but it didn't for: \" + this);\n+                    }\n+\n+                    for(int i = 0; i < changeListeners.size(); i++) {\n+                        String expected = expectedTemplate.replaceAll(\"%c\", \"\" + i);\n+                        assertTrue(records.remove(expected), () -> \"Expected \\\"\" + expected + \"\\\" but found none for: \" + this);\n+                    }\n+                }\n+                else if(expectedTemplate.contains(\"%i\")) {\n+                    if(invalidationListeners.isEmpty()) {\n+                        fail(\"Expected \\\"\" + expectedTemplate + \"\\\" to match at least once, but it didn't for: \" + this);\n+                    }\n+\n+                    for(int i = 0; i < invalidationListeners.size(); i++) {\n+                        String expected = expectedTemplate.replaceAll(\"%i\", \"\" + i);\n+                        assertTrue(records.remove(expected), () -> \"Expected \\\"\" + expected + \"\\\" but found none for: \" + this);\n+                    }\n+                }\n+            }\n+\n+            if(!records.isEmpty()) {\n+                fail(\"Did not expect: \" + records + \" for: \" + this);\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return observableValue + \"[il=\" + invalidationListeners.size() + \", cl=\" + changeListeners.size() + \"]\";\n+        }\n+    }\n+\n+    static class Case<P extends Property<T>, T> {\n+        final T primaryValue;\n+        final T alternativeValue;\n+        final Consumer<T> valueSetter;\n+        final ObservableValue<? super T> observableValue;\n+\n+        public Case(P property, T primaryValue, T alternativeValue, Function<P, ObservableValue<? super T>> modifier, BiConsumer<P, T> valueSetter) {\n+            this.primaryValue = primaryValue;\n+            this.alternativeValue = alternativeValue;\n+            this.valueSetter = (T v) -> valueSetter.accept(property, v);\n+            this.observableValue = modifier.apply(property);\n+\n+            this.valueSetter.accept(primaryValue);\n+        }\n+\n+        static <P extends Property<T>, T> Case<P, T> of(P property, T primaryValue, T alternativeValue, Function<P, ObservableValue<? super T>> modifier, BiConsumer<P, T> valueSetter) {\n+            return new Case<>(property, primaryValue, alternativeValue, modifier, valueSetter);\n+        }\n+\n+        static <P extends Property<T>, T> Case<P, T> of(P property, T primaryValue, T alternativeValue) {\n+            return new Case<>(property, primaryValue, alternativeValue, p -> p, (p, v) -> p.setValue(v));\n+        }\n+    }\n+\n+    \/**\n+     * Takes a list of values and creates an iterator of pairs of those values. The iterator\n+     * does not only return all possible pair combinations, but also different transitions between\n+     * two pairs. Effectively, given x values it returns x^3 combinations.\n+     *\/\n+    private static class Combinations implements Iterable<int[]> {\n+        private final int[] values;\n+\n+        public Combinations(int[] values) {\n+            this.values = values;\n+        }\n+\n+        @Override\n+        public Iterator<int[]> iterator() {\n+            return new Combinator(values);\n+        }\n+    }\n+\n+    private static class Combinator implements Iterator<int[]> {\n+        private final int[] values;\n+        private final int m;\n+\n+        private int s;\n+        private int x;\n+        private int y;\n+\n+        public Combinator(int[] values) {\n+            this.values = values;\n+            this.m = values.length;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return y < m;\n+        }\n+\n+        @Override\n+        public int[] next() {\n+            if(!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+\n+            int[] next = new int[] {values[x], values[(y + s) % m]};\n+\n+            if(++s == m) {\n+                s = 0;\n+\n+                if(++x == m) {\n+                    x = 0;\n+                    y++;\n+                }\n+            }\n+\n+            return next;\n+        }\n+    }\n+\n+    sealed interface Record {\n+        String identifier();\n+\n+        record Added(String identifier) implements Record {}\n+        record Removed(String identifier) implements Record {}\n+        record Change(String identifier, Object old, Object current) implements Record {\n+            @Override\n+            public String toString() {\n+                return \"[\" + identifier + \": Changed from \" + old + \" to \" + current + \"]\";\n+            }\n+        }\n+    }\n+\n+    private static void assertConsistentChangeSequence(List<Record> records, Object expectedFirstValue, Object expectedLastValue, Set<Object> inputValidValues) {\n+        Set<Object> validValues = new HashSet<>(inputValidValues);  \/\/ convert to regular set as Set#of is being obnoxious about calling contains(null)\n+\n+        for (String identifier : records.stream().map(Record::identifier).distinct().toList()) {\n+            List<Record> filtered = records.stream().filter(c -> c.identifier().equals(identifier)).toList();\n+\n+            \/\/ ensure they are actual changes, not same values:\n+            for (Record r : filtered) {\n+                if (r instanceof Record.Change c) {\n+                    assertNotEquals(c.old, c.current, c + \" was not a change!\");\n+                }\n+            }\n+\n+            Record previous = null;\n+\n+            \/\/ ensure previous new value is next old value:\n+            for (Record r : filtered) {\n+                if (r instanceof Record.Change c) {\n+                    \/\/ Checks if values make sense at all:\n+                    assertTrue(validValues.contains(c.old), c + \" has an unexpected old value; valid values are \" + validValues);\n+                    assertTrue(validValues.contains(c.current), c + \" has an unexpected current value; valid values are \" + validValues);\n+\n+                    if (previous != null) {\n+                        if (previous instanceof Record.Change pc) {\n+                            assertEquals(c.old, pc.current, pc + \" was followed by \" + c + \" with incorrect old value\");\n+                        }\n+                    }\n+                }\n+\n+                previous = r;\n+            }\n+\n+            List<Record.Change> changesOnly = filtered.stream()\n+                .filter(Record.Change.class::isInstance)\n+                .map(Record.Change.class::cast)\n+                .toList();\n+\n+            changesOnly.stream()\n+                .findFirst()\n+                .ifPresent(c -> c.old.equals(expectedFirstValue));\n+\n+            changesOnly.stream()\n+                .reduce((first, second) -> second)\n+                .ifPresent(c -> c.current.equals(expectedLastValue));\n+\n+            if (!Objects.equals(expectedFirstValue, expectedLastValue) && changesOnly.isEmpty()) {\n+                fail(\"Records for \" + identifier + \" did not contain any changes, but did expect a change from \" + expectedFirstValue + \" to \" + expectedLastValue);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/ObservableValueTest.java","additions":786,"deletions":0,"binary":false,"changes":786,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,0 +170,1 @@\n+        Property<T> p3 = factory.createProperty();\n@@ -172,1 +173,2 @@\n-        assertEquals(2, ExpressionHelperUtility.getInvalidationListeners(observable).size());\n+        p3.bind(observable); \/\/ one extra as ListenerHelper has different semantics\n+        assertEquals(3, ExpressionHelperUtility.getInvalidationListeners(observable).size());\n@@ -176,0 +178,1 @@\n+        p3 = null;\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/PropertyBaseTest.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}