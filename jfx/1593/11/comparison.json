{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.nio.ByteBuffer;\n@@ -35,6 +34,9 @@\n-public class ImageFrame {\n-    private ImageType imageType;\n-    private ByteBuffer imageData;\n-    private int width;\n-    private int height;\n-    private int stride;\n+public final class ImageFrame {\n+    private final ImageType imageType;\n+    private final Buffer imageData;\n+    private final int width;\n+    private final int height;\n+    private final int stride;\n+    private final int[] palette;\n+    private final int paletteIndexBits;\n+    private final ImageMetadata metadata;\n@@ -42,2 +44,0 @@\n-    private byte[][] palette;\n-    private ImageMetadata metadata;\n@@ -53,4 +53,2 @@\n-     * @param stride The stride from a pixel position in one row to the same\n-     * horizontal position in the next row.\n-     * @param palette The image palette. This is ignored unless the type is\n-     * one of the palette types.\n+     * @param stride The stride from a pixel position in one row to the same horizontal position in the next row,\n+     *               in data elements (not necessarily bytes).\n@@ -59,7 +57,23 @@\n-    public ImageFrame(ImageType imageType, ByteBuffer imageData,\n-                      int width, int height, int stride, byte[][] palette,\n-                      ImageMetadata metadata)\n-    {\n-        this(imageType, imageData,\n-             width, height, stride, palette,\n-             1.0f, metadata);\n+    public ImageFrame(ImageType imageType, Buffer imageData,\n+                      int width, int height, int stride,\n+                      ImageMetadata metadata) {\n+        this(imageType, imageData, width, height, stride, 1.0f, metadata);\n+    }\n+\n+    \/**\n+     * Create an <code>ImageFrame<\/code>.\n+     *\n+     * @param imageType The type of image data. The value of this field also implies the number of bands.\n+     * @param imageData The image data.\n+     * @param width The image width.\n+     * @param height The image height.\n+     * @param stride The stride from a pixel position in one row to the same horizontal position in the next row,\n+     *               in data elements (not necessarily bytes).\n+     * @param pixelScale The scale of a 72DPI virtual pixel in the resolution of the image\n+     *                   (1.0f for 72DPI images, 2.0f for 144DPI images, etc.).\n+     * @param metadata The image metadata.\n+     *\/\n+    public ImageFrame(ImageType imageType, Buffer imageData,\n+                      int width, int height, int stride,\n+                      float pixelScale, ImageMetadata metadata) {\n+        this(imageType, imageData, width, height, stride, null, -1, pixelScale, metadata);\n@@ -76,4 +90,4 @@\n-     * @param stride The stride from a pixel position in one row to the same\n-     * horizontal position in the next row.\n-     * @param palette The image palette. This is ignored unless the type is\n-     * one of the palette types.\n+     * @param stride The stride from a pixel position in one row to the same horizontal position in the next row,\n+     *               in data elements (not necessarily bytes).\n+     * @param palette The image palette. This is ignored unless the type is one of the palette types.\n+     * @param paletteIndexBits The size of a palette index, in bits.\n@@ -84,4 +98,3 @@\n-    public ImageFrame(ImageType imageType, ByteBuffer imageData,\n-                      int width, int height, int stride, byte[][] palette,\n-                      float pixelScale, ImageMetadata metadata)\n-    {\n+    public ImageFrame(ImageType imageType, Buffer imageData,\n+                      int width, int height, int stride, int[] palette,\n+                      int paletteIndexBits, float pixelScale, ImageMetadata metadata) {\n@@ -94,0 +107,1 @@\n+        this.paletteIndexBits = paletteIndexBits;\n@@ -118,1 +132,1 @@\n-    public byte[][] getPalette() {\n+    public int[] getPalette() {\n@@ -122,0 +136,4 @@\n+    public int getPaletteIndexBits() {\n+        return paletteIndexBits;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/ImageFrame.java","additions":48,"deletions":30,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,2 @@\n+     * @param screenPixelScale screen pixel scale (used for variable-density images)\n+     * @param imagePixelScale image pixel scale (used for fixed-density images)\n@@ -77,2 +79,3 @@\n-    public ImageFrame load(int imageIndex, int width, int height,\n-            boolean preserveAspectRatio, boolean smooth) throws IOException;\n+    ImageFrame load(int imageIndex, double width, double height,\n+            boolean preserveAspectRatio, boolean smooth,\n+            float screenPixelScale, float imagePixelScale) throws IOException;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/ImageLoader.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.io.BufferedInputStream;\n@@ -48,0 +49,1 @@\n+import java.util.Optional;\n@@ -65,1 +67,1 @@\n-         * An image with with two 8-bit valued channels, one of gray levels,\n+         * An image with two 8-bit valued channels, one of gray levels,\n@@ -70,1 +72,1 @@\n-         * An image with with two 8-bit valued channels, one of gray levels,\n+         * An image with two 8-bit valued channels, one of gray levels,\n@@ -75,1 +77,1 @@\n-         * An image with with one 8-bit channel of indexes into a 24-bit\n+         * An image with one channel of indexes into a 24-bit\n@@ -80,1 +82,1 @@\n-         * An image with with one 8-bit channel of indexes into a 32-bit\n+         * An image with one channel of indexes into a 32-bit\n@@ -86,1 +88,1 @@\n-         * An image with with one 8-bit channel of indexes into a 32-bit\n+         * An image with one channel of indexes into a 32-bit\n@@ -92,1 +94,1 @@\n-         * An image with with one 8-bit channel of indexes into a 24-bit\n+         * An image with one channel of indexes into a 24-bit\n@@ -99,1 +101,1 @@\n-         * An image with with three 8-bit valued channels of red, green, and\n+         * An image with three 8-bit valued channels of red, green, and\n@@ -104,1 +106,6 @@\n-         * An image with with four 8-bit valued channels of red, green, blue,\n+         * An image with three 8-bit valued channels of red, green, and\n+         * blue, respectively, ordered as BGRBGRBGR...\n+         *\/\n+        BGR,\n+        \/**\n+         * An image with four 8-bit valued channels of red, green, blue,\n@@ -110,1 +117,1 @@\n-         * An image with with four 8-bit valued channels of red, green, blue,\n+         * An image with four 8-bit valued channels of red, green, blue,\n@@ -114,1 +121,47 @@\n-        RGBA_PRE\n+        RGBA_PRE,\n+        \/**\n+         * An image with four 8-bit valued channels of red, green, blue,\n+         * and non-premultiplied opacity, respectively, ordered as\n+         * BGRABGRABGRA...\n+         *\/\n+        BGRA,\n+        \/**\n+         * An image with four 8-bit valued channels of red, green, blue,\n+         * and premultiplied opacity, respectively, ordered as\n+         * BGRABGRABGRA...\n+         *\/\n+        BGRA_PRE,\n+        \/**\n+         * An image with four 8-bit valued channels of red, green, blue,\n+         * and non-premultiplied opacity, respectively, ordered as\n+         * ABGRABGRABGR...\n+         *\/\n+        ABGR,\n+        \/**\n+         * An image with four 8-bit valued channels of red, green, blue,\n+         * and premultiplied opacity, respectively, ordered as\n+         * ABGRABGRABGR...\n+         *\/\n+        ABGR_PRE,\n+        \/**\n+         * An image with three 8-bit valued channels of red, green, and blue,\n+         * packed into a 32-bit integer, ordered as XRGBXRGBXRGB...\n+         *\/\n+        INT_RGB,\n+        \/**\n+         * An image with three 8-bit valued channels of red, green, and blue,\n+         * packed into a 32-bit integer, ordered as XBGRXBGRXBGR...\n+         *\/\n+        INT_BGR,\n+        \/**\n+         * An image with four 8-bit valued channels of red, green, blue, and\n+         * non-premultiplied opacity, packed into a 32-bit integer, ordered as\n+         * ARGBARGBARGB...\n+         *\/\n+        INT_ARGB,\n+        \/**\n+         * An image with four 8-bit valued channels of red, green, blue, and\n+         * premultiplied opacity, packed into a 32-bit integer, ordered as\n+         * ARGBARGBARGB...\n+         *\/\n+        INT_ARGB_PRE\n@@ -129,0 +182,1 @@\n+    private Optional<ImageLoaderFactory> xImageLoaderFactory;\n@@ -284,7 +338,2 @@\n-            if (isIOS) {\n-                \/\/ no extension\/signature recognition done here,\n-                \/\/ we always want the iOS native loader\n-                loader = IosImageLoaderFactory.getInstance().createImageLoader(input);\n-            } else {\n-                loader = getLoaderBySignature(input, listener);\n-            }\n+            loader = findImageLoader(input, listener);\n+\n@@ -292,1 +341,3 @@\n-                images = loadAll(loader, width, height, preserveAspectRatio, pixelScale, smooth);\n+                \/\/ Images loaded from an InputStream always have an image pixel scale of 1, since we\n+                \/\/ don't have a file name to infer a different intrinsic scale (with the @Nx convention).\n+                images = loadAll(loader, width, height, preserveAspectRatio, pixelScale, 1, smooth);\n@@ -335,4 +386,35 @@\n-                    if (factory == null) {\n-                        throw new IllegalArgumentException(\n-                            \"Unsupported MIME subtype: image\/\" + dataUri.getMimeSubtype());\n-                    }\n+                    if (factory != null) {\n+                        \/\/ We also inspect the image file signature to confirm that it matches the MIME type.\n+                        theStream = new ByteArrayInputStream(dataUri.getData());\n+                        ImageLoader loaderBySignature = getLoaderBySignature(theStream, listener);\n+\n+                        if (loaderBySignature != null) {\n+                            \/\/ If the MIME type doesn't agree with the file signature, log a warning and\n+                            \/\/ continue with the image loader that matches the file signature.\n+                            boolean imageTypeMismatch = !factory.getFormatDescription().getFormatName().equals(\n+                                loaderBySignature.getFormatDescription().getFormatName());\n+\n+                            if (imageTypeMismatch) {\n+                                var logger = Logging.getJavaFXLogger();\n+                                if (logger.isLoggable(PlatformLogger.Level.WARNING)) {\n+                                    logger.warning(String.format(\n+                                        \"Image format '%s' does not match MIME type '%s\/%s' in URI '%s'\",\n+                                        loaderBySignature.getFormatDescription().getFormatName(),\n+                                        dataUri.getMimeType(), dataUri.getMimeSubtype(), dataUri));\n+                                }\n+                            }\n+\n+                            loader = loaderBySignature;\n+                        } else {\n+                            \/\/ We're here because the image format doesn't have a detectable signature.\n+                            \/\/ In this case, we need to close the input stream (because we already consumed\n+                            \/\/ parts of it to detect a potential file signature) and create a new input\n+                            \/\/ stream for the image loader that matches the MIME type.\n+                            theStream.close();\n+                            theStream = new ByteArrayInputStream(dataUri.getData());\n+                            loader = factory.createImageLoader(theStream);\n+                        }\n+                    } else {\n+                        \/\/ If we don't have a built-in loader factory we try to find an ImageIO loader\n+                        \/\/ that can load the content of the data URI.\n+                        ImageLoader imageLoader = tryCreateXImageLoader(new ByteArrayInputStream(dataUri.getData()));\n@@ -340,3 +422,4 @@\n-                    \/\/ We also inspect the image file signature to confirm that it matches the MIME type.\n-                    theStream = new ByteArrayInputStream(dataUri.getData());\n-                    ImageLoader loaderBySignature = getLoaderBySignature(theStream, listener);\n+                        if (imageLoader == null) {\n+                            throw new IllegalArgumentException(\n+                                \"Unsupported MIME subtype: image\/\" + dataUri.getMimeSubtype());\n+                        }\n@@ -344,5 +427,4 @@\n-                    if (loaderBySignature != null) {\n-                        \/\/ If the MIME type doesn't agree with the file signature, log a warning and\n-                        \/\/ continue with the image loader that matches the file signature.\n-                        boolean imageTypeMismatch = !factory.getFormatDescription().getFormatName().equals(\n-                            loaderBySignature.getFormatDescription().getFormatName());\n+                        \/\/ If the specified MIME type doesn't agree with any of the supported MIME types of\n+                        \/\/ the XImageLoader, we log a warning but continue to load the image.\n+                        boolean imageTypeMismatch = imageLoader.getFormatDescription().getMIMESubtypes().stream()\n+                                .noneMatch(dataUri.getMimeSubtype()::equals);\n@@ -355,1 +437,1 @@\n-                                    loaderBySignature.getFormatDescription().getFormatName(),\n+                                    imageLoader.getFormatDescription().getFormatName(),\n@@ -360,9 +442,1 @@\n-                        loader = loaderBySignature;\n-                    } else {\n-                        \/\/ We're here because the image format doesn't have a detectable signature.\n-                        \/\/ In this case, we need to close the input stream (because we already consumed\n-                        \/\/ parts of it to detect a potential file signature) and create a new input\n-                        \/\/ stream for the image loader that matches the MIME type.\n-                        theStream.close();\n-                        theStream = new ByteArrayInputStream(dataUri.getData());\n-                        loader = factory.createImageLoader(theStream);\n+                        loader = imageLoader;\n@@ -404,5 +478,1 @@\n-                    if (isIOS) {\n-                        loader = IosImageLoaderFactory.getInstance().createImageLoader(theStream);\n-                    } else {\n-                        loader = getLoaderBySignature(theStream, listener);\n-                    }\n+                    loader = findImageLoader(theStream, listener);\n@@ -415,1 +485,1 @@\n-                images = loadAll(loader, width, height, preserveAspectRatio, imgPixelScale, smooth);\n+                images = loadAll(loader, width, height, preserveAspectRatio, devPixelScale, imgPixelScale, smooth);\n@@ -451,1 +521,1 @@\n-            float pixelScale, boolean smooth) throws ImageStorageException {\n+            float devPixelScale, float imgPixelScale, boolean smooth) throws ImageStorageException {\n@@ -456,2 +526,0 @@\n-        int imgw = (int) Math.round(width * pixelScale);\n-        int imgh = (int) Math.round(height * pixelScale);\n@@ -460,1 +528,1 @@\n-                image = loader.load(imageIndex++, imgw, imgh, preserveAspectRatio, smooth);\n+                image = loader.load(imageIndex++, width, height, preserveAspectRatio, smooth, devPixelScale, imgPixelScale);\n@@ -470,1 +538,0 @@\n-                image.setPixelScale(pixelScale);\n@@ -484,0 +551,23 @@\n+    private ImageLoader findImageLoader(InputStream stream, ImageLoadListener listener) throws IOException {\n+        if (isIOS) {\n+            return IosImageLoaderFactory.getInstance().createImageLoader(stream);\n+        }\n+\n+        \/\/ We need a stream that supports the mark and reset methods, since XImageLoader\n+        \/\/ is used as a fallback after our built-in loader selection has already consumed\n+        \/\/ part of the input stream.\n+        if (!stream.markSupported()) {\n+            stream = new BufferedInputStream(stream);\n+        }\n+\n+        stream.mark(Integer.MAX_VALUE);\n+        ImageLoader loader = getLoaderBySignature(stream, listener);\n+\n+        if (loader == null) {\n+            stream.reset();\n+            loader = tryCreateXImageLoader(stream);\n+        }\n+\n+        return loader;\n+    }\n+\n@@ -532,0 +622,22 @@\n+\n+    \/**\n+     * Tries to create an {@link com.sun.javafx.iio.javax.XImageLoader} for the specified input stream.\n+     * This might fail in the future if the {@code java.desktop} module is not present on the module path.\n+     * At present, this will not fail because JavaFX requires the {@code java.desktop} module.\n+     *\/\n+    private synchronized ImageLoader tryCreateXImageLoader(InputStream stream) throws IOException {\n+        if (xImageLoaderFactory == null) {\n+            try {\n+                Class<?> factoryClass = Class.forName(\"com.sun.javafx.iio.javax.XImageLoaderFactory\");\n+                xImageLoaderFactory = Optional.of((ImageLoaderFactory)factoryClass.getMethod(\"getInstance\").invoke(null));\n+            } catch (NoClassDefFoundError | ReflectiveOperationException e) {\n+                xImageLoaderFactory = Optional.empty();\n+            }\n+        }\n+\n+        if (xImageLoaderFactory.isEmpty()) {\n+            return null;\n+        }\n+\n+        return xImageLoaderFactory.get().createImageLoader(stream);\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/ImageStorage.java","additions":163,"deletions":51,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -486,2 +486,3 @@\n-    public ImageFrame load(int imageIndex, int width, int height,\n-            boolean preserveAspectRatio, boolean smooth) throws IOException\n+    public ImageFrame load(int imageIndex, double w, double h,\n+            boolean preserveAspectRatio, boolean smooth,\n+            float screenPixelScale, float imagePixelScale) throws IOException\n@@ -494,3 +495,4 @@\n-        int[] outWH = ImageTools.computeDimensions(bih.biWidth, hght, width, height, preserveAspectRatio);\n-        width = outWH[0];\n-        height = outWH[1];\n+        int[] outWH = ImageTools.computeDimensions(\n+            bih.biWidth, hght, (int)(w * imagePixelScale), (int)(h * imagePixelScale), preserveAspectRatio);\n+        int width = outWH[0];\n+        int height = outWH[1];\n@@ -558,1 +560,1 @@\n-                width, height, width * bpp, null, imageMetadata);\n+                width, height, width * bpp, imagePixelScale, imageMetadata);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/bmp\/BMPImageLoaderFactory.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import com.sun.javafx.geom.Point2D;\n-import com.sun.javafx.geom.Rectangle;\n@@ -31,1 +29,0 @@\n-import com.sun.javafx.iio.ImageMetadata;\n@@ -33,1 +30,0 @@\n-import com.sun.javafx.iio.ImageStorage.ImageType;\n@@ -40,1 +36,0 @@\n-import java.nio.Buffer;\n@@ -133,320 +128,0 @@\n-\/\/    public static PixelFormat getPixelFormat(ImageType type) {\n-\/\/        PixelFormat format;\n-\/\/        switch (type) {\n-\/\/            case GRAY:\n-\/\/                format = PixelFormat.BYTE_GRAY;\n-\/\/                break;\n-\/\/            case GRAY_ALPHA:\n-\/\/            case GRAY_ALPHA_PRE:\n-\/\/                format = PixelFormat.BYTE_RGBA_PRE;\n-\/\/                break;\n-\/\/            case PALETTE:\n-\/\/                format = PixelFormat.BYTE_RGB;\n-\/\/                break;\n-\/\/            case PALETTE_ALPHA:\n-\/\/            case PALETTE_ALPHA_PRE:\n-\/\/                format = PixelFormat.BYTE_RGBA_PRE;\n-\/\/                break;\n-\/\/            case RGB:\n-\/\/                format = PixelFormat.BYTE_RGB;\n-\/\/                break;\n-\/\/            case RGBA:\n-\/\/            case RGBA_PRE:\n-\/\/                format = PixelFormat.BYTE_RGBA_PRE;\n-\/\/                break;\n-\/\/            default:\n-\/\/                \/\/ This should not be possible ...\n-\/\/                throw new IllegalArgumentException(\"Unknown ImageType \" + type);\n-\/\/        }\n-\/\/\n-\/\/        return format;\n-\/\/    }\n-\/\/    public static boolean isConversionACopy(ImageType type, PixelFormat format) {\n-\/\/        return (type == ImageType.GRAY && format == PixelFormat.BYTE_GRAY) ||\n-\/\/                (type == ImageType.RGB && format == PixelFormat.BYTE_RGB) ||\n-\/\/                (type == ImageType.RGBA_PRE && format == PixelFormat.BYTE_RGBA_PRE);\n-\/\/    }\n-    public static ImageType getConvertedType(ImageType type) {\n-        ImageType retType = type;\n-        switch (type) {\n-            case GRAY:\n-                retType = ImageType.GRAY;\n-                break;\n-            case GRAY_ALPHA:\n-            case GRAY_ALPHA_PRE:\n-            case PALETTE_ALPHA:\n-            case PALETTE_ALPHA_PRE:\n-            case PALETTE_TRANS:\n-            case RGBA:\n-                retType = ImageType.RGBA_PRE;\n-                break;\n-            case PALETTE:\n-            case RGB:\n-                retType = ImageType.RGB;\n-                break;\n-            case RGBA_PRE:\n-                retType = ImageType.RGBA_PRE;\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Unsupported ImageType \" + type);\n-        }\n-        return retType;\n-    }\n-\n-    public static byte[] createImageArray(ImageType type, int width, int height) {\n-        int numBands = 0;\n-        switch (type) {\n-            case GRAY:\n-            case PALETTE:\n-            case PALETTE_ALPHA:\n-            case PALETTE_ALPHA_PRE:\n-                numBands = 1;\n-                break;\n-            case GRAY_ALPHA:\n-            case GRAY_ALPHA_PRE:\n-                numBands = 2;\n-                break;\n-            case RGB:\n-                numBands = 3;\n-                break;\n-            case RGBA:\n-            case RGBA_PRE:\n-                numBands = 4;\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Unsupported ImageType \" + type);\n-        }\n-        return new byte[width * height * numBands];\n-    }\n-\n-    public static ImageFrame convertImageFrame(ImageFrame frame) {\n-        ImageFrame retFrame;\n-        ImageType type = frame.getImageType();\n-        ImageType convertedType = getConvertedType(type);\n-        if (convertedType == type) {\n-            retFrame = frame;\n-        } else {\n-            byte[] inArray = null;\n-            Buffer buf = frame.getImageData();\n-            if (!(buf instanceof ByteBuffer)) {\n-                throw new IllegalArgumentException(\"!(frame.getImageData() instanceof ByteBuffer)\");\n-            }\n-            ByteBuffer bbuf = (ByteBuffer) buf;\n-            if (bbuf.hasArray()) {\n-                inArray = bbuf.array();\n-            } else {\n-                inArray = new byte[bbuf.capacity()];\n-                bbuf.get(inArray);\n-            }\n-            int width = frame.getWidth();\n-            int height = frame.getHeight();\n-            int inStride = frame.getStride();\n-            byte[] outArray = createImageArray(convertedType, width, height);\n-            ByteBuffer newBuf = ByteBuffer.wrap(outArray);\n-            int outStride = outArray.length \/ height;\n-            byte[][] palette = frame.getPalette();\n-            ImageMetadata metadata = frame.getMetadata();\n-            int transparentIndex = metadata.transparentIndex != null ? metadata.transparentIndex : 0;\n-            convert(width, height, type,\n-                    inArray, 0, inStride, outArray, 0, outStride,\n-                    palette, transparentIndex, false);\n-            ImageMetadata imd = new ImageMetadata(metadata.gamma,\n-                    metadata.blackIsZero, null,\n-                    metadata.backgroundColor, null,\n-                    metadata.delayTime, metadata.loopCount,\n-                    metadata.imageWidth, metadata.imageHeight,\n-                    metadata.imageLeftPosition, metadata.imageTopPosition,\n-                    metadata.disposalMethod);\n-            retFrame = new ImageFrame(convertedType, newBuf, width, height,\n-                    outStride, null, imd);\n-        }\n-        return retFrame;\n-    }\n-\n-    public static byte[] convert(int width, int height, ImageType inputType,\n-            byte[] input, int inputOffset, int inRowStride,\n-            byte[] output, int outputOffset, int outRowStride,\n-            byte[][] palette, int transparentIndex, boolean skipTransparent) {\n-        \/\/\n-        \/\/ Take care of the layouts that are a direct copy.\n-        \/\/\n-        if (inputType == ImageType.GRAY ||\n-                inputType == ImageType.RGB ||\n-                inputType == ImageType.RGBA_PRE) {\n-            if (input != output) {\n-                int bytesPerRow = width;\n-                if (inputType == ImageType.RGB) {\n-                    bytesPerRow *= 3;\n-                } else if (inputType == ImageType.RGBA_PRE) {\n-                    bytesPerRow *= 4;\n-                }\n-                if (height == 1) {\n-                    System.arraycopy(input, inputOffset, output, outputOffset, bytesPerRow);\n-                } else {\n-                    int inRowOffset = inputOffset;\n-                    int outRowOffset = outputOffset;\n-                    for (int row = 0; row < height; row++) {\n-                        System.arraycopy(input, inRowOffset, output, outRowOffset, bytesPerRow);\n-                        inRowOffset += inRowStride;\n-                        outRowOffset += outRowStride;\n-                    }\n-                }\n-            }\n-        } else if (inputType == ImageType.GRAY_ALPHA || inputType == ImageType.GRAY_ALPHA_PRE) {\n-            int inOffset = inputOffset;\n-            int outOffset = outputOffset;\n-            if (inputType == ImageType.GRAY_ALPHA) {\n-                for (int y = 0; y < height; y++) {\n-                    int inOff = inOffset;\n-                    int outOff = outOffset;\n-                    for (int x = 0; x < width; x++) {\n-                        \/\/ copy input to local variables in case operating in place\n-                        byte gray = input[inOff++];\n-                        int alpha = input[inOff++] & 0xff;\n-                        float f = alpha \/ 255.0F;\n-                        gray = (byte) (f * (gray & 0xff));\n-                        output[outOff++] = gray;\n-                        output[outOff++] = gray;\n-                        output[outOff++] = gray;\n-                        output[outOff++] = (byte) alpha;\n-                    }\n-                    inOffset += inRowStride;\n-                    outOffset += outRowStride;\n-                }\n-            } else {\n-                for (int y = 0; y < height; y++) {\n-                    int inOff = inOffset;\n-                    int outOff = outOffset;\n-                    for (int x = 0; x < width; x++) {\n-                        \/\/ copy input to local variables in case operating in place\n-                        byte gray = input[inOff++];\n-                        output[outOff++] = gray;\n-                        output[outOff++] = gray;\n-                        output[outOff++] = gray;\n-                        output[outOff++] = input[inOff++];\n-                    }\n-                    inOffset += inRowStride;\n-                    outOffset += outRowStride;\n-                }\n-            }\n-        } else if (inputType == ImageType.PALETTE) {\n-            int inOffset = inputOffset;\n-            int outOffset = outputOffset;\n-            byte[] red = palette[0];\n-            byte[] green = palette[1];\n-            byte[] blue = palette[2];\n-            int inOff = inOffset;\n-            int outOff = outOffset;\n-            \/\/loop through the scanline and mask for the value if each byte.\n-            \/\/the byte is an index into the palette array for that pixel.\n-            for (int x = 0; x < width; x++) {\n-                int index = (input[inOff++] & 0xff);\n-\n-                output[outOff++] = red[index];\n-                output[outOff++] = green[index];\n-                output[outOff++] = blue[index];\n-\n-                outOffset += outRowStride;\n-            }\n-        } else if (inputType == ImageType.PALETTE_ALPHA) {\n-            int inOffset = inputOffset;\n-            int outOffset = outputOffset;\n-            byte[] red = palette[0];\n-            byte[] green = palette[1];\n-            byte[] blue = palette[2];\n-            byte[] alpha = palette[3];\n-                int inOff = inOffset;\n-                int outOff = outOffset;\n-                for (int x = 0; x < width; x++) {\n-                    int index = input[inOff++] & 0xff;\n-                    byte r = red[index];\n-                    byte g = green[index];\n-                    byte b = blue[index];\n-                    int a = alpha[index] & 0xff;\n-                    float f = a \/ 255.0F;\n-                    output[outOff++] = (byte) (f * (r & 0xff));\n-                    output[outOff++] = (byte) (f * (g & 0xff));\n-                    output[outOff++] = (byte) (f * (b & 0xff));\n-                    output[outOff++] = (byte) a;\n-                }\n-                inOffset += inRowStride;\n-                outOffset += outRowStride;\n-        } else if (inputType == ImageType.PALETTE_ALPHA_PRE) {\n-            int inOffset = inputOffset;\n-            int outOffset = outputOffset;\n-            byte[] red = palette[0];\n-            byte[] green = palette[1];\n-            byte[] blue = palette[2];\n-            byte[] alpha = palette[3];\n-            for (int y = 0; y < height; y++) {\n-                int inOff = inOffset;\n-                int outOff = outOffset;\n-                for (int x = 0; x < width; x++) {\n-                    int index = input[inOff++] & 0xff;\n-                    output[outOff++] = red[index];\n-                    output[outOff++] = green[index];\n-                    output[outOff++] = blue[index];\n-                    output[outOff++] = alpha[index];\n-                }\n-                inOffset += inRowStride;\n-                outOffset += outRowStride;\n-            }\n-        } else if (inputType == ImageType.PALETTE_TRANS) {\n-            int inOffset = inputOffset;\n-            int outOffset = outputOffset;\n-            for (int y = 0; y < height; y++) {\n-                int inOff = inOffset;\n-                int outOff = outOffset;\n-                byte[] red = palette[0];\n-                byte[] green = palette[1];\n-                byte[] blue = palette[2];\n-                for (int x = 0; x < width; x++) {\n-                    int index = input[inOff++] & 0xff;\n-                    if (index == transparentIndex) {\n-                        if (skipTransparent) {\n-                            outOff+=4;\n-                        } else {\n-                            output[outOff++] = (byte) 0;\n-                            output[outOff++] = (byte) 0;\n-                            output[outOff++] = (byte) 0;\n-                            output[outOff++] = (byte) 0;\n-                        }\n-                    } else {\n-                        output[outOff++] = red[index];\n-                        output[outOff++] = green[index];\n-                        output[outOff++] = blue[index];\n-                        output[outOff++] = (byte) 255;\n-                    }\n-                }\n-                inOffset += inRowStride;\n-                outOffset += outRowStride;\n-            }\n-        } else if (inputType == ImageType.RGBA) {\n-            int inOffset = inputOffset;\n-            int outOffset = outputOffset;\n-            for (int y = 0; y < height; y++) {\n-                int inOff = inOffset;\n-                int outOff = outOffset;\n-                for (int x = 0; x < width; x++) {\n-                    \/\/ copy input to local variables in case operating in place\n-                    byte red = input[inOff++];\n-                    byte green = input[inOff++];\n-                    byte blue = input[inOff++];\n-                    int alpha = input[inOff++] & 0xff;\n-                    float f = alpha \/ 255.0F;\n-                    output[outOff++] = (byte) (f * (red & 0xff));\n-                    output[outOff++] = (byte) (f * (green & 0xff));\n-                    output[outOff++] = (byte) (f * (blue & 0xff));\n-                    output[outOff++] = (byte) alpha;\n-                }\n-\/\/                System.arraycopy(input, inOffset, output, outOffset, width*4);\n-                inOffset += inRowStride;\n-                outOffset += outRowStride;\n-            }\n-        } else {\n-            throw new UnsupportedOperationException(\"Unsupported ImageType \" +\n-                    inputType);\n-        }\n-\n-        return output;\n-    }\n@@ -493,160 +168,0 @@\n-    \/\/ Helper for computeUpdatedPixels method\n-    private static void computeUpdatedPixels(int sourceOffset,\n-            int sourceExtent,\n-            int destinationOffset,\n-            int dstMin,\n-            int dstMax,\n-            int sourceSubsampling,\n-            int passStart,\n-            int passExtent,\n-            int passPeriod,\n-            int[] vals,\n-            int offset) {\n-        \/\/ We need to satisfy the congruences:\n-        \/\/ dst = destinationOffset + (src - sourceOffset)\/sourceSubsampling\n-        \/\/\n-        \/\/ src - passStart == 0 (mod passPeriod)\n-        \/\/ src - sourceOffset == 0 (mod sourceSubsampling)\n-        \/\/\n-        \/\/ subject to the inequalities:\n-        \/\/\n-        \/\/ src >= passStart\n-        \/\/ src < passStart + passExtent\n-        \/\/ src >= sourceOffset\n-        \/\/ src < sourceOffset + sourceExtent\n-        \/\/ dst >= dstMin\n-        \/\/ dst <= dstmax\n-        \/\/\n-        \/\/ where\n-        \/\/\n-        \/\/ dst = destinationOffset + (src - sourceOffset)\/sourceSubsampling\n-        \/\/\n-        \/\/ For now we use a brute-force approach although we could\n-        \/\/ attempt to analyze the congruences.  If passPeriod and\n-        \/\/ sourceSubsamling are relatively prime, the period will be\n-        \/\/ their product.  If they share a common factor, either the\n-        \/\/ period will be equal to the larger value, or the sequences\n-        \/\/ will be completely disjoint, depending on the relationship\n-        \/\/ between passStart and sourceOffset.  Since we only have to do this\n-        \/\/ twice per image (once each for X and Y), it seems cheap enough\n-        \/\/ to do it the straightforward way.\n-\n-        boolean gotPixel = false;\n-        int firstDst = -1;\n-        int secondDst = -1;\n-        int lastDst = -1;\n-\n-        for (int i = 0; i < passExtent; i++) {\n-            int src = passStart + i * passPeriod;\n-            if (src < sourceOffset) {\n-                continue;\n-            }\n-            if ((src - sourceOffset) % sourceSubsampling != 0) {\n-                continue;\n-            }\n-            if (src >= sourceOffset + sourceExtent) {\n-                break;\n-            }\n-\n-            int dst = destinationOffset +\n-                    (src - sourceOffset) \/ sourceSubsampling;\n-            if (dst < dstMin) {\n-                continue;\n-            }\n-            if (dst > dstMax) {\n-                break;\n-            }\n-\n-            if (!gotPixel) {\n-                firstDst = dst; \/\/ Record smallest valid pixel\n-                gotPixel = true;\n-            } else if (secondDst == -1) {\n-                secondDst = dst; \/\/ Record second smallest valid pixel\n-            }\n-            lastDst = dst; \/\/ Record largest valid pixel\n-        }\n-\n-        vals[offset] = firstDst;\n-\n-        \/\/ If we never saw a valid pixel, set width to 0\n-        if (!gotPixel) {\n-            vals[offset + 2] = 0;\n-        } else {\n-            vals[offset + 2] = lastDst - firstDst + 1;\n-        }\n-\n-        \/\/ The period is given by the difference of any two adjacent pixels\n-        vals[offset + 4] = Math.max(secondDst - firstDst, 1);\n-    }\n-\n-    \/**\n-     * A utility method that computes the exact set of destination\n-     * pixels that will be written during a particular decoding pass.\n-     * The intent is to simplify the work done by readers in combining\n-     * the source region, source subsampling, and destination offset\n-     * information obtained from the <code>ImageReadParam<\/code> with\n-     * the offsets and periods of a progressive or interlaced decoding\n-     * pass.\n-     *\n-     * @param sourceRegion a <code>Rectangle<\/code> containing the\n-     * source region being read, offset by the source subsampling\n-     * offsets, and clipped against the source bounds, as returned by\n-     * the <code>getSourceRegion<\/code> method.\n-     * @param destinationOffset a <code>Point<\/code> containing the\n-     * coordinates of the upper-left pixel to be written in the\n-     * destination.\n-     * @param dstMinX the smallest X coordinate (inclusive) of the\n-     * destination <code>Raster<\/code>.\n-     * @param dstMinY the smallest Y coordinate (inclusive) of the\n-     * destination <code>Raster<\/code>.\n-     * @param dstMaxX the largest X coordinate (inclusive) of the destination\n-     * <code>Raster<\/code>.\n-     * @param dstMaxY the largest Y coordinate (inclusive) of the destination\n-     * <code>Raster<\/code>.\n-     * @param sourceXSubsampling the X subsampling factor.\n-     * @param sourceYSubsampling the Y subsampling factor.\n-     * @param passXStart the smallest source X coordinate (inclusive)\n-     * of the current progressive pass.\n-     * @param passYStart the smallest source Y coordinate (inclusive)\n-     * of the current progressive pass.\n-     * @param passWidth the width in pixels of the current progressive\n-     * pass.\n-     * @param passHeight the height in pixels of the current progressive\n-     * pass.\n-     * @param passPeriodX the X period (horizontal spacing between\n-     * pixels) of the current progressive pass.\n-     * @param passPeriodY the Y period (vertical spacing between\n-     * pixels) of the current progressive pass.\n-     *\n-     * @return an array of 6 <code>int<\/code>s containing the\n-     * destination min X, min Y, width, height, X period and Y period\n-     * of the region that will be updated.\n-     *\/\n-    public static int[] computeUpdatedPixels(Rectangle sourceRegion,\n-            Point2D destinationOffset,\n-            int dstMinX,\n-            int dstMinY,\n-            int dstMaxX,\n-            int dstMaxY,\n-            int sourceXSubsampling,\n-            int sourceYSubsampling,\n-            int passXStart,\n-            int passYStart,\n-            int passWidth,\n-            int passHeight,\n-            int passPeriodX,\n-            int passPeriodY) {\n-        int[] vals = new int[6];\n-        computeUpdatedPixels(sourceRegion.x, sourceRegion.width,\n-                (int) (destinationOffset.x + 0.5F),\n-                dstMinX, dstMaxX, sourceXSubsampling,\n-                passXStart, passWidth, passPeriodX,\n-                vals, 0);\n-        computeUpdatedPixels(sourceRegion.y, sourceRegion.height,\n-                (int) (destinationOffset.y + 0.5F),\n-                dstMinY, dstMaxY, sourceYSubsampling,\n-                passYStart, passHeight, passPeriodY,\n-                vals, 1);\n-        return vals;\n-    }\n-\n@@ -707,1 +222,1 @@\n-                destWidth, destHeight, destWidth * numBands, null, src.getMetadata());\n+                destWidth, destHeight, destWidth * numBands, src.getMetadata());\n@@ -734,67 +249,0 @@\n-\/\/    public static final java.awt.image.BufferedImage getAsBufferedImage(Image prismImage) {\n-\/\/        java.awt.image.BufferedImage image = null;\n-\/\/\n-\/\/        int width = prismImage.getWidth();\n-\/\/        int height = prismImage.getHeight();\n-\/\/        int scanlineStride = prismImage.getScanlineStride();\n-\/\/        byte[] pixels = ((java.nio.ByteBuffer) prismImage.getPixelBuffer()).array();\n-\/\/        switch (prismImage.getPixelFormat()) {\n-\/\/            case BYTE_GRAY: {\n-\/\/                image = new java.awt.image.BufferedImage(width, height,\n-\/\/                        java.awt.image.BufferedImage.TYPE_BYTE_GRAY);\n-\/\/                java.awt.image.DataBufferByte db =\n-\/\/                        (java.awt.image.DataBufferByte) image.getRaster().getDataBuffer();\n-\/\/                byte[] data = db.getData();\n-\/\/                System.arraycopy(pixels, 0, data, 0, width * height);\n-\/\/            }\n-\/\/            break;\n-\/\/            case BYTE_RGB: {\n-\/\/                image = new java.awt.image.BufferedImage(width, height,\n-\/\/                        java.awt.image.BufferedImage.TYPE_3BYTE_BGR);\n-\/\/                for (int y = 0; y < height; y++) {\n-\/\/                    int off = y * scanlineStride;\n-\/\/                    for (int x = 0; x < width; x++) {\n-\/\/                        int rgb = ((pixels[off++] & 0xff) << 16) |\n-\/\/                                ((pixels[off++] & 0xff) << 8) |\n-\/\/                                (pixels[off++] & 0xff);\n-\/\/                        image.setRGB(x, y, rgb);\n-\/\/                    }\n-\/\/                }\n-\/\/            }\n-\/\/            break;\n-\/\/            case BYTE_RGBA_PRE: {\n-\/\/                image = new java.awt.image.BufferedImage(width, height,\n-\/\/                        java.awt.image.BufferedImage.TYPE_4BYTE_ABGR_PRE);\n-\/\/--                for (int y = 0; y < height; y++) {\n-\/\/--                    int off = y * scanlineStride;\n-\/\/--                    for (int x = 0; x < width; x++) {\n-\/\/--                        int rgb = ((pixels[off++] & 0xff) << 16) |\n-\/\/--                                ((pixels[off++] & 0xff) << 8) |\n-\/\/--                                (pixels[off++] & 0xff) |\n-\/\/--                                ((pixels[off++] & 0xff) << 24);\n-\/\/--                        image.setRGB(x, y, rgb);\n-\/\/--                    }\n-\/\/--                }\n-\/\/                java.awt.image.DataBufferByte db =\n-\/\/                        (java.awt.image.DataBufferByte) image.getRaster().getDataBuffer();\n-\/\/                byte[] data = db.getData();\n-\/\/                for (int y = 0; y < height; y++) {\n-\/\/                    int offPrism = y * scanlineStride;\n-\/\/                    int offImage = y * width * 4;\n-\/\/                    for (int x = 0; x < width; x++) {\n-\/\/                        data[offImage++] = pixels[offPrism + 3]; \/\/ A\n-\/\/                        data[offImage++] = pixels[offPrism + 2]; \/\/ B\n-\/\/                        data[offImage++] = pixels[offPrism + 1]; \/\/ G\n-\/\/                        data[offImage++] = pixels[offPrism];     \/\/ R\n-\/\/                        offPrism += 4;\n-\/\/                    }\n-\/\/                }\n-\/\/            }\n-\/\/            break;\n-\/\/            default:\n-\/\/                throw new UnsupportedOperationException(\"Unsupported test case \" +\n-\/\/                        prismImage.getPixelFormat());\n-\/\/        }\n-\/\/\n-\/\/        return image;\n-\/\/    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/common\/ImageTools.java","additions":1,"deletions":553,"binary":false,"changes":554,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,2 +201,2 @@\n-    @Override\n-    public ImageFrame load(int imageIndex, int width, int height, boolean preserveAspectRatio, boolean smooth) throws IOException {\n+    public ImageFrame load(int imageIndex, double imgw, double imgh, boolean preserveAspectRatio, boolean smooth,\n+                           float screenPixelScale, float imagePixelScale) throws IOException {\n@@ -225,3 +225,4 @@\n-        int[] outWH = ImageTools.computeDimensions(screenW, screenH, width, height, preserveAspectRatio);\n-        width = outWH[0];\n-        height = outWH[1];\n+        int[] outWH = ImageTools.computeDimensions(\n+            screenW, screenH, (int)(imgw * imagePixelScale), (int)(imgh * imagePixelScale), preserveAspectRatio);\n+        int width = outWH[0];\n+        int height = outWH[1];\n@@ -244,1 +245,1 @@\n-                width, height, width * 4, null, metadata);\n+                width, height, width * 4, imagePixelScale, metadata);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/gif\/GIFImageLoader2.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,3 +221,2 @@\n-    public ImageFrame load(int imageIndex, int width, int height, boolean preserveAspectRatio, boolean smooth)\n-            throws IOException {\n-\n+    public ImageFrame load(int imageIndex, double w, double h, boolean preserveAspectRatio, boolean smooth,\n+                           float screenPixelScale, float imagePixelScale) throws IOException {\n@@ -230,3 +229,4 @@\n-        int[] widthHeight = ImageTools.computeDimensions(inWidth, inHeight, width, height, preserveAspectRatio);\n-        width = widthHeight[0];\n-        height = widthHeight[1];\n+        int[] widthHeight = ImageTools.computeDimensions(\n+            inWidth, inHeight, (int)(w * imagePixelScale), (int)(h * imagePixelScale), preserveAspectRatio);\n+        int width = widthHeight[0];\n+        int height = widthHeight[1];\n@@ -264,1 +264,1 @@\n-                null,\n+                imagePixelScale,\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/ios\/IosImageLoader.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,299 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.iio.javax;\n+\n+import com.sun.javafx.iio.ImageFormatDescription;\n+import com.sun.javafx.iio.ImageFrame;\n+import com.sun.javafx.iio.ImageLoadListener;\n+import com.sun.javafx.iio.ImageLoader;\n+import com.sun.javafx.iio.ImageMetadata;\n+import com.sun.javafx.iio.ImageStorage.ImageType;\n+import com.sun.javafx.iio.ImageStorageException;\n+import com.sun.javafx.iio.common.ImageDescriptor;\n+import com.sun.javafx.iio.common.ImageTools;\n+import javax.imageio.ImageReadParam;\n+import javax.imageio.ImageReader;\n+import javax.imageio.event.IIOReadProgressListener;\n+import javax.imageio.event.IIOReadWarningListener;\n+import javax.imageio.stream.ImageInputStream;\n+import java.awt.Dimension;\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ComponentSampleModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DataBufferByte;\n+import java.awt.image.DataBufferInt;\n+import java.awt.image.IndexColorModel;\n+import java.awt.image.MultiPixelPackedSampleModel;\n+import java.awt.image.SinglePixelPackedSampleModel;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+import static java.awt.image.BufferedImage.*;\n+\n+public class XImageLoader implements ImageLoader {\n+\n+    private final ImageReader reader;\n+    private final ImageInputStream stream;\n+    private final ImageFormatDescription description;\n+\n+    public XImageLoader(ImageReader reader, ImageInputStream stream) throws IOException {\n+        this.reader = reader;\n+        this.stream = stream;\n+        this.description = new ImageDescriptor(\n+            reader.getFormatName(), new String[0], new ImageFormatDescription.Signature[0],\n+            reader.getOriginatingProvider() == null ? new String[0] :\n+                Arrays.stream(reader.getOriginatingProvider().getMIMETypes())\n+                    .map(type -> type.substring(type.indexOf('\/')))\n+                    .toArray(String[]::new));\n+\n+        reader.setInput(stream);\n+    }\n+\n+    @Override\n+    public ImageFormatDescription getFormatDescription() {\n+        return description;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        reader.dispose();\n+\n+        try {\n+            if (stream != null) {\n+                stream.close();\n+            }\n+        } catch (IOException ignored) {\n+        }\n+    }\n+\n+    @Override\n+    public void addListener(ImageLoadListener listener) {\n+        var listenerImpl = new LoadListenerImpl(listener);\n+        reader.addIIOReadProgressListener(listenerImpl);\n+        reader.addIIOReadWarningListener(listenerImpl);\n+    }\n+\n+    @Override\n+    public void removeListener(ImageLoadListener listener) {\n+        var listenerImpl = new LoadListenerImpl(listener);\n+        reader.removeIIOReadProgressListener(listenerImpl);\n+        reader.removeIIOReadWarningListener(listenerImpl);\n+    }\n+\n+    @Override\n+    public ImageFrame load(int imageIndex, double w, double h, boolean preserveAspectRatio, boolean smooth,\n+                           float screenPixelScale, float imagePixelScale) throws IOException {\n+        \/\/ We currently don't support animated images loaded via ImageIO\n+        if (imageIndex != 0) {\n+            return null;\n+        }\n+\n+        int width, height;\n+        float pixelScale;\n+        ImageReadParam param = reader.getDefaultReadParam();\n+\n+        if (param.canSetSourceRenderSize()) {\n+            int imageWidth = reader.getWidth(imageIndex);\n+            int imageHeight = reader.getHeight(imageIndex);\n+            int[] widthHeight = ImageTools.computeDimensions(\n+                (int)(imageWidth * screenPixelScale), (int)(imageHeight * screenPixelScale),\n+                (int)(w * screenPixelScale), (int)(h * screenPixelScale),\n+                preserveAspectRatio);\n+\n+            width = widthHeight[0];\n+            height = widthHeight[1];\n+            pixelScale = screenPixelScale;\n+            param.setSourceRenderSize(new Dimension(width, height));\n+        } else {\n+            int[] widthHeight = ImageTools.computeDimensions(\n+                reader.getWidth(imageIndex), reader.getHeight(imageIndex),\n+                (int)(w * imagePixelScale), (int)(h * imagePixelScale),\n+                preserveAspectRatio);\n+\n+            width = widthHeight[0];\n+            height = widthHeight[1];\n+            pixelScale = imagePixelScale;\n+        }\n+\n+        BufferedImage image = reader.read(imageIndex, param);\n+\n+        if (image.getWidth() != width || image.getHeight() != height) {\n+            image = (BufferedImage)image.getScaledInstance(\n+                width, height, smooth ? Image.SCALE_SMOOTH : Image.SCALE_DEFAULT);\n+        }\n+\n+        var metadata = new ImageMetadata(\n+            null, true, null, null, null,\n+            null, null, image.getWidth(), image.getHeight(), null,\n+            null, null);\n+\n+        \/\/ Scanline stride is measured in elements of the underlying buffer, which can be bytes or ints.\n+        int scanlineStride = switch(image.getSampleModel()) {\n+            case ComponentSampleModel m -> m.getScanlineStride();\n+            case MultiPixelPackedSampleModel m -> m.getScanlineStride();\n+            case SinglePixelPackedSampleModel m -> m.getScanlineStride();\n+            default -> throw new IllegalStateException(\"Unsupported sample model: \" + image.getSampleModel());\n+        };\n+\n+        return switch (image.getType()) {\n+            case TYPE_BYTE_GRAY -> new ImageFrame(ImageType.GRAY,\n+                    getByteBuffer(image.getRaster().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), scanlineStride,\n+                    pixelScale, metadata);\n+\n+            case TYPE_3BYTE_BGR -> new ImageFrame(ImageType.BGR,\n+                    getByteBuffer(image.getRaster().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), scanlineStride,\n+                    pixelScale, metadata);\n+\n+            case TYPE_4BYTE_ABGR -> new ImageFrame(ImageType.ABGR,\n+                    getByteBuffer(image.getRaster().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), scanlineStride,\n+                    pixelScale, metadata);\n+\n+            case TYPE_4BYTE_ABGR_PRE -> new ImageFrame(ImageType.ABGR_PRE,\n+                    getByteBuffer(image.getRaster().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), scanlineStride,\n+                    pixelScale, metadata);\n+\n+            case TYPE_INT_RGB -> new ImageFrame(ImageType.INT_RGB,\n+                    getIntBuffer(image.getRaster().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), scanlineStride,\n+                    pixelScale, metadata);\n+\n+            case TYPE_INT_BGR -> new ImageFrame(ImageType.INT_BGR,\n+                    getIntBuffer(image.getRaster().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), scanlineStride,\n+                    pixelScale, metadata);\n+\n+            case TYPE_INT_ARGB -> new ImageFrame(ImageType.INT_ARGB,\n+                    getIntBuffer(image.getRaster().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), scanlineStride,\n+                    pixelScale, metadata);\n+\n+            case TYPE_INT_ARGB_PRE -> new ImageFrame(ImageType.INT_ARGB_PRE,\n+                    getIntBuffer(image.getRaster().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), scanlineStride,\n+                    pixelScale, metadata);\n+\n+            case TYPE_BYTE_BINARY, TYPE_BYTE_INDEXED -> {\n+                IndexColorModel colorModel = (IndexColorModel)image.getColorModel();\n+                int[] palette = new int[colorModel.getMapSize()];\n+                colorModel.getRGBs(palette);\n+\n+                ImageType imageType = colorModel.hasAlpha()\n+                    ? colorModel.isAlphaPremultiplied()\n+                        ? ImageType.PALETTE_ALPHA_PRE\n+                        : ImageType.PALETTE_ALPHA\n+                    : ImageType.PALETTE;\n+\n+                yield new ImageFrame(\n+                    imageType, getByteBuffer(image.getRaster().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), scanlineStride,\n+                    palette, colorModel.getPixelSize(), pixelScale, metadata);\n+            }\n+\n+            default ->\n+                throw new ImageStorageException(\"Unsupported image type: \" + switch (image.getType()) {\n+                    case TYPE_CUSTOM -> \"TYPE_CUSTOM\";\n+                    case TYPE_USHORT_565_RGB -> \"TYPE_USHORT_565_RGB\";\n+                    case TYPE_USHORT_555_RGB -> \"TYPE_USHORT_555_RGB\";\n+                    case TYPE_USHORT_GRAY -> \"TYPE_USHORT_GRAY\";\n+                    default -> Integer.toString(image.getType());\n+                });\n+        };\n+    }\n+\n+    private static ByteBuffer getByteBuffer(DataBuffer buffer) {\n+        DataBufferByte byteBuffer = (DataBufferByte)buffer;\n+        byte[] data = byteBuffer.getData();\n+        int offset = byteBuffer.getOffset();\n+        int size = byteBuffer.getSize();\n+        return ByteBuffer.wrap(data, offset, size);\n+    }\n+\n+    private static IntBuffer getIntBuffer(DataBuffer buffer) {\n+        DataBufferInt byteBuffer = (DataBufferInt)buffer;\n+        int[] data = byteBuffer.getData();\n+        int offset = byteBuffer.getOffset();\n+        int size = byteBuffer.getSize();\n+        return IntBuffer.wrap(data, offset, size);\n+    }\n+\n+    private final class LoadListenerImpl implements IIOReadProgressListener, IIOReadWarningListener {\n+        private final ImageLoadListener listener;\n+        private float lastProgress;\n+\n+        LoadListenerImpl(ImageLoadListener listener) {\n+            this.listener = listener;\n+        }\n+\n+        @Override\n+        public void warningOccurred(ImageReader source, String warning) {\n+            listener.imageLoadWarning(XImageLoader.this, warning);\n+        }\n+\n+        @Override\n+        public void imageProgress(ImageReader source, float percentageDone) {\n+            if (percentageDone > lastProgress) {\n+                lastProgress = percentageDone;\n+                listener.imageLoadProgress(XImageLoader.this, percentageDone);\n+            }\n+        }\n+\n+        @Override public void imageStarted(ImageReader source, int imageIndex) {\n+            listener.imageLoadProgress(XImageLoader.this, 0);\n+        }\n+\n+        @Override\n+        public void imageComplete(ImageReader source) {\n+            if (lastProgress < 100) {\n+                listener.imageLoadProgress(XImageLoader.this, 100);\n+            }\n+        }\n+\n+        @Override public void sequenceStarted(ImageReader source, int minIndex) {}\n+        @Override public void sequenceComplete(ImageReader source) {}\n+        @Override public void thumbnailStarted(ImageReader source, int imageIndex, int thumbnailIndex) {}\n+        @Override public void thumbnailProgress(ImageReader source, float percentageDone) {}\n+        @Override public void thumbnailComplete(ImageReader source) {}\n+        @Override public void readAborted(ImageReader source) {}\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof LoadListenerImpl impl && Objects.equals(impl.listener, listener);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return listener.hashCode();\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/javax\/XImageLoader.java","additions":299,"deletions":0,"binary":false,"changes":299,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.iio.javax;\n+\n+import com.sun.javafx.iio.ImageFormatDescription;\n+import com.sun.javafx.iio.ImageLoader;\n+import com.sun.javafx.iio.ImageLoaderFactory;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageReader;\n+import javax.imageio.stream.ImageInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Iterator;\n+\n+public class XImageLoaderFactory implements ImageLoaderFactory {\n+\n+    private static XImageLoaderFactory theInstance;\n+\n+    private XImageLoaderFactory() {}\n+\n+    public static synchronized XImageLoaderFactory getInstance() {\n+        if (theInstance == null) {\n+            theInstance = new XImageLoaderFactory();\n+        }\n+\n+        return theInstance;\n+    }\n+\n+    @Override\n+    public ImageFormatDescription getFormatDescription() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public ImageLoader createImageLoader(InputStream input) throws IOException {\n+        boolean oldUseCache = ImageIO.getUseCache();\n+        ImageIO.setUseCache(false);\n+\n+        try {\n+            ImageInputStream stream = ImageIO.createImageInputStream(input);\n+            if (stream != null) {\n+                Iterator<ImageReader> readers = ImageIO.getImageReaders(stream);\n+                ImageReader reader = readers.hasNext() ? readers.next() : null;\n+                if (reader == null) {\n+                    stream.close();\n+                    return null;\n+                }\n+\n+                \/\/ XImageLoader is responsible for closing the ImageInputStream after\n+                \/\/ it has finished reading from it.\n+                return new XImageLoader(reader, stream);\n+            }\n+\n+            return null;\n+        } finally {\n+            ImageIO.setUseCache(oldUseCache);\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/javax\/XImageLoaderFactory.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,1 +207,2 @@\n-    public ImageFrame load(int imageIndex, int width, int height, boolean preserveAspectRatio, boolean smooth) throws IOException {\n+    public ImageFrame load(int imageIndex, double w, double h, boolean preserveAspectRatio, boolean smooth,\n+                           float screenPixelScale, float imagePixelScale) throws IOException {\n@@ -215,3 +216,4 @@\n-        int[] widthHeight = ImageTools.computeDimensions(inWidth, inHeight, width, height, preserveAspectRatio);\n-        width = widthHeight[0];\n-        height = widthHeight[1];\n+        int[] widthHeight = ImageTools.computeDimensions(\n+            inWidth, inHeight, (int)(w * imagePixelScale), (int)(h * imagePixelScale), preserveAspectRatio);\n+        int width = widthHeight[0];\n+        int height = widthHeight[1];\n@@ -270,1 +272,1 @@\n-                width, height, width * outNumComponents, null, md);\n+                width, height, width * outNumComponents, imagePixelScale, md);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/jpeg\/JPEGImageLoader.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,2 +315,0 @@\n-            case PNG_COLOR_PALETTE:\n-                return ImageStorage.ImageType.PALETTE;\n@@ -623,1 +621,1 @@\n-                width * bpp, null, metadata);\n+                width * bpp, metadata);\n@@ -640,2 +638,3 @@\n-    public ImageFrame load(int imageIndex, int rWidth, int rHeight,\n-            boolean preserveAspectRatio, boolean smooth) throws IOException {\n+    public ImageFrame load(int imageIndex, double w, double h,\n+            boolean preserveAspectRatio, boolean smooth,\n+            float screenPixelScale, float imagePixelScale) throws IOException {\n@@ -659,3 +658,4 @@\n-        int[] outWH = ImageTools.computeDimensions(width, height, rWidth, rHeight, preserveAspectRatio);\n-        rWidth = outWH[0];\n-        rHeight = outWH[1];\n+        int[] outWH = ImageTools.computeDimensions(\n+            width, height, (int)(w * imagePixelScale), (int)(h * imagePixelScale), preserveAspectRatio);\n+        int rWidth = outWH[0];\n+        int rHeight = outWH[1];\n@@ -685,1 +685,3 @@\n-                : new ImageFrame(getType(), bb, width, height, bpp * width, palette, metaData);\n+                : new ImageFrame(getType(), bb, width, height, bpp * width, metaData);\n+\n+        imgPNG.setPixelScale(imagePixelScale);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/png\/PNGImageLoader2.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,3 @@\n-     * @param srcscanelems number of buffer elements between rows of data in the source\n+     * @param srcscanelems number of logical buffer elements between rows of data in the source;\n+     *                     note that the definition of a logical buffer element depends on the implementation,\n+     *                     usually this is a byte or an int, but for indexed converters it is a bit\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/PixelConverter.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.image.impl.ByteAbgr;\n+import com.sun.javafx.image.impl.ByteArgb;\n@@ -34,0 +36,1 @@\n+import com.sun.javafx.image.impl.ByteRgba;\n@@ -37,0 +40,2 @@\n+import com.sun.javafx.image.impl.IntBgr;\n+import com.sun.javafx.image.impl.IntRgb;\n@@ -210,1 +215,15 @@\n-        if (src ==        ByteBgra.getter) {\n+        if (src ==        ByteRgba.getter) {\n+            if (dst ==               ByteRgba.setter) {\n+                return    ByteRgba.ToByteRgbaConverter();\n+            } else if (dst ==        ByteBgra.setter) {\n+                return    ByteRgba.ToByteBgraConverter();\n+            } else if (dst ==        ByteBgraPre.setter) {\n+                return    ByteRgba.ToByteBgraPreConverter();\n+            }\n+        } else if (src == ByteAbgr.getter) {\n+            if (dst ==               ByteBgra.setter) {\n+                return    ByteAbgr.ToByteBgraConverter();\n+            } else if (dst ==        ByteBgraPre.setter) {\n+                return    ByteAbgr.ToByteBgraPreConverter();\n+            }\n+        } else if (src == ByteBgra.getter) {\n@@ -229,0 +248,2 @@\n+            } else if (dst ==       ByteArgb.setter) {\n+                return    ByteRgb.ToByteArgbConverter();\n@@ -231,1 +252,3 @@\n-            if (dst ==              ByteBgr.setter) {\n+            if (dst ==              ByteRgb.setter) {\n+                return    ByteBgr.ToByteRgbConverter();\n+            } else if (dst ==       ByteBgr.setter) {\n@@ -237,0 +260,2 @@\n+            } else if (dst ==       ByteArgb.setter) {\n+                return    ByteBgr.ToByteArgbConverter();\n@@ -342,1 +367,9 @@\n-        if (src ==        IntArgb.getter) {\n+        if (src ==        IntRgb.getter) {\n+            if (dst ==              IntArgbPre.setter) {\n+                return    IntRgb.ToIntArgbPreConverter();\n+            }\n+        } else if (src == IntBgr.getter) {\n+            if (dst ==              IntArgbPre.setter) {\n+                return    IntBgr.ToIntArgbPreConverter();\n+            }\n+        } else if (src == IntArgb.getter) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/PixelUtils.java","additions":37,"deletions":4,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,0 +284,50 @@\n+\n+    static class SwapThreeByteConverter extends BaseByteToByteConverter {\n+        public SwapThreeByteConverter(BytePixelGetter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h)\n+        {\n+            srcscanbytes -= w * 3;\n+            dstscanbytes -= w * 3;\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    byte b0 = srcarr[srcoff];\n+                    byte b1 = srcarr[srcoff + 1];\n+                    byte b2 = srcarr[srcoff + 2];\n+                    dstarr[dstoff++] = b2;\n+                    dstarr[dstoff++] = b1;\n+                    dstarr[dstoff++] = b0;\n+                    srcoff += 3;\n+                }\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h)\n+        {\n+            srcscanbytes -= w * 3;\n+            dstscanbytes -= w * 3;\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    byte b0 = srcbuf.get(srcoff);\n+                    byte b1 = srcbuf.get(srcoff + 1);\n+                    byte b2 = srcbuf.get(srcoff + 2);\n+                    dstbuf.put(dstoff++, b2);\n+                    dstbuf.put(dstoff++, b1);\n+                    dstbuf.put(dstoff++, b0);\n+                    srcoff += 3;\n+                }\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/BaseByteToByteConverter.java","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.AlphaType;\n+import com.sun.javafx.image.BytePixelGetter;\n+import com.sun.javafx.image.BytePixelSetter;\n+import com.sun.javafx.image.ByteToBytePixelConverter;\n+import com.sun.javafx.image.PixelUtils;\n+import java.nio.ByteBuffer;\n+\n+abstract class BaseIndexedToByteConverter implements ByteToBytePixelConverter {\n+\n+    static abstract class IndexedGetter implements BytePixelGetter {\n+        final int[] preColors;\n+        final int[] nonPreColors;\n+        private final AlphaType alphaType;\n+\n+        IndexedGetter(int[] colors, AlphaType alphaType) {\n+            int[] preColors = null, nonPreColors = null;\n+\n+            switch (alphaType) {\n+                case OPAQUE -> {\n+                    nonPreColors = colors;\n+                    preColors = colors;\n+                }\n+\n+                case PREMULTIPLIED -> {\n+                    preColors = colors;\n+                    nonPreColors = new int[colors.length];\n+\n+                    for (int i = 0; i < colors.length; i++) {\n+                        nonPreColors[i] = PixelUtils.PretoNonPre(colors[i]);\n+                    }\n+                }\n+\n+                case NONPREMULTIPLIED -> {\n+                    nonPreColors = colors;\n+                    preColors = new int[colors.length];\n+\n+                    for (int i = 0; i < colors.length; i++) {\n+                        preColors[i] = PixelUtils.NonPretoPre(colors[i]);\n+                    }\n+                }\n+            }\n+\n+            this.alphaType = alphaType;\n+            this.preColors = preColors;\n+            this.nonPreColors = nonPreColors;\n+        }\n+\n+        @Override\n+        public AlphaType getAlphaType() {\n+            return alphaType;\n+        }\n+    }\n+\n+    protected final IndexedGetter getter;\n+    protected final BytePixelSetter setter;\n+    protected final int nSrcElems;\n+    protected final int nDstElems;\n+\n+    BaseIndexedToByteConverter(IndexedGetter getter, BytePixelSetter setter) {\n+        this.getter = getter;\n+        this.setter = setter;\n+        this.nSrcElems = getter.getNumElements();\n+        this.nDstElems = setter.getNumElements();\n+    }\n+\n+    @Override\n+    public final IndexedGetter getGetter() {\n+        return getter;\n+    }\n+\n+    @Override\n+    public final BytePixelSetter getSetter() {\n+        return setter;\n+    }\n+\n+    abstract void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                            byte[] dstarr, int dstoff, int dstscanbytes,\n+                            int w, int h);\n+\n+    abstract void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                            ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                            int w, int h);\n+\n+    @Override\n+    public final void convert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                              byte[] dstarr, int dstoff, int dstscanbytes,\n+                              int w, int h) {\n+        if (w <= 0 || h <= 0) return;\n+\n+        if (srcscanbytes == w * nSrcElems && dstscanbytes == w * nDstElems) {\n+            w *= h;\n+            h = 1;\n+        }\n+\n+        doConvert(srcarr, srcoff, srcscanbytes,\n+                  dstarr, dstoff, dstscanbytes,\n+                  w, h);\n+    }\n+\n+    @Override\n+    public final void convert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                              ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                              int w, int h) {\n+        if (w <= 0 || h <= 0) return;\n+\n+        if (srcscanbytes == w * nSrcElems && dstscanbytes == w * nDstElems) {\n+            w *= h;\n+            h = 1;\n+        }\n+\n+        if (srcbuf.hasArray() && dstbuf.hasArray()) {\n+            srcoff += srcbuf.arrayOffset();\n+            dstoff += dstbuf.arrayOffset();\n+            doConvert(srcbuf.array(), srcoff, srcscanbytes,\n+                      dstbuf.array(), dstoff, dstscanbytes,\n+                      w, h);\n+        } else {\n+            doConvert(srcbuf, srcoff, srcscanbytes,\n+                      dstbuf, dstoff, dstscanbytes,\n+                      w, h);\n+        }\n+    }\n+\n+    @Override\n+    public final void convert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                              byte[] dstarr, int dstoff, int dstscanbytes,\n+                              int w, int h) {\n+        if (w <= 0 || h <= 0) return;\n+\n+        if (srcscanbytes == w * nSrcElems && dstscanbytes == w * nDstElems) {\n+            w *= h;\n+            h = 1;\n+        }\n+\n+        if (srcbuf.hasArray()) {\n+            byte[] srcarr = srcbuf.array();\n+            srcoff += srcbuf.arrayOffset();\n+            doConvert(srcarr, srcoff, srcscanbytes,\n+                      dstarr, dstoff, dstscanbytes,\n+                      w, h);\n+        } else {\n+            ByteBuffer dstbuf = ByteBuffer.wrap(dstarr);\n+            doConvert(srcbuf, srcoff, srcscanbytes,\n+                      dstbuf, dstoff, dstscanbytes,\n+                      w, h);\n+        }\n+    }\n+\n+    @Override\n+    public final void convert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                              ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                              int w, int h) {\n+        if (w <= 0 || h <= 0) return;\n+\n+        if (srcscanbytes == w * nSrcElems && dstscanbytes == w * nDstElems) {\n+            w *= h;\n+            h = 1;\n+        }\n+\n+        if (dstbuf.hasArray()) {\n+            byte[] dstarr = dstbuf.array();\n+            dstoff += dstbuf.arrayOffset();\n+            doConvert(srcarr, srcoff, srcscanbytes,\n+                      dstarr, dstoff, dstscanbytes,\n+                      w, h);\n+        } else {\n+            ByteBuffer srcbuf = ByteBuffer.wrap(srcarr);\n+            doConvert(srcbuf, srcoff, srcscanbytes,\n+                      dstbuf, dstoff, dstscanbytes,\n+                      w, h);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/BaseIndexedToByteConverter.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.AlphaType;\n+import com.sun.javafx.image.BytePixelAccessor;\n+import com.sun.javafx.image.BytePixelGetter;\n+import com.sun.javafx.image.BytePixelSetter;\n+import com.sun.javafx.image.ByteToBytePixelConverter;\n+import com.sun.javafx.image.PixelUtils;\n+import java.nio.ByteBuffer;\n+\n+public final class ByteAbgr {\n+\n+    private ByteAbgr() {}\n+\n+    public static final BytePixelGetter     getter = Accessor.instance;\n+    public static final BytePixelSetter     setter = Accessor.instance;\n+    public static final BytePixelAccessor accessor = Accessor.instance;\n+\n+    private static ByteToBytePixelConverter ToByteBgraObj;\n+    public  static ByteToBytePixelConverter ToByteBgraConverter() {\n+        if (ToByteBgraObj == null) {\n+            ToByteBgraObj = BaseByteToByteConverter.createReorderer(\n+                getter, ByteBgra.setter, 1, 2, 3, 0);\n+        }\n+        return ToByteBgraObj;\n+    }\n+\n+    public static ByteToBytePixelConverter ToByteBgraPreConverter() {\n+        return ToByteBgraPreConv.instance;\n+    }\n+\n+    static class Accessor implements BytePixelAccessor {\n+        static final BytePixelAccessor instance = new Accessor();\n+        private Accessor() {}\n+\n+        @Override\n+        public AlphaType getAlphaType() {\n+            return AlphaType.NONPREMULTIPLIED;\n+        }\n+\n+        @Override\n+        public int getNumElements() {\n+            return 4;\n+        }\n+\n+        @Override\n+        public int getArgb(byte[] arr, int offset) {\n+            return (((arr[offset    ]       ) << 24) |\n+                    ((arr[offset + 1] & 0xff)      ) |\n+                    ((arr[offset + 2] & 0xff) <<  8) |\n+                    ((arr[offset + 3] & 0xff) << 16));\n+        }\n+\n+        @Override\n+        public int getArgbPre(byte[] arr, int offset) {\n+            return PixelUtils.NonPretoPre(getArgb(arr, offset));\n+        }\n+\n+        @Override\n+        public int getArgb(ByteBuffer buf, int offset) {\n+            return (((buf.get(offset    )       ) << 24) |\n+                    ((buf.get(offset + 1) & 0xff)      ) |\n+                    ((buf.get(offset + 2) & 0xff) <<  8) |\n+                    ((buf.get(offset + 3) & 0xff) << 16));\n+        }\n+\n+        @Override\n+        public int getArgbPre(ByteBuffer buf, int offset) {\n+            return PixelUtils.NonPretoPre(getArgb(buf, offset));\n+        }\n+\n+        @Override\n+        public void setArgb(byte[] arr, int offset, int argb) {\n+            arr[offset    ] = (byte) (argb >> 24);\n+            arr[offset + 1] = (byte) (argb      );\n+            arr[offset + 2] = (byte) (argb >>  8);\n+            arr[offset + 3] = (byte) (argb >> 16);\n+        }\n+\n+        @Override\n+        public void setArgbPre(byte[] arr, int offset, int argbpre) {\n+            setArgb(arr, offset, PixelUtils.PretoNonPre(argbpre));\n+        }\n+\n+        @Override\n+        public void setArgb(ByteBuffer buf, int offset, int argb) {\n+            buf.put(offset    , (byte) (argb >> 24));\n+            buf.put(offset + 1, (byte) (argb      ));\n+            buf.put(offset + 2, (byte) (argb >>  8));\n+            buf.put(offset + 3, (byte) (argb >> 16));\n+        }\n+\n+        @Override\n+        public void setArgbPre(ByteBuffer buf, int offset, int argbpre) {\n+            setArgb(buf, offset, PixelUtils.PretoNonPre(argbpre));\n+        }\n+    }\n+\n+    static class ToByteBgraPreConv extends BaseByteToByteConverter {\n+        static final ByteToBytePixelConverter instance =\n+            new ToByteBgraPreConv();\n+\n+        private ToByteBgraPreConv() {\n+            super(ByteAbgr.getter, ByteBgraPre.setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h)\n+        {\n+            srcscanbytes -= w * 4;\n+            dstscanbytes -= w * 4;\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int  a = srcarr[srcoff] & 0xff;\n+                    byte b = srcarr[srcoff + 1];\n+                    byte g = srcarr[srcoff + 2];\n+                    byte r = srcarr[srcoff + 3];\n+                    srcoff += 4;\n+                    if (a < 0xff) {\n+                        if (a == 0) {\n+                            b = g = r = 0;\n+                        } else {\n+                            b = (byte) (((b & 0xff) * a + 0x7f) \/ 0xff);\n+                            g = (byte) (((g & 0xff) * a + 0x7f) \/ 0xff);\n+                            r = (byte) (((r & 0xff) * a + 0x7f) \/ 0xff);\n+                        }\n+                    }\n+                    dstarr[dstoff++] = b;\n+                    dstarr[dstoff++] = g;\n+                    dstarr[dstoff++] = r;\n+                    dstarr[dstoff++] = (byte) a;\n+                }\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h)\n+        {\n+            srcscanbytes -= w * 4;\n+            dstscanbytes -= w * 4;\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int  a = srcbuf.get(srcoff) & 0xff;\n+                    byte b = srcbuf.get(srcoff + 1);\n+                    byte g = srcbuf.get(srcoff + 2);\n+                    byte r = srcbuf.get(srcoff + 3);\n+                    srcoff += 4;\n+                    if (a < 0xff) {\n+                        if (a == 0) {\n+                            b = g = r = 0;\n+                        } else {\n+                            b = (byte) (((b & 0xff) * a + 0x7f) \/ 0xff);\n+                            g = (byte) (((g & 0xff) * a + 0x7f) \/ 0xff);\n+                            r = (byte) (((r & 0xff) * a + 0x7f) \/ 0xff);\n+                        }\n+                    }\n+                    dstbuf.put(dstoff    , b);\n+                    dstbuf.put(dstoff + 1, g);\n+                    dstbuf.put(dstoff + 2, r);\n+                    dstbuf.put(dstoff + 3, (byte) a);\n+                    dstoff += 4;\n+                }\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/ByteAbgr.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,8 @@\n+    private static ByteToBytePixelConverter ToByteRgbObj;\n+    public static ByteToBytePixelConverter ToByteRgbConverter() {\n+        if (ToByteRgbObj == null) {\n+            ToByteRgbObj = new BaseByteToByteConverter.SwapThreeByteConverter(ByteBgr.getter, ByteRgb.setter);\n+        }\n+        return ToByteRgbObj;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/ByteBgr.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.javafx.image.BytePixelAccessor;\n@@ -34,0 +35,1 @@\n+import com.sun.javafx.image.PixelUtils;\n@@ -38,1 +40,2 @@\n-    public static final BytePixelGetter getter = Getter.instance;\n+    public static final BytePixelGetter getter = Accessor.instance;\n+    public static final BytePixelSetter setter = Accessor.instance;\n@@ -60,2 +63,6 @@\n-    public static final ByteToBytePixelConverter ToByteBgrConverter() {\n-        return ByteRgb.SwapThreeByteConverter.rgbToBgrInstance;\n+    private static ByteToBytePixelConverter rgbToBgrInstance;\n+    public static ByteToBytePixelConverter ToByteBgrConverter() {\n+        if (rgbToBgrInstance == null) {\n+            rgbToBgrInstance = new BaseByteToByteConverter.SwapThreeByteConverter(ByteRgb.getter, ByteBgr.setter);\n+        }\n+        return rgbToBgrInstance;\n@@ -64,3 +71,3 @@\n-    static class Getter implements BytePixelGetter {\n-        static final BytePixelGetter instance = new Getter();\n-        private Getter() {}\n+    static class Accessor implements BytePixelAccessor {\n+        static final BytePixelAccessor instance = new Accessor();\n+        private Accessor() {}\n@@ -109,0 +116,24 @@\n+\n+        @Override\n+        public void setArgb(byte[] arr, int offset, int argb) {\n+            arr[offset    ] = (byte)((argb >> 16) & 0xff);\n+            arr[offset + 1] = (byte)((argb >> 8) & 0xff);\n+            arr[offset + 2] = (byte)(argb & 0xff);\n+        }\n+\n+        @Override\n+        public void setArgbPre(byte[] arr, int offset, int argbpre) {\n+            setArgb(arr, offset, PixelUtils.PretoNonPre(argbpre));\n+        }\n+\n+        @Override\n+        public void setArgb(ByteBuffer buf, int offset, int argb) {\n+            buf.put(offset    , (byte)((argb >> 16) & 0xff));\n+            buf.put(offset + 1, (byte)((argb >> 8) & 0xff));\n+            buf.put(offset + 2, (byte)(argb & 0xff));\n+        }\n+\n+        @Override\n+        public void setArgbPre(ByteBuffer buf, int offset, int argbpre) {\n+            setArgb(buf, offset, PixelUtils.PretoNonPre(argbpre));\n+        }\n@@ -257,47 +288,0 @@\n-\n-    static class SwapThreeByteConverter extends BaseByteToByteConverter {\n-        static final ByteToBytePixelConverter rgbToBgrInstance =\n-            new SwapThreeByteConverter(ByteRgb.getter, ByteBgr.accessor);\n-\n-        public SwapThreeByteConverter(BytePixelGetter getter, BytePixelSetter setter) {\n-            super(getter, setter);\n-        }\n-\n-        @Override\n-        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n-                       byte[] dstarr, int dstoff, int dstscanbytes,\n-                       int w, int h)\n-        {\n-            srcscanbytes -= w * 3;\n-            srcscanbytes -= w * 4;\n-            while (--h >= 0) {\n-                for (int x = 0; x < w; x++) {\n-                    dstarr[dstoff++] = srcarr[srcoff + 2];\n-                    dstarr[dstoff++] = srcarr[srcoff + 1];\n-                    dstarr[dstoff++] = srcarr[srcoff    ];\n-                    srcoff += 3;\n-                }\n-                srcoff += srcscanbytes;\n-                dstoff += dstscanbytes;\n-            }\n-        }\n-\n-        @Override\n-        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n-                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n-                       int w, int h)\n-        {\n-            srcscanbytes -= w * 3;\n-            srcscanbytes -= w * 4;\n-            while (--h >= 0) {\n-                for (int x = 0; x < w; x++) {\n-                    dstbuf.put(dstoff++, srcbuf.get(srcoff + 2));\n-                    dstbuf.put(dstoff++, srcbuf.get(srcoff + 1));\n-                    dstbuf.put(dstoff++, srcbuf.get(srcoff    ));\n-                    srcoff += 3;\n-                }\n-                srcoff += srcscanbytes;\n-                dstoff += dstscanbytes;\n-            }\n-        }\n-    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/ByteRgb.java","additions":38,"deletions":54,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,3 +61,3 @@\n-\/\/    public static ByteToBytePixelConverter ToByteBgraPreConverter() {\n-\/\/        return ByteRgba.ToByteBgraPreConv.instance;\n-\/\/    }\n+    public static ByteToBytePixelConverter ToByteBgraPreConverter() {\n+        return ByteRgba.ToByteBgraPreConv.instance;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/ByteRgba.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.AlphaType;\n+import com.sun.javafx.image.BytePixelSetter;\n+import com.sun.javafx.image.ByteToBytePixelConverter;\n+import java.nio.ByteBuffer;\n+\n+public final class EightBitIndexed {\n+\n+    private EightBitIndexed() {}\n+\n+    public static Getter createGetter(int[] colors, AlphaType alphaType) {\n+        return new Getter(colors, alphaType);\n+    }\n+\n+    public static ByteToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\n+        return new ToByteRgbConverter(src, dst);\n+    }\n+\n+    public static ByteToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\n+        return new ToByteBgraAnyConverter(src, dst);\n+    }\n+\n+    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\n+        Getter(int[] colors, AlphaType alphaType) {\n+            super(colors, alphaType);\n+        }\n+\n+        @Override\n+        public int getNumElements() {\n+            return 8;\n+        }\n+\n+        @Override\n+        public int getArgb(byte[] arr, int offset) {\n+            return preColors[arr[offset]];\n+        }\n+\n+        @Override\n+        public int getArgbPre(byte[] arr, int offset) {\n+            return nonPreColors[arr[offset]];\n+        }\n+\n+        @Override\n+        public int getArgb(ByteBuffer buf, int offset) {\n+            return preColors[buf.get(offset)];\n+        }\n+\n+        @Override\n+        public int getArgbPre(ByteBuffer buf, int offset) {\n+            return nonPreColors[buf.get(offset)];\n+        }\n+    }\n+\n+    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\n+        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[srcarr[srcoff + x]];\n+                    dstarr[dstoff++] = (byte) argb;\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 24);\n+                }\n+\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[srcbuf.get(srcoff + x)];\n+                    dstbuf.put(dstoff, (byte) argb);\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\n+                    dstoff += 4;\n+                }\n+\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+\n+    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\n+        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = getGetter().nonPreColors;\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[srcarr[srcoff + x]];\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) argb;\n+                }\n+\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = getGetter().nonPreColors;\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[srcbuf.get(srcoff + x)];\n+                    dstbuf.put(dstoff, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) argb);\n+                    dstoff += 3;\n+                }\n+\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/EightBitIndexed.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.AlphaType;\n+import com.sun.javafx.image.BytePixelSetter;\n+import com.sun.javafx.image.ByteToBytePixelConverter;\n+import java.nio.ByteBuffer;\n+\n+public final class FourBitIndexed {\n+\n+    private FourBitIndexed() {}\n+\n+    public static Getter createGetter(int[] colors, AlphaType alphaType) {\n+        return new Getter(colors, alphaType);\n+    }\n+\n+    public static ByteToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\n+        return new ToByteRgbConverter(src, dst);\n+    }\n+\n+    public static ByteToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\n+        return new ToByteBgraAnyConverter(src, dst);\n+    }\n+\n+    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\n+        Getter(int[] colors, AlphaType alphaType) {\n+            super(colors, alphaType);\n+        }\n+\n+        @Override\n+        public int getNumElements() {\n+            return 4;\n+        }\n+\n+        @Override\n+        public int getArgb(byte[] arr, int offset) {\n+            return preColors[(arr[offset \/ 2] >> (4 - offset % 2 * 4)) & 0xf];\n+        }\n+\n+        @Override\n+        public int getArgbPre(byte[] arr, int offset) {\n+            return nonPreColors[(arr[offset \/ 2] >> (4 - offset % 2 * 4)) & 0xf];\n+        }\n+\n+        @Override\n+        public int getArgb(ByteBuffer buf, int offset) {\n+            return preColors[(buf.get(offset \/ 2) >> (4 - offset % 2 * 4)) & 0xf];\n+        }\n+\n+        @Override\n+        public int getArgbPre(ByteBuffer buf, int offset) {\n+            return nonPreColors[(buf.get(offset \/ 2) >> (4 - offset % 2 * 4)) & 0xf];\n+        }\n+    }\n+\n+    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\n+        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int srcscanbits = srcscanbytes * 8;\n+            int srcoffbits = srcoff * 8;\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcarr[srcoffbits \/ 8 + x \/ 2] >> (4 - x % 2 * 4)) & 0xf];\n+                    dstarr[dstoff++] = (byte) argb;\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 24);\n+                }\n+\n+                srcoffbits += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int srcscanbits = srcscanbytes * 8;\n+            int srcoffbits = srcoff * 8;\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcbuf.get(srcoffbits \/ 8 + x \/ 2) >> (4 - x % 2 * 4)) & 0xf];\n+                    dstbuf.put(dstoff, (byte) argb);\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\n+                    dstoff += 4;\n+                }\n+\n+                srcoffbits += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+\n+    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\n+        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int srcscanbits = srcscanbytes * 8;\n+            int srcoffbits = srcoff * 8;\n+            int[] colors = getGetter().nonPreColors;\n+\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcarr[srcoffbits \/ 8 + x \/ 2] >> (4 - x % 2 * 4)) & 0xf];\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) argb;\n+                }\n+\n+                srcoffbits += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int srcscanbits = srcscanbytes * 8;\n+            int srcoffbits = srcoff * 8;\n+            int[] colors = getGetter().nonPreColors;\n+\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcbuf.get(srcoffbits \/ 8 + x \/ 2) >> (4 - x % 2 * 4)) & 0xf];\n+                    dstbuf.put(dstoff, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) argb);\n+                    dstoff += 3;\n+                }\n+\n+                srcoffbits += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/FourBitIndexed.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.AlphaType;\n+import com.sun.javafx.image.IntPixelAccessor;\n+import com.sun.javafx.image.IntPixelGetter;\n+import com.sun.javafx.image.IntPixelSetter;\n+import com.sun.javafx.image.IntToIntPixelConverter;\n+import com.sun.javafx.image.PixelUtils;\n+import java.nio.IntBuffer;\n+\n+public final class IntBgr {\n+    private IntBgr() {}\n+\n+    public static final IntPixelGetter     getter = Accessor.instance;\n+    public static final IntPixelSetter     setter = Accessor.instance;\n+    public static final IntPixelAccessor accessor = Accessor.instance;\n+\n+    public static IntToIntPixelConverter ToIntArgbPreConverter() {\n+        return IntBgr.ToIntArgbPreConv.instance;\n+    }\n+\n+    static class Accessor implements IntPixelAccessor {\n+        static final IntPixelAccessor instance = new Accessor();\n+        private Accessor() {}\n+\n+        @Override\n+        public AlphaType getAlphaType() {\n+            return AlphaType.OPAQUE;\n+        }\n+\n+        @Override\n+        public int getNumElements() {\n+            return 1;\n+        }\n+\n+        @Override\n+        public int getArgb(int[] arr, int offset) {\n+            int pixel = arr[offset];\n+            int r = pixel & 0xff;\n+            int g = (pixel >> 8) & 0xff;\n+            int b = (pixel >> 16) & 0xff;\n+            return (255 << 24) | (r << 16) | (g << 8) | b;\n+        }\n+\n+        @Override\n+        public int getArgbPre(int[] arr, int offset) {\n+            return PixelUtils.NonPretoPre(getArgb(arr, offset));\n+        }\n+\n+        @Override\n+        public int getArgb(IntBuffer buffer, int offset) {\n+            int pixel = buffer.get(offset);\n+            int r = pixel & 0xff;\n+            int g = (pixel >> 8) & 0xff;\n+            int b = (pixel >> 16) & 0xff;\n+            return (255 << 24) | (r << 16) | (g << 8) | b;\n+        }\n+\n+        @Override\n+        public int getArgbPre(IntBuffer buffer, int offset) {\n+            return PixelUtils.NonPretoPre(getArgb(buffer, offset));\n+        }\n+\n+        @Override\n+        public void setArgb(int[] arr, int offset, int argb) {\n+            int b = argb & 0xff;\n+            int g = (argb >> 8) & 0xff;\n+            int r = (argb >> 16) & 0xff;\n+            arr[offset] = (255 << 24) | (b << 16) | (g << 8) | r;\n+        }\n+\n+        @Override\n+        public void setArgbPre(int[] arr, int offset, int argbpre) {\n+            setArgb(arr, offset, PixelUtils.PretoNonPre(argbpre));\n+        }\n+\n+        @Override\n+        public void setArgb(IntBuffer buffer, int offset, int argb) {\n+            int b = argb & 0xff;\n+            int g = (argb >> 8) & 0xff;\n+            int r = (argb >> 16) & 0xff;\n+            buffer.put(offset, (255 << 24) | (b << 16) | (g << 8) | r);\n+        }\n+\n+        @Override\n+        public void setArgbPre(IntBuffer buffer, int offset, int argbpre) {\n+            setArgb(buffer, offset, PixelUtils.PretoNonPre(argbpre));\n+        }\n+    }\n+\n+    public static class ToIntArgbPreConv extends BaseIntToIntConverter {\n+        public static final IntToIntPixelConverter instance =\n+            new ToIntArgbPreConv();\n+\n+        private ToIntArgbPreConv() {\n+            super(IntBgr.getter, IntArgbPre.setter);\n+        }\n+\n+        @Override\n+        void doConvert(int[] srcarr, int srcoff, int srcscanints,\n+                       int[] dstarr, int dstoff, int dstscanints,\n+                       int w, int h)\n+        {\n+            srcscanints -= w;\n+            dstscanints -= w;\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int pixel = srcarr[srcoff++];\n+                    int b = (pixel >> 16) & 0xff;\n+                    int g = (pixel >>  8) & 0xff;\n+                    int r = (pixel      ) & 0xff;\n+                    dstarr[dstoff++] = (255 << 24) | (r << 16) | (g << 8) | b;\n+                }\n+                srcoff += srcscanints;\n+                dstoff += dstscanints;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(IntBuffer srcbuf, int srcoff, int srcscanints,\n+                       IntBuffer dstbuf, int dstoff, int dstscanints,\n+                       int w, int h)\n+        {\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int pixel = srcbuf.get(srcoff + x);\n+                    int b = (pixel >> 16) & 0xff;\n+                    int g = (pixel >>  8) & 0xff;\n+                    int r = (pixel      ) & 0xff;\n+                    dstbuf.put(dstoff + x, (255 << 24) | (r << 16) | (g << 8) | b);\n+                }\n+                srcoff += srcscanints;\n+                dstoff += dstscanints;\n+            }\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/IntBgr.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.AlphaType;\n+import com.sun.javafx.image.IntPixelAccessor;\n+import com.sun.javafx.image.IntPixelGetter;\n+import com.sun.javafx.image.IntPixelSetter;\n+import com.sun.javafx.image.IntToIntPixelConverter;\n+import com.sun.javafx.image.PixelUtils;\n+import java.nio.IntBuffer;\n+\n+public class IntRgb {\n+    private IntRgb() {}\n+\n+    public static final IntPixelGetter     getter = Accessor.instance;\n+    public static final IntPixelSetter     setter = Accessor.instance;\n+    public static final IntPixelAccessor accessor = Accessor.instance;\n+\n+    public static IntToIntPixelConverter ToIntArgbPreConverter() {\n+        return IntRgb.ToIntArgbPreConv.instance;\n+    }\n+\n+    static class Accessor implements IntPixelAccessor {\n+        static final IntPixelAccessor instance = new Accessor();\n+        private Accessor() {}\n+\n+        @Override\n+        public AlphaType getAlphaType() {\n+            return AlphaType.OPAQUE;\n+        }\n+\n+        @Override\n+        public int getNumElements() {\n+            return 1;\n+        }\n+\n+        @Override\n+        public int getArgb(int[] arr, int offset) {\n+            return arr[offset] | (0xff << 24);\n+        }\n+\n+        @Override\n+        public int getArgbPre(int[] arr, int offset) {\n+            return PixelUtils.NonPretoPre(arr[offset] | (0xff << 24));\n+        }\n+\n+        @Override\n+        public int getArgb(IntBuffer buffer, int offset) {\n+            return buffer.get(offset) | (0xff << 24);\n+        }\n+\n+        @Override\n+        public int getArgbPre(IntBuffer buffer, int offset) {\n+            return PixelUtils.NonPretoPre(buffer.get(offset) | (0xff << 24));\n+        }\n+\n+        @Override\n+        public void setArgb(int[] arr, int offset, int argb) {\n+            arr[offset] = argb | (0xff << 24);\n+        }\n+\n+        @Override\n+        public void setArgbPre(int[] arr, int offset, int argbpre) {\n+            arr[offset] = PixelUtils.PretoNonPre(argbpre) | (0xff << 24);\n+        }\n+\n+        @Override\n+        public void setArgb(IntBuffer buffer, int offset, int argb) {\n+            buffer.put(offset, argb | (0xff << 24));\n+        }\n+\n+        @Override\n+        public void setArgbPre(IntBuffer buffer, int offset, int argbpre) {\n+            buffer.put(offset, PixelUtils.PretoNonPre(argbpre) | (0xff << 24));\n+        }\n+    }\n+\n+    public static class ToIntArgbPreConv extends BaseIntToIntConverter {\n+        public static final IntToIntPixelConverter instance =\n+            new ToIntArgbPreConv();\n+\n+        private ToIntArgbPreConv() {\n+            super(IntRgb.getter, IntArgbPre.setter);\n+        }\n+\n+        @Override\n+        void doConvert(int[] srcarr, int srcoff, int srcscanints,\n+                       int[] dstarr, int dstoff, int dstscanints,\n+                       int w, int h)\n+        {\n+            srcscanints -= w;\n+            dstscanints -= w;\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int pixel = srcarr[srcoff++];\n+                    int r = (pixel >> 16) & 0xff;\n+                    int g = (pixel >>  8) & 0xff;\n+                    int b = (pixel      ) & 0xff;\n+                    dstarr[dstoff++] = (255 << 24) | (r << 16) | (g << 8) | b;\n+                }\n+                srcoff += srcscanints;\n+                dstoff += dstscanints;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(IntBuffer srcbuf, int srcoff, int srcscanints,\n+                       IntBuffer dstbuf, int dstoff, int dstscanints,\n+                       int w, int h)\n+        {\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int pixel = srcbuf.get(srcoff + x);\n+                    int r = (pixel >> 16) & 0xff;\n+                    int g = (pixel >>  8) & 0xff;\n+                    int b = (pixel      ) & 0xff;\n+                    dstbuf.put(dstoff + x, (255 << 24) | (r << 16) | (g << 8) | b);\n+                }\n+                srcoff += srcscanints;\n+                dstoff += dstscanints;\n+            }\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/IntRgb.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.AlphaType;\n+import com.sun.javafx.image.BytePixelSetter;\n+import com.sun.javafx.image.ByteToBytePixelConverter;\n+import java.nio.ByteBuffer;\n+\n+public final class OneBitIndexed {\n+\n+    private OneBitIndexed() {}\n+\n+    public static Getter createGetter(int[] colors, AlphaType alphaType) {\n+        return new Getter(colors, alphaType);\n+    }\n+\n+    public static ByteToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\n+        return new ToByteRgbConverter(src, dst);\n+    }\n+\n+    public static ByteToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\n+        return new ToByteBgraAnyConverter(src, dst);\n+    }\n+\n+    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\n+        Getter(int[] colors, AlphaType alphaType) {\n+            super(colors, alphaType);\n+        }\n+\n+        @Override\n+        public int getNumElements() {\n+            return 1;\n+        }\n+\n+        @Override\n+        public int getArgb(byte[] arr, int offset) {\n+            return preColors[(arr[offset \/ 8] >> (7 - offset % 8)) & 1];\n+        }\n+\n+        @Override\n+        public int getArgbPre(byte[] arr, int offset) {\n+            return nonPreColors[(arr[offset \/ 8] >> (7 - offset % 8)) & 1];\n+        }\n+\n+        @Override\n+        public int getArgb(ByteBuffer buf, int offset) {\n+            return preColors[(buf.get(offset \/ 8) >> (7 - offset % 8)) & 1];\n+        }\n+\n+        @Override\n+        public int getArgbPre(ByteBuffer buf, int offset) {\n+            return nonPreColors[(buf.get(offset \/ 8) >> (7 - offset % 8)) & 1];\n+        }\n+    }\n+\n+    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\n+        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int srcscanbits = srcscanbytes * 8;\n+            int srcoffbits = srcoff * 8;\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcarr[srcoffbits \/ 8 + x \/ 8] >> (7 - x % 8)) & 1];\n+                    dstarr[dstoff++] = (byte) argb;\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 24);\n+                }\n+\n+                srcoffbits += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int srcscanbits = srcscanbytes * 8;\n+            int srcoffbits = srcoff * 8;\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcbuf.get(srcoffbits \/ 8 + x \/ 8) >> (7 - x % 8)) & 1];\n+                    dstbuf.put(dstoff, (byte) argb);\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\n+                    dstoff += 4;\n+                }\n+\n+                srcoffbits += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+\n+    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\n+        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int srcscanbits = srcscanbytes * 8;\n+            int srcoffbits = srcoff * 8;\n+            int[] colors = getGetter().nonPreColors;\n+\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcarr[srcoffbits \/ 8 + x \/ 8] >> (7 - x % 8)) & 1];\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) argb;\n+                }\n+\n+                srcoffbits += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int srcscanbits = srcscanbytes * 8;\n+            int srcoffbits = srcoff * 8;\n+            int[] colors = getGetter().nonPreColors;\n+\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcbuf.get(srcoffbits \/ 8 + x \/ 8) >> (7 - x % 8)) & 1];\n+                    dstbuf.put(dstoff, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) argb);\n+                    dstoff += 3;\n+                }\n+\n+                srcoffbits += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/OneBitIndexed.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.AlphaType;\n+import com.sun.javafx.image.BytePixelSetter;\n+import com.sun.javafx.image.ByteToBytePixelConverter;\n+import java.nio.ByteBuffer;\n+\n+public final class TwoBitIndexed {\n+\n+    private TwoBitIndexed() {}\n+\n+    public static Getter createGetter(int[] colors, AlphaType alphaType) {\n+        return new Getter(colors, alphaType);\n+    }\n+\n+    public static ByteToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\n+        return new ToByteRgbConverter(src, dst);\n+    }\n+\n+    public static ByteToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\n+        return new ToByteBgraAnyConverter(src, dst);\n+    }\n+\n+    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\n+        Getter(int[] colors, AlphaType alphaType) {\n+            super(colors, alphaType);\n+        }\n+\n+        @Override\n+        public int getNumElements() {\n+            return 2;\n+        }\n+\n+        @Override\n+        public int getArgb(byte[] arr, int offset) {\n+            return preColors[(arr[offset \/ 4] >> (6 - offset % 4 * 2)) & 3];\n+        }\n+\n+        @Override\n+        public int getArgbPre(byte[] arr, int offset) {\n+            return nonPreColors[(arr[offset \/ 4] >> (6 - offset % 4 * 2)) & 3];\n+        }\n+\n+        @Override\n+        public int getArgb(ByteBuffer buf, int offset) {\n+            return preColors[(buf.get(offset \/ 4) >> (6 - offset % 4 * 2)) & 3];\n+        }\n+\n+        @Override\n+        public int getArgbPre(ByteBuffer buf, int offset) {\n+            return nonPreColors[(buf.get(offset \/ 4) >> (6 - offset % 4 * 2)) & 3];\n+        }\n+    }\n+\n+    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\n+        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int srcscanbits = srcscanbytes * 8;\n+            int srcoffbits = srcoff * 8;\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcarr[srcoffbits \/ 8 + x \/ 4] >> (6 - x % 4 * 2)) & 3];\n+                    dstarr[dstoff++] = (byte) argb;\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 24);\n+                }\n+                srcoffbits += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int srcscanbits = srcscanbytes * 8;\n+            int srcoffbits = srcoff * 8;\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcbuf.get(srcoffbits \/ 8 + x \/ 4) >> (6 - x % 4 * 2)) & 3];\n+                    dstbuf.put(dstoff, (byte) argb);\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\n+                    dstoff += 4;\n+                }\n+\n+                srcoffbits += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+\n+    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\n+        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int srcscanbits = srcscanbytes * 8;\n+            int srcoffbits = srcoff * 8;\n+            int[] colors = getGetter().nonPreColors;\n+\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcarr[srcoffbits \/ 8 + x \/ 4] >> (6 - x % 4 * 2)) & 3];\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) argb;\n+                }\n+\n+                srcoffbits += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int srcscanbits = srcscanbytes * 8;\n+            int srcoffbits = srcoff * 8;\n+            int[] colors = getGetter().nonPreColors;\n+\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcbuf.get(srcoffbits \/ 8 + x \/ 4) >> (6 - x % 4 * 2)) & 3];\n+                    dstbuf.put(dstoff, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) argb);\n+                    dstoff += 3;\n+                }\n+\n+                srcoffbits += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/TwoBitIndexed.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,6 @@\n+import com.sun.javafx.image.AlphaType;\n+import com.sun.javafx.image.impl.ByteIndexed;\n+import com.sun.javafx.image.impl.EightBitIndexed;\n+import com.sun.javafx.image.impl.FourBitIndexed;\n+import com.sun.javafx.image.impl.OneBitIndexed;\n+import com.sun.javafx.image.impl.TwoBitIndexed;\n@@ -50,0 +56,2 @@\n+import com.sun.javafx.image.impl.ByteAbgr;\n+import com.sun.javafx.image.impl.ByteBgr;\n@@ -57,0 +65,3 @@\n+import com.sun.javafx.image.impl.IntArgb;\n+import com.sun.javafx.image.impl.IntBgr;\n+import com.sun.javafx.image.impl.IntRgb;\n@@ -203,1 +214,1 @@\n-    \/*\n+    \/**\n@@ -206,2 +217,2 @@\n-     * It does not duplicate the memory, except in L8A8 case.\n-     * If it necessary, it does in-place format conversion like RGBA->BGRA\n+     * If possible, it does not duplicate the memory.\n+     * If necessary, it does in-place format conversion like RGBA->BGRA\n@@ -213,1 +224,0 @@\n-        ByteBuffer buffer = (ByteBuffer) frame.getImageData();\n@@ -216,1 +226,1 @@\n-        int scanBytes = frame.getStride();\n+        int stride = frame.getStride();\n@@ -219,38 +229,133 @@\n-        switch (type) {\n-            case GRAY:\n-                return Image.fromByteGrayData(buffer, w, h, scanBytes, ps);\n-\n-            case RGB:\n-                return Image.fromByteRgbData(buffer, w, h, scanBytes, ps);\n-\n-            case RGBA:\n-                \/\/ Bgra => BgrePre is same operation as Rgba => RgbaPre\n-                \/\/ TODO: 3D - need a way to handle pre versus non-Pre\n-                ByteBgra.ToByteBgraPreConverter().convert(buffer, 0, scanBytes,\n-                                                          buffer, 0, scanBytes,\n-                                                          w, h);\n-                \/* NOBREAK *\/\n-            case RGBA_PRE:\n-                ByteRgba.ToByteBgraConverter().convert(buffer, 0, scanBytes,\n-                                                       buffer, 0, scanBytes,\n-                                                       w, h);\n-                return Image.fromByteBgraPreData(buffer, w, h, scanBytes, ps);\n-\n-            case GRAY_ALPHA:\n-                \/\/ TODO: 3D - need a way to handle pre versus non-Pre\n-                ByteGrayAlpha.ToByteGrayAlphaPreConverter().convert(buffer, 0, scanBytes,\n-                                                                    buffer, 0, scanBytes,\n-                                                                    w, h);\n-                \/* NOBREAK *\/\n-            case GRAY_ALPHA_PRE:\n-                if (scanBytes != w * 2) {\n-                    throw new AssertionError(\"Bad stride for GRAY_ALPHA\");\n-                }\n-                byte newbuf[] = new byte[w * h * 4];\n-                ByteGrayAlphaPre.ToByteBgraPreConverter().convert(buffer, 0, scanBytes,\n-                                                                  newbuf, 0, w*4,\n-                                                                  w, h);\n-                return Image.fromByteBgraPreData(newbuf, w, h, ps);\n-            default:\n-                throw new RuntimeException(\"Unknown image type: \" + type);\n-        }\n+        \/\/ GRAY, RGB, BGRA_PRE, and INT_ARGB_PRE are directly supported by Prism.\n+        \/\/ We'll need to convert all other formats that we might encounter to one of the supported formats.\n+        return switch (type) {\n+            case GRAY -> fromByteGrayData((ByteBuffer)frame.getImageData(), w, h, stride, ps);\n+            case RGB -> fromByteRgbData((ByteBuffer)frame.getImageData(), w, h, stride, ps);\n+            case BGRA_PRE -> fromByteBgraPreData((ByteBuffer)frame.getImageData(), w, h, stride, ps);\n+\n+            case INT_ARGB_PRE ->\n+                \/\/ Note: from here on, stride is measured in bytes.\n+                fromIntArgbPreData((IntBuffer)frame.getImageData(), w, h, stride * 4, ps);\n+\n+            case GRAY_ALPHA -> {\n+                byte[] buffer = new byte[w * h * 4];\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteGrayAlpha.ToByteGrayAlphaPreConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                ByteGrayAlphaPre.ToByteBgraPreConverter().convert(imageData, 0, stride, buffer, 0, w * 4, w, h);\n+                yield fromByteBgraPreData(buffer, w, h, ps);\n+            }\n+\n+            case GRAY_ALPHA_PRE -> {\n+                byte[] buffer = new byte[w * h * 4];\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteGrayAlphaPre.ToByteBgraPreConverter().convert(imageData, 0, stride, buffer, 0, w * 4, w, h);\n+                yield fromByteBgraPreData(buffer, w, h, ps);\n+            }\n+\n+            case BGR -> {\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteBgr.ToByteRgbConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromByteRgbData(imageData, w, h, stride, ps);\n+            }\n+\n+            case RGBA -> {\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteRgba.ToByteBgraPreConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromByteBgraPreData(imageData, w, h, stride, ps);\n+            }\n+\n+            case RGBA_PRE -> {\n+                \/\/ Source is already premultiplied, so the non-pre converter is sufficient.\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteRgba.ToByteBgraConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromByteBgraPreData(imageData, w, h, stride, ps);\n+            }\n+\n+            case BGRA -> {\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteBgra.ToByteBgraPreConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromByteBgraPreData(imageData, w, h, stride, ps);\n+            }\n+\n+            case ABGR -> {\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteAbgr.ToByteBgraPreConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromByteBgraPreData(imageData, w, h, stride, ps);\n+            }\n+\n+            case ABGR_PRE -> {\n+                \/\/ Source is already premultiplied, so the non-pre converter is sufficient.\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteAbgr.ToByteBgraConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromByteBgraPreData(imageData, w, h, stride, ps);\n+            }\n+\n+            case INT_RGB -> {\n+                IntBuffer imageData = (IntBuffer)frame.getImageData();\n+                IntRgb.ToIntArgbPreConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromIntArgbPreData(imageData, w, h, stride * 4, ps); \/\/ Note: from here on, stride is measured in bytes.\n+            }\n+\n+            case INT_BGR -> {\n+                IntBuffer imageData = (IntBuffer)frame.getImageData();\n+                IntBgr.ToIntArgbPreConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromIntArgbPreData(imageData, w, h, stride * 4, ps); \/\/ Note: from here on, stride is measured in bytes.\n+            }\n+\n+            case INT_ARGB -> {\n+                IntBuffer imageData = (IntBuffer)frame.getImageData();\n+                IntArgb.ToIntArgbPreConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromIntArgbPreData(imageData, w, h, stride * 4, ps); \/\/ Note: from here on, stride is measured in bytes.\n+            }\n+\n+            case PALETTE, PALETTE_ALPHA, PALETTE_ALPHA_PRE -> {\n+                AlphaType alphaType = switch (type) {\n+                    case PALETTE_ALPHA -> AlphaType.NONPREMULTIPLIED;\n+                    case PALETTE_ALPHA_PRE -> AlphaType.PREMULTIPLIED;\n+                    default -> AlphaType.OPAQUE; \/\/ PALETTE\n+                };\n+\n+                ByteToBytePixelConverter converter = switch (frame.getPaletteIndexBits()) {\n+                    case 1 -> {\n+                        var getter = OneBitIndexed.createGetter(frame.getPalette(), alphaType);\n+                        yield alphaType == AlphaType.OPAQUE\n+                            ? OneBitIndexed.createToByteRgb(getter, ByteRgb.setter)\n+                            : OneBitIndexed.createToByteBgraAny(getter, ByteBgraPre.setter);\n+                    }\n+\n+                    case 2 -> {\n+                        var getter = TwoBitIndexed.createGetter(frame.getPalette(), alphaType);\n+                        yield alphaType == AlphaType.OPAQUE\n+                            ? TwoBitIndexed.createToByteRgb(getter, ByteRgb.setter)\n+                            : TwoBitIndexed.createToByteBgraAny(getter, ByteBgraPre.setter);\n+                    }\n+\n+                    case 4 -> {\n+                        var getter = FourBitIndexed.createGetter(frame.getPalette(), alphaType);\n+                        yield alphaType == AlphaType.OPAQUE\n+                            ? FourBitIndexed.createToByteRgb(getter, ByteRgb.setter)\n+                            : FourBitIndexed.createToByteBgraAny(getter, ByteBgraPre.setter);\n+                    }\n+\n+                    case 8 -> {\n+                        var getter = EightBitIndexed.createGetter(frame.getPalette(), alphaType);\n+                        yield alphaType == AlphaType.OPAQUE\n+                            ? EightBitIndexed.createToByteRgb(getter, ByteRgb.setter)\n+                            : EightBitIndexed.createToByteBgraAny(getter, ByteBgraPre.setter);\n+                    }\n+\n+                    default -> throw new RuntimeException(\"Unsupported bits per pixel: \" + frame.getPaletteIndexBits());\n+                };\n+\n+                int dstPixelSize = alphaType == AlphaType.OPAQUE ? 3 : 4;\n+                byte[] buffer = new byte[w * h * dstPixelSize];\n+                converter.convert((ByteBuffer)frame.getImageData(), 0, stride, buffer, 0, w * dstPixelSize, w, h);\n+\n+                yield alphaType == AlphaType.OPAQUE\n+                    ? fromByteRgbData(buffer, w, h)\n+                    : fromByteBgraPreData(buffer, w, h, ps);\n+            }\n+\n+            case PALETTE_TRANS ->\n+                throw new RuntimeException(\"Unsupported image type: \" + type);\n+        };\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/Image.java","additions":149,"deletions":44,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n- * Supported image formats are:\n+ * JavaFX has built-in support for the following image formats:\n@@ -75,0 +75,2 @@\n+ * For all other formats, JavaFX uses the {@link javax.imageio Java Image I\/O API} on supported platforms.\n+ * Image I\/O is extensible so that developers can \"plug-in\" support for additional formats.\n@@ -79,1 +81,1 @@\n- * filtering used when scaling, and whether or not to preserve the original\n+ * filtering used when scaling, and whether to preserve the original\n@@ -82,1 +84,1 @@\n- * <p>If a URL string is passed to a constructor, it be any of the following:\n+ * <p>If a URL string is passed to a constructor, it can be any of the following:\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/image\/Image.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -22,0 +22,1 @@\n+--add-exports javafx.graphics\/com.sun.javafx.iio.javax=ALL-UNNAMED\n@@ -56,0 +57,1 @@\n+--add-opens java.desktop\/javax.imageio=ALL-UNNAMED\n","filename":"modules\/javafx.graphics\/src\/test\/addExports","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-            loader.load(0, 1, 1, true, true);\n+            loader.load(0, 1, 1, true, true, 1, 1);\n@@ -212,1 +212,1 @@\n-        ImageFrame f = l.load(0, 0, 0, true, false);\n+        ImageFrame f = l.load(0, 0, 0, true, false, 1, 1);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/iio\/GIFLoaderTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -354,1 +354,1 @@\n-            0, 0, 0, null, null);\n+            0, 0, 0, null);\n@@ -361,1 +361,1 @@\n-                    @Override public ImageFrame load(int i, int w, int h, boolean p, boolean s) {\n+                    @Override public ImageFrame load(int i, double w, double h, boolean p, boolean s, float s0, float s1) {\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/iio\/ImageStorageTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        ImageFrame frame = loader.load(0, 0, 0, true, true);\n+        ImageFrame frame = loader.load(0, 0, 0, true, true, 1, 1);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/iio\/bmp\/BMPImageLoaderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.iio.javax;\n+\n+import com.sun.javafx.iio.ImageFrame;\n+import com.sun.javafx.iio.ImageLoadListener;\n+import com.sun.javafx.iio.ImageLoader;\n+import com.sun.javafx.iio.ImageMetadata;\n+import com.sun.javafx.iio.ImageStorage.ImageType;\n+import com.sun.javafx.iio.javax.XImageLoader;\n+import com.sun.javafx.iio.javax.XImageLoaderFactory;\n+import com.sun.prism.Image;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageReadParam;\n+import javax.imageio.ImageReader;\n+import javax.imageio.ImageTypeSpecifier;\n+import javax.imageio.metadata.IIOMetadata;\n+import javax.imageio.stream.ImageInputStream;\n+import java.awt.image.BufferedImage;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import com.sun.prism.PixelFormat;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class XImageLoaderTest {\n+\n+    private int color(int r, int g, int b) {\n+        return 255 << 24 | (r & 0xff) << 16 | (g & 0xff) << 8 | (b & 0xff);\n+    }\n+\n+    private void assertImageContent(Image image) {\n+        assertEquals(color(255, 0, 0), image.getArgb(0, 0));\n+        assertEquals(color(0, 255, 0), image.getArgb(5, 0));\n+        assertEquals(color(0, 0, 255), image.getArgb(9, 0));\n+\n+        assertEquals(color(0, 255, 255), image.getArgb(0, 5));\n+        assertEquals(color(255, 0, 255), image.getArgb(4, 5));\n+        assertEquals(color(255, 255, 0), image.getArgb(9, 5));\n+\n+        assertEquals(color(255, 128, 128), image.getArgb(0, 9));\n+        assertEquals(color(128, 128, 255), image.getArgb(4, 9));\n+        assertEquals(color(143, 240, 128), image.getArgb(9, 9));\n+    }\n+\n+    @Test\n+    void loadImageBGR() throws Exception {\n+        try (InputStream stream = getClass().getResourceAsStream(\"\/test\/com\/sun\/javafx\/iio\/checker.bmp\")) {\n+            ImageLoader loader = XImageLoaderFactory.getInstance().createImageLoader(stream);\n+            ImageFrame frame = loader.load(0, -1, -1, true, false, 1, 1);\n+            Image image = Image.convertImageFrame(frame);\n+\n+            assertEquals(12, frame.getWidth());\n+            assertEquals(12, frame.getHeight());\n+            assertEquals(1, frame.getPixelScale());\n+            assertEquals(ImageType.BGR, frame.getImageType());\n+\n+            assertEquals(12, image.getWidth());\n+            assertEquals(12, image.getHeight());\n+            assertEquals(PixelFormat.BYTE_RGB, image.getPixelFormat());\n+            assertImageContent(image);\n+        }\n+    }\n+\n+    @Test\n+    void loadImageABGR() throws Exception {\n+        try (InputStream stream = getClass().getResourceAsStream(\"\/test\/com\/sun\/javafx\/iio\/checker.png\")) {\n+            ImageLoader loader = XImageLoaderFactory.getInstance().createImageLoader(stream);\n+            ImageFrame frame = loader.load(0, -1, -1, true, false, 1, 1);\n+            Image image = Image.convertImageFrame(frame);\n+\n+            assertEquals(12, frame.getWidth());\n+            assertEquals(12, frame.getHeight());\n+            assertEquals(1, frame.getPixelScale());\n+            assertEquals(ImageType.ABGR, frame.getImageType());\n+\n+            assertEquals(12, image.getWidth());\n+            assertEquals(12, image.getHeight());\n+            assertEquals(PixelFormat.BYTE_BGRA_PRE, image.getPixelFormat());\n+            assertImageContent(image);\n+        }\n+    }\n+\n+    @Test\n+    void loadImageABGR2x() throws Exception {\n+        try (InputStream stream = getClass().getResourceAsStream(\"\/test\/com\/sun\/javafx\/iio\/checker@2x.png\")) {\n+            ImageLoader loader = XImageLoaderFactory.getInstance().createImageLoader(stream);\n+            ImageFrame frame = loader.load(0, -1, -1, true, false, 1, 2);\n+            Image image = Image.convertImageFrame(frame);\n+\n+            assertEquals(24, frame.getWidth());\n+            assertEquals(24, frame.getHeight());\n+            assertEquals(2, frame.getPixelScale());\n+            assertEquals(ImageType.ABGR, frame.getImageType());\n+\n+            assertEquals(24, image.getWidth());\n+            assertEquals(24, image.getHeight());\n+            assertEquals(PixelFormat.BYTE_BGRA_PRE, image.getPixelFormat());\n+            assertImageContent(image);\n+        }\n+    }\n+\n+    enum AwtImageTypes {\n+        TYPE_BYTE_GRAY(BufferedImage.TYPE_BYTE_GRAY, ImageType.GRAY),\n+        TYPE_3BYTE_BGR(BufferedImage.TYPE_3BYTE_BGR, ImageType.BGR),\n+        TYPE_4BYTE_ABGR(BufferedImage.TYPE_4BYTE_ABGR, ImageType.ABGR),\n+        TYPE_4BYTE_ABGR_PRE(BufferedImage.TYPE_4BYTE_ABGR_PRE, ImageType.ABGR_PRE),\n+        TYPE_INT_RGB(BufferedImage.TYPE_INT_RGB, ImageType.INT_RGB),\n+        TYPE_INT_BGR(BufferedImage.TYPE_INT_BGR, ImageType.INT_BGR),\n+        TYPE_INT_ARGB(BufferedImage.TYPE_INT_ARGB, ImageType.INT_ARGB),\n+        TYPE_INT_ARGB_PRE(BufferedImage.TYPE_INT_ARGB_PRE, ImageType.INT_ARGB_PRE);\n+\n+        AwtImageTypes(int awtImageType, ImageType fxImageType) {\n+            this.awtIimageType = awtImageType;\n+            this.fxImageType = fxImageType;\n+        }\n+\n+        final int awtIimageType;\n+        final ImageType fxImageType;\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(AwtImageTypes.class)\n+    void loadVariableDensityImage(AwtImageTypes types) throws IOException {\n+        class CustomImageReader extends ImageReader {\n+            final int imageType;\n+\n+            protected CustomImageReader(int imageType) {\n+                super(null);\n+                this.imageType = imageType;\n+            }\n+\n+            @Override public String getFormatName() { return \"test\"; }\n+            @Override public int getNumImages(boolean allowSearch) { return 1; }\n+            @Override public int getWidth(int imageIndex) { return 2; }\n+            @Override public int getHeight(int imageIndex) { return 2; }\n+            @Override public Iterator<ImageTypeSpecifier> getImageTypes(int imageIndex) { return null; }\n+            @Override public IIOMetadata getStreamMetadata() { return null; }\n+            @Override public IIOMetadata getImageMetadata(int imageIndex) { return null; }\n+\n+            @Override\n+            public ImageReadParam getDefaultReadParam() {\n+                return new ImageReadParam() {{ canSetSourceRenderSize = true; }};\n+            }\n+\n+            @Override\n+            public BufferedImage read(int imageIndex, ImageReadParam param) {\n+                int w = (int)param.getSourceRenderSize().getWidth();\n+                int h = (int)param.getSourceRenderSize().getHeight();\n+                return new BufferedImage(w, h, imageType);\n+            }\n+        }\n+\n+        var imageLoader = new XImageLoader(new CustomImageReader(types.awtIimageType), null);\n+\n+        \/\/ Load an image with screenPixelScale == 1\n+        var imageFrame = imageLoader.load(0, -1, -1, false, false, 1, 1);\n+        assertEquals(2, imageFrame.getWidth());\n+        assertEquals(2, imageFrame.getHeight());\n+        assertEquals(1, imageFrame.getPixelScale());\n+        assertEquals(types.fxImageType, imageFrame.getImageType());\n+\n+        \/\/ Load an image with screenPixelScale == 1.5\n+        imageFrame = imageLoader.load(0, -1, -1, false, false, 1.5f, 1);\n+        assertEquals(3, imageFrame.getWidth());\n+        assertEquals(3, imageFrame.getHeight());\n+        assertEquals(1.5, imageFrame.getPixelScale());\n+        assertEquals(types.fxImageType, imageFrame.getImageType());\n+\n+        \/\/ Load an image with screenPixelScale == 2\n+        imageFrame = imageLoader.load(0, -1, -1, false, false, 2, 1);\n+        assertEquals(4, imageFrame.getWidth());\n+        assertEquals(4, imageFrame.getHeight());\n+        assertEquals(2, imageFrame.getPixelScale());\n+        assertEquals(types.fxImageType, imageFrame.getImageType());\n+    }\n+\n+    @Test\n+    void addAndRemoveListener() throws Exception {\n+        try (InputStream stream = getClass().getResourceAsStream(\"\/test\/com\/sun\/javafx\/iio\/checker.png\")) {\n+            ImageReader pngReader = ImageIO.getImageReadersByFormatName(\"PNG\").next();\n+            ImageInputStream input = ImageIO.createImageInputStream(stream);\n+            pngReader.setInput(input);\n+            XImageLoader loader = new XImageLoader(pngReader, input);\n+            ImageLoadListener listener = new ImageLoadListener() {\n+                @Override public void imageLoadProgress(ImageLoader loader, float percentageComplete) {}\n+                @Override public void imageLoadWarning(ImageLoader loader, String message) {}\n+                @Override public void imageLoadMetaData(ImageLoader loader, ImageMetadata metadata) {}\n+            };\n+\n+            Field progressListenersField = ImageReader.class.getDeclaredField(\"progressListeners\");\n+            Field warningListenersField = ImageReader.class.getDeclaredField(\"warningListeners\");\n+            progressListenersField.setAccessible(true);\n+            warningListenersField.setAccessible(true);\n+            assertNull(progressListenersField.get(pngReader));\n+            assertNull(warningListenersField.get(pngReader));\n+\n+            loader.addListener(listener);\n+            assertEquals(1, ((List<?>)progressListenersField.get(pngReader)).size());\n+            assertEquals(1, ((List<?>)warningListenersField.get(pngReader)).size());\n+\n+            loader.removeListener(listener);\n+            assertNull(progressListenersField.get(pngReader));\n+            assertNull(warningListenersField.get(pngReader));\n+        }\n+    }\n+\n+    @Test\n+    void testProgressListener() throws Exception {\n+        try (InputStream stream = getClass().getResourceAsStream(\"\/test\/com\/sun\/javafx\/iio\/checker.png\")) {\n+            List<Float> progress = new ArrayList<>();\n+            ImageLoader loader = XImageLoaderFactory.getInstance().createImageLoader(stream);\n+            loader.addListener(new ImageLoadListener() {\n+                @Override\n+                public void imageLoadProgress(ImageLoader loader, float percentageComplete) {\n+                    progress.add(percentageComplete);\n+                }\n+\n+                @Override public void imageLoadWarning(ImageLoader loader, String message) {}\n+                @Override public void imageLoadMetaData(ImageLoader loader, ImageMetadata metadata) {}\n+            });\n+\n+            loader.load(0, -1, -1, true, false, 1, 1);\n+\n+            assertTrue(progress.size() > 1);\n+            assertEquals(0, progress.get(0));\n+            assertEquals(100, progress.get(progress.size() - 1));\n+\n+            List<Float> orderedProgress = new ArrayList<>(progress);\n+            orderedProgress.sort(Comparator.naturalOrder());\n+            assertEquals(orderedProgress, progress);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/iio\/javax\/XImageLoaderTest.java","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -43,1 +43,1 @@\n-        loader.load(0, 0, 0, true, true);\n+        loader.load(0, 0, 0, true, true, 1, 1);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/iio\/png\/PNGImageLoaderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import com.sun.javafx.image.impl.ByteAbgr;\n@@ -59,0 +60,2 @@\n+import com.sun.javafx.image.impl.IntBgr;\n+import com.sun.javafx.image.impl.IntRgb;\n@@ -343,0 +346,1 @@\n+        private final int ncomp;\n@@ -356,0 +360,1 @@\n+            this.ncomp = (ashift < 0) ? 3 : 4;\n@@ -425,0 +430,4 @@\n+        public int getNcomp() {\n+            return ncomp;\n+        }\n+\n@@ -439,1 +448,0 @@\n-\n@@ -441,0 +449,1 @@\n+        new ByteFormat(ByteAbgr.getter,    ByteAbgr.setter,     0, 3, 2, 1),\n@@ -445,1 +454,1 @@\n-        new ByteFormat(ByteRgb.getter,                         -1, 0, 1, 2),\n+        new ByteFormat(ByteRgb.getter,     ByteRgb.setter,     -1, 0, 1, 2),\n@@ -454,0 +463,2 @@\n+        new IntFormat(IntBgr.getter,     IntBgr.setter,     -1,  0, 8,16),\n+        new IntFormat(IntRgb.getter,     IntRgb.setter,     -1, 16, 8, 0),\n@@ -817,1 +828,1 @@\n-                \/\/ Should not be null - so far all int formats are full color+alpha\n+                if (ifmtsetter.getNcomp() < 4 && b2ipc == null) continue;\n@@ -975,1 +986,1 @@\n-                \/\/ Should not be null - so far all int formats are full color+alpha\n+                if (ifmtsetter.getNcomp() < 4 && i2ipc == null) continue;\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/image\/ConverterTest.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,450 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.prism;\n+\n+import com.sun.javafx.iio.ImageFrame;\n+import com.sun.javafx.iio.ImageMetadata;\n+import com.sun.javafx.iio.ImageStorage.ImageType;\n+import com.sun.prism.Image;\n+import com.sun.prism.PixelFormat;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import java.nio.Buffer;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ImageTest {\n+\n+    \/**\n+     * All supported {@link ImageType} to {@link PixelFormat} conversions.\n+     *\/\n+    enum SupportedConversions {\n+        GRAY(ImageType.GRAY, PixelFormat.BYTE_GRAY, 2,\n+            byteArray(\n+                1, 2, 3, 4\n+            ),\n+            byteArray(\n+                1, 2, 3, 4\n+            )),\n+\n+        GRAY_ALPHA(ImageType.GRAY_ALPHA, PixelFormat.BYTE_BGRA_PRE, 4,\n+            byteArray(\n+                100, 127, 50, 127,\n+                100, 0, 50, 0\n+            ),\n+            byteArray(\n+                50, 50, 50, 127, 25, 25, 25, 127,\n+                0, 0, 0, 0, 0, 0, 0, 0\n+            )),\n+\n+        GRAY_ALPHA_PRE(ImageType.GRAY_ALPHA_PRE, PixelFormat.BYTE_BGRA_PRE, 4,\n+            byteArray(\n+                100, 127, 50, 127,\n+                100, 0, 50, 0\n+            ),\n+            byteArray(\n+                100, 100, 100, 127, 50, 50, 50, 127,\n+                100, 100, 100, 0, 50, 50, 50, 0\n+            )),\n+\n+        RGB(ImageType.RGB, PixelFormat.BYTE_RGB, 6,\n+            byteArray(\n+                1, 2, 3, 4, 5, 6,\n+                7, 8, 9, 10, 11, 12\n+            ),\n+            byteArray(\n+                1, 2, 3, 4, 5, 6,\n+                7, 8, 9, 10, 11, 12\n+            )),\n+\n+        BGR(ImageType.BGR, PixelFormat.BYTE_RGB, 6,\n+            byteArray(\n+                1, 2, 3, 4, 5, 6,\n+                7, 8, 9, 10, 11, 12\n+            ),\n+            byteArray(\n+                3, 2, 1, 6, 5, 4,\n+                9, 8, 7, 12, 11, 10\n+            )),\n+\n+        RGBA(ImageType.RGBA, PixelFormat.BYTE_BGRA_PRE, 8,\n+            byteArray(\n+                100, 0, 0, 127, 0, 50, 0, 127,\n+                255, 127, 0, 127, 50, 60, 70, 255\n+            ),\n+            byteArray(\n+                0, 0, 50, 127, 0, 25, 0, 127,\n+                0, 63, 127, 127, 70, 60, 50, 255\n+            )),\n+\n+        RGBA_PRE(ImageType.RGBA_PRE, PixelFormat.BYTE_BGRA_PRE, 8,\n+            byteArray(\n+                100, 0, 0, 127, 0, 50, 0, 127,\n+                255, 127, 0, 127, 50, 40, 30, 0\n+            ),\n+            byteArray(\n+                0, 0, 100, 127, 0, 50, 0, 127,\n+                0, 127, 255, 127, 30, 40, 50, 0\n+            )),\n+\n+        BGRA(ImageType.BGRA, PixelFormat.BYTE_BGRA_PRE, 8,\n+            byteArray(\n+                100, 0, 0, 127, 0, 50, 0, 127,\n+                255, 127, 0, 127, 50, 50, 50, 0\n+            ),\n+            byteArray(\n+                50, 0, 0, 127, 0, 25, 0, 127,\n+                127, 63, 0, 127, 0, 0, 0, 0\n+            )),\n+\n+        BGRA_PRE(ImageType.BGRA_PRE, PixelFormat.BYTE_BGRA_PRE, 8,\n+            byteArray(\n+                100, 0, 0, 127, 0, 50, 0, 127,\n+                255, 127, 0, 127, 50, 50, 50, 0\n+            ),\n+            byteArray(\n+                100, 0, 0, 127, 0, 50, 0, 127,\n+                255, 127, 0, 127, 50, 50, 50, 0\n+            )),\n+\n+        ABGR(ImageType.ABGR, PixelFormat.BYTE_BGRA_PRE, 8,\n+            byteArray(\n+                127, 100, 0, 0, 127, 50, 0, 100,\n+                127, 255, 127, 0, 0, 50, 50, 50\n+            ),\n+            byteArray(\n+                50, 0, 0, 127, 25, 0, 50, 127,\n+                127, 63, 0, 127, 0, 0, 0, 0\n+            )),\n+\n+        ABGR_PRE(ImageType.ABGR_PRE, PixelFormat.BYTE_BGRA_PRE, 8,\n+            byteArray(\n+                127, 100, 0, 0, 127, 50, 0, 100,\n+                127, 255, 127, 0, 0, 50, 50, 50\n+            ),\n+            byteArray(\n+                100, 0, 0, 127, 50, 0, 100, 127,\n+                255, 127, 0, 127, 50, 50, 50, 0\n+            )),\n+\n+        INT_RGB(ImageType.INT_RGB, PixelFormat.INT_ARGB_PRE, 2,\n+            new int[] {\n+                rgb(50, 100, 150), rgb(10, 20, 30),\n+                rgb(40, 50, 60), rgb(255, 255, 255)\n+            },\n+            new int[] {\n+                argb(255, 50, 100, 150), argb(255, 10, 20, 30),\n+                argb(255, 40, 50, 60), argb(255, 255, 255, 255)\n+            }),\n+\n+        INT_BGR(ImageType.INT_BGR, PixelFormat.INT_ARGB_PRE, 2,\n+            new int[] {\n+                rgb(50, 100, 150), rgb(10, 20, 30),\n+                rgb(40, 50, 60), rgb(255, 255, 255)\n+            },\n+            new int[] {\n+                argb(255, 150, 100, 50), argb(255, 30, 20, 10),\n+                argb(255, 60, 50, 40), argb(255, 255, 255, 255)\n+            }),\n+\n+        INT_ARGB(ImageType.INT_ARGB, PixelFormat.INT_ARGB_PRE, 2,\n+            new int[] {\n+                argb(127, 50, 100, 150), argb(127, 10, 20, 30),\n+                argb(255, 40, 50, 60), argb(0, 255, 255, 255)\n+            },\n+            new int[] {\n+                argb(127, 25, 50, 75), argb(127, 5, 10, 15),\n+                argb(255, 40, 50, 60), argb(0, 0, 0, 0)\n+            }),\n+\n+        INT_ARGB_PRE(ImageType.INT_ARGB_PRE, PixelFormat.INT_ARGB_PRE, 2,\n+            new int[] {\n+                argb(127, 50, 100, 150), argb(127, 10, 20, 30),\n+                argb(255, 0, 0, 0), argb(0, 255, 255, 255)\n+            },\n+            new int[] {\n+                argb(127, 50, 100, 150), argb(127, 10, 20, 30),\n+                argb(255, 0, 0, 0), argb(0, 255, 255, 255)\n+            }),\n+\n+        PALETTE_ONE_BIT_OPAQUE(ImageType.PALETTE, PixelFormat.BYTE_RGB, 1, 1,\n+            new int[] {\n+                rgb(255, 0, 0), rgb(0, 127, 0)\n+            },\n+            encodeBits(\n+                0, 1, \/*padding:*\/ 0, 0, 0, 0, 0, 0,\n+                1, 0, \/*padding:*\/ 0, 0, 0, 0, 0, 0\n+            ),\n+            byteArray(\n+                255, 0, 0, 0, 127, 0,\n+                0, 127, 0, 255, 0, 0\n+            )),\n+\n+        PALETTE_ONE_BIT_ALPHA(ImageType.PALETTE_ALPHA, PixelFormat.BYTE_BGRA_PRE, 1, 1,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0)\n+            },\n+            encodeBits(\n+                0, 1, \/*padding:*\/ 0, 0, 0, 0, 0, 0,\n+                1, 0, \/*padding:*\/ 0, 0, 0, 0, 0, 0\n+            ),\n+            byteArray(\n+                0, 0, 127, 127, 0, 127, 0, 255,\n+                0, 127, 0, 255, 0, 0, 127, 127\n+            )),\n+\n+        PALETTE_ONE_BIT_ALPHA_PRE(ImageType.PALETTE_ALPHA_PRE, PixelFormat.BYTE_BGRA_PRE, 1, 1,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0)\n+            },\n+            encodeBits(\n+                0, 1, \/*padding:*\/ 0, 0, 0, 0, 0, 0,\n+                1, 0, \/*padding:*\/ 0, 0, 0, 0, 0, 0\n+            ),\n+            byteArray(\n+                0, 0, 255, 127, 0, 127, 0, 255,\n+                0, 127, 0, 255, 0, 0, 255, 127\n+            )),\n+\n+        PALETTE_TWO_BIT_OPAQUE(ImageType.PALETTE, PixelFormat.BYTE_RGB, 1, 2,\n+            new int[] {\n+                rgb(255, 0, 0), rgb(0, 127, 0), rgb(10, 20, 30), rgb(50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 1, \/*padding:*\/ 0, 0, 0, 0,\n+                1, 0, 1, 1, \/*padding:*\/ 0, 0, 0, 0\n+            ),\n+            byteArray(\n+                255, 0, 0, 0, 127, 0,\n+                10, 20, 30, 50, 60, 70\n+            )),\n+\n+        PALETTE_TWO_BIT_ALPHA(ImageType.PALETTE_ALPHA, PixelFormat.BYTE_BGRA_PRE, 1, 2,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0), argb(0, 10, 20, 30), argb(255, 50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 1, \/*padding:*\/ 0, 0, 0, 0,\n+                1, 0, 1, 1, \/*padding:*\/ 0, 0, 0, 0\n+            ),\n+            byteArray(\n+                0, 0, 127, 127, 0, 127, 0, 255,\n+                0, 0, 0, 0, 70, 60, 50, 255\n+            )),\n+\n+        PALETTE_TWO_BIT_ALPHA_PRE(ImageType.PALETTE_ALPHA_PRE, PixelFormat.BYTE_BGRA_PRE, 1, 2,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0), argb(0, 10, 20, 30), argb(255, 50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 1, \/*padding:*\/ 0, 0, 0, 0,\n+                1, 0, 1, 1, \/*padding:*\/ 0, 0, 0, 0\n+            ),\n+            byteArray(\n+                0, 0, 255, 127, 0, 127, 0, 255,\n+                30, 20, 10, 0, 70, 60, 50, 255\n+            )),\n+\n+        PALETTE_FOUR_BIT_OPAQUE(ImageType.PALETTE, PixelFormat.BYTE_RGB, 1, 4,\n+            new int[] {\n+                rgb(255, 0, 0), rgb(0, 127, 0), rgb(10, 20, 30), rgb(50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 0, 0, 0, 0, 1,\n+                0, 0, 1, 0, 0, 0, 1, 1\n+            ),\n+            byteArray(\n+                255, 0, 0, 0, 127, 0,\n+                10, 20, 30, 50, 60, 70\n+            )),\n+\n+        PALETTE_FOUR_BIT_ALPHA(ImageType.PALETTE_ALPHA, PixelFormat.BYTE_BGRA_PRE, 1, 4,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0), argb(0, 10, 20, 30), argb(255, 50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 0, 0, 0, 0, 1,\n+                0, 0, 1, 0, 0, 0, 1, 1\n+            ),\n+            byteArray(\n+                0, 0, 127, 127, 0, 127, 0, 255,\n+                0, 0, 0, 0, 70, 60, 50, 255\n+            )),\n+\n+        PALETTE_FOUR_BIT_ALPHA_PRE(ImageType.PALETTE_ALPHA_PRE, PixelFormat.BYTE_BGRA_PRE, 1, 4,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0), argb(0, 10, 20, 30), argb(255, 50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 0, 0, 0, 0, 1,\n+                0, 0, 1, 0, 0, 0, 1, 1\n+            ),\n+            byteArray(\n+                0, 0, 255, 127, 0, 127, 0, 255,\n+                30, 20, 10, 0, 70, 60, 50, 255\n+            )),\n+\n+        PALETTE_EIGHT_BIT_OPAQUE(ImageType.PALETTE, PixelFormat.BYTE_RGB, 2, 8,\n+            new int[] {\n+                rgb(255, 0, 0), rgb(0, 127, 0), rgb(10, 20, 30), rgb(50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n+                0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1\n+            ),\n+            byteArray(\n+                255, 0, 0, 0, 127, 0,\n+                10, 20, 30, 50, 60, 70\n+            )),\n+\n+        PALETTE_EIGHT_BIT_ALPHA(ImageType.PALETTE_ALPHA, PixelFormat.BYTE_BGRA_PRE, 2, 8,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0), argb(0, 10, 20, 30), argb(255, 50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n+                0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1\n+            ),\n+            byteArray(\n+                0, 0, 127, 127, 0, 127, 0, 255,\n+                0, 0, 0, 0, 70, 60, 50, 255\n+            )),\n+\n+        PALETTE_EIGHT_BIT_ALPHA_PRE(ImageType.PALETTE_ALPHA_PRE, PixelFormat.BYTE_BGRA_PRE, 2, 8,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0), argb(0, 10, 20, 30), argb(255, 50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n+                0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1\n+            ),\n+            byteArray(\n+                0, 0, 255, 127, 0, 127, 0, 255,\n+                30, 20, 10, 0, 70, 60, 50, 255\n+            ));\n+\n+        static int rgb(int r, int g, int b) {\n+            return 255 << 24 | (r & 0xff) << 16 | (g & 0xff) << 8 | (b & 0xff);\n+        }\n+\n+        static int argb(int a, int r, int g, int b) {\n+            return a << 24 | (r & 0xff) << 16 | (g & 0xff) << 8 | (b & 0xff);\n+        }\n+\n+        static byte[] encodeBits(int... bits) {\n+            var result = new byte[bits.length \/ 8 + 1];\n+            for (int i = 0; i < bits.length; ++i) {\n+                result[i \/ 8] |= (byte)(bits[i] << (7 - (i % 8)));\n+            }\n+\n+            return result;\n+        }\n+\n+        \/\/ Allows us to create byte arrays with unsigned literals without casting to (byte)\n+        static byte[] byteArray(int... bytes) {\n+            var result = new byte[bytes.length];\n+            for (int i = 0; i < bytes.length; ++i) {\n+                result[i] = (byte)Objects.checkIndex(bytes[i], 256);\n+            }\n+\n+            return result;\n+        }\n+\n+        SupportedConversions(ImageType sourceType, PixelFormat targetType, int stride,\n+                             int paletteIndexBits, int[] palette,\n+                             byte[] sourceData, byte[] targetData) {\n+            this(sourceType, targetType, stride, palette, paletteIndexBits,\n+                 ByteBuffer.wrap(sourceData), ByteBuffer.wrap(targetData));\n+        }\n+\n+        SupportedConversions(ImageType sourceType, PixelFormat targetType, int stride,\n+                             byte[] sourceData, byte[] targetData) {\n+            this(sourceType, targetType, stride, null, -1,\n+                 ByteBuffer.wrap(sourceData), ByteBuffer.wrap(targetData));\n+        }\n+\n+        SupportedConversions(ImageType sourceType, PixelFormat targetType, int stride,\n+                             int[] sourceData, int[] targetData) {\n+            this(sourceType, targetType, stride, null, -1,\n+                 IntBuffer.wrap(sourceData), IntBuffer.wrap(targetData));\n+        }\n+\n+        SupportedConversions(ImageType sourceType, PixelFormat targetType, int stride,\n+                             int[] palette, int paletteIndexBits,\n+                             Buffer sourceData, Buffer targetData) {\n+            this.sourceType = sourceType;\n+            this.targetType = targetType;\n+            this.sourceData = sourceData;\n+            this.targetData = targetData;\n+            this.palette = palette;\n+            this.paletteIndexBits = paletteIndexBits;\n+            this.stride = stride;\n+        }\n+\n+        final ImageType sourceType;\n+        final PixelFormat targetType;\n+        final Buffer sourceData;\n+        final Buffer targetData;\n+        final int paletteIndexBits;\n+        final int[] palette;\n+        final int stride;\n+    }\n+\n+    \/**\n+     * Asserts that the content of an {@link ImageFrame} is correctly converted to {@link Image}\n+     * for all supported image formats.\n+     *\/\n+    @ParameterizedTest\n+    @EnumSource(SupportedConversions.class)\n+    void convertImageFrame(SupportedConversions conversion) {\n+        var imageFrame = new ImageFrame(\n+            conversion.sourceType, conversion.sourceData, 2, 2, conversion.stride,\n+            conversion.palette, conversion.paletteIndexBits, 1,\n+            new ImageMetadata(null, null, null, null, null, null, null, 2, 2, null, null, null));\n+\n+        var image = Image.convertImageFrame(imageFrame);\n+\n+        assertEquals(2, image.getWidth());\n+        assertEquals(2, image.getHeight());\n+        assertEquals(conversion.targetType, image.getPixelFormat());\n+        assertEquals(conversion.targetData, image.getPixelBuffer(), () ->\n+            \"Expected: %s\\nActual: %s\".formatted(\n+                formatArray(conversion.targetData.array()),\n+                formatArray(image.getPixelBuffer().array())));\n+    }\n+\n+    private static String formatArray(Object array) {\n+        return switch (array) {\n+            case byte[] byteArray -> Arrays.toString(byteArray);\n+            case int[] intArray -> Arrays.toString(intArray);\n+            default -> throw new AssertionError();\n+        };\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/prism\/ImageTest.java","additions":450,"deletions":0,"binary":false,"changes":450,"status":"added"},{"filename":"modules\/javafx.graphics\/src\/test\/resources\/test\/com\/sun\/javafx\/iio\/checker.bmp","binary":true,"status":"added"}]}