{"files":[{"patch":"@@ -216,2 +216,0 @@\n-                    case TYPE_BYTE_BINARY -> \"TYPE_BYTE_BINARY\";\n-                    case TYPE_BYTE_INDEXED -> \"TYPE_BYTE_INDEXED\";\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/javax\/XImageLoader.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,79 +1,79 @@\n-\/*\r\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.  Oracle designates this\r\n- * particular file as subject to the \"Classpath\" exception as provided\r\n- * by Oracle in the LICENSE file that accompanied this code.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-package com.sun.javafx.image;\r\n-\r\n-import java.nio.ByteBuffer;\r\n-\r\n-public interface IndexedToBytePixelConverter extends PixelConverter<ByteBuffer, ByteBuffer> {\r\n-\r\n-    \/**\r\n-     * Copies a rectangular region of data from the source array to the destination array.\r\n-     *\r\n-     * @param srcarr the byte array containing the source data\r\n-     * @param srcoff the index in the array of the first source pixel data\r\n-     * @param srcscanbits number of bits between rows of data in the source\r\n-     * @param dstarr the byte array containing the destination data\r\n-     * @param dstoff the index in the array of the first destination pixel data\r\n-     * @param dstscanbytes number of array indices between rows of data in the destination\r\n-     * @param w the number of pixels to process across before moving to the next row\r\n-     * @param h the number of rows of pixels to process\r\n-     *\/\r\n-    void convert(byte[] srcarr, int srcoff, int srcscanbits,\r\n-                 byte[] dstarr, int dstoff, int dstscanbytes,\r\n-                 int w, int h);\r\n-\r\n-    \/**\r\n-     * Copies a rectangular region of data from the source buffer to the destination array.\r\n-     *\r\n-     * @param srcbuf the nio buffer containing the source data\r\n-     * @param srcoff the absolute location in the buffer of the first source pixel data\r\n-     * @param srcscanbits number of bits between rows of data in the source\r\n-     * @param dstarr the byte array containing the destination data\r\n-     * @param dstoff the index in the array of the first destination pixel data\r\n-     * @param dstscanbytes number of array indices between rows of data in the destination\r\n-     * @param w the number of pixels to process across before moving to the next row\r\n-     * @param h the number of rows of pixels to process\r\n-     *\/\r\n-    void convert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\r\n-                 byte[] dstarr, int dstoff, int dstscanbytes,\r\n-                 int w, int h);\r\n-\r\n-    \/**\r\n-     * Copies a rectangular region of data from the source array to the destination buffer.\r\n-     *\r\n-     * @param srcarr the byte array containing the source data\r\n-     * @param srcoff the index in the array of the first source pixel data\r\n-     * @param srcscanbits number of bits between rows of data in the source\r\n-     * @param dstbuf the nio buffer containing the destination data\r\n-     * @param dstoff the absolute location in the buffer of the first destination pixel data\r\n-     * @param dstscanbytes number of buffer elements between rows of data in the destination\r\n-     * @param w the number of pixels to process across before moving to the next row\r\n-     * @param h the number of rows of pixels to process\r\n-     *\/\r\n-    void convert(byte[] srcarr, int srcoff, int srcscanbits,\r\n-                 ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n-                 int w, int h);\r\n-}\r\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image;\n+\n+import java.nio.ByteBuffer;\n+\n+public interface IndexedToBytePixelConverter extends PixelConverter<ByteBuffer, ByteBuffer> {\n+\n+    \/**\n+     * Copies a rectangular region of data from the source array to the destination array.\n+     *\n+     * @param srcarr the byte array containing the source data\n+     * @param srcoff the index in the array of the first source pixel data\n+     * @param srcscanbits number of bits between rows of data in the source\n+     * @param dstarr the byte array containing the destination data\n+     * @param dstoff the index in the array of the first destination pixel data\n+     * @param dstscanbytes number of array indices between rows of data in the destination\n+     * @param w the number of pixels to process across before moving to the next row\n+     * @param h the number of rows of pixels to process\n+     *\/\n+    void convert(byte[] srcarr, int srcoff, int srcscanbits,\n+                 byte[] dstarr, int dstoff, int dstscanbytes,\n+                 int w, int h);\n+\n+    \/**\n+     * Copies a rectangular region of data from the source buffer to the destination array.\n+     *\n+     * @param srcbuf the nio buffer containing the source data\n+     * @param srcoff the absolute location in the buffer of the first source pixel data\n+     * @param srcscanbits number of bits between rows of data in the source\n+     * @param dstarr the byte array containing the destination data\n+     * @param dstoff the index in the array of the first destination pixel data\n+     * @param dstscanbytes number of array indices between rows of data in the destination\n+     * @param w the number of pixels to process across before moving to the next row\n+     * @param h the number of rows of pixels to process\n+     *\/\n+    void convert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\n+                 byte[] dstarr, int dstoff, int dstscanbytes,\n+                 int w, int h);\n+\n+    \/**\n+     * Copies a rectangular region of data from the source array to the destination buffer.\n+     *\n+     * @param srcarr the byte array containing the source data\n+     * @param srcoff the index in the array of the first source pixel data\n+     * @param srcscanbits number of bits between rows of data in the source\n+     * @param dstbuf the nio buffer containing the destination data\n+     * @param dstoff the absolute location in the buffer of the first destination pixel data\n+     * @param dstscanbytes number of buffer elements between rows of data in the destination\n+     * @param w the number of pixels to process across before moving to the next row\n+     * @param h the number of rows of pixels to process\n+     *\/\n+    void convert(byte[] srcarr, int srcoff, int srcscanbits,\n+                 ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                 int w, int h);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/IndexedToBytePixelConverter.java","additions":79,"deletions":79,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -1,182 +1,182 @@\n-\/*\r\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.  Oracle designates this\r\n- * particular file as subject to the \"Classpath\" exception as provided\r\n- * by Oracle in the LICENSE file that accompanied this code.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-package com.sun.javafx.image.impl;\r\n-\r\n-import com.sun.javafx.image.BytePixelSetter;\r\n-import com.sun.javafx.image.IndexedToBytePixelConverter;\r\n-import java.nio.ByteBuffer;\r\n-\r\n-public final class EightBitIndexed {\r\n-\r\n-    private EightBitIndexed() {}\r\n-\r\n-    public static Getter createGetter(int[] colors, Boolean premultiplied) {\r\n-        return new Getter(colors, premultiplied);\r\n-    }\r\n-\r\n-    public static IndexedToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\r\n-        return new ToByteRgbConverter(src, dst);\r\n-    }\r\n-\r\n-    public static IndexedToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\r\n-        return new ToByteBgraAnyConverter(src, dst);\r\n-    }\r\n-\r\n-    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\r\n-        Getter(int[] colors, Boolean premultiplied) {\r\n-            super(colors, premultiplied);\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getNumElements() {\r\n-            return 8;\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgb(byte[] arr, int offset) {\r\n-            return preColors[arr[offset]];\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgbPre(byte[] arr, int offset) {\r\n-            return nonPreColors[arr[offset]];\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgb(ByteBuffer buf, int offset) {\r\n-            return preColors[buf.get(offset)];\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgbPre(ByteBuffer buf, int offset) {\r\n-            return nonPreColors[buf.get(offset)];\r\n-        }\r\n-    }\r\n-\r\n-    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\r\n-        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\r\n-            super(getter, setter);\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\r\n-                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = switch (setter.getAlphaType()) {\r\n-                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n-                case PREMULTIPLIED -> getGetter().preColors;\r\n-            };\r\n-\r\n-            dstscanbytes -= w * 4;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[srcarr[srcoff + x]];\r\n-                    dstarr[dstoff++] = (byte) argb;\r\n-                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n-                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n-                    dstarr[dstoff++] = (byte) (argb >> 24);\r\n-                }\r\n-\r\n-                srcoff += srcscanbits;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\r\n-                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = switch (setter.getAlphaType()) {\r\n-                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n-                case PREMULTIPLIED -> getGetter().preColors;\r\n-            };\r\n-\r\n-            dstscanbytes -= w * 4;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[srcbuf.get(srcoff + x)];\r\n-                    dstbuf.put(dstoff, (byte) argb);\r\n-                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n-                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\r\n-                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\r\n-                    dstoff += 4;\r\n-                }\r\n-\r\n-                srcoff += srcscanbits;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\r\n-        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\r\n-            super(getter, setter);\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\r\n-                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = getGetter().nonPreColors;\r\n-            dstscanbytes -= w * 3;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[srcarr[srcoff + x]];\r\n-                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n-                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n-                    dstarr[dstoff++] = (byte) argb;\r\n-                }\r\n-\r\n-                srcoff += srcscanbits;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\r\n-                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = getGetter().nonPreColors;\r\n-            dstscanbytes -= w * 3;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[srcbuf.get(srcoff + x)];\r\n-                    dstbuf.put(dstoff, (byte) (argb >> 16));\r\n-                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n-                    dstbuf.put(dstoff + 2, (byte) argb);\r\n-                    dstoff += 3;\r\n-                }\r\n-\r\n-                srcoff += srcscanbits;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.BytePixelSetter;\n+import com.sun.javafx.image.IndexedToBytePixelConverter;\n+import java.nio.ByteBuffer;\n+\n+public final class EightBitIndexed {\n+\n+    private EightBitIndexed() {}\n+\n+    public static Getter createGetter(int[] colors, Boolean premultiplied) {\n+        return new Getter(colors, premultiplied);\n+    }\n+\n+    public static IndexedToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\n+        return new ToByteRgbConverter(src, dst);\n+    }\n+\n+    public static IndexedToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\n+        return new ToByteBgraAnyConverter(src, dst);\n+    }\n+\n+    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\n+        Getter(int[] colors, Boolean premultiplied) {\n+            super(colors, premultiplied);\n+        }\n+\n+        @Override\n+        public int getNumElements() {\n+            return 8;\n+        }\n+\n+        @Override\n+        public int getArgb(byte[] arr, int offset) {\n+            return preColors[arr[offset]];\n+        }\n+\n+        @Override\n+        public int getArgbPre(byte[] arr, int offset) {\n+            return nonPreColors[arr[offset]];\n+        }\n+\n+        @Override\n+        public int getArgb(ByteBuffer buf, int offset) {\n+            return preColors[buf.get(offset)];\n+        }\n+\n+        @Override\n+        public int getArgbPre(ByteBuffer buf, int offset) {\n+            return nonPreColors[buf.get(offset)];\n+        }\n+    }\n+\n+    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\n+        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[srcarr[srcoff + x]];\n+                    dstarr[dstoff++] = (byte) argb;\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 24);\n+                }\n+\n+                srcoff += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[srcbuf.get(srcoff + x)];\n+                    dstbuf.put(dstoff, (byte) argb);\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\n+                    dstoff += 4;\n+                }\n+\n+                srcoff += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+\n+    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\n+        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = getGetter().nonPreColors;\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[srcarr[srcoff + x]];\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) argb;\n+                }\n+\n+                srcoff += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = getGetter().nonPreColors;\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[srcbuf.get(srcoff + x)];\n+                    dstbuf.put(dstoff, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) argb);\n+                    dstoff += 3;\n+                }\n+\n+                srcoff += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/EightBitIndexed.java","additions":182,"deletions":182,"binary":false,"changes":364,"status":"modified"},{"patch":"@@ -1,182 +1,182 @@\n-\/*\r\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.  Oracle designates this\r\n- * particular file as subject to the \"Classpath\" exception as provided\r\n- * by Oracle in the LICENSE file that accompanied this code.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-package com.sun.javafx.image.impl;\r\n-\r\n-import com.sun.javafx.image.BytePixelSetter;\r\n-import com.sun.javafx.image.IndexedToBytePixelConverter;\r\n-import java.nio.ByteBuffer;\r\n-\r\n-public final class FourBitIndexed {\r\n-\r\n-    private FourBitIndexed() {}\r\n-\r\n-    public static Getter createGetter(int[] colors, Boolean premultiplied) {\r\n-        return new Getter(colors, premultiplied);\r\n-    }\r\n-\r\n-    public static IndexedToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\r\n-        return new ToByteRgbConverter(src, dst);\r\n-    }\r\n-\r\n-    public static IndexedToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\r\n-        return new ToByteBgraAnyConverter(src, dst);\r\n-    }\r\n-\r\n-    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\r\n-        Getter(int[] colors, Boolean premultiplied) {\r\n-            super(colors, premultiplied);\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getNumElements() {\r\n-            return 4;\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgb(byte[] arr, int offset) {\r\n-            return preColors[(arr[offset \/ 2] >> (4 - offset % 2 * 4)) & 0xf];\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgbPre(byte[] arr, int offset) {\r\n-            return nonPreColors[(arr[offset \/ 2] >> (4 - offset % 2 * 4)) & 0xf];\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgb(ByteBuffer buf, int offset) {\r\n-            return preColors[(buf.get(offset \/ 2) >> (4 - offset % 2 * 4)) & 0xf];\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgbPre(ByteBuffer buf, int offset) {\r\n-            return nonPreColors[(buf.get(offset \/ 2) >> (4 - offset % 2 * 4)) & 0xf];\r\n-        }\r\n-    }\r\n-\r\n-    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\r\n-        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\r\n-            super(getter, setter);\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\r\n-                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = switch (setter.getAlphaType()) {\r\n-                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n-                case PREMULTIPLIED -> getGetter().preColors;\r\n-            };\r\n-\r\n-            dstscanbytes -= w * 4;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 2] >> (4 - x % 2 * 4)) & 0xf];\r\n-                    dstarr[dstoff++] = (byte) argb;\r\n-                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n-                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n-                    dstarr[dstoff++] = (byte) (argb >> 24);\r\n-                }\r\n-\r\n-                srcoff += srcscanbits;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\r\n-                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = switch (setter.getAlphaType()) {\r\n-                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n-                case PREMULTIPLIED -> getGetter().preColors;\r\n-            };\r\n-\r\n-            dstscanbytes -= w * 4;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 2) >> (4 - x % 2 * 4)) & 0xf];\r\n-                    dstbuf.put(dstoff, (byte) argb);\r\n-                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n-                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\r\n-                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\r\n-                    dstoff += 4;\r\n-                }\r\n-\r\n-                srcoff += srcscanbits;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\r\n-        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\r\n-            super(getter, setter);\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\r\n-                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = getGetter().nonPreColors;\r\n-            dstscanbytes -= w * 3;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 2] >> (4 - x % 2 * 4)) & 0xf];\r\n-                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n-                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n-                    dstarr[dstoff++] = (byte) argb;\r\n-                }\r\n-\r\n-                srcoff += srcscanbits;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\r\n-                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = getGetter().nonPreColors;\r\n-            dstscanbytes -= w * 3;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 2) >> (4 - x % 2 * 4)) & 0xf];\r\n-                    dstbuf.put(dstoff, (byte) (argb >> 16));\r\n-                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n-                    dstbuf.put(dstoff + 2, (byte) argb);\r\n-                    dstoff += 3;\r\n-                }\r\n-\r\n-                srcoff += srcscanbits;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.BytePixelSetter;\n+import com.sun.javafx.image.IndexedToBytePixelConverter;\n+import java.nio.ByteBuffer;\n+\n+public final class FourBitIndexed {\n+\n+    private FourBitIndexed() {}\n+\n+    public static Getter createGetter(int[] colors, Boolean premultiplied) {\n+        return new Getter(colors, premultiplied);\n+    }\n+\n+    public static IndexedToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\n+        return new ToByteRgbConverter(src, dst);\n+    }\n+\n+    public static IndexedToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\n+        return new ToByteBgraAnyConverter(src, dst);\n+    }\n+\n+    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\n+        Getter(int[] colors, Boolean premultiplied) {\n+            super(colors, premultiplied);\n+        }\n+\n+        @Override\n+        public int getNumElements() {\n+            return 4;\n+        }\n+\n+        @Override\n+        public int getArgb(byte[] arr, int offset) {\n+            return preColors[(arr[offset \/ 2] >> (4 - offset % 2 * 4)) & 0xf];\n+        }\n+\n+        @Override\n+        public int getArgbPre(byte[] arr, int offset) {\n+            return nonPreColors[(arr[offset \/ 2] >> (4 - offset % 2 * 4)) & 0xf];\n+        }\n+\n+        @Override\n+        public int getArgb(ByteBuffer buf, int offset) {\n+            return preColors[(buf.get(offset \/ 2) >> (4 - offset % 2 * 4)) & 0xf];\n+        }\n+\n+        @Override\n+        public int getArgbPre(ByteBuffer buf, int offset) {\n+            return nonPreColors[(buf.get(offset \/ 2) >> (4 - offset % 2 * 4)) & 0xf];\n+        }\n+    }\n+\n+    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\n+        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 2] >> (4 - x % 2 * 4)) & 0xf];\n+                    dstarr[dstoff++] = (byte) argb;\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 24);\n+                }\n+\n+                srcoff += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 2) >> (4 - x % 2 * 4)) & 0xf];\n+                    dstbuf.put(dstoff, (byte) argb);\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\n+                    dstoff += 4;\n+                }\n+\n+                srcoff += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+\n+    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\n+        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = getGetter().nonPreColors;\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 2] >> (4 - x % 2 * 4)) & 0xf];\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) argb;\n+                }\n+\n+                srcoff += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = getGetter().nonPreColors;\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 2) >> (4 - x % 2 * 4)) & 0xf];\n+                    dstbuf.put(dstoff, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) argb);\n+                    dstoff += 3;\n+                }\n+\n+                srcoff += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/FourBitIndexed.java","additions":182,"deletions":182,"binary":false,"changes":364,"status":"modified"},{"patch":"@@ -1,178 +1,178 @@\n-\/*\r\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.  Oracle designates this\r\n- * particular file as subject to the \"Classpath\" exception as provided\r\n- * by Oracle in the LICENSE file that accompanied this code.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-package com.sun.javafx.image.impl;\r\n-\r\n-import com.sun.javafx.image.BytePixelSetter;\r\n-import com.sun.javafx.image.IndexedToBytePixelConverter;\r\n-import java.nio.ByteBuffer;\r\n-\r\n-public final class OneBitIndexed {\r\n-\r\n-    private OneBitIndexed() {}\r\n-\r\n-    public static Getter createGetter(int[] colors, Boolean premultiplied) {\r\n-        return new Getter(colors, premultiplied);\r\n-    }\r\n-\r\n-    public static IndexedToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\r\n-        return new ToByteRgbConverter(src, dst);\r\n-    }\r\n-\r\n-    public static IndexedToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\r\n-        return new ToByteBgraAnyConverter(src, dst);\r\n-    }\r\n-\r\n-    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\r\n-        Getter(int[] colors, Boolean premultiplied) {\r\n-            super(colors, premultiplied);\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getNumElements() {\r\n-            return 1;\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgb(byte[] arr, int offset) {\r\n-            return preColors[(arr[offset \/ 8] >> (7 - offset % 8)) & 1];\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgbPre(byte[] arr, int offset) {\r\n-            return nonPreColors[(arr[offset \/ 8] >> (7 - offset % 8)) & 1];\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgb(ByteBuffer buf, int offset) {\r\n-            return preColors[(buf.get(offset \/ 8) >> (7 - offset % 8)) & 1];\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgbPre(ByteBuffer buf, int offset) {\r\n-            return nonPreColors[(buf.get(offset \/ 8) >> (7 - offset % 8)) & 1];\r\n-        }\r\n-    }\r\n-\r\n-    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\r\n-        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\r\n-            super(getter, setter);\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\r\n-                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = switch (setter.getAlphaType()) {\r\n-                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n-                case PREMULTIPLIED -> getGetter().preColors;\r\n-            };\r\n-\r\n-            dstscanbytes -= w * 4;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 8] >> (7 - x % 8)) & 1];\r\n-                    dstarr[dstoff++] = (byte) argb;\r\n-                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n-                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n-                    dstarr[dstoff++] = (byte) (argb >> 24);\r\n-                }\r\n-                srcoff += srcscanbits;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\r\n-                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = switch (setter.getAlphaType()) {\r\n-                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n-                case PREMULTIPLIED -> getGetter().preColors;\r\n-            };\r\n-\r\n-            dstscanbytes -= w * 4;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 8) >> (7 - x % 8)) & 1];\r\n-                    dstbuf.put(dstoff, (byte) argb);\r\n-                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n-                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\r\n-                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\r\n-                    dstoff += 4;\r\n-                }\r\n-                srcoff += srcscanbits;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\r\n-        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\r\n-            super(getter, setter);\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\r\n-                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = getGetter().nonPreColors;\r\n-            dstscanbytes -= w * 3;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 8] >> (7 - x % 8)) & 1];\r\n-                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n-                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n-                    dstarr[dstoff++] = (byte) argb;\r\n-                }\r\n-                srcoff += srcscanbits;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\r\n-                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = getGetter().nonPreColors;\r\n-            dstscanbytes -= w * 3;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 8) >> (7 - x % 8)) & 1];\r\n-                    dstbuf.put(dstoff, (byte) (argb >> 16));\r\n-                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n-                    dstbuf.put(dstoff + 2, (byte) argb);\r\n-                    dstoff += 3;\r\n-                }\r\n-                srcoff += srcscanbits;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.BytePixelSetter;\n+import com.sun.javafx.image.IndexedToBytePixelConverter;\n+import java.nio.ByteBuffer;\n+\n+public final class OneBitIndexed {\n+\n+    private OneBitIndexed() {}\n+\n+    public static Getter createGetter(int[] colors, Boolean premultiplied) {\n+        return new Getter(colors, premultiplied);\n+    }\n+\n+    public static IndexedToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\n+        return new ToByteRgbConverter(src, dst);\n+    }\n+\n+    public static IndexedToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\n+        return new ToByteBgraAnyConverter(src, dst);\n+    }\n+\n+    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\n+        Getter(int[] colors, Boolean premultiplied) {\n+            super(colors, premultiplied);\n+        }\n+\n+        @Override\n+        public int getNumElements() {\n+            return 1;\n+        }\n+\n+        @Override\n+        public int getArgb(byte[] arr, int offset) {\n+            return preColors[(arr[offset \/ 8] >> (7 - offset % 8)) & 1];\n+        }\n+\n+        @Override\n+        public int getArgbPre(byte[] arr, int offset) {\n+            return nonPreColors[(arr[offset \/ 8] >> (7 - offset % 8)) & 1];\n+        }\n+\n+        @Override\n+        public int getArgb(ByteBuffer buf, int offset) {\n+            return preColors[(buf.get(offset \/ 8) >> (7 - offset % 8)) & 1];\n+        }\n+\n+        @Override\n+        public int getArgbPre(ByteBuffer buf, int offset) {\n+            return nonPreColors[(buf.get(offset \/ 8) >> (7 - offset % 8)) & 1];\n+        }\n+    }\n+\n+    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\n+        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 8] >> (7 - x % 8)) & 1];\n+                    dstarr[dstoff++] = (byte) argb;\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 24);\n+                }\n+                srcoff += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 8) >> (7 - x % 8)) & 1];\n+                    dstbuf.put(dstoff, (byte) argb);\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\n+                    dstoff += 4;\n+                }\n+                srcoff += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+\n+    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\n+        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = getGetter().nonPreColors;\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 8] >> (7 - x % 8)) & 1];\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) argb;\n+                }\n+                srcoff += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = getGetter().nonPreColors;\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 8) >> (7 - x % 8)) & 1];\n+                    dstbuf.put(dstoff, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) argb);\n+                    dstoff += 3;\n+                }\n+                srcoff += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/OneBitIndexed.java","additions":178,"deletions":178,"binary":false,"changes":356,"status":"modified"},{"patch":"@@ -1,178 +1,178 @@\n-\/*\r\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.  Oracle designates this\r\n- * particular file as subject to the \"Classpath\" exception as provided\r\n- * by Oracle in the LICENSE file that accompanied this code.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-package com.sun.javafx.image.impl;\r\n-\r\n-import com.sun.javafx.image.BytePixelSetter;\r\n-import com.sun.javafx.image.IndexedToBytePixelConverter;\r\n-import java.nio.ByteBuffer;\r\n-\r\n-public final class TwoBitIndexed {\r\n-\r\n-    private TwoBitIndexed() {}\r\n-\r\n-    public static Getter createGetter(int[] colors, Boolean premultiplied) {\r\n-        return new Getter(colors, premultiplied);\r\n-    }\r\n-\r\n-    public static IndexedToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\r\n-        return new ToByteRgbConverter(src, dst);\r\n-    }\r\n-\r\n-    public static IndexedToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\r\n-        return new ToByteBgraAnyConverter(src, dst);\r\n-    }\r\n-\r\n-    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\r\n-        Getter(int[] colors, Boolean premultiplied) {\r\n-            super(colors, premultiplied);\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getNumElements() {\r\n-            return 2;\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgb(byte[] arr, int offset) {\r\n-            return preColors[(arr[offset \/ 4] >> (6 - offset % 4 * 2)) & 3];\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgbPre(byte[] arr, int offset) {\r\n-            return nonPreColors[(arr[offset \/ 4] >> (6 - offset % 4 * 2)) & 3];\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgb(ByteBuffer buf, int offset) {\r\n-            return preColors[(buf.get(offset \/ 4) >> (6 - offset % 4 * 2)) & 3];\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getArgbPre(ByteBuffer buf, int offset) {\r\n-            return nonPreColors[(buf.get(offset \/ 4) >> (6 - offset % 4 * 2)) & 3];\r\n-        }\r\n-    }\r\n-\r\n-    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\r\n-        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\r\n-            super(getter, setter);\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\r\n-                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = switch (setter.getAlphaType()) {\r\n-                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n-                case PREMULTIPLIED -> getGetter().preColors;\r\n-            };\r\n-\r\n-            dstscanbytes -= w * 4;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 4] >> (6 - x % 4 * 2)) & 3];\r\n-                    dstarr[dstoff++] = (byte) argb;\r\n-                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n-                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n-                    dstarr[dstoff++] = (byte) (argb >> 24);\r\n-                }\r\n-                srcoff += srcscanbits;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\r\n-                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = switch (setter.getAlphaType()) {\r\n-                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n-                case PREMULTIPLIED -> getGetter().preColors;\r\n-            };\r\n-\r\n-            dstscanbytes -= w * 4;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 4) >> (6 - x % 4 * 2)) & 3];\r\n-                    dstbuf.put(dstoff, (byte) argb);\r\n-                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n-                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\r\n-                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\r\n-                    dstoff += 4;\r\n-                }\r\n-                srcoff += srcscanbytes;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\r\n-        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\r\n-            super(getter, setter);\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\r\n-                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = getGetter().nonPreColors;\r\n-            dstscanbytes -= w * 3;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 4] >> (6 - x % 4 * 2)) & 3];\r\n-                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n-                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n-                    dstarr[dstoff++] = (byte) argb;\r\n-                }\r\n-                srcoff += srcscanbytes;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-\r\n-        @Override\r\n-        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\r\n-                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n-                       int w, int h) {\r\n-            int[] colors = getGetter().nonPreColors;\r\n-            dstscanbytes -= w * 3;\r\n-\r\n-            while (--h >= 0) {\r\n-                for (int x = 0; x < w; x++) {\r\n-                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 4) >> (6 - x % 4 * 2)) & 3];\r\n-                    dstbuf.put(dstoff, (byte) (argb >> 16));\r\n-                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n-                    dstbuf.put(dstoff + 2, (byte) argb);\r\n-                    dstoff += 3;\r\n-                }\r\n-                srcoff += srcscanbytes;\r\n-                dstoff += dstscanbytes;\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.BytePixelSetter;\n+import com.sun.javafx.image.IndexedToBytePixelConverter;\n+import java.nio.ByteBuffer;\n+\n+public final class TwoBitIndexed {\n+\n+    private TwoBitIndexed() {}\n+\n+    public static Getter createGetter(int[] colors, Boolean premultiplied) {\n+        return new Getter(colors, premultiplied);\n+    }\n+\n+    public static IndexedToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\n+        return new ToByteRgbConverter(src, dst);\n+    }\n+\n+    public static IndexedToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\n+        return new ToByteBgraAnyConverter(src, dst);\n+    }\n+\n+    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\n+        Getter(int[] colors, Boolean premultiplied) {\n+            super(colors, premultiplied);\n+        }\n+\n+        @Override\n+        public int getNumElements() {\n+            return 2;\n+        }\n+\n+        @Override\n+        public int getArgb(byte[] arr, int offset) {\n+            return preColors[(arr[offset \/ 4] >> (6 - offset % 4 * 2)) & 3];\n+        }\n+\n+        @Override\n+        public int getArgbPre(byte[] arr, int offset) {\n+            return nonPreColors[(arr[offset \/ 4] >> (6 - offset % 4 * 2)) & 3];\n+        }\n+\n+        @Override\n+        public int getArgb(ByteBuffer buf, int offset) {\n+            return preColors[(buf.get(offset \/ 4) >> (6 - offset % 4 * 2)) & 3];\n+        }\n+\n+        @Override\n+        public int getArgbPre(ByteBuffer buf, int offset) {\n+            return nonPreColors[(buf.get(offset \/ 4) >> (6 - offset % 4 * 2)) & 3];\n+        }\n+    }\n+\n+    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\n+        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 4] >> (6 - x % 4 * 2)) & 3];\n+                    dstarr[dstoff++] = (byte) argb;\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 24);\n+                }\n+                srcoff += srcscanbits;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = switch (setter.getAlphaType()) {\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\n+                case PREMULTIPLIED -> getGetter().preColors;\n+            };\n+\n+            dstscanbytes -= w * 4;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 4) >> (6 - x % 4 * 2)) & 3];\n+                    dstbuf.put(dstoff, (byte) argb);\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\n+                    dstoff += 4;\n+                }\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+\n+    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\n+        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = getGetter().nonPreColors;\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 4] >> (6 - x % 4 * 2)) & 3];\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\n+                    dstarr[dstoff++] = (byte) argb;\n+                }\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h) {\n+            int[] colors = getGetter().nonPreColors;\n+            dstscanbytes -= w * 3;\n+\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 4) >> (6 - x % 4 * 2)) & 3];\n+                    dstbuf.put(dstoff, (byte) (argb >> 16));\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\n+                    dstbuf.put(dstoff + 2, (byte) argb);\n+                    dstoff += 3;\n+                }\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/TwoBitIndexed.java","additions":178,"deletions":178,"binary":false,"changes":356,"status":"modified"}]}