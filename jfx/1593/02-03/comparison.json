{"files":[{"patch":"@@ -40,1 +40,2 @@\n-    private final byte[][] palette;\n+    private final int[] palette;\n+    private final int paletteIndexBits;\n@@ -53,3 +54,1 @@\n-     * horizontal position in the next row, in bytes\n-     * @param palette The image palette. This is ignored unless the type is\n-     * one of the palette types.\n+     * horizontal position in the next row.\n@@ -59,6 +58,21 @@\n-                      int width, int height, int stride, byte[][] palette,\n-                      ImageMetadata metadata)\n-    {\n-        this(imageType, imageData,\n-             width, height, stride, palette,\n-             1.0f, metadata);\n+                      int width, int height, int stride,\n+                      ImageMetadata metadata) {\n+        this(imageType, imageData, width, height, stride, 1.0f, metadata);\n+    }\n+\n+    \/**\n+     * Create an <code>ImageFrame<\/code>.\n+     *\n+     * @param imageType The type of image data. The value of this field also implies the number of bands.\n+     * @param imageData The image data.\n+     * @param width The image width.\n+     * @param height The image height.\n+     * @param stride The stride from a pixel position in one row to the same horizontal position in the next row.\n+     * @param pixelScale The scale of a 72DPI virtual pixel in the resolution of the image\n+     *                   (1.0f for 72DPI images, 2.0f for 144DPI images, etc.).\n+     * @param metadata The image metadata.\n+     *\/\n+    public ImageFrame(ImageType imageType, Buffer imageData,\n+                      int width, int height, int stride,\n+                      float pixelScale, ImageMetadata metadata) {\n+        this(imageType, imageData, width, height, stride, null, -1, pixelScale, metadata);\n@@ -75,4 +89,3 @@\n-     * @param stride The stride from a pixel position in one row to the same\n-     * horizontal position in the next row, in bytes\n-     * @param palette The image palette. This is ignored unless the type is\n-     * one of the palette types.\n+     * @param stride The stride from a pixel position in one row to the same horizontal position in the next row.\n+     * @param palette The image palette. This is ignored unless the type is one of the palette types.\n+     * @param paletteIndexBits The size of a palette index, in bits.\n@@ -84,3 +97,2 @@\n-                      int width, int height, int stride, byte[][] palette,\n-                      float pixelScale, ImageMetadata metadata)\n-    {\n+                      int width, int height, int stride, int[] palette,\n+                      int paletteIndexBits, float pixelScale, ImageMetadata metadata) {\n@@ -93,0 +105,1 @@\n+        this.paletteIndexBits = paletteIndexBits;\n@@ -117,1 +130,1 @@\n-    public byte[][] getPalette() {\n+    public int[] getPalette() {\n@@ -121,0 +134,4 @@\n+    public int getPaletteIndexBits() {\n+        return paletteIndexBits;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/ImageFrame.java","additions":35,"deletions":18,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-         * An image with one 8-bit channel of indexes into a 24-bit\n+         * An image with one channel of indexes into a 24-bit\n@@ -82,1 +82,1 @@\n-         * An image with one 8-bit channel of indexes into a 32-bit\n+         * An image with one channel of indexes into a 32-bit\n@@ -88,1 +88,1 @@\n-         * An image with one 8-bit channel of indexes into a 32-bit\n+         * An image with one channel of indexes into a 32-bit\n@@ -94,1 +94,1 @@\n-         * An image with one 8-bit channel of indexes into a 24-bit\n+         * An image with one channel of indexes into a 24-bit\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/ImageStorage.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-                width, height, width * bpp, null, imagePixelScale, imageMetadata);\n+                width, height, width * bpp, imagePixelScale, imageMetadata);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/bmp\/BMPImageLoaderFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import com.sun.javafx.geom.Point2D;\n-import com.sun.javafx.geom.Rectangle;\n@@ -31,1 +29,0 @@\n-import com.sun.javafx.iio.ImageMetadata;\n@@ -33,1 +30,0 @@\n-import com.sun.javafx.iio.ImageStorage.ImageType;\n@@ -40,1 +36,0 @@\n-import java.nio.Buffer;\n@@ -133,320 +128,0 @@\n-\/\/    public static PixelFormat getPixelFormat(ImageType type) {\n-\/\/        PixelFormat format;\n-\/\/        switch (type) {\n-\/\/            case GRAY:\n-\/\/                format = PixelFormat.BYTE_GRAY;\n-\/\/                break;\n-\/\/            case GRAY_ALPHA:\n-\/\/            case GRAY_ALPHA_PRE:\n-\/\/                format = PixelFormat.BYTE_RGBA_PRE;\n-\/\/                break;\n-\/\/            case PALETTE:\n-\/\/                format = PixelFormat.BYTE_RGB;\n-\/\/                break;\n-\/\/            case PALETTE_ALPHA:\n-\/\/            case PALETTE_ALPHA_PRE:\n-\/\/                format = PixelFormat.BYTE_RGBA_PRE;\n-\/\/                break;\n-\/\/            case RGB:\n-\/\/                format = PixelFormat.BYTE_RGB;\n-\/\/                break;\n-\/\/            case RGBA:\n-\/\/            case RGBA_PRE:\n-\/\/                format = PixelFormat.BYTE_RGBA_PRE;\n-\/\/                break;\n-\/\/            default:\n-\/\/                \/\/ This should not be possible ...\n-\/\/                throw new IllegalArgumentException(\"Unknown ImageType \" + type);\n-\/\/        }\n-\/\/\n-\/\/        return format;\n-\/\/    }\n-\/\/    public static boolean isConversionACopy(ImageType type, PixelFormat format) {\n-\/\/        return (type == ImageType.GRAY && format == PixelFormat.BYTE_GRAY) ||\n-\/\/                (type == ImageType.RGB && format == PixelFormat.BYTE_RGB) ||\n-\/\/                (type == ImageType.RGBA_PRE && format == PixelFormat.BYTE_RGBA_PRE);\n-\/\/    }\n-    public static ImageType getConvertedType(ImageType type) {\n-        ImageType retType = type;\n-        switch (type) {\n-            case GRAY:\n-                retType = ImageType.GRAY;\n-                break;\n-            case GRAY_ALPHA:\n-            case GRAY_ALPHA_PRE:\n-            case PALETTE_ALPHA:\n-            case PALETTE_ALPHA_PRE:\n-            case PALETTE_TRANS:\n-            case RGBA:\n-                retType = ImageType.RGBA_PRE;\n-                break;\n-            case PALETTE:\n-            case RGB:\n-                retType = ImageType.RGB;\n-                break;\n-            case RGBA_PRE:\n-                retType = ImageType.RGBA_PRE;\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Unsupported ImageType \" + type);\n-        }\n-        return retType;\n-    }\n-\n-    public static byte[] createImageArray(ImageType type, int width, int height) {\n-        int numBands = 0;\n-        switch (type) {\n-            case GRAY:\n-            case PALETTE:\n-            case PALETTE_ALPHA:\n-            case PALETTE_ALPHA_PRE:\n-                numBands = 1;\n-                break;\n-            case GRAY_ALPHA:\n-            case GRAY_ALPHA_PRE:\n-                numBands = 2;\n-                break;\n-            case RGB:\n-                numBands = 3;\n-                break;\n-            case RGBA:\n-            case RGBA_PRE:\n-                numBands = 4;\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Unsupported ImageType \" + type);\n-        }\n-        return new byte[width * height * numBands];\n-    }\n-\n-    public static ImageFrame convertImageFrame(ImageFrame frame) {\n-        ImageFrame retFrame;\n-        ImageType type = frame.getImageType();\n-        ImageType convertedType = getConvertedType(type);\n-        if (convertedType == type) {\n-            retFrame = frame;\n-        } else {\n-            byte[] inArray = null;\n-            Buffer buf = frame.getImageData();\n-            if (!(buf instanceof ByteBuffer)) {\n-                throw new IllegalArgumentException(\"!(frame.getImageData() instanceof ByteBuffer)\");\n-            }\n-            ByteBuffer bbuf = (ByteBuffer) buf;\n-            if (bbuf.hasArray()) {\n-                inArray = bbuf.array();\n-            } else {\n-                inArray = new byte[bbuf.capacity()];\n-                bbuf.get(inArray);\n-            }\n-            int width = frame.getWidth();\n-            int height = frame.getHeight();\n-            int inStride = frame.getStride();\n-            byte[] outArray = createImageArray(convertedType, width, height);\n-            ByteBuffer newBuf = ByteBuffer.wrap(outArray);\n-            int outStride = outArray.length \/ height;\n-            byte[][] palette = frame.getPalette();\n-            ImageMetadata metadata = frame.getMetadata();\n-            int transparentIndex = metadata.transparentIndex != null ? metadata.transparentIndex : 0;\n-            convert(width, height, type,\n-                    inArray, 0, inStride, outArray, 0, outStride,\n-                    palette, transparentIndex, false);\n-            ImageMetadata imd = new ImageMetadata(metadata.gamma,\n-                    metadata.blackIsZero, null,\n-                    metadata.backgroundColor, null,\n-                    metadata.delayTime, metadata.loopCount,\n-                    metadata.imageWidth, metadata.imageHeight,\n-                    metadata.imageLeftPosition, metadata.imageTopPosition,\n-                    metadata.disposalMethod);\n-            retFrame = new ImageFrame(convertedType, newBuf, width, height,\n-                    outStride, null, imd);\n-        }\n-        return retFrame;\n-    }\n-\n-    public static byte[] convert(int width, int height, ImageType inputType,\n-            byte[] input, int inputOffset, int inRowStride,\n-            byte[] output, int outputOffset, int outRowStride,\n-            byte[][] palette, int transparentIndex, boolean skipTransparent) {\n-        \/\/\n-        \/\/ Take care of the layouts that are a direct copy.\n-        \/\/\n-        if (inputType == ImageType.GRAY ||\n-                inputType == ImageType.RGB ||\n-                inputType == ImageType.RGBA_PRE) {\n-            if (input != output) {\n-                int bytesPerRow = width;\n-                if (inputType == ImageType.RGB) {\n-                    bytesPerRow *= 3;\n-                } else if (inputType == ImageType.RGBA_PRE) {\n-                    bytesPerRow *= 4;\n-                }\n-                if (height == 1) {\n-                    System.arraycopy(input, inputOffset, output, outputOffset, bytesPerRow);\n-                } else {\n-                    int inRowOffset = inputOffset;\n-                    int outRowOffset = outputOffset;\n-                    for (int row = 0; row < height; row++) {\n-                        System.arraycopy(input, inRowOffset, output, outRowOffset, bytesPerRow);\n-                        inRowOffset += inRowStride;\n-                        outRowOffset += outRowStride;\n-                    }\n-                }\n-            }\n-        } else if (inputType == ImageType.GRAY_ALPHA || inputType == ImageType.GRAY_ALPHA_PRE) {\n-            int inOffset = inputOffset;\n-            int outOffset = outputOffset;\n-            if (inputType == ImageType.GRAY_ALPHA) {\n-                for (int y = 0; y < height; y++) {\n-                    int inOff = inOffset;\n-                    int outOff = outOffset;\n-                    for (int x = 0; x < width; x++) {\n-                        \/\/ copy input to local variables in case operating in place\n-                        byte gray = input[inOff++];\n-                        int alpha = input[inOff++] & 0xff;\n-                        float f = alpha \/ 255.0F;\n-                        gray = (byte) (f * (gray & 0xff));\n-                        output[outOff++] = gray;\n-                        output[outOff++] = gray;\n-                        output[outOff++] = gray;\n-                        output[outOff++] = (byte) alpha;\n-                    }\n-                    inOffset += inRowStride;\n-                    outOffset += outRowStride;\n-                }\n-            } else {\n-                for (int y = 0; y < height; y++) {\n-                    int inOff = inOffset;\n-                    int outOff = outOffset;\n-                    for (int x = 0; x < width; x++) {\n-                        \/\/ copy input to local variables in case operating in place\n-                        byte gray = input[inOff++];\n-                        output[outOff++] = gray;\n-                        output[outOff++] = gray;\n-                        output[outOff++] = gray;\n-                        output[outOff++] = input[inOff++];\n-                    }\n-                    inOffset += inRowStride;\n-                    outOffset += outRowStride;\n-                }\n-            }\n-        } else if (inputType == ImageType.PALETTE) {\n-            int inOffset = inputOffset;\n-            int outOffset = outputOffset;\n-            byte[] red = palette[0];\n-            byte[] green = palette[1];\n-            byte[] blue = palette[2];\n-            int inOff = inOffset;\n-            int outOff = outOffset;\n-            \/\/loop through the scanline and mask for the value if each byte.\n-            \/\/the byte is an index into the palette array for that pixel.\n-            for (int x = 0; x < width; x++) {\n-                int index = (input[inOff++] & 0xff);\n-\n-                output[outOff++] = red[index];\n-                output[outOff++] = green[index];\n-                output[outOff++] = blue[index];\n-\n-                outOffset += outRowStride;\n-            }\n-        } else if (inputType == ImageType.PALETTE_ALPHA) {\n-            int inOffset = inputOffset;\n-            int outOffset = outputOffset;\n-            byte[] red = palette[0];\n-            byte[] green = palette[1];\n-            byte[] blue = palette[2];\n-            byte[] alpha = palette[3];\n-                int inOff = inOffset;\n-                int outOff = outOffset;\n-                for (int x = 0; x < width; x++) {\n-                    int index = input[inOff++] & 0xff;\n-                    byte r = red[index];\n-                    byte g = green[index];\n-                    byte b = blue[index];\n-                    int a = alpha[index] & 0xff;\n-                    float f = a \/ 255.0F;\n-                    output[outOff++] = (byte) (f * (r & 0xff));\n-                    output[outOff++] = (byte) (f * (g & 0xff));\n-                    output[outOff++] = (byte) (f * (b & 0xff));\n-                    output[outOff++] = (byte) a;\n-                }\n-                inOffset += inRowStride;\n-                outOffset += outRowStride;\n-        } else if (inputType == ImageType.PALETTE_ALPHA_PRE) {\n-            int inOffset = inputOffset;\n-            int outOffset = outputOffset;\n-            byte[] red = palette[0];\n-            byte[] green = palette[1];\n-            byte[] blue = palette[2];\n-            byte[] alpha = palette[3];\n-            for (int y = 0; y < height; y++) {\n-                int inOff = inOffset;\n-                int outOff = outOffset;\n-                for (int x = 0; x < width; x++) {\n-                    int index = input[inOff++] & 0xff;\n-                    output[outOff++] = red[index];\n-                    output[outOff++] = green[index];\n-                    output[outOff++] = blue[index];\n-                    output[outOff++] = alpha[index];\n-                }\n-                inOffset += inRowStride;\n-                outOffset += outRowStride;\n-            }\n-        } else if (inputType == ImageType.PALETTE_TRANS) {\n-            int inOffset = inputOffset;\n-            int outOffset = outputOffset;\n-            for (int y = 0; y < height; y++) {\n-                int inOff = inOffset;\n-                int outOff = outOffset;\n-                byte[] red = palette[0];\n-                byte[] green = palette[1];\n-                byte[] blue = palette[2];\n-                for (int x = 0; x < width; x++) {\n-                    int index = input[inOff++] & 0xff;\n-                    if (index == transparentIndex) {\n-                        if (skipTransparent) {\n-                            outOff+=4;\n-                        } else {\n-                            output[outOff++] = (byte) 0;\n-                            output[outOff++] = (byte) 0;\n-                            output[outOff++] = (byte) 0;\n-                            output[outOff++] = (byte) 0;\n-                        }\n-                    } else {\n-                        output[outOff++] = red[index];\n-                        output[outOff++] = green[index];\n-                        output[outOff++] = blue[index];\n-                        output[outOff++] = (byte) 255;\n-                    }\n-                }\n-                inOffset += inRowStride;\n-                outOffset += outRowStride;\n-            }\n-        } else if (inputType == ImageType.RGBA) {\n-            int inOffset = inputOffset;\n-            int outOffset = outputOffset;\n-            for (int y = 0; y < height; y++) {\n-                int inOff = inOffset;\n-                int outOff = outOffset;\n-                for (int x = 0; x < width; x++) {\n-                    \/\/ copy input to local variables in case operating in place\n-                    byte red = input[inOff++];\n-                    byte green = input[inOff++];\n-                    byte blue = input[inOff++];\n-                    int alpha = input[inOff++] & 0xff;\n-                    float f = alpha \/ 255.0F;\n-                    output[outOff++] = (byte) (f * (red & 0xff));\n-                    output[outOff++] = (byte) (f * (green & 0xff));\n-                    output[outOff++] = (byte) (f * (blue & 0xff));\n-                    output[outOff++] = (byte) alpha;\n-                }\n-\/\/                System.arraycopy(input, inOffset, output, outOffset, width*4);\n-                inOffset += inRowStride;\n-                outOffset += outRowStride;\n-            }\n-        } else {\n-            throw new UnsupportedOperationException(\"Unsupported ImageType \" +\n-                    inputType);\n-        }\n-\n-        return output;\n-    }\n@@ -493,160 +168,0 @@\n-    \/\/ Helper for computeUpdatedPixels method\n-    private static void computeUpdatedPixels(int sourceOffset,\n-            int sourceExtent,\n-            int destinationOffset,\n-            int dstMin,\n-            int dstMax,\n-            int sourceSubsampling,\n-            int passStart,\n-            int passExtent,\n-            int passPeriod,\n-            int[] vals,\n-            int offset) {\n-        \/\/ We need to satisfy the congruences:\n-        \/\/ dst = destinationOffset + (src - sourceOffset)\/sourceSubsampling\n-        \/\/\n-        \/\/ src - passStart == 0 (mod passPeriod)\n-        \/\/ src - sourceOffset == 0 (mod sourceSubsampling)\n-        \/\/\n-        \/\/ subject to the inequalities:\n-        \/\/\n-        \/\/ src >= passStart\n-        \/\/ src < passStart + passExtent\n-        \/\/ src >= sourceOffset\n-        \/\/ src < sourceOffset + sourceExtent\n-        \/\/ dst >= dstMin\n-        \/\/ dst <= dstmax\n-        \/\/\n-        \/\/ where\n-        \/\/\n-        \/\/ dst = destinationOffset + (src - sourceOffset)\/sourceSubsampling\n-        \/\/\n-        \/\/ For now we use a brute-force approach although we could\n-        \/\/ attempt to analyze the congruences.  If passPeriod and\n-        \/\/ sourceSubsamling are relatively prime, the period will be\n-        \/\/ their product.  If they share a common factor, either the\n-        \/\/ period will be equal to the larger value, or the sequences\n-        \/\/ will be completely disjoint, depending on the relationship\n-        \/\/ between passStart and sourceOffset.  Since we only have to do this\n-        \/\/ twice per image (once each for X and Y), it seems cheap enough\n-        \/\/ to do it the straightforward way.\n-\n-        boolean gotPixel = false;\n-        int firstDst = -1;\n-        int secondDst = -1;\n-        int lastDst = -1;\n-\n-        for (int i = 0; i < passExtent; i++) {\n-            int src = passStart + i * passPeriod;\n-            if (src < sourceOffset) {\n-                continue;\n-            }\n-            if ((src - sourceOffset) % sourceSubsampling != 0) {\n-                continue;\n-            }\n-            if (src >= sourceOffset + sourceExtent) {\n-                break;\n-            }\n-\n-            int dst = destinationOffset +\n-                    (src - sourceOffset) \/ sourceSubsampling;\n-            if (dst < dstMin) {\n-                continue;\n-            }\n-            if (dst > dstMax) {\n-                break;\n-            }\n-\n-            if (!gotPixel) {\n-                firstDst = dst; \/\/ Record smallest valid pixel\n-                gotPixel = true;\n-            } else if (secondDst == -1) {\n-                secondDst = dst; \/\/ Record second smallest valid pixel\n-            }\n-            lastDst = dst; \/\/ Record largest valid pixel\n-        }\n-\n-        vals[offset] = firstDst;\n-\n-        \/\/ If we never saw a valid pixel, set width to 0\n-        if (!gotPixel) {\n-            vals[offset + 2] = 0;\n-        } else {\n-            vals[offset + 2] = lastDst - firstDst + 1;\n-        }\n-\n-        \/\/ The period is given by the difference of any two adjacent pixels\n-        vals[offset + 4] = Math.max(secondDst - firstDst, 1);\n-    }\n-\n-    \/**\n-     * A utility method that computes the exact set of destination\n-     * pixels that will be written during a particular decoding pass.\n-     * The intent is to simplify the work done by readers in combining\n-     * the source region, source subsampling, and destination offset\n-     * information obtained from the <code>ImageReadParam<\/code> with\n-     * the offsets and periods of a progressive or interlaced decoding\n-     * pass.\n-     *\n-     * @param sourceRegion a <code>Rectangle<\/code> containing the\n-     * source region being read, offset by the source subsampling\n-     * offsets, and clipped against the source bounds, as returned by\n-     * the <code>getSourceRegion<\/code> method.\n-     * @param destinationOffset a <code>Point<\/code> containing the\n-     * coordinates of the upper-left pixel to be written in the\n-     * destination.\n-     * @param dstMinX the smallest X coordinate (inclusive) of the\n-     * destination <code>Raster<\/code>.\n-     * @param dstMinY the smallest Y coordinate (inclusive) of the\n-     * destination <code>Raster<\/code>.\n-     * @param dstMaxX the largest X coordinate (inclusive) of the destination\n-     * <code>Raster<\/code>.\n-     * @param dstMaxY the largest Y coordinate (inclusive) of the destination\n-     * <code>Raster<\/code>.\n-     * @param sourceXSubsampling the X subsampling factor.\n-     * @param sourceYSubsampling the Y subsampling factor.\n-     * @param passXStart the smallest source X coordinate (inclusive)\n-     * of the current progressive pass.\n-     * @param passYStart the smallest source Y coordinate (inclusive)\n-     * of the current progressive pass.\n-     * @param passWidth the width in pixels of the current progressive\n-     * pass.\n-     * @param passHeight the height in pixels of the current progressive\n-     * pass.\n-     * @param passPeriodX the X period (horizontal spacing between\n-     * pixels) of the current progressive pass.\n-     * @param passPeriodY the Y period (vertical spacing between\n-     * pixels) of the current progressive pass.\n-     *\n-     * @return an array of 6 <code>int<\/code>s containing the\n-     * destination min X, min Y, width, height, X period and Y period\n-     * of the region that will be updated.\n-     *\/\n-    public static int[] computeUpdatedPixels(Rectangle sourceRegion,\n-            Point2D destinationOffset,\n-            int dstMinX,\n-            int dstMinY,\n-            int dstMaxX,\n-            int dstMaxY,\n-            int sourceXSubsampling,\n-            int sourceYSubsampling,\n-            int passXStart,\n-            int passYStart,\n-            int passWidth,\n-            int passHeight,\n-            int passPeriodX,\n-            int passPeriodY) {\n-        int[] vals = new int[6];\n-        computeUpdatedPixels(sourceRegion.x, sourceRegion.width,\n-                (int) (destinationOffset.x + 0.5F),\n-                dstMinX, dstMaxX, sourceXSubsampling,\n-                passXStart, passWidth, passPeriodX,\n-                vals, 0);\n-        computeUpdatedPixels(sourceRegion.y, sourceRegion.height,\n-                (int) (destinationOffset.y + 0.5F),\n-                dstMinY, dstMaxY, sourceYSubsampling,\n-                passYStart, passHeight, passPeriodY,\n-                vals, 1);\n-        return vals;\n-    }\n-\n@@ -707,1 +222,1 @@\n-                destWidth, destHeight, destWidth * numBands, null, src.getMetadata());\n+                destWidth, destHeight, destWidth * numBands, src.getMetadata());\n@@ -734,67 +249,0 @@\n-\/\/    public static final java.awt.image.BufferedImage getAsBufferedImage(Image prismImage) {\n-\/\/        java.awt.image.BufferedImage image = null;\n-\/\/\n-\/\/        int width = prismImage.getWidth();\n-\/\/        int height = prismImage.getHeight();\n-\/\/        int scanlineStride = prismImage.getScanlineStride();\n-\/\/        byte[] pixels = ((java.nio.ByteBuffer) prismImage.getPixelBuffer()).array();\n-\/\/        switch (prismImage.getPixelFormat()) {\n-\/\/            case BYTE_GRAY: {\n-\/\/                image = new java.awt.image.BufferedImage(width, height,\n-\/\/                        java.awt.image.BufferedImage.TYPE_BYTE_GRAY);\n-\/\/                java.awt.image.DataBufferByte db =\n-\/\/                        (java.awt.image.DataBufferByte) image.getRaster().getDataBuffer();\n-\/\/                byte[] data = db.getData();\n-\/\/                System.arraycopy(pixels, 0, data, 0, width * height);\n-\/\/            }\n-\/\/            break;\n-\/\/            case BYTE_RGB: {\n-\/\/                image = new java.awt.image.BufferedImage(width, height,\n-\/\/                        java.awt.image.BufferedImage.TYPE_3BYTE_BGR);\n-\/\/                for (int y = 0; y < height; y++) {\n-\/\/                    int off = y * scanlineStride;\n-\/\/                    for (int x = 0; x < width; x++) {\n-\/\/                        int rgb = ((pixels[off++] & 0xff) << 16) |\n-\/\/                                ((pixels[off++] & 0xff) << 8) |\n-\/\/                                (pixels[off++] & 0xff);\n-\/\/                        image.setRGB(x, y, rgb);\n-\/\/                    }\n-\/\/                }\n-\/\/            }\n-\/\/            break;\n-\/\/            case BYTE_RGBA_PRE: {\n-\/\/                image = new java.awt.image.BufferedImage(width, height,\n-\/\/                        java.awt.image.BufferedImage.TYPE_4BYTE_ABGR_PRE);\n-\/\/--                for (int y = 0; y < height; y++) {\n-\/\/--                    int off = y * scanlineStride;\n-\/\/--                    for (int x = 0; x < width; x++) {\n-\/\/--                        int rgb = ((pixels[off++] & 0xff) << 16) |\n-\/\/--                                ((pixels[off++] & 0xff) << 8) |\n-\/\/--                                (pixels[off++] & 0xff) |\n-\/\/--                                ((pixels[off++] & 0xff) << 24);\n-\/\/--                        image.setRGB(x, y, rgb);\n-\/\/--                    }\n-\/\/--                }\n-\/\/                java.awt.image.DataBufferByte db =\n-\/\/                        (java.awt.image.DataBufferByte) image.getRaster().getDataBuffer();\n-\/\/                byte[] data = db.getData();\n-\/\/                for (int y = 0; y < height; y++) {\n-\/\/                    int offPrism = y * scanlineStride;\n-\/\/                    int offImage = y * width * 4;\n-\/\/                    for (int x = 0; x < width; x++) {\n-\/\/                        data[offImage++] = pixels[offPrism + 3]; \/\/ A\n-\/\/                        data[offImage++] = pixels[offPrism + 2]; \/\/ B\n-\/\/                        data[offImage++] = pixels[offPrism + 1]; \/\/ G\n-\/\/                        data[offImage++] = pixels[offPrism];     \/\/ R\n-\/\/                        offPrism += 4;\n-\/\/                    }\n-\/\/                }\n-\/\/            }\n-\/\/            break;\n-\/\/            default:\n-\/\/                throw new UnsupportedOperationException(\"Unsupported test case \" +\n-\/\/                        prismImage.getPixelFormat());\n-\/\/        }\n-\/\/\n-\/\/        return image;\n-\/\/    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/common\/ImageTools.java","additions":1,"deletions":553,"binary":false,"changes":554,"status":"modified"},{"patch":"@@ -245,1 +245,1 @@\n-                width, height, width * 4, null, imagePixelScale, metadata);\n+                width, height, width * 4, imagePixelScale, metadata);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/gif\/GIFImageLoader2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,1 +264,0 @@\n-                null,\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/ios\/IosImageLoader.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.awt.image.IndexColorModel;\n@@ -155,1 +156,1 @@\n-                    getByteBuffer(image.getData().getDataBuffer()),\n+                    getByteBuffer(image.getRaster().getDataBuffer()),\n@@ -157,1 +158,1 @@\n-                    null, pixelScale, metadata);\n+                    pixelScale, metadata);\n@@ -160,1 +161,1 @@\n-                    getByteBuffer(image.getData().getDataBuffer()),\n+                    getByteBuffer(image.getRaster().getDataBuffer()),\n@@ -162,1 +163,1 @@\n-                    null, pixelScale, metadata);\n+                    pixelScale, metadata);\n@@ -165,1 +166,1 @@\n-                    getByteBuffer(image.getData().getDataBuffer()),\n+                    getByteBuffer(image.getRaster().getDataBuffer()),\n@@ -167,1 +168,1 @@\n-                    null, pixelScale, metadata);\n+                    pixelScale, metadata);\n@@ -170,1 +171,1 @@\n-                    getByteBuffer(image.getData().getDataBuffer()),\n+                    getByteBuffer(image.getRaster().getDataBuffer()),\n@@ -172,1 +173,1 @@\n-                    null, pixelScale, metadata);\n+                    pixelScale, metadata);\n@@ -175,1 +176,1 @@\n-                    getIntBuffer(image.getData().getDataBuffer()),\n+                    getIntBuffer(image.getRaster().getDataBuffer()),\n@@ -177,1 +178,1 @@\n-                    null, pixelScale, metadata);\n+                    pixelScale, metadata);\n@@ -180,1 +181,1 @@\n-                    getIntBuffer(image.getData().getDataBuffer()),\n+                    getIntBuffer(image.getRaster().getDataBuffer()),\n@@ -182,1 +183,1 @@\n-                    null, pixelScale, metadata);\n+                    pixelScale, metadata);\n@@ -185,1 +186,1 @@\n-                    getIntBuffer(image.getData().getDataBuffer()),\n+                    getIntBuffer(image.getRaster().getDataBuffer()),\n@@ -187,1 +188,1 @@\n-                    null, pixelScale, metadata);\n+                    pixelScale, metadata);\n@@ -190,1 +191,1 @@\n-                    getIntBuffer(image.getData().getDataBuffer()),\n+                    getIntBuffer(image.getRaster().getDataBuffer()),\n@@ -192,1 +193,16 @@\n-                    null, pixelScale, metadata);\n+                    pixelScale, metadata);\n+\n+            case TYPE_BYTE_BINARY, TYPE_BYTE_INDEXED -> {\n+                var colorModel = (IndexColorModel)image.getColorModel();\n+                var palette = new int[colorModel.getMapSize()];\n+                colorModel.getRGBs(palette);\n+                yield new ImageFrame(\n+                    colorModel.hasAlpha()\n+                        ? colorModel.isAlphaPremultiplied()\n+                            ? ImageStorage.ImageType.PALETTE_ALPHA_PRE\n+                            : ImageStorage.ImageType.PALETTE_ALPHA\n+                        : ImageStorage.ImageType.PALETTE,\n+                    getByteBuffer(image.getRaster().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), image.getWidth() * colorModel.getPixelSize(),\n+                    palette, colorModel.getPixelSize(), pixelScale, metadata);\n+            }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/javax\/XImageLoader.java","additions":32,"deletions":16,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-                width, height, width * outNumComponents, null, imagePixelScale, md);\n+                width, height, width * outNumComponents, imagePixelScale, md);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/jpeg\/JPEGImageLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -315,2 +315,0 @@\n-            case PNG_COLOR_PALETTE:\n-                return ImageStorage.ImageType.PALETTE;\n@@ -623,1 +621,1 @@\n-                width * bpp, null, metadata);\n+                width * bpp, metadata);\n@@ -687,1 +685,1 @@\n-                : new ImageFrame(getType(), bb, width, height, bpp * width, palette, metaData);\n+                : new ImageFrame(getType(), bb, width, height, bpp * width, metaData);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/png\/PNGImageLoader2.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\r\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.  Oracle designates this\r\n+ * particular file as subject to the \"Classpath\" exception as provided\r\n+ * by Oracle in the LICENSE file that accompanied this code.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+package com.sun.javafx.image;\r\n+\r\n+import java.nio.ByteBuffer;\r\n+\r\n+public interface IndexedToBytePixelConverter extends PixelConverter<ByteBuffer, ByteBuffer> {\r\n+\r\n+    \/**\r\n+     * Copies a rectangular region of data from the source array to the destination array.\r\n+     *\r\n+     * @param srcarr the byte array containing the source data\r\n+     * @param srcoff the index in the array of the first source pixel data\r\n+     * @param srcscanbits number of bits between rows of data in the source\r\n+     * @param dstarr the byte array containing the destination data\r\n+     * @param dstoff the index in the array of the first destination pixel data\r\n+     * @param dstscanbytes number of array indices between rows of data in the destination\r\n+     * @param w the number of pixels to process across before moving to the next row\r\n+     * @param h the number of rows of pixels to process\r\n+     *\/\r\n+    void convert(byte[] srcarr, int srcoff, int srcscanbits,\r\n+                 byte[] dstarr, int dstoff, int dstscanbytes,\r\n+                 int w, int h);\r\n+\r\n+    \/**\r\n+     * Copies a rectangular region of data from the source buffer to the destination array.\r\n+     *\r\n+     * @param srcbuf the nio buffer containing the source data\r\n+     * @param srcoff the absolute location in the buffer of the first source pixel data\r\n+     * @param srcscanbits number of bits between rows of data in the source\r\n+     * @param dstarr the byte array containing the destination data\r\n+     * @param dstoff the index in the array of the first destination pixel data\r\n+     * @param dstscanbytes number of array indices between rows of data in the destination\r\n+     * @param w the number of pixels to process across before moving to the next row\r\n+     * @param h the number of rows of pixels to process\r\n+     *\/\r\n+    void convert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\r\n+                 byte[] dstarr, int dstoff, int dstscanbytes,\r\n+                 int w, int h);\r\n+\r\n+    \/**\r\n+     * Copies a rectangular region of data from the source array to the destination buffer.\r\n+     *\r\n+     * @param srcarr the byte array containing the source data\r\n+     * @param srcoff the index in the array of the first source pixel data\r\n+     * @param srcscanbits number of bits between rows of data in the source\r\n+     * @param dstbuf the nio buffer containing the destination data\r\n+     * @param dstoff the absolute location in the buffer of the first destination pixel data\r\n+     * @param dstscanbytes number of buffer elements between rows of data in the destination\r\n+     * @param w the number of pixels to process across before moving to the next row\r\n+     * @param h the number of rows of pixels to process\r\n+     *\/\r\n+    void convert(byte[] srcarr, int srcoff, int srcscanbits,\r\n+                 ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n+                 int w, int h);\r\n+}\r\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/IndexedToBytePixelConverter.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,3 @@\n-     * @param srcscanelems number of buffer elements between rows of data in the source\n+     * @param srcscanelems number of logical buffer elements between rows of data in the source;\n+     *                     note that the definition of a logical buffer element depends on the implementation,\n+     *                     usually this is a byte or an int, but for indexed converters it is a bit\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/PixelConverter.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.AlphaType;\n+import com.sun.javafx.image.BytePixelGetter;\n+import com.sun.javafx.image.BytePixelSetter;\n+import com.sun.javafx.image.IndexedToBytePixelConverter;\n+import com.sun.javafx.image.PixelUtils;\n+import java.nio.ByteBuffer;\n+\n+abstract class BaseIndexedToByteConverter implements IndexedToBytePixelConverter {\n+\n+    static abstract class IndexedGetter implements BytePixelGetter {\n+        final int[] preColors;\n+        final int[] nonPreColors;\n+        private final Boolean premultiplied;\n+\n+        IndexedGetter(int[] colors, Boolean premultiplied) {\n+            this.premultiplied = premultiplied;\n+\n+            if (premultiplied == null) {\n+                this.nonPreColors = colors;\n+                this.preColors = colors;\n+            } else if (premultiplied) {\n+                this.preColors = colors;\n+                this.nonPreColors = new int[colors.length];\n+\n+                for (int i = 0; i < colors.length; i++) {\n+                    nonPreColors[i] = PixelUtils.PretoNonPre(colors[i]);\n+                }\n+            } else {\n+                this.nonPreColors = colors;\n+                this.preColors = new int[colors.length];\n+\n+                for (int i = 0; i < colors.length; i++) {\n+                    preColors[i] = PixelUtils.NonPretoPre(colors[i]);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public AlphaType getAlphaType() {\n+            return premultiplied == null\n+                ? AlphaType.OPAQUE\n+                : premultiplied\n+                    ? AlphaType.PREMULTIPLIED\n+                    : AlphaType.NONPREMULTIPLIED;\n+        }\n+    }\n+\n+    protected final IndexedGetter getter;\n+    protected final BytePixelSetter setter;\n+    protected final int nSrcElems;\n+    protected final int nDstElems;\n+\n+    BaseIndexedToByteConverter(IndexedGetter getter, BytePixelSetter setter) {\n+        this.getter = getter;\n+        this.setter = setter;\n+        this.nSrcElems = getter.getNumElements();\n+        this.nDstElems = setter.getNumElements();\n+    }\n+\n+    @Override\n+    public final IndexedGetter getGetter() {\n+        return getter;\n+    }\n+\n+    @Override\n+    public final BytePixelSetter getSetter() {\n+        return setter;\n+    }\n+\n+    abstract void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\n+                            byte[] dstarr, int dstoff, int dstscanbytes,\n+                            int w, int h);\n+\n+    abstract void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\n+                            ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                            int w, int h);\n+\n+    @Override\n+    public final void convert(byte[] srcarr, int srcoff, int srcscanbits,\n+                              byte[] dstarr, int dstoff, int dstscanbytes,\n+                              int w, int h) {\n+        if (w <= 0 || h <= 0) return;\n+\n+        if (srcscanbits == w * nSrcElems && dstscanbytes == w * nDstElems) {\n+            w *= h;\n+            h = 1;\n+        }\n+\n+        doConvert(srcarr, srcoff, srcscanbits,\n+                  dstarr, dstoff, dstscanbytes,\n+                  w, h);\n+    }\n+\n+    @Override\n+    public final void convert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\n+                              ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                              int w, int h) {\n+        if (w <= 0 || h <= 0) return;\n+\n+        if (srcscanbits == w * nSrcElems && dstscanbytes == w * nDstElems) {\n+            w *= h;\n+            h = 1;\n+        }\n+\n+        if (srcbuf.hasArray() && dstbuf.hasArray()) {\n+            srcoff += srcbuf.arrayOffset();\n+            dstoff += dstbuf.arrayOffset();\n+            doConvert(srcbuf.array(), srcoff, srcscanbits,\n+                      dstbuf.array(), dstoff, dstscanbytes,\n+                      w, h);\n+        } else {\n+            doConvert(srcbuf, srcoff, srcscanbits,\n+                      dstbuf, dstoff, dstscanbytes,\n+                      w, h);\n+        }\n+    }\n+\n+    @Override\n+    public final void convert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\n+                              byte[] dstarr, int dstoff, int dstscanbytes,\n+                              int w, int h) {\n+        if (w <= 0 || h <= 0) return;\n+\n+        if (srcscanbits == w * nSrcElems && dstscanbytes == w * nDstElems) {\n+            w *= h;\n+            h = 1;\n+        }\n+\n+        if (srcbuf.hasArray()) {\n+            byte[] srcarr = srcbuf.array();\n+            srcoff += srcbuf.arrayOffset();\n+            doConvert(srcarr, srcoff, srcscanbits,\n+                      dstarr, dstoff, dstscanbytes,\n+                      w, h);\n+        } else {\n+            ByteBuffer dstbuf = ByteBuffer.wrap(dstarr);\n+            doConvert(srcbuf, srcoff, srcscanbits,\n+                      dstbuf, dstoff, dstscanbytes,\n+                      w, h);\n+        }\n+    }\n+\n+    @Override\n+    public final void convert(byte[] srcarr, int srcoff, int srcscanbits,\n+                              ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                              int w, int h) {\n+        if (w <= 0 || h <= 0) return;\n+\n+        if (srcscanbits == w * nSrcElems && dstscanbytes == w * nDstElems) {\n+            w *= h;\n+            h = 1;\n+        }\n+\n+        if (dstbuf.hasArray()) {\n+            byte[] dstarr = dstbuf.array();\n+            dstoff += dstbuf.arrayOffset();\n+            doConvert(srcarr, srcoff, srcscanbits,\n+                      dstarr, dstoff, dstscanbytes,\n+                      w, h);\n+        } else {\n+            ByteBuffer srcbuf = ByteBuffer.wrap(srcarr);\n+            doConvert(srcbuf, srcoff, srcscanbits,\n+                      dstbuf, dstoff, dstscanbytes,\n+                      w, h);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/BaseIndexedToByteConverter.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\r\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.  Oracle designates this\r\n+ * particular file as subject to the \"Classpath\" exception as provided\r\n+ * by Oracle in the LICENSE file that accompanied this code.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+package com.sun.javafx.image.impl;\r\n+\r\n+import com.sun.javafx.image.BytePixelSetter;\r\n+import com.sun.javafx.image.IndexedToBytePixelConverter;\r\n+import java.nio.ByteBuffer;\r\n+\r\n+public final class EightBitIndexed {\r\n+\r\n+    private EightBitIndexed() {}\r\n+\r\n+    public static Getter createGetter(int[] colors, Boolean premultiplied) {\r\n+        return new Getter(colors, premultiplied);\r\n+    }\r\n+\r\n+    public static IndexedToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\r\n+        return new ToByteRgbConverter(src, dst);\r\n+    }\r\n+\r\n+    public static IndexedToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\r\n+        return new ToByteBgraAnyConverter(src, dst);\r\n+    }\r\n+\r\n+    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\r\n+        Getter(int[] colors, Boolean premultiplied) {\r\n+            super(colors, premultiplied);\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getNumElements() {\r\n+            return 8;\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgb(byte[] arr, int offset) {\r\n+            return preColors[arr[offset]];\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgbPre(byte[] arr, int offset) {\r\n+            return nonPreColors[arr[offset]];\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgb(ByteBuffer buf, int offset) {\r\n+            return preColors[buf.get(offset)];\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgbPre(ByteBuffer buf, int offset) {\r\n+            return nonPreColors[buf.get(offset)];\r\n+        }\r\n+    }\r\n+\r\n+    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\r\n+        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\r\n+            super(getter, setter);\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\r\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = switch (setter.getAlphaType()) {\r\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n+                case PREMULTIPLIED -> getGetter().preColors;\r\n+            };\r\n+\r\n+            dstscanbytes -= w * 4;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[srcarr[srcoff + x]];\r\n+                    dstarr[dstoff++] = (byte) argb;\r\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n+                    dstarr[dstoff++] = (byte) (argb >> 24);\r\n+                }\r\n+\r\n+                srcoff += srcscanbits;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\r\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = switch (setter.getAlphaType()) {\r\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n+                case PREMULTIPLIED -> getGetter().preColors;\r\n+            };\r\n+\r\n+            dstscanbytes -= w * 4;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[srcbuf.get(srcoff + x)];\r\n+                    dstbuf.put(dstoff, (byte) argb);\r\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n+                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\r\n+                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\r\n+                    dstoff += 4;\r\n+                }\r\n+\r\n+                srcoff += srcscanbits;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\r\n+        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\r\n+            super(getter, setter);\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\r\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = getGetter().nonPreColors;\r\n+            dstscanbytes -= w * 3;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[srcarr[srcoff + x]];\r\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n+                    dstarr[dstoff++] = (byte) argb;\r\n+                }\r\n+\r\n+                srcoff += srcscanbits;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\r\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = getGetter().nonPreColors;\r\n+            dstscanbytes -= w * 3;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[srcbuf.get(srcoff + x)];\r\n+                    dstbuf.put(dstoff, (byte) (argb >> 16));\r\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n+                    dstbuf.put(dstoff + 2, (byte) argb);\r\n+                    dstoff += 3;\r\n+                }\r\n+\r\n+                srcoff += srcscanbits;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/EightBitIndexed.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\r\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.  Oracle designates this\r\n+ * particular file as subject to the \"Classpath\" exception as provided\r\n+ * by Oracle in the LICENSE file that accompanied this code.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+package com.sun.javafx.image.impl;\r\n+\r\n+import com.sun.javafx.image.BytePixelSetter;\r\n+import com.sun.javafx.image.IndexedToBytePixelConverter;\r\n+import java.nio.ByteBuffer;\r\n+\r\n+public final class FourBitIndexed {\r\n+\r\n+    private FourBitIndexed() {}\r\n+\r\n+    public static Getter createGetter(int[] colors, Boolean premultiplied) {\r\n+        return new Getter(colors, premultiplied);\r\n+    }\r\n+\r\n+    public static IndexedToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\r\n+        return new ToByteRgbConverter(src, dst);\r\n+    }\r\n+\r\n+    public static IndexedToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\r\n+        return new ToByteBgraAnyConverter(src, dst);\r\n+    }\r\n+\r\n+    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\r\n+        Getter(int[] colors, Boolean premultiplied) {\r\n+            super(colors, premultiplied);\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getNumElements() {\r\n+            return 4;\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgb(byte[] arr, int offset) {\r\n+            return preColors[(arr[offset \/ 2] >> (4 - offset % 2 * 4)) & 0xf];\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgbPre(byte[] arr, int offset) {\r\n+            return nonPreColors[(arr[offset \/ 2] >> (4 - offset % 2 * 4)) & 0xf];\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgb(ByteBuffer buf, int offset) {\r\n+            return preColors[(buf.get(offset \/ 2) >> (4 - offset % 2 * 4)) & 0xf];\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgbPre(ByteBuffer buf, int offset) {\r\n+            return nonPreColors[(buf.get(offset \/ 2) >> (4 - offset % 2 * 4)) & 0xf];\r\n+        }\r\n+    }\r\n+\r\n+    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\r\n+        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\r\n+            super(getter, setter);\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\r\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = switch (setter.getAlphaType()) {\r\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n+                case PREMULTIPLIED -> getGetter().preColors;\r\n+            };\r\n+\r\n+            dstscanbytes -= w * 4;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 2] >> (4 - x % 2 * 4)) & 0xf];\r\n+                    dstarr[dstoff++] = (byte) argb;\r\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n+                    dstarr[dstoff++] = (byte) (argb >> 24);\r\n+                }\r\n+\r\n+                srcoff += srcscanbits;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\r\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = switch (setter.getAlphaType()) {\r\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n+                case PREMULTIPLIED -> getGetter().preColors;\r\n+            };\r\n+\r\n+            dstscanbytes -= w * 4;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 2) >> (4 - x % 2 * 4)) & 0xf];\r\n+                    dstbuf.put(dstoff, (byte) argb);\r\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n+                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\r\n+                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\r\n+                    dstoff += 4;\r\n+                }\r\n+\r\n+                srcoff += srcscanbits;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\r\n+        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\r\n+            super(getter, setter);\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\r\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = getGetter().nonPreColors;\r\n+            dstscanbytes -= w * 3;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 2] >> (4 - x % 2 * 4)) & 0xf];\r\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n+                    dstarr[dstoff++] = (byte) argb;\r\n+                }\r\n+\r\n+                srcoff += srcscanbits;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\r\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = getGetter().nonPreColors;\r\n+            dstscanbytes -= w * 3;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 2) >> (4 - x % 2 * 4)) & 0xf];\r\n+                    dstbuf.put(dstoff, (byte) (argb >> 16));\r\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n+                    dstbuf.put(dstoff + 2, (byte) argb);\r\n+                    dstoff += 3;\r\n+                }\r\n+\r\n+                srcoff += srcscanbits;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/FourBitIndexed.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\r\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.  Oracle designates this\r\n+ * particular file as subject to the \"Classpath\" exception as provided\r\n+ * by Oracle in the LICENSE file that accompanied this code.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+package com.sun.javafx.image.impl;\r\n+\r\n+import com.sun.javafx.image.BytePixelSetter;\r\n+import com.sun.javafx.image.IndexedToBytePixelConverter;\r\n+import java.nio.ByteBuffer;\r\n+\r\n+public final class OneBitIndexed {\r\n+\r\n+    private OneBitIndexed() {}\r\n+\r\n+    public static Getter createGetter(int[] colors, Boolean premultiplied) {\r\n+        return new Getter(colors, premultiplied);\r\n+    }\r\n+\r\n+    public static IndexedToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\r\n+        return new ToByteRgbConverter(src, dst);\r\n+    }\r\n+\r\n+    public static IndexedToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\r\n+        return new ToByteBgraAnyConverter(src, dst);\r\n+    }\r\n+\r\n+    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\r\n+        Getter(int[] colors, Boolean premultiplied) {\r\n+            super(colors, premultiplied);\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getNumElements() {\r\n+            return 1;\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgb(byte[] arr, int offset) {\r\n+            return preColors[(arr[offset \/ 8] >> (7 - offset % 8)) & 1];\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgbPre(byte[] arr, int offset) {\r\n+            return nonPreColors[(arr[offset \/ 8] >> (7 - offset % 8)) & 1];\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgb(ByteBuffer buf, int offset) {\r\n+            return preColors[(buf.get(offset \/ 8) >> (7 - offset % 8)) & 1];\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgbPre(ByteBuffer buf, int offset) {\r\n+            return nonPreColors[(buf.get(offset \/ 8) >> (7 - offset % 8)) & 1];\r\n+        }\r\n+    }\r\n+\r\n+    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\r\n+        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\r\n+            super(getter, setter);\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\r\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = switch (setter.getAlphaType()) {\r\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n+                case PREMULTIPLIED -> getGetter().preColors;\r\n+            };\r\n+\r\n+            dstscanbytes -= w * 4;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 8] >> (7 - x % 8)) & 1];\r\n+                    dstarr[dstoff++] = (byte) argb;\r\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n+                    dstarr[dstoff++] = (byte) (argb >> 24);\r\n+                }\r\n+                srcoff += srcscanbits;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\r\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = switch (setter.getAlphaType()) {\r\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n+                case PREMULTIPLIED -> getGetter().preColors;\r\n+            };\r\n+\r\n+            dstscanbytes -= w * 4;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 8) >> (7 - x % 8)) & 1];\r\n+                    dstbuf.put(dstoff, (byte) argb);\r\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n+                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\r\n+                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\r\n+                    dstoff += 4;\r\n+                }\r\n+                srcoff += srcscanbits;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\r\n+        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\r\n+            super(getter, setter);\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\r\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = getGetter().nonPreColors;\r\n+            dstscanbytes -= w * 3;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 8] >> (7 - x % 8)) & 1];\r\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n+                    dstarr[dstoff++] = (byte) argb;\r\n+                }\r\n+                srcoff += srcscanbits;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbits,\r\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = getGetter().nonPreColors;\r\n+            dstscanbytes -= w * 3;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 8) >> (7 - x % 8)) & 1];\r\n+                    dstbuf.put(dstoff, (byte) (argb >> 16));\r\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n+                    dstbuf.put(dstoff + 2, (byte) argb);\r\n+                    dstoff += 3;\r\n+                }\r\n+                srcoff += srcscanbits;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/OneBitIndexed.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\r\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.  Oracle designates this\r\n+ * particular file as subject to the \"Classpath\" exception as provided\r\n+ * by Oracle in the LICENSE file that accompanied this code.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+package com.sun.javafx.image.impl;\r\n+\r\n+import com.sun.javafx.image.BytePixelSetter;\r\n+import com.sun.javafx.image.IndexedToBytePixelConverter;\r\n+import java.nio.ByteBuffer;\r\n+\r\n+public final class TwoBitIndexed {\r\n+\r\n+    private TwoBitIndexed() {}\r\n+\r\n+    public static Getter createGetter(int[] colors, Boolean premultiplied) {\r\n+        return new Getter(colors, premultiplied);\r\n+    }\r\n+\r\n+    public static IndexedToBytePixelConverter createToByteRgb(Getter src, BytePixelSetter dst) {\r\n+        return new ToByteRgbConverter(src, dst);\r\n+    }\r\n+\r\n+    public static IndexedToBytePixelConverter createToByteBgraAny(Getter src, BytePixelSetter dst) {\r\n+        return new ToByteBgraAnyConverter(src, dst);\r\n+    }\r\n+\r\n+    public static class Getter extends BaseIndexedToByteConverter.IndexedGetter {\r\n+        Getter(int[] colors, Boolean premultiplied) {\r\n+            super(colors, premultiplied);\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getNumElements() {\r\n+            return 2;\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgb(byte[] arr, int offset) {\r\n+            return preColors[(arr[offset \/ 4] >> (6 - offset % 4 * 2)) & 3];\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgbPre(byte[] arr, int offset) {\r\n+            return nonPreColors[(arr[offset \/ 4] >> (6 - offset % 4 * 2)) & 3];\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgb(ByteBuffer buf, int offset) {\r\n+            return preColors[(buf.get(offset \/ 4) >> (6 - offset % 4 * 2)) & 3];\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getArgbPre(ByteBuffer buf, int offset) {\r\n+            return nonPreColors[(buf.get(offset \/ 4) >> (6 - offset % 4 * 2)) & 3];\r\n+        }\r\n+    }\r\n+\r\n+    public static class ToByteBgraAnyConverter extends BaseIndexedToByteConverter {\r\n+        public ToByteBgraAnyConverter(Getter getter, BytePixelSetter setter) {\r\n+            super(getter, setter);\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbits,\r\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = switch (setter.getAlphaType()) {\r\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n+                case PREMULTIPLIED -> getGetter().preColors;\r\n+            };\r\n+\r\n+            dstscanbytes -= w * 4;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 4] >> (6 - x % 4 * 2)) & 3];\r\n+                    dstarr[dstoff++] = (byte) argb;\r\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n+                    dstarr[dstoff++] = (byte) (argb >> 24);\r\n+                }\r\n+                srcoff += srcscanbits;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\r\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = switch (setter.getAlphaType()) {\r\n+                case OPAQUE, NONPREMULTIPLIED -> getGetter().nonPreColors;\r\n+                case PREMULTIPLIED -> getGetter().preColors;\r\n+            };\r\n+\r\n+            dstscanbytes -= w * 4;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 4) >> (6 - x % 4 * 2)) & 3];\r\n+                    dstbuf.put(dstoff, (byte) argb);\r\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n+                    dstbuf.put(dstoff + 2, (byte) (argb >> 16));\r\n+                    dstbuf.put(dstoff + 3, (byte) (argb >> 24));\r\n+                    dstoff += 4;\r\n+                }\r\n+                srcoff += srcscanbytes;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    public static class ToByteRgbConverter extends BaseIndexedToByteConverter {\r\n+        public ToByteRgbConverter(Getter getter, BytePixelSetter setter) {\r\n+            super(getter, setter);\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\r\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = getGetter().nonPreColors;\r\n+            dstscanbytes -= w * 3;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[(srcarr[srcoff \/ 8 + x \/ 4] >> (6 - x % 4 * 2)) & 3];\r\n+                    dstarr[dstoff++] = (byte) (argb >> 16);\r\n+                    dstarr[dstoff++] = (byte) (argb >> 8);\r\n+                    dstarr[dstoff++] = (byte) argb;\r\n+                }\r\n+                srcoff += srcscanbytes;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+\r\n+        @Override\r\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\r\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\r\n+                       int w, int h) {\r\n+            int[] colors = getGetter().nonPreColors;\r\n+            dstscanbytes -= w * 3;\r\n+\r\n+            while (--h >= 0) {\r\n+                for (int x = 0; x < w; x++) {\r\n+                    int argb = colors[(srcbuf.get(srcoff \/ 8 + x \/ 4) >> (6 - x % 4 * 2)) & 3];\r\n+                    dstbuf.put(dstoff, (byte) (argb >> 16));\r\n+                    dstbuf.put(dstoff + 1, (byte) (argb >> 8));\r\n+                    dstbuf.put(dstoff + 2, (byte) argb);\r\n+                    dstoff += 3;\r\n+                }\r\n+                srcoff += srcscanbytes;\r\n+                dstoff += dstscanbytes;\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/TwoBitIndexed.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -28,0 +28,6 @@\n+import com.sun.javafx.image.IndexedToBytePixelConverter;\n+import com.sun.javafx.image.impl.ByteIndexed;\n+import com.sun.javafx.image.impl.EightBitIndexed;\n+import com.sun.javafx.image.impl.FourBitIndexed;\n+import com.sun.javafx.image.impl.OneBitIndexed;\n+import com.sun.javafx.image.impl.TwoBitIndexed;\n@@ -302,1 +308,49 @@\n-            case PALETTE, PALETTE_ALPHA, PALETTE_ALPHA_PRE, PALETTE_TRANS ->\n+            case PALETTE, PALETTE_ALPHA, PALETTE_ALPHA_PRE -> {\n+                Boolean premultiplied = switch (type) {\n+                    case PALETTE_ALPHA -> Boolean.FALSE;\n+                    case PALETTE_ALPHA_PRE -> Boolean.TRUE;\n+                    default -> null; \/\/ PALETTE\n+                };\n+\n+                var converter = switch (frame.getPaletteIndexBits()) {\n+                    case 1 -> {\n+                        var getter = OneBitIndexed.createGetter(frame.getPalette(), premultiplied);\n+                        yield premultiplied == null\n+                            ? OneBitIndexed.createToByteRgb(getter, ByteRgb.setter)\n+                            : OneBitIndexed.createToByteBgraAny(getter, ByteBgraPre.setter);\n+                    }\n+\n+                    case 2 -> {\n+                        var getter = TwoBitIndexed.createGetter(frame.getPalette(), premultiplied);\n+                        yield premultiplied == null\n+                            ? TwoBitIndexed.createToByteRgb(getter, ByteRgb.setter)\n+                            : TwoBitIndexed.createToByteBgraAny(getter, ByteBgraPre.setter);\n+                    }\n+\n+                    case 4 -> {\n+                        var getter = FourBitIndexed.createGetter(frame.getPalette(), premultiplied);\n+                        yield premultiplied == null\n+                            ? FourBitIndexed.createToByteRgb(getter, ByteRgb.setter)\n+                            : FourBitIndexed.createToByteBgraAny(getter, ByteBgraPre.setter);\n+                    }\n+\n+                    case 8 -> {\n+                        var getter = EightBitIndexed.createGetter(frame.getPalette(), premultiplied);\n+                        yield premultiplied == null\n+                            ? EightBitIndexed.createToByteRgb(getter, ByteRgb.setter)\n+                            : EightBitIndexed.createToByteBgraAny(getter, ByteBgraPre.setter);\n+                    }\n+\n+                    default -> throw new RuntimeException(\"Unsupported bits per pixel: \" + frame.getPaletteIndexBits());\n+                };\n+\n+                int dstPixelSize = premultiplied == null ? 3 : 4;\n+                byte[] buffer = new byte[w * h * dstPixelSize];\n+                converter.convert((ByteBuffer)frame.getImageData(), 0, stride, buffer, 0, w * dstPixelSize, w, h);\n+\n+                yield premultiplied == null\n+                    ? fromByteRgbData(buffer, w, h)\n+                    : fromByteBgraPreData(buffer, w, h, ps);\n+            }\n+\n+            case PALETTE_TRANS ->\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/Image.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-            0, 0, 0, null, null);\n+            0, 0, 0, null);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/iio\/ImageStorageTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import java.util.Arrays;\n+import java.util.Objects;\n@@ -48,2 +50,6 @@\n-            new byte[] { 1, 2, 3, 4 },\n-            new byte[] { 1, 2, 3, 4 }),\n+            byteArray(\n+                1, 2, 3, 4\n+            ),\n+            byteArray(\n+                1, 2, 3, 4\n+            )),\n@@ -52,1 +58,1 @@\n-            new byte[] {\n+            byteArray(\n@@ -55,2 +61,2 @@\n-            },\n-            new byte[] {\n+            ),\n+            byteArray(\n@@ -59,1 +65,1 @@\n-            }),\n+            )),\n@@ -62,1 +68,1 @@\n-            new byte[] {\n+            byteArray(\n@@ -65,2 +71,2 @@\n-            },\n-            new byte[] {\n+            ),\n+            byteArray(\n@@ -69,1 +75,1 @@\n-            }),\n+            )),\n@@ -72,1 +78,1 @@\n-            new byte[] {\n+            byteArray(\n@@ -75,2 +81,2 @@\n-            },\n-            new byte[] {\n+            ),\n+            byteArray(\n@@ -79,1 +85,1 @@\n-            }),\n+            )),\n@@ -82,1 +88,1 @@\n-            new byte[] {\n+            byteArray(\n@@ -85,2 +91,2 @@\n-            },\n-            new byte[] {\n+            ),\n+            byteArray(\n@@ -89,1 +95,1 @@\n-            }),\n+            )),\n@@ -92,1 +98,1 @@\n-            new byte[] {\n+            byteArray(\n@@ -94,3 +100,3 @@\n-                (byte)255, 127, 0, 127, 50, 60, 70, (byte)255\n-            },\n-            new byte[] {\n+                255, 127, 0, 127, 50, 60, 70, 255\n+            ),\n+            byteArray(\n@@ -98,2 +104,2 @@\n-                0, 63, 127, 127, 70, 60, 50, (byte)255\n-            }),\n+                0, 63, 127, 127, 70, 60, 50, 255\n+            )),\n@@ -102,1 +108,1 @@\n-            new byte[] {\n+            byteArray(\n@@ -104,3 +110,3 @@\n-                (byte)255, 127, 0, 127, 50, 40, 30, 0\n-            },\n-            new byte[] {\n+                255, 127, 0, 127, 50, 40, 30, 0\n+            ),\n+            byteArray(\n@@ -108,2 +114,2 @@\n-                0, 127, (byte)255, 127, 30, 40, 50, 0\n-            }),\n+                0, 127, 255, 127, 30, 40, 50, 0\n+            )),\n@@ -112,1 +118,1 @@\n-            new byte[] {\n+            byteArray(\n@@ -114,3 +120,3 @@\n-                (byte)255, 127, 0, 127, 50, 50, 50, 0\n-            },\n-            new byte[] {\n+                255, 127, 0, 127, 50, 50, 50, 0\n+            ),\n+            byteArray(\n@@ -119,1 +125,1 @@\n-            }),\n+            )),\n@@ -122,1 +128,1 @@\n-            new byte[] {\n+            byteArray(\n@@ -124,3 +130,3 @@\n-                (byte)255, 127, 0, 127, 50, 50, 50, 0\n-            },\n-            new byte[] {\n+                255, 127, 0, 127, 50, 50, 50, 0\n+            ),\n+            byteArray(\n@@ -128,2 +134,2 @@\n-                (byte)255, 127, 0, 127, 50, 50, 50, 0\n-            }),\n+                255, 127, 0, 127, 50, 50, 50, 0\n+            )),\n@@ -132,1 +138,1 @@\n-            new byte[] {\n+            byteArray(\n@@ -134,3 +140,3 @@\n-                127, (byte)255, 127, 0, 0, 50, 50, 50\n-            },\n-            new byte[] {\n+                127, 255, 127, 0, 0, 50, 50, 50\n+            ),\n+            byteArray(\n@@ -139,1 +145,1 @@\n-            }),\n+            )),\n@@ -142,1 +148,1 @@\n-            new byte[] {\n+            byteArray(\n@@ -144,3 +150,3 @@\n-                127, (byte)255, 127, 0, 0, 50, 50, 50\n-            },\n-            new byte[] {\n+                127, 255, 127, 0, 0, 50, 50, 50\n+            ),\n+            byteArray(\n@@ -148,2 +154,2 @@\n-                (byte)255, 127, 0, 127, 50, 50, 50, 0\n-            }),\n+                255, 127, 0, 127, 50, 50, 50, 0\n+            )),\n@@ -189,1 +195,157 @@\n-            });\n+            }),\n+\n+        PALETTE_ONE_BIT_OPAQUE(ImageType.PALETTE, PixelFormat.BYTE_RGB, 2, 1,\n+            new int[] {\n+                rgb(255, 0, 0), rgb(0, 127, 0)\n+            },\n+            encodeBits(\n+                0, 1,\n+                1, 0\n+            ),\n+            byteArray(\n+                255, 0, 0, 0, 127, 0,\n+                0, 127, 0, 255, 0, 0\n+            )),\n+\n+        PALETTE_ONE_BIT_ALPHA(ImageType.PALETTE_ALPHA, PixelFormat.BYTE_BGRA_PRE, 2, 1,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0)\n+            },\n+            encodeBits(\n+                0, 1,\n+                1, 0\n+            ),\n+            byteArray(\n+                0, 0, 127, 127, 0, 127, 0, 255,\n+                0, 127, 0, 255, 0, 0, 127, 127\n+            )),\n+\n+        PALETTE_ONE_BIT_ALPHA_PRE(ImageType.PALETTE_ALPHA_PRE, PixelFormat.BYTE_BGRA_PRE, 2, 1,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0)\n+            },\n+            encodeBits(\n+                0, 1,\n+                1, 0\n+            ),\n+            byteArray(\n+                0, 0, 255, 127, 0, 127, 0, 255,\n+                0, 127, 0, 255, 0, 0, 255, 127\n+            )),\n+\n+        PALETTE_TWO_BIT_OPAQUE(ImageType.PALETTE, PixelFormat.BYTE_RGB, 4, 2,\n+            new int[] {\n+                rgb(255, 0, 0), rgb(0, 127, 0), rgb(10, 20, 30), rgb(50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 1,\n+                1, 0, 1, 1\n+            ),\n+            byteArray(\n+                255, 0, 0, 0, 127, 0,\n+                10, 20, 30, 50, 60, 70\n+            )),\n+\n+        PALETTE_TWO_BIT_ALPHA(ImageType.PALETTE_ALPHA, PixelFormat.BYTE_BGRA_PRE, 4, 2,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0), argb(0, 10, 20, 30), argb(255, 50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 1,\n+                1, 0, 1, 1\n+            ),\n+            byteArray(\n+                0, 0, 127, 127, 0, 127, 0, 255,\n+                0, 0, 0, 0, 70, 60, 50, 255\n+            )),\n+\n+        PALETTE_TWO_BIT_ALPHA_PRE(ImageType.PALETTE_ALPHA_PRE, PixelFormat.BYTE_BGRA_PRE, 4, 2,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0), argb(0, 10, 20, 30), argb(255, 50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 1,\n+                1, 0, 1, 1\n+            ),\n+            byteArray(\n+                0, 0, 255, 127, 0, 127, 0, 255,\n+                30, 20, 10, 0, 70, 60, 50, 255\n+            )),\n+\n+        PALETTE_FOUR_BIT_OPAQUE(ImageType.PALETTE, PixelFormat.BYTE_RGB, 8, 4,\n+            new int[] {\n+                rgb(255, 0, 0), rgb(0, 127, 0), rgb(10, 20, 30), rgb(50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 0, 0, 0, 0, 1,\n+                0, 0, 1, 0, 0, 0, 1, 1\n+            ),\n+            byteArray(\n+                255, 0, 0, 0, 127, 0,\n+                10, 20, 30, 50, 60, 70\n+            )),\n+\n+        PALETTE_FOUR_BIT_ALPHA(ImageType.PALETTE_ALPHA, PixelFormat.BYTE_BGRA_PRE, 8, 4,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0), argb(0, 10, 20, 30), argb(255, 50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 0, 0, 0, 0, 1,\n+                0, 0, 1, 0, 0, 0, 1, 1\n+            ),\n+            byteArray(\n+                0, 0, 127, 127, 0, 127, 0, 255,\n+                0, 0, 0, 0, 70, 60, 50, 255\n+            )),\n+\n+        PALETTE_FOUR_BIT_ALPHA_PRE(ImageType.PALETTE_ALPHA_PRE, PixelFormat.BYTE_BGRA_PRE, 8, 4,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0), argb(0, 10, 20, 30), argb(255, 50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 0, 0, 0, 0, 1,\n+                0, 0, 1, 0, 0, 0, 1, 1\n+            ),\n+            byteArray(\n+                0, 0, 255, 127, 0, 127, 0, 255,\n+                30, 20, 10, 0, 70, 60, 50, 255\n+            )),\n+\n+        PALETTE_EIGHT_BIT_OPAQUE(ImageType.PALETTE, PixelFormat.BYTE_RGB, 16, 8,\n+            new int[] {\n+                rgb(255, 0, 0), rgb(0, 127, 0), rgb(10, 20, 30), rgb(50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n+                0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1\n+            ),\n+            byteArray(\n+                255, 0, 0, 0, 127, 0,\n+                10, 20, 30, 50, 60, 70\n+            )),\n+\n+        PALETTE_EIGHT_BIT_ALPHA(ImageType.PALETTE_ALPHA, PixelFormat.BYTE_BGRA_PRE, 16, 8,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0), argb(0, 10, 20, 30), argb(255, 50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n+                0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1\n+            ),\n+            byteArray(\n+                0, 0, 127, 127, 0, 127, 0, 255,\n+                0, 0, 0, 0, 70, 60, 50, 255\n+            )),\n+\n+        PALETTE_EIGHT_BIT_ALPHA_PRE(ImageType.PALETTE_ALPHA_PRE, PixelFormat.BYTE_BGRA_PRE, 16, 8,\n+            new int[] {\n+                argb(127, 255, 0, 0), argb(255, 0, 127, 0), argb(0, 10, 20, 30), argb(255, 50, 60, 70)\n+            },\n+            encodeBits(\n+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n+                0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1\n+            ),\n+            byteArray(\n+                0, 0, 255, 127, 0, 127, 0, 255,\n+                30, 20, 10, 0, 70, 60, 50, 255\n+            ));\n@@ -199,0 +361,26 @@\n+        static byte[] encodeBits(int... bits) {\n+            var result = new byte[bits.length \/ 8 + 1];\n+            for (int i = 0; i < bits.length; ++i) {\n+                result[i \/ 8] |= (byte)(bits[i] << (7 - (i % 8)));\n+            }\n+\n+            return result;\n+        }\n+\n+        \/\/ Allows us to create byte arrays with unsigned literals without casting to (byte)\n+        static byte[] byteArray(int... bytes) {\n+            var result = new byte[bytes.length];\n+            for (int i = 0; i < bytes.length; ++i) {\n+                result[i] = (byte)Objects.checkIndex(bytes[i], 256);\n+            }\n+\n+            return result;\n+        }\n+\n+        SupportedConversions(ImageType sourceType, PixelFormat targetType, int stride,\n+                             int paletteIndexBits, int[] palette,\n+                             byte[] sourceData, byte[] targetData) {\n+            this(sourceType, targetType, stride, palette, paletteIndexBits,\n+                 ByteBuffer.wrap(sourceData), ByteBuffer.wrap(targetData));\n+        }\n+\n@@ -201,1 +389,2 @@\n-            this(sourceType, targetType, stride, ByteBuffer.wrap(sourceData), ByteBuffer.wrap(targetData));\n+            this(sourceType, targetType, stride, null, -1,\n+                 ByteBuffer.wrap(sourceData), ByteBuffer.wrap(targetData));\n@@ -206,1 +395,2 @@\n-            this(sourceType, targetType, stride, IntBuffer.wrap(sourceData), IntBuffer.wrap(targetData));\n+            this(sourceType, targetType, stride, null, -1,\n+                 IntBuffer.wrap(sourceData), IntBuffer.wrap(targetData));\n@@ -210,0 +400,1 @@\n+                             int[] palette, int paletteIndexBits,\n@@ -215,0 +406,2 @@\n+            this.palette = palette;\n+            this.paletteIndexBits = paletteIndexBits;\n@@ -222,0 +415,2 @@\n+        final int paletteIndexBits;\n+        final int[] palette;\n@@ -233,1 +428,2 @@\n-            conversion.sourceType, conversion.sourceData, 2, 2, conversion.stride, null,\n+            conversion.sourceType, conversion.sourceData, 2, 2, conversion.stride,\n+            conversion.palette, conversion.paletteIndexBits, 1,\n@@ -241,1 +437,12 @@\n-        assertEquals(conversion.targetData, image.getPixelBuffer());\n+        assertEquals(conversion.targetData, image.getPixelBuffer(), () ->\n+            \"Expected: %s\\nActual: %s\".formatted(\n+                formatArray(conversion.targetData.array()),\n+                formatArray(image.getPixelBuffer().array())));\n+    }\n+\n+    private static String formatArray(Object array) {\n+        return switch (array) {\n+            case byte[] byteArray -> Arrays.toString(byteArray);\n+            case int[] intArray -> Arrays.toString(intArray);\n+            default -> throw new AssertionError();\n+        };\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/prism\/ImageTest.java","additions":264,"deletions":57,"binary":false,"changes":321,"status":"modified"}]}