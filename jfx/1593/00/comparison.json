{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.nio.ByteBuffer;\n@@ -35,6 +34,8 @@\n-public class ImageFrame {\n-    private ImageType imageType;\n-    private ByteBuffer imageData;\n-    private int width;\n-    private int height;\n-    private int stride;\n+public final class ImageFrame {\n+    private final ImageType imageType;\n+    private final Buffer imageData;\n+    private final int width;\n+    private final int height;\n+    private final int stride;\n+    private final byte[][] palette;\n+    private final ImageMetadata metadata;\n@@ -42,2 +43,0 @@\n-    private byte[][] palette;\n-    private ImageMetadata metadata;\n@@ -54,1 +53,1 @@\n-     * horizontal position in the next row.\n+     * horizontal position in the next row, in bytes\n@@ -59,1 +58,1 @@\n-    public ImageFrame(ImageType imageType, ByteBuffer imageData,\n+    public ImageFrame(ImageType imageType, Buffer imageData,\n@@ -77,1 +76,1 @@\n-     * horizontal position in the next row.\n+     * horizontal position in the next row, in bytes\n@@ -84,1 +83,1 @@\n-    public ImageFrame(ImageType imageType, ByteBuffer imageData,\n+    public ImageFrame(ImageType imageType, Buffer imageData,\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/ImageFrame.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,2 @@\n+     * @param screenPixelScale screen pixel scale (used for variable-density images)\n+     * @param imagePixelScale image pixel scale (used for fixed-density images)\n@@ -77,2 +79,3 @@\n-    public ImageFrame load(int imageIndex, int width, int height,\n-            boolean preserveAspectRatio, boolean smooth) throws IOException;\n+    ImageFrame load(int imageIndex, double width, double height,\n+            boolean preserveAspectRatio, boolean smooth,\n+            float screenPixelScale, float imagePixelScale) throws IOException;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/ImageLoader.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.io.BufferedInputStream;\n@@ -65,1 +66,1 @@\n-         * An image with with two 8-bit valued channels, one of gray levels,\n+         * An image with two 8-bit valued channels, one of gray levels,\n@@ -70,1 +71,1 @@\n-         * An image with with two 8-bit valued channels, one of gray levels,\n+         * An image with two 8-bit valued channels, one of gray levels,\n@@ -75,1 +76,1 @@\n-         * An image with with one 8-bit channel of indexes into a 24-bit\n+         * An image with one 8-bit channel of indexes into a 24-bit\n@@ -80,1 +81,1 @@\n-         * An image with with one 8-bit channel of indexes into a 32-bit\n+         * An image with one 8-bit channel of indexes into a 32-bit\n@@ -86,1 +87,1 @@\n-         * An image with with one 8-bit channel of indexes into a 32-bit\n+         * An image with one 8-bit channel of indexes into a 32-bit\n@@ -92,1 +93,1 @@\n-         * An image with with one 8-bit channel of indexes into a 24-bit\n+         * An image with one 8-bit channel of indexes into a 24-bit\n@@ -99,1 +100,1 @@\n-         * An image with with three 8-bit valued channels of red, green, and\n+         * An image with three 8-bit valued channels of red, green, and\n@@ -104,1 +105,6 @@\n-         * An image with with four 8-bit valued channels of red, green, blue,\n+         * An image with three 8-bit valued channels of red, green, and\n+         * blue, respectively, ordered as BGRBGRBGR...\n+         *\/\n+        BGR,\n+        \/**\n+         * An image with four 8-bit valued channels of red, green, blue,\n@@ -110,1 +116,1 @@\n-         * An image with with four 8-bit valued channels of red, green, blue,\n+         * An image with four 8-bit valued channels of red, green, blue,\n@@ -114,1 +120,47 @@\n-        RGBA_PRE\n+        RGBA_PRE,\n+        \/**\n+         * An image with four 8-bit valued channels of red, green, blue,\n+         * and non-premultiplied opacity, respectively, ordered as\n+         * BGRABGRABGRA...\n+         *\/\n+        BGRA,\n+        \/**\n+         * An image with four 8-bit valued channels of red, green, blue,\n+         * and premultiplied opacity, respectively, ordered as\n+         * BGRABGRABGRA...\n+         *\/\n+        BGRA_PRE,\n+        \/**\n+         * An image with four 8-bit valued channels of red, green, blue,\n+         * and non-premultiplied opacity, respectively, ordered as\n+         * ABGRABGRABGR...\n+         *\/\n+        ABGR,\n+        \/**\n+         * An image with four 8-bit valued channels of red, green, blue,\n+         * and premultiplied opacity, respectively, ordered as\n+         * ABGRABGRABGR...\n+         *\/\n+        ABGR_PRE,\n+        \/**\n+         * An image with three 8-bit valued channels of red, green, and blue,\n+         * packed into a 32-bit integer, ordered as XRGBXRGBXRGB...\n+         *\/\n+        INT_RGB,\n+        \/**\n+         * An image with three 8-bit valued channels of red, green, and blue,\n+         * packed into a 32-bit integer, ordered as XBGRXBGRXBGR...\n+         *\/\n+        INT_BGR,\n+        \/**\n+         * An image with four 8-bit valued channels of red, green, blue, and\n+         * non-premultiplied opacity, packed into a 32-bit integer, ordered as\n+         * ARGBARGBARGB...\n+         *\/\n+        INT_ARGB,\n+        \/**\n+         * An image with four 8-bit valued channels of red, green, blue, and\n+         * premultiplied opacity, packed into a 32-bit integer, ordered as\n+         * ARGBARGBARGB...\n+         *\/\n+        INT_ARGB_PRE\n@@ -129,0 +181,1 @@\n+    private final ImageLoaderFactory xImageLoaderFactory = tryGetXImageLoaderFactory();\n@@ -141,0 +194,9 @@\n+    private static ImageLoaderFactory tryGetXImageLoaderFactory() {\n+        try {\n+            Class<?> factoryClass = Class.forName(\"com.sun.javafx.iio.javax.XImageLoaderFactory\");\n+            return (ImageLoaderFactory)factoryClass.getMethod(\"getInstance\").invoke(null);\n+        } catch (ReflectiveOperationException e) {\n+            return null;\n+        }\n+    }\n+\n@@ -284,7 +346,2 @@\n-            if (isIOS) {\n-                \/\/ no extension\/signature recognition done here,\n-                \/\/ we always want the iOS native loader\n-                loader = IosImageLoaderFactory.getInstance().createImageLoader(input);\n-            } else {\n-                loader = getLoaderBySignature(input, listener);\n-            }\n+            loader = findImageLoader(input, listener);\n+\n@@ -292,1 +349,1 @@\n-                images = loadAll(loader, width, height, preserveAspectRatio, pixelScale, smooth);\n+                images = loadAll(loader, width, height, preserveAspectRatio, pixelScale, 1, smooth);\n@@ -335,4 +392,20 @@\n-                    if (factory == null) {\n-                        throw new IllegalArgumentException(\n-                            \"Unsupported MIME subtype: image\/\" + dataUri.getMimeSubtype());\n-                    }\n+                    if (factory != null) {\n+                        \/\/ We also inspect the image file signature to confirm that it matches the MIME type.\n+                        theStream = new ByteArrayInputStream(dataUri.getData());\n+                        ImageLoader loaderBySignature = getLoaderBySignature(theStream, listener);\n+\n+                        if (loaderBySignature != null) {\n+                            \/\/ If the MIME type doesn't agree with the file signature, log a warning and\n+                            \/\/ continue with the image loader that matches the file signature.\n+                            boolean imageTypeMismatch = !factory.getFormatDescription().getFormatName().equals(\n+                                loaderBySignature.getFormatDescription().getFormatName());\n+\n+                            if (imageTypeMismatch) {\n+                                var logger = Logging.getJavaFXLogger();\n+                                if (logger.isLoggable(PlatformLogger.Level.WARNING)) {\n+                                    logger.warning(String.format(\n+                                        \"Image format '%s' does not match MIME type '%s\/%s' in URI '%s'\",\n+                                        loaderBySignature.getFormatDescription().getFormatName(),\n+                                        dataUri.getMimeType(), dataUri.getMimeSubtype(), dataUri));\n+                                }\n+                            }\n@@ -340,3 +413,21 @@\n-                    \/\/ We also inspect the image file signature to confirm that it matches the MIME type.\n-                    theStream = new ByteArrayInputStream(dataUri.getData());\n-                    ImageLoader loaderBySignature = getLoaderBySignature(theStream, listener);\n+                            loader = loaderBySignature;\n+                        } else {\n+                            \/\/ We're here because the image format doesn't have a detectable signature.\n+                            \/\/ In this case, we need to close the input stream (because we already consumed\n+                            \/\/ parts of it to detect a potential file signature) and create a new input\n+                            \/\/ stream for the image loader that matches the MIME type.\n+                            theStream.close();\n+                            theStream = new ByteArrayInputStream(dataUri.getData());\n+                            loader = factory.createImageLoader(theStream);\n+                        }\n+                    } else {\n+                        \/\/ If we don't have a built-in loader factory we try to find an ImageIO loader\n+                        \/\/ that can load the content of the data URI.\n+                        ImageLoader imageLoader = xImageLoaderFactory != null\n+                            ? xImageLoaderFactory.createImageLoader(new ByteArrayInputStream(dataUri.getData()))\n+                            : null;\n+\n+                        if (imageLoader == null) {\n+                            throw new IllegalArgumentException(\n+                                \"Unsupported MIME subtype: image\/\" + dataUri.getMimeSubtype());\n+                        }\n@@ -344,5 +435,4 @@\n-                    if (loaderBySignature != null) {\n-                        \/\/ If the MIME type doesn't agree with the file signature, log a warning and\n-                        \/\/ continue with the image loader that matches the file signature.\n-                        boolean imageTypeMismatch = !factory.getFormatDescription().getFormatName().equals(\n-                            loaderBySignature.getFormatDescription().getFormatName());\n+                        \/\/ If the specified MIME type doesn't agree with any of the supported MIME types of\n+                        \/\/ the XImageLoader, we log a warning but continue to load the image.\n+                        boolean imageTypeMismatch = imageLoader.getFormatDescription().getMIMESubtypes().stream()\n+                                .noneMatch(dataUri.getMimeSubtype()::equals);\n@@ -355,1 +445,1 @@\n-                                    loaderBySignature.getFormatDescription().getFormatName(),\n+                                    imageLoader.getFormatDescription().getFormatName(),\n@@ -360,9 +450,1 @@\n-                        loader = loaderBySignature;\n-                    } else {\n-                        \/\/ We're here because the image format doesn't have a detectable signature.\n-                        \/\/ In this case, we need to close the input stream (because we already consumed\n-                        \/\/ parts of it to detect a potential file signature) and create a new input\n-                        \/\/ stream for the image loader that matches the MIME type.\n-                        theStream.close();\n-                        theStream = new ByteArrayInputStream(dataUri.getData());\n-                        loader = factory.createImageLoader(theStream);\n+                        loader = imageLoader;\n@@ -386,5 +468,1 @@\n-                    if (isIOS) {\n-                        loader = IosImageLoaderFactory.getInstance().createImageLoader(theStream);\n-                    } else {\n-                        loader = getLoaderBySignature(theStream, listener);\n-                    }\n+                    loader = findImageLoader(theStream, listener);\n@@ -397,1 +475,1 @@\n-                images = loadAll(loader, width, height, preserveAspectRatio, imgPixelScale, smooth);\n+                images = loadAll(loader, width, height, preserveAspectRatio, devPixelScale, imgPixelScale, smooth);\n@@ -433,1 +511,1 @@\n-            float pixelScale, boolean smooth) throws ImageStorageException {\n+            float devPixelScale, float imgPixelScale, boolean smooth) throws ImageStorageException {\n@@ -438,2 +516,0 @@\n-        int imgw = (int) Math.round(width * pixelScale);\n-        int imgh = (int) Math.round(height * pixelScale);\n@@ -442,1 +518,1 @@\n-                image = loader.load(imageIndex++, imgw, imgh, preserveAspectRatio, smooth);\n+                image = loader.load(imageIndex++, width, height, preserveAspectRatio, smooth, devPixelScale, imgPixelScale);\n@@ -452,1 +528,0 @@\n-                image.setPixelScale(pixelScale);\n@@ -466,0 +541,23 @@\n+    private ImageLoader findImageLoader(InputStream stream, ImageLoadListener listener) throws IOException {\n+        if (isIOS) {\n+            return IosImageLoaderFactory.getInstance().createImageLoader(stream);\n+        }\n+\n+        \/\/ We need a stream that supports the mark and reset methods, since XImageLoader\n+        \/\/ is used as a fallback after our built-in loader selection has already consumed\n+        \/\/ part of the input stream.\n+        if (!stream.markSupported()) {\n+            stream = new BufferedInputStream(stream);\n+        }\n+\n+        stream.mark(Integer.MAX_VALUE);\n+        ImageLoader loader = getLoaderBySignature(stream, listener);\n+\n+        if (loader == null && xImageLoaderFactory != null) {\n+            stream.reset();\n+            loader = xImageLoaderFactory.createImageLoader(stream);\n+        }\n+\n+        return loader;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/ImageStorage.java","additions":149,"deletions":51,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -486,2 +486,3 @@\n-    public ImageFrame load(int imageIndex, int width, int height,\n-            boolean preserveAspectRatio, boolean smooth) throws IOException\n+    public ImageFrame load(int imageIndex, double w, double h,\n+            boolean preserveAspectRatio, boolean smooth,\n+            float screenPixelScale, float imagePixelScale) throws IOException\n@@ -494,3 +495,4 @@\n-        int[] outWH = ImageTools.computeDimensions(bih.biWidth, hght, width, height, preserveAspectRatio);\n-        width = outWH[0];\n-        height = outWH[1];\n+        int[] outWH = ImageTools.computeDimensions(\n+            bih.biWidth, hght, (int)(w * imagePixelScale), (int)(h * imagePixelScale), preserveAspectRatio);\n+        int width = outWH[0];\n+        int height = outWH[1];\n@@ -558,1 +560,1 @@\n-                width, height, width * bpp, null, imageMetadata);\n+                width, height, width * bpp, null, imagePixelScale, imageMetadata);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/bmp\/BMPImageLoaderFactory.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,2 +201,2 @@\n-    @Override\n-    public ImageFrame load(int imageIndex, int width, int height, boolean preserveAspectRatio, boolean smooth) throws IOException {\n+    public ImageFrame load(int imageIndex, double imgw, double imgh, boolean preserveAspectRatio, boolean smooth,\n+                           float screenPixelScale, float imagePixelScale) throws IOException {\n@@ -225,3 +225,4 @@\n-        int[] outWH = ImageTools.computeDimensions(screenW, screenH, width, height, preserveAspectRatio);\n-        width = outWH[0];\n-        height = outWH[1];\n+        int[] outWH = ImageTools.computeDimensions(\n+            screenW, screenH, (int)(imgw * imagePixelScale), (int)(imgh * imagePixelScale), preserveAspectRatio);\n+        int width = outWH[0];\n+        int height = outWH[1];\n@@ -244,1 +245,1 @@\n-                width, height, width * 4, null, metadata);\n+                width, height, width * 4, null, imagePixelScale, metadata);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/gif\/GIFImageLoader2.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,3 +221,2 @@\n-    public ImageFrame load(int imageIndex, int width, int height, boolean preserveAspectRatio, boolean smooth)\n-            throws IOException {\n-\n+    public ImageFrame load(int imageIndex, double w, double h, boolean preserveAspectRatio, boolean smooth,\n+                           float screenPixelScale, float imagePixelScale) throws IOException {\n@@ -230,3 +229,4 @@\n-        int[] widthHeight = ImageTools.computeDimensions(inWidth, inHeight, width, height, preserveAspectRatio);\n-        width = widthHeight[0];\n-        height = widthHeight[1];\n+        int[] widthHeight = ImageTools.computeDimensions(\n+            inWidth, inHeight, (int)(w * imagePixelScale), (int)(h * imagePixelScale), preserveAspectRatio);\n+        int width = widthHeight[0];\n+        int height = widthHeight[1];\n@@ -265,0 +265,1 @@\n+                imagePixelScale,\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/ios\/IosImageLoader.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.iio.javax;\n+\n+import com.sun.javafx.iio.ImageFormatDescription;\n+import com.sun.javafx.iio.ImageFrame;\n+import com.sun.javafx.iio.ImageLoadListener;\n+import com.sun.javafx.iio.ImageLoader;\n+import com.sun.javafx.iio.ImageMetadata;\n+import com.sun.javafx.iio.ImageStorage;\n+import com.sun.javafx.iio.ImageStorageException;\n+import com.sun.javafx.iio.common.ImageDescriptor;\n+import com.sun.javafx.iio.common.ImageTools;\n+import javax.imageio.ImageReadParam;\n+import javax.imageio.ImageReader;\n+import javax.imageio.event.IIOReadProgressListener;\n+import javax.imageio.event.IIOReadWarningListener;\n+import javax.imageio.stream.ImageInputStream;\n+import java.awt.Dimension;\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DataBufferByte;\n+import java.awt.image.DataBufferInt;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+import static java.awt.image.BufferedImage.*;\n+\n+public class XImageLoader implements ImageLoader {\n+\n+    private final ImageReader reader;\n+    private final ImageInputStream stream;\n+    private final ImageFormatDescription description;\n+\n+    public XImageLoader(ImageReader reader, ImageInputStream stream) throws IOException {\n+        this.reader = reader;\n+        this.stream = stream;\n+        this.description = new ImageDescriptor(\n+            reader.getFormatName(), new String[0], new ImageFormatDescription.Signature[0],\n+            reader.getOriginatingProvider() == null ? new String[0] :\n+                Arrays.stream(reader.getOriginatingProvider().getMIMETypes())\n+                    .map(type -> type.substring(type.indexOf('\/')))\n+                    .toArray(String[]::new));\n+\n+        reader.setInput(stream);\n+    }\n+\n+    @Override\n+    public ImageFormatDescription getFormatDescription() {\n+        return description;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        reader.dispose();\n+\n+        try {\n+            if (stream != null) {\n+                stream.close();\n+            }\n+        } catch (IOException ignored) {\n+        }\n+    }\n+\n+    @Override\n+    public void addListener(ImageLoadListener listener) {\n+        var listenerImpl = new LoadListenerImpl(listener);\n+        reader.addIIOReadProgressListener(listenerImpl);\n+        reader.addIIOReadWarningListener(listenerImpl);\n+    }\n+\n+    @Override\n+    public void removeListener(ImageLoadListener listener) {\n+        var listenerImpl = new LoadListenerImpl(listener);\n+        reader.removeIIOReadProgressListener(listenerImpl);\n+        reader.removeIIOReadWarningListener(listenerImpl);\n+    }\n+\n+    @Override\n+    public ImageFrame load(int imageIndex, double w, double h, boolean preserveAspectRatio, boolean smooth,\n+                           float screenPixelScale, float imagePixelScale) throws IOException {\n+        \/\/ We currently don't support animated images loaded via ImageIO\n+        if (imageIndex != 0) {\n+            return null;\n+        }\n+\n+        int width, height;\n+        float pixelScale;\n+        ImageReadParam param = reader.getDefaultReadParam();\n+\n+        if (param.canSetSourceRenderSize()) {\n+            int imageWidth = reader.getWidth(imageIndex);\n+            int imageHeight = reader.getHeight(imageIndex);\n+            int[] widthHeight = ImageTools.computeDimensions(\n+                (int)(imageWidth * screenPixelScale), (int)(imageHeight * screenPixelScale),\n+                (int)(w * screenPixelScale), (int)(h * screenPixelScale),\n+                preserveAspectRatio);\n+\n+            width = widthHeight[0];\n+            height = widthHeight[1];\n+            pixelScale = screenPixelScale;\n+            param.setSourceRenderSize(new Dimension(width, height));\n+        } else {\n+            int[] widthHeight = ImageTools.computeDimensions(\n+                reader.getWidth(imageIndex), reader.getHeight(imageIndex),\n+                (int)(w * imagePixelScale), (int)(h * imagePixelScale),\n+                preserveAspectRatio);\n+\n+            width = widthHeight[0];\n+            height = widthHeight[1];\n+            pixelScale = imagePixelScale;\n+        }\n+\n+        BufferedImage image = reader.read(imageIndex, param);\n+\n+        if (image.getWidth() != width || image.getHeight() != height) {\n+            image = (BufferedImage)image.getScaledInstance(\n+                width, height, smooth ? Image.SCALE_SMOOTH : Image.SCALE_DEFAULT);\n+        }\n+\n+        var metadata = new ImageMetadata(\n+            null, true, null, null, null,\n+            null, null, image.getWidth(), image.getHeight(), null,\n+            null, null);\n+\n+        return switch (image.getType()) {\n+            case TYPE_BYTE_GRAY -> new ImageFrame(ImageStorage.ImageType.GRAY,\n+                    getByteBuffer(image.getData().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), image.getWidth(),\n+                    null, pixelScale, metadata);\n+\n+            case TYPE_3BYTE_BGR -> new ImageFrame(ImageStorage.ImageType.BGR,\n+                    getByteBuffer(image.getData().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), image.getWidth() * 3,\n+                    null, pixelScale, metadata);\n+\n+            case TYPE_4BYTE_ABGR -> new ImageFrame(ImageStorage.ImageType.ABGR,\n+                    getByteBuffer(image.getData().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), image.getWidth() * 4,\n+                    null, pixelScale, metadata);\n+\n+            case TYPE_4BYTE_ABGR_PRE -> new ImageFrame(ImageStorage.ImageType.ABGR_PRE,\n+                    getByteBuffer(image.getData().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), image.getWidth() * 4,\n+                    null, pixelScale, metadata);\n+\n+            case TYPE_INT_RGB -> new ImageFrame(ImageStorage.ImageType.INT_RGB,\n+                    getIntBuffer(image.getData().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), image.getWidth() * 4,\n+                    null, pixelScale, metadata);\n+\n+            case TYPE_INT_BGR -> new ImageFrame(ImageStorage.ImageType.INT_BGR,\n+                    getIntBuffer(image.getData().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), image.getWidth() * 4,\n+                    null, pixelScale, metadata);\n+\n+            case TYPE_INT_ARGB -> new ImageFrame(ImageStorage.ImageType.INT_ARGB,\n+                    getIntBuffer(image.getData().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), image.getWidth() * 4,\n+                    null, pixelScale, metadata);\n+\n+            case TYPE_INT_ARGB_PRE -> new ImageFrame(ImageStorage.ImageType.INT_ARGB_PRE,\n+                    getIntBuffer(image.getData().getDataBuffer()),\n+                    image.getWidth(), image.getHeight(), image.getWidth() * 4,\n+                    null, pixelScale, metadata);\n+\n+            default ->\n+                throw new ImageStorageException(\"Unsupported image type: \" + switch (image.getType()) {\n+                    case TYPE_CUSTOM -> \"TYPE_CUSTOM\";\n+                    case TYPE_USHORT_565_RGB -> \"TYPE_USHORT_565_RGB\";\n+                    case TYPE_USHORT_555_RGB -> \"TYPE_USHORT_555_RGB\";\n+                    case TYPE_USHORT_GRAY -> \"TYPE_USHORT_GRAY\";\n+                    case TYPE_BYTE_BINARY -> \"TYPE_BYTE_BINARY\";\n+                    case TYPE_BYTE_INDEXED -> \"TYPE_BYTE_INDEXED\";\n+                    default -> Integer.toString(image.getType());\n+                });\n+        };\n+    }\n+\n+    private static ByteBuffer getByteBuffer(DataBuffer buffer) {\n+        DataBufferByte byteBuffer = (DataBufferByte)buffer;\n+        byte[] data = byteBuffer.getData();\n+        int offset = byteBuffer.getOffset();\n+        int size = byteBuffer.getSize();\n+\n+        if (offset == 0 && size == data.length) {\n+            return ByteBuffer.wrap(data);\n+        }\n+\n+        return ByteBuffer.wrap(Arrays.copyOf(data, size - offset));\n+    }\n+\n+    private static IntBuffer getIntBuffer(DataBuffer buffer) {\n+        DataBufferInt byteBuffer = (DataBufferInt)buffer;\n+        int[] data = byteBuffer.getData();\n+        int offset = byteBuffer.getOffset();\n+        int size = byteBuffer.getSize();\n+\n+        if (offset == 0 && size == data.length) {\n+            return IntBuffer.wrap(data);\n+        }\n+\n+        return IntBuffer.wrap(Arrays.copyOf(data, size - offset));\n+    }\n+\n+    private final class LoadListenerImpl implements IIOReadProgressListener, IIOReadWarningListener {\n+        private final ImageLoadListener listener;\n+        private float lastProgress;\n+\n+        LoadListenerImpl(ImageLoadListener listener) {\n+            this.listener = listener;\n+        }\n+\n+        @Override\n+        public void warningOccurred(ImageReader source, String warning) {\n+            listener.imageLoadWarning(XImageLoader.this, warning);\n+        }\n+\n+        @Override\n+        public void imageProgress(ImageReader source, float percentageDone) {\n+            if (percentageDone > lastProgress) {\n+                lastProgress = percentageDone;\n+                listener.imageLoadProgress(XImageLoader.this, percentageDone);\n+            }\n+        }\n+\n+        @Override public void imageStarted(ImageReader source, int imageIndex) {\n+            listener.imageLoadProgress(XImageLoader.this, 0);\n+        }\n+\n+        @Override\n+        public void imageComplete(ImageReader source) {\n+            if (lastProgress < 100) {\n+                listener.imageLoadProgress(XImageLoader.this, 100);\n+            }\n+        }\n+\n+        @Override public void sequenceStarted(ImageReader source, int minIndex) {}\n+        @Override public void sequenceComplete(ImageReader source) {}\n+        @Override public void thumbnailStarted(ImageReader source, int imageIndex, int thumbnailIndex) {}\n+        @Override public void thumbnailProgress(ImageReader source, float percentageDone) {}\n+        @Override public void thumbnailComplete(ImageReader source) {}\n+        @Override public void readAborted(ImageReader source) {}\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof LoadListenerImpl impl && Objects.equals(impl.listener, listener);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return listener.hashCode();\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/javax\/XImageLoader.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.iio.javax;\n+\n+import com.sun.javafx.iio.ImageFormatDescription;\n+import com.sun.javafx.iio.ImageLoader;\n+import com.sun.javafx.iio.ImageLoaderFactory;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageReader;\n+import javax.imageio.stream.ImageInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Iterator;\n+\n+public class XImageLoaderFactory implements ImageLoaderFactory {\n+\n+    private static XImageLoaderFactory theInstance;\n+\n+    private XImageLoaderFactory() {}\n+\n+    public static synchronized XImageLoaderFactory getInstance() {\n+        if (theInstance == null) {\n+            theInstance = new XImageLoaderFactory();\n+        }\n+\n+        return theInstance;\n+    }\n+\n+    @Override\n+    public ImageFormatDescription getFormatDescription() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public ImageLoader createImageLoader(InputStream input) throws IOException {\n+        boolean oldUseCache = ImageIO.getUseCache();\n+        ImageIO.setUseCache(false);\n+\n+        try {\n+            ImageInputStream stream = ImageIO.createImageInputStream(input);\n+            if (stream != null) {\n+                Iterator<ImageReader> readers = ImageIO.getImageReaders(stream);\n+                ImageReader reader = readers.hasNext() ? readers.next() : null;\n+                if (reader == null) {\n+                    stream.close();\n+                    return null;\n+                }\n+\n+                \/\/ XImageLoader is responsible for closing the ImageInputStream after\n+                \/\/ it has finished reading from it.\n+                return new XImageLoader(reader, stream);\n+            }\n+\n+            return null;\n+        } finally {\n+            ImageIO.setUseCache(oldUseCache);\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/javax\/XImageLoaderFactory.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,1 +207,2 @@\n-    public ImageFrame load(int imageIndex, int width, int height, boolean preserveAspectRatio, boolean smooth) throws IOException {\n+    public ImageFrame load(int imageIndex, double w, double h, boolean preserveAspectRatio, boolean smooth,\n+                           float screenPixelScale, float imagePixelScale) throws IOException {\n@@ -215,3 +216,4 @@\n-        int[] widthHeight = ImageTools.computeDimensions(inWidth, inHeight, width, height, preserveAspectRatio);\n-        width = widthHeight[0];\n-        height = widthHeight[1];\n+        int[] widthHeight = ImageTools.computeDimensions(\n+            inWidth, inHeight, (int)(w * imagePixelScale), (int)(h * imagePixelScale), preserveAspectRatio);\n+        int width = widthHeight[0];\n+        int height = widthHeight[1];\n@@ -270,1 +272,1 @@\n-                width, height, width * outNumComponents, null, md);\n+                width, height, width * outNumComponents, null, imagePixelScale, md);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/jpeg\/JPEGImageLoader.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -640,2 +640,3 @@\n-    public ImageFrame load(int imageIndex, int rWidth, int rHeight,\n-            boolean preserveAspectRatio, boolean smooth) throws IOException {\n+    public ImageFrame load(int imageIndex, double w, double h,\n+            boolean preserveAspectRatio, boolean smooth,\n+            float screenPixelScale, float imagePixelScale) throws IOException {\n@@ -659,3 +660,4 @@\n-        int[] outWH = ImageTools.computeDimensions(width, height, rWidth, rHeight, preserveAspectRatio);\n-        rWidth = outWH[0];\n-        rHeight = outWH[1];\n+        int[] outWH = ImageTools.computeDimensions(\n+            width, height, (int)(w * imagePixelScale), (int)(h * imagePixelScale), preserveAspectRatio);\n+        int rWidth = outWH[0];\n+        int rHeight = outWH[1];\n@@ -687,0 +689,2 @@\n+        imgPNG.setPixelScale(imagePixelScale);\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/png\/PNGImageLoader2.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.image.impl.ByteAbgr;\n+import com.sun.javafx.image.impl.ByteArgb;\n@@ -34,0 +36,1 @@\n+import com.sun.javafx.image.impl.ByteRgba;\n@@ -37,0 +40,2 @@\n+import com.sun.javafx.image.impl.IntBgr;\n+import com.sun.javafx.image.impl.IntRgb;\n@@ -210,1 +215,15 @@\n-        if (src ==        ByteBgra.getter) {\n+        if (src ==        ByteRgba.getter) {\n+            if (dst ==               ByteRgba.setter) {\n+                return    ByteRgba.ToByteRgbaConverter();\n+            } else if (dst ==        ByteBgra.setter) {\n+                return    ByteRgba.ToByteBgraConverter();\n+            } else if (dst ==        ByteBgraPre.setter) {\n+                return    ByteRgba.ToByteBgraPreConverter();\n+            }\n+        } else if (src == ByteAbgr.getter) {\n+            if (dst ==               ByteBgra.setter) {\n+                return    ByteAbgr.ToByteBgraConverter();\n+            } else if (dst ==        ByteBgraPre.setter) {\n+                return    ByteAbgr.ToByteBgraPreConverter();\n+            }\n+        } else if (src == ByteBgra.getter) {\n@@ -229,0 +248,2 @@\n+            } else if (dst ==       ByteArgb.setter) {\n+                return    ByteRgb.ToByteArgbConverter();\n@@ -231,1 +252,3 @@\n-            if (dst ==              ByteBgr.setter) {\n+            if (dst ==              ByteRgb.setter) {\n+                return    ByteBgr.ToByteRgbConverter();\n+            } else if (dst ==       ByteBgr.setter) {\n@@ -237,0 +260,2 @@\n+            } else if (dst ==       ByteArgb.setter) {\n+                return    ByteBgr.ToByteArgbConverter();\n@@ -342,1 +367,9 @@\n-        if (src ==        IntArgb.getter) {\n+        if (src ==        IntRgb.getter) {\n+            if (dst ==              IntArgbPre.setter) {\n+                return    IntRgb.ToIntArgbPreConverter();\n+            }\n+        } else if (src == IntBgr.getter) {\n+            if (dst ==              IntArgbPre.setter) {\n+                return    IntBgr.ToIntArgbPreConverter();\n+            }\n+        } else if (src == IntArgb.getter) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/PixelUtils.java","additions":37,"deletions":4,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,0 +284,50 @@\n+\n+    static class SwapThreeByteConverter extends BaseByteToByteConverter {\n+        public SwapThreeByteConverter(BytePixelGetter getter, BytePixelSetter setter) {\n+            super(getter, setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h)\n+        {\n+            srcscanbytes -= w * 3;\n+            srcscanbytes -= w * 4;\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    byte b0 = srcarr[srcoff];\n+                    byte b1 = srcarr[srcoff + 1];\n+                    byte b2 = srcarr[srcoff + 2];\n+                    dstarr[dstoff++] = b2;\n+                    dstarr[dstoff++] = b1;\n+                    dstarr[dstoff++] = b0;\n+                    srcoff += 3;\n+                }\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h)\n+        {\n+            srcscanbytes -= w * 3;\n+            srcscanbytes -= w * 4;\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    byte b0 = srcbuf.get(srcoff);\n+                    byte b1 = srcbuf.get(srcoff + 1);\n+                    byte b2 = srcbuf.get(srcoff + 2);\n+                    dstbuf.put(dstoff++, b2);\n+                    dstbuf.put(dstoff++, b1);\n+                    dstbuf.put(dstoff++, b0);\n+                    srcoff += 3;\n+                }\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/BaseByteToByteConverter.java","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.AlphaType;\n+import com.sun.javafx.image.BytePixelAccessor;\n+import com.sun.javafx.image.BytePixelGetter;\n+import com.sun.javafx.image.BytePixelSetter;\n+import com.sun.javafx.image.ByteToBytePixelConverter;\n+import com.sun.javafx.image.PixelUtils;\n+import java.nio.ByteBuffer;\n+\n+public final class ByteAbgr {\n+\n+    private ByteAbgr() {}\n+\n+    public static final BytePixelGetter     getter = Accessor.instance;\n+    public static final BytePixelSetter     setter = Accessor.instance;\n+    public static final BytePixelAccessor accessor = Accessor.instance;\n+\n+    private static ByteToBytePixelConverter ToByteBgraObj;\n+    public  static ByteToBytePixelConverter ToByteBgraConverter() {\n+        if (ToByteBgraObj == null) {\n+            ToByteBgraObj = BaseByteToByteConverter.createReorderer(\n+                getter, ByteBgra.setter, 1, 2, 3, 0);\n+        }\n+        return ToByteBgraObj;\n+    }\n+\n+    public static ByteToBytePixelConverter ToByteBgraPreConverter() {\n+        return ToByteBgraPreConv.instance;\n+    }\n+\n+    static class Accessor implements BytePixelAccessor {\n+        static final BytePixelAccessor instance = new Accessor();\n+        private Accessor() {}\n+\n+        @Override\n+        public AlphaType getAlphaType() {\n+            return AlphaType.NONPREMULTIPLIED;\n+        }\n+\n+        @Override\n+        public int getNumElements() {\n+            return 4;\n+        }\n+\n+        @Override\n+        public int getArgb(byte[] arr, int offset) {\n+            return (((arr[offset    ]       ) << 24) |\n+                    ((arr[offset + 1] & 0xff)      ) |\n+                    ((arr[offset + 2] & 0xff) <<  8) |\n+                    ((arr[offset + 3] & 0xff) << 16));\n+        }\n+\n+        @Override\n+        public int getArgbPre(byte[] arr, int offset) {\n+            return PixelUtils.NonPretoPre(getArgb(arr, offset));\n+        }\n+\n+        @Override\n+        public int getArgb(ByteBuffer buf, int offset) {\n+            return (((buf.get(offset    )       ) << 24) |\n+                    ((buf.get(offset + 1) & 0xff)      ) |\n+                    ((buf.get(offset + 2) & 0xff) <<  8) |\n+                    ((buf.get(offset + 3) & 0xff) << 16));\n+        }\n+\n+        @Override\n+        public int getArgbPre(ByteBuffer buf, int offset) {\n+            return PixelUtils.NonPretoPre(getArgb(buf, offset));\n+        }\n+\n+        @Override\n+        public void setArgb(byte[] arr, int offset, int argb) {\n+            arr[offset    ] = (byte) (argb >> 24);\n+            arr[offset + 1] = (byte) (argb      );\n+            arr[offset + 2] = (byte) (argb >>  8);\n+            arr[offset + 3] = (byte) (argb >> 16);\n+        }\n+\n+        @Override\n+        public void setArgbPre(byte[] arr, int offset, int argbpre) {\n+            setArgb(arr, offset, PixelUtils.PretoNonPre(argbpre));\n+        }\n+\n+        @Override\n+        public void setArgb(ByteBuffer buf, int offset, int argb) {\n+            buf.put(offset    , (byte) (argb >> 24));\n+            buf.put(offset + 1, (byte) (argb      ));\n+            buf.put(offset + 2, (byte) (argb >>  8));\n+            buf.put(offset + 3, (byte) (argb >> 16));\n+        }\n+\n+        @Override\n+        public void setArgbPre(ByteBuffer buf, int offset, int argbpre) {\n+            setArgb(buf, offset, PixelUtils.PretoNonPre(argbpre));\n+        }\n+    }\n+\n+    static class ToByteBgraPreConv extends BaseByteToByteConverter {\n+        static final ByteToBytePixelConverter instance =\n+            new ToByteBgraPreConv();\n+\n+        private ToByteBgraPreConv() {\n+            super(ByteAbgr.getter, ByteBgraPre.setter);\n+        }\n+\n+        @Override\n+        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n+                       byte[] dstarr, int dstoff, int dstscanbytes,\n+                       int w, int h)\n+        {\n+            srcscanbytes -= w * 4;\n+            dstscanbytes -= w * 4;\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int  a = srcarr[srcoff] & 0xff;\n+                    byte b = srcarr[srcoff + 1];\n+                    byte g = srcarr[srcoff + 2];\n+                    byte r = srcarr[srcoff + 3];\n+                    srcoff += 4;\n+                    if (a < 0xff) {\n+                        if (a == 0) {\n+                            b = g = r = 0;\n+                        } else {\n+                            b = (byte) (((b & 0xff) * a + 0x7f) \/ 0xff);\n+                            g = (byte) (((g & 0xff) * a + 0x7f) \/ 0xff);\n+                            r = (byte) (((r & 0xff) * a + 0x7f) \/ 0xff);\n+                        }\n+                    }\n+                    dstarr[dstoff++] = b;\n+                    dstarr[dstoff++] = g;\n+                    dstarr[dstoff++] = r;\n+                    dstarr[dstoff++] = (byte) a;\n+                }\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n+                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n+                       int w, int h)\n+        {\n+            srcscanbytes -= w * 4;\n+            dstscanbytes -= w * 4;\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int  a = srcbuf.get(srcoff) & 0xff;\n+                    byte b = srcbuf.get(srcoff + 1);\n+                    byte g = srcbuf.get(srcoff + 2);\n+                    byte r = srcbuf.get(srcoff + 3);\n+                    srcoff += 4;\n+                    if (a < 0xff) {\n+                        if (a == 0) {\n+                            b = g = r = 0;\n+                        } else {\n+                            b = (byte) (((b & 0xff) * a + 0x7f) \/ 0xff);\n+                            g = (byte) (((g & 0xff) * a + 0x7f) \/ 0xff);\n+                            r = (byte) (((r & 0xff) * a + 0x7f) \/ 0xff);\n+                        }\n+                    }\n+                    dstbuf.put(dstoff    , b);\n+                    dstbuf.put(dstoff + 1, g);\n+                    dstbuf.put(dstoff + 2, r);\n+                    dstbuf.put(dstoff + 3, (byte) a);\n+                    dstoff += 4;\n+                }\n+                srcoff += srcscanbytes;\n+                dstoff += dstscanbytes;\n+            }\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/ByteAbgr.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,8 @@\n+    private static ByteToBytePixelConverter ToByteRgbObj;\n+    public static ByteToBytePixelConverter ToByteRgbConverter() {\n+        if (ToByteRgbObj == null) {\n+            ToByteRgbObj = new BaseByteToByteConverter.SwapThreeByteConverter(ByteBgr.getter, ByteRgb.setter);\n+        }\n+        return ToByteRgbObj;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/ByteBgr.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.javafx.image.BytePixelAccessor;\n@@ -34,0 +35,1 @@\n+import com.sun.javafx.image.PixelUtils;\n@@ -38,1 +40,2 @@\n-    public static final BytePixelGetter getter = Getter.instance;\n+    public static final BytePixelGetter getter = Accessor.instance;\n+    public static final BytePixelSetter setter = Accessor.instance;\n@@ -60,2 +63,6 @@\n-    public static final ByteToBytePixelConverter ToByteBgrConverter() {\n-        return ByteRgb.SwapThreeByteConverter.rgbToBgrInstance;\n+    private static ByteToBytePixelConverter rgbToBgrInstance;\n+    public static ByteToBytePixelConverter ToByteBgrConverter() {\n+        if (rgbToBgrInstance == null) {\n+            rgbToBgrInstance = new BaseByteToByteConverter.SwapThreeByteConverter(ByteRgb.getter, ByteBgr.setter);\n+        }\n+        return rgbToBgrInstance;\n@@ -64,3 +71,3 @@\n-    static class Getter implements BytePixelGetter {\n-        static final BytePixelGetter instance = new Getter();\n-        private Getter() {}\n+    static class Accessor implements BytePixelAccessor {\n+        static final BytePixelAccessor instance = new Accessor();\n+        private Accessor() {}\n@@ -109,0 +116,24 @@\n+\n+        @Override\n+        public void setArgb(byte[] arr, int offset, int argb) {\n+            arr[offset    ] = (byte)((argb >> 16) & 0xff);\n+            arr[offset + 1] = (byte)((argb >> 8) & 0xff);\n+            arr[offset + 2] = (byte)(argb & 0xff);\n+        }\n+\n+        @Override\n+        public void setArgbPre(byte[] arr, int offset, int argbpre) {\n+            setArgb(arr, offset, PixelUtils.PretoNonPre(argbpre));\n+        }\n+\n+        @Override\n+        public void setArgb(ByteBuffer buf, int offset, int argb) {\n+            buf.put(offset    , (byte)((argb >> 16) & 0xff));\n+            buf.put(offset + 1, (byte)((argb >> 8) & 0xff));\n+            buf.put(offset + 2, (byte)(argb & 0xff));\n+        }\n+\n+        @Override\n+        public void setArgbPre(ByteBuffer buf, int offset, int argbpre) {\n+            setArgb(buf, offset, PixelUtils.PretoNonPre(argbpre));\n+        }\n@@ -257,47 +288,0 @@\n-\n-    static class SwapThreeByteConverter extends BaseByteToByteConverter {\n-        static final ByteToBytePixelConverter rgbToBgrInstance =\n-            new SwapThreeByteConverter(ByteRgb.getter, ByteBgr.accessor);\n-\n-        public SwapThreeByteConverter(BytePixelGetter getter, BytePixelSetter setter) {\n-            super(getter, setter);\n-        }\n-\n-        @Override\n-        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,\n-                       byte[] dstarr, int dstoff, int dstscanbytes,\n-                       int w, int h)\n-        {\n-            srcscanbytes -= w * 3;\n-            srcscanbytes -= w * 4;\n-            while (--h >= 0) {\n-                for (int x = 0; x < w; x++) {\n-                    dstarr[dstoff++] = srcarr[srcoff + 2];\n-                    dstarr[dstoff++] = srcarr[srcoff + 1];\n-                    dstarr[dstoff++] = srcarr[srcoff    ];\n-                    srcoff += 3;\n-                }\n-                srcoff += srcscanbytes;\n-                dstoff += dstscanbytes;\n-            }\n-        }\n-\n-        @Override\n-        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,\n-                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,\n-                       int w, int h)\n-        {\n-            srcscanbytes -= w * 3;\n-            srcscanbytes -= w * 4;\n-            while (--h >= 0) {\n-                for (int x = 0; x < w; x++) {\n-                    dstbuf.put(dstoff++, srcbuf.get(srcoff + 2));\n-                    dstbuf.put(dstoff++, srcbuf.get(srcoff + 1));\n-                    dstbuf.put(dstoff++, srcbuf.get(srcoff    ));\n-                    srcoff += 3;\n-                }\n-                srcoff += srcscanbytes;\n-                dstoff += dstscanbytes;\n-            }\n-        }\n-    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/ByteRgb.java","additions":38,"deletions":54,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,3 +61,3 @@\n-\/\/    public static ByteToBytePixelConverter ToByteBgraPreConverter() {\n-\/\/        return ByteRgba.ToByteBgraPreConv.instance;\n-\/\/    }\n+    public static ByteToBytePixelConverter ToByteBgraPreConverter() {\n+        return ByteRgba.ToByteBgraPreConv.instance;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/ByteRgba.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.AlphaType;\n+import com.sun.javafx.image.IntPixelAccessor;\n+import com.sun.javafx.image.IntPixelGetter;\n+import com.sun.javafx.image.IntPixelSetter;\n+import com.sun.javafx.image.IntToIntPixelConverter;\n+import com.sun.javafx.image.PixelUtils;\n+import java.nio.IntBuffer;\n+\n+public final class IntBgr {\n+    private IntBgr() {}\n+\n+    public static final IntPixelGetter     getter = Accessor.instance;\n+    public static final IntPixelSetter     setter = Accessor.instance;\n+    public static final IntPixelAccessor accessor = Accessor.instance;\n+\n+    public static IntToIntPixelConverter ToIntArgbPreConverter() {\n+        return IntBgr.ToIntArgbPreConv.instance;\n+    }\n+\n+    static class Accessor implements IntPixelAccessor {\n+        static final IntPixelAccessor instance = new Accessor();\n+        private Accessor() {}\n+\n+        @Override\n+        public AlphaType getAlphaType() {\n+            return AlphaType.OPAQUE;\n+        }\n+\n+        @Override\n+        public int getNumElements() {\n+            return 1;\n+        }\n+\n+        @Override\n+        public int getArgb(int[] arr, int offset) {\n+            int pixel = arr[offset];\n+            int r = pixel & 0xff;\n+            int g = (pixel >> 8) & 0xff;\n+            int b = (pixel >> 16) & 0xff;\n+            return (255 << 24) | (r << 16) | (g << 8) | b;\n+        }\n+\n+        @Override\n+        public int getArgbPre(int[] arr, int offset) {\n+            return PixelUtils.NonPretoPre(getArgb(arr, offset));\n+        }\n+\n+        @Override\n+        public int getArgb(IntBuffer buffer, int offset) {\n+            int pixel = buffer.get(offset);\n+            int r = pixel & 0xff;\n+            int g = (pixel >> 8) & 0xff;\n+            int b = (pixel >> 16) & 0xff;\n+            return (255 << 24) | (r << 16) | (g << 8) | b;\n+        }\n+\n+        @Override\n+        public int getArgbPre(IntBuffer buffer, int offset) {\n+            return PixelUtils.NonPretoPre(getArgb(buffer, offset));\n+        }\n+\n+        @Override\n+        public void setArgb(int[] arr, int offset, int argb) {\n+            int b = argb & 0xff;\n+            int g = (argb >> 8) & 0xff;\n+            int r = (argb >> 16) & 0xff;\n+            arr[offset] = (255 << 24) | (b << 16) | (g << 8) | r;\n+        }\n+\n+        @Override\n+        public void setArgbPre(int[] arr, int offset, int argbpre) {\n+            setArgb(arr, offset, PixelUtils.PretoNonPre(argbpre));\n+        }\n+\n+        @Override\n+        public void setArgb(IntBuffer buffer, int offset, int argb) {\n+            int b = argb & 0xff;\n+            int g = (argb >> 8) & 0xff;\n+            int r = (argb >> 16) & 0xff;\n+            buffer.put(offset, (255 << 24) | (b << 16) | (g << 8) | r);\n+        }\n+\n+        @Override\n+        public void setArgbPre(IntBuffer buffer, int offset, int argbpre) {\n+            setArgb(buffer, offset, PixelUtils.PretoNonPre(argbpre));\n+        }\n+    }\n+\n+    public static class ToIntArgbPreConv extends BaseIntToIntConverter {\n+        public static final IntToIntPixelConverter instance =\n+            new ToIntArgbPreConv();\n+\n+        private ToIntArgbPreConv() {\n+            super(IntBgr.getter, IntArgbPre.setter);\n+        }\n+\n+        @Override\n+        void doConvert(int[] srcarr, int srcoff, int srcscanints,\n+                       int[] dstarr, int dstoff, int dstscanints,\n+                       int w, int h)\n+        {\n+            srcscanints -= w;\n+            dstscanints -= w;\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int pixel = srcarr[srcoff++];\n+                    int b = (pixel >> 16) & 0xff;\n+                    int g = (pixel >>  8) & 0xff;\n+                    int r = (pixel      ) & 0xff;\n+                    dstarr[dstoff++] = (255 << 24) | (r << 16) | (g << 8) | b;\n+                }\n+                srcoff += srcscanints;\n+                dstoff += dstscanints;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(IntBuffer srcbuf, int srcoff, int srcscanints,\n+                       IntBuffer dstbuf, int dstoff, int dstscanints,\n+                       int w, int h)\n+        {\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int pixel = srcbuf.get(srcoff + x);\n+                    int b = (pixel >> 16) & 0xff;\n+                    int g = (pixel >>  8) & 0xff;\n+                    int r = (pixel      ) & 0xff;\n+                    dstbuf.put(dstoff + x, (255 << 24) | (r << 16) | (g << 8) | b);\n+                }\n+                srcoff += srcscanints;\n+                dstoff += dstscanints;\n+            }\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/IntBgr.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.image.impl;\n+\n+import com.sun.javafx.image.AlphaType;\n+import com.sun.javafx.image.IntPixelAccessor;\n+import com.sun.javafx.image.IntPixelGetter;\n+import com.sun.javafx.image.IntPixelSetter;\n+import com.sun.javafx.image.IntToIntPixelConverter;\n+import com.sun.javafx.image.PixelUtils;\n+import java.nio.IntBuffer;\n+\n+public class IntRgb {\n+    private IntRgb() {}\n+\n+    public static final IntPixelGetter     getter = Accessor.instance;\n+    public static final IntPixelSetter     setter = Accessor.instance;\n+    public static final IntPixelAccessor accessor = Accessor.instance;\n+\n+    public static IntToIntPixelConverter ToIntArgbPreConverter() {\n+        return IntRgb.ToIntArgbPreConv.instance;\n+    }\n+\n+    static class Accessor implements IntPixelAccessor {\n+        static final IntPixelAccessor instance = new Accessor();\n+        private Accessor() {}\n+\n+        @Override\n+        public AlphaType getAlphaType() {\n+            return AlphaType.OPAQUE;\n+        }\n+\n+        @Override\n+        public int getNumElements() {\n+            return 1;\n+        }\n+\n+        @Override\n+        public int getArgb(int[] arr, int offset) {\n+            return arr[offset] | (0xff << 24);\n+        }\n+\n+        @Override\n+        public int getArgbPre(int[] arr, int offset) {\n+            return PixelUtils.NonPretoPre(arr[offset] | (0xff << 24));\n+        }\n+\n+        @Override\n+        public int getArgb(IntBuffer buffer, int offset) {\n+            return buffer.get(offset) | (0xff << 24);\n+        }\n+\n+        @Override\n+        public int getArgbPre(IntBuffer buffer, int offset) {\n+            return PixelUtils.NonPretoPre(buffer.get(offset) | (0xff << 24));\n+        }\n+\n+        @Override\n+        public void setArgb(int[] arr, int offset, int argb) {\n+            arr[offset] = argb | (0xff << 24);\n+        }\n+\n+        @Override\n+        public void setArgbPre(int[] arr, int offset, int argbpre) {\n+            arr[offset] = PixelUtils.PretoNonPre(argbpre) | (0xff << 24);\n+        }\n+\n+        @Override\n+        public void setArgb(IntBuffer buffer, int offset, int argb) {\n+            buffer.put(offset, argb | (0xff << 24));\n+        }\n+\n+        @Override\n+        public void setArgbPre(IntBuffer buffer, int offset, int argbpre) {\n+            buffer.put(offset, PixelUtils.PretoNonPre(argbpre) | (0xff << 24));\n+        }\n+    }\n+\n+    public static class ToIntArgbPreConv extends BaseIntToIntConverter {\n+        public static final IntToIntPixelConverter instance =\n+            new ToIntArgbPreConv();\n+\n+        private ToIntArgbPreConv() {\n+            super(IntRgb.getter, IntArgbPre.setter);\n+        }\n+\n+        @Override\n+        void doConvert(int[] srcarr, int srcoff, int srcscanints,\n+                       int[] dstarr, int dstoff, int dstscanints,\n+                       int w, int h)\n+        {\n+            srcscanints -= w;\n+            dstscanints -= w;\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int pixel = srcarr[srcoff++];\n+                    int r = (pixel >> 16) & 0xff;\n+                    int g = (pixel >>  8) & 0xff;\n+                    int b = (pixel      ) & 0xff;\n+                    dstarr[dstoff++] = (255 << 24) | (r << 16) | (g << 8) | b;\n+                }\n+                srcoff += srcscanints;\n+                dstoff += dstscanints;\n+            }\n+        }\n+\n+        @Override\n+        void doConvert(IntBuffer srcbuf, int srcoff, int srcscanints,\n+                       IntBuffer dstbuf, int dstoff, int dstscanints,\n+                       int w, int h)\n+        {\n+            while (--h >= 0) {\n+                for (int x = 0; x < w; x++) {\n+                    int pixel = srcbuf.get(srcoff + x);\n+                    int r = (pixel >> 16) & 0xff;\n+                    int g = (pixel >>  8) & 0xff;\n+                    int b = (pixel      ) & 0xff;\n+                    dstbuf.put(dstoff + x, (255 << 24) | (r << 16) | (g << 8) | b);\n+                }\n+                srcoff += srcscanints;\n+                dstoff += dstscanints;\n+            }\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/image\/impl\/IntRgb.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,2 @@\n+import com.sun.javafx.image.impl.ByteAbgr;\n+import com.sun.javafx.image.impl.ByteBgr;\n@@ -57,0 +59,3 @@\n+import com.sun.javafx.image.impl.IntArgb;\n+import com.sun.javafx.image.impl.IntBgr;\n+import com.sun.javafx.image.impl.IntRgb;\n@@ -203,1 +208,1 @@\n-    \/*\n+    \/**\n@@ -206,2 +211,2 @@\n-     * It does not duplicate the memory, except in L8A8 case.\n-     * If it necessary, it does in-place format conversion like RGBA->BGRA\n+     * If possible, it does not duplicate the memory.\n+     * If necessary, it does in-place format conversion like RGBA->BGRA\n@@ -213,1 +218,0 @@\n-        ByteBuffer buffer = (ByteBuffer) frame.getImageData();\n@@ -216,1 +220,1 @@\n-        int scanBytes = frame.getStride();\n+        int stride = frame.getStride();\n@@ -219,38 +223,83 @@\n-        switch (type) {\n-            case GRAY:\n-                return Image.fromByteGrayData(buffer, w, h, scanBytes, ps);\n-\n-            case RGB:\n-                return Image.fromByteRgbData(buffer, w, h, scanBytes, ps);\n-\n-            case RGBA:\n-                \/\/ Bgra => BgrePre is same operation as Rgba => RgbaPre\n-                \/\/ TODO: 3D - need a way to handle pre versus non-Pre\n-                ByteBgra.ToByteBgraPreConverter().convert(buffer, 0, scanBytes,\n-                                                          buffer, 0, scanBytes,\n-                                                          w, h);\n-                \/* NOBREAK *\/\n-            case RGBA_PRE:\n-                ByteRgba.ToByteBgraConverter().convert(buffer, 0, scanBytes,\n-                                                       buffer, 0, scanBytes,\n-                                                       w, h);\n-                return Image.fromByteBgraPreData(buffer, w, h, scanBytes, ps);\n-\n-            case GRAY_ALPHA:\n-                \/\/ TODO: 3D - need a way to handle pre versus non-Pre\n-                ByteGrayAlpha.ToByteGrayAlphaPreConverter().convert(buffer, 0, scanBytes,\n-                                                                    buffer, 0, scanBytes,\n-                                                                    w, h);\n-                \/* NOBREAK *\/\n-            case GRAY_ALPHA_PRE:\n-                if (scanBytes != w * 2) {\n-                    throw new AssertionError(\"Bad stride for GRAY_ALPHA\");\n-                }\n-                byte newbuf[] = new byte[w * h * 4];\n-                ByteGrayAlphaPre.ToByteBgraPreConverter().convert(buffer, 0, scanBytes,\n-                                                                  newbuf, 0, w*4,\n-                                                                  w, h);\n-                return Image.fromByteBgraPreData(newbuf, w, h, ps);\n-            default:\n-                throw new RuntimeException(\"Unknown image type: \" + type);\n-        }\n+        \/\/ GRAY, RGB, BGRA_PRE, and INT_ARGB_PRE are directly supported by Prism.\n+        \/\/ We'll need to convert all other formats that we might encounter to one of the supported formats.\n+        \/\/ TODO: 3D - need a way to handle pre versus non-Pre\n+        return switch (type) {\n+            case GRAY -> fromByteGrayData((ByteBuffer)frame.getImageData(), w, h, stride, ps);\n+            case RGB -> fromByteRgbData((ByteBuffer)frame.getImageData(), w, h, stride, ps);\n+            case BGRA_PRE -> fromByteBgraPreData((ByteBuffer)frame.getImageData(), w, h, stride, ps);\n+            case INT_ARGB_PRE -> fromIntArgbPreData((IntBuffer)frame.getImageData(), w, h, stride, ps);\n+\n+            case GRAY_ALPHA -> {\n+                byte[] buffer = new byte[w * h * 4];\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteGrayAlpha.ToByteGrayAlphaPreConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                ByteGrayAlphaPre.ToByteBgraPreConverter().convert(imageData, 0, stride, buffer, 0, w * 4, w, h);\n+                yield fromByteBgraPreData(buffer, w, h, ps);\n+            }\n+\n+            case GRAY_ALPHA_PRE -> {\n+                byte[] buffer = new byte[w * h * 4];\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteGrayAlphaPre.ToByteBgraPreConverter().convert(imageData, 0, stride, buffer, 0, w * 4, w, h);\n+                yield fromByteBgraPreData(buffer, w, h, ps);\n+            }\n+\n+            case BGR -> {\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteBgr.ToByteRgbConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromByteRgbData(imageData, w, h, stride, ps);\n+            }\n+\n+            case RGBA -> {\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteRgba.ToByteBgraPreConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromByteBgraPreData(imageData, w, h, stride, ps);\n+            }\n+\n+            case RGBA_PRE -> {\n+                \/\/ Source is already premultiplied, so the non-pre converter is sufficient.\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteRgba.ToByteBgraConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromByteBgraPreData(imageData, w, h, stride, ps);\n+            }\n+\n+            case BGRA -> {\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteBgra.ToByteBgraPreConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromByteBgraPreData(imageData, w, h, stride, ps);\n+            }\n+\n+            case ABGR -> {\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteAbgr.ToByteBgraPreConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromByteBgraPreData(imageData, w, h, stride, ps);\n+            }\n+\n+            case ABGR_PRE -> {\n+                \/\/ Source is already premultiplied, so the non-pre converter is sufficient.\n+                ByteBuffer imageData = (ByteBuffer)frame.getImageData();\n+                ByteAbgr.ToByteBgraConverter().convert(imageData, 0, stride, imageData, 0, stride, w, h);\n+                yield fromByteBgraPreData(imageData, w, h, stride, ps);\n+            }\n+\n+            case INT_RGB -> {\n+                IntBuffer imageData = (IntBuffer)frame.getImageData();\n+                IntRgb.ToIntArgbPreConverter().convert(imageData, 0, stride \/ 4, imageData, 0, stride \/ 4, w, h);\n+                yield fromIntArgbPreData(imageData, w, h, stride, ps);\n+            }\n+\n+            case INT_BGR -> {\n+                IntBuffer imageData = (IntBuffer)frame.getImageData();\n+                IntBgr.ToIntArgbPreConverter().convert(imageData, 0, stride \/ 4, imageData, 0, stride \/ 4, w, h);\n+                yield fromIntArgbPreData(imageData, w, h, stride, ps);\n+            }\n+\n+            case INT_ARGB -> {\n+                IntBuffer imageData = (IntBuffer)frame.getImageData();\n+                IntArgb.ToIntArgbPreConverter().convert(imageData, 0, stride \/ 4, imageData, 0, stride \/ 4, w, h);\n+                yield fromIntArgbPreData(imageData, w, h, stride, ps);\n+            }\n+\n+            case PALETTE, PALETTE_ALPHA, PALETTE_ALPHA_PRE, PALETTE_TRANS ->\n+                throw new RuntimeException(\"Unsupported image type: \" + type);\n+        };\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/Image.java","additions":93,"deletions":44,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n- * Supported image formats are:\n+ * JavaFX has built-in support for the following image formats:\n@@ -75,0 +75,2 @@\n+ * For all other formats, JavaFX uses the {@link javax.imageio Java Image I\/O API} on supported platforms.\n+ * Image I\/O is extensible so that developers can \"plug-in\" support for additional formats.\n@@ -79,1 +81,1 @@\n- * filtering used when scaling, and whether or not to preserve the original\n+ * filtering used when scaling, and whether to preserve the original\n@@ -82,1 +84,1 @@\n- * <p>If a URL string is passed to a constructor, it be any of the following:\n+ * <p>If a URL string is passed to a constructor, it can be any of the following:\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/image\/Image.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -22,0 +22,1 @@\n+--add-exports javafx.graphics\/com.sun.javafx.iio.javax=ALL-UNNAMED\n@@ -56,0 +57,1 @@\n+--add-opens java.desktop\/javax.imageio=ALL-UNNAMED\n","filename":"modules\/javafx.graphics\/src\/test\/addExports","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-            loader.load(0, 1, 1, true, true);\n+            loader.load(0, 1, 1, true, true, 1, 1);\n@@ -212,1 +212,1 @@\n-        ImageFrame f = l.load(0, 0, 0, true, false);\n+        ImageFrame f = l.load(0, 0, 0, true, false, 1, 1);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/iio\/GIFLoaderTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-                    @Override public ImageFrame load(int i, int w, int h, boolean p, boolean s) {\n+                    @Override public ImageFrame load(int i, double w, double h, boolean p, boolean s, float s0, float s1) {\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/iio\/ImageStorageTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        ImageFrame frame = loader.load(0, 0, 0, true, true);\n+        ImageFrame frame = loader.load(0, 0, 0, true, true, 1, 1);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/iio\/bmp\/BMPImageLoaderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.iio.javax;\n+\n+import com.sun.javafx.iio.ImageFrame;\n+import com.sun.javafx.iio.ImageLoadListener;\n+import com.sun.javafx.iio.ImageLoader;\n+import com.sun.javafx.iio.ImageMetadata;\n+import com.sun.javafx.iio.ImageStorage.ImageType;\n+import com.sun.javafx.iio.javax.XImageLoader;\n+import com.sun.javafx.iio.javax.XImageLoaderFactory;\n+import com.sun.prism.Image;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageReadParam;\n+import javax.imageio.ImageReader;\n+import javax.imageio.ImageTypeSpecifier;\n+import javax.imageio.metadata.IIOMetadata;\n+import javax.imageio.stream.ImageInputStream;\n+import java.awt.image.BufferedImage;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import com.sun.prism.PixelFormat;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class XImageLoaderTest {\n+\n+    private int color(int r, int g, int b) {\n+        return 255 << 24 | (r & 0xff) << 16 | (g & 0xff) << 8 | (b & 0xff);\n+    }\n+\n+    private void assertImageContent(Image image) {\n+        assertEquals(color(255, 0, 0), image.getArgb(0, 0));\n+        assertEquals(color(0, 255, 0), image.getArgb(5, 0));\n+        assertEquals(color(0, 0, 255), image.getArgb(9, 0));\n+\n+        assertEquals(color(0, 255, 255), image.getArgb(0, 5));\n+        assertEquals(color(255, 0, 255), image.getArgb(4, 5));\n+        assertEquals(color(255, 255, 0), image.getArgb(9, 5));\n+\n+        assertEquals(color(255, 128, 128), image.getArgb(0, 9));\n+        assertEquals(color(128, 128, 255), image.getArgb(4, 9));\n+        assertEquals(color(143, 240, 128), image.getArgb(9, 9));\n+    }\n+\n+    @Test\n+    void loadImageBGR() throws Exception {\n+        try (InputStream stream = getClass().getResourceAsStream(\"\/test\/com\/sun\/javafx\/iio\/checker.bmp\")) {\n+            ImageLoader loader = XImageLoaderFactory.getInstance().createImageLoader(stream);\n+            ImageFrame frame = loader.load(0, -1, -1, true, false, 1, 1);\n+            Image image = Image.convertImageFrame(frame);\n+\n+            assertEquals(12, frame.getWidth());\n+            assertEquals(12, frame.getHeight());\n+            assertEquals(1, frame.getPixelScale());\n+            assertEquals(ImageType.BGR, frame.getImageType());\n+\n+            assertEquals(12, image.getWidth());\n+            assertEquals(12, image.getHeight());\n+            assertEquals(PixelFormat.BYTE_RGB, image.getPixelFormat());\n+            assertImageContent(image);\n+        }\n+    }\n+\n+    @Test\n+    void loadImageABGR() throws Exception {\n+        try (InputStream stream = getClass().getResourceAsStream(\"\/test\/com\/sun\/javafx\/iio\/checker.png\")) {\n+            ImageLoader loader = XImageLoaderFactory.getInstance().createImageLoader(stream);\n+            ImageFrame frame = loader.load(0, -1, -1, true, false, 1, 1);\n+            Image image = Image.convertImageFrame(frame);\n+\n+            assertEquals(12, frame.getWidth());\n+            assertEquals(12, frame.getHeight());\n+            assertEquals(1, frame.getPixelScale());\n+            assertEquals(ImageType.ABGR, frame.getImageType());\n+\n+            assertEquals(12, image.getWidth());\n+            assertEquals(12, image.getHeight());\n+            assertEquals(PixelFormat.BYTE_BGRA_PRE, image.getPixelFormat());\n+            assertImageContent(image);\n+        }\n+    }\n+\n+    @Test\n+    void loadImageABGR2x() throws Exception {\n+        try (InputStream stream = getClass().getResourceAsStream(\"\/test\/com\/sun\/javafx\/iio\/checker@2x.png\")) {\n+            ImageLoader loader = XImageLoaderFactory.getInstance().createImageLoader(stream);\n+            ImageFrame frame = loader.load(0, -1, -1, true, false, 1, 2);\n+            Image image = Image.convertImageFrame(frame);\n+\n+            assertEquals(24, frame.getWidth());\n+            assertEquals(24, frame.getHeight());\n+            assertEquals(2, frame.getPixelScale());\n+            assertEquals(ImageType.ABGR, frame.getImageType());\n+\n+            assertEquals(24, image.getWidth());\n+            assertEquals(24, image.getHeight());\n+            assertEquals(PixelFormat.BYTE_BGRA_PRE, image.getPixelFormat());\n+            assertImageContent(image);\n+        }\n+    }\n+\n+    enum AwtImageTypes {\n+        TYPE_BYTE_GRAY(BufferedImage.TYPE_BYTE_GRAY, ImageType.GRAY),\n+        TYPE_3BYTE_BGR(BufferedImage.TYPE_3BYTE_BGR, ImageType.BGR),\n+        TYPE_4BYTE_ABGR(BufferedImage.TYPE_4BYTE_ABGR, ImageType.ABGR),\n+        TYPE_4BYTE_ABGR_PRE(BufferedImage.TYPE_4BYTE_ABGR_PRE, ImageType.ABGR_PRE),\n+        TYPE_INT_RGB(BufferedImage.TYPE_INT_RGB, ImageType.INT_RGB),\n+        TYPE_INT_BGR(BufferedImage.TYPE_INT_BGR, ImageType.INT_BGR),\n+        TYPE_INT_ARGB(BufferedImage.TYPE_INT_ARGB, ImageType.INT_ARGB),\n+        TYPE_INT_ARGB_PRE(BufferedImage.TYPE_INT_ARGB_PRE, ImageType.INT_ARGB_PRE);\n+\n+        AwtImageTypes(int awtImageType, ImageType fxImageType) {\n+            this.awtIimageType = awtImageType;\n+            this.fxImageType = fxImageType;\n+        }\n+\n+        final int awtIimageType;\n+        final ImageType fxImageType;\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(AwtImageTypes.class)\n+    void loadVariableDensityImage(AwtImageTypes types) throws IOException {\n+        class CustomImageReader extends ImageReader {\n+            final int imageType;\n+\n+            protected CustomImageReader(int imageType) {\n+                super(null);\n+                this.imageType = imageType;\n+            }\n+\n+            @Override public String getFormatName() { return \"test\"; }\n+            @Override public int getNumImages(boolean allowSearch) { return 1; }\n+            @Override public int getWidth(int imageIndex) { return 2; }\n+            @Override public int getHeight(int imageIndex) { return 2; }\n+            @Override public Iterator<ImageTypeSpecifier> getImageTypes(int imageIndex) { return null; }\n+            @Override public IIOMetadata getStreamMetadata() { return null; }\n+            @Override public IIOMetadata getImageMetadata(int imageIndex) { return null; }\n+\n+            @Override\n+            public ImageReadParam getDefaultReadParam() {\n+                return new ImageReadParam() {{ canSetSourceRenderSize = true; }};\n+            }\n+\n+            @Override\n+            public BufferedImage read(int imageIndex, ImageReadParam param) {\n+                int w = (int)param.getSourceRenderSize().getWidth();\n+                int h = (int)param.getSourceRenderSize().getHeight();\n+                return new BufferedImage(w, h, imageType);\n+            }\n+        }\n+\n+        var imageLoader = new XImageLoader(new CustomImageReader(types.awtIimageType), null);\n+\n+        \/\/ Load an image with screenPixelScale == 1\n+        var imageFrame = imageLoader.load(0, -1, -1, false, false, 1, 1);\n+        assertEquals(2, imageFrame.getWidth());\n+        assertEquals(2, imageFrame.getHeight());\n+        assertEquals(1, imageFrame.getPixelScale());\n+        assertEquals(types.fxImageType, imageFrame.getImageType());\n+\n+        \/\/ Load an image with screenPixelScale == 1.5\n+        imageFrame = imageLoader.load(0, -1, -1, false, false, 1.5f, 1);\n+        assertEquals(3, imageFrame.getWidth());\n+        assertEquals(3, imageFrame.getHeight());\n+        assertEquals(1.5, imageFrame.getPixelScale());\n+        assertEquals(types.fxImageType, imageFrame.getImageType());\n+\n+        \/\/ Load an image with screenPixelScale == 2\n+        imageFrame = imageLoader.load(0, -1, -1, false, false, 2, 1);\n+        assertEquals(4, imageFrame.getWidth());\n+        assertEquals(4, imageFrame.getHeight());\n+        assertEquals(2, imageFrame.getPixelScale());\n+        assertEquals(types.fxImageType, imageFrame.getImageType());\n+    }\n+\n+    @Test\n+    void addAndRemoveListener() throws Exception {\n+        try (InputStream stream = getClass().getResourceAsStream(\"\/test\/com\/sun\/javafx\/iio\/checker.png\")) {\n+            ImageReader pngReader = ImageIO.getImageReadersByFormatName(\"PNG\").next();\n+            ImageInputStream input = ImageIO.createImageInputStream(stream);\n+            pngReader.setInput(input);\n+            XImageLoader loader = new XImageLoader(pngReader, input);\n+            ImageLoadListener listener = new ImageLoadListener() {\n+                @Override public void imageLoadProgress(ImageLoader loader, float percentageComplete) {}\n+                @Override public void imageLoadWarning(ImageLoader loader, String message) {}\n+                @Override public void imageLoadMetaData(ImageLoader loader, ImageMetadata metadata) {}\n+            };\n+\n+            Field progressListenersField = ImageReader.class.getDeclaredField(\"progressListeners\");\n+            Field warningListenersField = ImageReader.class.getDeclaredField(\"warningListeners\");\n+            progressListenersField.setAccessible(true);\n+            warningListenersField.setAccessible(true);\n+            assertNull(progressListenersField.get(pngReader));\n+            assertNull(warningListenersField.get(pngReader));\n+\n+            loader.addListener(listener);\n+            assertEquals(1, ((List<?>)progressListenersField.get(pngReader)).size());\n+            assertEquals(1, ((List<?>)warningListenersField.get(pngReader)).size());\n+\n+            loader.removeListener(listener);\n+            assertNull(progressListenersField.get(pngReader));\n+            assertNull(warningListenersField.get(pngReader));\n+        }\n+    }\n+\n+    @Test\n+    void testProgressListener() throws Exception {\n+        try (InputStream stream = getClass().getResourceAsStream(\"\/test\/com\/sun\/javafx\/iio\/checker.png\")) {\n+            List<Float> progress = new ArrayList<>();\n+            ImageLoader loader = XImageLoaderFactory.getInstance().createImageLoader(stream);\n+            loader.addListener(new ImageLoadListener() {\n+                @Override\n+                public void imageLoadProgress(ImageLoader loader, float percentageComplete) {\n+                    progress.add(percentageComplete);\n+                }\n+\n+                @Override public void imageLoadWarning(ImageLoader loader, String message) {}\n+                @Override public void imageLoadMetaData(ImageLoader loader, ImageMetadata metadata) {}\n+            });\n+\n+            loader.load(0, -1, -1, true, false, 1, 1);\n+\n+            assertTrue(progress.size() > 1);\n+            assertEquals(0, progress.get(0));\n+            assertEquals(100, progress.get(progress.size() - 1));\n+\n+            List<Float> orderedProgress = new ArrayList<>(progress);\n+            orderedProgress.sort(Comparator.naturalOrder());\n+            assertEquals(orderedProgress, progress);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/iio\/javax\/XImageLoaderTest.java","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -43,1 +43,1 @@\n-        loader.load(0, 0, 0, true, true);\n+        loader.load(0, 0, 0, true, true, 1, 1);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/iio\/png\/PNGImageLoaderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import com.sun.javafx.image.impl.ByteAbgr;\n@@ -59,0 +60,2 @@\n+import com.sun.javafx.image.impl.IntBgr;\n+import com.sun.javafx.image.impl.IntRgb;\n@@ -343,0 +346,1 @@\n+        private final int ncomp;\n@@ -356,0 +360,1 @@\n+            this.ncomp = (ashift < 0) ? 3 : 4;\n@@ -425,0 +430,4 @@\n+        public int getNcomp() {\n+            return ncomp;\n+        }\n+\n@@ -439,1 +448,0 @@\n-\n@@ -441,0 +449,1 @@\n+        new ByteFormat(ByteAbgr.getter,    ByteAbgr.setter,     0, 3, 2, 1),\n@@ -445,1 +454,1 @@\n-        new ByteFormat(ByteRgb.getter,                         -1, 0, 1, 2),\n+        new ByteFormat(ByteRgb.getter,     ByteRgb.setter,     -1, 0, 1, 2),\n@@ -454,0 +463,2 @@\n+        new IntFormat(IntBgr.getter,     IntBgr.setter,     -1,  0, 8,16),\n+        new IntFormat(IntRgb.getter,     IntRgb.setter,     -1, 16, 8, 0),\n@@ -817,1 +828,1 @@\n-                \/\/ Should not be null - so far all int formats are full color+alpha\n+                if (ifmtsetter.getNcomp() < 4 && b2ipc == null) continue;\n@@ -975,1 +986,1 @@\n-                \/\/ Should not be null - so far all int formats are full color+alpha\n+                if (ifmtsetter.getNcomp() < 4 && i2ipc == null) continue;\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/image\/ConverterTest.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.prism;\n+\n+import com.sun.javafx.iio.ImageFrame;\n+import com.sun.javafx.iio.ImageMetadata;\n+import com.sun.javafx.iio.ImageStorage.ImageType;\n+import com.sun.prism.Image;\n+import com.sun.prism.PixelFormat;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import java.nio.Buffer;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ImageTest {\n+\n+    \/**\n+     * All supported {@link ImageType} to {@link PixelFormat} conversions.\n+     *\/\n+    enum SupportedConversions {\n+        GRAY(ImageType.GRAY, PixelFormat.BYTE_GRAY, 2,\n+            new byte[] { 1, 2, 3, 4 },\n+            new byte[] { 1, 2, 3, 4 }),\n+\n+        GRAY_ALPHA(ImageType.GRAY_ALPHA, PixelFormat.BYTE_BGRA_PRE, 4,\n+            new byte[] {\n+                100, 127, 50, 127,\n+                100, 0, 50, 0\n+            },\n+            new byte[] {\n+                50, 50, 50, 127, 25, 25, 25, 127,\n+                0, 0, 0, 0, 0, 0, 0, 0\n+            }),\n+\n+        GRAY_ALPHA_PRE(ImageType.GRAY_ALPHA_PRE, PixelFormat.BYTE_BGRA_PRE, 4,\n+            new byte[] {\n+                100, 127, 50, 127,\n+                100, 0, 50, 0\n+            },\n+            new byte[] {\n+                100, 100, 100, 127, 50, 50, 50, 127,\n+                100, 100, 100, 0, 50, 50, 50, 0\n+            }),\n+\n+        RGB(ImageType.RGB, PixelFormat.BYTE_RGB, 6,\n+            new byte[] {\n+                1, 2, 3, 4, 5, 6,\n+                7, 8, 9, 10, 11, 12\n+            },\n+            new byte[] {\n+                1, 2, 3, 4, 5, 6,\n+                7, 8, 9, 10, 11, 12\n+            }),\n+\n+        BGR(ImageType.BGR, PixelFormat.BYTE_RGB, 6,\n+            new byte[] {\n+                1, 2, 3, 4, 5, 6,\n+                7, 8, 9, 10, 11, 12\n+            },\n+            new byte[] {\n+                3, 2, 1, 6, 5, 4,\n+                9, 8, 7, 12, 11, 10\n+            }),\n+\n+        RGBA(ImageType.RGBA, PixelFormat.BYTE_BGRA_PRE, 8,\n+            new byte[] {\n+                100, 0, 0, 127, 0, 50, 0, 127,\n+                (byte)255, 127, 0, 127, 50, 60, 70, (byte)255\n+            },\n+            new byte[] {\n+                0, 0, 50, 127, 0, 25, 0, 127,\n+                0, 63, 127, 127, 70, 60, 50, (byte)255\n+            }),\n+\n+        RGBA_PRE(ImageType.RGBA_PRE, PixelFormat.BYTE_BGRA_PRE, 8,\n+            new byte[] {\n+                100, 0, 0, 127, 0, 50, 0, 127,\n+                (byte)255, 127, 0, 127, 50, 40, 30, 0\n+            },\n+            new byte[] {\n+                0, 0, 100, 127, 0, 50, 0, 127,\n+                0, 127, (byte)255, 127, 30, 40, 50, 0\n+            }),\n+\n+        BGRA(ImageType.BGRA, PixelFormat.BYTE_BGRA_PRE, 8,\n+            new byte[] {\n+                100, 0, 0, 127, 0, 50, 0, 127,\n+                (byte)255, 127, 0, 127, 50, 50, 50, 0\n+            },\n+            new byte[] {\n+                50, 0, 0, 127, 0, 25, 0, 127,\n+                127, 63, 0, 127, 0, 0, 0, 0\n+            }),\n+\n+        BGRA_PRE(ImageType.BGRA_PRE, PixelFormat.BYTE_BGRA_PRE, 8,\n+            new byte[] {\n+                100, 0, 0, 127, 0, 50, 0, 127,\n+                (byte)255, 127, 0, 127, 50, 50, 50, 0\n+            },\n+            new byte[] {\n+                100, 0, 0, 127, 0, 50, 0, 127,\n+                (byte)255, 127, 0, 127, 50, 50, 50, 0\n+            }),\n+\n+        ABGR(ImageType.ABGR, PixelFormat.BYTE_BGRA_PRE, 8,\n+            new byte[] {\n+                127, 100, 0, 0, 127, 50, 0, 100,\n+                127, (byte)255, 127, 0, 0, 50, 50, 50\n+            },\n+            new byte[] {\n+                50, 0, 0, 127, 25, 0, 50, 127,\n+                127, 63, 0, 127, 0, 0, 0, 0\n+            }),\n+\n+        ABGR_PRE(ImageType.ABGR_PRE, PixelFormat.BYTE_BGRA_PRE, 8,\n+            new byte[] {\n+                127, 100, 0, 0, 127, 50, 0, 100,\n+                127, (byte)255, 127, 0, 0, 50, 50, 50\n+            },\n+            new byte[] {\n+                100, 0, 0, 127, 50, 0, 100, 127,\n+                (byte)255, 127, 0, 127, 50, 50, 50, 0\n+            }),\n+\n+        INT_RGB(ImageType.INT_RGB, PixelFormat.INT_ARGB_PRE, 8,\n+            new int[] {\n+                rgb(50, 100, 150), rgb(10, 20, 30),\n+                rgb(40, 50, 60), rgb(255, 255, 255)\n+            },\n+            new int[] {\n+                argb(255, 50, 100, 150), argb(255, 10, 20, 30),\n+                argb(255, 40, 50, 60), argb(255, 255, 255, 255)\n+            }),\n+\n+        INT_BGR(ImageType.INT_BGR, PixelFormat.INT_ARGB_PRE, 8,\n+            new int[] {\n+                rgb(50, 100, 150), rgb(10, 20, 30),\n+                rgb(40, 50, 60), rgb(255, 255, 255)\n+            },\n+            new int[] {\n+                argb(255, 150, 100, 50), argb(255, 30, 20, 10),\n+                argb(255, 60, 50, 40), argb(255, 255, 255, 255)\n+            }),\n+\n+        INT_ARGB(ImageType.INT_ARGB, PixelFormat.INT_ARGB_PRE, 8,\n+            new int[] {\n+                argb(127, 50, 100, 150), argb(127, 10, 20, 30),\n+                argb(255, 40, 50, 60), argb(0, 255, 255, 255)\n+            },\n+            new int[] {\n+                argb(127, 25, 50, 75), argb(127, 5, 10, 15),\n+                argb(255, 40, 50, 60), argb(0, 0, 0, 0)\n+            }),\n+\n+        INT_ARGB_PRE(ImageType.INT_ARGB_PRE, PixelFormat.INT_ARGB_PRE, 8,\n+            new int[] {\n+                argb(127, 50, 100, 150), argb(127, 10, 20, 30),\n+                argb(255, 0, 0, 0), argb(0, 255, 255, 255)\n+            },\n+            new int[] {\n+                argb(127, 50, 100, 150), argb(127, 10, 20, 30),\n+                argb(255, 0, 0, 0), argb(0, 255, 255, 255)\n+            });\n+\n+        static int rgb(int r, int g, int b) {\n+            return 255 << 24 | (r & 0xff) << 16 | (g & 0xff) << 8 | (b & 0xff);\n+        }\n+\n+        static int argb(int a, int r, int g, int b) {\n+            return a << 24 | (r & 0xff) << 16 | (g & 0xff) << 8 | (b & 0xff);\n+        }\n+\n+        SupportedConversions(ImageType sourceType, PixelFormat targetType, int stride,\n+                             byte[] sourceData, byte[] targetData) {\n+            this(sourceType, targetType, stride, ByteBuffer.wrap(sourceData), ByteBuffer.wrap(targetData));\n+        }\n+\n+        SupportedConversions(ImageType sourceType, PixelFormat targetType, int stride,\n+                             int[] sourceData, int[] targetData) {\n+            this(sourceType, targetType, stride, IntBuffer.wrap(sourceData), IntBuffer.wrap(targetData));\n+        }\n+\n+        SupportedConversions(ImageType sourceType, PixelFormat targetType, int stride,\n+                             Buffer sourceData, Buffer targetData) {\n+            this.sourceType = sourceType;\n+            this.targetType = targetType;\n+            this.sourceData = sourceData;\n+            this.targetData = targetData;\n+            this.stride = stride;\n+        }\n+\n+        final ImageType sourceType;\n+        final PixelFormat targetType;\n+        final Buffer sourceData;\n+        final Buffer targetData;\n+        final int stride;\n+    }\n+\n+    \/**\n+     * Asserts that the content of an {@link ImageFrame} is correctly converted to {@link Image}\n+     * for all supported image formats.\n+     *\/\n+    @ParameterizedTest\n+    @EnumSource(SupportedConversions.class)\n+    void convertImageFrame(SupportedConversions conversion) {\n+        var imageFrame = new ImageFrame(\n+            conversion.sourceType, conversion.sourceData, 2, 2, conversion.stride, null,\n+            new ImageMetadata(null, null, null, null, null, null, null, 2, 2, null, null, null));\n+\n+        var image = Image.convertImageFrame(imageFrame);\n+\n+        assertEquals(2, image.getWidth());\n+        assertEquals(2, image.getHeight());\n+        assertEquals(conversion.targetType, image.getPixelFormat());\n+        assertEquals(conversion.targetData, image.getPixelBuffer());\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/prism\/ImageTest.java","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"filename":"modules\/javafx.graphics\/src\/test\/resources\/test\/com\/sun\/javafx\/iio\/checker.bmp","binary":true,"status":"added"}]}