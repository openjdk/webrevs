{"files":[{"patch":"@@ -45,0 +45,6 @@\n+\n+        \/\/ If no timer was started, we complete the transition immediately.\n+        if (timer == null) {\n+            onUpdate(1);\n+            onStop();\n+        }\n@@ -87,9 +93,0 @@\n-\n-    \/**\n-     * Returns whether the target value of the transition associated with the specified mediator\n-     * equals the target value of the transition associated with this mediator.\n-     *\n-     * @param mediator the other mediator\n-     * @return {@code true} if the target values are equal, {@code false} otherwise\n-     *\/\n-    public abstract boolean equalsTargetValue(TransitionMediator mediator);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/TransitionMediator.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-            mediator.onUpdate(1);\n@@ -95,12 +94,2 @@\n-            \/\/ If we already have a timer that targets the specified property, and the existing\n-            \/\/ timer has the same target value as the new timer, we discard the new timer and\n-            \/\/ return the existing timer. This scenario can sometimes happen when a CSS value\n-            \/\/ is redundantly applied, which would cause unexpected animations if we allowed\n-            \/\/ the new timer to interrupt the existing timer.\n-            if (existingTimer.mediator.equalsTargetValue(mediator)) {\n-                return existingTimer;\n-            }\n-\n-            \/\/ Here we know that the new timer has a different target value than the existing\n-            \/\/ timer, which means that the new timer is a reversing timer that needs to be\n-            \/\/ adjusted by the reversing shortening algorithm.\n+            \/\/ If we already have a timer for the styleable property, the new timer is a reversing\n+            \/\/ timer that needs to be adjusted by the reversing shortening algorithm.\n@@ -116,1 +105,0 @@\n-            mediator.onUpdate(1);\n@@ -127,3 +115,0 @@\n-        \/\/ If the combined duration is zero, we just call onUpdate without starting a timer.\n-        \/\/ This updates the value of the target property to the end value, and no events will be fired.\n-        mediator.onUpdate(1);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/TransitionTimer.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -75,2 +75,10 @@\n-        if (transition != null) {\n-            mediator = new TransitionMediatorImpl(get(), v != null && v);\n+        boolean newValue = v != null && v;\n+\n+        if (transition == null) {\n+            set(newValue);\n+        } else if (mediator == null || mediator.newValue != newValue) {\n+            \/\/ We only start a new transition if the new target value is different from the target\n+            \/\/ value of the existing transition. This scenario can sometimes happen when a CSS value\n+            \/\/ is redundantly applied, which would cause unexpected animations if we allowed the new\n+            \/\/ transition to interrupt the existing transition.\n+            mediator = new TransitionMediatorImpl(get(), newValue);\n@@ -78,2 +86,0 @@\n-        } else {\n-            setValue(v);\n@@ -130,1 +136,7 @@\n-            mediator = null;\n+            \/\/ When the transition is cancelled or completed, we clear the reference to this mediator.\n+            \/\/ However, when this mediator was cancelled by a reversing transition, the 'mediator' field\n+            \/\/ refers to the reversing mediator, and not to this mediator. We need to be careful to only\n+            \/\/ clear references to this mediator.\n+            if (mediator == this) {\n+                mediator = null;\n+            }\n@@ -137,5 +149,0 @@\n-\n-        @Override\n-        public boolean equalsTargetValue(TransitionMediator mediator) {\n-            return newValue == ((TransitionMediatorImpl) mediator).newValue;\n-        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableBooleanProperty.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -77,2 +77,10 @@\n-        if (transition != null) {\n-            mediator = new TransitionMediatorImpl(get(), v != null ? v.doubleValue() : 0);\n+        double newValue = v != null ? v.doubleValue() : 0;\n+\n+        if (transition == null) {\n+            set(newValue);\n+        } else if (mediator == null || mediator.newValue != newValue) {\n+            \/\/ We only start a new transition if the new target value is different from the target\n+            \/\/ value of the existing transition. This scenario can sometimes happen when a CSS value\n+            \/\/ is redundantly applied, which would cause unexpected animations if we allowed the new\n+            \/\/ transition to interrupt the existing transition.\n+            mediator = new TransitionMediatorImpl(get(), newValue);\n@@ -80,2 +88,0 @@\n-        } else {\n-            setValue(v);\n@@ -132,1 +138,7 @@\n-            mediator = null;\n+            \/\/ When the transition is cancelled or completed, we clear the reference to this mediator.\n+            \/\/ However, when this mediator was cancelled by a reversing transition, the 'mediator' field\n+            \/\/ refers to the reversing mediator, and not to this mediator. We need to be careful to only\n+            \/\/ clear references to this mediator.\n+            if (mediator == this) {\n+                mediator = null;\n+            }\n@@ -139,5 +151,0 @@\n-\n-        @Override\n-        public boolean equalsTargetValue(TransitionMediator mediator) {\n-            return newValue == ((TransitionMediatorImpl) mediator).newValue;\n-        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableDoubleProperty.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -75,2 +75,10 @@\n-        if (transition != null) {\n-            mediator = new TransitionMediatorImpl(get(), v != null ? v.floatValue() : 0);\n+        float newValue = v != null ? v.floatValue() : 0;\n+\n+        if (transition == null) {\n+            set(newValue);\n+        } else if (mediator == null || mediator.newValue != newValue) {\n+            \/\/ We only start a new transition if the new target value is different from the target\n+            \/\/ value of the existing transition. This scenario can sometimes happen when a CSS value\n+            \/\/ is redundantly applied, which would cause unexpected animations if we allowed the new\n+            \/\/ transition to interrupt the existing transition.\n+            mediator = new TransitionMediatorImpl(get(), newValue);\n@@ -78,2 +86,0 @@\n-        } else {\n-            setValue(v);\n@@ -130,1 +136,7 @@\n-            mediator = null;\n+            \/\/ When the transition is cancelled or completed, we clear the reference to this mediator.\n+            \/\/ However, when this mediator was cancelled by a reversing transition, the 'mediator' field\n+            \/\/ refers to the reversing mediator, and not to this mediator. We need to be careful to only\n+            \/\/ clear references to this mediator.\n+            if (mediator == this) {\n+                mediator = null;\n+            }\n@@ -137,5 +149,0 @@\n-\n-        @Override\n-        public boolean equalsTargetValue(TransitionMediator mediator) {\n-            return newValue == ((TransitionMediatorImpl) mediator).newValue;\n-        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableFloatProperty.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -75,2 +75,10 @@\n-        if (transition != null) {\n-            mediator = new TransitionMediatorImpl(get(), v != null ? v.intValue() : 0);\n+        int newValue = v != null ? v.intValue() : 0;\n+\n+        if (transition == null) {\n+            set(newValue);\n+        } else if (mediator == null || mediator.newValue != newValue) {\n+            \/\/ We only start a new transition if the new target value is different from the target\n+            \/\/ value of the existing transition. This scenario can sometimes happen when a CSS value\n+            \/\/ is redundantly applied, which would cause unexpected animations if we allowed the new\n+            \/\/ transition to interrupt the existing transition.\n+            mediator = new TransitionMediatorImpl(get(), newValue);\n@@ -78,2 +86,0 @@\n-        } else {\n-            setValue(v);\n@@ -130,1 +136,7 @@\n-            mediator = null;\n+            \/\/ When the transition is cancelled or completed, we clear the reference to this mediator.\n+            \/\/ However, when this mediator was cancelled by a reversing transition, the 'mediator' field\n+            \/\/ refers to the reversing mediator, and not to this mediator. We need to be careful to only\n+            \/\/ clear references to this mediator.\n+            if (mediator == this) {\n+                mediator = null;\n+            }\n@@ -137,5 +149,0 @@\n-\n-        @Override\n-        public boolean equalsTargetValue(TransitionMediator mediator) {\n-            return newValue == ((TransitionMediatorImpl) mediator).newValue;\n-        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableIntegerProperty.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -77,2 +77,10 @@\n-        if (transition != null) {\n-            mediator = new TransitionMediatorImpl(get(), v != null ? v.longValue() : 0);\n+        long newValue = v != null ? v.longValue() : 0;\n+\n+        if (transition == null) {\n+            set(newValue);\n+        } else if (mediator == null || mediator.newValue != newValue) {\n+            \/\/ We only start a new transition if the new target value is different from the target\n+            \/\/ value of the existing transition. This scenario can sometimes happen when a CSS value\n+            \/\/ is redundantly applied, which would cause unexpected animations if we allowed the new\n+            \/\/ transition to interrupt the existing transition.\n+            mediator = new TransitionMediatorImpl(get(), newValue);\n@@ -80,2 +88,0 @@\n-        } else {\n-            setValue(v);\n@@ -132,1 +138,7 @@\n-            mediator = null;\n+            \/\/ When the transition is cancelled or completed, we clear the reference to this mediator.\n+            \/\/ However, when this mediator was cancelled by a reversing transition, the 'mediator' field\n+            \/\/ refers to the reversing mediator, and not to this mediator. We need to be careful to only\n+            \/\/ clear references to this mediator.\n+            if (mediator == this) {\n+                mediator = null;\n+            }\n@@ -139,5 +151,0 @@\n-\n-        @Override\n-        public boolean equalsTargetValue(TransitionMediator mediator) {\n-            return newValue == ((TransitionMediatorImpl) mediator).newValue;\n-        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableLongProperty.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -93,1 +93,7 @@\n-            if (transition != null) {\n+            if (transition == null) {\n+                set(newValue);\n+            } else if (mediator == null || !Objects.equals(mediator.newValue, newValue)) {\n+                \/\/ We only start a new transition if the new target value is different from the target\n+                \/\/ value of the existing transition. This scenario can sometimes happen when a CSS value\n+                \/\/ is redundantly applied, which would cause unexpected animations if we allowed the new\n+                \/\/ transition to interrupt the existing transition.\n@@ -96,2 +102,0 @@\n-            } else {\n-                set(newValue);\n@@ -155,1 +159,7 @@\n-            mediator = null;\n+            \/\/ When the transition is cancelled or completed, we clear the reference to this mediator.\n+            \/\/ However, when this mediator was cancelled by a reversing transition, the 'mediator' field\n+            \/\/ refers to the reversing mediator, and not to this mediator. We need to be careful to only\n+            \/\/ clear references to this mediator.\n+            if (mediator == this) {\n+                mediator = null;\n+            }\n@@ -162,6 +172,0 @@\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public boolean equalsTargetValue(TransitionMediator mediator) {\n-            return Objects.equals(newValue, ((TransitionMediatorImpl)mediator).newValue);\n-        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableObjectProperty.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -86,5 +86,0 @@\n-\n-        @Override\n-        public boolean equalsTargetValue(TransitionMediator mediator) {\n-            return false;\n-        }\n@@ -224,21 +219,0 @@\n-\n-    @Test\n-    public void testRedundantTransitionIsDiscarded() {\n-        var transition = new TransitionDefinition(\"-fx-opacity\", seconds(1), ZERO, LINEAR);\n-\n-        var timer1 = new TimerWrapper(new TestTransitionMediator() {\n-            @Override public boolean equalsTargetValue(TransitionMediator mediator) {\n-                return true;\n-            }\n-        });\n-\n-        var timer2 = new TimerWrapper(new TestTransitionMediator());\n-\n-        \/\/ Start timer1. This adds it to the list of running timers.\n-        timer1.run(transition);\n-\n-        \/\/ Now we start timer2. Since both timers target the same property of the same node, and timer2\n-        \/\/ has the same target value as timer1, it is discarded and timer1 is returned instead.\n-        timer2.run(transition);\n-        assertSame(timer1.timer, timer2.timer);\n-    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/css\/TransitionTimerTest.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.css;\n+\n+import com.sun.javafx.css.TransitionDefinition;\n+import com.sun.javafx.css.TransitionMediator;\n+import com.sun.javafx.scene.NodeHelper;\n+import javafx.animation.Interpolator;\n+import javafx.css.CssMetaData;\n+import javafx.css.SimpleStyleableBooleanProperty;\n+import javafx.css.SimpleStyleableDoubleProperty;\n+import javafx.css.SimpleStyleableFloatProperty;\n+import javafx.css.SimpleStyleableIntegerProperty;\n+import javafx.css.SimpleStyleableLongProperty;\n+import javafx.css.SimpleStyleableObjectProperty;\n+import javafx.css.StyleOrigin;\n+import javafx.css.Styleable;\n+import javafx.css.StyleableBooleanProperty;\n+import javafx.css.StyleableDoubleProperty;\n+import javafx.css.StyleableFloatProperty;\n+import javafx.css.StyleableIntegerProperty;\n+import javafx.css.StyleableLongProperty;\n+import javafx.css.StyleableObjectProperty;\n+import javafx.css.StyleableProperty;\n+import javafx.css.converter.BooleanConverter;\n+import javafx.css.converter.ColorConverter;\n+import javafx.css.converter.SizeConverter;\n+import javafx.scene.Group;\n+import javafx.scene.Scene;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Stage;\n+import javafx.util.Duration;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import java.lang.reflect.Field;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class StyleableProperty_transition_Test {\n+\n+    static final CssMetaData<Styleable, Boolean> booleanPropertyMetadata = new CssMetaData<>(\n+            \"-fx-boolean-property\", BooleanConverter.getInstance(), false) {\n+        @Override public boolean isSettable(Styleable styleable) { return true; }\n+        @Override public StyleableProperty<Boolean> getStyleableProperty(Styleable styleable) { return booleanProperty; }\n+    };\n+\n+    static final CssMetaData<Styleable, Number> doublePropertyMetadata = new CssMetaData<>(\n+            \"-fx-double-property\", SizeConverter.getInstance(), 0) {\n+        @Override public boolean isSettable(Styleable styleable) { return true; }\n+        @Override public StyleableProperty<Number> getStyleableProperty(Styleable styleable) { return doubleProperty; }\n+    };\n+\n+    static final CssMetaData<Styleable, Number> floatPropertyMetadata = new CssMetaData<>(\n+            \"-fx-float-property\", SizeConverter.getInstance(), 0) {\n+        @Override public boolean isSettable(Styleable styleable) { return true; }\n+        @Override public StyleableProperty<Number> getStyleableProperty(Styleable styleable) { return floatProperty; }\n+    };\n+\n+    static final CssMetaData<Styleable, Number> integerPropertyMetadata = new CssMetaData<>(\n+            \"-fx-integer-property\", SizeConverter.getInstance(), 0) {\n+        @Override public boolean isSettable(Styleable styleable) { return true; }\n+        @Override public StyleableProperty<Number> getStyleableProperty(Styleable styleable) { return integerProperty; }\n+    };\n+\n+    static final CssMetaData<Styleable, Number> longPropertyMetadata = new CssMetaData<>(\n+            \"-fx-long-property\", SizeConverter.getInstance(), 0) {\n+        @Override public boolean isSettable(Styleable styleable) { return true; }\n+        @Override public StyleableProperty<Number> getStyleableProperty(Styleable styleable) { return longProperty; }\n+    };\n+\n+    static final CssMetaData<Styleable, Color> objectPropertyMetadata = new CssMetaData<>(\n+            \"-fx-object-property\", ColorConverter.getInstance(), Color.RED) {\n+        @Override public boolean isSettable(Styleable styleable) { return true; }\n+        @Override public StyleableProperty<Color> getStyleableProperty(Styleable styleable) { return objectProperty; }\n+    };\n+\n+    static final Group testBean = new Group() {\n+        {\n+            NodeHelper.getTransitionProperty(this).setValue(new TransitionDefinition[] {\n+                new TransitionDefinition(\"-fx-boolean-property\", Duration.ONE, Duration.ZERO, Interpolator.LINEAR),\n+                new TransitionDefinition(\"-fx-double-property\", Duration.ONE, Duration.ZERO, Interpolator.LINEAR),\n+                new TransitionDefinition(\"-fx-float-property\", Duration.ONE, Duration.ZERO, Interpolator.LINEAR),\n+                new TransitionDefinition(\"-fx-integer-property\", Duration.ONE, Duration.ZERO, Interpolator.LINEAR),\n+                new TransitionDefinition(\"-fx-long-property\", Duration.ONE, Duration.ZERO, Interpolator.LINEAR),\n+                new TransitionDefinition(\"-fx-object-property\", Duration.ONE, Duration.ZERO, Interpolator.LINEAR)\n+            });\n+        }\n+    };\n+\n+    static StyleableBooleanProperty booleanProperty;\n+    static StyleableDoubleProperty doubleProperty;\n+    static StyleableFloatProperty floatProperty;\n+    static StyleableIntegerProperty integerProperty;\n+    static StyleableLongProperty longProperty;\n+    static StyleableObjectProperty<Color> objectProperty;\n+\n+    static TransitionMediator getTransitionMediator(StyleableProperty<?> property) {\n+        Function<Class<?>, Field> getField = cls -> {\n+            try {\n+                var field = cls.getDeclaredField(\"mediator\");\n+                field.setAccessible(true);\n+                return field;\n+            } catch (NoSuchFieldException e) {\n+                return null;\n+            }\n+        };\n+\n+        Class<?> cls = property.getClass();\n+        while (cls != null) {\n+            Field field = getField.apply(cls);\n+            if (field != null) {\n+                try {\n+                    return (TransitionMediator)field.get(property);\n+                } catch (IllegalAccessException e) {\n+                    throw new AssertionError(e);\n+                }\n+            }\n+\n+            cls = cls.getSuperclass();\n+        }\n+\n+        throw new AssertionError();\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    record TestRun(StyleableProperty property, Object defaultValue, Object newValue) {}\n+\n+    static Stream<TestRun> transitionParameters() {\n+        booleanProperty = new SimpleStyleableBooleanProperty(booleanPropertyMetadata, testBean, null);\n+        doubleProperty = new SimpleStyleableDoubleProperty(doublePropertyMetadata, testBean, null);\n+        floatProperty = new SimpleStyleableFloatProperty(floatPropertyMetadata, testBean, null);\n+        integerProperty = new SimpleStyleableIntegerProperty(integerPropertyMetadata, testBean, null);\n+        longProperty = new SimpleStyleableLongProperty(longPropertyMetadata, testBean, null);\n+        objectProperty = new SimpleStyleableObjectProperty<>(objectPropertyMetadata, testBean, null, Color.RED);\n+\n+        return Stream.of(\n+            new TestRun(booleanProperty, false, true),\n+            new TestRun(doubleProperty, 0, 1),\n+            new TestRun(floatProperty, 0, 1),\n+            new TestRun(integerProperty, 0, 1),\n+            new TestRun(longProperty, 0, 1),\n+            new TestRun(objectProperty, Color.RED, Color.GREEN)\n+        );\n+    }\n+\n+    Scene scene;\n+    Stage stage;\n+\n+    @BeforeEach\n+    void setup() {\n+        scene = new Scene(new Group(testBean));\n+        stage = new Stage();\n+        stage.setScene(scene);\n+        stage.show();\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        ((Group)scene.getRoot()).getChildren().clear();\n+        stage.close();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"transitionParameters\")\n+    @SuppressWarnings(\"unchecked\")\n+    void testRedundantTransitionIsDiscarded(TestRun testRun) {\n+        \/\/ Setting a value for the first time doesn't start a transition.\n+        testRun.property.applyStyle(StyleOrigin.USER, testRun.defaultValue);\n+        var mediator1 = getTransitionMediator(testRun.property);\n+        assertNull(mediator1);\n+\n+        \/\/ Start the transition. This adds it to the list of running transitions.\n+        testRun.property.applyStyle(StyleOrigin.USER, testRun.newValue);\n+        var mediator2 = getTransitionMediator(testRun.property);\n+        assertNotNull(mediator2);\n+\n+        \/\/ The next call to applyStyle() has the same target value as the last one,\n+        \/\/ making it redundant. No new transition is started.\n+        testRun.property.applyStyle(StyleOrigin.USER, testRun.newValue);\n+        var mediator3 = getTransitionMediator(testRun.property);\n+        assertSame(mediator2, mediator3);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"transitionParameters\")\n+    @SuppressWarnings(\"unchecked\")\n+    void testReversingTransitionIsNotDiscarded(TestRun testRun) {\n+        \/\/ Setting a value for the first time doesn't start a transition.\n+        testRun.property.applyStyle(StyleOrigin.USER, testRun.defaultValue);\n+        var mediator1 = getTransitionMediator(testRun.property);\n+        assertNull(mediator1);\n+\n+        \/\/ Start the transition. This adds it to the list of running transitions.\n+        testRun.property.applyStyle(StyleOrigin.USER, testRun.newValue);\n+        var mediator2 = getTransitionMediator(testRun.property);\n+        assertNotNull(mediator2);\n+\n+        \/\/ The next call to applyStyle() has a different target value as the last one,\n+        \/\/ which makes this a reversing transition.\n+        testRun.property.applyStyle(StyleOrigin.USER, testRun.defaultValue);\n+        var mediator3 = getTransitionMediator(testRun.property);\n+        assertNotNull(mediator3);\n+        assertNotSame(mediator2, mediator3);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/css\/StyleableProperty_transition_Test.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"}]}