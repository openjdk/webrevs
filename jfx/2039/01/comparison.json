{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,1 +147,3 @@\n-    private int perpendiculardfddf(final double[] pts, final int off) {\n+    private int perpendiculardfddf(final double[] pts, final int off,\n+                                   final double A, final double B)\n+    {\n@@ -158,1 +160,1 @@\n-        return Helpers.cubicRootsInAB(a, b, c, d, pts, off, 0.0d, 1.0d);\n+        return Helpers.cubicRootsInAB(a, b, c, d, pts, off, A, B);\n@@ -174,1 +176,3 @@\n-    int rootsOfROCMinusW(final double[] roots, final int off, final double w2, final double err) {\n+    int rootsOfROCMinusW(final double[] roots, final int off, final double w2,\n+                         final double A, final double B)\n+    {\n@@ -179,1 +183,2 @@\n-        final int end = off + perpendiculardfddf(roots, off);\n+        final int end = off + perpendiculardfddf(roots, off, A, B);\n+        Helpers.isort(roots, off, end);\n@@ -182,1 +187,3 @@\n-        double t0 = 0.0d, ft0 = ROCsq(t0) - w2;\n+        double t0 = 0.0d;\n+        double ft0 = eliminateInf(ROCsq(t0) - w2);\n+        double t1, ft1;\n@@ -185,1 +192,2 @@\n-            double t1 = roots[i], ft1 = ROCsq(t1) - w2;\n+            t1 = roots[i];\n+            ft1 = eliminateInf(ROCsq(t1) - w2);\n@@ -191,1 +199,1 @@\n-                roots[ret++] = falsePositionROCsqMinusX(t0, t1, w2, err);\n+                roots[ret++] = falsePositionROCsqMinusX(t0, t1, ft0, ft1, w2, A); \/\/ A = err\n@@ -196,1 +204,0 @@\n-\n@@ -200,3 +207,6 @@\n-    private static double eliminateInf(final double x) {\n-        return (x == Double.POSITIVE_INFINITY ? Double.MAX_VALUE :\n-               (x == Double.NEGATIVE_INFINITY ? Double.MIN_VALUE : x));\n+    private final static double MAX_ROC_SQ = 1e20;\n+\n+    private static double eliminateInf(final double x2) {\n+        \/\/ limit the value of x to avoid numerical problems (smaller step):\n+        \/\/ must handle NaN and +Infinity:\n+        return (x2 <= MAX_ROC_SQ) ? x2 : MAX_ROC_SQ;\n@@ -213,0 +223,1 @@\n+                                            final double ft0, final double ft1,\n@@ -217,2 +228,2 @@\n-        double t = t1, ft = eliminateInf(ROCsq(t) - w2);\n-        double s = t0, fs = eliminateInf(ROCsq(s) - w2);\n+        double s = t0, fs = eliminateInf(ft0);\n+        double t = t1, ft = eliminateInf(ft1);\n@@ -221,1 +232,1 @@\n-        for (int i = 0; i < iterLimit && Math.abs(t - s) > err * Math.abs(t + s); i++) {\n+        for (int i = 0; i < iterLimit && Math.abs(t - s) > err; i++) {\n@@ -223,1 +234,1 @@\n-            fr = ROCsq(r) - w2;\n+            fr = eliminateInf(ROCsq(r) - w2);\n@@ -244,1 +255,1 @@\n-        return r;\n+        return (Math.abs(ft) <= Math.abs(fs)) ? t : s;\n@@ -259,4 +270,4 @@\n-        final double dx2dy2 = dx * dx + dy * dy;\n-        final double ddx2ddy2 = ddx * ddx + ddy * ddy;\n-        final double ddxdxddydy = ddx * dx + ddy * dy;\n-        return dx2dy2 * ((dx2dy2 * dx2dy2) \/ (dx2dy2 * ddx2ddy2 - ddxdxddydy * ddxdxddydy));\n+        final double dx2dy2 = dx * dx + dy * dy; \/\/ positive\n+        final double dxddyddxdy = dx * ddy - dy * ddx;\n+        \/\/ may return +Infinity if dxddyddxdy = 0 or NaN if 0\/0:\n+        return (dx2dy2 * dx2dy2 * dx2dy2) \/ (dxddyddxdy * dxddyddxdy); \/\/ both positive\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/Curve.java","additions":32,"deletions":21,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,5 @@\n-final class Helpers implements MarlinConst {\n+public final class Helpers implements MarlinConst {\n+\n+    private final static double T_ERR = 1e-4;\n+    private final static double T_A = T_ERR;\n+    private final static double T_B = 1.0 - T_ERR;\n@@ -40,0 +44,3 @@\n+    \/** use lower precision like former Pisces and Marlin (float-precision) *\/\n+    public static double ulp(final double value) { return Math.ulp((float)value); }\n+\n@@ -325,1 +332,1 @@\n-        ret += c.rootsOfROCMinusW(ts, ret, w2, 0.0001d);\n+        ret += c.rootsOfROCMinusW(ts, ret, w2, T_A, T_B);\n@@ -327,2 +334,2 @@\n-        ret = filterOutNotInAB(ts, 0, ret, 0.0001d, 0.9999d);\n-        isort(ts, ret);\n+        ret = filterOutNotInAB(ts, 0, ret, T_A, T_B);\n+        isort(ts, 0, ret);\n@@ -357,1 +364,1 @@\n-        isort(ts, ret);\n+        isort(ts, 0, ret);\n@@ -377,2 +384,2 @@\n-    static void isort(final double[] a, final int len) {\n-        for (int i = 1, j; i < len; i++) {\n+    static void isort(final double[] a, final int off, final int len) {\n+        for (int i = off + 1, j; i < len; i++) {\n@@ -381,1 +388,1 @@\n-            for (; j >= 0 && a[j] > ai; j--) {\n+            for (; j >= off && a[j] > ai; j--) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/Helpers.java","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -880,2 +880,2 @@\n-        final boolean p1eqp2 = Helpers.withinD(dx1, dy1, 6.0d * Math.ulp(y2));\n-        final boolean p3eqp4 = Helpers.withinD(dx4, dy4, 6.0d * Math.ulp(y4));\n+        final boolean p1eqp2 = Helpers.withinD(dx1, dy1, 6.0d * Helpers.ulp(y2));\n+        final boolean p3eqp4 = Helpers.withinD(dx4, dy4, 6.0d * Helpers.ulp(y4));\n@@ -899,1 +899,1 @@\n-        if (Helpers.within(dotsq, l1sq * l4sq, 4.0d * Math.ulp(dotsq))) {\n+        if (Helpers.within(dotsq, l1sq * l4sq, 4.0d * Helpers.ulp(dotsq))) {\n@@ -1072,2 +1072,2 @@\n-        final boolean p1eqp2 = Helpers.withinD(dx12, dy12, 6.0d * Math.ulp(y2));\n-        final boolean p2eqp3 = Helpers.withinD(dx23, dy23, 6.0d * Math.ulp(y3));\n+        final boolean p1eqp2 = Helpers.withinD(dx12, dy12, 6.0d * Helpers.ulp(y2));\n+        final boolean p2eqp3 = Helpers.withinD(dx23, dy23, 6.0d * Helpers.ulp(y3));\n@@ -1085,1 +1085,1 @@\n-        if (Helpers.within(dotsq, l1sq * l3sq, 4.0d * Math.ulp(dotsq))) {\n+        if (Helpers.within(dotsq, l1sq * l3sq, 4.0d * Helpers.ulp(dotsq))) {\n@@ -1331,1 +1331,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/Stroker.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.marlin.Helpers;\n@@ -235,1 +236,1 @@\n-        return Math.abs(num) < 2.0d * Math.ulp(num);\n+        return Math.abs(num) < 2.0d * Helpers.ulp(num);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/impl\/shape\/DMarlinPrismUtils.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}