{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -261,1 +261,1 @@\n-            updateItem();\n+            updateItem(-1);\n@@ -294,1 +294,1 @@\n-        index = getIndex();\n+        super.indexChanged(oldIndex, newIndex);\n@@ -298,1 +298,1 @@\n-        updateItem();\n+        updateItem(oldIndex);\n@@ -301,1 +301,0 @@\n-\/\/        oldIndex = index;\n@@ -391,1 +390,0 @@\n-    private int index = -1;\n@@ -394,1 +392,1 @@\n-    private void updateItem() {\n+    private void updateItem(int oldIndex) {\n@@ -399,1 +397,2 @@\n-        boolean valid = index >=0 && index < tv.getExpandedItemCount();\n+        final int newIndex = getIndex();\n+        boolean valid = newIndex >= 0 && newIndex < tv.getExpandedItemCount();\n@@ -408,1 +407,1 @@\n-            final TreeItem<T> newTreeItem = tv.getTreeItem(index);\n+            final TreeItem<T> newTreeItem = tv.getTreeItem(newIndex);\n@@ -410,0 +409,1 @@\n+            final T oldValue = oldTreeItem == null ? null : oldTreeItem.getValue();\n@@ -417,5 +417,11 @@\n-            \/\/ There used to be conditional code here to prevent updateItem from\n-            \/\/ being called when the value didn't change, but that led us to\n-            \/\/ issues such as RT-33108, where the value didn't change but the item\n-            \/\/ we needed to be listening to did. Without calling updateItem we\n-            \/\/ were breaking things, so once again the conditionals are gone.\n+            \/\/ RT-35864 - if the index didn't change, then avoid calling updateItem\n+            \/\/ unless the item has changed.\n+            if (oldIndex == newIndex) {\n+                if (!isItemChanged(oldValue, newValue)) {\n+                    \/\/ RT-37054:  we break out of the if\/else code here and\n+                    \/\/ proceed with the code following this, so that we may\n+                    \/\/ still update references, listeners, etc as required.\n+                    return;\n+                }\n+            }\n+\n@@ -441,1 +447,1 @@\n-        if (index == -1 || getTreeTableView() == null) return;\n+        if (getIndex() == -1 || getTreeTableView() == null) return;\n@@ -451,1 +457,1 @@\n-        boolean isSelected = !sm.isCellSelectionEnabled() && sm.isSelected(index);\n+        boolean isSelected = !sm.isCellSelectionEnabled() && sm.isSelected(getIndex());\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeTableRow.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import javafx.scene.control.IndexedCell;\n@@ -46,0 +47,3 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n@@ -51,0 +55,1 @@\n+import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;\n@@ -1133,0 +1138,49 @@\n+    \/**\n+     * Same index and underlying item should not cause the updateItem(..) method to be called.\n+     *\/\n+    @Test\n+    public void testSameIndexAndItemShouldNotUpdateItem() {\n+        AtomicInteger counter = new AtomicInteger();\n+\n+        list.setCellFactory(e -> new ListCell<>() {\n+            @Override\n+            protected void updateItem(String item, boolean empty) {\n+                counter.incrementAndGet();\n+                super.updateItem(item, empty);\n+            }\n+        });\n+\n+        stageLoader = new StageLoader(list);\n+\n+        counter.set(0);\n+        IndexedCell<String> cell = VirtualFlowTestUtils.getCell(list, 0);\n+        cell.updateIndex(0);\n+\n+        assertEquals(0, counter.get());\n+    }\n+\n+    \/**\n+     * The contract of a {@link ListCell} is that isItemChanged(..)\n+     * is called when the index is 'changed' to the same number as the old one, to evaluate if we need to call\n+     * updateItem(..).\n+     *\/\n+    @Test\n+    public void testSameIndexIsItemsChangedShouldBeCalled() {\n+        AtomicBoolean isItemChangedCalled = new AtomicBoolean();\n+\n+        list.setCellFactory(e -> new ListCell<>() {\n+            @Override\n+            protected boolean isItemChanged(String oldItem, String newItem) {\n+                isItemChangedCalled.set(true);\n+                return super.isItemChanged(oldItem, newItem);\n+            }\n+        });\n+\n+        stageLoader = new StageLoader(list);\n+\n+        IndexedCell<String> cell = VirtualFlowTestUtils.getCell(list, 0);\n+        cell.updateIndex(0);\n+\n+        assertTrue(isItemChangedCalled.get());\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ListCellTest.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -587,0 +587,3 @@\n+\n+        stageLoader = new StageLoader(list);\n+\n@@ -605,0 +608,29 @@\n+    @Test\n+    public void testSetItemsShouldUpdateTheCells() {\n+        final ListView<RT_22463_Person> list = new ListView<>();\n+\n+        RT_22463_Person p1 = new RT_22463_Person();\n+        p1.setId(1L);\n+        p1.setName(\"name1\");\n+        RT_22463_Person p2 = new RT_22463_Person();\n+        p2.setId(2L);\n+        p2.setName(\"name2\");\n+\n+        stageLoader = new StageLoader(list);\n+\n+        list.setItems(FXCollections.observableArrayList(p1, p2));\n+        VirtualFlowTestUtils.assertCellTextEquals(list, 0, \"name1\");\n+        VirtualFlowTestUtils.assertCellTextEquals(list, 1, \"name2\");\n+\n+        \/\/ Replace all Items by the new ones. Cells should get updated.\n+        RT_22463_Person newP1 = new RT_22463_Person();\n+        newP1.setId(1L);\n+        newP1.setName(\"updated name1\");\n+        RT_22463_Person newP2 = new RT_22463_Person();\n+        newP2.setId(2L);\n+        newP2.setName(\"updated name2\");\n+        list.setItems(FXCollections.observableArrayList(newP1, newP2));\n+        VirtualFlowTestUtils.assertCellTextEquals(list, 0, \"updated name1\");\n+        VirtualFlowTestUtils.assertCellTextEquals(list, 1, \"updated name2\");\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ListViewTest.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -33,0 +35,1 @@\n+import javafx.scene.control.IndexedCell;\n@@ -928,0 +931,51 @@\n+    \/**\n+     * Same index and underlying item should not cause the updateItem(..) method to be called.\n+     *\/\n+    @Test\n+    public void testSameIndexAndItemShouldNotUpdateItem() {\n+        AtomicInteger counter = new AtomicInteger();\n+\n+        editingColumn.setCellFactory(view -> new TableCell<>() {\n+            @Override\n+            protected void updateItem(String item, boolean empty) {\n+                counter.incrementAndGet();\n+                super.updateItem(item, empty);\n+            }\n+        });\n+        setupForEditing();\n+\n+        stageLoader = new StageLoader(table);\n+\n+        counter.set(0);\n+        IndexedCell<String> cell = VirtualFlowTestUtils.getCell(table, 0, 0);\n+        cell.updateIndex(0);\n+\n+        assertEquals(0, counter.get());\n+    }\n+\n+    \/**\n+     * The contract of a {@link TableCell} is that isItemChanged(..)\n+     * is called when the index is 'changed' to the same number as the old one, to evaluate if we need to call\n+     * updateItem(..).\n+     *\/\n+    @Test\n+    public void testSameIndexIsItemsChangedShouldBeCalled() {\n+        AtomicBoolean isItemChangedCalled = new AtomicBoolean();\n+\n+        editingColumn.setCellFactory(view -> new TableCell<>() {\n+            @Override\n+            protected boolean isItemChanged(String oldItem, String newItem) {\n+                isItemChangedCalled.set(true);\n+                return super.isItemChanged(oldItem, newItem);\n+            }\n+        });\n+        setupForEditing();\n+\n+        stageLoader = new StageLoader(table);\n+\n+        IndexedCell<String> cell = VirtualFlowTestUtils.getCell(table, 0, 0);\n+        cell.updateIndex(0);\n+\n+        assertTrue(isItemChangedCalled.get());\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TableCellTest.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import static org.junit.Assert.assertEquals;\n@@ -36,0 +37,1 @@\n+import javafx.scene.control.TreeTableRow;\n@@ -41,0 +43,3 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n@@ -157,0 +162,51 @@\n+\n+    \/**\n+     * Same index and underlying item should not cause the updateItem(..) method to be called.\n+     *\/\n+    @Test\n+    public void testSameIndexAndItemShouldNotUpdateItem() {\n+        AtomicInteger counter = new AtomicInteger();\n+\n+        TableView<String> table = ControlUtils.createTableView();\n+        table.setRowFactory(view -> new TableRow<>() {\n+            @Override\n+            protected void updateItem(String item, boolean empty) {\n+                counter.incrementAndGet();\n+                super.updateItem(item, empty);\n+            }\n+        });\n+\n+        stageLoader = new StageLoader(table);\n+\n+        counter.set(0);\n+        TableRow<String> row = ControlUtils.getTableRow(table, 0);\n+        row.updateIndex(0);\n+\n+        assertEquals(0, counter.get());\n+    }\n+\n+    \/**\n+     * The contract of a {@link TableRow} is that isItemChanged(..)\n+     * is called when the index is 'changed' to the same number as the old one, to evaluate if we need to call\n+     * updateItem(..).\n+     *\/\n+    @Test\n+    public void testSameIndexIsItemsChangedShouldBeCalled() {\n+        AtomicBoolean isItemChangedCalled = new AtomicBoolean();\n+\n+        TableView<String> table = ControlUtils.createTableView();\n+        table.setRowFactory(view -> new TableRow<>() {\n+            @Override\n+            protected boolean isItemChanged(String oldItem, String newItem) {\n+                isItemChangedCalled.set(true);\n+                return super.isItemChanged(oldItem, newItem);\n+            }\n+        });\n+\n+        stageLoader = new StageLoader(table);\n+\n+        TableRow<String> row = ControlUtils.getTableRow(table, 0);\n+        row.updateIndex(0);\n+\n+        assertTrue(isItemChangedCalled.get());\n+    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TableViewRowTest.java","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1083,0 +1083,3 @@\n+\n+        stageLoader = new StageLoader(table);\n+\n@@ -1101,0 +1104,36 @@\n+    @Test\n+    public void testSetItemsShouldUpdateTheCells() {\n+        final TableView<RT_22463_Person> table = new TableView<>();\n+        TableColumn<RT_22463_Person, ?> c1 = new TableColumn<>(\"Id\");\n+        TableColumn<RT_22463_Person, ?> c2 = new TableColumn<>(\"Name\");\n+        c1.setCellValueFactory(new PropertyValueFactory<>(\"id\"));\n+        c2.setCellValueFactory(new PropertyValueFactory<>(\"name\"));\n+        table.getColumns().addAll(c1, c2);\n+\n+        RT_22463_Person p1 = new RT_22463_Person();\n+        p1.setId(1L);\n+        p1.setName(\"name1\");\n+        RT_22463_Person p2 = new RT_22463_Person();\n+        p2.setId(2L);\n+        p2.setName(\"name2\");\n+\n+        stageLoader = new StageLoader(table);\n+\n+        table.setItems(FXCollections.observableArrayList(p1, p2));\n+        VirtualFlowTestUtils.assertCellTextEquals(table, 0, \"1\", \"name1\");\n+        VirtualFlowTestUtils.assertCellTextEquals(table, 1, \"2\", \"name2\");\n+\n+        \/\/ Replace all Items by the new ones. Cells should get updated.\n+        RT_22463_Person newP1 = new RT_22463_Person();\n+        newP1.setId(1L);\n+        newP1.setName(\"updated name1\");\n+        RT_22463_Person newP2 = new RT_22463_Person();\n+        newP2.setId(2L);\n+        newP2.setName(\"updated name2\");\n+\n+        table.setItems(FXCollections.observableArrayList(newP1, newP2));\n+\n+        VirtualFlowTestUtils.assertCellTextEquals(table, 0, \"1\", \"updated name1\");\n+        VirtualFlowTestUtils.assertCellTextEquals(table, 1, \"2\", \"updated name2\");\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TableViewTest.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -32,0 +34,1 @@\n+import javafx.scene.control.IndexedCell;\n@@ -1063,0 +1066,49 @@\n+    \/**\n+     * Same index and underlying item should not cause the updateItem(..) method to be called.\n+     *\/\n+    @Test\n+    public void testSameIndexAndItemShouldNotUpdateItem() {\n+        AtomicInteger counter = new AtomicInteger();\n+\n+        tree.setCellFactory(e -> new TreeCell<>() {\n+            @Override\n+            protected void updateItem(String item, boolean empty) {\n+                counter.incrementAndGet();\n+                super.updateItem(item, empty);\n+            }\n+        });\n+\n+        stageLoader = new StageLoader(tree);\n+\n+        counter.set(0);\n+        IndexedCell<String> cell = VirtualFlowTestUtils.getCell(tree, 0);\n+        cell.updateIndex(0);\n+\n+        assertEquals(0, counter.get());\n+    }\n+\n+    \/**\n+     * The contract of a {@link TreeCell} is that isItemChanged(..)\n+     * is called when the index is 'changed' to the same number as the old one, to evaluate if we need to call\n+     * updateItem(..).\n+     *\/\n+    @Test\n+    public void testSameIndexIsItemsChangedShouldBeCalled() {\n+        AtomicBoolean isItemChangedCalled = new AtomicBoolean();\n+\n+        tree.setCellFactory(e -> new TreeCell<>() {\n+            @Override\n+            protected boolean isItemChanged(String oldItem, String newItem) {\n+                isItemChangedCalled.set(true);\n+                return super.isItemChanged(oldItem, newItem);\n+            }\n+        });\n+\n+        stageLoader = new StageLoader(tree);\n+\n+        IndexedCell<String> cell = VirtualFlowTestUtils.getCell(tree, 0);\n+        cell.updateIndex(0);\n+\n+        assertTrue(isItemChangedCalled.get());\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeCellTest.java","additions":53,"deletions":1,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javafx.scene.control.IndexedCell;\n@@ -47,0 +48,2 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -1240,0 +1243,51 @@\n+    \/**\n+     * Same index and underlying item should not cause the updateItem(..) method to be called.\n+     *\/\n+    @Test\n+    public void testSameIndexAndItemShouldNotUpdateItem() {\n+        AtomicInteger counter = new AtomicInteger();\n+\n+        editingColumn.setCellFactory(view -> new TreeTableCell<>() {\n+            @Override\n+            protected void updateItem(String item, boolean empty) {\n+                counter.incrementAndGet();\n+                super.updateItem(item, empty);\n+            }\n+        });\n+        setupForEditing();\n+\n+        stageLoader = new StageLoader(tree);\n+\n+        counter.set(0);\n+        IndexedCell<String> cell = VirtualFlowTestUtils.getCell(tree, 0, 0);\n+        cell.updateIndex(0);\n+\n+        assertEquals(0, counter.get());\n+    }\n+\n+    \/**\n+     * The contract of a {@link TreeTableCell} is that isItemChanged(..)\n+     * is called when the index is 'changed' to the same number as the old one, to evaluate if we need to call\n+     * updateItem(..).\n+     *\/\n+    @Test\n+    public void testSameIndexIsItemsChangedShouldBeCalled() {\n+        AtomicBoolean isItemChangedCalled = new AtomicBoolean();\n+\n+        editingColumn.setCellFactory(view -> new TreeTableCell<>() {\n+            @Override\n+            protected boolean isItemChanged(String oldItem, String newItem) {\n+                isItemChangedCalled.set(true);\n+                return super.isItemChanged(oldItem, newItem);\n+            }\n+        });\n+        setupForEditing();\n+\n+        stageLoader = new StageLoader(tree);\n+\n+        IndexedCell<String> cell = VirtualFlowTestUtils.getCell(tree, 0, 0);\n+        cell.updateIndex(0);\n+\n+        assertTrue(isItemChangedCalled.get());\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeTableCellTest.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import javafx.scene.control.TableView;\n@@ -50,0 +51,3 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n@@ -942,0 +946,51 @@\n+\n+    \/**\n+     * Same index and underlying item should not cause the updateItem(..) method to be called.\n+     *\/\n+    @Test\n+    public void testSameIndexAndItemShouldNotUpdateItem() {\n+        AtomicInteger counter = new AtomicInteger();\n+\n+        TreeTableView<String> tree = ControlUtils.createTreeTableView();\n+        tree.setRowFactory(view -> new TreeTableRow<>() {\n+            @Override\n+            protected void updateItem(String item, boolean empty) {\n+                counter.incrementAndGet();\n+                super.updateItem(item, empty);\n+            }\n+        });\n+\n+        stageLoader = new StageLoader(tree);\n+\n+        counter.set(0);\n+        TreeTableRow<String> row = ControlUtils.getTreeTableRow(tree, 0);\n+        row.updateIndex(0);\n+\n+        assertEquals(0, counter.get());\n+    }\n+\n+    \/**\n+     * The contract of a {@link TreeTableRow} is that isItemChanged(..)\n+     * is called when the index is 'changed' to the same number as the old one, to evaluate if we need to call\n+     * updateItem(..).\n+     *\/\n+    @Test\n+    public void testSameIndexIsItemsChangedShouldBeCalled() {\n+        AtomicBoolean isItemChangedCalled = new AtomicBoolean();\n+\n+        TreeTableView<String> tree = ControlUtils.createTreeTableView();\n+        tree.setRowFactory(view -> new TreeTableRow<>() {\n+            @Override\n+            protected boolean isItemChanged(String oldItem, String newItem) {\n+                isItemChangedCalled.set(true);\n+                return super.isItemChanged(oldItem, newItem);\n+            }\n+        });\n+\n+        stageLoader = new StageLoader(tree);\n+\n+        TreeTableRow<String> row = ControlUtils.getTreeTableRow(tree, 0);\n+        row.updateIndex(0);\n+\n+        assertTrue(isItemChangedCalled.get());\n+    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeTableRowTest.java","additions":56,"deletions":1,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1744,0 +1744,2 @@\n+        stageLoader = new StageLoader(table);\n+\n@@ -1775,0 +1777,44 @@\n+    @Test\n+    public void testSetChildrenShouldUpdateTheCells() {\n+        final TreeTableView<RT_22463_Person> table = new TreeTableView<>();\n+        TreeTableColumn<RT_22463_Person, ?> c1 = new TreeTableColumn<>(\"Id\");\n+        TreeTableColumn<RT_22463_Person, ?> c2 = new TreeTableColumn<>(\"Name\");\n+        c1.setCellValueFactory(new TreeItemPropertyValueFactory<>(\"id\"));\n+        c2.setCellValueFactory(new TreeItemPropertyValueFactory<>(\"name\"));\n+        table.getColumns().addAll(c1, c2);\n+\n+        RT_22463_Person rootPerson = new RT_22463_Person();\n+        rootPerson.setName(\"Root\");\n+        TreeItem<RT_22463_Person> root = new TreeItem<>(rootPerson);\n+        root.setExpanded(true);\n+\n+        stageLoader = new StageLoader(table);\n+\n+        table.setRoot(root);\n+\n+        RT_22463_Person p1 = new RT_22463_Person();\n+        p1.setId(1L);\n+        p1.setName(\"name1\");\n+        RT_22463_Person p2 = new RT_22463_Person();\n+        p2.setId(2L);\n+        p2.setName(\"name2\");\n+        root.getChildren().addAll(\n+                new TreeItem<>(p1),\n+                new TreeItem<>(p2));\n+        VirtualFlowTestUtils.assertCellTextEquals(table, 1, \"1\", \"name1\");\n+        VirtualFlowTestUtils.assertCellTextEquals(table, 2, \"2\", \"name2\");\n+\n+        \/\/ Replace all TreeItems by the new ones. Cells should get updated.\n+        RT_22463_Person newP1 = new RT_22463_Person();\n+        newP1.setId(1L);\n+        newP1.setName(\"updated name1\");\n+        RT_22463_Person newP2 = new RT_22463_Person();\n+        newP2.setId(2L);\n+        newP2.setName(\"updated name2\");\n+        root.getChildren().setAll(\n+                new TreeItem<>(newP1),\n+                new TreeItem<>(newP2));\n+        VirtualFlowTestUtils.assertCellTextEquals(table, 1, \"1\", \"updated name1\");\n+        VirtualFlowTestUtils.assertCellTextEquals(table, 2, \"2\", \"updated name2\");\n+    }\n+\n@@ -2594,1 +2640,2 @@\n-        assertEquals(22, rt_31200_count);\n+        int oldCount = rt_31200_count;\n+        assertEquals(18, rt_31200_count);\n@@ -2601,1 +2648,2 @@\n-        assertEquals(22, rt_31200_count);\n+        \/\/ Should be the same count as above.\n+        assertEquals(oldCount, rt_31200_count);\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeTableViewTest.java","additions":51,"deletions":3,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,0 +105,2 @@\n+    private StageLoader stageLoader;\n+\n@@ -184,0 +186,4 @@\n+\n+        if (stageLoader != null) {\n+            stageLoader.dispose();\n+        }\n@@ -803,0 +809,3 @@\n+\n+        stageLoader = new StageLoader(tree);\n+\n@@ -815,0 +824,3 @@\n+\n+        Toolkit.getToolkit().firePulse();\n+\n@@ -830,0 +842,47 @@\n+\n+        Toolkit.getToolkit().firePulse();\n+\n+        VirtualFlowTestUtils.assertCellTextEquals(tree, 1, \"updated name1\");\n+        VirtualFlowTestUtils.assertCellTextEquals(tree, 2, \"updated name2\");\n+    }\n+\n+    @Test public void testSetChildrenShouldUpdateTheCells() {\n+        RT_22463_Person rootPerson = new RT_22463_Person();\n+        rootPerson.setName(\"Root\");\n+        TreeItem<RT_22463_Person> root = new TreeItem<>(rootPerson);\n+        root.setExpanded(true);\n+\n+        final TreeView<RT_22463_Person> tree = new TreeView<>();\n+\n+        stageLoader = new StageLoader(tree);\n+\n+        tree.setRoot(root);\n+\n+        RT_22463_Person p1 = new RT_22463_Person();\n+        p1.setId(1L);\n+        p1.setName(\"name1\");\n+        RT_22463_Person p2 = new RT_22463_Person();\n+        p2.setId(2L);\n+        p2.setName(\"name2\");\n+        root.getChildren().addAll(\n+                new TreeItem<>(p1),\n+                new TreeItem<>(p2));\n+\n+        Toolkit.getToolkit().firePulse();\n+\n+        VirtualFlowTestUtils.assertCellTextEquals(tree, 1, \"name1\");\n+        VirtualFlowTestUtils.assertCellTextEquals(tree, 2, \"name2\");\n+\n+        \/\/ Replace all TreeItems by the new ones. Cells should get updated.\n+        RT_22463_Person newP1 = new RT_22463_Person();\n+        newP1.setId(1L);\n+        newP1.setName(\"updated name1\");\n+        RT_22463_Person newP2 = new RT_22463_Person();\n+        newP2.setId(2L);\n+        newP2.setName(\"updated name2\");\n+        root.getChildren().setAll(\n+                new TreeItem<>(newP1),\n+                new TreeItem<>(newP2));\n+\n+        Toolkit.getToolkit().firePulse();\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeViewTest.java","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"}]}