{"files":[{"patch":"@@ -0,0 +1,54 @@\n+# Additional Information for JDK-8340852\n+\n+## Reverting to Previous `ScrollPane` Behavior:\n+\n+The fix for [JDK-8340852](https:\/\/bugs.openjdk.org\/browse\/JDK-8340852) changed the behavior of `ScrollPane`. With the latest update, `ScrollPane` only responds to keyboard navigation when it is the focused node. If you prefer the previous behavior, where `ScrollPane` always reacts to arrow keys and other navigational inputs, you can manually restore it by adding an event handler:\n+\n+```\n+scrollPane.addEventHandler(KeyEvent.KEY_PRESSED, e -> {\n+    double x = 0;\n+    double y = 0;\n+\n+    switch (e.getCode()) {\n+        case LEFT -> x = -0.1;\n+        case RIGHT -> x = 0.1;\n+        case UP -> y = -0.1;\n+        case DOWN -> y = 0.1;\n+        case PAGE_UP -> y = -0.9;\n+        case PAGE_DOWN, SPACE -> y = 0.9;\n+        case HOME -> x = y = Double.NEGATIVE_INFINITY;\n+        case END -> x = y = Double.POSITIVE_INFINITY;\n+        default -> {}\n+    }\n+\n+    if (x != 0 || y != 0) {\n+        scrollByFraction(scrollPane, x, y);\n+        e.consume();\n+    }\n+});\n+```\n+Using this helper method to convert scroll fractions to values for the scrollbars, and set them:\n+```\n+static void scrollByFraction(ScrollPane scrollPane, double x, double y) {\n+    Node content = scrollPane.getContent();\n+    if (content == null) return;\n+\n+    Bounds viewportBounds = scrollPane.getViewportBounds();\n+    Bounds layoutBounds = content.getLayoutBounds();\n+\n+    if (x != 0) {\n+        double visibleFraction = viewportBounds.getWidth() \/ layoutBounds.getWidth();\n+        double range = scrollPane.getHmax() - scrollPane.getHmin();\n+        double scrollFactor = range * visibleFraction \/ (1 - visibleFraction);\n+        scrollPane.setHvalue(scrollPane.getHvalue() + x * scrollFactor);\n+    }\n+\n+    if (y != 0) {\n+        double visibleFraction = viewportBounds.getHeight() \/ layoutBounds.getHeight();\n+        double range = scrollPane.getVmax() - scrollPane.getVmin();\n+        double scrollFactor = range * visibleFraction \/ (1 - visibleFraction);\n+        scrollPane.setVvalue(scrollPane.getVvalue() + y * scrollFactor);\n+    }\n+}\n+```\n+Adding this event handler will make ScrollPane react to navigation keys as it did before the update.\n","filename":"doc-files\/notes\/24\/JDK-8340852-info.md","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -54,1 +54,1 @@\n-When creating your custom Java runtime image, put the JavaFX jmods on the module path ahead of the JDK jmoods. For example:\n+When creating your custom Java runtime image, put the JavaFX jmods on the module path ahead of the JDK jmods. For example:\n@@ -78,52 +78,1 @@\n-Reverting to Previous `ScrollPane` Behavior:\n-\n-With the latest update, `ScrollPane` only responds to keyboard navigation when it is the focused node. If you prefer the previous behavior, where `ScrollPane` always reacts to arrow keys and other navigational inputs, you can manually restore it by adding an event handler:\n-\n-```\n-scrollPane.addEventHandler(KeyEvent.KEY_PRESSED, e -> {\n-    double x = 0;\n-    double y = 0;\n-\n-    switch (e.getCode()) {\n-        case LEFT -> x = -0.1;\n-        case RIGHT -> x = 0.1;\n-        case UP -> y = -0.1;\n-        case DOWN -> y = 0.1;\n-        case PAGE_UP -> y = -0.9;\n-        case PAGE_DOWN, SPACE -> y = 0.9;\n-        case HOME -> x = y = Double.NEGATIVE_INFINITY;\n-        case END -> x = y = Double.POSITIVE_INFINITY;\n-        default -> {}\n-    }\n-\n-    if (x != 0 || y != 0) {\n-        scrollByFraction(scrollPane, x, y);\n-        e.consume();\n-    }\n-});\n-```\n-Using this helper method to convert scroll fractions to values for the scrollbars, and set them:\n-```\n-static void scrollByFraction(ScrollPane scrollPane, double x, double y) {\n-    Node content = scrollPane.getContent();\n-    if (content == null) return;\n-\n-    Bounds viewportBounds = scrollPane.getViewportBounds();\n-    Bounds layoutBounds = content.getLayoutBounds();\n-\n-    if (x != 0) {\n-        double visibleFraction = viewportBounds.getWidth() \/ layoutBounds.getWidth();\n-        double range = scrollPane.getHmax() - scrollPane.getHmin();\n-        double scrollFactor = range * visibleFraction \/ (1 - visibleFraction);\n-        scrollPane.setHvalue(scrollPane.getHvalue() + x * scrollFactor);\n-    }\n-\n-    if (y != 0) {\n-        double visibleFraction = viewportBounds.getHeight() \/ layoutBounds.getHeight();\n-        double range = scrollPane.getVmax() - scrollPane.getVmin();\n-        double scrollFactor = range * visibleFraction \/ (1 - visibleFraction);\n-        scrollPane.setVvalue(scrollPane.getVvalue() + y * scrollFactor);\n-    }\n-}\n-```\n-Adding this event handler will make ScrollPane react to navigation keys as it did before the update.\n+Applications that prefer the previous behavior, where `ScrollPane` always reacts to arrow keys and other navigational inputs, can manually restore it by adding an event handler. See [this note](notes\/24\/JDK-8340852-info.md) for an example of how to do this.\n","filename":"doc-files\/release-notes-24.md","additions":2,"deletions":53,"binary":false,"changes":55,"status":"modified"}]}