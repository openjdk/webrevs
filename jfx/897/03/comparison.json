{"files":[{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javafx.scene.control;\n+\n+import java.util.List;\n+import javafx.css.PseudoClass;\n+import javafx.scene.Node;\n+import javafx.util.Callback;\n+\n+\/**\n+ * A constrained column resize implementation that honors all Tree\/TableColumn constraints -\n+ * minimum, preferred, and maximum width.\n+ *\n+ * @since 20\n+ *\/\n+public class ConstrainedColumnResize extends ConstrainedColumnResizeBase {\n+    public enum ResizeMode {\n+        AUTO_RESIZE_FLEX_HEAD,\n+        AUTO_RESIZE_FLEX_TAIL, \/\/ will be used to replace a (deprecated) CONSTRAINED_RESIZE_POLICY.\n+        AUTO_RESIZE_NEXT_COLUMN,\n+        AUTO_RESIZE_SUBSEQUENT_COLUMNS,\n+        AUTO_RESIZE_LAST_COLUMN,\n+        AUTO_RESIZE_ALL_COLUMNS\n+    }\n+\n+    private final ResizeMode mode;\n+\n+    public ConstrainedColumnResize(ResizeMode m) {\n+        this.mode = m;\n+    }\n+\n+    public boolean constrainedResize(ResizeFeaturesBase rf,\n+        List<? extends TableColumnBase<?,?>> visibleLeafColumns) {\n+\n+        double contentWidth = rf.getContentWidth();\n+        if (contentWidth == 0.0) {\n+            return false;\n+        }\n+\n+        ResizeHelper h = new ResizeHelper(rf, contentWidth, visibleLeafColumns, mode);\n+        h.resizeToContentWidth();\n+\n+        boolean rv;\n+        TableColumnBase<?,?> column = rf.getColumn();\n+        if (column == null) {\n+            rv = false;\n+        } else {\n+            rv = h.resizeColumn(column);\n+        }\n+\n+        \/\/ conditionally remove pseudoclass (given by this policy toString()) when the columns\n+        \/\/ are narrower than the available area and the rightmost column boundary line needs to be drawn.\n+        \/\/ hint: search modena.css for \"constrained-resize\" token\n+        Node n = rf.getTableNode();\n+        PseudoClass pc = PseudoClass.getPseudoClass(toString());\n+        boolean wide = h.applySizes();\n+        boolean current = n.getPseudoClassStates().contains(pc);\n+        if (wide != current) {\n+            if (wide) {\n+                n.pseudoClassStateChanged(pc, true);\n+            } else {\n+                n.pseudoClassStateChanged(pc, false);\n+            }\n+        }\n+        return rv;\n+    }\n+\n+    public static TablePolicy forTable(ResizeMode m) {\n+        return new TablePolicy(m);\n+    }\n+\n+    public static TreeTablePolicy forTreeTable(ResizeMode m) {\n+        return new TreeTablePolicy(m);\n+    }\n+\n+    public static class TablePolicy\n+        extends ConstrainedColumnResize\n+        implements Callback<TableView.ResizeFeatures,Boolean> {\n+\n+        public TablePolicy(ResizeMode m) {\n+            super(m);\n+        }\n+\n+        @Override\n+        public Boolean call(TableView.ResizeFeatures rf) {\n+            List<? extends TableColumnBase<?,?>> visibleLeafColumns = rf.getTable().getVisibleLeafColumns();\n+            return constrainedResize(rf, visibleLeafColumns);\n+        }\n+    }\n+\n+    public static class TreeTablePolicy\n+        extends ConstrainedColumnResize\n+        implements Callback<TreeTableView.ResizeFeatures,Boolean> {\n+\n+        public TreeTablePolicy(ResizeMode m) {\n+            super(m);\n+        }\n+\n+        @Override\n+        public Boolean call(TreeTableView.ResizeFeatures rf) {\n+            List<? extends TableColumnBase<?,?>> visibleLeafColumns = rf.getTable().getVisibleLeafColumns();\n+            return constrainedResize(rf, visibleLeafColumns);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/ConstrainedColumnResize.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javafx.scene.control;\n+\n+\/**\n+ * Base class for a constrained column resize policy.\n+ * Setting any policy that extends this class on a Tree\/TableView results in\n+ * disabling of its horizontal scroll bar.\n+ *\n+ * @since 20\n+ *\/\n+public abstract class ConstrainedColumnResizeBase {\n+\n+    @Override\n+    public String toString() {\n+        \/\/ name of a pseudo-style set on a Tree\/TableView when a constrained resize policy is in effect\n+        return \"constrained-resize\";\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/ConstrainedColumnResizeBase.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javafx.scene.Node;\n@@ -55,0 +56,16 @@\n+  \/**\n+   * Returns the width of the area available for columns.\n+   *\/\n+  public double getContentWidth() {\n+      \/\/ not available in the base class\n+      throw new UnsupportedOperationException(\"method not available in the base class\");\n+  }\n+\n+  \/**\n+   * Returns the associated TreeView or TreeTableView\n+   *\/\n+  public Node getTableNode() {\n+      \/\/ not available in the base class\n+      throw new UnsupportedOperationException(\"method not available in the base class\");\n+  }\n+\n@@ -70,0 +87,7 @@\n+\n+  \/**\n+   * Sets the column width during the resizing pass.\n+   *\/\n+  public void setColumnWidth(TableColumnBase<S,?> col, double width) {\n+      col.doSetWidth(width);\n+  }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/ResizeFeaturesBase.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,506 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javafx.scene.control;\n+\n+import java.util.BitSet;\n+import java.util.List;\n+\n+\/**\n+ * Helps resize Tree\/TableView columns.\n+ *\/\n+public class ResizeHelper {\n+    protected static final double EPSILON = 0.0000001;\n+\n+    private final ResizeFeaturesBase rf;\n+    private final double target;\n+    private final List<? extends TableColumnBase<?,?>> columns;\n+    private final int count;\n+    private final ConstrainedColumnResize.ResizeMode mode;\n+    private final double[] size;\n+    private final double[] min;\n+    private final double[] pref;\n+    private final double[] max;\n+    private final BitSet skip;\n+\n+    public ResizeHelper(ResizeFeaturesBase rf,\n+                        double target,\n+                        List<? extends TableColumnBase<?,?>> columns,\n+                        ConstrainedColumnResize.ResizeMode mode) {\n+        this.rf = rf;\n+        this.target = target;\n+        this.columns = columns;\n+        this.mode = mode;\n+\n+        this.count = columns.size();\n+        size = new double[count];\n+        min = new double[count];\n+        pref = new double[count];\n+        max = new double[count];\n+        skip = new BitSet(count);\n+\n+        for (int i = 0; i < count; i++) {\n+            TableColumnBase<?,?> c = columns.get(i);\n+            double w = c.getWidth();\n+            size[i] = w;\n+\n+            if (c.isResizable()) {\n+                min[i] = c.getMinWidth();\n+                pref[i] = clip(c.getPrefWidth(), c.getMinWidth(), c.getMaxWidth());\n+                max[i] = c.getMaxWidth();\n+            } else {\n+                skip.set(i, true);\n+            }\n+        }\n+    }\n+\n+    public void resizeToContentWidth() {\n+        boolean needsAnotherPass = false;\n+\n+        do {\n+            double sumWidths = 0.0;\n+            double sumMins = 0.0;\n+            for (int i = 0; i < count; i++) {\n+                sumWidths += size[i];\n+                sumMins += min[i];\n+            }\n+\n+            if(sumMins >= target) {\n+                return;\n+            }\n+\n+            double delta = target - sumWidths;\n+            if (isZero(delta)) {\n+                return;\n+            }\n+\n+            \/\/ remove fixed and skipped columns from consideration\n+            double total = 0.0;\n+            for (int i = 0; i < count; i++) {\n+                if (!skip.get(i)) {\n+                    total += step1(i);\n+                }\n+            }\n+\n+            if (isZero(total)) {\n+                return;\n+            }\n+\n+            double acc = 0.0; \/\/ accumulating widths of processed columns\n+            double rem = 0.0; \/\/ remainder from previous column\n+\n+            for (int i = 0; i < count; i++) {\n+                if (skip.get(i)) {\n+                    continue;\n+                }\n+\n+                double dw = rem + (delta * step1(i) \/ total);\n+                double w = Math.round(size[i] + dw);\n+                if (w < min[i]) {\n+                    rem = (w - min[i]);\n+                    w = min[i];\n+                    skip.set(i, true);\n+                    needsAnotherPass = true;\n+                } else if (w > max[i]) {\n+                    rem = (w - max[i]);\n+                    w = max[i];\n+                    skip.set(i, true);\n+                    needsAnotherPass = true;\n+                } else {\n+                    rem = dw - (w - size[i]);\n+                }\n+\n+                acc += w;\n+                size[i] = w;\n+            }\n+\n+            if (isZero(target - acc)) {\n+                needsAnotherPass = false;\n+            }\n+\n+            if (needsAnotherPass) {\n+            }\n+        } while (needsAnotherPass);\n+    }\n+\n+    protected double step1(int ix) {\n+        double w = pref[ix] - size[ix];\n+        if(w <= 0) {\n+            return size[ix];\n+        } else {\n+            return pref[ix];\n+        }\n+    }\n+\n+    \/**\n+     * Applies computed column widths to the tree\/table columns.\n+     * @return true if sum of columns equals or greater than the target area\n+     *\/\n+    public boolean applySizes() {\n+        double w = 0.0;\n+        for (int i = 0; i < count; i++) {\n+            TableColumnBase<?,?> c = columns.get(i);\n+            if (c.isResizable()) {\n+                rf.setColumnWidth(c, size[i]);\n+                w += size[i];\n+            }\n+        }\n+\n+        return (w > (target - 1.0));\n+    }\n+\n+    protected static boolean isZero(double x) {\n+        return Math.abs(x) < EPSILON;\n+    }\n+\n+    protected static double clip(double v, double min, double max) {\n+        if (v < min) {\n+            return min;\n+        } else if (v > max) {\n+            return max;\n+        }\n+        return v;\n+    }\n+\n+    public boolean resizeColumn(TableColumnBase<?,?> column) {\n+        double delta = rf.getDelta();\n+        \/\/ need to find the last leaf column of the given column - it is this\n+        \/\/ column that we actually resize from. If this column is a leaf, then we\n+        \/\/ use it.\n+        TableColumnBase<?,?> leafColumn = column;\n+        while (leafColumn.getColumns().size() > 0) {\n+            leafColumn = leafColumn.getColumns().get(leafColumn.getColumns().size() - 1);\n+        }\n+\n+        if (!leafColumn.isResizable()) {\n+            return false;\n+        }\n+\n+        int ix = columns.indexOf(leafColumn);\n+        boolean expanding = delta > 0.0;\n+        double allowedDelta;\n+        if (mode == ConstrainedColumnResize.ResizeMode.AUTO_RESIZE_ALL_COLUMNS) {\n+            allowedDelta = Math.abs(delta);\n+        } else {\n+            allowedDelta = getAllowedDelta(ix, expanding);\n+            if (isZero(allowedDelta)) {\n+                return false;\n+            }\n+        }\n+\n+        int ct = markOppositeColumns(ix);\n+        if (ct == 0) {\n+            return false;\n+        }\n+\n+        double d = computeAllowedDelta(!expanding);\n+        if (isZero(d)) {\n+            return false;\n+        }\n+\n+        allowedDelta = Math.min(Math.abs(delta), Math.min(allowedDelta, d));\n+        allowedDelta = (expanding ? 1 : -1) * Math.floor(allowedDelta);\n+\n+        if (isCornerCase(allowedDelta, ix)) {\n+            return false;\n+        }\n+\n+        return distributeDelta(ix, allowedDelta);\n+    }\n+\n+    protected boolean isCornerCase(double delta, int ix) {\n+        boolean isResizingLastColumn = (ix == count - 2);\n+        if (isResizingLastColumn) {\n+            if (delta > 0.0) {\n+                int i = count - 1;\n+                if (isZero(size[i] - min[i])) {\n+                    \/\/ last column hit min constraint\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    \/** non-negative *\/\n+    protected double getAllowedDelta(int ix, boolean expanding) {\n+        if (expanding) {\n+            return Math.abs(max[ix] - size[ix]);\n+        } else {\n+            return Math.abs(min[ix] - size[ix]);\n+        }\n+    }\n+\n+    \/** updates skip bitset with columns that might be resized, and returns the number of the opposite columns *\/\n+    protected int markOppositeColumns(int ix) {\n+        switch (mode) {\n+        case AUTO_RESIZE_NEXT_COLUMN:\n+            setSkip(0, ix + 1);\n+            setSkip(ix + 2, columns.size());\n+            break;\n+        case AUTO_RESIZE_FLEX_HEAD:\n+        case AUTO_RESIZE_FLEX_TAIL:\n+        case AUTO_RESIZE_SUBSEQUENT_COLUMNS:\n+            setSkip(0, ix + 1);\n+            break;\n+        case AUTO_RESIZE_LAST_COLUMN:\n+            setSkip(0, Math.max(ix + 1, columns.size() - 1));\n+            break;\n+        case AUTO_RESIZE_ALL_COLUMNS:\n+        default:\n+            setSkip(ix, ix + 1);\n+            break;\n+        }\n+\n+        return count - skip.cardinality();\n+    }\n+\n+    \/** range set with limit check *\/\n+    protected void setSkip(int from, int toExclusive) {\n+        if (from < 0) {\n+            from = 0;\n+        } else if (from >= count) {\n+            return;\n+        }\n+        int to = Math.min(count, toExclusive);\n+        if (from < to) {\n+            skip.set(from, to);\n+        }\n+    }\n+\n+    \/** returns the allowable delta for all of the opposite columns *\/\n+    protected double computeAllowedDelta(boolean expanding) {\n+        double delta = 0.0;\n+        int i = 0;\n+        for (;;) {\n+            i = skip.nextClearBit(i);\n+            \/\/ are we at the end?\n+            if (i >= count) {\n+                break;\n+            }\n+\n+            if (expanding) {\n+                delta += (max[i] - size[i]);\n+            } else {\n+                delta += (size[i] - min[i]);\n+            }\n+\n+            i++;\n+        }\n+        return delta;\n+    }\n+\n+    protected boolean distributeDelta(int ix, double delta) {\n+        int ct = count - skip.cardinality();\n+        if (ct == 0) {\n+            return false;\n+        } else if (ct == 1) {\n+            int oppx = skip.nextClearBit(0);\n+            size[ix] += delta;\n+            size[oppx] -= delta;\n+            return true;\n+        } else {\n+            size[ix] += delta;\n+            double adj;\n+            switch(mode) {\n+            case AUTO_RESIZE_FLEX_HEAD:\n+                adj = distributeDeltaFlexHead(-delta);\n+                break;\n+            case AUTO_RESIZE_FLEX_TAIL:\n+                adj = distributeDeltaFlexTail(-delta);\n+                break;\n+            default:\n+                adj = distributeDeltaRemainingColumns(-delta);\n+                break;\n+            }\n+            size[ix] += adj;\n+            return true;\n+        }\n+    }\n+\n+    protected double distributeDeltaFlexHead(double delta) {\n+        if (delta < 0) {\n+            \/\/ when shrinking, first resize columns that are wider than their preferred width\n+            for (int i = 0; i < count; i++) {\n+                if (skip.get(i)) {\n+                    continue;\n+                }\n+\n+                if (size[i] > pref[i]) {\n+                    delta = resize(i, delta);\n+\n+                    if (isZero(delta)) {\n+                        break;\n+                    }\n+                }\n+            }\n+        } else {\n+            \/\/ when expanding, first resize columns that are narrower than their preferred width\n+            for (int i = 0; i < count; i++) {\n+                if (skip.get(i)) {\n+                    continue;\n+                }\n+\n+                if (size[i] < pref[i]) {\n+                    delta = resize(i, delta);\n+\n+                    if (isZero(delta)) {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < count; i++) {\n+            if (skip.get(i)) {\n+                continue;\n+            }\n+\n+            delta = resize(i, delta);\n+\n+            if (isZero(delta)) {\n+                break;\n+            }\n+        }\n+        return delta;\n+    }\n+\n+    protected double distributeDeltaFlexTail(double delta) {\n+        if (delta < 0) {\n+            \/\/ when shrinking, first resize columns that are wider than their preferred width\n+            for (int i = count - 1; i >= 0; --i) {\n+                if (skip.get(i)) {\n+                    continue;\n+                }\n+\n+                if (size[i] > pref[i]) {\n+                    delta = resize(i, delta);\n+\n+                    if (isZero(delta)) {\n+                        break;\n+                    }\n+                }\n+            }\n+        } else {\n+            \/\/ when expanding, first resize columns that are narrower than their preferred width\n+            for (int i = count - 1; i >= 0; --i) {\n+                if (skip.get(i)) {\n+                    continue;\n+                }\n+\n+                if (size[i] < pref[i]) {\n+                    delta = resize(i, delta);\n+\n+                    if (isZero(delta)) {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (int i = count - 1; i >= 0; --i) {\n+            if (skip.get(i)) {\n+                continue;\n+            }\n+\n+            delta = resize(i, delta);\n+\n+            if (isZero(delta)) {\n+                break;\n+            }\n+        }\n+        return delta;\n+    }\n+\n+    protected double resize(int i, double delta) {\n+        double w = Math.round(size[i] + delta);\n+        if (w < min[i]) {\n+            delta = (w - min[i]);\n+            w = min[i];\n+        } else if (w > max[i]) {\n+            delta = (w - max[i]);\n+            w = max[i];\n+        } else {\n+            delta = 0.0;\n+        }\n+\n+        size[i] = w;\n+        return delta;\n+    }\n+\n+    protected double distributeDeltaRemainingColumns(double delta) {\n+        boolean needsAnotherPass = false;\n+        double adj = 0.0;\n+\n+        do {\n+            double total = 0.0;\n+            for (int i = 0; i < count; i++) {\n+                if (!skip.get(i)) {\n+                    total += pref[i];\n+                }\n+            }\n+\n+            if (isZero(total)) {\n+                return adj;\n+            }\n+\n+            double rem = 0.0; \/\/ remainder from previous column\n+\n+            for (int i = 0; i < count; i++) {\n+                if (skip.get(i)) {\n+                    continue;\n+                }\n+\n+                double dw = rem + (delta * pref[i] \/ total);\n+                double w = Math.round(size[i] + dw);\n+                if (w < min[i]) {\n+                    rem = (w - min[i]);\n+                    w = min[i];\n+                    skip.set(i, true);\n+                    needsAnotherPass = true;\n+                } else if (w > max[i]) {\n+                    rem = (w - max[i]);\n+                    w = max[i];\n+                    skip.set(i, true);\n+                    needsAnotherPass = true;\n+                } else {\n+                    rem = dw - (w - size[i]);\n+                }\n+\n+                size[i] = w;\n+            }\n+\n+            if (Math.abs(delta) < 1.0) {\n+                if (Math.abs(delta) >= 0.5) {\n+                    adj = Math.signum(delta);\n+                }\n+                needsAnotherPass = false;\n+            }\n+\n+        } while (needsAnotherPass);\n+\n+        return adj;\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/ResizeHelper.java","additions":506,"deletions":0,"binary":false,"changes":506,"status":"added"},{"patch":"@@ -185,183 +185,0 @@\n-\n-\n-\n-\n-    \/**\n-     * The constrained resize algorithm used by TableView and TreeTableView.\n-     * @param prop\n-     * @param isFirstRun\n-     * @param tableWidth\n-     * @param visibleLeafColumns\n-     * @return\n-     *\/\n-    static boolean constrainedResize(ResizeFeaturesBase prop,\n-                                     boolean isFirstRun,\n-                                     double tableWidth,\n-                                     List<? extends TableColumnBase<?,?>> visibleLeafColumns) {\n-        TableColumnBase<?,?> column = prop.getColumn();\n-        double delta = prop.getDelta();\n-\n-        \/*\n-         * There are two phases to the constrained resize policy:\n-         *   1) Ensuring internal consistency (i.e. table width == sum of all visible\n-         *      columns width). This is often called when the table is resized.\n-         *   2) Resizing the given column by __up to__ the given delta.\n-         *\n-         * It is possible that phase 1 occur and there be no need for phase 2 to\n-         * occur.\n-         *\/\n-\n-        boolean isShrinking;\n-        double target;\n-        double totalLowerBound = 0;\n-        double totalUpperBound = 0;\n-\n-        if (tableWidth == 0) return false;\n-\n-        \/*\n-         * PHASE 1: Check to ensure we have internal consistency. Based on the\n-         *          Swing JTable implementation.\n-         *\/\n-        \/\/ determine the width of all visible columns, and their preferred width\n-        double colWidth = 0;\n-        for (TableColumnBase<?,?> col : visibleLeafColumns) {\n-            colWidth += col.getWidth();\n-        }\n-\n-        if (Math.abs(colWidth - tableWidth) > EPSILON) {\n-            isShrinking = colWidth > tableWidth;\n-            target = tableWidth;\n-\n-            if (isFirstRun) {\n-                \/\/ if we are here we have an inconsistency - these two values should be\n-                \/\/ equal when this resizing policy is being used.\n-                for (TableColumnBase<?,?> col : visibleLeafColumns) {\n-                    totalLowerBound += col.getMinWidth();\n-                    totalUpperBound += col.getMaxWidth();\n-                }\n-\n-                \/\/ We run into trouble if the numbers are set to infinity later on\n-                totalUpperBound = totalUpperBound == Double.POSITIVE_INFINITY ?\n-                    Double.MAX_VALUE :\n-                    (totalUpperBound == Double.NEGATIVE_INFINITY ? Double.MIN_VALUE : totalUpperBound);\n-\n-                for (TableColumnBase col : visibleLeafColumns) {\n-                    double lowerBound = col.getMinWidth();\n-                    double upperBound = col.getMaxWidth();\n-\n-                    \/\/ Check for zero. This happens when the distribution of the delta\n-                    \/\/ finishes early due to a series of \"fixed\" entries at the end.\n-                    \/\/ In this case, lowerBound == upperBound, for all subsequent terms.\n-                    double newSize;\n-                    if (Math.abs(totalLowerBound - totalUpperBound) < EPSILON) {\n-                        newSize = lowerBound;\n-                    } else {\n-                        double f = (target - totalLowerBound) \/ (totalUpperBound - totalLowerBound);\n-                        newSize = Math.round(lowerBound + f * (upperBound - lowerBound));\n-                    }\n-\n-                    double remainder = resize(col, newSize - col.getWidth());\n-\n-                    target -= newSize + remainder;\n-                    totalLowerBound -= lowerBound;\n-                    totalUpperBound -= upperBound;\n-                }\n-\n-                isFirstRun = false;\n-            } else {\n-                double actualDelta = tableWidth - colWidth;\n-                List<? extends TableColumnBase<?,?>> cols = visibleLeafColumns;\n-                resizeColumns(cols, actualDelta);\n-            }\n-        }\n-\n-        \/\/ At this point we can be happy in the knowledge that we have internal\n-        \/\/ consistency, i.e. table width == sum of the width of all visible\n-        \/\/ leaf columns.\n-\n-        \/*\n-         * Column may be null if we just changed the resize policy, and we\n-         * just wanted to enforce internal consistency, as mentioned above.\n-         *\/\n-        if (column == null) {\n-            return false;\n-        }\n-\n-        \/*\n-         * PHASE 2: Handling actual column resizing (by the user). Based on my own\n-         *          implementation (based on the UX spec).\n-         *\/\n-\n-        isShrinking = delta < 0;\n-\n-        \/\/ need to find the last leaf column of the given column - it is this\n-        \/\/ column that we actually resize from. If this column is a leaf, then we\n-        \/\/ use it.\n-        TableColumnBase<?,?> leafColumn = column;\n-        while (leafColumn.getColumns().size() > 0) {\n-            leafColumn = leafColumn.getColumns().get(leafColumn.getColumns().size() - 1);\n-        }\n-\n-        int colPos = visibleLeafColumns.indexOf(leafColumn);\n-        int endColPos = visibleLeafColumns.size() - 1;\n-\n-        \/\/ we now can split the observableArrayList into two subobservableArrayLists, representing all\n-        \/\/ columns that should grow, and all columns that should shrink\n-        \/\/    var growingCols = if (isShrinking)\n-        \/\/        then table.visibleLeafColumns[colPos+1..endColPos]\n-        \/\/        else table.visibleLeafColumns[0..colPos];\n-        \/\/    var shrinkingCols = if (isShrinking)\n-        \/\/        then table.visibleLeafColumns[0..colPos]\n-        \/\/        else table.visibleLeafColumns[colPos+1..endColPos];\n-\n-\n-        double remainingDelta = delta;\n-        while (endColPos > colPos && remainingDelta != 0) {\n-            TableColumnBase<?,?> resizingCol = visibleLeafColumns.get(endColPos);\n-            endColPos--;\n-\n-            \/\/ if the column width is fixed, break out and try the next column\n-            if (! resizingCol.isResizable()) continue;\n-\n-            \/\/ for convenience we discern between the shrinking and growing columns\n-            TableColumnBase<?,?> shrinkingCol = isShrinking ? leafColumn : resizingCol;\n-            TableColumnBase<?,?> growingCol = !isShrinking ? leafColumn : resizingCol;\n-\n-            \/\/        (shrinkingCol.width == shrinkingCol.minWidth) or (growingCol.width == growingCol.maxWidth)\n-\n-            if (growingCol.getWidth() > growingCol.getPrefWidth()) {\n-                \/\/ growingCol is willing to be generous in this case - it goes\n-                \/\/ off to find a potentially better candidate to grow\n-                List<? extends TableColumnBase> seq = visibleLeafColumns.subList(colPos + 1, endColPos + 1);\n-                for (int i = seq.size() - 1; i >= 0; i--) {\n-                    TableColumnBase<?,?> c = seq.get(i);\n-                    if (c.getWidth() < c.getPrefWidth()) {\n-                        growingCol = c;\n-                        break;\n-                    }\n-                }\n-            }\n-            \/\/\n-            \/\/        if (shrinkingCol.width < shrinkingCol.prefWidth) {\n-            \/\/            for (c in reverse table.visibleLeafColumns[colPos+1..endColPos]) {\n-            \/\/                if (c.width > c.prefWidth) {\n-            \/\/                    shrinkingCol = c;\n-            \/\/                    break;\n-            \/\/                }\n-            \/\/            }\n-            \/\/        }\n-\n-\n-\n-            double sdiff = Math.min(Math.abs(remainingDelta), shrinkingCol.getWidth() - shrinkingCol.getMinWidth());\n-\n-\/\/                System.out.println(\"\\tshrinking \" + shrinkingCol.getText() + \" and growing \" + growingCol.getText());\n-\/\/                System.out.println(\"\\t\\tMath.min(Math.abs(\"+remainingDelta+\"), \"+shrinkingCol.getWidth()+\" - \"+shrinkingCol.getMinWidth()+\") = \" + sdiff);\n-\n-            double delta1 = resize(shrinkingCol, -sdiff);\n-            double delta2 = resize(growingCol, sdiff);\n-            remainingDelta += isShrinking ? sdiff : -sdiff;\n-        }\n-        return remainingDelta == 0;\n-    }\n-\n@@ -468,1 +285,0 @@\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TableUtil.java","additions":0,"deletions":184,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-\n+import com.sun.javafx.collections.MappingChange;\n+import com.sun.javafx.collections.NonIterableChange;\n@@ -43,0 +44,1 @@\n+import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;\n@@ -44,0 +46,1 @@\n+import com.sun.javafx.scene.control.TableColumnComparatorBase.TableColumnComparator;\n@@ -46,2 +49,2 @@\n-\n-import javafx.beans.*;\n+import javafx.beans.DefaultProperty;\n+import javafx.beans.InvalidationListener;\n@@ -49,0 +52,1 @@\n+import javafx.beans.WeakInvalidationListener;\n@@ -69,0 +73,1 @@\n+import javafx.css.converter.SizeConverter;\n@@ -74,0 +79,1 @@\n+import javafx.scene.control.skin.TableViewSkin;\n@@ -77,7 +83,0 @@\n-import com.sun.javafx.collections.MappingChange;\n-import com.sun.javafx.collections.NonIterableChange;\n-import javafx.css.converter.SizeConverter;\n-import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;\n-import com.sun.javafx.scene.control.TableColumnComparatorBase.TableColumnComparator;\n-import javafx.scene.control.skin.TableViewSkin;\n-\n@@ -398,0 +397,60 @@\n+    \/**\n+     * A policy that tries to adjust other columns in order to fit the table width.\n+     * <p>\n+     * When column constraints make it impossible to fit all the columns into the allowed area,\n+     * the columns are either clipped, or an empty space appears.  This policy disables the horizontal\n+     * scroll bar.\n+     *\/\n+    public static final Callback<TableView.ResizeFeatures, Boolean> CONSTRAINED_RESIZE_POLICY_ALL_COLUMNS =\n+        ConstrainedColumnResize.forTable(ConstrainedColumnResize.ResizeMode.AUTO_RESIZE_ALL_COLUMNS);\n+\n+    \/**\n+     * A policy that tries to adjust last column in order to fit the table width.\n+     * <p>\n+     * When column constraints make it impossible to fit all the columns into the allowed area,\n+     * the columns are either clipped, or an empty space appears.  This policy disables the horizontal\n+     * scroll bar.\n+     *\/\n+    public static final Callback<TableView.ResizeFeatures, Boolean> CONSTRAINED_RESIZE_POLICY_LAST_COLUMN =\n+        ConstrainedColumnResize.forTable(ConstrainedColumnResize.ResizeMode.AUTO_RESIZE_LAST_COLUMN);\n+\n+    \/**\n+     * A policy adjusts the next column in the opposite way in order to fit the table width.\n+     * <p>\n+     * When column constraints make it impossible to fit all the columns into the allowed area,\n+     * the columns are either clipped, or an empty space appears.  This policy disables the horizontal\n+     * scroll bar.\n+     *\/\n+    public static final Callback<TableView.ResizeFeatures, Boolean> CONSTRAINED_RESIZE_POLICY_NEXT_COLUMN =\n+        ConstrainedColumnResize.forTable(ConstrainedColumnResize.ResizeMode.AUTO_RESIZE_NEXT_COLUMN);\n+\n+    \/**\n+     * A policy that tries to adjust subsequent columns in order to fit the table width.\n+     * <p>\n+     * When column constraints make it impossible to fit all the columns into the allowed area,\n+     * the columns are either clipped, or an empty space appears.  This policy disables the horizontal\n+     * scroll bar.\n+     *\/\n+    public static final Callback<TableView.ResizeFeatures, Boolean> CONSTRAINED_RESIZE_POLICY_SUBSEQUENT_COLUMNS =\n+        ConstrainedColumnResize.forTable(ConstrainedColumnResize.ResizeMode.AUTO_RESIZE_SUBSEQUENT_COLUMNS);\n+\n+    \/**\n+     * A policy that tries to adjust columns, starting with the next one, in order to fit the table width.\n+     * <p>\n+     * When column constraints make it impossible to fit all the columns into the allowed area,\n+     * the columns are either clipped, or an empty space appears.  This policy disables the horizontal\n+     * scroll bar.\n+     *\/\n+    public static final Callback<TableView.ResizeFeatures, Boolean> CONSTRAINED_RESIZE_POLICY_FLEX_HEAD =\n+        ConstrainedColumnResize.forTable(ConstrainedColumnResize.ResizeMode.AUTO_RESIZE_FLEX_HEAD);\n+\n+    \/**\n+     * A policy that tries to adjust columns, starting with the last one, in order to fit the table width.\n+     * <p>\n+     * When column constraints make it impossible to fit all the columns into the allowed area,\n+     * the columns are either clipped, or an empty space appears.  This policy disables the horizontal\n+     * scroll bar.\n+     *\/\n+    public static final Callback<TableView.ResizeFeatures, Boolean> CONSTRAINED_RESIZE_POLICY_FLEX_TAIL =\n+        ConstrainedColumnResize.forTable(ConstrainedColumnResize.ResizeMode.AUTO_RESIZE_FLEX_TAIL);\n+\n@@ -410,19 +469,3 @@\n-    public static final Callback<ResizeFeatures, Boolean> CONSTRAINED_RESIZE_POLICY = new Callback<ResizeFeatures, Boolean>() {\n-\n-        private boolean isFirstRun = true;\n-\n-        @Override public String toString() {\n-            return \"constrained-resize\";\n-        }\n-\n-        @Override public Boolean call(ResizeFeatures prop) {\n-            TableView<?> table = prop.getTable();\n-            List<? extends TableColumnBase<?,?>> visibleLeafColumns = table.getVisibleLeafColumns();\n-            Boolean result = TableUtil.constrainedResize(prop,\n-                                               isFirstRun,\n-                                               table.contentWidth,\n-                                               visibleLeafColumns);\n-            isFirstRun = ! isFirstRun ? false : ! result;\n-            return result;\n-        }\n-    };\n+    @Deprecated(since=\"20\")\n+    public static final Callback<ResizeFeatures, Boolean> CONSTRAINED_RESIZE_POLICY =\n+        CONSTRAINED_RESIZE_POLICY_FLEX_TAIL;\n@@ -1860,0 +1903,10 @@\n+\n+        @Override\n+        public Node getTableNode() {\n+            return table;\n+        }\n+\n+        @Override\n+        public double getContentWidth() {\n+            return table.contentWidth;\n+        }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TableView.java","additions":82,"deletions":29,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -28,24 +28,0 @@\n-import com.sun.javafx.collections.MappingChange;\n-import com.sun.javafx.collections.NonIterableChange;\n-import com.sun.javafx.scene.control.Properties;\n-import com.sun.javafx.scene.control.SelectedCellsMap;\n-\n-import com.sun.javafx.scene.control.behavior.TableCellBehavior;\n-import com.sun.javafx.scene.control.behavior.TableCellBehaviorBase;\n-import com.sun.javafx.scene.control.behavior.TreeTableCellBehavior;\n-\n-import javafx.beans.property.DoubleProperty;\n-import javafx.css.CssMetaData;\n-import javafx.css.PseudoClass;\n-\n-import javafx.css.converter.SizeConverter;\n-import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;\n-import com.sun.javafx.scene.control.TableColumnComparatorBase;\n-\n-import javafx.css.Styleable;\n-import javafx.css.StyleableDoubleProperty;\n-import javafx.css.StyleableProperty;\n-import javafx.event.WeakEventHandler;\n-\n-import javafx.scene.control.skin.TreeTableViewSkin;\n-\n@@ -66,1 +42,9 @@\n-\n+import com.sun.javafx.collections.MappingChange;\n+import com.sun.javafx.collections.NonIterableChange;\n+import com.sun.javafx.scene.control.Properties;\n+import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;\n+import com.sun.javafx.scene.control.SelectedCellsMap;\n+import com.sun.javafx.scene.control.TableColumnComparatorBase;\n+import com.sun.javafx.scene.control.behavior.TableCellBehavior;\n+import com.sun.javafx.scene.control.behavior.TableCellBehaviorBase;\n+import com.sun.javafx.scene.control.behavior.TreeTableCellBehavior;\n@@ -72,0 +56,1 @@\n+import javafx.beans.property.DoubleProperty;\n@@ -88,0 +73,6 @@\n+import javafx.css.CssMetaData;\n+import javafx.css.PseudoClass;\n+import javafx.css.Styleable;\n+import javafx.css.StyleableDoubleProperty;\n+import javafx.css.StyleableProperty;\n+import javafx.css.converter.SizeConverter;\n@@ -91,0 +82,1 @@\n+import javafx.event.WeakEventHandler;\n@@ -94,0 +86,1 @@\n+import javafx.scene.control.skin.TreeTableViewSkin;\n@@ -540,0 +533,60 @@\n+    \/**\n+     * A policy that tries to adjust other columns in order to fit the tree table width.\n+     * <p>\n+     * When column constraints make it impossible to fit all the columns into the allowed area,\n+     * the columns are either clipped, or an empty space appears.  This policy disables the horizontal\n+     * scroll bar.\n+     *\/\n+    public static final Callback<TreeTableView.ResizeFeatures, Boolean> CONSTRAINED_RESIZE_POLICY_ALL_COLUMNS =\n+        ConstrainedColumnResize.forTreeTable(ConstrainedColumnResize.ResizeMode.AUTO_RESIZE_ALL_COLUMNS);\n+\n+    \/**\n+     * A policy that tries to adjust last column in order to fit the tree table width.\n+     * <p>\n+     * When column constraints make it impossible to fit all the columns into the allowed area,\n+     * the columns are either clipped, or an empty space appears.  This policy disables the horizontal\n+     * scroll bar.\n+     *\/\n+    public static final Callback<TreeTableView.ResizeFeatures, Boolean> CONSTRAINED_RESIZE_POLICY_LAST_COLUMN =\n+        ConstrainedColumnResize.forTreeTable(ConstrainedColumnResize.ResizeMode.AUTO_RESIZE_LAST_COLUMN);\n+\n+    \/**\n+     * A policy adjusts the next column in the opposite way in order to fit the tree table width.\n+     * <p>\n+     * When column constraints make it impossible to fit all the columns into the allowed area,\n+     * the columns are either clipped, or an empty space appears.  This policy disables the horizontal\n+     * scroll bar.\n+     *\/\n+    public static final Callback<TreeTableView.ResizeFeatures, Boolean> CONSTRAINED_RESIZE_POLICY_NEXT_COLUMN =\n+        ConstrainedColumnResize.forTreeTable(ConstrainedColumnResize.ResizeMode.AUTO_RESIZE_NEXT_COLUMN);\n+\n+    \/**\n+     * A policy that tries to adjust subsequent columns in order to fit the tree table width.\n+     * <p>\n+     * When column constraints make it impossible to fit all the columns into the allowed area,\n+     * the columns are either clipped, or an empty space appears.  This policy disables the horizontal\n+     * scroll bar.\n+     *\/\n+    public static final Callback<TreeTableView.ResizeFeatures, Boolean> CONSTRAINED_RESIZE_POLICY_SUBSEQUENT_COLUMNS =\n+        ConstrainedColumnResize.forTreeTable(ConstrainedColumnResize.ResizeMode.AUTO_RESIZE_SUBSEQUENT_COLUMNS);\n+\n+    \/**\n+     * A policy that tries to adjust columns, starting with the next one, in order to fit the tree table width.\n+     * <p>\n+     * When column constraints make it impossible to fit all the columns into the allowed area,\n+     * the columns are either clipped, or an empty space appears.  This policy disables the horizontal\n+     * scroll bar.\n+     *\/\n+    public static final Callback<TreeTableView.ResizeFeatures, Boolean> CONSTRAINED_RESIZE_POLICY_FLEX_HEAD =\n+        ConstrainedColumnResize.forTreeTable(ConstrainedColumnResize.ResizeMode.AUTO_RESIZE_FLEX_HEAD);\n+\n+    \/**\n+     * A policy that tries to adjust columns, starting with the last one, in order to fit the table width.\n+     * <p>\n+     * When column constraints make it impossible to fit all the columns into the allowed area,\n+     * the columns are either clipped, or an empty space appears.  This policy disables the horizontal\n+     * scroll bar.\n+     *\/\n+    public static final Callback<TreeTableView.ResizeFeatures, Boolean> CONSTRAINED_RESIZE_POLICY_FLEX_TAIL =\n+        ConstrainedColumnResize.forTreeTable(ConstrainedColumnResize.ResizeMode.AUTO_RESIZE_FLEX_TAIL);\n+\n@@ -552,0 +605,1 @@\n+    @Deprecated(since=\"20\")\n@@ -553,19 +607,1 @@\n-            new Callback<TreeTableView.ResizeFeatures, Boolean>() {\n-\n-        private boolean isFirstRun = true;\n-\n-        @Override public String toString() {\n-            return \"constrained-resize\";\n-        }\n-\n-        @Override public Boolean call(TreeTableView.ResizeFeatures prop) {\n-            TreeTableView<?> table = prop.getTable();\n-            List<? extends TableColumnBase<?,?>> visibleLeafColumns = table.getVisibleLeafColumns();\n-            Boolean result = TableUtil.constrainedResize(prop,\n-                                               isFirstRun,\n-                                               table.contentWidth,\n-                                               visibleLeafColumns);\n-            isFirstRun = ! isFirstRun ? false : ! result;\n-            return result;\n-        }\n-    };\n+        CONSTRAINED_RESIZE_POLICY_FLEX_TAIL;\n@@ -2185,0 +2221,10 @@\n+\n+        @Override\n+        public Node getTableNode() {\n+            return treeTable;\n+        }\n+\n+        @Override\n+        public double getContentWidth() {\n+            return treeTable.contentWidth;\n+        }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeTableView.java","additions":90,"deletions":44,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import com.sun.javafx.scene.control.Properties;\n-import com.sun.javafx.scene.control.TableColumnBaseHelper;\n@@ -30,1 +28,0 @@\n-import com.sun.javafx.scene.control.skin.Utils;\n@@ -37,0 +34,1 @@\n+import javafx.scene.control.ConstrainedColumnResizeBase;\n@@ -40,1 +38,0 @@\n-import javafx.scene.control.TableCell;\n@@ -47,1 +44,0 @@\n-import javafx.scene.control.TreeTableCell;\n@@ -49,1 +45,0 @@\n-import javafx.scene.control.TreeTableRow;\n@@ -51,1 +46,0 @@\n-import javafx.scene.layout.Region;\n@@ -54,3 +48,0 @@\n-import java.util.List;\n-import java.util.Optional;\n-\n@@ -214,2 +205,1 @@\n-        return (x == TableView.CONSTRAINED_RESIZE_POLICY) ||\n-               (x == TreeTableView.CONSTRAINED_RESIZE_POLICY);\n+        return (x instanceof ConstrainedColumnResizeBase);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableSkinUtils.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,310 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.scene.control;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.junit.After;\n+import org.junit.Test;\n+import com.sun.javafx.tk.Toolkit;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.scene.control.ConstrainedColumnResizeBase;\n+import javafx.scene.control.ResizeHelper;\n+import javafx.scene.control.SelectionMode;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableColumnBase;\n+import javafx.scene.control.TableView;\n+import javafx.scene.layout.BorderPane;\n+import javafx.util.Callback;\n+import test.com.sun.javafx.scene.control.infrastructure.StageLoader;\n+\n+\/**\n+ * Tests the new column resize policies with TableView.\n+ *\n+ * TODO rename\n+ * TODO parallel class with TreeTableView, or as part of each test?\n+ *\/\n+public class ResizeHelperTest {\n+\n+    public enum Cmd {\n+        ROWS,\n+        COL,\n+        MIN,\n+        PREF,\n+        MAX,\n+        COMBINE\n+    }\n+\n+    private StageLoader stageLoader;\n+\n+    @After\n+    public void after() {\n+        if (stageLoader != null) {\n+            stageLoader.dispose();\n+        }\n+    }\n+\n+    protected void checkInvariants(TableView<String> t) {\n+        List<TableColumn<String,?>> cols = t.getColumns();\n+        for (TableColumn<String,?> c: cols) {\n+            assertTrue(\"violated min constraint: w=\" + c.getWidth() + \" min=\" + c.getMinWidth(),\n+                       c.getWidth() >= c.getMinWidth());\n+            assertTrue(\"violated max constraint: w=\" + c.getWidth() + \" max=\" + c.getMaxWidth(),\n+                       c.getWidth() <= c.getMaxWidth());\n+        }\n+    }\n+\n+    protected static TableView<String> createTable(Object[] spec) {\n+        TableView<String> table = new TableView();\n+        table.getSelectionModel().setCellSelectionEnabled(true);\n+        table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);\n+\n+        TableColumn<String, String> lastColumn = null;\n+        int id = 1;\n+\n+        for (int i = 0; i < spec.length;) {\n+            Object x = spec[i++];\n+            if (x instanceof Cmd cmd) {\n+                switch (cmd) {\n+                case COL:\n+                    TableColumn<String, String> c = new TableColumn<>();\n+                    table.getColumns().add(c);\n+                    c.setText(\"C\" + table.getColumns().size());\n+                    c.setCellValueFactory((f) -> new SimpleStringProperty(\" \"));\n+                    lastColumn = c;\n+                    break;\n+                case MAX:\n+                    {\n+                        int w = (int)(spec[i++]);\n+                        lastColumn.setMaxWidth(w);\n+                    }\n+                    break;\n+                case MIN:\n+                    {\n+                        int w = (int)(spec[i++]);\n+                        lastColumn.setMinWidth(w);\n+                    }\n+                    break;\n+                case PREF:\n+                    {\n+                        int w = (int)(spec[i++]);\n+                        lastColumn.setPrefWidth(w);\n+                    }\n+                    break;\n+                case ROWS:\n+                    int n = (int)(spec[i++]);\n+                    for (int j = 0; j < n; j++) {\n+                        table.getItems().add(String.valueOf(n));\n+                    }\n+                    break;\n+                case COMBINE:\n+                    int ix = (int)(spec[i++]);\n+                    int ct = (int)(spec[i++]);\n+                    combineColumns(table, ix, ct, id++);\n+                    break;\n+                default:\n+                    throw new Error(\"?\" + cmd);\n+                }\n+            } else {\n+                throw new Error(\"?\" + x);\n+            }\n+        }\n+\n+        return table;\n+    }\n+\n+    protected static void combineColumns(TableView<String> t, int ix, int count, int name) {\n+        TableColumn<String,String> tc = new TableColumn<>();\n+        tc.setText(\"N\" + name);\n+\n+        for (int i = 0; i < count; i++) {\n+            TableColumn<String, String> c = (TableColumn<String, String>)t.getColumns().remove(ix);\n+            tc.getColumns().add(c);\n+        }\n+        t.getColumns().add(ix, tc);\n+    }\n+\n+    \/** verify that a custom constrained resize policy can indeed be implemented using public APIs *\/\n+    @Test\n+    public void testCanImplementCustomResizePolicy() {\n+        double WIDTH = 15.0;\n+\n+        \/\/ constrained resize policy that simply sets all column widths to WIDTH\n+        class UserPolicy\n+            extends ConstrainedColumnResizeBase\n+            implements Callback<TableView.ResizeFeatures, Boolean> {\n+\n+            @Override\n+            public Boolean call(TableView.ResizeFeatures rf) {\n+                List<? extends TableColumnBase<?, ?>> columns = rf.getTable().getVisibleLeafColumns();\n+                int sz = columns.size();\n+                \/\/ new public method getContentWidth() is visible\n+                double w = rf.getContentWidth();\n+                for (TableColumnBase<?, ?> c: columns) {\n+                    \/\/ using added public method setColumnWidth()\n+                    rf.setColumnWidth(c, WIDTH);\n+                }\n+                return false;\n+            }\n+        }\n+\n+        Object[] spec = {\n+            Cmd.ROWS, 3,\n+            Cmd.COL,\n+            Cmd.COL,\n+            Cmd.COL,\n+            Cmd.COL\n+        };\n+        TableView<String> table = createTable(spec);\n+\n+        UserPolicy policy = new UserPolicy();\n+        table.setColumnResizePolicy(policy);\n+        table.setPrefWidth(10);\n+\n+        \/\/ verify the policy is in effect\n+\n+        stageLoader = new StageLoader(new BorderPane(table));\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (TableColumn<?, ?> c: table.getColumns()) {\n+            assertEquals(WIDTH, c.getWidth());\n+        }\n+\n+        \/\/ resize and check again\n+        table.setPrefWidth(10_000);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (TableColumn<?, ?> c: table.getColumns()) {\n+            assertEquals(WIDTH, c.getWidth());\n+        }\n+    }\n+\n+    \/**\n+     * Exhausive behavioral test.\n+     *\n+     * Goes through all the policies, all valid combinations of constraints,\n+     * and widths increasing to MAX_WIDTH and back,\n+     * checkint that the initial resize does not violate (min,max) constraints.\n+     *\/\n+    \/\/@Test \/\/ this test takes too much time!\n+    public void testWidthChange() {\n+        long start = System.currentTimeMillis();\n+        for (int numCols: COLUMNS) {\n+            SpecGen gen = new SpecGen(numCols);\n+            while (gen.hasNext()) {\n+                Object[] spec = gen.next();\n+                TableView<String> table = createTable(spec);\n+                stageLoader = new StageLoader(new BorderPane(table));\n+                try {\n+                    for (int ip = 0; ip < POLICIES.length; ip++) {\n+                        Callback<TableView.ResizeFeatures, Boolean> policy = createPolicy(ip);\n+                        table.setColumnResizePolicy(policy);\n+                        for (int width: WIDTHS) {\n+                            table.setPrefWidth(width);\n+                            Toolkit.getToolkit().firePulse();\n+                            checkInvariants(table);\n+                        }\n+                    }\n+                } finally {\n+                    stageLoader.dispose();\n+                }\n+            }\n+        }\n+\n+        System.out.println(\"elapsed time = \" + (System.currentTimeMillis() - start) \/ 60_000 + \" minutes.\");\n+    }\n+\n+    protected static final Object[] POLICIES = {\n+        TableView.CONSTRAINED_RESIZE_POLICY_FLEX_HEAD,\n+        TableView.CONSTRAINED_RESIZE_POLICY_FLEX_TAIL,\n+        TableView.CONSTRAINED_RESIZE_POLICY_ALL_COLUMNS,\n+        TableView.CONSTRAINED_RESIZE_POLICY_LAST_COLUMN,\n+        TableView.CONSTRAINED_RESIZE_POLICY_NEXT_COLUMN,\n+        TableView.CONSTRAINED_RESIZE_POLICY_SUBSEQUENT_COLUMNS\n+    };\n+\n+    protected static Callback<TableView.ResizeFeatures, Boolean> createPolicy(int ix) {\n+        return (Callback<TableView.ResizeFeatures, Boolean>)POLICIES[ix];\n+    }\n+\n+    protected static final int[] WIDTHS = {\n+        0, 10, 100, 10_000, 200, 50\n+    };\n+\n+    protected static final int[] COLUMNS = {\n+        0, 1, 2, 5\n+    };\n+\n+    protected static class SpecGen {\n+        private static final int LAST = 8; \/\/ 2^3 min,pref,max + 1 fixed\n+        private final int[] phase;\n+\n+        public SpecGen(int numcols) {\n+            this.phase = new int[numcols];\n+        }\n+\n+        public boolean hasNext() {\n+            int terminal = LAST;\n+            for (int n: phase) {\n+                if (n != terminal) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public Object[] next() {\n+            ArrayList<Object> rv = new ArrayList<>(phase.length);\n+            for (int i = 0; i < phase.length; i++) {\n+                rv.add(Cmd.COL);\n+\n+                int n = phase[i];\n+                if (n < 8) {\n+                    if ((n & 0x01) != 0) {\n+                        rv.add(Cmd.MIN);\n+                        rv.add(100);\n+                    }\n+\n+                    if ((n & 0x02) != 0) {\n+                        rv.add(Cmd.PREF);\n+                        rv.add(200 + 50 * i);\n+                    }\n+\n+                    if ((n & 0x04) != 0) {\n+                        rv.add(Cmd.MAX);\n+                        rv.add(200 + 100 * i);\n+                    }\n+                } else if (n == LAST) {\n+                    rv.add(Cmd.MIN);\n+                    rv.add(50);\n+                    rv.add(Cmd.MAX);\n+                    rv.add(50);\n+                }\n+            }\n+            return rv.toArray();\n+        }\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ResizeHelperTest.java","additions":310,"deletions":0,"binary":false,"changes":310,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<classpath>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/base\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/graphics\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/controls\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/swing\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry excluding=\".classpath|.project|.settings|src\/\" kind=\"src\" output=\"bin\" path=\"\"\/>\n+\t<classpathentry kind=\"src\" path=\"src\"\/>\n+\t<classpathentry kind=\"output\" path=\"bin\"\/>\n+<\/classpath>\n","filename":"tests\/manual\/tester\/.classpath","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<projectDescription>\n+    <name>manualTests-tester<\/name>\n+    <comment><\/comment>\n+    <projects>\n+    <\/projects>\n+    <buildSpec>\n+        <buildCommand>\n+            <name>org.eclipse.jdt.core.javabuilder<\/name>\n+            <arguments>\n+            <\/arguments>\n+        <\/buildCommand>\n+    <\/buildSpec>\n+    <natures>\n+        <nature>org.eclipse.jdt.core.javanature<\/nature>\n+    <\/natures>\n+<\/projectDescription>\n","filename":"tests\/manual\/tester\/.project","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"","filename":"tests\/manual\/tester\/.settings\/org.eclipse.core.resources.prefs","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":".settings\/org.eclipse.core.resources.prefs","status":"copied"},{"patch":"@@ -0,0 +1,652 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.javafx.tester;\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.util.List;\n+import javax.swing.JComponent;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JSplitPane;\n+import javax.swing.JTable;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.table.DefaultTableModel;\n+import javafx.application.Application;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.embed.swing.SwingNode;\n+import javafx.geometry.Orientation;\n+import javafx.scene.Scene;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.ConstrainedColumnResize;\n+import javafx.scene.control.ConstrainedColumnResize.ResizeMode;\n+import javafx.scene.control.ConstrainedColumnResizeBase;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.ResizeHelper;\n+import javafx.scene.control.SelectionMode;\n+import javafx.scene.control.SplitPane;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableColumnBase;\n+import javafx.scene.control.TableView;\n+import javafx.scene.control.TableView.ResizeFeatures;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.Pane;\n+import javafx.stage.Stage;\n+import javafx.util.Callback;\n+\n+\/**\n+ * Tests TableView\/JTable constrained column resize modes.\n+ *\/\n+public class ATableViewResizeTester extends Application {\n+\n+    enum Demo {\n+        PREF(\"pref only\"),\n+        ALL(\"all set: min, pref, max\"),\n+        EMPTY(\"empty with pref\"),\n+        MIN_WIDTH(\"min width\"),\n+        MAX_WIDTH(\"max width\"),\n+        MIN_WIDTH2(\"min width (middle)\"),\n+        MAX_WIDTH2(\"max width (middle)\"),\n+        MIN_WIDTH3(\"min width (beginning)\"),\n+        MAX_WIDTH3(\"max width (beginning)\"),\n+        FIXED_MIDDLE(\"fixed in the middle\"),\n+        ALL_FIXED(\"all fixed\"),\n+        ALL_MAX(\"all with maximum width\"),\n+        MIN_IN_CENTER(\"min widths set in middle columns\"),\n+        MAX_IN_CENTER(\"max widths set in middle columns\"),\n+        NO_NESTED(\"no nested columns\"),\n+        NESTED(\"nested columns\"),\n+        MILLION(\"million rows\"),\n+        MANY_COLUMNS(\"many columns\"),\n+        MANY_COLUMNS_SAME(\"many columns, same pref\");\n+\n+        private final String text;\n+        Demo(String text) { this.text = text; }\n+        public String toString() { return text; }\n+    }\n+\n+    public enum Policy {\n+        AUTO_RESIZE_FLEX_HEAD(JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS),\n+        AUTO_RESIZE_FLEX_TAIL(JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS),\n+        AUTO_RESIZE_NEXT_COLUMN(JTable.AUTO_RESIZE_NEXT_COLUMN),\n+        AUTO_RESIZE_SUBSEQUENT_COLUMNS(JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS),\n+        AUTO_RESIZE_LAST_COLUMN(JTable.AUTO_RESIZE_LAST_COLUMN),\n+        AUTO_RESIZE_ALL_COLUMNS(JTable.AUTO_RESIZE_ALL_COLUMNS),\n+        USER(JTable.AUTO_RESIZE_ALL_COLUMNS),\n+        UNCONSTRAINED_RESIZE_POLICY(JTable.AUTO_RESIZE_OFF),\n+        CONSTRAINED_RESIZE_POLICY(JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS);\n+\n+        private final int value;\n+        Policy(int v) { this.value = v; }\n+        public int getValue() { return value; }\n+    }\n+\n+    public enum Cmd {\n+        ROWS,\n+        COL,\n+        MIN,\n+        PREF,\n+        MAX,\n+        COMBINE\n+    }\n+\n+    protected BorderPane contentPane;\n+    protected ComboBox<Demo> demoSelector;\n+    protected ComboBox<Policy> policySelector;\n+    protected SwingPanel swingPanel;\n+\n+    public static void main(String[] args) {\n+        Application.launch(ATableViewResizeTester.class, args);\n+    }\n+\n+    @Override\n+    public void start(Stage stage) throws Exception {\n+        contentPane = new BorderPane();\n+\n+        \/\/ selector\n+        demoSelector = new ComboBox<>();\n+        demoSelector.getItems().addAll(Demo.values());\n+        demoSelector.setEditable(false);\n+        demoSelector.getSelectionModel().selectedItemProperty().addListener((s,p,c) -> {\n+            updatePane();\n+        });\n+\n+        policySelector = new ComboBox<>();\n+        policySelector.getItems().addAll(Policy.values());\n+        policySelector.setEditable(false);\n+        policySelector.getSelectionModel().selectedItemProperty().addListener((s,p,c) -> {\n+            updatePane();\n+        });\n+\n+        \/\/ layout\n+\n+        SplitPane split = new SplitPane(contentPane, new BorderPane());\n+\n+        HBox hb = new HBox(\n+            new Label(\"Data:\"),\n+            demoSelector,\n+            new Label(\" Policy:\"),\n+            policySelector\n+        );\n+        hb.setSpacing(5);\n+\n+        BorderPane bp = new BorderPane();\n+        bp.setTop(hb);\n+        bp.setCenter(split);\n+\n+        SwingNode swn = new SwingNode();\n+        EventQueue.invokeLater(() -> {\n+            swingPanel = new SwingPanel();\n+            swn.setContent(swingPanel);\n+        });\n+\n+        SplitPane sp = new SplitPane(bp, new BorderPane(swn));\n+        sp.setOrientation(Orientation.VERTICAL);\n+\n+        stage.setScene(new Scene(sp));\n+        stage.setWidth(1000);\n+        stage.setHeight(500);\n+        stage.setTitle(\"TableView\/JTable Resize Tester \" + System.getProperty(\"java.version\"));\n+        stage.show();\n+\n+        demoSelector.getSelectionModel().selectFirst();\n+        policySelector.getSelectionModel().selectFirst();\n+    }\n+\n+    protected Callback<ResizeFeatures,Boolean> wrap(Callback<ResizeFeatures,Boolean> policy) {\n+        return new Callback<ResizeFeatures,Boolean>() {\n+            @Override\n+            public Boolean call(ResizeFeatures f) {\n+                Boolean rv = policy.call(f);\n+                int ix = f.getTable().getColumns().indexOf(f.getColumn());\n+                System.out.println(\n+                    \"col=\" + (ix < 0 ? f.getColumn() : ix) +\n+                    \" delta=\" + f.getDelta() +\n+                    \" w=\" + f.getTable().getWidth() +\n+                    \" rv=\" + rv\n+                );\n+                return rv;\n+            }\n+        };\n+    }\n+\n+    protected String describe(TableColumn c) {\n+        StringBuilder sb = new StringBuilder();\n+        if(c.getMinWidth() != 10.0) {\n+            sb.append(\"m\");\n+        }\n+        if(c.getPrefWidth() != 80.0) {\n+            sb.append(\"p\");\n+        }\n+        if(c.getMaxWidth() != 5000.0) {\n+            sb.append(\"X\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    protected Callback<ResizeFeatures, Boolean> createPolicy(Policy p) {\n+        switch(p) {\n+        case AUTO_RESIZE_FLEX_HEAD:\n+            return ConstrainedColumnResize.forTable(ResizeMode.AUTO_RESIZE_FLEX_HEAD);\n+        case AUTO_RESIZE_FLEX_TAIL:\n+            return ConstrainedColumnResize.forTable(ResizeMode.AUTO_RESIZE_FLEX_TAIL);\n+        case AUTO_RESIZE_ALL_COLUMNS:\n+            return ConstrainedColumnResize.forTable(ResizeMode.AUTO_RESIZE_ALL_COLUMNS);\n+        case AUTO_RESIZE_LAST_COLUMN:\n+            return ConstrainedColumnResize.forTable(ResizeMode.AUTO_RESIZE_LAST_COLUMN);\n+        case AUTO_RESIZE_NEXT_COLUMN:\n+            return ConstrainedColumnResize.forTable(ResizeMode.AUTO_RESIZE_NEXT_COLUMN);\n+        case AUTO_RESIZE_SUBSEQUENT_COLUMNS:\n+            return ConstrainedColumnResize.forTable(ResizeMode.AUTO_RESIZE_SUBSEQUENT_COLUMNS);\n+        case CONSTRAINED_RESIZE_POLICY:\n+            return TableView.CONSTRAINED_RESIZE_POLICY;\n+        case UNCONSTRAINED_RESIZE_POLICY:\n+            return TableView.UNCONSTRAINED_RESIZE_POLICY;\n+        case USER:\n+            return new UserDefinedResizePolicy();\n+        default:\n+            throw new Error(\"?\" + p);\n+        }\n+    }\n+\n+    protected Object[] createSpec(Demo d) {\n+        switch(d) {\n+        case ALL:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL,\n+                Cmd.COL, Cmd.MIN, 20, Cmd.PREF, 20, Cmd.MAX, 20,\n+                Cmd.COL, Cmd.PREF, 200,\n+                Cmd.COL, Cmd.PREF, 300, Cmd.MAX, 400,\n+                Cmd.COL\n+            };\n+        case PREF:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL, Cmd.PREF, 100,\n+                Cmd.COL, Cmd.PREF, 200,\n+                Cmd.COL, Cmd.PREF, 300,\n+                Cmd.COL, Cmd.PREF, 400\n+            };\n+        case EMPTY:\n+            return new Object[] {\n+                Cmd.COL, Cmd.PREF, 100,\n+                Cmd.COL, Cmd.PREF, 200,\n+                Cmd.COL, Cmd.PREF, 300\n+            };\n+        case MIN_WIDTH:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL, Cmd.MIN, 300\n+            };\n+        case MAX_WIDTH:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL, Cmd.MAX, 100\n+            };\n+        case MIN_WIDTH2:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL, Cmd.MIN, 300,\n+                Cmd.COL\n+            };\n+        case MAX_WIDTH2:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL, Cmd.MAX, 100,\n+                Cmd.COL\n+            };\n+        case MIN_WIDTH3:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL, Cmd.MIN, 300,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL\n+            };\n+        case MAX_WIDTH3:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL, Cmd.MAX, 100,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL\n+            };\n+        case MIN_IN_CENTER:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL,\n+                Cmd.COL, Cmd.MIN, 20,\n+                Cmd.COL, Cmd.MIN, 30,\n+                Cmd.COL, Cmd.MIN, 40,\n+                Cmd.COL, Cmd.MIN, 50,\n+                Cmd.COL, Cmd.MIN, 60,\n+                Cmd.COL\n+            };\n+        case MAX_IN_CENTER:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL,\n+                Cmd.COL, Cmd.MAX, 20,\n+                Cmd.COL, Cmd.MAX, 30,\n+                Cmd.COL, Cmd.MAX, 40,\n+                Cmd.COL, Cmd.MAX, 50,\n+                Cmd.COL, Cmd.MAX, 60,\n+                Cmd.COL\n+            };\n+        case FIXED_MIDDLE:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL, Cmd.MIN, 100, Cmd.MAX, 100,\n+                Cmd.COL, Cmd.MIN, 100, Cmd.MAX, 100,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL\n+            };\n+        case ALL_FIXED:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL, Cmd.MIN, 50, Cmd.MAX, 50,\n+                Cmd.COL, Cmd.MIN, 50, Cmd.MAX, 50,\n+                Cmd.COL, Cmd.MIN, 50, Cmd.MAX, 50\n+            };\n+        case ALL_MAX:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL, Cmd.MAX, 50,\n+                Cmd.COL, Cmd.MAX, 50,\n+                Cmd.COL, Cmd.MAX, 50\n+            };\n+       case NO_NESTED:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL, Cmd.PREF, 100,\n+                Cmd.COL, Cmd.PREF, 200,\n+                Cmd.COL, Cmd.PREF, 300,\n+                Cmd.COL, Cmd.MIN, 100, Cmd.MAX, 100,\n+                Cmd.COL, Cmd.PREF, 100,\n+                Cmd.COL, Cmd.MIN, 100,\n+                Cmd.COL, Cmd.MAX, 100,\n+                Cmd.COL, Cmd.PREF, 400,\n+                Cmd.COL\n+            };\n+        case NESTED:\n+            return new Object[] {\n+                Cmd.ROWS, 3,\n+                Cmd.COL, Cmd.PREF, 100,\n+                Cmd.COL, Cmd.PREF, 200,\n+                Cmd.COL, Cmd.PREF, 300,\n+                Cmd.COL, Cmd.MIN, 100, Cmd.MAX, 100,\n+                Cmd.COL, Cmd.PREF, 100,\n+                Cmd.COL, Cmd.MIN, 100,\n+                Cmd.COL, Cmd.MAX, 100,\n+                Cmd.COL, Cmd.PREF, 400,\n+                Cmd.COL,\n+                Cmd.COMBINE, 0, 3,\n+                Cmd.COMBINE, 1, 2\n+            };\n+        case MANY_COLUMNS:\n+            return new Object[] {\n+                Cmd.ROWS, 300,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL,\n+                Cmd.COL\n+            };\n+        case MANY_COLUMNS_SAME:\n+            return new Object[] {\n+                Cmd.ROWS, 300,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30,\n+                Cmd.COL, Cmd.PREF, 30\n+            };\n+        case MILLION:\n+            return new Object[] {\n+                Cmd.ROWS, 1_000_000,\n+                Cmd.COL,\n+                Cmd.COL\n+            };\n+        default:\n+            throw new Error(\"?\" + d);\n+        }\n+    }\n+\n+    protected void updatePane() {\n+        Policy p = policySelector.getSelectionModel().getSelectedItem();\n+        Demo d = demoSelector.getSelectionModel().getSelectedItem();\n+        Object[] spec = createSpec(d);\n+\n+        Pane n = createPane(p, spec);\n+        contentPane.setCenter(n);\n+\n+        EventQueue.invokeLater(() -> {\n+            swingPanel.updatePane(p, spec);\n+        });\n+    }\n+\n+    protected void combineColumns(TableView<String> t, int ix, int count, int name) {\n+        TableColumn<String,String> tc = new TableColumn<>();\n+        tc.setText(\"N\" + name);\n+\n+        for (int i = 0; i < count; i++) {\n+            TableColumn<String,String> c = (TableColumn<String,String>)t.getColumns().remove(ix);\n+            tc.getColumns().add(c);\n+        }\n+        t.getColumns().add(ix, tc);\n+    }\n+\n+    protected Pane createPane(Policy policy, Object[] spec) {\n+        if ((spec == null) || (policy == null)) {\n+            return new BorderPane();\n+        }\n+\n+        TableView<String> table = new TableView();\n+        table.getSelectionModel().setCellSelectionEnabled(true);\n+        table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);\n+\n+        Callback<ResizeFeatures,Boolean> p = createPolicy(policy);\n+        table.setColumnResizePolicy(p);\n+\n+        TableColumn<String,String> lastColumn = null;\n+        int id = 1;\n+\n+        for (int i = 0; i < spec.length;) {\n+            Object x = spec[i++];\n+            if (x instanceof Cmd cmd) {\n+                switch (cmd) {\n+                case COL:\n+                    TableColumn<String,String> c = new TableColumn<>();\n+                    table.getColumns().add(c);\n+                    c.setText(\"C\" + table.getColumns().size());\n+\/\/                    if (table.getColumns().size() == 1) {\n+\/\/                        c.setText(\"Really really really really really really really really really really really really really long\");\n+\/\/                    }\n+                    c.setCellValueFactory((f) -> new SimpleStringProperty(describe(c)));\n+                    lastColumn = c;\n+                    break;\n+                case MAX: {\n+                    int w = (int)(spec[i++]);\n+                    lastColumn.setMaxWidth(w);\n+                }\n+                    break;\n+                case MIN: {\n+                    int w = (int)(spec[i++]);\n+                    lastColumn.setMinWidth(w);\n+                }\n+                    break;\n+                case PREF: {\n+                    int w = (int)(spec[i++]);\n+                    lastColumn.setPrefWidth(w);\n+                }\n+                    break;\n+                case ROWS:\n+                    int n = (int)(spec[i++]);\n+                    for (int j = 0; j < n; j++) {\n+                        table.getItems().add(String.valueOf(n));\n+                    }\n+                    break;\n+                case COMBINE:\n+                    int ix = (int)(spec[i++]);\n+                    int ct = (int)(spec[i++]);\n+                    combineColumns(table, ix, ct, id++);\n+                    break;\n+                default:\n+                    throw new Error(\"?\" + cmd);\n+                }\n+            } else {\n+                throw new Error(\"?\" + x);\n+            }\n+        }\n+\n+        BorderPane bp = new BorderPane();\n+        bp.setCenter(table);\n+        return bp;\n+    }\n+\n+    protected static class SwingPanel extends JPanel {\n+        public SwingPanel() {\n+            super(new BorderLayout());\n+        }\n+\n+        public void updatePane(Policy policy, Object[] spec) {\n+            JComponent p = createPanel(policy, spec);\n+            removeAll();\n+            if (p != null) {\n+                add(p);\n+            }\n+            validate();\n+            repaint();\n+        }\n+\n+        private int createHSBPolicy(Policy p) {\n+            switch (p) {\n+            case UNCONSTRAINED_RESIZE_POLICY:\n+                return JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED;\n+            default:\n+                return JScrollPane.HORIZONTAL_SCROLLBAR_NEVER;\n+            }\n+        }\n+\n+        protected JComponent createPanel(Policy policy, Object[] spec) {\n+            if ((spec == null) || (policy == null)) {\n+                return null;\n+            }\n+\n+            DefaultTableModel m = new DefaultTableModel() {\n+                @Override\n+                public Object getValueAt(int row, int column) {\n+                    return \"\";\n+                }\n+            };\n+\n+            JTable t = new JTable(m);\n+            t.setShowHorizontalLines(true);\n+            t.setShowVerticalLines(true);\n+            t.setGridColor(Color.LIGHT_GRAY);\n+            t.setAutoResizeMode(policy.getValue());\n+\n+            javax.swing.table.TableColumn lastColumn = null;\n+\n+            for (int i = 0; i < spec.length;) {\n+                Object x = spec[i++];\n+                if (x instanceof Cmd cmd) {\n+                    switch (cmd) {\n+                    case COL:\n+                        javax.swing.table.TableColumn c = new javax.swing.table.TableColumn();\n+                        t.getColumnModel().addColumn(c);\n+                        c.setHeaderValue(\"C\" + t.getColumnCount());\n+                        lastColumn = c;\n+                        break;\n+                    case MAX: {\n+                        int w = (int)(spec[i++]);\n+                        lastColumn.setMaxWidth(w);\n+                    }\n+                        break;\n+                    case MIN: {\n+                        int w = (int)(spec[i++]);\n+                        lastColumn.setMinWidth(w);\n+                    }\n+                        break;\n+                    case PREF: {\n+                        int w = (int)(spec[i++]);\n+                        lastColumn.setPreferredWidth(w);\n+                    }\n+                        break;\n+                    case ROWS:\n+                        int n = (int)(spec[i++]);\n+                        for (int j = 0; j < n; j++) {\n+                            m.addRow((Object[])null);\n+                        }\n+                        break;\n+                    case COMBINE:\n+                        \/\/ ignored\n+                        int ix = (int)(spec[i++]);\n+                        int ct = (int)(spec[i++]);\n+                        break;\n+                    default:\n+                        throw new Error(\"?\" + cmd);\n+                    }\n+                } else {\n+                    throw new Error(\"?\" + x);\n+                }\n+            }\n+\n+            EmptyBorder b = new EmptyBorder(0, 0, 0, 0);\n+\n+            int hsp = createHSBPolicy(policy);\n+            JScrollPane scroll = new JScrollPane(t, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, hsp);\n+            scroll.setBorder(b);\n+\n+            JSplitPane split = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, scroll, new JPanel());\n+            split.setContinuousLayout(true);\n+            return split;\n+        }\n+    }\n+\n+    \/**\n+     * a user-defined policy demonstrates that we can indeed create a custom policy using the new API.\n+     * this policy simply sizes all columns equally.\n+     *\/\n+    protected static class UserDefinedResizePolicy\n+        extends ConstrainedColumnResizeBase\n+        implements Callback<TableView.ResizeFeatures,Boolean> {\n+\n+        @Override\n+        public Boolean call(ResizeFeatures rf) {\n+            List<? extends TableColumnBase<?,?>> visibleLeafColumns = rf.getTable().getVisibleLeafColumns();\n+            int sz = visibleLeafColumns.size();\n+            \/\/ using added public method getContentWidth()\n+            double w = rf.getContentWidth() \/ sz;\n+            for (TableColumnBase<?,?> c: visibleLeafColumns) {\n+                \/\/ using added public method setColumnWidth()\n+                rf.setColumnWidth(c, w);\n+            }\n+            return false;\n+        }\n+    }\n+}\n","filename":"tests\/manual\/tester\/src\/com\/oracle\/javafx\/tester\/ATableViewResizeTester.java","additions":652,"deletions":0,"binary":false,"changes":652,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+module andy_test {\n+    exports com.oracle.javafx.tester;\n+\n+    requires javafx.base;\n+    requires javafx.controls;\n+    requires javafx.graphics;\n+    requires java.desktop;\n+    requires javafx.swing;\n+}\n","filename":"tests\/manual\/tester\/src\/module-info.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"}]}