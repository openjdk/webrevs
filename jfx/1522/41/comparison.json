{"files":[{"patch":"@@ -4419,0 +4419,1 @@\n+    options.tags(\"interpolationType:a:Interpolation Type:\")\n","filename":"build.gradle","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.util.List;\n+import java.util.Objects;\n@@ -63,0 +65,60 @@\n+\n+    \/**\n+     * Converts the specified list into an unmodifiable list that does not contain {@code null} values.\n+     * The returned list is a copy of, and not a wrapper around the specified list.\n+     *\n+     * @param <T> the type of elements in the list\n+     * @param list the list, not {@code null}\n+     * @return an unmodifiable list that does not contain null values\n+     *\/\n+    public static <T> UnmodifiableArrayList<T> copyOfNullFiltered(List<T> list) {\n+        Objects.requireNonNull(list, \"list cannot be null\");\n+\n+        int numNonNullValues = 0;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newValues = (T[])new Object[list.size()];\n+\n+        if (list instanceof RandomAccess) {\n+            \/\/ Prevents the iterator allocation for random-access lists.\n+            for (int i = 0, max = list.size(); i < max; ++i) {\n+                T value = list.get(i);\n+                if (value != null) {\n+                    newValues[numNonNullValues++] = value;\n+                }\n+            }\n+        } else {\n+            for (T value : list) {\n+                if (value != null) {\n+                    newValues[numNonNullValues++] = value;\n+                }\n+            }\n+        }\n+\n+        return new UnmodifiableArrayList<>(newValues, numNonNullValues);\n+    }\n+\n+    \/**\n+     * Converts the specified array into an unmodifiable list that does not contain {@code null} values.\n+     * The returned list is a copy of, and not a wrapper around the specified array.\n+     *\n+     * @param <T> the type of elements in the array\n+     * @param elements the array, not {@code null}\n+     * @return an unmodifiable list that does not contain null values\n+     *\/\n+    public static <T> UnmodifiableArrayList<T> copyOfNullFiltered(T[] elements) {\n+        Objects.requireNonNull(elements, \"elements cannot be null\");\n+\n+        int numNonNullValues = 0;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newValues = (T[])new Object[elements.length];\n+\n+        for (int i = 0; i < elements.length; ++i) {\n+            if (elements[i] != null) {\n+                newValues[numNonNullValues++] = elements[i];\n+            }\n+        }\n+\n+        return new UnmodifiableArrayList<>(newValues, numNonNullValues);\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/UnmodifiableArrayList.java","additions":63,"deletions":1,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+--add-exports javafx.base\/com.sun.javafx=ALL-UNNAMED\n","filename":"modules\/javafx.base\/src\/test\/addExports","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx;\n+\n+import com.sun.javafx.UnmodifiableArrayList;\n+import org.junit.jupiter.api.Test;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class UnmodifiableArrayListTest {\n+\n+    @Test\n+    void testCopyOfNullFilteredList_nullList() {\n+        assertThrows(NullPointerException.class, () -> UnmodifiableArrayList.copyOfNullFiltered((List<?>)null));\n+    }\n+\n+    @Test\n+    void testCopyOfNullFilteredList_nullArray() {\n+        assertThrows(NullPointerException.class, () -> UnmodifiableArrayList.copyOfNullFiltered((Object[])null));\n+    }\n+\n+    @Test\n+    void testCopyOfNullFilteredList_randomAccess() {\n+        var list = new ArrayList<String>();\n+        list.add(\"a\");\n+        list.add(null);\n+        list.add(\"b\");\n+        list.add(null);\n+\n+        assertEquals(List.of(\"a\", \"b\"), UnmodifiableArrayList.copyOfNullFiltered(list));\n+    }\n+\n+    @Test\n+    void testCopyOfNullFilteredList_nonRandomAccess() {\n+        var list = new LinkedList<String>();\n+        list.add(\"a\");\n+        list.add(null);\n+        list.add(\"b\");\n+        list.add(null);\n+\n+        assertEquals(List.of(\"a\", \"b\"), UnmodifiableArrayList.copyOfNullFiltered(list));\n+    }\n+\n+    @Test\n+    void testCopyOfNullFilteredArray() {\n+        var list = new String[4];\n+        list[0] = \"a\";\n+        list[1] = null;\n+        list[2] = \"b\";\n+        list[3] = null;\n+\n+        assertEquals(List.of(\"a\", \"b\"), UnmodifiableArrayList.copyOfNullFiltered(list));\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/UnmodifiableArrayListTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.util;\n+\n+import java.lang.reflect.Field;\n+import java.util.function.Function;\n+\n+public final class ReflectionUtils {\n+\n+    \/**\n+     * Returns the value of a potentially private field of the specified object.\n+     * The field can be declared on any of the object's inherited classes.\n+     *\/\n+    public static Object getFieldValue(Object object, String fieldName) {\n+        Function<Class<?>, Field> getField = cls -> {\n+            try {\n+                var field = cls.getDeclaredField(fieldName);\n+                field.setAccessible(true);\n+                return field;\n+            } catch (NoSuchFieldException e) {\n+                return null;\n+            }\n+        };\n+\n+        Class<?> cls = object.getClass();\n+        while (cls != null) {\n+            Field field = getField.apply(cls);\n+            if (field != null) {\n+                try {\n+                    return field.get(object);\n+                } catch (IllegalAccessException e) {\n+                    throw new AssertionError(e);\n+                }\n+            }\n+\n+            cls = cls.getSuperclass();\n+        }\n+\n+        throw new AssertionError(\"Field not found: \" + fieldName);\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/util\/ReflectionUtils.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n-\t\t\t<attribute name=\"add-exports\" value=\"javafx.base\/com.sun.javafx.property=javafx.graphics:javafx.base\/test.javafx.collections=javafx.graphics:javafx.base\/test.util.memory=javafx.graphics\"\/>\n+\t\t\t<attribute name=\"add-exports\" value=\"javafx.base\/com.sun.javafx.property=javafx.graphics:javafx.base\/test.javafx.collections=javafx.graphics:javafx.base\/test.util.memory=javafx.graphics:javafx.base\/test.util=javafx.graphics\"\/>\n","filename":"modules\/javafx.graphics\/.classpath","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.animation;\n-\n-import com.sun.javafx.util.Utils;\n-import com.sun.scenario.animation.AbstractPrimaryTimer;\n-import javafx.animation.AnimationTimer;\n-\n-public final class AnimationTimerHelper {\n-\n-    static {\n-        Utils.forceInit(AnimationTimer.class);\n-    }\n-\n-    private static Accessor accessor;\n-\n-    public static void setAccessor(Accessor accessor) {\n-        AnimationTimerHelper.accessor = accessor;\n-    }\n-\n-    public static AbstractPrimaryTimer getPrimaryTimer(AnimationTimer timer) {\n-        return accessor.getPrimaryTimer(timer);\n-    }\n-\n-    public interface Accessor {\n-        AbstractPrimaryTimer getPrimaryTimer(AnimationTimer timer);\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/animation\/AnimationTimerHelper.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.css;\n+\n+import javafx.css.CssMetaData;\n+import javafx.css.Styleable;\n+import java.util.Map;\n+\n+\/**\n+ * Defines the {@code convert} and {@code convertBack} operations that enable object\n+ * decomposition and reconstruction. Note that the following invariant must always be\n+ * satisfied: {@code convert(convertBack(value)).equals(value)}\n+ *\n+ * @param <T> the target type\n+ *\/\n+public interface SubPropertyConverter<T> {\n+\n+    \/**\n+     * Converts a map of CSS values to the target type.\n+     *\n+     * @param values the constituent values\n+     * @throws NullPointerException if {@code values} is {@code null}\n+     * @return the converted object\n+     *\/\n+    T convert(Map<CssMetaData<? extends Styleable, ?>, Object> values);\n+\n+    \/**\n+     * Converts an object back to a map of its constituent values (deconstruction).\n+     * The returned map can be passed into {@link #convert(Map)} to reconstruct the object.\n+     *\n+     * @param value the object\n+     * @throws NullPointerException if {@code value} is {@code null}\n+     * @return a {@code Map} of the constituent values\n+     *\/\n+    Map<CssMetaData<? extends Styleable, ?>, Object> convertBack(T value);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/SubPropertyConverter.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -35,1 +35,1 @@\n-    private TransitionTimer timer;\n+    private TransitionTimer.CancellationToken cancellationToken;\n@@ -41,0 +41,2 @@\n+     * @param targetPropertyName the name of the targeted CSS property\n+     * @param nanoNow the current time in nanoseconds\n@@ -42,1 +44,1 @@\n-    public final void run(TransitionDefinition definition) {\n+    public final void run(TransitionDefinition definition, String targetPropertyName, long nanoNow) {\n@@ -44,1 +46,1 @@\n-        timer = TransitionTimer.run(this, definition);\n+        cancellationToken = TransitionTimer.run(this, definition, targetPropertyName, nanoNow);\n@@ -47,1 +49,1 @@\n-        if (timer == null) {\n+        if (cancellationToken == null) {\n@@ -54,14 +56,1 @@\n-     * Cancels the transition timer.\n-     *\n-     * @param forceStop if {@code true}, the transition timer is stopped unconditionally\n-     * @return {@code true} if the timer was cancelled, {@code false} otherwise\n-     * @see TransitionTimer#cancel(boolean)\n-     *\/\n-    public final boolean cancel(boolean forceStop) {\n-        return timer == null || timer.cancel(forceStop);\n-    }\n-\n-    \/**\n-     * Gets the running {@code TransitionTimer}.\n-     *\n-     * @return the {@code TransitionTimer}, or {@code null} if no timer is running\n+     * Cancels the transition timer if it is currently running.\n@@ -69,2 +58,4 @@\n-    public final TransitionTimer getTimer() {\n-        return timer;\n+    public final void cancel() {\n+        if (cancellationToken != null) {\n+            cancellationToken.cancel();\n+        }\n@@ -93,0 +84,17 @@\n+\n+    \/**\n+     * Derived classes must implement the following protocol:\n+     * <ol>\n+     *     <li>If the reversing-adjusted start value of the existing transition is equal\n+     *         to the end value of this transition:\n+     *         Set the reversing-adjusted start value of this transition to the end value\n+     *         of the existing transition and return {@code true}.\n+     *     <li>Otherwise, return {@code false}.\n+     * <\/ol>\n+     * Refer to <a href=\"https:\/\/www.w3.org\/TR\/css-transitions-1\/#starting\">Starting of transitions<\/a>\n+     * for more information about the reversing-adjusted start value.\n+     *\n+     * @param existingMediator the mediator of the existing transition\n+     * @return {@code true} if the reversing-adjusted start value was updated, {@code false} otherwise\n+     *\/\n+    public abstract boolean updateReversingAdjustedStartValue(TransitionMediator existingMediator);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/TransitionMediator.java","additions":28,"deletions":20,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.javafx.animation.AnimationTimerHelper;\n@@ -47,0 +46,7 @@\n+    \/**\n+     * A token that can be used to cancel a running timer.\n+     *\/\n+    public interface CancellationToken {\n+        void cancel();\n+    }\n+\n@@ -48,0 +54,1 @@\n+    private final String targetPropertyName;\n@@ -53,1 +60,0 @@\n-    private boolean updating;\n@@ -56,2 +62,4 @@\n-    private TransitionTimer(TransitionMediator mediator, TransitionDefinition definition) {\n-        long now = AnimationTimerHelper.getPrimaryTimer(this).nanos();\n+    private TransitionTimer(TransitionMediator mediator,\n+                            TransitionDefinition definition,\n+                            String targetPropertyName,\n+                            long nanoNow) {\n@@ -61,0 +69,1 @@\n+        this.targetPropertyName = targetPropertyName;\n@@ -63,2 +72,2 @@\n-        this.currentTime = now;\n-        this.startTime = now + delay;\n+        this.currentTime = nanoNow;\n+        this.startTime = nanoNow + delay;\n@@ -77,1 +86,3 @@\n-     * @return the {@code timer} instance if the timer was started, {@code null} otherwise\n+     * @param targetPropertyName the name of the CSS property targeted by the transition\n+     * @param nanoNow the current time in nanoseconds\n+     * @return a {@code CancellationToken} if the timer was started, {@code null} otherwise\n@@ -79,1 +90,4 @@\n-    public static TransitionTimer run(TransitionMediator mediator, TransitionDefinition definition) {\n+    public static CancellationToken run(TransitionMediator mediator,\n+                                        TransitionDefinition definition,\n+                                        String targetPropertyName,\n+                                        long nanoNow) {\n@@ -92,1 +106,1 @@\n-        var existingTimer = (TransitionTimer)NodeHelper.findTransitionTimer(node, property);\n+        var existingTimer = NodeHelper.findTransitionTimer(node, targetPropertyName);\n@@ -94,2 +108,0 @@\n-            \/\/ If we already have a timer for the styleable property, the new timer is a reversing\n-            \/\/ timer that needs to be adjusted by the reversing shortening algorithm.\n@@ -97,3 +109,9 @@\n-                var newTimer = new TransitionTimer(mediator, definition);\n-                newTimer.adjustReversingTimings(existingTimer);\n-                existingTimer.stop(TransitionEvent.CANCEL);\n+                var newTimer = new TransitionTimer(mediator, definition, targetPropertyName, nanoNow);\n+\n+                \/\/ If we already have a timer for the styleable property, the new timer might be a reversing\n+                \/\/ timer that needs to be adjusted by the reversing shortening algorithm.\n+                if (mediator.updateReversingAdjustedStartValue(existingTimer.getMediator())) {\n+                    newTimer.adjustReversingTimings(existingTimer);\n+                }\n+\n+                existingTimer.interrupt();\n@@ -101,1 +119,1 @@\n-                return newTimer;\n+                return newTimer::stop;\n@@ -104,1 +122,1 @@\n-            existingTimer.stop(TransitionEvent.CANCEL);\n+            existingTimer.stop();\n@@ -110,1 +128,1 @@\n-            var timer = new TransitionTimer(mediator, definition);\n+            var timer = new TransitionTimer(mediator, definition, targetPropertyName, nanoNow);\n@@ -112,1 +130,1 @@\n-            return timer;\n+            return timer::stop;\n@@ -119,18 +137,1 @@\n-     * Cancels this timer if it is currently running. If {@code forceStop} is {@code false}, the timer\n-     * will only be stopped if this method was not called from the timer's {@link #update(double)} method;\n-     * i.e. a timer will not stop itself while trying to set the new value of a styleable property.\n-     *\n-     * @param forceStop if {@code true}, the timer is stopped unconditionally\n-     * @return {@code true} if the timer was cancelled, {@code false} otherwise\n-     *\/\n-    public boolean cancel(boolean forceStop) {\n-        if (forceStop || !pollUpdating()) {\n-            stop(TransitionEvent.CANCEL);\n-            return true;\n-        }\n-\n-        return false;\n-    }\n-\n-    \/**\n-     * Returns the property targeted by this timer.\n+     * Returns the {@code TransitionMediator} associated with this timer.\n@@ -138,1 +139,1 @@\n-     * @return the property\n+     * @return the {@code TransitionMediator}\n@@ -140,2 +141,2 @@\n-    public Property<?> getTargetProperty() {\n-        return (Property<?>)mediator.getStyleableProperty();\n+    public TransitionMediator getMediator() {\n+        return mediator;\n@@ -169,1 +170,1 @@\n-                stop(TransitionEvent.END);\n+                stopTimer(TransitionEvent.END);\n@@ -180,1 +181,1 @@\n-        NodeHelper.addTransitionTimer(targetNode, this);\n+        NodeHelper.addTransitionTimer(targetNode, targetPropertyName, this);\n@@ -185,1 +186,3 @@\n-     * This method is unused, calling it will throw {@link UnsupportedOperationException}.\n+     * Stops this timer without updating the property to the target value.\n+     * This happens when the value of the styleable property is changed by the user, or when a\n+     * running timer is cancelled by a transition with zero duration.\n@@ -189,1 +192,1 @@\n-        throw new UnsupportedOperationException();\n+        stopTimer(TransitionEvent.CANCEL);\n@@ -193,5 +196,2 @@\n-     * Stops the running transition and fires the specified event.\n-     * This happens when the value of a CSS property targeted by a transition is changed by the user,\n-     * when the transition is interrupted by another transition, or when it ends normally.\n-     *\n-     * @param eventType the event type that is fired after the timer is stopped\n+     * Skips the rest of a running transition and updates the property to the target value.\n+     * This happens when the targeted node is removed from the scene graph or becomes invisible.\n@@ -199,1 +199,10 @@\n-    public void stop(EventType<TransitionEvent> eventType) {\n+    public void complete() {\n+        update(1);\n+        stopTimer(TransitionEvent.CANCEL);\n+    }\n+\n+    \/**\n+     * Stops this timer without invoking {@link TransitionMediator#onStop()}.\n+     * This form of completion only happens when a timer is interrupted by a reversing timer.\n+     *\/\n+    private void interrupt() {\n@@ -201,3 +210,2 @@\n-        mediator.onStop();\n-        NodeHelper.removeTransitionTimer(targetNode, this);\n-        fireTransitionEvent(eventType);\n+        NodeHelper.removeTransitionTimer(targetNode, targetPropertyName);\n+        fireTransitionEvent(TransitionEvent.CANCEL);\n@@ -207,2 +215,3 @@\n-     * Skips the rest of a running transition and updates the property to the target value.\n-     * This happens when the targeted node is removed from the scene graph or becomes invisible.\n+     * Stops the running timer and fires the specified event.\n+     *\n+     * @param eventType the event type that is fired after the timer is stopped\n@@ -210,3 +219,5 @@\n-    public void complete() {\n-        update(1);\n-        stop(TransitionEvent.CANCEL);\n+    private void stopTimer(EventType<TransitionEvent> eventType) {\n+        super.stop();\n+        mediator.onStop();\n+        NodeHelper.removeTransitionTimer(targetNode, targetPropertyName);\n+        fireTransitionEvent(eventType);\n@@ -224,1 +235,0 @@\n-            updating = true;\n@@ -229,2 +239,0 @@\n-        } finally {\n-            updating = false;\n@@ -234,12 +242,0 @@\n-    \/**\n-     * Polls whether the timer is currently updating the value of the property.\n-     * After this method is called, the {@link #updating} flag is {@code false}.\n-     *\n-     * @return {@code true} if the timer is currently updating the property, {@code false} otherwise\n-     *\/\n-    private boolean pollUpdating() {\n-        boolean updating = this.updating;\n-        this.updating = false;\n-        return updating;\n-    }\n-\n@@ -322,0 +318,1 @@\n+                    targetPropertyName,\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/TransitionTimer.java","additions":69,"deletions":72,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import javafx.beans.property.Property;\n@@ -326,2 +325,3 @@\n-    public static void addTransitionTimer(Node node, TransitionTimer timer) {\n-        nodeAccessor.addTransitionTimer(node, timer);\n+    public static Map<CssMetaData<? extends Styleable, ?>, TransitionDefinition> findTransitionDefinitions(\n+            Node node, CssMetaData<? extends Styleable, ?> metadata) {\n+        return nodeAccessor.findTransitionDefinitions(node, metadata);\n@@ -330,2 +330,2 @@\n-    public static void removeTransitionTimer(Node node, TransitionTimer timer) {\n-        nodeAccessor.removeTransitionTimer(node, timer);\n+    public static void addTransitionTimer(Node node, String propertyName, TransitionTimer timer) {\n+        nodeAccessor.addTransitionTimer(node, propertyName, timer);\n@@ -334,2 +334,6 @@\n-    public static TransitionTimer findTransitionTimer(Node node, Property<?> property) {\n-        return nodeAccessor.findTransitionTimer(node, property);\n+    public static void removeTransitionTimer(Node node, String propertyName) {\n+        nodeAccessor.removeTransitionTimer(node, propertyName);\n+    }\n+\n+    public static TransitionTimer findTransitionTimer(Node node, String propertyName) {\n+        return nodeAccessor.findTransitionTimer(node, propertyName);\n@@ -400,3 +404,5 @@\n-        void addTransitionTimer(Node node, TransitionTimer timer);\n-        void removeTransitionTimer(Node node, TransitionTimer timer);\n-        TransitionTimer findTransitionTimer(Node node, Property<?> property);\n+        Map<CssMetaData<? extends Styleable, ?>, TransitionDefinition> findTransitionDefinitions(\n+                Node node, CssMetaData<? extends Styleable, ?> metadata);\n+        void addTransitionTimer(Node node, String propertyName, TransitionTimer timer);\n+        void removeTransitionTimer(Node node, String propertyName);\n+        TransitionTimer findTransitionTimer(Node node, String propertyName);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/NodeHelper.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.InterpolationUtils;\n+import javafx.animation.Interpolatable;\n@@ -29,0 +31,1 @@\n+import java.util.Objects;\n@@ -33,1 +36,1 @@\n-public class BorderImageSlices {\n+public final class BorderImageSlices implements Interpolatable<BorderImageSlices> {\n@@ -54,0 +57,31 @@\n+\n+    @Override\n+    public BorderImageSlices interpolate(BorderImageSlices endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0 || equals(endValue)) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        return new BorderImageSlices(\n+            widths.interpolate(endValue.widths, t),\n+            InterpolationUtils.interpolateDiscrete(filled, endValue.filled, t));\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (!(o instanceof BorderImageSlices that)) return false;\n+        return filled == that.filled && Objects.equals(widths, that.widths);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = Objects.hashCode(widths);\n+        result = 31 * result + Boolean.hashCode(filled);\n+        return result;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/layout\/region\/BorderImageSlices.java","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.InterpolationUtils;\n+import javafx.animation.Interpolatable;\n@@ -29,1 +31,0 @@\n-\n@@ -36,0 +37,1 @@\n+import java.util.Objects;\n@@ -42,1 +44,1 @@\n-public class Margins {\n+public final class Margins implements Interpolatable<Margins> {\n@@ -73,0 +75,45 @@\n+    @Override\n+    public Margins interpolate(Margins endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0 || equals(endValue)) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        if (proportional != endValue.proportional) {\n+            return InterpolationUtils.interpolateDiscrete(this, endValue, t);\n+        }\n+\n+        return new Margins(\n+            InterpolationUtils.interpolate(top, endValue.top, t),\n+            InterpolationUtils.interpolate(right, endValue.right, t),\n+            InterpolationUtils.interpolate(bottom, endValue.bottom, t),\n+            InterpolationUtils.interpolate(left, endValue.left, t),\n+            proportional);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (!(o instanceof Margins margins)) return false;\n+        return Double.compare(top, margins.top) == 0\n+            && Double.compare(right, margins.right) == 0\n+            && Double.compare(bottom, margins.bottom) == 0\n+            && Double.compare(left, margins.left) == 0\n+            && proportional == margins.proportional;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = Double.hashCode(top);\n+        result = 31 * result + Double.hashCode(right);\n+        result = 31 * result + Double.hashCode(bottom);\n+        result = 31 * result + Double.hashCode(left);\n+        result = 31 * result + Boolean.hashCode(proportional);\n+        return result;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/layout\/region\/Margins.java","additions":50,"deletions":3,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,412 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.util;\n+\n+import com.sun.javafx.UnmodifiableArrayList;\n+import javafx.animation.Interpolatable;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.ImagePattern;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.Paint;\n+import javafx.scene.paint.RadialGradient;\n+import javafx.scene.paint.Stop;\n+import java.lang.reflect.Array;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public final class InterpolationUtils {\n+\n+    private InterpolationUtils() {}\n+\n+    \/**\n+     * Utility function that interpolates between two double values.\n+     *\/\n+    public static double interpolate(double from, double to, double t) {\n+        return from + t * (to - from);\n+    }\n+\n+    \/**\n+     * Utility function that interpolates between two discrete values, returning {@code from}\n+     * when {@code t < 0.5}, and {@code to} otherwise.\n+     *\/\n+    public static <T> T interpolateDiscrete(T from, T to, double t) {\n+        return t < 0.5 ? from : to;\n+    }\n+\n+    \/**\n+     * Utility function that interpolates between two discrete values, returning {@code from}\n+     * when {@code t < 0.5}, and {@code to} otherwise.\n+     *\/\n+    public static double interpolateDiscrete(double from, double to, double t) {\n+        return t < 0.5 ? from : to;\n+    }\n+\n+    \/**\n+     * Computes an intermediate list that consists of the pairwise interpolation between two lists,\n+     * using the following rules:\n+     * <ol>\n+     *     <li>The size of the returned list corresponds to the size of the second list.\n+     *     <li>If the first list has fewer elements than the second list, the missing elements are copied\n+     *         from the second list.\n+     *     <li>If the first list has more elements than the second list, the excess elements are discarded.\n+     *     <li>If the intermediate list is shallow-equal to the first list passed into the method (i.e. its\n+     *         elements are references to the same objects), the existing list is returned.\n+     *     <li>If a new list is returned, it is unmodifiable.\n+     * <\/ol>\n+     * This method preferably returns existing list instances (i.e. the {@code firstList} or\n+     * {@code secondList} arguments) as an indication to the caller that the result is shallow-equal\n+     * to either of the input arguments. Callers might depend on this behavior to optimize their own\n+     * object allocation strategy by quickly detecting whether anything has changed at all.\n+     *\n+     * @param firstList the first list, not {@code null}\n+     * @param secondList the second list, not {@code null}\n+     * @return the intermediate list\n+     *\/\n+    public static <T extends Interpolatable<T>> List<T> interpolateListsPairwise(\n+            List<T> firstList, List<T> secondList, double t) {\n+        Objects.requireNonNull(firstList, \"firstList\");\n+        Objects.requireNonNull(secondList, \"secondList\");\n+\n+        if (secondList.isEmpty()) {\n+            return firstList.isEmpty() ? firstList : secondList;\n+        }\n+\n+        int listSize = firstList.size();\n+\n+        \/\/ For small equisized lists (up to 8 elements), we use an optimization to prevent the allocation\n+        \/\/ of a new array in case the intermediate list would be equal to the existing list.\n+        if (listSize <= 8 && listSize == secondList.size()) {\n+            return interpolateEquisizedListsPairwise(firstList, secondList, t);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newArray = (T[])new Interpolatable[secondList.size()];\n+        boolean equal = firstList.size() == secondList.size();\n+\n+        for (int i = 0, firstListSize = firstList.size(); i < newArray.length; ++i) {\n+            if (firstListSize > i) {\n+                newArray[i] = firstList.get(i).interpolate(secondList.get(i), t);\n+                equal &= newArray[i] == firstList.get(i);\n+            } else {\n+                newArray[i] = secondList.get(i);\n+            }\n+        }\n+\n+        return equal ? firstList : new UnmodifiableArrayList<>(newArray, newArray.length);\n+    }\n+\n+    \/**\n+     * Computes an intermediate list that consists of the pairwise interpolation between two lists\n+     * of equal size, each containing up to 8 elements.\n+     * <p>\n+     * This method is an optimization: it does not allocate memory when the intermediate list is\n+     * shallow-equal to the list that is passed into this method, i.e. its elements are references\n+     * to the same objects. The existing list is returned in this case.\n+     *\/\n+    private static <T extends Interpolatable<T>> List<T> interpolateEquisizedListsPairwise(\n+            List<T> firstList, List<T> secondList, double t) {\n+        int listSize = firstList.size();\n+        if (listSize > 8 || listSize != secondList.size()) {\n+            throw new AssertionError();\n+        }\n+\n+        T item0 = null, item1 = null, item2 = null, item3 = null, item4 = null, item5 = null, item6 = null, item7 = null;\n+        boolean same = true;\n+\n+        switch (listSize) { \/\/ fall-through intended\n+            case 8: item7 = firstList.get(7).interpolate(secondList.get(7), t);\n+                    same &= item7 == firstList.get(7);\n+            case 7: item6 = firstList.get(6).interpolate(secondList.get(6), t);\n+                    same &= item6 == firstList.get(6);\n+            case 6: item5 = firstList.get(5).interpolate(secondList.get(5), t);\n+                    same &= item5 == firstList.get(5);\n+            case 5: item4 = firstList.get(4).interpolate(secondList.get(4), t);\n+                    same &= item4 == firstList.get(4);\n+            case 4: item3 = firstList.get(3).interpolate(secondList.get(3), t);\n+                    same &= item3 == firstList.get(3);\n+            case 3: item2 = firstList.get(2).interpolate(secondList.get(2), t);\n+                    same &= item2 == firstList.get(2);\n+            case 2: item1 = firstList.get(1).interpolate(secondList.get(1), t);\n+                    same &= item1 == firstList.get(1);\n+            case 1: item0 = firstList.get(0).interpolate(secondList.get(0), t);\n+                    same &= item0 == firstList.get(0);\n+        }\n+\n+        if (same) {\n+            return firstList;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newArray = (T[])new Interpolatable[listSize];\n+\n+        switch (listSize) { \/\/ fall-through intended\n+            case 8: newArray[7] = item7;\n+            case 7: newArray[6] = item6;\n+            case 6: newArray[5] = item5;\n+            case 5: newArray[4] = item4;\n+            case 4: newArray[3] = item3;\n+            case 3: newArray[2] = item2;\n+            case 2: newArray[1] = item1;\n+            case 1: newArray[0] = item0;\n+        }\n+\n+        return new UnmodifiableArrayList<>(newArray, listSize);\n+    }\n+\n+    \/**\n+     * Computes an intermediate array series that consists of the pairwise interpolation between two\n+     * array series, using the same rules as described in {@link #interpolateArraysPairwise}.\n+     * <p>\n+     * This method preferably returns existing array instances (i.e. the {@code firstArraySeries} or\n+     * {@code secondArraySeries} arguments) as an indication to the caller that the result is shallow-equal\n+     * to either of the input arguments. Callers might depend on this behavior to optimize their own\n+     * object allocation strategy by quickly detecting whether anything has changed at all.\n+     *\n+     * @param firstArraySeries the first array series, not {@code null}\n+     * @param secondArraySeries the second array series, not {@code null}\n+     * @return the intermediate array series\n+     *\/\n+    public static <T extends Interpolatable<T>> T[][] interpolateArraySeriesPairwise(\n+            T[][] firstArraySeries, T[][] secondArraySeries, double t) {\n+        Objects.requireNonNull(firstArraySeries, \"firstArraySeries\");\n+        Objects.requireNonNull(secondArraySeries, \"secondArraySeries\");\n+\n+        if (secondArraySeries.length == 0) {\n+            return firstArraySeries.length == 0 ? firstArraySeries : secondArraySeries;\n+        }\n+\n+        Class<?> arrayType = firstArraySeries.getClass().componentType();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[][] newArray = (T[][]) Array.newInstance(arrayType, secondArraySeries.length);\n+        boolean equal = firstArraySeries.length == secondArraySeries.length;\n+\n+        for (int i = 0, firstListSize = firstArraySeries.length; i < newArray.length; ++i) {\n+            if (firstListSize > i) {\n+                newArray[i] = interpolateArraysPairwise(firstArraySeries[i], secondArraySeries[i], t);\n+                equal &= newArray[i] == firstArraySeries[i];\n+            } else {\n+                newArray[i] = secondArraySeries[i];\n+            }\n+        }\n+\n+        return equal ? firstArraySeries : newArray;\n+    }\n+\n+    \/**\n+     * Computes an intermediate array that consists of the pairwise interpolation between two arrays,\n+     * using the following rules:\n+     * <ol>\n+     *     <li>The size of the returned array corresponds to the size of the second array.\n+     *     <li>If the first array has fewer elements than the second array, the missing elements are copied\n+     *         from the second array.\n+     *     <li>If the first array has more elements than the second array, the excess elements are discarded.\n+     *     <li>If the intermediate array is shallow-equal to the first array passed into the method (i.e. its\n+     *         elements are references to the same objects), the existing array is returned.\n+     * <\/ol>\n+     * This method preferably returns existing array instances (i.e. the {@code firstArray} or\n+     * {@code secondArray} arguments) as an indication to the caller that the result is shallow-equal\n+     * to either of the input arguments. Callers might depend on this behavior to optimize their own\n+     * object allocation strategy by quickly detecting whether anything has changed at all.\n+     *\n+     * @param firstArray the first array, not {@code null}\n+     * @param secondArray the second array, not {@code null}\n+     * @return the intermediate list\n+     *\/\n+    public static <T extends Interpolatable<T>> T[] interpolateArraysPairwise(\n+            T[] firstArray, T[] secondArray, double t) {\n+        Objects.requireNonNull(firstArray, \"firstArray\");\n+        Objects.requireNonNull(secondArray, \"secondArray\");\n+\n+        if (secondArray.length == 0) {\n+            return firstArray.length == 0 ? firstArray : secondArray;\n+        }\n+\n+        int arraySize = firstArray.length;\n+\n+        \/\/ For small equisized arrays (up to 8 elements), we use an optimization to prevent the allocation\n+        \/\/ of a new array in case the intermediate array would be equal to the existing array.\n+        if (arraySize <= 8 && arraySize == secondArray.length) {\n+            return interpolateEquisizedArraysPairwise(firstArray, secondArray, t);\n+        }\n+\n+        Class<?> componentType = firstArray.getClass().componentType();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newArray = (T[])Array.newInstance(componentType, secondArray.length);\n+        boolean equal = firstArray.length == secondArray.length;\n+\n+        for (int i = 0; i < newArray.length; ++i) {\n+            if (arraySize > i) {\n+                newArray[i] = firstArray[i].interpolate(secondArray[i], t);\n+                equal &= newArray[i] == firstArray[i];\n+            } else {\n+                newArray[i] = secondArray[i];\n+            }\n+        }\n+\n+        return equal ? firstArray : newArray;\n+    }\n+\n+    \/**\n+     * Computes an intermediate array that consists of the pairwise interpolation between two arrays\n+     * of equal size, each containing up to 8 elements.\n+     * <p>\n+     * This method is an optimization: it does not allocate memory when the intermediate array is\n+     * shallow-equal to the array that is passed into this method, i.e. its elements are references\n+     * to the same objects. The existing array is returned in this case.\n+     *\/\n+    private static <T extends Interpolatable<T>> T[] interpolateEquisizedArraysPairwise(\n+            T[] firstArray, T[] secondArray, double t) {\n+        int arraySize = firstArray.length;\n+        if (arraySize > 8 || arraySize != secondArray.length) {\n+            throw new AssertionError();\n+        }\n+\n+        T item0 = null, item1 = null, item2 = null, item3 = null, item4 = null, item5 = null, item6 = null, item7 = null;\n+        boolean same = true;\n+\n+        switch (arraySize) { \/\/ fall-through intended\n+            case 8: item7 = firstArray[7].interpolate(secondArray[7], t);\n+                    same &= item7 == firstArray[7];\n+            case 7: item6 = firstArray[6].interpolate(secondArray[6], t);\n+                    same &= item6 == firstArray[6];\n+            case 6: item5 = firstArray[5].interpolate(secondArray[5], t);\n+                    same &= item5 == firstArray[5];\n+            case 5: item4 = firstArray[4].interpolate(secondArray[4], t);\n+                    same &= item4 == firstArray[4];\n+            case 4: item3 = firstArray[3].interpolate(secondArray[3], t);\n+                    same &= item3 == firstArray[3];\n+            case 3: item2 = firstArray[2].interpolate(secondArray[2], t);\n+                    same &= item2 == firstArray[2];\n+            case 2: item1 = firstArray[1].interpolate(secondArray[1], t);\n+                    same &= item1 == firstArray[1];\n+            case 1: item0 = firstArray[0].interpolate(secondArray[0], t);\n+                    same &= item0 == firstArray[0];\n+        }\n+\n+        if (same) {\n+            return firstArray;\n+        }\n+\n+        Class<?> componentType = firstArray.getClass().componentType();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newArray = (T[])Array.newInstance(componentType, arraySize);\n+\n+        switch (arraySize) { \/\/ fall-through intended\n+            case 8: newArray[7] = item7;\n+            case 7: newArray[6] = item6;\n+            case 6: newArray[5] = item5;\n+            case 5: newArray[4] = item4;\n+            case 4: newArray[3] = item3;\n+            case 3: newArray[2] = item2;\n+            case 2: newArray[1] = item1;\n+            case 1: newArray[0] = item0;\n+        }\n+\n+        return newArray;\n+    }\n+\n+    \/**\n+     * Interpolates between potentially different types of paint.\n+     * <p>\n+     * In addition to homogeneous interpolations between paints of the same type, the following\n+     * heterogeneous interpolations are supported:\n+     * <ul>\n+     *     <li>Color ↔ LinearGradient\n+     *     <li>Color ↔ RadialGradient\n+     * <\/ul>\n+     * If a paint is not interpolatable, {@code startValue} is returned for {@code t < 0.5},\n+     * and {@code endValue} is returned otherwise.\n+     *\/\n+    public static Paint interpolatePaint(Paint startValue, Paint endValue, double t) {\n+        if (startValue instanceof Color start) {\n+            if (endValue instanceof Color end) {\n+                return start.interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof LinearGradient end) {\n+                return newSolidGradient(end, start).interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof RadialGradient end) {\n+                return newSolidGradient(end, start).interpolate(end, t);\n+            }\n+        }\n+\n+        if (startValue instanceof LinearGradient start) {\n+            if (endValue instanceof LinearGradient end) {\n+                return start.interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof Color end) {\n+                return start.interpolate(newSolidGradient(start, end), t);\n+            }\n+        }\n+\n+        if (startValue instanceof RadialGradient start) {\n+            if (endValue instanceof RadialGradient end) {\n+                return start.interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof Color end) {\n+                return start.interpolate(newSolidGradient(start, end), t);\n+            }\n+        }\n+\n+        if (startValue instanceof ImagePattern start && endValue instanceof ImagePattern end) {\n+            return start.interpolate(end, t);\n+        }\n+\n+        return t < 0.5 ? startValue : endValue;\n+    }\n+\n+    \/**\n+     * Creates a new linear gradient that consists of two stops with the same color.\n+     *\/\n+    public static LinearGradient newSolidGradient(LinearGradient source, Color color) {\n+        return new LinearGradient(\n+                source.getStartX(), source.getStartY(),\n+                source.getEndX(), source.getEndY(),\n+                source.isProportional(),\n+                source.getCycleMethod(),\n+                List.of(new Stop(0, color), new Stop(1, color)));\n+    }\n+\n+    \/**\n+     * Creates a new radial gradient that consists of two stops with the same color.\n+     *\/\n+    public static RadialGradient newSolidGradient(RadialGradient source, Color color) {\n+        return new RadialGradient(\n+                source.getFocusAngle(), source.getFocusDistance(),\n+                source.getCenterX(), source.getCenterY(),\n+                source.getRadius(),\n+                source.isProportional(),\n+                source.getCycleMethod(),\n+                List.of(new Stop(0, color), new Stop(1, color)));\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/util\/InterpolationUtils.java","additions":412,"deletions":0,"binary":false,"changes":412,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.javafx.animation.AnimationTimerHelper;\n@@ -53,9 +52,0 @@\n-    static {\n-        AnimationTimerHelper.setAccessor(new AnimationTimerHelper.Accessor() {\n-            @Override\n-            public AbstractPrimaryTimer getPrimaryTimer(AnimationTimer timer) {\n-                return timer.timer;\n-            }\n-        });\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/animation\/AnimationTimer.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,3 +29,35 @@\n- * A value that can be interpolated. It defines single\n- * {@link #interpolate(Object, double)} method, which returns interpolated value\n- * of given fraction.\n+ * A value that can be interpolated. It defines a single {@link #interpolate(Object, double)}\n+ * method, which returns an intermediate value between the value of this {@code Interpolatable}\n+ * and the specified target value.\n+ * <p>\n+ * Component values can be interpolated in different ways, depending on the semantics of the component type:\n+ * <table class=\"striped\">\n+ *     <caption><b>Interpolation types<\/b><\/caption>\n+ *     <tbody>\n+ *         <tr><td style=\"vertical-align: top\"><a id=\"default\" style=\"white-space: nowrap\">default<\/a><\/td>\n+ *             <td>Component types that implement {@code Interpolatable} are interpolated by calling the\n+ *                 {@link #interpolate(Object, double)} method.<\/td>\n+ *         <\/tr>\n+ *         <tr><td style=\"vertical-align: top\"><a id=\"linear\" style=\"white-space: nowrap\">linear<\/a><\/td>\n+ *             <td>Two components are combined by linear interpolation such that {@code t = 0} produces\n+ *                 the start value, {@code t = 1} produces the end value, and {@code 0 < t < 1} produces\n+ *                 {@code (1 - t) * start + t * end}. This interpolation type is usually applicable for\n+ *                 numeric components.<\/td>\n+ *         <\/tr>\n+ *         <tr><td style=\"vertical-align: top\"><a id=\"discrete\" style=\"white-space: nowrap\">discrete<\/a><\/td>\n+ *             <td>If two components cannot be meaningfully combined, the intermediate component value\n+ *                 is equal to the start value for {@code t < 0.5} and equal to the end value for\n+ *                 {@code t >= 0.5}.<\/td>\n+ *         <\/tr>\n+ *         <tr><td style=\"vertical-align: top\"><a id=\"pairwise\" style=\"white-space: nowrap\">pairwise<\/a><\/td>\n+ *             <td>Two lists are combined by pairwise interpolation. Paired list elements are interpolated\n+ *                 with rules as described in this table (substituting \"component\" for \"element\").\n+ *                 If the start list has fewer elements than the target list, the missing elements are copied\n+ *                 from the target list. If the start list has more elements than the target list, the excess\n+ *                 elements are discarded.\n+ *             <\/td>\n+ *         <\/tr>\n+ *     <\/tbody>\n+ * <\/table>\n+ * Some component types are interpolated in specific ways not covered here.\n+ * Refer to their respective documentation for more information.\n@@ -40,3 +72,8 @@\n-     * The function calculates an interpolated value along the fraction\n-     * {@code t} between {@code 0.0} and {@code 1.0}. When {@code t} = 1.0,\n-     * {@code endVal} is returned.\n+     * Returns an intermediate value between the value of this {@code Interpolatable} and the specified\n+     * {@code endValue} using the linear interpolation factor {@code t}, ranging from 0 (inclusive)\n+     * to 1 (inclusive).\n+     * <p>\n+     * The returned value might not be a new instance; the implementation might also return one of the\n+     * two existing instances if the intermediate value would be equal to one of the existing values.\n+     * However, this is an optimization and applications should not assume any particular identity\n+     * of the returned value.\n@@ -44,5 +81,9 @@\n-     * @param endValue\n-     *            target value\n-     * @param t\n-     *            fraction between {@code 0.0} and {@code 1.0}\n-     * @return interpolated value\n+     * @implSpec An implementation is not required to reject interpolation factors less than 0 or larger\n+     *           than 1, but this specification gives no meaning to values returned outside of this range.\n+     *           For example, an implementation might clamp the interpolation factor to [0..1], or it might\n+     *           continue the linear interpolation outside of this range.\n+     *\n+     * @param endValue the target value\n+     * @param t the interpolation factor\n+     * @throws NullPointerException if {@code endValue} is {@code null}\n+     * @return the intermediate value\n@@ -50,1 +91,1 @@\n-    public T interpolate(T endValue, double t);\n+    T interpolate(T endValue, double t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/animation\/Interpolatable.java","additions":53,"deletions":12,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import com.sun.javafx.tk.Toolkit;\n@@ -79,1 +80,1 @@\n-        } else if (mediator == null || mediator.newValue != newValue) {\n+        } else if (mediator == null || mediator.endValue != newValue) {\n@@ -85,1 +86,1 @@\n-            mediator.run(transition);\n+            mediator.run(transition, getCssMetaData().getProperty(), Toolkit.getToolkit().getPrimaryTimer().nanos());\n@@ -95,6 +96,1 @@\n-        origin = StyleOrigin.USER;\n-\n-        \/\/ Calling the 'bind' method always cancels a transition timer.\n-        if (mediator != null) {\n-            mediator.cancel(true);\n-        }\n+        onUserChange();\n@@ -107,4 +103,1 @@\n-\n-        if (mediator == null || mediator.cancel(false)) {\n-            origin = StyleOrigin.USER;\n-        }\n+        onUserChange();\n@@ -117,2 +110,2 @@\n-    private StyleOrigin origin = null;\n-    private TransitionMediatorImpl mediator = null;\n+    private void onUserChange() {\n+        origin = StyleOrigin.USER;\n@@ -120,3 +113,7 @@\n-    private class TransitionMediatorImpl extends TransitionMediator {\n-        private final boolean oldValue;\n-        private final boolean newValue;\n+        if (mediator != null) {\n+            mediator.cancel();\n+        }\n+    }\n+\n+    private StyleOrigin origin;\n+    private TransitionMediatorImpl mediator;\n@@ -124,3 +121,9 @@\n-        public TransitionMediatorImpl(boolean oldValue, boolean newValue) {\n-            this.oldValue = oldValue;\n-            this.newValue = newValue;\n+    private class TransitionMediatorImpl extends TransitionMediator {\n+        private final boolean startValue;\n+        private final boolean endValue;\n+        private boolean reversingAdjustedStartValue;\n+\n+        public TransitionMediatorImpl(boolean startValue, boolean endValue) {\n+            this.startValue = startValue;\n+            this.endValue = endValue;\n+            this.reversingAdjustedStartValue = startValue;\n@@ -131,1 +134,1 @@\n-            set(progress > 0 ? newValue : oldValue);\n+            StyleableBooleanProperty.super.set(progress < 0.5 ? startValue : endValue);\n@@ -136,7 +139,1 @@\n-            \/\/ When the transition is cancelled or completed, we clear the reference to this mediator.\n-            \/\/ However, when this mediator was cancelled by a reversing transition, the 'mediator' field\n-            \/\/ refers to the reversing mediator, and not to this mediator. We need to be careful to only\n-            \/\/ clear references to this mediator.\n-            if (mediator == this) {\n-                mediator = null;\n-            }\n+            mediator = null;\n@@ -149,0 +146,12 @@\n+\n+        @Override\n+        public boolean updateReversingAdjustedStartValue(TransitionMediator existingMediator) {\n+            var mediator = (TransitionMediatorImpl)existingMediator;\n+\n+            if (mediator.reversingAdjustedStartValue == endValue) {\n+                reversingAdjustedStartValue = mediator.endValue;\n+                return true;\n+            }\n+\n+            return false;\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableBooleanProperty.java","additions":37,"deletions":28,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import com.sun.javafx.tk.Toolkit;\n@@ -81,1 +82,1 @@\n-        } else if (mediator == null || mediator.newValue != newValue) {\n+        } else if (mediator == null || mediator.endValue != newValue) {\n@@ -87,1 +88,1 @@\n-            mediator.run(transition);\n+            mediator.run(transition, getCssMetaData().getProperty(), Toolkit.getToolkit().getPrimaryTimer().nanos());\n@@ -97,6 +98,1 @@\n-        origin = StyleOrigin.USER;\n-\n-        \/\/ Calling the 'bind' method always cancels a transition timer.\n-        if (mediator != null) {\n-            mediator.cancel(true);\n-        }\n+        onUserChange();\n@@ -109,4 +105,1 @@\n-\n-        if (mediator == null || mediator.cancel(false)) {\n-            origin = StyleOrigin.USER;\n-        }\n+        onUserChange();\n@@ -119,2 +112,2 @@\n-    private StyleOrigin origin = null;\n-    private TransitionMediatorImpl mediator = null;\n+    private void onUserChange() {\n+        origin = StyleOrigin.USER;\n@@ -122,3 +115,7 @@\n-    private class TransitionMediatorImpl extends TransitionMediator {\n-        private final double oldValue;\n-        private final double newValue;\n+        if (mediator != null) {\n+            mediator.cancel();\n+        }\n+    }\n+\n+    private StyleOrigin origin;\n+    private TransitionMediatorImpl mediator;\n@@ -126,3 +123,9 @@\n-        public TransitionMediatorImpl(double oldValue, double newValue) {\n-            this.oldValue = oldValue;\n-            this.newValue = newValue;\n+    private class TransitionMediatorImpl extends TransitionMediator {\n+        private final double startValue;\n+        private final double endValue;\n+        private double reversingAdjustedStartValue;\n+\n+        public TransitionMediatorImpl(double startValue, double endValue) {\n+            this.startValue = startValue;\n+            this.endValue = endValue;\n+            this.reversingAdjustedStartValue = startValue;\n@@ -133,1 +136,2 @@\n-            set(progress < 1 ? oldValue + (newValue - oldValue) * progress : newValue);\n+            StyleableDoubleProperty.super.set(\n+                progress < 1 ? startValue + (endValue - startValue) * progress : endValue);\n@@ -138,7 +142,1 @@\n-            \/\/ When the transition is cancelled or completed, we clear the reference to this mediator.\n-            \/\/ However, when this mediator was cancelled by a reversing transition, the 'mediator' field\n-            \/\/ refers to the reversing mediator, and not to this mediator. We need to be careful to only\n-            \/\/ clear references to this mediator.\n-            if (mediator == this) {\n-                mediator = null;\n-            }\n+            mediator = null;\n@@ -151,0 +149,12 @@\n+\n+        @Override\n+        public boolean updateReversingAdjustedStartValue(TransitionMediator existingMediator) {\n+            var mediator = (TransitionMediatorImpl)existingMediator;\n+\n+            if (mediator.reversingAdjustedStartValue == endValue) {\n+                reversingAdjustedStartValue = mediator.endValue;\n+                return true;\n+            }\n+\n+            return false;\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableDoubleProperty.java","additions":38,"deletions":28,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import com.sun.javafx.tk.Toolkit;\n@@ -79,1 +80,1 @@\n-        } else if (mediator == null || mediator.newValue != newValue) {\n+        } else if (mediator == null || mediator.endValue != newValue) {\n@@ -85,1 +86,1 @@\n-            mediator.run(transition);\n+            mediator.run(transition, getCssMetaData().getProperty(), Toolkit.getToolkit().getPrimaryTimer().nanos());\n@@ -95,6 +96,1 @@\n-        origin = StyleOrigin.USER;\n-\n-        \/\/ Calling the 'bind' method always cancels a transition timer.\n-        if (mediator != null) {\n-            mediator.cancel(true);\n-        }\n+        onUserChange();\n@@ -107,4 +103,1 @@\n-\n-        if (mediator == null || mediator.cancel(false)) {\n-            origin = StyleOrigin.USER;\n-        }\n+        onUserChange();\n@@ -117,2 +110,2 @@\n-    private StyleOrigin origin = null;\n-    private TransitionMediatorImpl mediator = null;\n+    private void onUserChange() {\n+        origin = StyleOrigin.USER;\n@@ -120,3 +113,7 @@\n-    private class TransitionMediatorImpl extends TransitionMediator {\n-        private final float oldValue;\n-        private final float newValue;\n+        if (mediator != null) {\n+            mediator.cancel();\n+        }\n+    }\n+\n+    private StyleOrigin origin;\n+    private TransitionMediatorImpl mediator;\n@@ -124,3 +121,9 @@\n-        public TransitionMediatorImpl(float oldValue, float newValue) {\n-            this.oldValue = oldValue;\n-            this.newValue = newValue;\n+    private class TransitionMediatorImpl extends TransitionMediator {\n+        private final float startValue;\n+        private final float endValue;\n+        private float reversingAdjustedStartValue;\n+\n+        public TransitionMediatorImpl(float startValue, float endValue) {\n+            this.startValue = startValue;\n+            this.endValue = endValue;\n+            this.reversingAdjustedStartValue = startValue;\n@@ -131,1 +134,2 @@\n-            set(progress < 1 ? oldValue + (newValue - oldValue) * (float)progress : newValue);\n+            StyleableFloatProperty.super.set(\n+                progress < 1 ? startValue + (endValue - startValue) * (float)progress : endValue);\n@@ -136,7 +140,1 @@\n-            \/\/ When the transition is cancelled or completed, we clear the reference to this mediator.\n-            \/\/ However, when this mediator was cancelled by a reversing transition, the 'mediator' field\n-            \/\/ refers to the reversing mediator, and not to this mediator. We need to be careful to only\n-            \/\/ clear references to this mediator.\n-            if (mediator == this) {\n-                mediator = null;\n-            }\n+            mediator = null;\n@@ -149,0 +147,12 @@\n+\n+        @Override\n+        public boolean updateReversingAdjustedStartValue(TransitionMediator existingMediator) {\n+            var mediator = (TransitionMediatorImpl)existingMediator;\n+\n+            if (mediator.reversingAdjustedStartValue == endValue) {\n+                reversingAdjustedStartValue = mediator.endValue;\n+                return true;\n+            }\n+\n+            return false;\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableFloatProperty.java","additions":38,"deletions":28,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import com.sun.javafx.tk.Toolkit;\n@@ -79,1 +80,1 @@\n-        } else if (mediator == null || mediator.newValue != newValue) {\n+        } else if (mediator == null || mediator.endValue != newValue) {\n@@ -85,1 +86,1 @@\n-            mediator.run(transition);\n+            mediator.run(transition, getCssMetaData().getProperty(), Toolkit.getToolkit().getPrimaryTimer().nanos());\n@@ -95,6 +96,1 @@\n-        origin = StyleOrigin.USER;\n-\n-        \/\/ Calling the 'bind' method always cancels a transition timer.\n-        if (mediator != null) {\n-            mediator.cancel(true);\n-        }\n+        onUserChange();\n@@ -107,4 +103,1 @@\n-\n-        if (mediator == null || mediator.cancel(false)) {\n-            origin = StyleOrigin.USER;\n-        }\n+        onUserChange();\n@@ -117,2 +110,2 @@\n-    private StyleOrigin origin = null;\n-    private TransitionMediatorImpl mediator = null;\n+    private void onUserChange() {\n+        origin = StyleOrigin.USER;\n@@ -120,3 +113,7 @@\n-    private final class TransitionMediatorImpl extends TransitionMediator {\n-        private final int oldValue;\n-        private final int newValue;\n+        if (mediator != null) {\n+            mediator.cancel();\n+        }\n+    }\n+\n+    private StyleOrigin origin;\n+    private TransitionMediatorImpl mediator;\n@@ -124,3 +121,9 @@\n-        public TransitionMediatorImpl(int oldValue, int newValue) {\n-            this.oldValue = oldValue;\n-            this.newValue = newValue;\n+    private final class TransitionMediatorImpl extends TransitionMediator {\n+        private final int startValue;\n+        private final int endValue;\n+        private int reversingAdjustedStartValue;\n+\n+        public TransitionMediatorImpl(int startValue, int endValue) {\n+            this.startValue = startValue;\n+            this.endValue = endValue;\n+            this.reversingAdjustedStartValue = startValue;\n@@ -131,1 +134,3 @@\n-            set(progress < 1 ? oldValue + (int)((newValue - oldValue) * progress) : newValue);\n+            \/\/ Integers are interpolated in real number space and rounded to the nearest integer.\n+            StyleableIntegerProperty.super.set(\n+                progress < 1 ? (int)Math.round(startValue + (endValue - startValue) * progress) : endValue);\n@@ -136,7 +141,1 @@\n-            \/\/ When the transition is cancelled or completed, we clear the reference to this mediator.\n-            \/\/ However, when this mediator was cancelled by a reversing transition, the 'mediator' field\n-            \/\/ refers to the reversing mediator, and not to this mediator. We need to be careful to only\n-            \/\/ clear references to this mediator.\n-            if (mediator == this) {\n-                mediator = null;\n-            }\n+            mediator = null;\n@@ -149,0 +148,12 @@\n+\n+        @Override\n+        public boolean updateReversingAdjustedStartValue(TransitionMediator existingMediator) {\n+            var mediator = (TransitionMediatorImpl)existingMediator;\n+\n+            if (mediator.reversingAdjustedStartValue == endValue) {\n+                reversingAdjustedStartValue = mediator.endValue;\n+                return true;\n+            }\n+\n+            return false;\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableIntegerProperty.java","additions":39,"deletions":28,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import com.sun.javafx.tk.Toolkit;\n+import com.sun.javafx.util.Utils;\n@@ -81,1 +83,1 @@\n-        } else if (mediator == null || mediator.newValue != newValue) {\n+        } else if (mediator == null || mediator.endValue != newValue) {\n@@ -87,1 +89,1 @@\n-            mediator.run(transition);\n+            mediator.run(transition, getCssMetaData().getProperty(), Toolkit.getToolkit().getPrimaryTimer().nanos());\n@@ -97,6 +99,1 @@\n-        origin = StyleOrigin.USER;\n-\n-        \/\/ Calling the 'bind' method always cancels a transition timer.\n-        if (mediator != null) {\n-            mediator.cancel(true);\n-        }\n+        onUserChange();\n@@ -109,4 +106,1 @@\n-\n-        if (mediator == null || mediator.cancel(false)) {\n-            origin = StyleOrigin.USER;\n-        }\n+        onUserChange();\n@@ -119,2 +113,2 @@\n-    private StyleOrigin origin = null;\n-    private TransitionMediatorImpl mediator = null;\n+    private void onUserChange() {\n+        origin = StyleOrigin.USER;\n@@ -122,3 +116,7 @@\n-    private final class TransitionMediatorImpl extends TransitionMediator {\n-        private final long oldValue;\n-        private final long newValue;\n+        if (mediator != null) {\n+            mediator.cancel();\n+        }\n+    }\n+\n+    private StyleOrigin origin;\n+    private TransitionMediatorImpl mediator;\n@@ -126,3 +124,9 @@\n-        public TransitionMediatorImpl(long oldValue, long newValue) {\n-            this.oldValue = oldValue;\n-            this.newValue = newValue;\n+    private final class TransitionMediatorImpl extends TransitionMediator {\n+        private final long startValue;\n+        private final long endValue;\n+        private long reversingAdjustedStartValue;\n+\n+        public TransitionMediatorImpl(long startValue, long endValue) {\n+            this.startValue = startValue;\n+            this.endValue = endValue;\n+            this.reversingAdjustedStartValue = startValue;\n@@ -133,1 +137,4 @@\n-            set(progress < 1 ? oldValue + (long)((newValue - oldValue) * progress) : newValue);\n+            \/\/ Longs are interpolated in real number space and rounded to the nearest long.\n+            long diff = endValue - startValue;\n+            long result = startValue + Math.round(progress * diff);\n+            StyleableLongProperty.super.set(progress < 1 ? Utils.clamp(startValue, result, endValue) : endValue);\n@@ -138,7 +145,1 @@\n-            \/\/ When the transition is cancelled or completed, we clear the reference to this mediator.\n-            \/\/ However, when this mediator was cancelled by a reversing transition, the 'mediator' field\n-            \/\/ refers to the reversing mediator, and not to this mediator. We need to be careful to only\n-            \/\/ clear references to this mediator.\n-            if (mediator == this) {\n-                mediator = null;\n-            }\n+            mediator = null;\n@@ -151,0 +152,12 @@\n+\n+        @Override\n+        public boolean updateReversingAdjustedStartValue(TransitionMediator existingMediator) {\n+            var mediator = (TransitionMediatorImpl)existingMediator;\n+\n+            if (mediator.reversingAdjustedStartValue == endValue) {\n+                reversingAdjustedStartValue = mediator.endValue;\n+                return true;\n+            }\n+\n+            return false;\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableLongProperty.java","additions":41,"deletions":28,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import com.sun.javafx.css.SubPropertyConverter;\n@@ -31,0 +32,2 @@\n+import com.sun.javafx.tk.Toolkit;\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -35,0 +38,4 @@\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n@@ -74,0 +81,1 @@\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@@ -75,11 +83,34 @@\n-        T oldValue;\n-\n-        if (newValue == null) {\n-            set(null);\n-        } else if (!(newValue instanceof Interpolatable<?>)\n-                   || ((oldValue = get()) == null)\n-                   || !(newValue.getClass().isInstance(oldValue))) {\n-            \/\/ Consider a case where T := Paint. Now 'oldValue' could be a Color instance, while 'newValue' could\n-            \/\/ be a LinearGradient instance. Both types implement Interpolatable, but with different type arguments.\n-            \/\/ We detect this case by checking whether 'newValue' is an instance of 'oldValue' (so that\n-            \/\/ oldValue.interpolate(newValue, t) succeeds), and skipping the transition when the test fails.\n+        CssMetaData<? extends Styleable, T> metadata = getCssMetaData();\n+        StyleConverter<?, T> converter = metadata.getConverter();\n+        T oldValue = get();\n+\n+        if (oldValue != null && newValue != null && converter instanceof SubPropertyConverter c) {\n+            applyComponents(oldValue, newValue, metadata, c);\n+        } else {\n+            applyValue(oldValue, newValue, metadata);\n+        }\n+\n+        this.origin = origin;\n+    }\n+\n+    \/**\n+     * Sets the value of the property, and potentially starts a transition.\n+     * This method is used for values that don't support component-wise transitions, and for cases\n+     * where one of the values is {@code null} and we fall back to a discrete transition.\n+     *\n+     * @param oldValue the old value\n+     * @param newValue the new value\n+     * @param metadata the CSS metadata of the value\n+     *\/\n+    private void applyValue(T oldValue, T newValue, CssMetaData<? extends Styleable, T> metadata) {\n+        \/\/ If this.origin == null, we're setting the value for the first time.\n+        \/\/ No transition should be started in this case.\n+        TransitionDefinition transition =\n+            this.origin != null && getBean() instanceof Node node ?\n+            NodeHelper.findTransitionDefinition(node, metadata) : null;\n+\n+        \/\/ We only start a new transition if the new target value is different from the target\n+        \/\/ value of the existing transition. This scenario can sometimes happen when a CSS value\n+        \/\/ is redundantly applied, which would cause unexpected animations if we allowed the new\n+        \/\/ transition to interrupt the existing transition.\n+        if (transition == null) {\n@@ -87,0 +118,69 @@\n+        } else if (controller == null || !Objects.equals(newValue, controller.getTargetValue())) {\n+            TransitionControllerBase controller;\n+\n+            \/\/ 'oldValue' and 'newValue' could be objects that both implement Interpolatable, but with\n+            \/\/ different type arguments. We detect this case by checking whether 'newValue' is an instance\n+            \/\/ of 'oldValue' (so that oldValue.interpolate(newValue, t) succeeds), and only applying the\n+            \/\/ transition when the test succeeds.\n+            if (oldValue instanceof Interpolatable<?>\n+                    && newValue instanceof Interpolatable<?>\n+                    && newValue.getClass().isInstance(oldValue)) {\n+                controller = new InterpolatableTransitionController(oldValue, newValue);\n+            } else {\n+                controller = new DiscreteTransitionController(oldValue, newValue);\n+            }\n+\n+            this.controller = controller; \/\/ needs to be set before calling run()\n+            controller.run(transition, metadata.getProperty(), Toolkit.getToolkit().getPrimaryTimer().nanos());\n+        }\n+    }\n+\n+    \/**\n+     * Sets the value of the property, and potentially starts a transition.\n+     * This method is used for values that support component-wise transitions.\n+     *\n+     * @param newValue the new value\n+     * @param metadata the CSS metadata of the value\n+     * @param converter the style converter of the value\n+     *\/\n+    private void applyComponents(T oldValue, T newValue,\n+                                 CssMetaData<? extends Styleable, T> metadata,\n+                                 SubPropertyConverter<T> converter) {\n+        \/\/ If this.origin == null, we're setting the value for the first time.\n+        \/\/ No transition should be started in this case.\n+        Map<CssMetaData<? extends Styleable, ?>, TransitionDefinition> transitions =\n+            this.origin != null && getBean() instanceof Node node ?\n+            NodeHelper.findTransitionDefinitions(node, metadata) : null;\n+\n+        List<CssMetaData<? extends Styleable, ?>> subMetadata = metadata.getSubProperties();\n+\n+        if (transitions == null || transitions.isEmpty() || subMetadata == null || subMetadata.isEmpty()) {\n+            set(newValue);\n+        } else if (controller == null || !Objects.equals(newValue, controller.getTargetValue())) {\n+            var oldCssValues = converter.convertBack(oldValue);\n+            var newCssValues = converter.convertBack(newValue);\n+            var controller = new AggregatingTransitionController(newValue);\n+\n+            for (int i = 0, max = subMetadata.size(); i < max; ++i) {\n+                processComponent(controller, subMetadata.get(i), transitions, oldCssValues, newCssValues);\n+            }\n+\n+            this.controller = controller; \/\/ needs to be set before calling run()\n+            controller.run();\n+        }\n+    }\n+\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    private void processComponent(AggregatingTransitionController controller,\n+                                  CssMetaData<? extends Styleable, ?> metadata,\n+                                  Map<CssMetaData<? extends Styleable, ?>, TransitionDefinition> transitions,\n+                                  Map<CssMetaData<? extends Styleable, ?>, Object> oldCssValues,\n+                                  Map<CssMetaData<? extends Styleable, ?>, Object> newCssValues) {\n+        Object oldCssValue = oldCssValues.get(metadata);\n+        Object newCssValue = newCssValues.get(metadata);\n+\n+        \/\/ If the old and new CSS value is equal, we don't need to bother checking for a specified\n+        \/\/ transition, as it would not be noticeable anyway. Note that we're using deepEquals, as\n+        \/\/ the value might be an array of CSS values.\n+        if (Objects.deepEquals(oldCssValue, newCssValue)) {\n+            controller.addValue(metadata, oldCssValue);\n@@ -88,14 +188,49 @@\n-            \/\/ If this.origin == null, we're setting the value for the first time.\n-            \/\/ No transition should be started in this case.\n-            TransitionDefinition transition = this.origin != null && getBean() instanceof Node node ?\n-                NodeHelper.findTransitionDefinition(node, getCssMetaData()) : null;\n-\n-            if (transition == null) {\n-                set(newValue);\n-            } else if (mediator == null || !Objects.equals(mediator.newValue, newValue)) {\n-                \/\/ We only start a new transition if the new target value is different from the target\n-                \/\/ value of the existing transition. This scenario can sometimes happen when a CSS value\n-                \/\/ is redundantly applied, which would cause unexpected animations if we allowed the new\n-                \/\/ transition to interrupt the existing transition.\n-                mediator = new TransitionMediatorImpl(oldValue, newValue);\n-                mediator.run(transition);\n+            \/\/ The following code accounts for pre-existing transition mediators that can occur when more\n+            \/\/ than two states are involved. Consider the following scenario:\n+            \/\/\n+            \/\/     .button {\n+            \/\/       -fx-border-color: red;\n+            \/\/       -fx-border-width: 5;\n+            \/\/       transition: all 4s;\n+            \/\/     }\n+            \/\/\n+            \/\/     .button:hover {\n+            \/\/       -fx-border-color: green;\n+            \/\/     }\n+            \/\/\n+            \/\/     .button:pressed {\n+            \/\/       -fx-border-color: blue;\n+            \/\/       -fx-border-width: 20;\n+            \/\/     }\n+            \/\/\n+            \/\/ Now assume the following interactions:\n+            \/\/   1. Move the cursor over the button (:hover)\n+            \/\/   2. Press the mouse button (:hover:pressed)\n+            \/\/   3. Release the mouse button (:hover)\n+            \/\/   4. Move the cursor away from the button.\n+            \/\/\n+            \/\/ When the mouse button is released (step 3), the -fx-border-width sub-property transitions\n+            \/\/ from 20 (the current value) to 5 (the target value). Then, when the cursor is moved away\n+            \/\/ from the button while the -fx-border-width transition is still running, we need to preserve\n+            \/\/ the running transition by adding its mediator to the newly created transition controller\n+            \/\/ that manages the hover->base transition. In this way, the new transition controller will\n+            \/\/ continue to aggregate the effects of the pre-existing transition.\n+            \/\/\n+            var transition = transitions.get(metadata);\n+            var existingTimer = NodeHelper.findTransitionTimer((Node)getBean(), metadata.getProperty());\n+            var existingMediator = existingTimer != null && existingTimer.getMediator()\n+                instanceof StyleableObjectProperty.ComponentTransitionMediator m ? m : null;\n+\n+            if (existingMediator != null) {\n+                if (transition == null) {\n+                    existingMediator.cancel();\n+                    controller.addValue(metadata, newCssValue);\n+                } else if (Objects.deepEquals(newCssValue, existingMediator.endValue)) {\n+                    controller.addExistingMediator(existingMediator);\n+                } else {\n+                    controller.addMediator(oldCssValue, newCssValue, metadata, transition);\n+                }\n+            } else if (transition != null) {\n+                controller.addMediator(oldCssValue, newCssValue, metadata, transition);\n+            } else {\n+                controller.addValue(metadata, newCssValue);\n@@ -105,1 +240,6 @@\n-        this.origin = origin;\n+        List<CssMetaData<? extends Styleable, ?>> subMetadata = metadata.getSubProperties();\n+        if (subMetadata != null) {\n+            for (int i = 0, max = subMetadata.size(); i < max; ++i) {\n+                processComponent(controller, subMetadata.get(i), transitions, oldCssValues, newCssValues);\n+            }\n+        }\n@@ -112,6 +252,1 @@\n-        origin = StyleOrigin.USER;\n-\n-        \/\/ Calling the 'bind' method always cancels a transition timer.\n-        if (mediator != null) {\n-            mediator.cancel(true);\n-        }\n+        onUserChange();\n@@ -124,9 +259,1 @@\n-\n-        \/\/ Calling the 'set' method cancels the transition timer, but not if the 'set' method was\n-        \/\/ directly called by the timer itself (i.e. a timer will not accidentally cancel itself).\n-        \/\/ Note that indirect cancellation is still possible: a timer may fire a transition event,\n-        \/\/ which could cause user code to be executed that invokes this 'set' method. In that case,\n-        \/\/ the call will cancel the timer.\n-        if (mediator == null || mediator.cancel(false)) {\n-            origin = StyleOrigin.USER;\n-        }\n+        onUserChange();\n@@ -139,2 +266,2 @@\n-    private StyleOrigin origin = null;\n-    private TransitionMediatorImpl mediator = null;\n+    private void onUserChange() {\n+        origin = StyleOrigin.USER;\n@@ -142,3 +269,4 @@\n-    private final class TransitionMediatorImpl extends TransitionMediator {\n-        private final T oldValue;\n-        private final T newValue;\n+        if (controller != null) {\n+            controller.cancel();\n+        }\n+    }\n@@ -146,3 +274,45 @@\n-        TransitionMediatorImpl(T oldValue, T newValue) {\n-            this.oldValue = oldValue;\n-            this.newValue = newValue;\n+    private StyleOrigin origin;\n+    private TransitionController<T> controller;\n+\n+    \/**\n+     * Common interface for transition controllers:\n+     * <ol>\n+     *     <li>{@link DiscreteTransitionController}\n+     *     <li>{@link InterpolatableTransitionController}\n+     *     <li>{@link AggregatingTransitionController}\n+     * <\/ol>\n+     *\n+     * @param <T> the property value type\n+     *\/\n+    private interface TransitionController<T> {\n+        T getTargetValue();\n+        void cancel();\n+    }\n+\n+    \/**\n+     * Base class for transition controllers that don't support component-wise transitions.\n+     *\/\n+    private abstract class TransitionControllerBase extends TransitionMediator implements TransitionController<T> {\n+        final T startValue;\n+        final T endValue;\n+        private T reversingAdjustedStartValue;\n+\n+        TransitionControllerBase(T startValue, T endValue) {\n+            this.startValue = startValue;\n+            this.endValue = endValue;\n+            this.reversingAdjustedStartValue = startValue;\n+        }\n+\n+        @Override\n+        public void onStop() {\n+            controller = null;\n+        }\n+\n+        @Override\n+        public StyleableProperty<?> getStyleableProperty() {\n+            return StyleableObjectProperty.this;\n+        }\n+\n+        @Override\n+        public T getTargetValue() {\n+            return endValue;\n@@ -153,0 +323,21 @@\n+        public boolean updateReversingAdjustedStartValue(TransitionMediator existingMediator) {\n+            var mediator = (TransitionControllerBase)existingMediator;\n+\n+            if (Objects.deepEquals(mediator.reversingAdjustedStartValue, endValue)) {\n+                reversingAdjustedStartValue = mediator.endValue;\n+                return true;\n+            }\n+\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * Controller for transitions of non-interpolatable values using discrete interpolation.\n+     *\/\n+    private final class DiscreteTransitionController extends TransitionControllerBase {\n+        DiscreteTransitionController(T startValue, T endValue) {\n+            super(startValue, endValue);\n+        }\n+\n+        @Override\n@@ -154,1 +345,10 @@\n-            set(progress < 1 ? ((Interpolatable<T>)oldValue).interpolate(newValue, progress) : newValue);\n+            StyleableObjectProperty.super.set(progress < 0.5 ? startValue : endValue);\n+        }\n+    }\n+\n+    \/**\n+     * Controller for transitions of {@link Interpolatable} values.\n+     *\/\n+    private final class InterpolatableTransitionController extends TransitionControllerBase {\n+        InterpolatableTransitionController(T startValue, T endValue) {\n+            super(startValue, endValue);\n@@ -158,7 +358,105 @@\n-        public void onStop() {\n-            \/\/ When the transition is cancelled or completed, we clear the reference to this mediator.\n-            \/\/ However, when this mediator was cancelled by a reversing transition, the 'mediator' field\n-            \/\/ refers to the reversing mediator, and not to this mediator. We need to be careful to only\n-            \/\/ clear references to this mediator.\n-            if (mediator == this) {\n-                mediator = null;\n+        @SuppressWarnings(\"unchecked\")\n+        public void onUpdate(double progress) {\n+            StyleableObjectProperty.super.set(\n+                progress < 1 ? ((Interpolatable<T>)startValue).interpolate(endValue, progress) : endValue);\n+        }\n+    }\n+\n+    \/**\n+     * Controller for component-wise transitions that aggregates the effects of its component transitions.\n+     * <p>\n+     * For each animation frame, this controller waits until all its component mediators have updated\n+     * their current value, and then converts the collected component values into a new object of type\n+     * {@code T} using the {@link StyleConverter} of this {@link StyleableObjectProperty}.\n+     *\/\n+    private final class AggregatingTransitionController implements TransitionController<T> {\n+        private final T newValue;\n+        private final Map<CssMetaData<? extends Styleable, ?>, Object> cssValues;\n+        private final List<ComponentTransitionMediator<?>> mediators = new ArrayList<>(5);\n+        private int remainingValues;\n+\n+        AggregatingTransitionController(T newValue) {\n+            this.newValue = newValue;\n+            this.cssValues = new HashMap<>();\n+        }\n+\n+        @Override\n+        public T getTargetValue() {\n+            return newValue;\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            \/\/ Cancelling a mediator removes it from the 'mediators' list, so we need\n+            \/\/ to make a copy of the list before we iterate on it.\n+            for (var mediator : List.copyOf(mediators)) {\n+                mediator.cancel();\n+            }\n+        }\n+\n+        \/**\n+         * Starts all transition timers managed by this controller.\n+         *\/\n+        public void run() {\n+            remainingValues = mediators.size();\n+            long nanoNow = Toolkit.getToolkit().getPrimaryTimer().nanos();\n+\n+            \/\/ Starting a transition may result in instant cancellation (if the combined duration\n+            \/\/ is zero), which would instantly remove the mediator from the list. This is why we\n+            \/\/ need to make a copy of the 'mediators' list before we iterate on it.\n+            for (var mediator : List.copyOf(mediators)) {\n+                mediator.run(nanoNow);\n+            }\n+        }\n+\n+        \/**\n+         * Adds a component value to the value cache.\n+         *\n+         * @param metadata the {@code CssMetaData} of the component\n+         * @param value the new value\n+         *\/\n+        public void addValue(CssMetaData<? extends Styleable, ?> metadata, Object value) {\n+            cssValues.put(metadata, value);\n+        }\n+\n+        \/**\n+         * Adds a new component transition mediator to this controller.\n+         *\n+         * @param oldValue the old component value\n+         * @param newValue the new component value\n+         * @param metadata the component metadata\n+         * @param transition the transition definition\n+         * @param <U> the component value type\n+         *\/\n+        public <U> void addMediator(U oldValue, U newValue,\n+                                    CssMetaData<? extends Styleable, ?> metadata,\n+                                    TransitionDefinition transition) {\n+            mediators.add(new ComponentTransitionMediator<>(oldValue, newValue, this, metadata, transition));\n+        }\n+\n+        \/**\n+         * Adds an existing component transition mediator to this controller.\n+         * After calling this method, the existing mediator will be associated with this controller.\n+         *\n+         * @param mediator the existing component transition mediator\n+         * @param <U> the component value type\n+         *\/\n+        public <U> void addExistingMediator(ComponentTransitionMediator<U> mediator) {\n+            mediator.associatedController = this;\n+            mediators.add(mediator);\n+        }\n+\n+        \/**\n+         * This method is called when a component transition mediator updates its current value.\n+         * When all component values have been collected, they are converted to an object of type\n+         * {@code T} using the {@link StyleConverter} of this {@link StyleableObjectProperty}.\n+         *\n+         * @param metadata the {@code CssMetaData} of the component\n+         * @param value the new value\n+         *\/\n+        public void onUpdate(CssMetaData<? extends Styleable, ?> metadata, Object value) {\n+            cssValues.put(metadata, value);\n+\n+            if (--remainingValues == 0) {\n+                remainingValues = mediators.size();\n+                StyleableObjectProperty.super.set(getCssMetaData().getConverter().convert(cssValues));\n@@ -168,0 +466,48 @@\n+        \/**\n+         * This method is called when a component transition mediator is stopped.\n+         *\n+         * @param mediator the component transition mediator\n+         *\/\n+        public void onStop(ComponentTransitionMediator<?> mediator) {\n+            for (int i = 0, max = mediators.size(); i < max; ++i) {\n+                if (mediators.get(i) == mediator) {\n+                    mediators.remove(i);\n+                    break;\n+                }\n+            }\n+\n+            if (mediators.isEmpty()) {\n+                StyleableObjectProperty.this.controller = null;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Transition mediator for CSS sub-properties.\n+     * <p>\n+     * This transition mediator does not interact with the {@link StyleableObjectProperty} directly,\n+     * but instead feeds its effects into the associated {@link AggregatingTransitionController}.\n+     *\n+     * @param <U> the type of the sub-property\n+     *\/\n+    private final class ComponentTransitionMediator<U> extends TransitionMediator {\n+        private final U startValue;\n+        private final U endValue;\n+        private final CssMetaData<? extends Styleable, ?> metadata;\n+        private final TransitionDefinition definition;\n+        private AggregatingTransitionController associatedController;\n+        private U reversingAdjustedStartValue;\n+        private boolean running;\n+\n+        ComponentTransitionMediator(U startValue, U endValue,\n+                                    AggregatingTransitionController associatedController,\n+                                    CssMetaData<? extends Styleable, ?> metadata,\n+                                    TransitionDefinition definition) {\n+            this.startValue = startValue;\n+            this.endValue = endValue;\n+            this.reversingAdjustedStartValue = startValue;\n+            this.associatedController = associatedController;\n+            this.metadata = metadata;\n+            this.definition = definition;\n+        }\n+\n@@ -172,0 +518,47 @@\n+\n+        public void run(long now) {\n+            if (!running) {\n+                running = true;\n+                run(definition, metadata.getProperty(), now);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+        public void onUpdate(double progress) {\n+            Object value;\n+\n+            if (progress < 1) {\n+                if (startValue instanceof Interpolatable[][] ov && endValue instanceof Interpolatable[][] nv) {\n+                    value = InterpolationUtils.interpolateArraySeriesPairwise(ov, nv, progress);\n+                } else if (startValue instanceof Interpolatable[] ov && endValue instanceof Interpolatable[] nv) {\n+                    value = InterpolationUtils.interpolateArraysPairwise(ov, nv, progress);\n+                } else if (startValue instanceof Interpolatable && endValue instanceof Interpolatable) {\n+                    value = ((Interpolatable<U>)startValue).interpolate(endValue, progress);\n+                } else {\n+                    value = InterpolationUtils.interpolateDiscrete(startValue, endValue, progress);\n+                }\n+            } else {\n+                value = endValue;\n+            }\n+\n+            associatedController.onUpdate(metadata, value);\n+        }\n+\n+        @Override\n+        public void onStop() {\n+            associatedController.onStop(this);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public boolean updateReversingAdjustedStartValue(TransitionMediator existingMediator) {\n+            var mediator = (ComponentTransitionMediator<U>)existingMediator;\n+\n+            if (Objects.deepEquals(mediator.reversingAdjustedStartValue, endValue)) {\n+                reversingAdjustedStartValue = mediator.endValue;\n+                return true;\n+            }\n+\n+            return false;\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableObjectProperty.java","additions":450,"deletions":57,"binary":false,"changes":507,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+import com.sun.javafx.css.TransitionDefinition;\n+import com.sun.javafx.css.TransitionMediator;\n+import com.sun.javafx.scene.NodeHelper;\n+import com.sun.javafx.tk.Toolkit;\n@@ -30,0 +34,2 @@\n+import javafx.scene.Node;\n+import java.util.Objects;\n@@ -67,3 +73,18 @@\n-    public void applyStyle(StyleOrigin origin, String v) {\n-        \/\/ call set here in case the set method is overriden\n-        set(v);\n+    public void applyStyle(StyleOrigin origin, String newValue) {\n+        \/\/ If this.origin == null, we're setting the value for the first time.\n+        \/\/ No transition should be started in this case.\n+        TransitionDefinition transition =\n+            this.origin != null && getBean() instanceof Node node ?\n+            NodeHelper.findTransitionDefinition(node, getCssMetaData()) : null;\n+\n+        if (transition == null) {\n+            set(newValue);\n+        } else if (mediator == null || !Objects.equals(newValue, mediator.endValue)) {\n+            \/\/ We only start a new transition if the new target value is different from the target\n+            \/\/ value of the existing transition. This scenario can sometimes happen when a CSS value\n+            \/\/ is redundantly applied, which would cause unexpected animations if we allowed the new\n+            \/\/ transition to interrupt the existing transition.\n+            mediator = new TransitionMediatorImpl(get(), newValue); \/\/ needs to be set before calling run()\n+            mediator.run(transition, getCssMetaData().getProperty(), Toolkit.getToolkit().getPrimaryTimer().nanos());\n+        }\n+\n@@ -77,1 +98,1 @@\n-        origin = StyleOrigin.USER;\n+        onUserChange();\n@@ -84,1 +105,1 @@\n-        origin = StyleOrigin.USER;\n+        onUserChange();\n@@ -87,1 +108,0 @@\n-\n@@ -92,1 +112,10 @@\n-    private StyleOrigin origin = null;\n+    private void onUserChange() {\n+        origin = StyleOrigin.USER;\n+\n+        if (mediator != null) {\n+            mediator.cancel();\n+        }\n+    }\n+\n+    private StyleOrigin origin;\n+    private TransitionMediatorImpl mediator;\n@@ -94,0 +123,38 @@\n+    private final class TransitionMediatorImpl extends TransitionMediator {\n+        final String startValue;\n+        final String endValue;\n+        private String reversingAdjustedStartValue;\n+\n+        TransitionMediatorImpl(String startValue, String endValue) {\n+            this.startValue = startValue;\n+            this.endValue = endValue;\n+            this.reversingAdjustedStartValue = startValue;\n+        }\n+\n+        @Override\n+        public void onUpdate(double progress) {\n+            StyleableStringProperty.super.set(progress < 0.5 ? startValue : endValue);\n+        }\n+\n+        @Override\n+        public void onStop() {\n+            mediator = null;\n+        }\n+\n+        @Override\n+        public StyleableProperty<?> getStyleableProperty() {\n+            return StyleableStringProperty.this;\n+        }\n+\n+        @Override\n+        public boolean updateReversingAdjustedStartValue(TransitionMediator existingMediator) {\n+            var mediator = (TransitionMediatorImpl)existingMediator;\n+\n+            if (Objects.equals(mediator.reversingAdjustedStartValue, endValue)) {\n+                reversingAdjustedStartValue = mediator.endValue;\n+                return true;\n+            }\n+\n+            return false;\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableStringProperty.java","additions":75,"deletions":8,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import javafx.scene.layout.Region;\n@@ -86,0 +87,5 @@\n+    \/**\n+     * The name of the CSS property or sub-property that is targeted by the transition.\n+     *\/\n+    private final String propertyName;\n+\n@@ -100,0 +106,17 @@\n+    @Deprecated(forRemoval = true)\n+    public TransitionEvent(EventType<? extends Event> eventType,\n+                           StyleableProperty<?> property,\n+                           Duration elapsedTime) {\n+        this(eventType, property, property.getCssMetaData().getProperty(), elapsedTime);\n+    }\n+\n+    \/**\n+     * Creates a new instance of the {@code TransitionEvent} class.\n+     *\n+     * @param eventType the event type\n+     * @param property the {@code StyleableProperty} that is targeted by the transition\n+     * @param propertyName the name of the targeted CSS property or sub-property\n+     * @param elapsedTime the time that has elapsed since the transition has entered its active period\n+     * @throws NullPointerException if any of the arguments is {@code null}\n+     * @since 24\n+     *\/\n@@ -102,0 +125,1 @@\n+                           String propertyName,\n@@ -105,0 +129,1 @@\n+        this.propertyName = Objects.requireNonNull(propertyName, \"propertyName cannot be null\");\n@@ -117,0 +142,15 @@\n+    \/**\n+     * Gets the name of the CSS property or sub-property that is targeted by the transition.\n+     * <p>\n+     * The name of the CSS property under transition can be a long-hand property name, which is different\n+     * from the name returned by {@link CssMetaData#getProperty()} of the {@code StyleableProperty} that\n+     * is targeted by the transition. For example, if a transition targets {@link Region#borderProperty()},\n+     * the name of the CSS property might be {@code -fx-border-color}, {@code -fx-border-radius}, etc.\n+     *\n+     * @return the CSS property or sub-property name\n+     * @since 24\n+     *\/\n+    public String getPropertyName() {\n+        return propertyName;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/TransitionEvent.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ import com.sun.javafx.util.InterpolationUtils;\n+ import javafx.animation.Interpolatable;\n@@ -29,0 +31,1 @@\n+ import java.util.Objects;\n@@ -34,1 +37,1 @@\n-public class Insets {\n+public class Insets implements Interpolatable<Insets> {\n@@ -41,1 +44,2 @@\n-     * The inset on the top side\n+     * The inset on the top side.\n+     *\n@@ -43,0 +47,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -48,1 +53,2 @@\n-     * The inset on the right side\n+     * The inset on the right side.\n+     *\n@@ -50,0 +56,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -55,1 +62,2 @@\n-     * The inset on the bottom side\n+     * The inset on the bottom side.\n+     *\n@@ -57,0 +65,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -62,1 +71,2 @@\n-     * The inset on the left side\n+     * The inset on the left side.\n+     *\n@@ -64,0 +74,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -102,0 +113,25 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public Insets interpolate(Insets endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0 || equals(endValue)) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        return new Insets(\n+            InterpolationUtils.interpolate(top, endValue.top, t),\n+            InterpolationUtils.interpolate(right, endValue.right, t),\n+            InterpolationUtils.interpolate(bottom, endValue.bottom, t),\n+            InterpolationUtils.interpolate(left, endValue.left, t));\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/geometry\/Insets.java","additions":42,"deletions":6,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Objects;\n@@ -54,0 +55,1 @@\n+     *\n@@ -55,0 +57,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -69,0 +72,1 @@\n+     *\n@@ -70,0 +74,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -361,0 +366,1 @@\n+     * @throws NullPointerException {@inheritDoc}\n@@ -365,0 +371,2 @@\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/geometry\/Point2D.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Objects;\n@@ -55,0 +56,1 @@\n+     *\n@@ -56,0 +58,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -70,0 +73,1 @@\n+     *\n@@ -71,0 +75,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -85,0 +90,1 @@\n+     *\n@@ -86,0 +92,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -399,0 +406,1 @@\n+     * @throws NullPointerException {@inheritDoc}\n@@ -403,0 +411,2 @@\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/geometry\/Point3D.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -637,2 +637,4 @@\n-                if (node.transitions == null) {\n-                    node.transitions = node.new TransitionDefinitionCollection();\n+                var definitions = node.miscProperties != null ? node.miscProperties.transitionDefinitions : null;\n+                if (definitions == null) {\n+                    definitions = new TransitionDefinitionCollection();\n+                    node.getMiscProperties().transitionDefinitions = definitions;\n@@ -641,1 +643,1 @@\n-                return node.transitions;\n+                return definitions;\n@@ -647,1 +649,2 @@\n-                return node.transitions == null ? null : node.transitions.find(metadata);\n+                var definitions = node.miscProperties != null ? node.miscProperties.transitionDefinitions : null;\n+                return definitions == null ? null : definitions.find(metadata);\n@@ -651,2 +654,9 @@\n-            public void addTransitionTimer(Node node, TransitionTimer timer) {\n-                node.addTransitionTimer(timer);\n+            public Map<CssMetaData<? extends Styleable, ?>, TransitionDefinition> findTransitionDefinitions(\n+                    Node node, CssMetaData<? extends Styleable, ?> metadata) {\n+                var definitions = node.miscProperties != null ? node.miscProperties.transitionDefinitions : null;\n+                return definitions == null ? null : definitions.findAll(metadata);\n+            }\n+\n+            @Override\n+            public void addTransitionTimer(Node node, String propertyName, TransitionTimer timer) {\n+                node.addTransitionTimer(propertyName, timer);\n@@ -656,2 +666,2 @@\n-            public void removeTransitionTimer(Node node, TransitionTimer timer) {\n-                node.removeTransitionTimer(timer);\n+            public void removeTransitionTimer(Node node, String propertyName) {\n+                node.removeTransitionTimer(propertyName);\n@@ -661,2 +671,2 @@\n-            public TransitionTimer findTransitionTimer(Node node, Property<?> property) {\n-                return node.findTransitionTimer(property);\n+            public TransitionTimer findTransitionTimer(Node node, String propertyName) {\n+                return node.findTransitionTimer(propertyName);\n@@ -6787,0 +6797,2 @@\n+        private TransitionTimerCollection transitionTimers;\n+        private TransitionDefinitionCollection transitionDefinitions;\n@@ -8973,1 +8985,61 @@\n-    private List<TransitionTimer> transitionTimers;\n+    \/**\n+     * The list of running transition timers for this node, implemented as a mapping of\n+     * CSS property names to {@link TransitionTimer} instances.\n+     *\/\n+    private static class TransitionTimerCollection extends HashMap<String, TransitionTimer> {\n+        TransitionTimerCollection() {\n+            super(4);\n+        }\n+\n+        \/**\n+         * Returns all transition timers for the specified {@code StyleableProperty},\n+         * including all of its sub-properties.\n+         *\n+         * @param property the {@code StyleableProperty}\n+         * @return a mapping of CSS property names to {@code TransitionTimer} instances\n+         *\/\n+        public Map<String, TransitionTimer> getAll(StyleableProperty<?> property) {\n+            if (isEmpty()) {\n+                return Map.of();\n+            }\n+\n+            var result = collectTransitionTimers(property, null);\n+            return result != null ? result : Map.of();\n+        }\n+\n+        \/**\n+         * Finds all transition timers for the specified {@code StyleableProperty}, including all\n+         * of its sub-properties. This method does not allocate a new {@code Map} for the common\n+         * case where no transitions are found.\n+         *\n+         * @param property the {@code StyleableProperty}\n+         * @param result this argument is an implementation detail, callers must specify {@code null}\n+         * @return a mapping of CSS property names to {@code TransitionTimer} instances\n+         *\/\n+        private Map<String, TransitionTimer> collectTransitionTimers(\n+                StyleableProperty<?> property, Map<String, TransitionTimer> result) {\n+            CssMetaData<? extends Styleable, ?> metadata = property.getCssMetaData();\n+            String propertyName = metadata.getProperty();\n+            TransitionTimer timer = get(propertyName);\n+            if (timer != null) {\n+                if (result == null) {\n+                    \/\/ We expect the number of concurrent transitions for any given node to be\n+                    \/\/ quite small in most cases, six mappings should be enough.\n+                    result = HashMap.newHashMap(6);\n+                }\n+\n+                result.put(propertyName, timer);\n+            }\n+\n+            List<CssMetaData<? extends Styleable, ?>> subMetadata = metadata.getSubProperties();\n+            if (subMetadata == null) {\n+                return result;\n+            }\n+\n+            for (int i = 0, max = subMetadata.size(); i < max; ++i) {\n+                result = collectTransitionTimers(property, result);\n+            }\n+\n+            return result;\n+        }\n+    }\n@@ -8982,1 +9054,2 @@\n-    private void addTransitionTimer(TransitionTimer timer) {\n+    private void addTransitionTimer(String propertyName, TransitionTimer timer) {\n+        var transitionTimers = miscProperties != null ? miscProperties.transitionTimers : null;\n@@ -8984,1 +9057,2 @@\n-            transitionTimers = new ArrayList<>(4);\n+            transitionTimers = new TransitionTimerCollection();\n+            getMiscProperties().transitionTimers = transitionTimers;\n@@ -8987,1 +9061,1 @@\n-        transitionTimers.add(timer);\n+        transitionTimers.put(propertyName, timer);\n@@ -8997,1 +9071,2 @@\n-    private void removeTransitionTimer(TransitionTimer timer) {\n+    private void removeTransitionTimer(String propertyName) {\n+        var transitionTimers = miscProperties != null ? miscProperties.transitionTimers : null;\n@@ -8999,1 +9074,5 @@\n-            transitionTimers.remove(timer);\n+            transitionTimers.remove(propertyName);\n+\n+            if (transitionTimers.isEmpty()) {\n+                miscProperties.transitionTimers = null;\n+            }\n@@ -9004,1 +9083,1 @@\n-     * Finds the transition timer that targets the specified {@code property}.\n+     * Finds the transition timer that targets the specified {@code propertyName}.\n@@ -9006,1 +9085,1 @@\n-     * @param property the targeted property\n+     * @param propertyName the CSS name of the targeted property\n@@ -9010,14 +9089,4 @@\n-    private TransitionTimer findTransitionTimer(Property<?> property) {\n-        if (transitionTimers == null) {\n-            return null;\n-        }\n-\n-        for (int i = 0, max = transitionTimers.size(); i < max; ++i) {\n-            TransitionTimer timer = transitionTimers.get(i);\n-\n-            \/\/ We use an identity comparison here because we're looking for the exact property\n-            \/\/ instance that was targeted by the transition timer on this node.\n-            if (timer.getTargetProperty() == property) {\n-                return timer;\n-            }\n-        }\n+    private TransitionTimer findTransitionTimer(String propertyName) {\n+        var transitionTimers = miscProperties != null ? miscProperties.transitionTimers : null;\n+        return transitionTimers != null ? transitionTimers.get(propertyName) : null;\n+    }\n@@ -9025,1 +9094,10 @@\n-        return null;\n+    \/**\n+     * Finds all transition timers that target the specified {@code property}.\n+     *\n+     * @param property the targeted property\n+     * @return a mapping of property names to transition timers, or an empty map if the\n+     *         property is not targeted by any transition timers\n+     *\/\n+    private Map<String, TransitionTimer> findTransitionTimers(StyleableProperty<?> property) {\n+        var transitionTimers = miscProperties != null ? miscProperties.transitionTimers : null;\n+        return transitionTimers != null ? transitionTimers.getAll(property) : Map.of();\n@@ -9034,0 +9112,1 @@\n+        var transitionTimers = miscProperties != null ? miscProperties.transitionTimers : null;\n@@ -9038,3 +9117,3 @@\n-        \/\/ Make a copy of the list, because completing the timers causes them to be removed\n-        \/\/ from the list, which would result in a ConcurrentModificationException.\n-        for (TransitionTimer timer : List.copyOf(transitionTimers)) {\n+        \/\/ Make a copy of the timers, because completing the timers causes them to be removed\n+        \/\/ from the map, which would result in a ConcurrentModificationException.\n+        for (TransitionTimer timer : List.copyOf(transitionTimers.values())) {\n@@ -9046,2 +9125,2 @@\n-    List<TransitionTimer> getTransitionTimers() {\n-        return transitionTimers;\n+    Map<String, TransitionTimer> getTransitionTimers() {\n+        return miscProperties != null ? miscProperties.transitionTimers : null;\n@@ -9058,1 +9137,1 @@\n-    private class TransitionDefinitionCollection\n+    private static class TransitionDefinitionCollection\n@@ -9065,1 +9144,2 @@\n-         * or {@code null} if no transition was found.\n+         * or {@code null} if no transition was found. This method does not account for\n+         * sub-properties of the specified property.\n@@ -9071,1 +9151,1 @@\n-        TransitionDefinition find(CssMetaData<? extends Styleable, ?> metadata) {\n+        public TransitionDefinition find(CssMetaData<? extends Styleable, ?> metadata) {\n@@ -9090,0 +9170,52 @@\n+            return null;\n+        }\n+\n+        \/**\n+         * Returns all transitions for the property referenced by the specified CSS metadata,\n+         * including all of its sub-properties.\n+         *\n+         * @param metadata the CSS metadata of the property\n+         * @return a mapping of CSS metadata instances to {@code TransitionDefinition} instances\n+         *\/\n+        public Map<CssMetaData<? extends Styleable, ?>, TransitionDefinition> findAll(\n+                CssMetaData<? extends Styleable, ?> metadata) {\n+            if (isEmpty()) {\n+                return Map.of();\n+            }\n+\n+            var result = collectTransitions(metadata, null);\n+            return result != null ? result : Map.of();\n+        }\n+\n+        \/**\n+         * Finds all transition definitions for the property referenced by the specified CSS metadata,\n+         * including all of its sub-properties. This method does not allocate a new {@code Map} for the\n+         * common case where no transitions are found.\n+         *\n+         * @param metadata the CSS metadata of the property\n+         * @param result this argument is an implementation detail, callers must specify {@code null}\n+         * @return a mapping of CSS metadata instances to {@code TransitionDefinition} instances\n+         *\/\n+        private Map<CssMetaData<? extends Styleable, ?>, TransitionDefinition> collectTransitions(\n+                CssMetaData<? extends Styleable, ?> metadata,\n+                Map<CssMetaData<? extends Styleable, ?>, TransitionDefinition> result) {\n+            \/\/ We look for a matching transition in reverse, since multiple transitions might be specified\n+            \/\/ for the same property. In this case, the last transition takes precedence.\n+            for (int max = size(), i = max - 1; i >= 0; --i) {\n+                TransitionDefinition transition = get(i);\n+\n+                boolean selected = TransitionDefinitionConverter.PROPERTY_ALL.equals(transition.propertyName())\n+                        || metadata.getProperty().equals(transition.propertyName());\n+\n+                if (selected) {\n+                    if (result == null) {\n+                        \/\/ We expect the number of concurrent transitions for any given node to be\n+                        \/\/ quite small in most cases, six mappings should be enough.\n+                        result = HashMap.newHashMap(6);\n+                    }\n+\n+                    result.put(metadata, transition);\n+                    break;\n+                }\n+            }\n+\n@@ -9092,1 +9224,1 @@\n-                return null;\n+                return result;\n@@ -9095,3 +9227,1 @@\n-            \/\/ We also need to search for matching sub-properties, since a transition might be defined\n-            \/\/ for a sub-property (for example, '-fx-background-color') but must be applied to the base\n-            \/\/ property (-fx-background).\n+            \/\/ We also need to search for transitions defined on all sub-properties of the current property.\n@@ -9099,4 +9229,1 @@\n-                TransitionDefinition transition = find(subMetadata.get(i));\n-                if (transition != null) {\n-                    return transition;\n-                }\n+                result = collectTransitions(subMetadata.get(i), result);\n@@ -9105,1 +9232,1 @@\n-            return null;\n+            return result;\n@@ -9137,2 +9264,0 @@\n-    private TransitionDefinitionCollection transitions;\n-\n@@ -9141,5 +9266,1 @@\n-        if (transitions == null) {\n-            transitions = new TransitionDefinitionCollection();\n-        }\n-\n-        return transitions;\n+        return miscProperties != null ? miscProperties.transitionDefinitions : null;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":178,"deletions":57,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import javafx.animation.Interpolatable;\n@@ -39,0 +40,1 @@\n+import java.util.Objects;\n@@ -50,0 +52,1 @@\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -73,1 +76,1 @@\n-public final class Background {\n+public final class Background implements Interpolatable<Background> {\n@@ -139,0 +142,1 @@\n+     *\n@@ -140,0 +144,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#pairwise\">pairwise<\/a>\n@@ -148,0 +153,1 @@\n+     *\n@@ -149,0 +155,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#pairwise\">pairwise<\/a>\n@@ -160,0 +167,1 @@\n+     *\n@@ -161,0 +169,1 @@\n+     * @interpolationType the intermediate value is derived from {@link #getFills() fills}\n@@ -247,3 +256,3 @@\n-        \/\/ array based constructor (for speed).\n-        this(fills == null ? null : fills.toArray(new BackgroundFill[fills.size()]),\n-             images == null ? null : images.toArray(new BackgroundImage[images.size()]));\n+        \/\/ array based constructor.\n+        this(fills != null ? UnmodifiableArrayList.copyOfNullFiltered(fills) : List.of(),\n+             images != null ? UnmodifiableArrayList.copyOfNullFiltered(images) : List.of(), 0);\n@@ -267,0 +276,18 @@\n+        this(fills != null ? UnmodifiableArrayList.copyOfNullFiltered(fills) : List.of(),\n+             images != null ? UnmodifiableArrayList.copyOfNullFiltered(images) : List.of(), 0);\n+    }\n+\n+    \/**\n+     * Creates a new Background with the specified fills and images.\n+     * This constructor requires that both lists do not contain null values, and that the lists\n+     * are immutable. The purpose of this constructor is to prevent an unnecessary array creation\n+     * when the caller already knows that the specified lists satisfy the non-null precondition\n+     * and preserve the immutability invariant.\n+     *\n+     * @param fills the fills, not {@code null}\n+     * @param images the images, not {@code null}\n+     *\/\n+    private Background(List<BackgroundFill> fills, List<BackgroundImage> images, int ignored) {\n+        Objects.requireNonNull(fills, \"fills cannot be null\");\n+        Objects.requireNonNull(images, \"images cannot be null\");\n+\n@@ -273,33 +300,21 @@\n-        \/\/ If the fills is empty or null then we know we can just use the shared\n-        \/\/ immutable empty list from Collections.\n-        if (fills == null || fills.length == 0) {\n-            this.fills = Collections.emptyList();\n-        } else {\n-            \/\/ We need to iterate over all of the supplied elements in the fills array.\n-            \/\/ Each null element is ignored. Each non-null element is inspected to\n-            \/\/ see if it contributes to the outsets.\n-            final BackgroundFill[] noNulls = new BackgroundFill[fills.length];\n-            int size = 0;\n-            for (int i=0; i<fills.length; i++) {\n-                final BackgroundFill fill = fills[i];\n-                if (fill != null) {\n-                    noNulls[size++] = fill;\n-                    final Insets fillInsets = fill.getInsets();\n-                    final double fillTop = fillInsets.getTop();\n-                    final double fillRight = fillInsets.getRight();\n-                    final double fillBottom = fillInsets.getBottom();\n-                    final double fillLeft = fillInsets.getLeft();\n-                    outerTop = outerTop <= fillTop ? outerTop : fillTop; \/\/ min\n-                    outerRight = outerRight <= fillRight ? outerRight : fillRight; \/\/ min\n-                    outerBottom = outerBottom <= fillBottom ? outerBottom : fillBottom; \/\/ min\n-                    outerLeft = outerLeft <= fillLeft ? outerLeft : fillLeft; \/\/ min\n-\n-                    \/\/ The common case is to NOT have percent based radii\n-                    final boolean b = fill.getRadii().hasPercentBasedRadii;\n-                    hasPercentFillRadii |= b;\n-                    if (fill.fill.isOpaque()) {\n-                        opaqueFill = true;\n-                        if (b) {\n-                            hasPercentOpaqueInsets = true;\n-                        }\n-                    }\n+        \/\/ We need to iterate over all of the supplied elements in the fills list.\n+        \/\/ Each element is inspected to see if it contributes to the outsets.\n+        for (int i = 0, max = fills.size(); i < max; i++) {\n+            final BackgroundFill fill = fills.get(i);\n+            final Insets fillInsets = fill.getInsets();\n+            final double fillTop = fillInsets.getTop();\n+            final double fillRight = fillInsets.getRight();\n+            final double fillBottom = fillInsets.getBottom();\n+            final double fillLeft = fillInsets.getLeft();\n+            outerTop = outerTop <= fillTop ? outerTop : fillTop; \/\/ min\n+            outerRight = outerRight <= fillRight ? outerRight : fillRight; \/\/ min\n+            outerBottom = outerBottom <= fillBottom ? outerBottom : fillBottom; \/\/ min\n+            outerLeft = outerLeft <= fillLeft ? outerLeft : fillLeft; \/\/ min\n+\n+            \/\/ The common case is to NOT have percent based radii\n+            final boolean b = fill.getRadii().hasPercentBasedRadii;\n+            hasPercentFillRadii |= b;\n+            if (fill.fill.isOpaque()) {\n+                opaqueFill = true;\n+                if (b) {\n+                    hasPercentOpaqueInsets = true;\n@@ -308,1 +323,0 @@\n-            this.fills = new UnmodifiableArrayList<>(noNulls, size);\n@@ -310,0 +324,2 @@\n+\n+        this.fills = fills;\n@@ -320,13 +336,1 @@\n-        \/\/ An null or empty images array results in an empty list\n-        if (images == null || images.length == 0) {\n-            this.images = Collections.emptyList();\n-        } else {\n-            \/\/ Filter out any  null values and create an immutable array list\n-            final BackgroundImage[] noNulls = new BackgroundImage[images.length];\n-            int size = 0;\n-            for (int i=0; i<images.length; i++) {\n-                final BackgroundImage image = images[i];\n-                if (image != null) noNulls[size++] = image;\n-            }\n-            this.images = new UnmodifiableArrayList<>(noNulls, size);\n-        }\n+        this.images = images;\n@@ -638,0 +642,39 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public Background interpolate(Background endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        \/\/ interpolateListsPairwise() is implemented such that it returns existing list instances\n+        \/\/ (i.e. the 'this.fills' or 'endValue.fills' arguments) as an indication that the result\n+        \/\/ is shallow-equal to either of the input arguments. This allows us to very quickly detect\n+        \/\/ if we can return 'this' or 'endValue' without allocating a new Background instance.\n+        List<BackgroundFill> newFills = fills == endValue.fills ?\n+            fills : InterpolationUtils.interpolateListsPairwise(fills, endValue.fills, t);\n+\n+        List<BackgroundImage> newImages = images == endValue.images ?\n+            images : InterpolationUtils.interpolateListsPairwise(images, endValue.images, t);\n+\n+        if (newFills == fills && newImages == images) {\n+            return this;\n+        }\n+\n+        if (newFills == endValue.fills && newImages == endValue.images) {\n+            return endValue;\n+        }\n+\n+        return new Background(newFills, newImages, 0);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Background.java","additions":95,"deletions":52,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.javafx.css.SubPropertyConverter;\n@@ -30,0 +31,1 @@\n+import java.util.List;\n@@ -42,1 +44,2 @@\n-class BackgroundConverter extends StyleConverter<ParsedValue[], Background> {\n+class BackgroundConverter extends StyleConverter<ParsedValue[], Background>\n+                          implements SubPropertyConverter<Background> {\n@@ -46,1 +49,7 @@\n-    @Override public Background convert(Map<CssMetaData<? extends Styleable, ?>,Object> convertedValues) {\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException if {@code convertedValues} is {@code null}\n+     *\/\n+    @Override\n+    public Background convert(Map<CssMetaData<? extends Styleable, ?>,Object> convertedValues) {\n@@ -48,1 +57,1 @@\n-        final String[] imageUrls = (String[]) convertedValues.get(Background.BACKGROUND_IMAGE);\n+        final Object[] images = (Object[]) convertedValues.get(Background.BACKGROUND_IMAGE);\n@@ -50,1 +59,1 @@\n-        final boolean hasImages = imageUrls != null && imageUrls.length > 0;\n+        final boolean hasImages = images != null && images.length > 0;\n@@ -79,1 +88,1 @@\n-            backgroundImages = new BackgroundImage[imageUrls.length];\n+            backgroundImages = new BackgroundImage[images.length];\n@@ -93,1 +102,1 @@\n-            for (int i = 0; i < imageUrls.length; i++) {\n+            for (int i = 0; i < images.length; i++) {\n@@ -95,1 +104,13 @@\n-                if (imageUrls[i] == null) continue;\n+                if (images[i] == null) continue;\n+\n+                final Image image;\n+\n+                \/\/ The images are either URLs (when they come from CSS) or the actual Image\n+                \/\/ instances (when they come from the convertBack operation).\n+                if (images[i] instanceof String url) {\n+                    image = StyleManager.getInstance().getCachedImage(url);\n+                } else if (images[i] instanceof Image img) {\n+                    image = img;\n+                } else {\n+                    throw new IllegalArgumentException(\"Unexpected type: \" + images[i].getClass().getName());\n+                }\n@@ -97,1 +118,0 @@\n-                final Image image = StyleManager.getInstance().getCachedImage(imageUrls[i]);\n@@ -117,0 +137,45 @@\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException if {@code value} is {@code null}\n+     *\/\n+    @Override\n+    public Map<CssMetaData<? extends Styleable, ?>, Object> convertBack(Background value) {\n+        List<BackgroundFill> fills = value.getFills();\n+        int fillsCount = fills.size();\n+        Paint[] backgroundColor = new Paint[fillsCount];\n+        CornerRadii[] backgroundRadius = new CornerRadii[fillsCount];\n+        Insets[] backgroundInsets = new Insets[fillsCount];\n+\n+        for (int i = 0; i < fillsCount; ++i) {\n+            BackgroundFill fill = fills.get(i);\n+            backgroundColor[i] = fill.getFill();\n+            backgroundRadius[i] = fill.getRadii();\n+            backgroundInsets[i] = fill.getInsets();\n+        }\n+\n+        List<BackgroundImage> backgroundImages = value.getImages();\n+        int imageCount = backgroundImages.size();\n+        Image[] images = new Image[imageCount];\n+        BackgroundPosition[] backgroundPosition = new BackgroundPosition[imageCount];\n+        RepeatStruct[] backgroundRepeat = new RepeatStruct[imageCount];\n+        BackgroundSize[] backgroundSize = new BackgroundSize[imageCount];\n+\n+        for (int i = 0; i < imageCount; ++i) {\n+            BackgroundImage image = backgroundImages.get(i);\n+            images[i] = image.getImage();\n+            backgroundPosition[i] = image.getPosition();\n+            backgroundRepeat[i] = new RepeatStruct(image.getRepeatX(), image.getRepeatY());\n+            backgroundSize[i] = image.getSize();\n+        }\n+\n+        return Map.of(\n+            Background.BACKGROUND_COLOR, backgroundColor,\n+            Background.BACKGROUND_IMAGE, images,\n+            Background.BACKGROUND_INSETS, backgroundInsets,\n+            Background.BACKGROUND_POSITION, backgroundPosition,\n+            Background.BACKGROUND_RADIUS, backgroundRadius,\n+            Background.BACKGROUND_REPEAT, backgroundRepeat,\n+            Background.BACKGROUND_SIZE, backgroundSize);\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundConverter.java","additions":74,"deletions":9,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.InterpolationUtils;\n+import javafx.animation.Interpolatable;\n@@ -32,0 +34,1 @@\n+import java.util.Objects;\n@@ -44,1 +47,1 @@\n-public final class BackgroundFill {\n+public final class BackgroundFill implements Interpolatable<BackgroundFill> {\n@@ -48,0 +51,1 @@\n+     *\n@@ -49,0 +53,1 @@\n+     * @interpolationType see {@link Paint}\n@@ -58,0 +63,1 @@\n+     *\n@@ -59,0 +65,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -69,0 +76,1 @@\n+     *\n@@ -70,0 +78,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -106,0 +115,45 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public BackgroundFill interpolate(BackgroundFill endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        \/\/ CornerRadii, Insets and Paint are implemented such that interpolate() always returns the\n+        \/\/ existing instance if the intermediate value is equal to the start value or the end value,\n+        \/\/ which allows us to use an identity comparison in place of a value comparison to determine\n+        \/\/ equality.\n+        CornerRadii newRadii = radii.interpolate(endValue.radii, t);\n+        Insets newInsets = insets.interpolate(endValue.insets, t);\n+        Paint newFill = InterpolationUtils.interpolatePaint(fill, endValue.fill, t);\n+\n+        if (isSame(newFill, newRadii, newInsets)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newFill, newRadii, newInsets)) {\n+            return endValue;\n+        }\n+\n+        return new BackgroundFill(newFill, newRadii, newInsets);\n+    }\n+\n+    private boolean isSame(Paint fill, CornerRadii radii, Insets insets) {\n+        return this.fill == fill\n+            && this.radii == radii\n+            && this.insets == insets;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundFill.java","additions":56,"deletions":2,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import javafx.animation.Interpolatable;\n@@ -30,0 +31,1 @@\n+import java.util.Objects;\n@@ -46,1 +48,1 @@\n-public final class BackgroundImage {\n+public final class BackgroundImage implements Interpolatable<BackgroundImage> {\n@@ -55,0 +57,1 @@\n+     *\n@@ -56,0 +59,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -64,0 +68,1 @@\n+     *\n@@ -65,1 +70,2 @@\n-     * is to be repeated along the x-axis of the region\n+     *         is to be repeated along the x-axis of the region\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -74,0 +80,1 @@\n+     *\n@@ -75,1 +82,2 @@\n-     * is to be repeated along the y-axis of the region\n+     *         is to be repeated along the y-axis of the region\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -83,0 +91,1 @@\n+     *\n@@ -84,0 +93,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -90,0 +100,1 @@\n+     *\n@@ -91,0 +102,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -141,0 +153,62 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public BackgroundImage interpolate(BackgroundImage endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        \/\/ BackgroundPosition and BackgroundSize are implemented such that interpolate() always returns\n+        \/\/ the existing instance if the intermediate value is equal to the start value or the end value,\n+        \/\/ which allows us to use an identity comparison in place of a value comparison to determine\n+        \/\/ equality.\n+        BackgroundPosition newPosition = this.position.interpolate(endValue.position, t);\n+        BackgroundSize newSize = this.size.interpolate(endValue.size, t);\n+        BackgroundRepeat newRepeatX, newRepeatY;\n+        Image newImage;\n+\n+        if (t < 0.5) {\n+            newRepeatX = this.repeatX;\n+            newRepeatY = this.repeatY;\n+            newImage = this.image;\n+        } else {\n+            newRepeatX = endValue.repeatX;\n+            newRepeatY = endValue.repeatY;\n+            newImage = endValue.image;\n+        }\n+\n+        if (isSame(newImage, newRepeatX, newRepeatY, newPosition, newSize)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newImage, newRepeatX, newRepeatY, newPosition, newSize)) {\n+            return endValue;\n+        }\n+\n+        return new BackgroundImage(newImage, newRepeatX, newRepeatY, newPosition, newSize);\n+    }\n+\n+    private boolean isSame(Image image,\n+                           BackgroundRepeat repeatX,\n+                           BackgroundRepeat repeatY,\n+                           BackgroundPosition position,\n+                           BackgroundSize size) {\n+        return this.image == image\n+            && this.repeatX == repeatX\n+            && this.repeatY == repeatY\n+            && this.position == position\n+            && this.size == size;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundImage.java","additions":78,"deletions":4,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.InterpolationUtils;\n+import javafx.animation.Interpolatable;\n@@ -30,0 +32,1 @@\n+import java.util.Objects;\n@@ -52,1 +55,1 @@\n-public class BackgroundPosition {\n+public class BackgroundPosition implements Interpolatable<BackgroundPosition> {\n@@ -71,2 +74,3 @@\n-     * @return the Side along the horizontal axis to which the BackgroundImage is\n-     * anchored\n+     *\n+     * @return the Side along the horizontal axis to which the BackgroundImage is anchored\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -80,2 +84,2 @@\n-     * @return the Side along the vertical axis to which the BackgroundImage is\n-     * anchored\n+     * @return the Side along the vertical axis to which the BackgroundImage is anchored\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -93,0 +97,1 @@\n+     *\n@@ -94,0 +99,4 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> if one\n+     *                    value is absolute and the other is a {@link #isHorizontalAsPercentage() percentage},\n+     *                    or if the background is anchored at different {@link #getHorizontalSide() sides};\n+     *                    otherwise <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -104,0 +113,1 @@\n+     *\n@@ -105,0 +115,4 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> if one\n+     *                    value is absolute and the other is a {@link #isVerticalAsPercentage() percentage},\n+     *                    or if the background is anchored at different {@link #getVerticalSide() sides};\n+     *                    otherwise <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -112,0 +126,1 @@\n+     *\n@@ -113,0 +128,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -120,0 +136,1 @@\n+     *\n@@ -121,0 +138,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -178,0 +196,77 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public BackgroundPosition interpolate(BackgroundPosition endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        double newHorizontalPosition, newVerticalPosition;\n+        boolean newHorizontalAsPercentage, newVerticalAsPercentage;\n+        Side newHorizontalSide, newVerticalSide;\n+\n+        if (this.horizontalSide == endValue.horizontalSide\n+                && this.horizontalAsPercentage == endValue.horizontalAsPercentage) {\n+            newHorizontalPosition = InterpolationUtils.interpolate(this.horizontalPosition, endValue.horizontalPosition, t);\n+            newHorizontalAsPercentage = this.horizontalAsPercentage;\n+            newHorizontalSide = this.horizontalSide;\n+        } else if (t < 0.5) {\n+            newHorizontalPosition = this.horizontalPosition;\n+            newHorizontalAsPercentage = this.horizontalAsPercentage;\n+            newHorizontalSide = this.horizontalSide;\n+        } else {\n+            newHorizontalPosition = endValue.horizontalPosition;\n+            newHorizontalAsPercentage = endValue.horizontalAsPercentage;\n+            newHorizontalSide = endValue.horizontalSide;\n+        }\n+\n+        if (this.verticalSide == endValue.verticalSide\n+                && this.verticalAsPercentage == endValue.verticalAsPercentage) {\n+            newVerticalPosition = InterpolationUtils.interpolate(this.verticalPosition, endValue.verticalPosition, t);\n+            newVerticalAsPercentage = this.verticalAsPercentage;\n+            newVerticalSide = this.verticalSide;\n+        } else if (t < 0.5) {\n+            newVerticalPosition = this.verticalPosition;\n+            newVerticalAsPercentage = this.verticalAsPercentage;\n+            newVerticalSide = this.verticalSide;\n+        } else {\n+            newVerticalPosition = endValue.verticalPosition;\n+            newVerticalAsPercentage = endValue.verticalAsPercentage;\n+            newVerticalSide = endValue.verticalSide;\n+        }\n+\n+        if (isSame(newHorizontalSide, newHorizontalPosition, newHorizontalAsPercentage,\n+                   newVerticalSide, newVerticalPosition, newVerticalAsPercentage)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newHorizontalSide, newHorizontalPosition, newHorizontalAsPercentage,\n+                            newVerticalSide, newVerticalPosition, newVerticalAsPercentage)) {\n+            return endValue;\n+        }\n+\n+        return new BackgroundPosition(\n+            newHorizontalSide, newHorizontalPosition, newHorizontalAsPercentage,\n+            newVerticalSide, newVerticalPosition, newVerticalAsPercentage);\n+    }\n+\n+    private boolean isSame(Side horizontalSide, double horizontalPosition, boolean horizontalAsPercentage,\n+                           Side verticalSide, double verticalPosition, boolean verticalAsPercentage) {\n+        return this.horizontalSide == horizontalSide\n+            && this.horizontalPosition == horizontalPosition\n+            && this.horizontalAsPercentage == horizontalAsPercentage\n+            && this.verticalSide == verticalSide\n+            && this.verticalPosition == verticalPosition\n+            && this.verticalAsPercentage == verticalAsPercentage;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundPosition.java","additions":101,"deletions":6,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.InterpolationUtils;\n+import javafx.animation.Interpolatable;\n@@ -29,0 +31,1 @@\n+import java.util.Objects;\n@@ -57,1 +60,1 @@\n-public final class BackgroundSize {\n+public final class BackgroundSize implements Interpolatable<BackgroundSize> {\n@@ -85,0 +88,1 @@\n+     *\n@@ -86,1 +90,6 @@\n-     * BackgroundImage should render\n+     *         BackgroundImage should render\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n+     *                    if {@link #isCover() cover} or {@link #isContain() contain} is set, if one value\n+     *                    is absolute and the other value is a {@link #isWidthAsPercentage() percentage},\n+     *                    or if the width is {@link #AUTO}; otherwise\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -96,0 +105,1 @@\n+     *\n@@ -97,1 +107,6 @@\n-     * BackgroundImage should render\n+     *         BackgroundImage should render\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n+     *                    if {@link #isCover() cover} or {@link #isContain() contain} is set, if one value\n+     *                    is absolute and the other value is a {@link #isHeightAsPercentage() percentage},\n+     *                    or if the height is {@link #AUTO}; otherwise\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -105,0 +120,1 @@\n+     *\n@@ -106,0 +122,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -113,0 +130,1 @@\n+     *\n@@ -114,0 +132,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -122,0 +141,1 @@\n+     *\n@@ -123,0 +143,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -131,0 +152,1 @@\n+     *\n@@ -132,0 +154,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -183,0 +206,64 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public BackgroundSize interpolate(BackgroundSize endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        if (cover || contain || endValue.cover || endValue.contain) {\n+            return t < 0.5 ? this : endValue;\n+        }\n+\n+        double newWidth = interpolate(\n+            this.width, endValue.width, this.widthAsPercentage, endValue.widthAsPercentage, t);\n+\n+        double newHeight = interpolate(\n+            this.height, endValue.height, this.heightAsPercentage, endValue.heightAsPercentage, t);\n+\n+        boolean newWidthAsPercentage, newHeightAsPercentage;\n+\n+        if (t < 0.5) {\n+            newWidthAsPercentage = this.widthAsPercentage;\n+            newHeightAsPercentage = this.heightAsPercentage;\n+        } else {\n+            newWidthAsPercentage = endValue.widthAsPercentage;\n+            newHeightAsPercentage = endValue.heightAsPercentage;\n+        }\n+\n+        if (isSame(newWidth, newHeight, newWidthAsPercentage, newHeightAsPercentage)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newWidth, newHeight, newWidthAsPercentage, newHeightAsPercentage)) {\n+            return endValue;\n+        }\n+\n+        return new BackgroundSize(newWidth, newHeight, newWidthAsPercentage, newHeightAsPercentage, false, false);\n+    }\n+\n+    private boolean isSame(double width, double height, boolean widthAsPercentage, boolean heightAsPercentage) {\n+        return this.width == width\n+            && this.height == height\n+            && this.widthAsPercentage == widthAsPercentage\n+            && this.heightAsPercentage == heightAsPercentage;\n+    }\n+\n+    private static double interpolate(double start, double end,\n+                                      boolean startIsPercentage, boolean endIsPercentage,\n+                                      double t) {\n+        return startIsPercentage == endIsPercentage && start != AUTO && end != AUTO ?\n+            InterpolationUtils.interpolate(start, end, t) :\n+            InterpolationUtils.interpolateDiscrete(start, end, t);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundSize.java","additions":91,"deletions":4,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,2 @@\n-\n+import java.util.Objects;\n+import javafx.animation.Interpolatable;\n@@ -37,1 +38,0 @@\n-import javafx.css.CssMetaData;\n@@ -39,0 +39,2 @@\n+import javafx.css.CssMetaData;\n+import javafx.css.Styleable;\n@@ -50,1 +52,1 @@\n-import javafx.css.Styleable;\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -90,1 +92,1 @@\n-public final class Border {\n+public final class Border implements Interpolatable<Border> {\n@@ -168,2 +170,3 @@\n-     * @return the list of BorderStrokes which together define the stroked\n-     * portion of this Border\n+     *\n+     * @return the list of BorderStrokes which together define the stroked portion of this Border\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#pairwise\">pairwise<\/a>\n@@ -183,0 +186,1 @@\n+     *\n@@ -184,1 +188,2 @@\n-     * instead of stroke for this Border\n+     *         instead of stroke for this Border\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#pairwise\">pairwise<\/a>\n@@ -280,2 +285,2 @@\n-        this(strokes == null ? null : strokes.toArray(new BorderStroke[strokes.size()]),\n-             images == null ? null : images.toArray(new BorderImage[images.size()]));\n+        this(strokes != null ? UnmodifiableArrayList.copyOfNullFiltered(strokes) : List.of(),\n+             images != null ? UnmodifiableArrayList.copyOfNullFiltered(images) : List.of(), 0);\n@@ -303,0 +308,18 @@\n+        this(strokes != null ? UnmodifiableArrayList.copyOfNullFiltered(strokes) : List.of(),\n+             images != null ? UnmodifiableArrayList.copyOfNullFiltered(images) : List.of(), 0);\n+    }\n+\n+    \/**\n+     * Creates a new Border with the specified strokes and images.\n+     * This constructor requires that both lists do not contain null values, and that the lists\n+     * are immutable. The purpose of this constructor is to prevent an unnecessary array creation\n+     * when the caller already knows that the specified lists satisfy the non-null precondition\n+     * and preserve the immutability invariant.\n+     *\n+     * @param strokes the strokes, not {@code null}\n+     * @param images the images, not {@code null}\n+     *\/\n+    private Border(List<BorderStroke> strokes, List<BorderImage> images, int ignored) {\n+        Objects.requireNonNull(strokes, \"strokes cannot be null\");\n+        Objects.requireNonNull(images, \"images cannot be null\");\n+\n@@ -306,36 +329,26 @@\n-        if (strokes == null || strokes.length == 0) {\n-            this.strokes = Collections.emptyList();\n-        } else {\n-            final BorderStroke[] noNulls = new BorderStroke[strokes.length];\n-            int size = 0;\n-            for (int i=0; i<strokes.length; i++) {\n-                final BorderStroke stroke = strokes[i];\n-                if (stroke != null) {\n-                    noNulls[size++] = stroke;\n-\n-                    \/\/ Calculate the insets and outsets. \"insets\" are the distance\n-                    \/\/ from the edge of the region to the inmost edge of the inmost border.\n-                    \/\/ Outsets are the distance from the edge of the region out towards the\n-                    \/\/ outer-most edge of the outer-most border.\n-                    final double strokeInnerTop = stroke.innerEdge.getTop();\n-                    final double strokeInnerRight = stroke.innerEdge.getRight();\n-                    final double strokeInnerBottom = stroke.innerEdge.getBottom();\n-                    final double strokeInnerLeft = stroke.innerEdge.getLeft();\n-\n-                    innerTop = innerTop >= strokeInnerTop ? innerTop : strokeInnerTop;\n-                    innerRight = innerRight >= strokeInnerRight? innerRight : strokeInnerRight;\n-                    innerBottom = innerBottom >= strokeInnerBottom ? innerBottom : strokeInnerBottom;\n-                    innerLeft = innerLeft >= strokeInnerLeft ? innerLeft : strokeInnerLeft;\n-\n-                    final double strokeOuterTop = stroke.outerEdge.getTop();\n-                    final double strokeOuterRight = stroke.outerEdge.getRight();\n-                    final double strokeOuterBottom = stroke.outerEdge.getBottom();\n-                    final double strokeOuterLeft = stroke.outerEdge.getLeft();\n-\n-                    outerTop = outerTop >= strokeOuterTop ? outerTop : strokeOuterTop;\n-                    outerRight = outerRight >= strokeOuterRight? outerRight : strokeOuterRight;\n-                    outerBottom = outerBottom >= strokeOuterBottom ? outerBottom : strokeOuterBottom;\n-                    outerLeft = outerLeft >= strokeOuterLeft ? outerLeft : strokeOuterLeft;\n-                }\n-            }\n-            this.strokes = new UnmodifiableArrayList<>(noNulls, size);\n+        for (int i = 0, max = strokes.size(); i < max; i++) {\n+            final BorderStroke stroke = strokes.get(i);\n+\n+            \/\/ Calculate the insets and outsets. \"insets\" are the distance\n+            \/\/ from the edge of the region to the inmost edge of the inmost border.\n+            \/\/ Outsets are the distance from the edge of the region out towards the\n+            \/\/ outer-most edge of the outer-most border.\n+            final double strokeInnerTop = stroke.innerEdge.getTop();\n+            final double strokeInnerRight = stroke.innerEdge.getRight();\n+            final double strokeInnerBottom = stroke.innerEdge.getBottom();\n+            final double strokeInnerLeft = stroke.innerEdge.getLeft();\n+\n+            innerTop = innerTop >= strokeInnerTop ? innerTop : strokeInnerTop;\n+            innerRight = innerRight >= strokeInnerRight? innerRight : strokeInnerRight;\n+            innerBottom = innerBottom >= strokeInnerBottom ? innerBottom : strokeInnerBottom;\n+            innerLeft = innerLeft >= strokeInnerLeft ? innerLeft : strokeInnerLeft;\n+\n+            final double strokeOuterTop = stroke.outerEdge.getTop();\n+            final double strokeOuterRight = stroke.outerEdge.getRight();\n+            final double strokeOuterBottom = stroke.outerEdge.getBottom();\n+            final double strokeOuterLeft = stroke.outerEdge.getLeft();\n+\n+            outerTop = outerTop >= strokeOuterTop ? outerTop : strokeOuterTop;\n+            outerRight = outerRight >= strokeOuterRight? outerRight : strokeOuterRight;\n+            outerBottom = outerBottom >= strokeOuterBottom ? outerBottom : strokeOuterBottom;\n+            outerLeft = outerLeft >= strokeOuterLeft ? outerLeft : strokeOuterLeft;\n@@ -344,34 +357,26 @@\n-        if (images == null || images.length == 0) {\n-            this.images = Collections.emptyList();\n-        } else {\n-            final BorderImage[] noNulls = new BorderImage[images.length];\n-            int size = 0;\n-            for (int i=0; i<images.length; i++) {\n-                final BorderImage image = images[i];\n-                if (image != null){\n-                    noNulls[size++] = image;\n-\n-                    \/\/ The Image width + insets may contribute to the insets \/ outsets of\n-                    \/\/ this border.\n-                    final double imageInnerTop = image.innerEdge.getTop();\n-                    final double imageInnerRight = image.innerEdge.getRight();\n-                    final double imageInnerBottom = image.innerEdge.getBottom();\n-                    final double imageInnerLeft = image.innerEdge.getLeft();\n-\n-                    innerTop = innerTop >= imageInnerTop ? innerTop : imageInnerTop;\n-                    innerRight = innerRight >= imageInnerRight? innerRight : imageInnerRight;\n-                    innerBottom = innerBottom >= imageInnerBottom ? innerBottom : imageInnerBottom;\n-                    innerLeft = innerLeft >= imageInnerLeft ? innerLeft : imageInnerLeft;\n-\n-                    final double imageOuterTop = image.outerEdge.getTop();\n-                    final double imageOuterRight = image.outerEdge.getRight();\n-                    final double imageOuterBottom = image.outerEdge.getBottom();\n-                    final double imageOuterLeft = image.outerEdge.getLeft();\n-\n-                    outerTop = outerTop >= imageOuterTop ? outerTop : imageOuterTop;\n-                    outerRight = outerRight >= imageOuterRight? outerRight : imageOuterRight;\n-                    outerBottom = outerBottom >= imageOuterBottom ? outerBottom : imageOuterBottom;\n-                    outerLeft = outerLeft >= imageOuterLeft ? outerLeft : imageOuterLeft;\n-                }\n-            }\n-            this.images = new UnmodifiableArrayList<>(noNulls, size);\n+        this.strokes = strokes;\n+\n+        for (int i = 0, max = images.size(); i < max; i++) {\n+            final BorderImage image = images.get(i);\n+\n+            \/\/ The Image width + insets may contribute to the insets \/ outsets of\n+            \/\/ this border.\n+            final double imageInnerTop = image.innerEdge.getTop();\n+            final double imageInnerRight = image.innerEdge.getRight();\n+            final double imageInnerBottom = image.innerEdge.getBottom();\n+            final double imageInnerLeft = image.innerEdge.getLeft();\n+\n+            innerTop = innerTop >= imageInnerTop ? innerTop : imageInnerTop;\n+            innerRight = innerRight >= imageInnerRight? innerRight : imageInnerRight;\n+            innerBottom = innerBottom >= imageInnerBottom ? innerBottom : imageInnerBottom;\n+            innerLeft = innerLeft >= imageInnerLeft ? innerLeft : imageInnerLeft;\n+\n+            final double imageOuterTop = image.outerEdge.getTop();\n+            final double imageOuterRight = image.outerEdge.getRight();\n+            final double imageOuterBottom = image.outerEdge.getBottom();\n+            final double imageOuterLeft = image.outerEdge.getLeft();\n+\n+            outerTop = outerTop >= imageOuterTop ? outerTop : imageOuterTop;\n+            outerRight = outerRight >= imageOuterRight? outerRight : imageOuterRight;\n+            outerBottom = outerBottom >= imageOuterBottom ? outerBottom : imageOuterBottom;\n+            outerLeft = outerLeft >= imageOuterLeft ? outerLeft : imageOuterLeft;\n@@ -380,0 +385,2 @@\n+        this.images = images;\n+\n@@ -408,0 +415,39 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public Border interpolate(Border endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        \/\/ interpolateListsPairwise() is implemented such that it returns existing list instances\n+        \/\/ (i.e. the 'this.images' or 'endValue.images' arguments) as an indication that the result\n+        \/\/ is shallow-equal to either of the input arguments. This allows us to very quickly detect\n+        \/\/ if we can return 'this' or 'endValue' without allocating a new Border instance.\n+        List<BorderImage> newImages = images == endValue.images ?\n+            images : InterpolationUtils.interpolateListsPairwise(images, endValue.images, t);\n+\n+        List<BorderStroke> newStrokes = strokes == endValue.strokes ?\n+            strokes : InterpolationUtils.interpolateListsPairwise(strokes, endValue.strokes, t);\n+\n+        if (images == newImages && strokes == newStrokes) {\n+            return this;\n+        }\n+\n+        if (endValue.images == newImages && endValue.strokes == newStrokes) {\n+            return endValue;\n+        }\n+\n+        return new Border(newStrokes, newImages);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Border.java","additions":126,"deletions":80,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.javafx.css.SubPropertyConverter;\n@@ -32,0 +33,1 @@\n+import java.util.List;\n@@ -43,0 +45,1 @@\n+ * Converts -fx-border components into a {@link Border}.\n@@ -44,1 +47,2 @@\n-class BorderConverter extends StyleConverter<ParsedValue[], Border> {\n+class BorderConverter extends StyleConverter<ParsedValue[], Border>\n+                      implements SubPropertyConverter<Border> {\n@@ -56,0 +60,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException if {@code convertedValues} is {@code null}\n+     *\/\n@@ -60,1 +69,1 @@\n-        final String[] imageUrls = (String[]) convertedValues.get(Border.BORDER_IMAGE_SOURCE);\n+        final Object[] images = (Object[]) convertedValues.get(Border.BORDER_IMAGE_SOURCE);\n@@ -73,1 +82,1 @@\n-        final boolean hasImages = imageUrls != null && imageUrls.length > 0;\n+        final boolean hasImages = images != null && images.length > 0;\n@@ -148,1 +157,1 @@\n-            borderImages = new BorderImage[imageUrls.length];\n+            borderImages = new BorderImage[images.length];\n@@ -165,2 +174,2 @@\n-            for (int i=0; i<imageUrls.length; i++) {\n-                if (imageUrls[i] == null) continue;\n+            for (int i=0; i<images.length; i++) {\n+                if (images[i] == null) continue;\n@@ -170,12 +179,2 @@\n-                    switch (repeat.repeatX) {\n-                        case SPACE: repeatX = BorderRepeat.SPACE; break;\n-                        case ROUND: repeatX = BorderRepeat.ROUND; break;\n-                        case REPEAT: repeatX = BorderRepeat.REPEAT; break;\n-                        case NO_REPEAT: repeatX = BorderRepeat.STRETCH; break;\n-                    }\n-                    switch (repeat.repeatY) {\n-                        case SPACE: repeatY = BorderRepeat.SPACE; break;\n-                        case ROUND: repeatY = BorderRepeat.ROUND; break;\n-                        case REPEAT: repeatY = BorderRepeat.REPEAT; break;\n-                        case NO_REPEAT: repeatY = BorderRepeat.STRETCH; break;\n-                    }\n+                    repeatX = convertToBorderRepeat(repeat.repeatX);\n+                    repeatY = convertToBorderRepeat(repeat.repeatY);\n@@ -187,2 +186,13 @@\n-                final Image img = StyleManager.getInstance().getCachedImage(imageUrls[i]);\n-                borderImages[i] = new BorderImage(img, width, inset, slice.widths, slice.filled, repeatX, repeatY);\n+                final Image image;\n+\n+                \/\/ The images are either URLs (when they come from CSS) or the actual Image\n+                \/\/ instances (when they come from the convertBack operation).\n+                if (images[i] instanceof String url) {\n+                    image = StyleManager.getInstance().getCachedImage(url);\n+                } else if (images[i] instanceof Image img) {\n+                    image = img;\n+                } else {\n+                    throw new IllegalArgumentException(\"Unexpected type: \" + images[i].getClass().getName());\n+                }\n+\n+                borderImages[i] = new BorderImage(image, width, inset, slice.widths, slice.filled, repeatX, repeatY);\n@@ -195,0 +205,86 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException if {@code border} is {@code null}\n+     *\/\n+    @Override\n+    public Map<CssMetaData<? extends Styleable, ?>, Object> convertBack(Border border) {\n+        List<BorderStroke> strokes = border.getStrokes();\n+        int strokesCount = strokes.size();\n+        Paint[][] borderStrokeFills = new Paint[strokesCount][];\n+        BorderStrokeStyle[][] borderStrokeStyles = new BorderStrokeStyle[strokesCount][];\n+        Margins[] borderWidths = new Margins[strokesCount];\n+        CornerRadii[] borderRadius = new CornerRadii[strokesCount];\n+        Insets[] borderInsets = new Insets[strokesCount];\n+\n+        for (int i = 0; i < strokesCount; ++i) {\n+            BorderStroke stroke = strokes.get(i);\n+            borderStrokeFills[i] = new Paint[4];\n+            borderStrokeFills[i][0] = stroke.getTopStroke();\n+            borderStrokeFills[i][1] = stroke.getRightStroke();\n+            borderStrokeFills[i][2] = stroke.getBottomStroke();\n+            borderStrokeFills[i][3] = stroke.getLeftStroke();\n+\n+            borderStrokeStyles[i] = new BorderStrokeStyle[4];\n+            borderStrokeStyles[i][0] = stroke.getTopStyle();\n+            borderStrokeStyles[i][1] = stroke.getRightStyle();\n+            borderStrokeStyles[i][2] = stroke.getBottomStyle();\n+            borderStrokeStyles[i][3] = stroke.getLeftStyle();\n+\n+            BorderWidths widths = stroke.getWidths();\n+            borderWidths[i] = new Margins(widths.getTop(), widths.getRight(), widths.getBottom(), widths.getLeft(), false);\n+\n+            borderRadius[i] = stroke.getRadii();\n+            borderInsets[i] = stroke.getInsets();\n+        }\n+\n+        List<BorderImage> borderImages = border.getImages();\n+        int imagesCount = borderImages.size();\n+        Image[] images = new Image[imagesCount];\n+        RepeatStruct[] imageRepeats = new RepeatStruct[imagesCount];\n+        BorderImageSlices[] imageSlices = new BorderImageSlices[imagesCount];\n+        BorderWidths[] imageWidths = new BorderWidths[imagesCount];\n+        Insets[] imageInsets = new Insets[imagesCount];\n+\n+        for (int i = 0; i < imagesCount; ++i) {\n+            BorderImage image = borderImages.get(i);\n+            images[i] = image.getImage();\n+            imageRepeats[i] = new RepeatStruct(\n+                convertToBackgroundRepeat(image.getRepeatX()),\n+                convertToBackgroundRepeat(image.getRepeatY()));\n+            imageSlices[i] = new BorderImageSlices(image.getSlices(), image.isFilled());\n+            imageWidths[i] = image.getWidths();\n+            imageInsets[i] = image.getInsets();\n+        }\n+\n+        return Map.of(\n+            Border.BORDER_COLOR, borderStrokeFills,\n+            Border.BORDER_STYLE, borderStrokeStyles,\n+            Border.BORDER_WIDTH, borderWidths,\n+            Border.BORDER_RADIUS, borderRadius,\n+            Border.BORDER_INSETS, borderInsets,\n+            Border.BORDER_IMAGE_SOURCE, images,\n+            Border.BORDER_IMAGE_REPEAT, imageRepeats,\n+            Border.BORDER_IMAGE_SLICE, imageSlices,\n+            Border.BORDER_IMAGE_WIDTH, imageWidths,\n+            Border.BORDER_IMAGE_INSETS, imageInsets);\n+    }\n+\n+    private BackgroundRepeat convertToBackgroundRepeat(BorderRepeat repeat) {\n+        return switch (repeat) {\n+            case REPEAT -> BackgroundRepeat.REPEAT;\n+            case ROUND -> BackgroundRepeat.ROUND;\n+            case SPACE -> BackgroundRepeat.SPACE;\n+            case STRETCH -> BackgroundRepeat.NO_REPEAT;\n+        };\n+    }\n+\n+    private BorderRepeat convertToBorderRepeat(BackgroundRepeat repeat) {\n+        return switch (repeat) {\n+            case REPEAT -> BorderRepeat.REPEAT;\n+            case ROUND -> BorderRepeat.ROUND;\n+            case SPACE -> BorderRepeat.SPACE;\n+            case NO_REPEAT -> BorderRepeat.STRETCH;\n+        };\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BorderConverter.java","additions":117,"deletions":21,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javafx.animation.Interpolatable;\n@@ -32,0 +33,1 @@\n+import java.util.Objects;\n@@ -51,1 +53,1 @@\n-public class BorderImage {\n+public class BorderImage implements Interpolatable<BorderImage> {\n@@ -57,0 +59,1 @@\n+     *\n@@ -58,0 +61,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -66,0 +70,1 @@\n+     *\n@@ -67,1 +72,2 @@\n-     * is to be repeated along the x-axis of the region\n+     *         is to be repeated along the x-axis of the region\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -76,0 +82,1 @@\n+     *\n@@ -77,1 +84,2 @@\n-     * is to be repeated along the y-axis of the region\n+     *         is to be repeated along the y-axis of the region\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -87,0 +95,1 @@\n+     *\n@@ -88,0 +97,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -106,0 +116,1 @@\n+     *\n@@ -107,0 +118,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -115,0 +127,1 @@\n+     *\n@@ -116,0 +129,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -123,0 +137,1 @@\n+     *\n@@ -124,0 +139,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -189,0 +205,64 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public BorderImage interpolate(BorderImage endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        \/\/ BorderWidths and Insets are implemented such that interpolate() always returns the existing\n+        \/\/ instance if the intermediate value is equal to the start value or the end value, which allows\n+        \/\/ us to use an identity comparison in place of a value comparison to determine equality.\n+        BorderWidths newWidths = widths.interpolate(endValue.widths, t);\n+        BorderWidths newSlices = slices.interpolate(endValue.slices, t);\n+        Insets newInsets = insets.interpolate(endValue.insets, t);\n+        Image newImage;\n+        BorderRepeat newRepeatX, newRepeatY;\n+        boolean newFilled;\n+\n+        if (t < 0.5) {\n+            newImage = this.image;\n+            newRepeatX = this.repeatX;\n+            newRepeatY = this.repeatY;\n+            newFilled = this.filled;\n+        } else {\n+            newImage = endValue.image;\n+            newRepeatX = endValue.repeatX;\n+            newRepeatY = endValue.repeatY;\n+            newFilled = endValue.filled;\n+        }\n+\n+        if (isSame(newImage, newWidths, newSlices, newFilled, newRepeatX, newRepeatY)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newImage, newWidths, newSlices, newFilled, newRepeatX, newRepeatY)) {\n+            return endValue;\n+        }\n+\n+        return new BorderImage(endValue.image, newWidths, newInsets, newSlices,\n+                               endValue.filled, endValue.repeatX, endValue.repeatY);\n+    }\n+\n+    private boolean isSame(Image image, BorderWidths widths, BorderWidths slices, boolean filled,\n+                           BorderRepeat repeatX, BorderRepeat repeatY) {\n+        return this.image == image\n+            && this.widths == widths\n+            && this.slices == slices\n+            && this.filled == filled\n+            && this.repeatX == repeatX\n+            && this.repeatY == repeatY;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BorderImage.java","additions":84,"deletions":4,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.InterpolationUtils;\n+import javafx.animation.Interpolatable;\n@@ -33,0 +35,1 @@\n+import java.util.Objects;\n@@ -48,1 +51,1 @@\n-public class BorderStroke {\n+public class BorderStroke implements Interpolatable<BorderStroke> {\n@@ -75,0 +78,1 @@\n+     * @interpolationType see {@link Paint}\n@@ -88,0 +92,1 @@\n+     * @interpolationType see {@link Paint}\n@@ -98,0 +103,1 @@\n+     * @interpolationType see {@link Paint}\n@@ -108,0 +114,1 @@\n+     * @interpolationType see {@link Paint}\n@@ -117,0 +124,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -127,0 +135,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -138,0 +147,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -149,0 +159,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -156,0 +167,1 @@\n+     *\n@@ -157,0 +169,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -164,0 +177,1 @@\n+     *\n@@ -165,0 +179,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -176,0 +191,1 @@\n+     *\n@@ -177,0 +193,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -361,0 +378,78 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public BorderStroke interpolate(BorderStroke endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        \/\/ CornerRadii, BorderWidths, Insets and Paint are implemented such that interpolate() always returns\n+        \/\/ the existing instance if the intermediate value is equal to the start value or the end value,\n+        \/\/ which allows us to use an identity comparison in place of a value comparison to determine equality.\n+        CornerRadii newRadii = this.radii.interpolate(endValue.radii, t);\n+        BorderWidths newWidths = this.widths.interpolate(endValue.widths, t);\n+        Insets newInsets = this.insets.interpolate(endValue.insets, t);\n+        Paint newTopStroke = InterpolationUtils.interpolatePaint(this.topStroke, endValue.topStroke, t);\n+        Paint newRightStroke = InterpolationUtils.interpolatePaint(this.rightStroke, endValue.rightStroke, t);\n+        Paint newBottomStroke = InterpolationUtils.interpolatePaint(this.bottomStroke, endValue.bottomStroke, t);\n+        Paint newLeftStroke = InterpolationUtils.interpolatePaint(this.leftStroke, endValue.leftStroke, t);\n+        BorderStrokeStyle newTopStyle, newRightStyle, newBottomStyle, newLeftStyle;\n+\n+        if (t < 0.5) {\n+            newTopStyle = this.topStyle;\n+            newRightStyle = this.rightStyle;\n+            newBottomStyle = this.bottomStyle;\n+            newLeftStyle = this.leftStyle;\n+        } else {\n+            newTopStyle = endValue.topStyle;\n+            newRightStyle = endValue.rightStyle;\n+            newBottomStyle = endValue.bottomStyle;\n+            newLeftStyle = endValue.leftStyle;\n+        }\n+\n+        if (isSame(newTopStroke, newRightStroke, newBottomStroke, newLeftStroke,\n+                   newTopStyle, newRightStyle, newBottomStyle, newLeftStyle,\n+                   newRadii, newWidths, newInsets)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newTopStroke, newRightStroke, newBottomStroke, newLeftStroke,\n+                            newTopStyle, newRightStyle, newBottomStyle, newLeftStyle,\n+                            newRadii, newWidths, newInsets)) {\n+            return endValue;\n+        }\n+\n+        return new BorderStroke(newTopStroke, newRightStroke, newBottomStroke, newLeftStroke,\n+                                newTopStyle, newRightStyle, newBottomStyle, newLeftStyle,\n+                                newRadii, newWidths, newInsets);\n+    }\n+\n+    private boolean isSame(Paint topStroke, Paint rightStroke, Paint bottomStroke, Paint leftStroke,\n+                           BorderStrokeStyle topStyle, BorderStrokeStyle rightStyle,\n+                           BorderStrokeStyle bottomStyle, BorderStrokeStyle leftStyle,\n+                           CornerRadii radii, BorderWidths widths, Insets insets) {\n+        return this.topStroke == topStroke\n+            && this.rightStroke == rightStroke\n+            && this.bottomStroke == bottomStroke\n+            && this.leftStroke == leftStroke\n+            && this.topStyle == topStyle\n+            && this.rightStyle == rightStyle\n+            && this.bottomStyle == bottomStyle\n+            && this.leftStyle == leftStyle\n+            && this.radii == radii\n+            && this.widths == widths\n+            && this.insets == insets;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BorderStroke.java","additions":97,"deletions":2,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.InterpolationUtils;\n+import javafx.animation.Interpolatable;\n@@ -29,1 +31,1 @@\n-\n+import java.util.Objects;\n@@ -44,1 +46,1 @@\n-public final class BorderWidths {\n+public final class BorderWidths implements Interpolatable<BorderWidths> {\n@@ -75,0 +77,1 @@\n+     *\n@@ -76,0 +79,4 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isTopAsPercentage() percentages}, and both\n+     *                    values are not the special value {@link #AUTO};\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -85,0 +92,1 @@\n+     *\n@@ -86,0 +94,4 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isRightAsPercentage() percentages}, and both\n+     *                    values are not the special value {@link #AUTO};\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -95,0 +107,1 @@\n+     *\n@@ -96,0 +109,4 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isBottomAsPercentage() percentages}, and both\n+     *                    values are not the special value {@link #AUTO};\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -105,0 +122,1 @@\n+     *\n@@ -106,0 +124,4 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isLeftAsPercentage() percentages}, and both\n+     *                    values are not the special value {@link #AUTO};\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -113,0 +135,1 @@\n+     *\n@@ -114,0 +137,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -121,0 +145,1 @@\n+     *\n@@ -122,0 +147,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -129,0 +155,1 @@\n+     *\n@@ -130,0 +157,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -137,0 +165,1 @@\n+     *\n@@ -138,0 +167,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -226,0 +256,101 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public BorderWidths interpolate(BorderWidths endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0 || equals(endValue)) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        double newTop, newRight, newBottom, newLeft;\n+        boolean newTopAsPercentage, newRightAsPercentage, newBottomAsPercentage, newLeftAsPercentage;\n+\n+        if (this.topAsPercentage == endValue.topAsPercentage) {\n+            newTop = interpolate(this.top, endValue.top, t);\n+            newTopAsPercentage = this.topAsPercentage;\n+        } else if (t < 0.5) {\n+            newTop = this.top;\n+            newTopAsPercentage = this.topAsPercentage;\n+        } else {\n+            newTop = endValue.top;\n+            newTopAsPercentage = endValue.topAsPercentage;\n+        }\n+\n+        if (this.rightAsPercentage == endValue.rightAsPercentage) {\n+            newRight = interpolate(this.right, endValue.right, t);\n+            newRightAsPercentage = this.rightAsPercentage;\n+        } else if (t < 0.5) {\n+            newRight = this.right;\n+            newRightAsPercentage = this.rightAsPercentage;\n+        } else {\n+            newRight = endValue.right;\n+            newRightAsPercentage = endValue.rightAsPercentage;\n+        }\n+\n+        if (this.bottomAsPercentage == endValue.bottomAsPercentage) {\n+            newBottom = interpolate(this.bottom, endValue.bottom, t);\n+            newBottomAsPercentage = this.bottomAsPercentage;\n+        } else if (t < 0.5) {\n+            newBottom = this.bottom;\n+            newBottomAsPercentage = this.bottomAsPercentage;\n+        } else {\n+            newBottom = endValue.bottom;\n+            newBottomAsPercentage = endValue.bottomAsPercentage;\n+        }\n+\n+        if (this.leftAsPercentage == endValue.leftAsPercentage) {\n+            newLeft = interpolate(this.left, endValue.left, t);\n+            newLeftAsPercentage = this.leftAsPercentage;\n+        } else if (t < 0.5) {\n+            newLeft = this.left;\n+            newLeftAsPercentage = this.leftAsPercentage;\n+        } else {\n+            newLeft = endValue.left;\n+            newLeftAsPercentage = endValue.leftAsPercentage;\n+        }\n+\n+        if (isSame(newTop, newRight, newBottom, newLeft,\n+                   newTopAsPercentage, newRightAsPercentage,\n+                   newBottomAsPercentage, newLeftAsPercentage)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newTop, newRight, newBottom, newLeft,\n+                            newTopAsPercentage, newRightAsPercentage,\n+                            newBottomAsPercentage, newLeftAsPercentage)) {\n+            return endValue;\n+        }\n+\n+        return new BorderWidths(\n+            newTop, newRight, newBottom, newLeft,\n+            newTopAsPercentage, newRightAsPercentage, newBottomAsPercentage, newLeftAsPercentage);\n+    }\n+\n+    private static double interpolate(double start, double end, double t) {\n+        return start != AUTO && end != AUTO ?\n+            InterpolationUtils.interpolate(start, end, t) :\n+            InterpolationUtils.interpolateDiscrete(start, end, t);\n+    }\n+\n+    private boolean isSame(double top, double right, double bottom, double left,\n+                           boolean topAsPercentage, boolean rightAsPercentage,\n+                           boolean bottomAsPercentage, boolean leftAsPercentage) {\n+        return this.top == top\n+            && this.right == right\n+            && this.bottom == bottom\n+            && this.left == left\n+            && this.topAsPercentage == topAsPercentage\n+            && this.rightAsPercentage == rightAsPercentage\n+            && this.bottomAsPercentage == bottomAsPercentage\n+            && this.leftAsPercentage == leftAsPercentage;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BorderWidths.java","additions":134,"deletions":3,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.InterpolationUtils;\n+import javafx.animation.Interpolatable;\n@@ -29,1 +31,1 @@\n-\n+import java.util.Objects;\n@@ -40,1 +42,1 @@\n-public class CornerRadii {\n+public class CornerRadii implements Interpolatable<CornerRadii> {\n@@ -52,0 +54,1 @@\n+     *\n@@ -53,0 +56,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isTopLeftHorizontalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -59,0 +65,1 @@\n+     *\n@@ -60,0 +67,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isTopLeftVerticalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -66,0 +76,1 @@\n+     *\n@@ -67,0 +78,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isTopRightVerticalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -73,0 +87,1 @@\n+     *\n@@ -74,0 +89,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isTopRightHorizontalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -80,0 +98,1 @@\n+     *\n@@ -81,0 +100,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isBottomRightHorizontalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -87,0 +109,1 @@\n+     *\n@@ -88,0 +111,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isBottomRightVerticalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -94,0 +120,1 @@\n+     *\n@@ -95,0 +122,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isBottomLeftVerticalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -101,0 +131,1 @@\n+     *\n@@ -102,0 +133,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isBottomLeftHorizontalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -107,1 +141,2 @@\n-     * indicates whether {@code topLeftHorizontalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code topLeftHorizontalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -109,0 +144,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -114,1 +150,2 @@\n-     * indicates whether {@code topLeftVerticalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code topLeftVerticalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -116,0 +153,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -121,1 +159,2 @@\n-     * indicates whether {@code topRightVerticalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code topRightVerticalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -123,0 +162,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -128,1 +168,2 @@\n-     * indicates whether {@code topRightHorizontalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code topRightHorizontalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -130,0 +171,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -135,1 +177,2 @@\n-     * indicates whether {@code bottomRightHorizontalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code bottomRightHorizontalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -137,0 +180,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -142,1 +186,2 @@\n-     * indicates whether {@code bottomRightVerticalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code bottomRightVerticalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -144,0 +189,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -149,1 +195,2 @@\n-     * indicates whether {@code bottomLeftVerticalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code bottomLeftVerticalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -151,0 +198,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -156,1 +204,2 @@\n-     * indicates whether {@code bottomLeftHorizontalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code bottomLeftHorizontalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -158,0 +207,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -362,0 +412,168 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public CornerRadii interpolate(CornerRadii endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        if (uniform && endValue.uniform) {\n+            double newRadius = interpolate(\n+                this.topLeftHorizontalRadius, endValue.topLeftHorizontalRadius,\n+                this.topLeftHorizontalRadiusAsPercentage, endValue.topLeftHorizontalRadiusAsPercentage, t);\n+\n+            boolean newRadiusAsPercentage = t < 0.5 ?\n+                this.topLeftHorizontalRadiusAsPercentage :\n+                endValue.topLeftHorizontalRadiusAsPercentage;\n+\n+            if (topLeftHorizontalRadius == newRadius\n+                    && topLeftHorizontalRadiusAsPercentage == newRadiusAsPercentage) {\n+                return this;\n+            }\n+\n+            if (endValue.topLeftHorizontalRadius == newRadius\n+                    && endValue.topLeftHorizontalRadiusAsPercentage == newRadiusAsPercentage) {\n+                return endValue;\n+            }\n+\n+            return new CornerRadii(newRadius, newRadiusAsPercentage);\n+        }\n+\n+        boolean newTopLeftHorizontalRadiusAsPercentage,\n+                newTopLeftVerticalRadiusAsPercentage,\n+                newTopRightVerticalRadiusAsPercentage,\n+                newTopRightHorizontalRadiusAsPercentage,\n+                newBottomRightHorizontalRadiusAsPercentage,\n+                newBottomRightVerticalRadiusAsPercentage,\n+                newBottomLeftVerticalRadiusAsPercentage,\n+                newBottomLeftHorizontalRadiusAsPercentage;\n+\n+        if (t < 0.5) {\n+            newTopLeftHorizontalRadiusAsPercentage = this.topLeftHorizontalRadiusAsPercentage;\n+            newTopLeftVerticalRadiusAsPercentage = this.topLeftVerticalRadiusAsPercentage;\n+            newTopRightVerticalRadiusAsPercentage = this.topRightVerticalRadiusAsPercentage;\n+            newTopRightHorizontalRadiusAsPercentage = this.topRightHorizontalRadiusAsPercentage;\n+            newBottomRightHorizontalRadiusAsPercentage = this.bottomRightHorizontalRadiusAsPercentage;\n+            newBottomRightVerticalRadiusAsPercentage = this.bottomRightVerticalRadiusAsPercentage;\n+            newBottomLeftVerticalRadiusAsPercentage = this.bottomLeftVerticalRadiusAsPercentage;\n+            newBottomLeftHorizontalRadiusAsPercentage = this.bottomLeftHorizontalRadiusAsPercentage;\n+        } else {\n+            newTopLeftHorizontalRadiusAsPercentage = endValue.topLeftHorizontalRadiusAsPercentage;\n+            newTopLeftVerticalRadiusAsPercentage = endValue.topLeftVerticalRadiusAsPercentage;\n+            newTopRightVerticalRadiusAsPercentage = endValue.topRightVerticalRadiusAsPercentage;\n+            newTopRightHorizontalRadiusAsPercentage = endValue.topRightHorizontalRadiusAsPercentage;\n+            newBottomRightHorizontalRadiusAsPercentage = endValue.bottomRightHorizontalRadiusAsPercentage;\n+            newBottomRightVerticalRadiusAsPercentage = endValue.bottomRightVerticalRadiusAsPercentage;\n+            newBottomLeftVerticalRadiusAsPercentage = endValue.bottomLeftVerticalRadiusAsPercentage;\n+            newBottomLeftHorizontalRadiusAsPercentage = endValue.bottomLeftHorizontalRadiusAsPercentage;\n+        }\n+\n+        double newTopLeftHorizontalRadius = interpolate(\n+            this.topLeftHorizontalRadius, endValue.topLeftHorizontalRadius,\n+            this.topLeftHorizontalRadiusAsPercentage, endValue.topLeftHorizontalRadiusAsPercentage, t);\n+\n+        double newTopLeftVerticalRadius = interpolate(\n+            this.topLeftVerticalRadius, endValue.topLeftVerticalRadius,\n+            this.topLeftVerticalRadiusAsPercentage, endValue.topLeftVerticalRadiusAsPercentage, t);\n+\n+        double newTopRightVerticalRadius = interpolate(\n+            this.topRightVerticalRadius, endValue.topRightVerticalRadius,\n+            this.topRightVerticalRadiusAsPercentage, endValue.topRightVerticalRadiusAsPercentage, t);\n+\n+        double newTopRightHorizontalRadius = interpolate(\n+            this.topRightHorizontalRadius, endValue.topRightHorizontalRadius,\n+            this.topRightHorizontalRadiusAsPercentage, endValue.topRightHorizontalRadiusAsPercentage, t);\n+\n+        double newBottomRightHorizontalRadius = interpolate(\n+            this.bottomRightHorizontalRadius, endValue.bottomRightHorizontalRadius,\n+            this.bottomRightHorizontalRadiusAsPercentage, endValue.bottomRightHorizontalRadiusAsPercentage, t);\n+\n+        double newBottomRightVerticalRadius = interpolate(\n+            this.bottomRightVerticalRadius, endValue.bottomRightVerticalRadius,\n+            this.bottomRightVerticalRadiusAsPercentage, endValue.bottomRightVerticalRadiusAsPercentage, t);\n+\n+        double newBottomLeftVerticalRadius = interpolate(\n+            this.bottomLeftVerticalRadius, endValue.bottomLeftVerticalRadius,\n+            this.bottomLeftVerticalRadiusAsPercentage, endValue.bottomLeftVerticalRadiusAsPercentage, t);\n+\n+        double newBottomLeftHorizontalRadius = interpolate(\n+            this.bottomLeftHorizontalRadius, endValue.bottomLeftHorizontalRadius,\n+            this.bottomLeftHorizontalRadiusAsPercentage, endValue.bottomLeftHorizontalRadiusAsPercentage, t);\n+\n+        if (isSame(newTopLeftHorizontalRadius, newTopLeftVerticalRadius,\n+                   newTopRightVerticalRadius, newTopRightHorizontalRadius,\n+                   newBottomRightHorizontalRadius, newBottomRightVerticalRadius,\n+                   newBottomLeftVerticalRadius, newBottomLeftHorizontalRadius,\n+                   newTopLeftHorizontalRadiusAsPercentage, newTopLeftVerticalRadiusAsPercentage,\n+                   newTopRightVerticalRadiusAsPercentage, newTopRightHorizontalRadiusAsPercentage,\n+                   newBottomRightHorizontalRadiusAsPercentage, newBottomRightVerticalRadiusAsPercentage,\n+                   newBottomLeftVerticalRadiusAsPercentage, newBottomLeftHorizontalRadiusAsPercentage)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newTopLeftHorizontalRadius, newTopLeftVerticalRadius,\n+                            newTopRightVerticalRadius, newTopRightHorizontalRadius,\n+                            newBottomRightHorizontalRadius, newBottomRightVerticalRadius,\n+                            newBottomLeftVerticalRadius, newBottomLeftHorizontalRadius,\n+                            newTopLeftHorizontalRadiusAsPercentage, newTopLeftVerticalRadiusAsPercentage,\n+                            newTopRightVerticalRadiusAsPercentage, newTopRightHorizontalRadiusAsPercentage,\n+                            newBottomRightHorizontalRadiusAsPercentage, newBottomRightVerticalRadiusAsPercentage,\n+                            newBottomLeftVerticalRadiusAsPercentage, newBottomLeftHorizontalRadiusAsPercentage)) {\n+            return endValue;\n+        }\n+\n+        return new CornerRadii(\n+            newTopLeftHorizontalRadius, newTopLeftVerticalRadius,\n+            newTopRightVerticalRadius, newTopRightHorizontalRadius,\n+            newBottomRightHorizontalRadius, newBottomRightVerticalRadius,\n+            newBottomLeftVerticalRadius, newBottomLeftHorizontalRadius,\n+            newTopLeftHorizontalRadiusAsPercentage, newTopLeftVerticalRadiusAsPercentage,\n+            newTopRightVerticalRadiusAsPercentage, newTopRightHorizontalRadiusAsPercentage,\n+            newBottomRightHorizontalRadiusAsPercentage, newBottomRightVerticalRadiusAsPercentage,\n+            newBottomLeftVerticalRadiusAsPercentage, newBottomLeftHorizontalRadiusAsPercentage);\n+    }\n+\n+    private static double interpolate(double start, double end,\n+                                      boolean startIsPercentage, boolean endIsPercentage,\n+                                      double t) {\n+        return startIsPercentage == endIsPercentage ?\n+            InterpolationUtils.interpolate(start, end, t) :\n+            InterpolationUtils.interpolateDiscrete(start, end, t);\n+    }\n+\n+    private boolean isSame(double topLeftHorizontalRadius, double topLeftVerticalRadius,\n+                           double topRightVerticalRadius, double topRightHorizontalRadius,\n+                           double bottomRightHorizontalRadius, double bottomRightVerticalRadius,\n+                           double bottomLeftVerticalRadius, double bottomLeftHorizontalRadius,\n+                           boolean topLeftHorizontalRadiusAsPercentage, boolean topLeftVerticalRadiusAsPercentage,\n+                           boolean topRightVerticalRadiusAsPercentage, boolean topRightHorizontalRadiusAsPercentage,\n+                           boolean bottomRightHorizontalRadiusAsPercentage, boolean bottomRightVerticalRadiusAsPercentage,\n+                           boolean bottomLeftVerticalRadiusAsPercentage, boolean bottomLeftHorizontalRadiusAsPercentage) {\n+        return this.topLeftHorizontalRadius == topLeftHorizontalRadius\n+            && this.topLeftVerticalRadius == topLeftVerticalRadius\n+            && this.topRightVerticalRadius == topRightVerticalRadius\n+            && this.topRightHorizontalRadius == topRightHorizontalRadius\n+            && this.bottomRightHorizontalRadius == bottomRightHorizontalRadius\n+            && this.bottomRightVerticalRadius == bottomRightVerticalRadius\n+            && this.bottomLeftVerticalRadius == bottomLeftVerticalRadius\n+            && this.bottomLeftHorizontalRadius == bottomLeftHorizontalRadius\n+            && this.topLeftHorizontalRadiusAsPercentage == topLeftHorizontalRadiusAsPercentage\n+            && this.topLeftVerticalRadiusAsPercentage == topLeftVerticalRadiusAsPercentage\n+            && this.topRightVerticalRadiusAsPercentage == topRightVerticalRadiusAsPercentage\n+            && this.topRightHorizontalRadiusAsPercentage == topRightHorizontalRadiusAsPercentage\n+            && this.bottomRightHorizontalRadiusAsPercentage == bottomRightHorizontalRadiusAsPercentage\n+            && this.bottomRightVerticalRadiusAsPercentage == bottomRightVerticalRadiusAsPercentage\n+            && this.bottomLeftVerticalRadiusAsPercentage == bottomLeftVerticalRadiusAsPercentage\n+            && this.bottomLeftHorizontalRadiusAsPercentage == bottomLeftHorizontalRadiusAsPercentage;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/CornerRadii.java","additions":228,"deletions":10,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import javafx.animation.Interpolatable;\n@@ -31,0 +30,2 @@\n+import java.util.Objects;\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -108,1 +109,1 @@\n-public final class Color extends Paint implements Interpolatable<Color> {\n+public final class Color extends Paint {\n@@ -1844,0 +1845,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -1853,0 +1855,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -1862,0 +1865,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -1871,0 +1875,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -1938,1 +1943,8 @@\n-     * {@inheritDoc}\n+     * Returns an intermediate value between the value of this {@code Color} and the specified\n+     * {@code endValue} using the linear interpolation factor {@code t}, ranging from 0 (inclusive)\n+     * to 1 (inclusive).\n+     *\n+     * @param endValue the target value\n+     * @param t the interpolation factor\n+     * @throws NullPointerException if {@code endValue} is {@code null}\n+     * @return the intermediate value\n@@ -1940,2 +1952,5 @@\n-    @Override public Color interpolate(Color endValue, double t) {\n-        if (t <= 0.0) return this;\n+    public Color interpolate(Color endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ If both instances are equal, return this instance to prevent the creation of numerous small objects.\n+        if (t <= 0.0 || equals(endValue)) return this;\n@@ -1952,0 +1967,11 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public Paint interpolate(Paint endValue, double t) {\n+        return InterpolationUtils.interpolatePaint(this, endValue, t);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/Color.java","additions":32,"deletions":6,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import com.sun.javafx.util.InterpolationUtils;\n+import java.util.Objects;\n@@ -140,0 +142,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -153,0 +156,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -165,0 +171,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -178,0 +187,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -191,0 +203,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -209,0 +224,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -224,0 +240,1 @@\n+    private int hash;\n@@ -273,0 +290,76 @@\n+    \/**\n+     * Returns an intermediate value between the value of this {@code ImagePattern} and the specified\n+     * {@code endValue} using the linear interpolation factor {@code t}, ranging from 0 (inclusive)\n+     * to 1 (inclusive).\n+     *\n+     * @param endValue the target value\n+     * @param t the interpolation factor\n+     * @throws NullPointerException if {@code endValue} is {@code null}\n+     * @return the intermediate value\n+     * @since 24\n+     *\/\n+    public ImagePattern interpolate(ImagePattern endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0 || equals(endValue)) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        if (proportional != endValue.proportional) {\n+            return InterpolationUtils.interpolateDiscrete(this, endValue, t);\n+        }\n+\n+        return new ImagePattern(\n+            InterpolationUtils.interpolateDiscrete(image, endValue.image, t),\n+            InterpolationUtils.interpolate(x, endValue.x, t),\n+            InterpolationUtils.interpolate(y, endValue.y, t),\n+            InterpolationUtils.interpolate(width, endValue.width, t),\n+            InterpolationUtils.interpolate(height, endValue.height, t),\n+            proportional);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public Paint interpolate(Paint endValue, double t) {\n+        return InterpolationUtils.interpolatePaint(this, endValue, t);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof ImagePattern other) {\n+            return proportional == other.proportional\n+                && x == other.x\n+                && y == other.y\n+                && width == other.width\n+                && height == other.height\n+                && image.equals(other.image);\n+        }\n+\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        if (hash == 0) {\n+            long bits = 17L;\n+            bits = 37L * bits + Double.doubleToLongBits(x);\n+            bits = 37L * bits + Double.doubleToLongBits(y);\n+            bits = 37L * bits + Double.doubleToLongBits(width);\n+            bits = 37L * bits + Double.doubleToLongBits(height);\n+            bits = 37L * bits + ((proportional) ? 1231L : 1237L);\n+            bits = 37L * bits + image.hashCode();\n+            hash = (int) (bits ^ (bits >> 32));\n+        }\n+\n+        return hash;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/ImagePattern.java","additions":94,"deletions":1,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-\n+import java.util.Objects;\n@@ -32,0 +32,1 @@\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -81,1 +82,1 @@\n-     * point on a unit square that will be scaled to match the size of the\n+     * point on a unit square that will be scaled to match the size of\n@@ -83,1 +84,1 @@\n-     (\n+     *\n@@ -86,0 +87,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -96,1 +100,1 @@\n-     * point on a unit square that will be scaled to match the size of the\n+     * point on a unit square that will be scaled to match the size of\n@@ -101,0 +105,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -111,1 +118,1 @@\n-     * point on a unit square that will be scaled to match the size of the\n+     * point on a unit square that will be scaled to match the size of\n@@ -116,0 +123,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -126,1 +136,1 @@\n-     * point on a unit square that will be scaled to match the size of the\n+     * point on a unit square that will be scaled to match the size of\n@@ -131,0 +141,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -148,0 +161,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -162,0 +176,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -183,0 +198,3 @@\n+     * @interpolationType Stop list interpolation produces smooth transitions of gradient stops by allowing\n+     *                    the insertion of new stops along the gradient. At most, the intermediate stop list\n+     *                    has the combined number of gradient stops of both the start list and the target list.\n@@ -267,0 +285,18 @@\n+    \/**\n+     * Private constructor accepting a stop list that is already normalized.\n+     * This constructor is only called from the {@link #interpolate} method.\n+     *\/\n+    private LinearGradient(\n+            double startX, double startY, double endX, double endY,\n+            boolean proportional, CycleMethod cycleMethod, List<Stop> stops,\n+            int ignored) {\n+        this.startX = startX;\n+        this.startY = startY;\n+        this.endX = endX;\n+        this.endY = endY;\n+        this.proportional = proportional;\n+        this.cycleMethod = cycleMethod;\n+        this.stops = stops;\n+        this.opaque = determineOpacity();\n+    }\n+\n@@ -293,0 +329,90 @@\n+    \/**\n+     * Returns an intermediate value between the value of this {@code LinearGradient} and the specified\n+     * {@code endValue} using the linear interpolation factor {@code t}, ranging from 0 (inclusive)\n+     * to 1 (inclusive).\n+     *\n+     * @param endValue the target value\n+     * @param t the interpolation factor\n+     * @throws NullPointerException if {@code endValue} is {@code null}\n+     * @return the intermediate value\n+     * @since 24\n+     *\/\n+    public LinearGradient interpolate(LinearGradient endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0.0) {\n+            return this;\n+        }\n+\n+        if (t >= 1.0) {\n+            return endValue;\n+        }\n+\n+        double newStartX, newStartY, newEndX, newEndY;\n+        boolean newProportional;\n+\n+        if (this.proportional == endValue.proportional) {\n+            newStartX = InterpolationUtils.interpolate(this.startX, endValue.startX, t);\n+            newStartY = InterpolationUtils.interpolate(this.startY, endValue.startY, t);\n+            newEndX = InterpolationUtils.interpolate(this.endX, endValue.endX, t);\n+            newEndY = InterpolationUtils.interpolate(this.endY, endValue.endY, t);\n+            newProportional = this.proportional;\n+        } else if (t < 0.5) {\n+            newStartX = this.startX;\n+            newStartY = this.startY;\n+            newEndX = this.endX;\n+            newEndY = this.endY;\n+            newProportional = this.proportional;\n+        } else {\n+            newStartX = endValue.startX;\n+            newStartY = endValue.startY;\n+            newEndX = endValue.endX;\n+            newEndY = endValue.endY;\n+            newProportional = endValue.proportional;\n+        }\n+\n+        CycleMethod newCycleMethod = InterpolationUtils.interpolateDiscrete(this.cycleMethod, endValue.cycleMethod, t);\n+\n+        \/\/ Optimization: if both lists are equal, we don't compute a new intermediate list.\n+        List<Stop> newStops = this.stops.equals(endValue.stops) ?\n+            null : Stop.interpolateLists(this.stops, endValue.stops, t);\n+\n+        if (isSame(newStartX, newStartY, newEndX, newEndY, newProportional,\n+                   newCycleMethod, Objects.requireNonNullElse(newStops, this.stops))) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newStartX, newStartY, newEndX, newEndY, newProportional,\n+                            newCycleMethod, Objects.requireNonNullElse(newStops, endValue.stops))) {\n+            return endValue;\n+        }\n+\n+        return new LinearGradient(newStartX, newStartY, newEndX, newEndY,\n+                                  newProportional, newCycleMethod,\n+                                  Objects.requireNonNullElse(newStops, this.stops), 0);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public Paint interpolate(Paint endValue, double t) {\n+        return InterpolationUtils.interpolatePaint(this, endValue, t);\n+    }\n+\n+    private boolean isSame(double startX, double startY, double endX, double endY,\n+                           boolean proportional, CycleMethod cycleMethod, List<Stop> stops) {\n+        return this.startX == startX\n+            && this.startY == startY\n+            && this.endX == endX\n+            && this.endY == endY\n+            && this.proportional == proportional\n+            && this.cycleMethod == cycleMethod\n+            && this.stops == stops;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/LinearGradient.java","additions":133,"deletions":7,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import javafx.animation.Interpolatable;\n@@ -34,0 +35,11 @@\n+ * <p>\n+ * Linear interpolation is supported between the following heterogeneous paint combinations:\n+ * <ul>\n+ *     <li>{@link Color} ↔ {@link LinearGradient}\n+ *     <li>{@link Color} ↔ {@link RadialGradient}\n+ * <\/ul>\n+ * Heterogeneous paint interpolation converts the {@code Color} to a visually identical gradient\n+ * paint, and then performs a linear interpolation between the two gradient paints.\n+ * If heterogeneous paints cannot be interpolated as described, the paints are interpolated\n+ * <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">as discrete<\/a>.\n+ *\n@@ -36,1 +48,1 @@\n-public abstract class Paint {\n+public abstract class Paint implements Interpolatable<Paint> {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/Paint.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-\n+import java.util.Objects;\n@@ -32,0 +32,1 @@\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -74,2 +75,4 @@\n-     * @return the angle in degrees from the center of the gradient\n-     * to the focus point to which the first color is mapped\n+     *\n+     * @return the angle in degrees from the center of the gradient to the focus point\n+     *         to which the first color is mapped\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -88,2 +91,4 @@\n-     * @return the distance from the center of the gradient to the\n-     * focus point to which the first color is mapped\n+     *\n+     * @return the distance from the center of the gradient to the focus point to which\n+     *         the first color is mapped\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -100,1 +105,1 @@\n-     * point on a unit square that will be scaled to match the size of the\n+     * point on a unit square that will be scaled to match the size of\n@@ -104,2 +109,1 @@\n-     * @return the X coordinate of the center point of the circle defining the\n-     * gradient\n+     * @return the X coordinate of the center point of the circle defining the gradient\n@@ -107,0 +111,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -121,2 +128,1 @@\n-     * @return the X coordinate of the center point of the circle defining the\n-     * gradient\n+     * @return the X coordinate of the center point of the circle defining the gradient\n@@ -124,0 +130,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -137,2 +146,1 @@\n-     * @return the radius of the circle defining the extents of the color\n-     * gradient\n+     * @return the radius of the circle defining the extents of the color gradient\n@@ -140,0 +148,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -156,2 +167,1 @@\n-     * @return true if the center and radius values are proportional, otherwise\n-     * absolute\n+     * @return true if the center and radius values are proportional, otherwise absolute\n@@ -159,0 +169,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -173,0 +184,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -194,0 +206,3 @@\n+     * @interpolationType Stop list interpolation produces smooth transitions of gradient stops by allowing\n+     *                    the insertion of new stops along the gradient. At most, the intermediate stop list\n+     *                    has the combined number of gradient stops of both the start list and the target list.\n@@ -288,0 +303,18 @@\n+    \/**\n+     * Private constructor accepting a stop list that is already normalized.\n+     * This constructor is only called from the {@link #interpolate} method.\n+     *\/\n+    private RadialGradient(\n+            double focusAngle, double focusDistance, double centerX, double centerY, double radius,\n+            boolean proportional, CycleMethod cycleMethod, List<Stop> stops, int ignored) {\n+        this.focusAngle = focusAngle;\n+        this.focusDistance = focusDistance;\n+        this.centerX = centerX;\n+        this.centerY = centerY;\n+        this.radius = radius;\n+        this.proportional = proportional;\n+        this.cycleMethod = cycleMethod;\n+        this.stops = stops;\n+        this.opaque = determineOpacity();\n+    }\n+\n@@ -314,0 +347,89 @@\n+    \/**\n+     * Returns an intermediate value between the value of this {@code RadialGradient} and the specified\n+     * {@code endValue} using the linear interpolation factor {@code t}, ranging from 0 (inclusive)\n+     * to 1 (inclusive).\n+     *\n+     * @param endValue the target value\n+     * @param t the interpolation factor\n+     * @throws NullPointerException if {@code endValue} is {@code null}\n+     * @return the intermediate value\n+     * @since 24\n+     *\/\n+    public RadialGradient interpolate(RadialGradient endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0.0) {\n+            return this;\n+        }\n+\n+        if (t >= 1.0) {\n+            return endValue;\n+        }\n+\n+        double newCenterX, newCenterY, newRadius;\n+        boolean newProportional;\n+\n+        if (this.proportional == endValue.proportional) {\n+            newCenterX = InterpolationUtils.interpolate(this.centerX, endValue.centerX, t);\n+            newCenterY = InterpolationUtils.interpolate(this.centerY, endValue.centerY, t);\n+            newRadius = InterpolationUtils.interpolate(this.radius, endValue.radius, t);\n+            newProportional = this.proportional;\n+        } else if (t < 0.5) {\n+            newCenterX = this.centerX;\n+            newCenterY = this.centerY;\n+            newRadius = this.radius;\n+            newProportional = this.proportional;\n+        } else {\n+            newCenterX = endValue.centerX;\n+            newCenterY = endValue.centerY;\n+            newRadius = endValue.radius;\n+            newProportional = endValue.proportional;\n+        }\n+\n+        double newFocusAngle = InterpolationUtils.interpolate(this.focusAngle, endValue.focusAngle, t);\n+        double newFocusDistance = InterpolationUtils.interpolate(this.focusDistance, endValue.focusDistance, t);\n+        CycleMethod newCycleMethod = InterpolationUtils.interpolateDiscrete(this.cycleMethod, endValue.cycleMethod, t);\n+\n+        \/\/ Optimization: if both lists are equal, we don't compute a new intermediate list.\n+        List<Stop> newStops = this.stops.equals(endValue.stops) ?\n+            null : Stop.interpolateLists(this.stops, endValue.stops, t);\n+\n+        if (isSame(newFocusAngle, newFocusDistance, newCenterX, newCenterY, newRadius, newProportional,\n+                   newCycleMethod, Objects.requireNonNullElse(newStops, this.stops))) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newFocusAngle, newFocusDistance, newCenterX, newCenterY, newRadius, newProportional,\n+                            newCycleMethod, Objects.requireNonNullElse(newStops, endValue.stops))) {\n+            return endValue;\n+        }\n+\n+        return new RadialGradient(newFocusAngle, newFocusDistance, newCenterX, newCenterY, newRadius, newProportional,\n+                                  newCycleMethod, Objects.requireNonNullElse(newStops, this.stops), 0);\n+    }\n+\n+    private boolean isSame(double focusAngle, double focusDistance, double centerX, double centerY,\n+                           double radius, boolean proportional, CycleMethod cycleMethod, List<Stop> stops) {\n+        return this.focusAngle == focusAngle\n+            && this.focusDistance == focusDistance\n+            && this.centerX == centerX\n+            && this.centerY == centerY\n+            && this.radius == radius\n+            && this.proportional == proportional\n+            && this.cycleMethod == cycleMethod\n+            && this.stops == stops;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public Paint interpolate(Paint endValue, double t) {\n+        return InterpolationUtils.interpolatePaint(this, endValue, t);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/RadialGradient.java","additions":137,"deletions":15,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,4 @@\n+import java.util.Objects;\n+import com.sun.javafx.UnmodifiableArrayList;\n+import com.sun.javafx.util.InterpolationUtils;\n+import javafx.animation.Interpolatable;\n@@ -49,1 +53,1 @@\n-public final class Stop {\n+public final class Stop implements Interpolatable<Stop> {\n@@ -68,1 +72,1 @@\n-            if (s == null || s.getColor() == null) continue;\n+            if (s == null) continue;\n@@ -134,0 +138,78 @@\n+    \/**\n+     * Interpolates between two normalized lists of stops.\n+     *\n+     * @param firstList the first list, not {@code null}\n+     * @param secondList the second list, not {@code null}\n+     * @return the interpolated list, which may also be {@code firstList} or {@code secondList};\n+     *         if a new list is returned, it is unmodifiable\n+     *\/\n+    static List<Stop> interpolateLists(List<Stop> firstList, List<Stop> secondList, double t) {\n+        Objects.requireNonNull(firstList, \"firstList cannot be null\");\n+        Objects.requireNonNull(secondList, \"secondList cannot be null\");\n+\n+        if (!firstList.isEmpty() && firstList.get(0).getOffset() > 0) {\n+            throw new IllegalArgumentException(\"firstList is not normalized\");\n+        }\n+\n+        if (!secondList.isEmpty() && secondList.get(0).getOffset() > 0) {\n+            throw new IllegalArgumentException(\"secondList is not normalized\");\n+        }\n+\n+        if (t <= 0) {\n+            return firstList;\n+        }\n+\n+        if (t >= 1) {\n+            return secondList;\n+        }\n+\n+        \/\/ We need a new list that is at most the combined size of firstList and secondList.\n+        \/\/ In many cases we don't need all of that capacity, but allocating once is better than\n+        \/\/ re-allocating when we run out of space. In general, we expect the size of stop lists\n+        \/\/ to be quite small (a single-digit number of stops at most).\n+        Stop[] stops = new Stop[firstList.size() + secondList.size()];\n+        int size = 0;\n+\n+        for (int i = 0, j = 0, imax = firstList.size(), jmax = secondList.size(); i < imax && j < jmax; ++size) {\n+            Stop first = firstList.get(i);\n+            Stop second = secondList.get(j);\n+\n+            if (first.offset == second.offset) {\n+                stops[size] = first.color.equals(second.color) ?\n+                    first : new Stop(first.offset, first.color.interpolate(second.color, t));\n+                ++i;\n+                ++j;\n+            } else if (first.offset < second.offset) {\n+                stops[size] = interpolateVirtualStop(first, second, secondList.get(j - 1), 1 - t);\n+                ++i;\n+            } else {\n+                stops[size] = interpolateVirtualStop(second, first, firstList.get(i - 1), t);\n+                ++j;\n+            }\n+        }\n+\n+        return new UnmodifiableArrayList<>(stops, size);\n+    }\n+\n+    \/**\n+     * Consider two lists A and B, where A contains three stops, and B contains two stops:\n+     * <pre>{@code\n+     *               A2\n+     *             \/   \\\n+     *           \/      \\\n+     *    B1---\/----[X]--\\--B2\n+     *       \/            \\\n+     *     \/               \\\n+     *   A1                 A3\n+     * }<\/pre>\n+     *\n+     * Given the stops A{1,2,3} and B{1,2} in the diagram above, this method computes a new virtual\n+     * stop X that matches the offset of A2, and then interpolates between X and A2.\n+     *\/\n+    private static Stop interpolateVirtualStop(Stop A2, Stop B2, Stop B1, double t) {\n+        double u = (A2.offset - B1.offset) \/ (B2.offset - B1.offset);\n+        Color colorX = B1.color.interpolate(B2.color, u);\n+        Color colorR = colorX.interpolate(A2.color, t);\n+        return colorR.equals(A2.color) ? A2 : new Stop(A2.offset, colorR);\n+    }\n+\n@@ -152,2 +234,2 @@\n-     * @return position of the Stop within the gradient\n-     *         (ranging from {@code 0} to {@code 1})\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     * @return position of the Stop within the gradient (ranging from {@code 0} to {@code 1})\n@@ -168,0 +250,2 @@\n+     *\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -187,1 +271,38 @@\n-        this.color = color;\n+        this.color = Objects.requireNonNullElse(color, Color.TRANSPARENT);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 24\n+     *\/\n+    @Override\n+    public Stop interpolate(Stop endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0.0) {\n+            return this;\n+        }\n+\n+        if (t >= 1.0) {\n+            return endValue;\n+        }\n+\n+        \/\/ Color is implemented such that interpolate() always returns the existing instance if the\n+        \/\/ intermediate value is equal to the start value or the end value, which allows us to use an\n+        \/\/ identity comparison in place of a value comparison to determine equality.\n+        Color color = this.color.interpolate(endValue.color, t);\n+        double offset = InterpolationUtils.interpolate(this.offset, endValue.offset, t);\n+\n+        if (offset == this.offset && color == this.color) {\n+            return this;\n+        }\n+\n+        if (offset == endValue.offset && color == endValue.color) {\n+            return endValue;\n+        }\n+\n+        return new Stop(offset, color);\n@@ -198,4 +319,2 @@\n-        if (obj instanceof Stop) {\n-            Stop other = (Stop) obj;\n-            return offset == other.offset &&\n-              (color == null ? other.color == null : color.equals(other.color));\n+        if (obj instanceof Stop other) {\n+            return offset == other.offset && color.equals(other.color);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/Stop.java","additions":129,"deletions":10,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.Map;\n@@ -96,1 +97,1 @@\n-    public static List<TransitionTimer> getTransitionTimers(Node n) {\n+    public static Map<String, TransitionTimer> getTransitionTimers(Node n) {\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/javafx\/scene\/NodeShim.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,6 @@\n+import javafx.css.CssMetaData;\n+import javafx.css.ParsedValue;\n+import javafx.css.StyleConverter;\n+import javafx.scene.Node;\n+import javafx.scene.image.Image;\n+\n@@ -30,0 +36,6 @@\n+    public static final CssMetaData<Node, Image[]> BACKGROUND_IMAGE = Background.BACKGROUND_IMAGE;\n+\n+    public static StyleConverter<ParsedValue[], Background> getConverter() {\n+        return BackgroundConverter.INSTANCE;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/javafx\/scene\/layout\/BackgroundShim.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.layout;\n+\n+import javafx.css.CssMetaData;\n+import javafx.css.ParsedValue;\n+import javafx.css.StyleConverter;\n+import javafx.scene.Node;\n+\n+public class BorderShim {\n+\n+    public static final CssMetaData<Node, String[]> BORDER_IMAGE_SOURCE = Border.BORDER_IMAGE_SOURCE;\n+\n+    public static StyleConverter<ParsedValue[], Border> getConverter() {\n+        return BorderConverter.getInstance();\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/javafx\/scene\/layout\/BorderShim.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.paint;\n+\n+import java.util.List;\n+\n+public final class StopShim {\n+\n+    private StopShim() {}\n+\n+    public static List<Stop> interpolateLists(List<Stop> firstList, List<Stop> secondList, double t) {\n+        return Stop.interpolateLists(firstList, secondList, t);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/javafx\/scene\/paint\/StopShim.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+--add-exports javafx.graphics\/com.sun.javafx.scene.paint=ALL-UNNAMED\n","filename":"modules\/javafx.graphics\/src\/test\/addExports","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import com.sun.javafx.scene.NodeHelper;\n@@ -35,0 +36,1 @@\n+import javafx.scene.Node;\n@@ -63,3 +65,1 @@\n-        void run(TransitionDefinition definition) {\n-            mediator.run(definition);\n-            timer = mediator.getTimer();\n+        void run(TransitionDefinition definition, Node node) {\n@@ -67,0 +67,2 @@\n+            mediator.run(definition, definition.propertyName(), now);\n+            timer = NodeHelper.findTransitionTimer(node, definition.propertyName());\n@@ -86,0 +88,5 @@\n+\n+        @Override\n+        public boolean updateReversingAdjustedStartValue(TransitionMediator existingMediator) {\n+            return true;\n+        }\n@@ -112,1 +119,1 @@\n-        timer.run(transition);\n+        timer.run(transition, node);\n@@ -132,1 +139,1 @@\n-        timer.run(transition);\n+        timer.run(transition, node);\n@@ -144,1 +151,1 @@\n-        timer.run(transition);\n+        timer.run(transition, node);\n@@ -147,17 +154,2 @@\n-        assertTrue(timer.mediator.cancel(false));\n-        assertEquals(0, NodeShim.getTransitionTimers(node).size());\n-    }\n-\n-    @Test\n-    public void testTimerDoesNotStopItselfWhenSettingValue() {\n-        var flag = new boolean[1];\n-        var transition = new TransitionDefinition(\"-fx-opacity\", seconds(1), ZERO, LINEAR);\n-        var timer = new TimerWrapper(new TestTransitionMediator() {\n-            @Override public void onUpdate(double progress) {\n-                flag[0] = cancel(false);\n-            }\n-        });\n-\n-        timer.run(transition);\n-        timer.fire(seconds(0.2));\n-        assertFalse(flag[0]);\n+        timer.mediator.cancel();\n+        assertNull(NodeShim.getTransitionTimers(node));\n@@ -178,1 +170,1 @@\n-        timer.run(transition);\n+        timer.run(transition, node);\n@@ -200,1 +192,1 @@\n-        timer1.run(transition);\n+        timer1.run(transition, node);\n@@ -208,1 +200,1 @@\n-        timer2.run(transition);\n+        timer2.run(transition, node);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/css\/TransitionTimerTest.java","additions":18,"deletions":26,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.scene.layout.region;\n+\n+import com.sun.javafx.scene.layout.region.BorderImageSlices;\n+import javafx.scene.layout.BorderWidths;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class BorderImageSlicesTest {\n+\n+    @Test\n+    void testEquals() {\n+        var a = new BorderImageSlices(new BorderWidths(1, 2, 3, 4), true);\n+        var b = new BorderImageSlices(new BorderWidths(1, 2, 3, 4), true);\n+        assertTrue(a.equals(b));\n+        assertTrue(b.equals(a));\n+\n+        a = new BorderImageSlices(new BorderWidths(1, 2, 3, 4), true);\n+        b = new BorderImageSlices(new BorderWidths(1, 2, 3, 4), false);\n+        assertFalse(a.equals(b));\n+        assertFalse(b.equals(a));\n+\n+        a = new BorderImageSlices(new BorderWidths(1, 2, 3, 4), true);\n+        b = new BorderImageSlices(new BorderWidths(5, 2, 3, 4), true);\n+        assertFalse(a.equals(b));\n+        assertFalse(b.equals(a));\n+    }\n+\n+    @Test\n+    void testHashCode() {\n+        var a = new BorderImageSlices(new BorderWidths(1, 2, 3, 4), true);\n+        var b = new BorderImageSlices(new BorderWidths(1, 2, 3, 4), true);\n+        assertEquals(a.hashCode(), b.hashCode());\n+\n+        a = new BorderImageSlices(new BorderWidths(1, 2, 3, 4), true);\n+        b = new BorderImageSlices(new BorderWidths(1, 2, 3, 4), false);\n+        assertNotEquals(a.hashCode(), b.hashCode());\n+\n+        a = new BorderImageSlices(new BorderWidths(1, 2, 3, 4), true);\n+        b = new BorderImageSlices(new BorderWidths(5, 2, 3, 4), true);\n+        assertNotEquals(a.hashCode(), b.hashCode());\n+    }\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenTwoDifferentValuesReturnsNewInstance() {\n+            var startValue = new BorderImageSlices(new BorderWidths(0), true);\n+            var endValue = new BorderImageSlices(new BorderWidths(1), false);\n+\n+            assertEquals(new BorderImageSlices(new BorderWidths(0.4), true),\n+                         startValue.interpolate(endValue, 0.4));\n+\n+            assertEquals(new BorderImageSlices(new BorderWidths(0.5), false),\n+                         startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsStartInstance() {\n+            var startValue = new BorderImageSlices(new BorderWidths(1), true);\n+            var endValue = new BorderImageSlices(new BorderWidths(1), true);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new BorderImageSlices(BorderWidths.EMPTY, true);\n+            var endValue = new BorderImageSlices(BorderWidths.FULL, true);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new BorderImageSlices(BorderWidths.EMPTY, true);\n+            var endValue = new BorderImageSlices(BorderWidths.FULL, true);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/layout\/region\/BorderImageSlicesTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.scene.layout.region;\n+\n+import com.sun.javafx.scene.layout.region.Margins;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class MarginsTest {\n+\n+    @Test\n+    void testEquals() {\n+        var a = new Margins(1, 2, 3, 4, false);\n+        var b = new Margins(1, 2, 3, 4, false);\n+        assertTrue(a.equals(b));\n+        assertTrue(b.equals(a));\n+\n+        a = new Margins(1, 2, 3, 4, false);\n+        b = new Margins(1, 2, 3, 4, true);\n+        assertFalse(a.equals(b));\n+        assertFalse(b.equals(a));\n+\n+        a = new Margins(1, 2, 3, 4, false);\n+        b = new Margins(5, 2, 3, 4, false);\n+        assertFalse(a.equals(b));\n+        assertFalse(b.equals(a));\n+\n+        a = new Margins(1, 2, 3, 4, false);\n+        b = new Margins(1, 5, 3, 4, false);\n+        assertFalse(a.equals(b));\n+        assertFalse(b.equals(a));\n+\n+        a = new Margins(1, 2, 3, 4, false);\n+        b = new Margins(1, 2, 5, 4, false);\n+        assertFalse(a.equals(b));\n+        assertFalse(b.equals(a));\n+\n+        a = new Margins(1, 2, 3, 4, false);\n+        b = new Margins(1, 2, 3, 5, false);\n+        assertFalse(a.equals(b));\n+        assertFalse(b.equals(a));\n+    }\n+\n+    @Test\n+    void testHashCode() {\n+        var a = new Margins(1, 2, 3, 4, false);\n+        var b = new Margins(1, 2, 3, 4, false);\n+        assertEquals(a.hashCode(), b.hashCode());\n+\n+        a = new Margins(1, 2, 3, 4, false);\n+        b = new Margins(5, 2, 3, 4, false);\n+        assertNotEquals(a.hashCode(), b.hashCode());\n+    }\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenTwoDifferentValuesReturnsNewInstance() {\n+            var startValue = new Margins(2, 4, 6, 8, false);\n+            var endValue = new Margins(4, 8, 12, 16, false);\n+            var expected = new Margins(3, 6, 9, 12, false);\n+            assertEquals(expected, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenProportionalAndNonProportionalValuesReturnsStartOrEndInstance() {\n+            var startValue = new Margins(2, 4, 6, 8, true);\n+            var endValue = new Margins(4, 8, 12, 16, false);\n+            assertEquals(startValue, startValue.interpolate(endValue, 0.4));\n+            assertEquals(endValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsStartInstance() {\n+            var startValue = new Margins(2, 4, 6, 8, false);\n+            var endValue = new Margins(2, 4, 6, 8, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new Margins(2, 4, 6, 8, false);\n+            var endValue = new Margins(4, 8, 12, 16, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new Margins(2, 4, 6, 8, false);\n+            var endValue = new Margins(4, 8, 12, 16, false);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/layout\/region\/MarginsTest.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.util;\n+\n+import com.sun.javafx.util.InterpolationUtils;\n+import javafx.scene.paint.CycleMethod;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.Paint;\n+import javafx.scene.paint.RadialGradient;\n+import javafx.scene.paint.Stop;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import java.util.List;\n+\n+import static javafx.scene.paint.Color.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class InterpolationUtilsTest {\n+\n+    @Nested\n+    class PairwiseListInterpolationTest {\n+        @Test\n+        void differentValuesReturnsNewInstance() {\n+            var startValue = List.<Paint>of(RED, BLUE);\n+            var endValue = List.<Paint>of(GREEN, YELLOW);\n+            var expected = List.of(RED.interpolate(GREEN, 0.5), BLUE.interpolate(YELLOW, 0.5));\n+            var actual = InterpolationUtils.interpolateListsPairwise(startValue, endValue, 0.5);\n+            assertEquals(expected, actual);\n+            assertNotSame(expected, startValue);\n+            assertNotSame(expected, endValue);\n+            assertThrows(UnsupportedOperationException.class, () -> actual.add(RED));\n+        }\n+\n+        @Test\n+        void sameValuesReturnsStartInstance() {\n+            var startValue = List.<Paint>of(RED, BLUE);\n+            var endValue = List.<Paint>of(RED, BLUE);\n+            var actual = InterpolationUtils.interpolateListsPairwise(startValue, endValue, 0.5);\n+            assertSame(startValue, actual);\n+        }\n+\n+        @Test\n+        void secondListHasMoreElements() {\n+            var startValue = List.<Paint>of(RED, BLUE);\n+            var endValue = List.<Paint>of(GREEN, YELLOW, PURPLE);\n+            var expected = List.of(RED.interpolate(GREEN, 0.5), BLUE.interpolate(YELLOW, 0.5), PURPLE);\n+            var actual = InterpolationUtils.interpolateListsPairwise(startValue, endValue, 0.5);\n+            assertEquals(expected, actual);\n+        }\n+\n+        @Test\n+        void secondListHasLessElements() {\n+            var startValue = List.<Paint>of(RED, BLUE);\n+            var endValue = List.<Paint>of(GREEN);\n+            var expected = List.of(RED.interpolate(GREEN, 0.5));\n+            var actual = InterpolationUtils.interpolateListsPairwise(startValue, endValue, 0.5);\n+            assertEquals(expected, actual);\n+        }\n+    }\n+\n+    @Nested\n+    class PairwiseArrayInterpolationTest {\n+        @Test\n+        void differentValuesReturnsNewInstance() {\n+            var startValue = arrayOf(RED, BLUE);\n+            var endValue = arrayOf(GREEN, YELLOW);\n+            var expected = arrayOf(RED.interpolate(GREEN, 0.5), BLUE.interpolate(YELLOW, 0.5));\n+            var actual = InterpolationUtils.interpolateArraysPairwise(startValue, endValue, 0.5);\n+            assertArrayEquals(expected, actual);\n+            assertNotSame(expected, startValue);\n+            assertNotSame(expected, endValue);\n+        }\n+\n+        @Test\n+        void sameValuesReturnsStartInstance() {\n+            var startValue = arrayOf(RED, BLUE);\n+            var endValue = arrayOf(RED, BLUE);\n+            var actual = InterpolationUtils.interpolateArraysPairwise(startValue, endValue, 0.5);\n+            assertSame(startValue, actual);\n+        }\n+\n+        @Test\n+        void secondArrayHasMoreElements() {\n+            var startValue = arrayOf(RED, BLUE);\n+            var endValue = arrayOf(GREEN, YELLOW, PURPLE);\n+            var expected = arrayOf(RED.interpolate(GREEN, 0.5), BLUE.interpolate(YELLOW, 0.5), PURPLE);\n+            var actual = InterpolationUtils.interpolateArraysPairwise(startValue, endValue, 0.5);\n+            assertArrayEquals(expected, actual);\n+        }\n+\n+        @Test\n+        void secondArrayHasLessElements() {\n+            var startValue = arrayOf(RED, BLUE);\n+            var endValue = arrayOf(GREEN);\n+            var expected = arrayOf(RED.interpolate(GREEN, 0.5));\n+            var actual = InterpolationUtils.interpolateArraysPairwise(startValue, endValue, 0.5);\n+            assertArrayEquals(expected, actual);\n+        }\n+    }\n+\n+    @Nested\n+    class InterpolateColorTest {\n+        @Test\n+        void toLinearGradient() {\n+            var paint = InterpolationUtils.interpolatePaint(\n+                BLUE,\n+                new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, RED), new Stop(1, GREEN)),\n+                0.5);\n+\n+            var expected = new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                              new Stop(0, BLUE.interpolate(RED, 0.5)),\n+                                              new Stop(1, BLUE.interpolate(GREEN, 0.5)));\n+\n+            assertEquals(expected, paint);\n+        }\n+\n+        @Test\n+        void toRadialGradient() {\n+            var paint = InterpolationUtils.interpolatePaint(\n+                BLUE,\n+                new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, RED), new Stop(1, GREEN)),\n+                0.5);\n+\n+            var expected = new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                              new Stop(0, BLUE.interpolate(RED, 0.5)),\n+                                              new Stop(1, BLUE.interpolate(GREEN, 0.5)));\n+\n+            assertEquals(expected, paint);\n+        }\n+    }\n+\n+    @Nested\n+    class InterpolateLinearGradientTest {\n+        @Test\n+        void toColor() {\n+            var paint = InterpolationUtils.interpolatePaint(\n+                new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, RED), new Stop(1, GREEN)),\n+                BLUE,\n+                0.5);\n+\n+            var expected = new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                              new Stop(0, RED.interpolate(BLUE, 0.5)),\n+                                              new Stop(1, GREEN.interpolate(BLUE, 0.5)));\n+\n+            assertEquals(expected, paint);\n+        }\n+\n+        @Test\n+        void toRadialGradient() {\n+            var toPaint = new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                             new Stop(0, RED), new Stop(1, GREEN));\n+\n+            var actual = InterpolationUtils.interpolatePaint(\n+                new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, RED), new Stop(1, GREEN)),\n+                toPaint,\n+                0.5);\n+\n+            assertSame(actual, toPaint);\n+        }\n+    }\n+\n+    @Nested\n+    class InterpolateRadialGradientTest {\n+        @Test\n+        void toColor() {\n+            var paint = InterpolationUtils.interpolatePaint(\n+                new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, RED), new Stop(1, GREEN)),\n+                BLUE,\n+                0.5);\n+\n+            var expected = new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                              new Stop(0, RED.interpolate(BLUE, 0.5)),\n+                                              new Stop(1, GREEN.interpolate(BLUE, 0.5)));\n+\n+            assertEquals(expected, paint);\n+        }\n+\n+        @Test\n+        void toLinearGradient() {\n+            var toPaint = new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                             new Stop(0, RED), new Stop(1, GREEN));\n+\n+            var actual = InterpolationUtils.interpolatePaint(\n+                new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, RED), new Stop(1, GREEN)),\n+                toPaint,\n+                0.5);\n+\n+            assertSame(actual, toPaint);\n+        }\n+    }\n+\n+    @SafeVarargs\n+    private static <T> T[] arrayOf(T... values) {\n+        return values;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/util\/InterpolationUtilsTest.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.javafx.css.TransitionMediator;\n@@ -31,0 +30,1 @@\n+import com.sun.javafx.tk.Toolkit;\n@@ -39,0 +39,2 @@\n+import javafx.css.SimpleStyleableStringProperty;\n+import javafx.css.StyleConverter;\n@@ -48,0 +50,1 @@\n+import javafx.css.StyleableStringProperty;\n@@ -51,0 +54,2 @@\n+import javafx.css.converter.StringConverter;\n+import javafx.geometry.Insets;\n@@ -53,0 +58,4 @@\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.BackgroundFill;\n+import javafx.scene.layout.BackgroundShim;\n+import javafx.scene.layout.CornerRadii;\n@@ -58,0 +67,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -60,2 +70,2 @@\n-import java.lang.reflect.Field;\n-import java.util.function.Function;\n+import test.com.sun.javafx.pgstub.StubToolkit;\n+import java.util.List;\n@@ -65,0 +75,1 @@\n+import static test.util.ReflectionUtils.*;\n@@ -98,2 +109,2 @@\n-    static final CssMetaData<Styleable, Color> objectPropertyMetadata = new CssMetaData<>(\n-            \"-fx-object-property\", ColorConverter.getInstance(), Color.RED) {\n+    static final CssMetaData<Styleable, String> stringPropertyMetadata = new CssMetaData<>(\n+            \"-fx-string-property\", StringConverter.getInstance(), null) {\n@@ -101,1 +112,1 @@\n-        @Override public StyleableProperty<Color> getStyleableProperty(Styleable styleable) { return objectProperty; }\n+        @Override public StyleableProperty<String> getStyleableProperty(Styleable styleable) { return stringProperty; }\n@@ -104,0 +115,19 @@\n+    static final CssMetaData<Styleable, Color> interpolatableObjectPropertyMetadata = new CssMetaData<>(\n+            \"-fx-interpolatable-property\", ColorConverter.getInstance(), Color.RED) {\n+        @Override public boolean isSettable(Styleable styleable) { return true; }\n+        @Override public StyleableProperty<Color> getStyleableProperty(Styleable styleable) {\n+            return interpolatableObjectProperty;\n+        }\n+    };\n+\n+    static final CssMetaData<Styleable, Background> componentTransitionableObjectPropertyMetadata = new CssMetaData<>(\n+            \"-fx-component-transitionable-property\", BackgroundShim.getConverter(),\n+            Background.fill(Color.RED), false, Background.getClassCssMetaData()) {\n+        @Override public boolean isSettable(Styleable styleable) { return true; }\n+        @Override public StyleableProperty<Background> getStyleableProperty(Styleable styleable) {\n+            return componentTransitionableObjectProperty;\n+        }\n+    };\n+\n+    static final Duration ONE_SECOND = Duration.seconds(1);\n+\n@@ -107,6 +137,8 @@\n-                new TransitionDefinition(\"-fx-boolean-property\", Duration.ONE, Duration.ZERO, Interpolator.LINEAR),\n-                new TransitionDefinition(\"-fx-double-property\", Duration.ONE, Duration.ZERO, Interpolator.LINEAR),\n-                new TransitionDefinition(\"-fx-float-property\", Duration.ONE, Duration.ZERO, Interpolator.LINEAR),\n-                new TransitionDefinition(\"-fx-integer-property\", Duration.ONE, Duration.ZERO, Interpolator.LINEAR),\n-                new TransitionDefinition(\"-fx-long-property\", Duration.ONE, Duration.ZERO, Interpolator.LINEAR),\n-                new TransitionDefinition(\"-fx-object-property\", Duration.ONE, Duration.ZERO, Interpolator.LINEAR)\n+                new TransitionDefinition(\"-fx-boolean-property\", ONE_SECOND, Duration.ZERO, Interpolator.LINEAR),\n+                new TransitionDefinition(\"-fx-double-property\", ONE_SECOND, Duration.ZERO, Interpolator.LINEAR),\n+                new TransitionDefinition(\"-fx-float-property\", ONE_SECOND, Duration.ZERO, Interpolator.LINEAR),\n+                new TransitionDefinition(\"-fx-integer-property\", ONE_SECOND, Duration.ZERO, Interpolator.LINEAR),\n+                new TransitionDefinition(\"-fx-long-property\", ONE_SECOND, Duration.ZERO, Interpolator.LINEAR),\n+                new TransitionDefinition(\"-fx-string-property\", ONE_SECOND, Duration.ZERO, Interpolator.LINEAR),\n+                new TransitionDefinition(\"-fx-interpolatable-property\", ONE_SECOND, Duration.ZERO, Interpolator.LINEAR),\n+                new TransitionDefinition(\"-fx-component-transitionable-property\", ONE_SECOND, Duration.ZERO, Interpolator.LINEAR)\n@@ -122,29 +154,3 @@\n-    static StyleableObjectProperty<Color> objectProperty;\n-\n-    static TransitionMediator getTransitionMediator(StyleableProperty<?> property) {\n-        Function<Class<?>, Field> getField = cls -> {\n-            try {\n-                var field = cls.getDeclaredField(\"mediator\");\n-                field.setAccessible(true);\n-                return field;\n-            } catch (NoSuchFieldException e) {\n-                return null;\n-            }\n-        };\n-\n-        Class<?> cls = property.getClass();\n-        while (cls != null) {\n-            Field field = getField.apply(cls);\n-            if (field != null) {\n-                try {\n-                    return (TransitionMediator)field.get(property);\n-                } catch (IllegalAccessException e) {\n-                    throw new AssertionError(e);\n-                }\n-            }\n-\n-            cls = cls.getSuperclass();\n-        }\n-\n-        throw new AssertionError();\n-    }\n+    static StyleableStringProperty stringProperty;\n+    static StyleableObjectProperty<Color> interpolatableObjectProperty;\n+    static StyleableObjectProperty<Background> componentTransitionableObjectProperty;\n@@ -153,1 +159,1 @@\n-    record TestRun(StyleableProperty property, Object defaultValue, Object newValue) {}\n+    record TestRun(StyleableProperty property, String fieldName, Object defaultValue, Object newValue) {}\n@@ -161,1 +167,5 @@\n-        objectProperty = new SimpleStyleableObjectProperty<>(objectPropertyMetadata, testBean, null, Color.RED);\n+        stringProperty = new SimpleStyleableStringProperty(stringPropertyMetadata, testBean, null);\n+        interpolatableObjectProperty = new SimpleStyleableObjectProperty<>(\n+            interpolatableObjectPropertyMetadata, testBean, null, Color.RED);\n+        componentTransitionableObjectProperty = new SimpleStyleableObjectProperty<>(\n+            componentTransitionableObjectPropertyMetadata, testBean, null, Background.fill(Color.RED));\n@@ -164,6 +174,9 @@\n-            new TestRun(booleanProperty, false, true),\n-            new TestRun(doubleProperty, 0, 1),\n-            new TestRun(floatProperty, 0, 1),\n-            new TestRun(integerProperty, 0, 1),\n-            new TestRun(longProperty, 0, 1),\n-            new TestRun(objectProperty, Color.RED, Color.GREEN)\n+            new TestRun(booleanProperty, \"mediator\", false, true),\n+            new TestRun(doubleProperty, \"mediator\", 0, 1),\n+            new TestRun(floatProperty, \"mediator\", 0, 1),\n+            new TestRun(integerProperty, \"mediator\", 0, 1),\n+            new TestRun(longProperty, \"mediator\", 0, 1),\n+            new TestRun(stringProperty, \"mediator\", \"foo\", \"bar\"),\n+            new TestRun(interpolatableObjectProperty, \"controller\", Color.RED, Color.GREEN),\n+            new TestRun(componentTransitionableObjectProperty, \"controller\",\n+                        Background.fill(Color.RED), Background.fill(Color.GREEN))\n@@ -173,0 +186,1 @@\n+    StubToolkit toolkit;\n@@ -176,0 +190,5 @@\n+    void setAnimationTime(long time) {\n+        toolkit.setCurrentTime(time);\n+        toolkit.handleAnimation();\n+    }\n+\n@@ -178,1 +197,2 @@\n-        scene = new Scene(new Group(testBean));\n+        toolkit = (StubToolkit)Toolkit.getToolkit();\n+        scene = new Scene(new Group());\n@@ -194,0 +214,2 @@\n+        ((Group)scene.getRoot()).getChildren().setAll(testBean);\n+\n@@ -196,1 +218,1 @@\n-        var mediator1 = getTransitionMediator(testRun.property);\n+        var mediator1 = getFieldValue(testRun.property, testRun.fieldName);\n@@ -201,1 +223,1 @@\n-        var mediator2 = getTransitionMediator(testRun.property);\n+        var mediator2 = getFieldValue(testRun.property, testRun.fieldName);\n@@ -207,1 +229,1 @@\n-        var mediator3 = getTransitionMediator(testRun.property);\n+        var mediator3 = getFieldValue(testRun.property, testRun.fieldName);\n@@ -215,0 +237,2 @@\n+        ((Group)scene.getRoot()).getChildren().setAll(testBean);\n+\n@@ -217,1 +241,1 @@\n-        var mediator1 = getTransitionMediator(testRun.property);\n+        var mediator1 = getFieldValue(testRun.property, testRun.fieldName);\n@@ -222,1 +246,1 @@\n-        var mediator2 = getTransitionMediator(testRun.property);\n+        var mediator2 = getFieldValue(testRun.property, testRun.fieldName);\n@@ -228,1 +252,1 @@\n-        var mediator3 = getTransitionMediator(testRun.property);\n+        var mediator3 = getFieldValue(testRun.property, testRun.fieldName);\n@@ -232,0 +256,213 @@\n+\n+    @Test\n+    void testExistingTransitionOfComponentTransitionableIsPreserved() {\n+        var bean = new Group();\n+        ((Group)scene.getRoot()).getChildren().setAll(bean);\n+        var border1 = new Background(new BackgroundFill(Color.RED, new CornerRadii(5), Insets.EMPTY));\n+        var border2 = new Background(new BackgroundFill(Color.GREEN, new CornerRadii(10), Insets.EMPTY));\n+        var border3 = new Background(new BackgroundFill(Color.BLUE, new CornerRadii(10), Insets.EMPTY));\n+        var property = new SimpleStyleableObjectProperty<>(componentTransitionableObjectPropertyMetadata, bean, null);\n+\n+        NodeHelper.getTransitionProperty(bean).setValue(new TransitionDefinition[] {\n+            new TransitionDefinition(\"-fx-background-color\", Duration.seconds(1), Duration.ZERO, Interpolator.LINEAR),\n+            new TransitionDefinition(\"-fx-background-radius\", Duration.seconds(1), Duration.ZERO, Interpolator.LINEAR)\n+        });\n+\n+        \/\/ Setting a value for the first time doesn't start a transition.\n+        setAnimationTime(0);\n+        property.applyStyle(StyleOrigin.USER, border1);\n+\n+        \/\/ Start the transition and capture a copy of the sub-property mediator list.\n+        \/\/ -fx-background-color will transition from RED to GREEN\n+        \/\/ -fx-background-radius will transition rom 5 to 10\n+        property.applyStyle(StyleOrigin.USER, border2);\n+        var oldMediators = List.copyOf((List<?>)getFieldValue(getFieldValue(property, \"controller\"), \"mediators\"));\n+\n+        \/\/ Advance the animation time and start the second transition.\n+        \/\/ -fx-background-color will transition from (mix of RED\/GREEN) to BLUE\n+        \/\/ -fx-background-radius will pick up the previous transition, because its target value is the same (10)\n+        setAnimationTime(500);\n+        property.applyStyle(StyleOrigin.USER, border3);\n+        var newMediators = (List<?>)getFieldValue(getFieldValue(property, \"controller\"), \"mediators\");\n+\n+        \/\/ The result is that now we have a new mediator for -fx-background-color, but the same\n+        \/\/ mediator as in the previous transition for -fx-background-radius.\n+        assertEquals(2, oldMediators.size());\n+        assertEquals(2, newMediators.size());\n+        assertNotSame(oldMediators.get(0), newMediators.get(0)); \/\/ -fx-background-color\n+        assertSame(oldMediators.get(1), newMediators.get(1));    \/\/ -fx-background-radius\n+    }\n+\n+    @Test\n+    void testIntegerTransitionsInRealNumberSpace() {\n+        ((Group)scene.getRoot()).getChildren().setAll(testBean);\n+        var property = new SimpleStyleableIntegerProperty(integerPropertyMetadata, testBean, null);\n+\n+        \/\/ Setting a value for the first time doesn't start a transition.\n+        setAnimationTime(0);\n+        property.applyStyle(StyleOrigin.USER, 0);\n+\n+        \/\/ Start the transition and sample the outputs.\n+        property.applyStyle(StyleOrigin.USER, 2);\n+        setAnimationTime(249);\n+        assertEquals(0, property.get());\n+        setAnimationTime(250);\n+        assertEquals(1, property.get());\n+        setAnimationTime(500);\n+        assertEquals(1, property.get());\n+        setAnimationTime(749);\n+        assertEquals(1, property.get());\n+        setAnimationTime(750);\n+        assertEquals(2, property.get());\n+    }\n+\n+    @Test\n+    void testLongTransitionsInRealNumberSpace() {\n+        ((Group)scene.getRoot()).getChildren().setAll(testBean);\n+        var property = new SimpleStyleableLongProperty(longPropertyMetadata, testBean, null);\n+\n+        \/\/ Setting a value for the first time doesn't start a transition.\n+        setAnimationTime(0);\n+        property.applyStyle(StyleOrigin.USER, 0);\n+\n+        \/\/ Start the transition and sample the outputs.\n+        property.applyStyle(StyleOrigin.USER, 2);\n+        setAnimationTime(249);\n+        assertEquals(0, property.get());\n+        setAnimationTime(250);\n+        assertEquals(1, property.get());\n+        setAnimationTime(500);\n+        assertEquals(1, property.get());\n+        setAnimationTime(749);\n+        assertEquals(1, property.get());\n+        setAnimationTime(750);\n+        assertEquals(2, property.get());\n+    }\n+\n+    @Test\n+    void testBooleanTransitionsAsDiscrete() {\n+        ((Group)scene.getRoot()).getChildren().setAll(testBean);\n+        var property = new SimpleStyleableBooleanProperty(booleanPropertyMetadata, testBean, null);\n+\n+        \/\/ Setting a value for the first time doesn't start a transition.\n+        setAnimationTime(0);\n+        property.applyStyle(StyleOrigin.USER, false);\n+\n+        \/\/ Start the transition and sample the outputs.\n+        property.applyStyle(StyleOrigin.USER, true);\n+        setAnimationTime(499);\n+        assertFalse(property.get());\n+        setAnimationTime(500);\n+        assertTrue(property.get());\n+    }\n+\n+    @Test\n+    void testStringTransitionsAsDiscrete() {\n+        ((Group)scene.getRoot()).getChildren().setAll(testBean);\n+        var property = new SimpleStyleableStringProperty(stringPropertyMetadata, testBean, null);\n+\n+        \/\/ Setting a value for the first time doesn't start a transition.\n+        setAnimationTime(0);\n+        property.applyStyle(StyleOrigin.USER, \"foo\");\n+\n+        \/\/ Start the transition and sample the outputs.\n+        property.applyStyle(StyleOrigin.USER, \"bar\");\n+        setAnimationTime(499);\n+        assertEquals(\"foo\", property.get());\n+        setAnimationTime(500);\n+        assertEquals(\"bar\", property.get());\n+\n+        \/\/ This is a reversing transition, so it only needs half the time to flip the value.\n+        property.applyStyle(StyleOrigin.USER, \"foo\");\n+        setAnimationTime(749);\n+        assertEquals(\"bar\", property.get());\n+        setAnimationTime(750);\n+        assertEquals(\"foo\", property.get());\n+    }\n+\n+    @Test\n+    void testNonInterpolatableObjectTransitionsAsDiscrete() {\n+        enum Fruit { APPLE, ORANGE }\n+\n+        CssMetaData<Styleable, Fruit> metadata = new CssMetaData<>(\n+                \"-fx-fruit\", StyleConverter.getEnumConverter(Fruit.class), Fruit.APPLE) {\n+            @Override public boolean isSettable(Styleable styleable) { return true; }\n+            @Override public StyleableProperty<Fruit> getStyleableProperty(Styleable styleable) {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+\n+        var bean = new Group();\n+        NodeHelper.getTransitionProperty(bean).setValue(new TransitionDefinition[] {\n+            new TransitionDefinition(\"-fx-fruit\", ONE_SECOND, Duration.ZERO, Interpolator.LINEAR)\n+        });\n+\n+        ((Group)scene.getRoot()).getChildren().setAll(bean);\n+        var property = new SimpleStyleableObjectProperty<Fruit>(metadata, bean, null);\n+\n+        \/\/ Setting a value for the first time doesn't start a transition.\n+        setAnimationTime(0);\n+        property.applyStyle(StyleOrigin.USER, Fruit.APPLE);\n+\n+        \/\/ Start the transition and sample the outputs.\n+        property.applyStyle(StyleOrigin.USER, Fruit.ORANGE);\n+        setAnimationTime(499);\n+        assertSame(Fruit.APPLE, property.get());\n+        setAnimationTime(500);\n+        assertSame(Fruit.ORANGE, property.get());\n+\n+        \/\/ This is a reversing transition, so it only needs half the time to flip the value.\n+        property.applyStyle(StyleOrigin.USER, Fruit.APPLE);\n+        setAnimationTime(749);\n+        assertSame(Fruit.ORANGE, property.get());\n+        setAnimationTime(750);\n+        assertSame(Fruit.APPLE, property.get());\n+    }\n+\n+    @Test\n+    void testNullObjectTransitionsAsDiscrete_withInterpolatableValue() {\n+        ((Group)scene.getRoot()).getChildren().setAll(testBean);\n+        var property = new SimpleStyleableObjectProperty<>(interpolatableObjectPropertyMetadata, testBean, null);\n+\n+        \/\/ Setting a value for the first time doesn't start a transition.\n+        setAnimationTime(0);\n+        property.applyStyle(StyleOrigin.USER, Color.RED);\n+\n+        \/\/ Start the transition and sample the outputs.\n+        property.applyStyle(StyleOrigin.USER, null);\n+        setAnimationTime(499);\n+        assertSame(Color.RED, property.get());\n+        setAnimationTime(500);\n+        assertNull(property.get());\n+\n+        \/\/ This is a reversing transition, so it only needs half the time to flip the value.\n+        property.applyStyle(StyleOrigin.USER, Color.RED);\n+        setAnimationTime(749);\n+        assertNull(property.get());\n+        setAnimationTime(750);\n+        assertSame(Color.RED, property.get());\n+    }\n+\n+    @Test\n+    void testNullObjectTransitionsAsDiscrete_withComponentTransitionableValue() {\n+        ((Group)scene.getRoot()).getChildren().setAll(testBean);\n+        var property = new SimpleStyleableObjectProperty<>(componentTransitionableObjectPropertyMetadata, testBean, null);\n+\n+        \/\/ Setting a value for the first time doesn't start a transition.\n+        setAnimationTime(0);\n+        property.applyStyle(StyleOrigin.USER, Background.fill(Color.RED));\n+\n+        \/\/ Start the transition and sample the outputs.\n+        property.applyStyle(StyleOrigin.USER, null);\n+        setAnimationTime(499);\n+        assertEquals(Background.fill(Color.RED), property.get());\n+        setAnimationTime(500);\n+        assertNull(property.get());\n+\n+        \/\/ This is a reversing transition, so it only needs half the time to flip the value.\n+        property.applyStyle(StyleOrigin.USER, Background.fill(Color.RED));\n+        setAnimationTime(749);\n+        assertNull(property.get());\n+        setAnimationTime(750);\n+        assertEquals(Background.fill(Color.RED), property.get());\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/css\/StyleableProperty_transition_Test.java","additions":293,"deletions":56,"binary":false,"changes":349,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\n+import org.junit.jupiter.api.Nested;\n@@ -31,4 +31,2 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -65,0 +63,26 @@\n+    }\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenTwoDifferentValuesReturnsNewInstance() {\n+            var startValue = new Insets(2, 4, 6, 8);\n+            var endValue = new Insets(4, 8, 12, 16);\n+            var expected = new Insets(3, 6, 9, 12);\n+            assertEquals(expected, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsStartInstance() {\n+            var startValue = new Insets(2, 4, 6, 8);\n+            var endValue = new Insets(2, 4, 6, 8);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new Insets(2, 4, 6, 8);\n+            var endValue = new Insets(4, 8, 12, 16);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n@@ -66,0 +90,7 @@\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new Insets(2, 4, 6, 8);\n+            var endValue = new Insets(4, 8, 12, 16);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/geometry\/InsetsTest.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import java.util.Map;\n+\n@@ -186,1 +188,1 @@\n-        List<TransitionTimer> timers = NodeShim.getTransitionTimers(node);\n+        Map<String, TransitionTimer> timers = NodeShim.getTransitionTimers(node);\n@@ -194,1 +196,1 @@\n-        assertNotNull(timers.get(0));\n+        assertNotNull(timers.values().iterator().next());\n@@ -223,1 +225,1 @@\n-        assertEquals(0, NodeShim.getTransitionTimers(node).size());\n+        assertNull(NodeShim.getTransitionTimers(node));\n@@ -248,1 +250,1 @@\n-        assertEquals(0, NodeShim.getTransitionTimers(node).size());\n+        assertNull(NodeShim.getTransitionTimers(node));\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/Node_transition_Test.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.layout;\n+\n+import com.sun.javafx.css.SubPropertyConverter;\n+import com.sun.javafx.tk.Toolkit;\n+import javafx.geometry.Insets;\n+import javafx.scene.image.Image;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.BackgroundFill;\n+import javafx.scene.layout.BackgroundImage;\n+import javafx.scene.layout.BackgroundPosition;\n+import javafx.scene.layout.BackgroundRepeat;\n+import javafx.scene.layout.BackgroundShim;\n+import javafx.scene.layout.BackgroundSize;\n+import javafx.scene.layout.CornerRadii;\n+import javafx.scene.paint.Color;\n+import org.junit.jupiter.api.Test;\n+import test.com.sun.javafx.pgstub.StubImageLoaderFactory;\n+import test.com.sun.javafx.pgstub.StubPlatformImageInfo;\n+import test.com.sun.javafx.pgstub.StubToolkit;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class BackgroundConverterTest {\n+\n+    private static final String IMAGE_URL = \"file:red.png\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private final SubPropertyConverter<Background> converter = (SubPropertyConverter<Background>)BackgroundShim.getConverter();\n+    private final StubImageLoaderFactory imageLoaderFactory = ((StubToolkit)Toolkit.getToolkit()).getImageLoaderFactory();\n+    private final Image image;\n+\n+    BackgroundConverterTest() {\n+        imageLoaderFactory.reset();\n+        imageLoaderFactory.registerImage(IMAGE_URL, new StubPlatformImageInfo(57, 41));\n+        image = new Image(IMAGE_URL);\n+    }\n+\n+    @Test\n+    void convertBackgroundImageFromURL() {\n+        var background = converter.convert(Map.of(BackgroundShim.BACKGROUND_IMAGE, new String[] {IMAGE_URL}));\n+        assertEquals(1, background.getImages().size());\n+        assertEquals(IMAGE_URL, background.getImages().get(0).getImage().getUrl());\n+    }\n+\n+    @Test\n+    void convertBackgroundImageFromImage() {\n+        var background = converter.convert(Map.of(BackgroundShim.BACKGROUND_IMAGE, new Image[] { image }));\n+        assertEquals(1, background.getImages().size());\n+        assertSame(image, background.getImages().get(0).getImage());\n+    }\n+\n+    @Test\n+    void convertBackgroundImageFromUnexpectedObjectFails() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+            converter.convert(Map.of(BackgroundShim.BACKGROUND_IMAGE, new Object[] { 1.0 })));\n+    }\n+\n+    @Test\n+    void convertBackDoesNotAcceptNull() {\n+        assertThrows(NullPointerException.class, () -> converter.convertBack(null));\n+    }\n+\n+    @Test\n+    void reconstructedObjectMustBeEqual() {\n+        var expected = new Background(\n+            List.of(new BackgroundFill(Color.RED, new CornerRadii(5, true), new Insets(2)),\n+                    new BackgroundFill(Color.GREEN, new CornerRadii(10, false), new Insets(1, 2, 3, 4))),\n+            List.of(new BackgroundImage(image, BackgroundRepeat.REPEAT, BackgroundRepeat.ROUND,\n+                                        BackgroundPosition.CENTER, BackgroundSize.DEFAULT))\n+        );\n+\n+        var actual = converter.convert(converter.convertBack(expected));\n+        assertEquals(expected, actual);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundConverterTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import javafx.scene.image.Image;\n@@ -32,1 +33,5 @@\n-\n+import javafx.scene.paint.ImagePattern;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.RadialGradient;\n+import java.io.ByteArrayInputStream;\n+import org.junit.jupiter.api.Nested;\n@@ -34,2 +39,3 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n+\n+import static com.sun.javafx.util.InterpolationUtils.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -112,0 +118,117 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void twoColorFills() {\n+            BackgroundFill startValue = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(Color.RED, new CornerRadii(4), new Insets(6));\n+            BackgroundFill actual = startValue.interpolate(endValue, 0.5);\n+            assertEquals(Color.ORANGE.interpolate(Color.RED, 0.5), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+        }\n+\n+        @Test\n+        public void twoLinearGradientFills() {\n+            var gradient1 = LinearGradient.valueOf(\"linear-gradient(to left top, red, blue)\");\n+            var gradient2 = LinearGradient.valueOf(\"linear-gradient(to left top, yellow, white)\");\n+            BackgroundFill startValue = new BackgroundFill(gradient1, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(gradient2, new CornerRadii(4), new Insets(6));\n+            BackgroundFill actual = startValue.interpolate(endValue, 0.5);\n+            assertEquals(gradient1.interpolate(gradient2, 0.5), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+        }\n+\n+        @Test\n+        public void linearGradientAndColorFills() {\n+            var gradient = LinearGradient.valueOf(\"linear-gradient(to left top, red, blue)\");\n+            BackgroundFill startValue = new BackgroundFill(gradient, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(Color.ORANGE, new CornerRadii(4), new Insets(6));\n+\n+            BackgroundFill actual = startValue.interpolate(endValue, 0.5);\n+            assertEquals(gradient.interpolate(newSolidGradient(gradient, Color.ORANGE), 0.5), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+\n+            actual = endValue.interpolate(startValue, 0.5);\n+            assertEquals(newSolidGradient(gradient, Color.ORANGE).interpolate(gradient, 0.5), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+        }\n+\n+        @Test\n+        public void twoRadialGradientFills() {\n+            var gradient1 = RadialGradient.valueOf(\"radial-gradient(radius 100%, red, blue)\");\n+            var gradient2 = RadialGradient.valueOf(\"radial-gradient(radius 50%, yellow, white)\");\n+            BackgroundFill startValue = new BackgroundFill(gradient1, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(gradient2, new CornerRadii(4), new Insets(6));\n+            BackgroundFill actual = startValue.interpolate(endValue, 0.5);\n+            assertEquals(gradient1.interpolate(gradient2, 0.5), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+        }\n+\n+        @Test\n+        public void radialGradientAndColorFills() {\n+            var gradient = RadialGradient.valueOf(\"radial-gradient(radius 100%, red, blue)\");\n+            BackgroundFill startValue = new BackgroundFill(gradient, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(Color.ORANGE, new CornerRadii(4), new Insets(6));\n+\n+            BackgroundFill actual = startValue.interpolate(endValue, 0.5);\n+            assertEquals(gradient.interpolate(newSolidGradient(gradient, Color.ORANGE), 0.5), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+\n+            actual = endValue.interpolate(startValue, 0.5);\n+            assertEquals(newSolidGradient(gradient, Color.ORANGE).interpolate(gradient, 0.5), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+        }\n+\n+        @Test\n+        public void incompatibleFillsReturnsStartFillOrEndFill() {\n+            var imagePattern = new ImagePattern(new Image(new ByteArrayInputStream(new byte[] {})));\n+            BackgroundFill startValue = new BackgroundFill(imagePattern, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(Color.RED, new CornerRadii(4), new Insets(6));\n+            BackgroundFill actual;\n+\n+            actual = startValue.interpolate(endValue, 0.25);\n+            assertEquals(startValue.getFill(), actual.getFill());\n+            assertEquals(new CornerRadii(2.5), actual.getRadii());\n+            assertEquals(new Insets(3), actual.getInsets());\n+\n+            actual = startValue.interpolate(endValue, 0.5);\n+            assertEquals(endValue.getFill(), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+\n+            actual = startValue.interpolate(endValue, 0.75);\n+            assertEquals(endValue.getFill(), actual.getFill());\n+            assertEquals(new CornerRadii(3.5), actual.getRadii());\n+            assertEquals(new Insets(5), actual.getInsets());\n+        }\n+\n+        @Test\n+        public void twoEqualFillsReturnsExistingInstance() {\n+            BackgroundFill startValue = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            BackgroundFill startValue = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(Color.RED, new CornerRadii(4), new Insets(6));\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            BackgroundFill startValue = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(Color.RED, new CornerRadii(4), new Insets(6));\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundFillTest.java","additions":126,"deletions":3,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -35,5 +37,1 @@\n-\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -251,0 +249,53 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        final BackgroundImage BACKGROUND_IMAGE_A = new BackgroundImage(\n+            IMAGE_1, NO_REPEAT, NO_REPEAT,\n+            new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false),\n+            new BackgroundSize(50, 100, false, false, false, false));\n+\n+        final BackgroundImage BACKGROUND_IMAGE_B = new BackgroundImage(\n+            IMAGE_2, REPEAT, SPACE,\n+            new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false),\n+            new BackgroundSize(100, 200, false, false, false, false));\n+\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var expect = new BackgroundImage(\n+                IMAGE_2, REPEAT, SPACE,\n+                new BackgroundPosition(Side.LEFT, 5, false, Side.TOP, 10, false),\n+                new BackgroundSize(75, 150, false, false, false, false));\n+\n+            var actual = BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, 0.5);\n+\n+            assertEquals(expect, actual);\n+            assertNotSame(expect, actual);\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var startValue = new BackgroundImage(\n+                IMAGE_1, NO_REPEAT, NO_REPEAT,\n+                new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false),\n+                new BackgroundSize(50, 100, false, false, false, false));\n+\n+            var endValue = new BackgroundImage(\n+                IMAGE_1, NO_REPEAT, NO_REPEAT,\n+                new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false),\n+                new BackgroundSize(50, 100, false, false, false, false));\n+\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            assertSame(BACKGROUND_IMAGE_A, BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, 0));\n+            assertSame(BACKGROUND_IMAGE_A, BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            assertSame(BACKGROUND_IMAGE_B, BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, 1));\n+            assertSame(BACKGROUND_IMAGE_B, BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundImageTest.java","additions":56,"deletions":5,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-\n+import org.junit.jupiter.api.Nested;\n@@ -32,4 +32,2 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -40,1 +38,2 @@\n-    @Test public void valuesAreCorrectAfterConstruction() {\n+    @Test\n+    public void valuesAreCorrectAfterConstruction() {\n@@ -181,0 +180,95 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateComponentWithAbsoluteAndPercentageMismatch() {\n+            record TestCase(BackgroundPosition endValue, BackgroundPosition expected) {}\n+\n+            final double v0 = 0, v25 = 10, v50 = 20, v100 = 40;\n+            final var startValue = new BackgroundPosition(Side.LEFT, v0, false, Side.TOP, v0, false);\n+\n+            \/\/ For each component: interpolation with t=0.25 returns start value on absolute\/percentage mismatch.\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new BackgroundPosition(Side.LEFT, v100, false, Side.TOP, v100, false),\n+                    new BackgroundPosition(Side.LEFT, v25, false, Side.TOP, v25, false)),\n+                new TestCase(\n+                    new BackgroundPosition(Side.LEFT, v100, true, Side.TOP, v100, false),\n+                    new BackgroundPosition(Side.LEFT, v0, false, Side.TOP, v25, false)),\n+                new TestCase(\n+                    new BackgroundPosition(Side.LEFT, v100, false, Side.TOP, v100, true),\n+                    new BackgroundPosition(Side.LEFT, v25, false, Side.TOP, v0, false))\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.25));\n+            }\n+\n+            \/\/ For each component: interpolation with t=0.5 returns end value on absolute\/percentage mismatch.\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new BackgroundPosition(Side.LEFT, v100, false, Side.TOP, v100, false),\n+                    new BackgroundPosition(Side.LEFT, v50, false, Side.TOP, v50, false)),\n+                new TestCase(\n+                    new BackgroundPosition(Side.LEFT, v100, true, Side.TOP, v100, false),\n+                    new BackgroundPosition(Side.LEFT, v100, true, Side.TOP, v50, false)),\n+                new TestCase(\n+                    new BackgroundPosition(Side.LEFT, v100, false, Side.TOP, v100, true),\n+                    new BackgroundPosition(Side.LEFT, v50, false, Side.TOP, v100, true))\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.5));\n+            }\n+        }\n+\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var endValue = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            var expected = new BackgroundPosition(Side.LEFT, 5, false, Side.TOP, 10, false);\n+            assertEquals(expected, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var startValue = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            var endValue = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.75));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var endValue = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var endValue = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+\n+        @Test\n+        public void percentageAndAbsolutePositionsCannotBeInterpolated() {\n+            var startValue = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var endValue = new BackgroundPosition(Side.LEFT, 10, true, Side.TOP, 20, true);\n+            assertEquals(startValue, startValue.interpolate(endValue, 0.25)); \/\/ equal to 'startValue' for t < 0.5\n+            assertEquals(endValue, startValue.interpolate(endValue, 0.5)); \/\/ equal to 'endValue' otherwise\n+        }\n+\n+        @Test\n+        public void differentSidesCannotBeInterpolated() {\n+            var startValue = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var endValue = new BackgroundPosition(Side.RIGHT, 10, false, Side.TOP, 20, false);\n+            var expect = new BackgroundPosition(Side.RIGHT, 10, false, Side.TOP, 10, false);\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+\n+            startValue = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            endValue = new BackgroundPosition(Side.LEFT, 10, false, Side.BOTTOM, 20, false);\n+            expect = new BackgroundPosition(Side.LEFT, 5, false, Side.BOTTOM, 20, false);\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundPositionTest.java","additions":100,"deletions":6,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-\n@@ -31,0 +30,1 @@\n+import org.junit.jupiter.api.Nested;\n@@ -32,4 +32,3 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import static javafx.scene.layout.BackgroundSize.AUTO;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -120,1 +119,1 @@\n-        assertEquals(BackgroundSize.AUTO, size.getWidth(), 0);\n+        assertEquals(AUTO, size.getWidth(), 0);\n@@ -170,1 +169,1 @@\n-        assertEquals(BackgroundSize.AUTO, size.getHeight(), 0);\n+        assertEquals(AUTO, size.getHeight(), 0);\n@@ -297,0 +296,105 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateComponentWithAbsoluteAndPercentageMismatch() {\n+            record TestCase(BackgroundSize endValue, BackgroundSize expected) {}\n+\n+            final double v0 = 0, v25 = 10, v50 = 20, v100 = 40;\n+            final var startValue = new BackgroundSize(v0, v0, false, false, false, false);\n+\n+            \/\/ For each component: interpolation with t=0.25 returns start value on absolute\/percentage mismatch.\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new BackgroundSize(v100, v100, false, false, false, false),\n+                    new BackgroundSize(v25, v25, false, false, false, false)),\n+                new TestCase(\n+                    new BackgroundSize(v100, v100, true, false, false, false),\n+                    new BackgroundSize(v0, v25, false, false, false, false)),\n+                new TestCase(\n+                    new BackgroundSize(v100, v100, false, true, false, false),\n+                    new BackgroundSize(v25, v0, false, false, false, false))\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.25));\n+            }\n+\n+            \/\/ For each component: interpolation with t=0.5 returns end value on absolute\/percentage mismatch.\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new BackgroundSize(v100, v100, false, false, false, false),\n+                    new BackgroundSize(v50, v50, false, false, false, false)),\n+                new TestCase(\n+                    new BackgroundSize(v100, v100, true, false, false, false),\n+                    new BackgroundSize(v100, v50, true, false, false, false)),\n+                new TestCase(\n+                    new BackgroundSize(v100, v100, false, true, false, false),\n+                    new BackgroundSize(v50, v100, false, true, false, false))\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.5));\n+            }\n+        }\n+\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new BackgroundSize(10, 20, false, false, false, false);\n+            var endValue = new BackgroundSize(20, 40, false, false, false, false);\n+            var expect = new BackgroundSize(15, 30, false, false, false, false);\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var startValue = new BackgroundSize(10, 20, false, false, false, false);\n+            var endValue = new BackgroundSize(10, 20, false, false, false, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.75));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new BackgroundSize(10, 20, false, false, false, false);\n+            var endValue = new BackgroundSize(20, 40, false, false, false, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new BackgroundSize(10, 20, false, false, false, false);\n+            var endValue = new BackgroundSize(20, 40, false, false, false, false);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+\n+        @Test\n+        public void widthOrHeightLessThanZeroCannotBeInterpolated() {\n+            var startValue = new BackgroundSize(10, 20, false, false, false, false);\n+            var endValue = new BackgroundSize(AUTO, 40, false, false, false, false);\n+            var expect = new BackgroundSize(AUTO, 30, false, false, false, false);\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+\n+            startValue = new BackgroundSize(20, 10, false, false, false, false);\n+            endValue = new BackgroundSize(40, AUTO, false, false, false, false);\n+            expect = new BackgroundSize(30, AUTO, false, false, false, false);\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void notInterpolatableReturnsStartOrEndInstance() {\n+            var startValue = new BackgroundSize(10, 10, false, false, false, true);\n+            var endValue = new BackgroundSize(20, 20, false, false, false, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+\n+            startValue = new BackgroundSize(10, 10, false, false, false, false);\n+            endValue = new BackgroundSize(20, 20, false, false, true, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+\n+            startValue = new BackgroundSize(AUTO, AUTO, false, false, false, false);\n+            endValue = new BackgroundSize(20, 20, false, false, false, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundSizeTest.java","additions":111,"deletions":7,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import javafx.scene.layout.BackgroundSize;\n@@ -38,0 +39,3 @@\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import java.util.List;\n@@ -40,7 +44,1 @@\n-\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -802,0 +800,86 @@\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new Background(\n+                List.of(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)),\n+                        new BackgroundFill(Color.BLUE, new CornerRadii(2), new Insets(2))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 5, false),\n+                                            new BackgroundSize(10, 10, false, false, false, false))));\n+\n+            var endValue = new Background(\n+                List.of(new BackgroundFill(Color.GREEN, new CornerRadii(20), new Insets(20)),\n+                        new BackgroundFill(Color.YELLOW, new CornerRadii(6), new Insets(6))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 20, false, Side.TOP, 15, false),\n+                                            new BackgroundSize(20, 30, false, false, false, false))));\n+\n+            var expect = new Background(\n+                List.of(new BackgroundFill(Color.RED.interpolate(Color.GREEN, 0.5), new CornerRadii(15), new Insets(15)),\n+                        new BackgroundFill(Color.BLUE.interpolate(Color.YELLOW, 0.5), new CornerRadii(4), new Insets(4))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 15, false, Side.TOP, 10, false),\n+                                            new BackgroundSize(15, 20, false, false, false, false))));\n+\n+            var actual = startValue.interpolate(endValue, 0.5);\n+\n+            assertEquals(expect, actual);\n+            assertNotSame(expect, actual);\n+        }\n+\n+        @Test\n+        public void interpolateBetweenDifferentNumberOfFillsAndImages() {\n+            var startValue = new Background(\n+                List.of(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 5, false),\n+                                            new BackgroundSize(10, 10, false, false, false, false))));\n+\n+            var endValue = new Background(\n+                List.of(new BackgroundFill(Color.GREEN, new CornerRadii(20), new Insets(20)),\n+                        new BackgroundFill(Color.BLUE, new CornerRadii(2), new Insets(2))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 20, false, Side.TOP, 15, false),\n+                                            new BackgroundSize(20, 30, false, false, false, false)),\n+                        new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 30, false, Side.TOP, 40, false),\n+                                            new BackgroundSize(50, 60, false, false, false, false))));\n+\n+            var expect = new Background(\n+                List.of(new BackgroundFill(Color.RED.interpolate(Color.GREEN, 0.5), new CornerRadii(15), new Insets(15)),\n+                        new BackgroundFill(Color.BLUE, new CornerRadii(2), new Insets(2))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 15, false, Side.TOP, 10, false),\n+                                            new BackgroundSize(15, 20, false, false, false, false)),\n+                        new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 30, false, Side.TOP, 40, false),\n+                                            new BackgroundSize(50, 60, false, false, false, false))));\n+\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var startValue = new Background(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)));\n+            var endValue = new Background(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new Background(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)));\n+            var endValue = new Background(new BackgroundFill(Color.GREEN, new CornerRadii(15), new Insets(20)));\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new Background(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)));\n+            var endValue = new Background(new BackgroundFill(Color.GREEN, new CornerRadii(15), new Insets(20)));\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundTest.java","additions":91,"deletions":7,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.layout;\n+\n+import com.sun.javafx.css.SubPropertyConverter;\n+import com.sun.javafx.tk.Toolkit;\n+import javafx.geometry.Insets;\n+import javafx.scene.image.Image;\n+import javafx.scene.layout.Border;\n+import javafx.scene.layout.BorderImage;\n+import javafx.scene.layout.BorderRepeat;\n+import javafx.scene.layout.BorderShim;\n+import javafx.scene.layout.BorderStroke;\n+import javafx.scene.layout.BorderStrokeStyle;\n+import javafx.scene.layout.BorderWidths;\n+import javafx.scene.layout.CornerRadii;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.CycleMethod;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.Stop;\n+import org.junit.jupiter.api.Test;\n+import test.com.sun.javafx.pgstub.StubImageLoaderFactory;\n+import test.com.sun.javafx.pgstub.StubPlatformImageInfo;\n+import test.com.sun.javafx.pgstub.StubToolkit;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class BorderConverterTest {\n+\n+    private static final String IMAGE_URL = \"file:red.png\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private final SubPropertyConverter<Border> converter = (SubPropertyConverter<Border>)BorderShim.getConverter();\n+    private final StubImageLoaderFactory imageLoaderFactory = ((StubToolkit)Toolkit.getToolkit()).getImageLoaderFactory();\n+    private final Image image;\n+\n+    BorderConverterTest() {\n+        imageLoaderFactory.reset();\n+        imageLoaderFactory.registerImage(IMAGE_URL, new StubPlatformImageInfo(57, 41));\n+        image = new Image(IMAGE_URL);\n+    }\n+\n+    @Test\n+    void convertBorderImageFromURL() {\n+        var border = converter.convert(Map.of(BorderShim.BORDER_IMAGE_SOURCE, new String[] {IMAGE_URL}));\n+        assertEquals(1, border.getImages().size());\n+        assertEquals(IMAGE_URL, border.getImages().get(0).getImage().getUrl());\n+    }\n+\n+    @Test\n+    void convertBorderImageFromImage() {\n+        var border = converter.convert(Map.of(BorderShim.BORDER_IMAGE_SOURCE, new Image[] { image }));\n+        assertEquals(1, border.getImages().size());\n+        assertSame(image, border.getImages().get(0).getImage());\n+    }\n+\n+    @Test\n+    void convertBorderImageFromUnexpectedObjectFails() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+            converter.convert(Map.of(BorderShim.BORDER_IMAGE_SOURCE, new Object[] { 1.0 })));\n+    }\n+\n+    @Test\n+    void convertBackDoesNotAcceptNull() {\n+        assertThrows(NullPointerException.class, () -> converter.convertBack(null));\n+    }\n+\n+    @Test\n+    void reconstructedObjectMustBeEqual() {\n+        var expected = new Border(\n+            List.of(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, CornerRadii.EMPTY, BorderWidths.EMPTY),\n+                    new BorderStroke(new LinearGradient(0.1, 0.2, 0.3, 0.4, true, CycleMethod.REPEAT,\n+                                                        new Stop(0, Color.BLUE), new Stop(0.5, Color.YELLOW)),\n+                                     BorderStrokeStyle.SOLID, CornerRadii.EMPTY, BorderWidths.EMPTY)),\n+            List.of(new BorderImage(image, BorderWidths.FULL, Insets.EMPTY, BorderWidths.DEFAULT,\n+                                    false, BorderRepeat.STRETCH, BorderRepeat.REPEAT))\n+        );\n+\n+        var actual = converter.convert(converter.convertBack(expected));\n+        assertEquals(expected, actual);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BorderConverterTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.layout;\n+\n+import javafx.geometry.Insets;\n+import javafx.scene.image.Image;\n+import javafx.scene.layout.BorderImage;\n+import javafx.scene.layout.BorderRepeat;\n+import javafx.scene.layout.BorderWidths;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class BorderImageTest {\n+\n+    private static final Image IMAGE_1 = new Image(\"test\/javafx\/scene\/layout\/red.png\");\n+    private static final Image IMAGE_2 = new Image(\"test\/javafx\/scene\/layout\/blue.png\");\n+\n+    @Nested\n+    class InterpolationTests {\n+        final BorderImage BORDER_IMAGE_A = new BorderImage(\n+            IMAGE_1, new BorderWidths(10), new Insets(8), new BorderWidths(6),\n+            false, BorderRepeat.REPEAT, BorderRepeat.REPEAT);\n+\n+        final BorderImage BORDER_IMAGE_B = new BorderImage(\n+            IMAGE_2, new BorderWidths(20), new Insets(4), new BorderWidths(12),\n+            false, BorderRepeat.REPEAT, BorderRepeat.REPEAT);\n+\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var image = new BorderImage(\n+                IMAGE_2, new BorderWidths(15), new Insets(6), new BorderWidths(9),\n+                false, BorderRepeat.REPEAT, BorderRepeat.REPEAT);\n+\n+            assertEquals(image, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var image = new BorderImage(\n+                IMAGE_1, new BorderWidths(10), new Insets(8), new BorderWidths(6),\n+                false, BorderRepeat.REPEAT, BorderRepeat.REPEAT);\n+\n+            assertSame(image, image.interpolate(BORDER_IMAGE_A, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            assertSame(BORDER_IMAGE_A, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, 0));\n+            assertSame(BORDER_IMAGE_A, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            assertSame(BORDER_IMAGE_B, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, 1));\n+            assertSame(BORDER_IMAGE_B, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, 1.5));\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BorderImageTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -28,0 +28,5 @@\n+import javafx.geometry.Insets;\n+import javafx.scene.layout.BorderStroke;\n+import javafx.scene.layout.BorderWidths;\n+import javafx.scene.layout.CornerRadii;\n+import org.junit.jupiter.api.Nested;\n@@ -30,0 +35,4 @@\n+import static javafx.scene.layout.BorderStrokeStyle.*;\n+import static javafx.scene.paint.Color.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -37,0 +46,34 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            var endValue = new BorderStroke(GREEN, DOTTED, new CornerRadii(20), new BorderWidths(15), new Insets(6));\n+            var expect = new BorderStroke(RED.interpolate(GREEN, 0.5), DOTTED, new CornerRadii(15), new BorderWidths(10), new Insets(4));\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var startValue = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            var endValue = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            var endValue = new BorderStroke(GREEN, SOLID, new CornerRadii(20), new BorderWidths(15), new Insets(6));\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            var endValue = new BorderStroke(GREEN, SOLID, new CornerRadii(20), new BorderWidths(15), new Insets(6));\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BorderStrokeTest.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.List;\n@@ -39,2 +40,1 @@\n-import static javafx.scene.layout.BorderRepeat.*;\n-\n+import org.junit.jupiter.api.Nested;\n@@ -42,5 +42,3 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import static javafx.scene.layout.BorderRepeat.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -641,0 +639,70 @@\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new Border(\n+                List.of(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)),\n+                        new BorderStroke(Color.BLUE, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20))),\n+                List.of(new BorderImage(IMAGE_1, new BorderWidths(10), new Insets(5), new BorderWidths(10), false, REPEAT, REPEAT)));\n+\n+            var endValue = new Border(\n+                List.of(new BorderStroke(Color.GREEN, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20)),\n+                        new BorderStroke(Color.YELLOW, BorderStrokeStyle.SOLID, new CornerRadii(40), new BorderWidths(40))),\n+                List.of(new BorderImage(IMAGE_2, new BorderWidths(30), new Insets(15), new BorderWidths(30), false, REPEAT, REPEAT)));\n+\n+            var expect = new Border(\n+                List.of(new BorderStroke(Color.RED.interpolate(Color.GREEN, 0.5), BorderStrokeStyle.SOLID, new CornerRadii(15), new BorderWidths(15)),\n+                        new BorderStroke(Color.BLUE.interpolate(Color.YELLOW, 0.5), BorderStrokeStyle.SOLID, new CornerRadii(30), new BorderWidths(30))),\n+                List.of(new BorderImage(IMAGE_2, new BorderWidths(20), new Insets(10), new BorderWidths(20), false, REPEAT, REPEAT)));\n+\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenDifferentNumberOfStrokesAndImages() {\n+            var startValue = new Border(\n+                List.of(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10))),\n+                List.of(new BorderImage(IMAGE_1, new BorderWidths(10), new Insets(5), new BorderWidths(10), false, REPEAT, REPEAT)));\n+\n+            var endValue = new Border(\n+                List.of(new BorderStroke(Color.GREEN, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20)),\n+                        new BorderStroke(Color.YELLOW, BorderStrokeStyle.SOLID, new CornerRadii(40), new BorderWidths(40))),\n+                List.of(new BorderImage(IMAGE_1, new BorderWidths(30), new Insets(15), new BorderWidths(30), false, REPEAT, REPEAT),\n+                        new BorderImage(IMAGE_2, new BorderWidths(30), new Insets(15), new BorderWidths(30), false, REPEAT, REPEAT)));\n+\n+            var expect = new Border(\n+                List.of(new BorderStroke(Color.RED.interpolate(Color.GREEN, 0.5), BorderStrokeStyle.SOLID, new CornerRadii(15), new BorderWidths(15)),\n+                        new BorderStroke(Color.YELLOW, BorderStrokeStyle.SOLID, new CornerRadii(40), new BorderWidths(40))),\n+                List.of(new BorderImage(IMAGE_1, new BorderWidths(20), new Insets(10), new BorderWidths(20), false, REPEAT, REPEAT),\n+                        new BorderImage(IMAGE_2, new BorderWidths(30), new Insets(15), new BorderWidths(30), false, REPEAT, REPEAT)));\n+\n+            var actual = startValue.interpolate(endValue, 0.5);\n+\n+            assertEquals(expect, actual);\n+            assertNotSame(expect, actual);\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var startValue = new Border(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)));\n+            var endValue = new Border(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new Border(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)));\n+            var endValue = new Border(new BorderStroke(Color.GREEN, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20)));\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new Border(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)));\n+            var endValue = new Border(new BorderStroke(Color.GREEN, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20)));\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BorderTest.java","additions":75,"deletions":7,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\n+import org.junit.jupiter.api.Nested;\n@@ -31,4 +31,2 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -247,0 +245,97 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateComponentWithAbsoluteAndPercentageMismatch() {\n+            record TestCase(BorderWidths endValue, BorderWidths expected) {}\n+\n+            final double v0 = 10, v25 = 12.5, v50 = 15, v100 = 20;\n+            final var startValue = new BorderWidths(v0, v0, v0, v0, false, false, false, false);\n+\n+            \/\/ For each component: interpolation with t=0.25 returns start value on absolute\/percentage mismatch\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, false, false, false),\n+                    new BorderWidths(v25, v25, v25, v25, false, false, false, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, true, false, false, false),\n+                    new BorderWidths(v0, v25, v25, v25, false, false, false, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, true, false, false),\n+                    new BorderWidths(v25, v0, v25, v25, false, false, false, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, false, true, false),\n+                    new BorderWidths(v25, v25, v0, v25, false, false, false, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, false, false, true),\n+                    new BorderWidths(v25, v25, v25, v0, false, false, false, false))\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.25));\n+            }\n+\n+            \/\/ For each component: interpolation with t=0.5 returns end value on absolute\/percentage mismatch\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, false, false, false),\n+                    new BorderWidths(v50, v50, v50, v50, false, false, false, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, true, false, false, false),\n+                    new BorderWidths(v100, v50, v50, v50, true, false, false, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, true, false, false),\n+                    new BorderWidths(v50, v100, v50, v50, false, true, false, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, false, true, false),\n+                    new BorderWidths(v50, v50, v100, v50, false, false, true, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, false, false, true),\n+                    new BorderWidths(v50, v50, v50, v100, false, false, false, true))\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.5));\n+            }\n+        }\n+\n+        @Test\n+        public void interpolateReturnsStartOrEndInstanceWhenResultIsEqual() {\n+            var startValue = new BorderWidths(10, 20, 30, 40, true, true, true, true);\n+            var endValue = new BorderWidths(20, 40, 60, 80, false, false, false, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            var endValue = new BorderWidths(20, 40, 60, 80, true, false, true, false);\n+            var expect = new BorderWidths(15, 30, 45, 60, true, false, true, false);\n+            var actual = startValue.interpolate(endValue, 0.5);\n+            assertEquals(expect, actual);\n+            assertNotSame(startValue, actual);\n+            assertNotSame(endValue, actual);\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var startValue = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            var endValue = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.75));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            var endValue = new BorderWidths(20, 40, 60, 80, true, false, true, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            var endValue = new BorderWidths(20, 40, 60, 80, true, false, true, false);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BorderWidthsTest.java","additions":100,"deletions":5,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -64,0 +64,31 @@\n+    @Test\n+    public void equality() {\n+        for (int i = 0; i < 8; ++i) {\n+            double[] r = new double[8];\n+            boolean[] p = new boolean[8];\n+\n+            r[i] = 1;\n+            p[i] = true;\n+\n+            var expected = new CornerRadii(\n+                r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7],\n+                p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);\n+\n+            var a = new CornerRadii(\n+                r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7],\n+                p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);\n+\n+            assertEquals(expected, a);\n+\n+            \/\/ change one radius at a time\n+            r[i] = 0;\n+            p[i] = false;\n+\n+            var b = new CornerRadii(\n+                r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7],\n+                p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);\n+\n+            assertNotEquals(expected, b);\n+        }\n+    }\n+\n@@ -126,0 +157,141 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateComponentWithAbsoluteAndPercentageMismatch() {\n+            record TestCase(CornerRadii endValue, CornerRadii expected) {}\n+\n+            final double v0 = 10, v25 = 12.5, v50 = 15, v100 = 20;\n+            final var startValue = new CornerRadii(\n+                v0, v0, v0, v0, v0, v0, v0, v0, false, false, false, false, false, false, false, false);\n+\n+            \/\/ For each component: interpolation with t=0.25 returns start value on absolute\/percentage mismatch.\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, false, false, false),\n+                    new CornerRadii(v25, v25, v25, v25, v25, v25, v25, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, true, false, false, false, false, false, false, false),\n+                    new CornerRadii(v0, v25, v25, v25, v25, v25, v25, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, true, false, false, false, false, false, false),\n+                    new CornerRadii(v25, v0, v25, v25, v25, v25, v25, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, true, false, false, false, false, false),\n+                    new CornerRadii(v25, v25, v0, v25, v25, v25, v25, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, true, false, false, false, false),\n+                    new CornerRadii(v25, v25, v25, v0, v25, v25, v25, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, true, false, false, false),\n+                    new CornerRadii(v25, v25, v25, v25, v0, v25, v25, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, true, false, false),\n+                    new CornerRadii(v25, v25, v25, v25, v25, v0, v25, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, false, true, false),\n+                    new CornerRadii(v25, v25, v25, v25, v25, v25, v0, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, false, false, true),\n+                    new CornerRadii(v25, v25, v25, v25, v25, v25, v25, v0, false, false, false, false, false, false, false, false)),\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.25));\n+            }\n+\n+            \/\/ For each component: interpolation with t=0.5 returns end value on absolute\/percentage mismatch\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, false, false, false),\n+                    new CornerRadii(v50, v50, v50, v50, v50, v50, v50, v50, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, true, false, false, false, false, false, false, false),\n+                    new CornerRadii(v100, v50, v50, v50, v50, v50, v50, v50, true, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, true, false, false, false, false, false, false),\n+                    new CornerRadii(v50, v100, v50, v50, v50, v50, v50, v50, false, true, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, true, false, false, false, false, false),\n+                    new CornerRadii(v50, v50, v100, v50, v50, v50, v50, v50, false, false, true, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, true, false, false, false, false),\n+                    new CornerRadii(v50, v50, v50, v100, v50, v50, v50, v50, false, false, false, true, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, true, false, false, false),\n+                    new CornerRadii(v50, v50, v50, v50, v100, v50, v50, v50, false, false, false, false, true, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, true, false, false),\n+                    new CornerRadii(v50, v50, v50, v50, v50, v100, v50, v50, false, false, false, false, false, true, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, false, true, false),\n+                    new CornerRadii(v50, v50, v50, v50, v50, v50, v100, v50, false, false, false, false, false, false, true, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, false, false, true),\n+                    new CornerRadii(v50, v50, v50, v50, v50, v50, v50, v100, false, false, false, false, false, false, false, true)),\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.5));\n+            }\n+        }\n+\n+        @Test\n+        public void interpolateReturnsStartOrEndInstanceWhenResultIsEqual() {\n+            \/\/ non-uniform values\n+            var startValue = new CornerRadii(10, 20, 30, 40, true);\n+            var endValue = new CornerRadii(20, 40, 60, 80, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+\n+            \/\/ uniform values\n+            startValue = new CornerRadii(10, true);\n+            endValue = new CornerRadii(20, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            \/\/ non-uniform values\n+            var startValue = new CornerRadii(10, 20, 30, 40, false);\n+            var endValue = new CornerRadii(20, 40, 60, 80, false);\n+            var expect = new CornerRadii(15, 30, 45, 60, false);\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+\n+            \/\/ uniform values\n+            startValue = new CornerRadii(10, 10, 10, 10, false);\n+            endValue = new CornerRadii(20, 20, 20, 20, false);\n+            expect = new CornerRadii(15, 15, 15, 15, false);\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            \/\/ non-uniform values\n+            var startValue = new CornerRadii(10, 20, 30, 40, false);\n+            var endValue = new CornerRadii(10, 20, 30, 40, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.75));\n+\n+            \/\/ uniform values\n+            startValue = new CornerRadii(10, 10, 10, 10, false);\n+            endValue = new CornerRadii(10, 10, 10, 10, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.75));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new CornerRadii(10, 20, 30, 40, false);\n+            var endValue = new CornerRadii(20, 30, 40, 50, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new CornerRadii(10, 20, 30, 40, false);\n+            var endValue = new CornerRadii(20, 30, 40, 50, false);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/CornerRadiiTest.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-\n+import javafx.scene.paint.Paint;\n+import org.junit.jupiter.api.Nested;\n@@ -36,5 +37,2 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -133,1 +131,1 @@\n-        Interpolatable<Color> start = new Color(0, 0, 0, 0);\n+        Interpolatable<Paint> start = new Color(0, 0, 0, 0);\n@@ -135,1 +133,1 @@\n-        Color mid = start.interpolate(end, .5);\n+        Color mid = (Color)start.interpolate(end, .5);\n@@ -1007,0 +1005,33 @@\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenTwoDifferentValuesReturnsNewInstance() {\n+            var startValue = new Color(0.2, 0.4, 0.6, 0.8);\n+            var endValue = new Color(0.3, 0.5, 0.7, 0.9);\n+            assertEquals(new Color(0.25, 0.45, 0.65, 0.85), startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsSameInstance() {\n+            var startValue = new Color(0.2, 0.4, 0.6, 0.8);\n+            var endValue = new Color(0.2, 0.4, 0.6, 0.8);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new Color(0.2, 0.4, 0.6, 0.8);\n+            var endValue = new Color(0.3, 0.5, 0.7, 0.9);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new Color(0.2, 0.4, 0.6, 0.8);\n+            var endValue = new Color(0.3, 0.5, 0.7, 0.9);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/ColorTest.java","additions":39,"deletions":8,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -36,6 +37,1 @@\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -93,1 +89,46 @@\n-\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var image = createImage();\n+            var startValue = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var endValue = new ImagePattern(image, 20, 30, 40, 50, false);\n+            var expected = new ImagePattern(image, 15, 25, 35, 45, false);\n+            assertEquals(expected, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenProportionalAndNonProportionalReturnsStartInstanceOrEndInstance() {\n+            var image = createImage();\n+            var startValue = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var endValue = new ImagePattern(image, 20, 30, 40, 50, true);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsStartInstance() {\n+            var image = createImage();\n+            var startValue = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var endValue = new ImagePattern(image, 10, 20, 30, 40, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var image = createImage();\n+            var startValue = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var endValue = new ImagePattern(image, 20, 30, 40, 50, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var image = createImage();\n+            var startValue = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var endValue = new ImagePattern(image, 20, 30, 40, 50, false);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/ImagePatternTest.java","additions":49,"deletions":8,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-\n+import org.junit.jupiter.api.Nested;\n@@ -39,7 +39,2 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assertions.fail;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -471,0 +466,87 @@\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLACK), new Stop(1, Color.WHITE)));\n+\n+            var endValue = new LinearGradient(\n+                20, 40, 60, 80,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.WHITE), new Stop(1, Color.BLACK)));\n+\n+            var expected = new LinearGradient(\n+                15, 30, 45, 60,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.gray(0.5)), new Stop(1, Color.gray(0.5))));\n+\n+            assertEquals(expected, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenProportionalAndNonProportionalReturnsStartValuesOrEndValues() {\n+            var startValue = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new LinearGradient(\n+                10, 20, 30, 40,\n+                false, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.75));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsStartInstance() {\n+            var startValue = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new LinearGradient(\n+                20, 40, 60, 80,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.RED)));\n+\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new LinearGradient(\n+                20, 40, 60, 80,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.RED)));\n+\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/LinearGradientTest.java","additions":90,"deletions":8,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-\n+import org.junit.jupiter.api.Nested;\n@@ -39,7 +39,2 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assertions.fail;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -499,0 +494,87 @@\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLACK), new Stop(1, Color.WHITE)));\n+\n+            var endValue = new RadialGradient(\n+                20, 40, 60, 80, 100,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.WHITE), new Stop(1, Color.BLACK)));\n+\n+            var expected = new RadialGradient(\n+                15, 30, 45, 60, 75,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.gray(0.5)), new Stop(1, Color.gray(0.5))));\n+\n+            assertEquals(expected, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenProportionalAndNonProportionalReturnsStartInstanceOrEndInstance() {\n+            var startValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                false, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.75));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsStartInstance() {\n+            var startValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.RED)));\n+\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.RED)));\n+\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/RadialGradientTest.java","additions":90,"deletions":8,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-\n+import javafx.scene.paint.StopShim;\n+import org.junit.jupiter.api.Nested;\n@@ -37,1 +38,2 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -153,0 +155,143 @@\n+\n+    @Test\n+    public void testInterpolateStop() {\n+        assertSame(zerostop, zerostop.interpolate(onestop, -0.5));\n+        assertSame(zerostop, zerostop.interpolate(onestop, 0));\n+        assertSame(onestop, zerostop.interpolate(onestop, 1));\n+        assertSame(onestop, zerostop.interpolate(onestop, 1.5));\n+        assertEquals(new Stop(0.5, color2), zerostop.interpolate(onestop, 0.5));\n+    }\n+\n+    @Nested\n+    class ListInterpolationTest {\n+        @Test\n+        public void returnFirstListBeforeInterval() {\n+            var firstList = List.of(new Stop(0, color1), new Stop(1, color3));\n+            var secondList = List.of(new Stop(0, color3), new Stop(1, color1));\n+            assertSame(firstList, StopShim.interpolateLists(firstList, secondList, 0));\n+            assertSame(firstList, StopShim.interpolateLists(firstList, secondList, -0.5));\n+        }\n+\n+        @Test\n+        public void returnSecondListAfterInterval() {\n+            var firstList = List.of(new Stop(0, color1), new Stop(1, color3));\n+            var secondList = List.of(new Stop(0, color3), new Stop(1, color1));\n+            assertSame(secondList, StopShim.interpolateLists(firstList, secondList, 1));\n+            assertSame(secondList, StopShim.interpolateLists(firstList, secondList, 1.5));\n+        }\n+\n+        @Test\n+        public void sameSize_sameOffsets() {\n+            var firstList = List.of(new Stop(0, color1), new Stop(1, color3));\n+            var secondList = List.of(new Stop(0, color3), new Stop(1, color1));\n+            var res = StopShim.interpolateLists(firstList, secondList, 0.5);\n+            assertEquals(List.of(\n+                new Stop(0, color2),\n+                new Stop(1, color2)),\n+            res);\n+        }\n+\n+        @Test\n+        public void sameSize_differentOffsets() {\n+            double t = 0.5;\n+            var firstList = normalize(List.of(new Stop(0.1, color1), new Stop(0.9, color3)));\n+            var secondList = normalize(List.of(new Stop(0.2, color3), new Stop(0.8, color1)));\n+            var res = StopShim.interpolateLists(firstList, secondList, t);\n+            assertEquals(List.of(\n+                new Stop(0, color2),\n+                new Stop(0.1, color2),\n+                new Stop(0.2, color1.interpolate(color3, 0.125).interpolate(color3, t)),\n+                new Stop(0.8, color1.interpolate(color3, 0.875).interpolate(color1, t)),\n+                new Stop(0.9, color2),\n+                new Stop(1, color2)),\n+            res);\n+        }\n+\n+        @Test\n+        public void firstListLargerThanSecondList_sameFirstAndLastOffset() {\n+            var firstList = normalize(List.of(new Stop(0, color1), new Stop(0.5, color3), new Stop(1, color1)));\n+            var secondList = normalize(List.of(new Stop(0, color1), new Stop(1, color3)));\n+\n+            var expected = List.of(\n+                new Stop(0, color1),\n+                new Stop(0.5, color2.interpolate(color3, 0.5)),\n+                new Stop(1, color2));\n+            assertEquals(expected, StopShim.interpolateLists(firstList, secondList, 0.5));\n+\n+            \/\/ An interpolation factor close to zero should yield a stop list very similar to the first list\n+            expected = firstList;\n+            assertSimilar(expected, StopShim.interpolateLists(firstList, secondList, 0.001));\n+\n+            \/\/ An interpolation factor close to one should yield a stop list very similar to the second list,\n+            \/\/ but with a different number of stops (3 instead of 2).\n+            expected = List.of(new Stop(0, color1), new Stop(0.5, color2), new Stop(1, color3));\n+            assertSimilar(expected, StopShim.interpolateLists(firstList, secondList, 0.999));\n+        }\n+\n+        @Test\n+        public void firstListSmallerThanSecondList_sameFirstAndLastOffset() {\n+            var firstList = normalize(List.of(new Stop(0, color1), new Stop(1, color3)));\n+            var secondList = normalize(List.of(new Stop(0, color1), new Stop(0.5, color3), new Stop(1, color1)));\n+\n+            var expected = List.of(\n+                new Stop(0, color1),\n+                new Stop(0.5, color2.interpolate(color3, 0.5)),\n+                new Stop(1, color2));\n+            assertEquals(expected, StopShim.interpolateLists(firstList, secondList, 0.5));\n+\n+            \/\/ An interpolation factor close to zero should yield a stop list very similar to the first list,\n+            \/\/ but with a different number of stops (3 instead of 2).\n+            expected = List.of( new Stop(0, color1), new Stop(0.5, color2), new Stop(1, color3));\n+            assertSimilar(expected, StopShim.interpolateLists(firstList, secondList, 0.001));\n+\n+            \/\/ An interpolation factor close to one should yield a stop list very similar to the second list.\n+            expected = secondList;\n+            assertSimilar(expected, StopShim.interpolateLists(firstList, secondList, 0.999));\n+        }\n+\n+        @Test\n+        public void differentSize_differentOffsets() {\n+            double t = 0.5;\n+            var firstList = normalize(List.of(new Stop(0, color1), new Stop(1, color3)));\n+            var secondList = normalize(List.of(new Stop(0.25, color3), new Stop(0.75, color1)));\n+            var res = StopShim.interpolateLists(firstList, secondList, t);\n+            assertEquals(List.of(\n+                new Stop(0, color2),\n+                new Stop(0.25, color1.interpolate(color3, 0.25).interpolate(color3, t)),\n+                new Stop(0.75, color1.interpolate(color3, 0.75).interpolate(color1, t)),\n+                new Stop(1, color2)),\n+            res);\n+        }\n+\n+        @Test\n+        public void interpolatedVirtualStopIsEqualToExistingStop() {\n+            double t = 0.5;\n+            var firstList = normalize(List.of(new Stop(0, color1), new Stop(1, color3)));\n+            var secondList = normalize(List.of(new Stop(0, color3), new Stop(0.5, color2), new Stop(1, color1)));\n+            var res = StopShim.interpolateLists(firstList, secondList, t);\n+            assertEquals(List.of(\n+                new Stop(0, color2),\n+                new Stop(0.5, color2),\n+                new Stop(1, color2)),\n+            res);\n+        }\n+\n+        private void assertSimilar(List<Stop> a, List<Stop> b) {\n+            assertEquals(a.size(), b.size());\n+            for (int i = 0; i < a.size(); ++i) {\n+                assertSimilar(a.get(i), b.get(i));\n+            }\n+        }\n+\n+        private void assertSimilar(Stop a, Stop b) {\n+            assertSimilar(a.getColor(), b.getColor());\n+            assertTrue(Math.abs(a.getOffset() - b.getOffset()) < 0.1);\n+        }\n+\n+        private void assertSimilar(Color a, Color b) {\n+            assertTrue(Math.abs(a.getRed() - b.getRed()) < 0.01);\n+            assertTrue(Math.abs(a.getGreen() - b.getGreen()) < 0.01);\n+            assertTrue(Math.abs(a.getBlue() - b.getBlue()) < 0.01);\n+            assertTrue(Math.abs(a.getOpacity() - b.getOpacity()) < 0.01);\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/StopListTest.java","additions":147,"deletions":2,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-\n+import org.junit.jupiter.api.Nested;\n@@ -32,4 +32,3 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import static javafx.scene.paint.Color.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -50,0 +49,6 @@\n+    @Test\n+    public void testNullColorIsTransparent() {\n+        var stop = new Stop(0.2f, null);\n+        assertEquals(TRANSPARENT, stop.getColor());\n+    }\n+\n@@ -59,2 +64,0 @@\n-        Stop nullColor = new Stop(0.2f, null);\n-        Stop nullColor2 = new Stop(0.2f, null);\n@@ -68,2 +71,0 @@\n-        assertTrue(nullColor.equals(nullColor2));\n-        assertFalse(nullColor.equals(basic));\n@@ -104,0 +105,33 @@\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenTwoDifferentValuesReturnsNewInstance() {\n+            var startValue = new Stop(0, RED);\n+            var endValue = new Stop(1, GREEN);\n+            assertEquals(new Stop(0.5, RED.interpolate(GREEN, 0.5)), startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsSameInstance() {\n+            var startValue = new Stop(0.25, RED);\n+            var endValue = new Stop(0.25, RED);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new Stop(0.25, RED);\n+            var endValue = new Stop(0.75, GREEN);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new Stop(0.25, RED);\n+            var endValue = new Stop(0.75, GREEN);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/StopTest.java","additions":43,"deletions":9,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+        var tab4 = new Tab(\"backgrounds\", new ScrollPane(createBackgroundTransitionsTab()));\n+        var tab5 = new Tab(\"borders\", new ScrollPane(createBorderTransitionsTab()));\n@@ -51,1 +53,1 @@\n-        var tabPane = new TabPane(tab1, tab2, tab3);\n+        var tabPane = new TabPane(tab1, tab2, tab3, tab4, tab5);\n@@ -118,0 +120,69 @@\n+\n+    private Region createBackgroundTransitionsTab() {\n+        return createContent(\"\"\"\n+            .rect {\n+              -fx-min-width: 100;\n+              -fx-min-height: 50;\n+              transition: all 2s;\n+            }\n+\n+            .rect:hover {\n+              -fx-min-width: 300;\n+            }\n+\n+            \/\/ Color transition\n+            #rect1 { -fx-background-color: red; }\n+            #rect1:hover { -fx-background-color: blue; }\n+\n+            \/\/ LinearGradient transition\n+            #rect2 { -fx-background-color: linear-gradient(to right, red, blue); }\n+            #rect2:hover { -fx-background-color: linear-gradient(to right, purple, yellow); }\n+\n+            \/\/ LinearGradient transition with different number of stops\n+            #rect3 { -fx-background-color: linear-gradient(to right, red, green); }\n+            #rect3:hover { -fx-background-color: linear-gradient(to right, red, yellow, blue); }\n+\n+            \/\/ RadialGradient transition with different number of stops\n+            #rect4 { -fx-background-color: radial-gradient(radius 100%, red, green); }\n+            #rect4:hover { -fx-background-color: radial-gradient(radius 100%, red, yellow, blue); }\n+            \"\"\",\n+            new RectInfo(\"#rect1\", \"rect1\"),\n+            new RectInfo(\"#rect2\", \"rect2\"),\n+            new RectInfo(\"#rect3\", \"rect3\"),\n+            new RectInfo(\"#rect4\", \"rect4\"));\n+    }\n+\n+    private Region createBorderTransitionsTab() {\n+        return createContent(\"\"\"\n+            .rect {\n+              -fx-min-width: 100;\n+              -fx-min-height: 50;\n+              -fx-border-width: 10;\n+              transition: all 2s;\n+            }\n+\n+            .rect:hover {\n+              -fx-min-width: 300;\n+            }\n+\n+            \/\/ Color transition\n+            #rect1 { -fx-border-color: red; }\n+            #rect1:hover { -fx-border-color: blue; }\n+\n+            \/\/ LinearGradient transition\n+            #rect2 { -fx-border-color: linear-gradient(to right, red, blue); }\n+            #rect2:hover { -fx-border-color: linear-gradient(to right, purple, yellow); }\n+\n+            \/\/ LinearGradient transition with different number of stops\n+            #rect3 { -fx-border-color: linear-gradient(to right, red, green); }\n+            #rect3:hover { -fx-border-color: linear-gradient(to right, red, yellow, blue); }\n+\n+            \/\/ RadialGradient transition with different number of stops\n+            #rect4 { -fx-border-color: radial-gradient(radius 100%, red, green); }\n+            #rect4:hover { -fx-border-color: radial-gradient(radius 100%, red, yellow, blue); }\n+            \"\"\",\n+            new RectInfo(\"#rect1\", \"rect1\"),\n+            new RectInfo(\"#rect2\", \"rect2\"),\n+            new RectInfo(\"#rect3\", \"rect3\"),\n+            new RectInfo(\"#rect4\", \"rect4\"));\n+    }\n","filename":"tests\/manual\/graphics\/CssTransitionsTest.java","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"}]}