{"files":[{"patch":"@@ -28,1 +28,1 @@\n-import com.sun.javafx.util.Utils;\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -72,1 +72,1 @@\n-            Utils.interpolateDiscrete(filled, endValue.filled, t));\n+            InterpolationUtils.interpolateDiscrete(filled, endValue.filled, t));\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/layout\/region\/BorderImageSlices.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -36,1 +37,0 @@\n-import com.sun.javafx.util.Utils;\n@@ -88,1 +88,1 @@\n-            return Utils.interpolateDiscrete(this, endValue, t);\n+            return InterpolationUtils.interpolateDiscrete(this, endValue, t);\n@@ -92,4 +92,4 @@\n-            Utils.interpolate(top, endValue.top, t),\n-            Utils.interpolate(right, endValue.right, t),\n-            Utils.interpolate(bottom, endValue.bottom, t),\n-            Utils.interpolate(left, endValue.left, t),\n+            InterpolationUtils.interpolate(top, endValue.top, t),\n+            InterpolationUtils.interpolate(right, endValue.right, t),\n+            InterpolationUtils.interpolate(bottom, endValue.bottom, t),\n+            InterpolationUtils.interpolate(left, endValue.left, t),\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/layout\/region\/Margins.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.scene.paint;\n-\n-import javafx.scene.paint.Color;\n-import javafx.scene.paint.ImagePattern;\n-import javafx.scene.paint.LinearGradient;\n-import javafx.scene.paint.Paint;\n-import javafx.scene.paint.RadialGradient;\n-import javafx.scene.paint.Stop;\n-import java.util.List;\n-\n-public final class PaintUtils {\n-\n-    private PaintUtils() {}\n-\n-    \/**\n-     * Interpolates between potentially different types of paint.\n-     * <p>\n-     * In addition to homogeneous interpolations between paints of the same type, the following\n-     * heterogeneous interpolations are supported:\n-     * <ul>\n-     *     <li>Color ↔ LinearGradient\n-     *     <li>Color ↔ RadialGradient\n-     * <\/ul>\n-     * If a paint is not interpolatable, {@code startValue} is returned for {@code t < 0.5},\n-     * and {@code endValue} is returned otherwise.\n-     *\/\n-    public static Paint interpolate(Paint startValue, Paint endValue, double t) {\n-        if (startValue instanceof Color start) {\n-            if (endValue instanceof Color end) {\n-                return start.interpolate(end, t);\n-            }\n-\n-            if (endValue instanceof LinearGradient end) {\n-                return newSolidGradient(end, start).interpolate(end, t);\n-            }\n-\n-            if (endValue instanceof RadialGradient end) {\n-                return newSolidGradient(end, start).interpolate(end, t);\n-            }\n-        }\n-\n-        if (startValue instanceof LinearGradient start) {\n-            if (endValue instanceof LinearGradient end) {\n-                return start.interpolate(end, t);\n-            }\n-\n-            if (endValue instanceof Color end) {\n-                return start.interpolate(newSolidGradient(start, end), t);\n-            }\n-        }\n-\n-        if (startValue instanceof RadialGradient start) {\n-            if (endValue instanceof RadialGradient end) {\n-                return start.interpolate(end, t);\n-            }\n-\n-            if (endValue instanceof Color end) {\n-                return start.interpolate(newSolidGradient(start, end), t);\n-            }\n-        }\n-\n-        if (startValue instanceof ImagePattern start && endValue instanceof ImagePattern end) {\n-            return start.interpolate(end, t);\n-        }\n-\n-        return t < 0.5 ? startValue : endValue;\n-    }\n-\n-    \/**\n-     * Creates a new linear gradient that consists of two stops with the same color.\n-     *\/\n-    public static LinearGradient newSolidGradient(LinearGradient source, Color color) {\n-        return new LinearGradient(\n-                source.getStartX(), source.getStartY(),\n-                source.getEndX(), source.getEndY(),\n-                source.isProportional(),\n-                source.getCycleMethod(),\n-                List.of(new Stop(0, color), new Stop(1, color)));\n-    }\n-\n-    \/**\n-     * Creates a new radial gradient that consists of two stops with the same color.\n-     *\/\n-    public static RadialGradient newSolidGradient(RadialGradient source, Color color) {\n-        return new RadialGradient(\n-                source.getFocusAngle(), source.getFocusDistance(),\n-                source.getCenterX(), source.getCenterY(),\n-                source.getRadius(),\n-                source.isProportional(),\n-                source.getCycleMethod(),\n-                List.of(new Stop(0, color), new Stop(1, color)));\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/paint\/PaintUtils.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -0,0 +1,409 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.util;\n+\n+import com.sun.javafx.UnmodifiableArrayList;\n+import javafx.animation.Interpolatable;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.ImagePattern;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.Paint;\n+import javafx.scene.paint.RadialGradient;\n+import javafx.scene.paint.Stop;\n+import java.lang.reflect.Array;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public final class InterpolationUtils {\n+\n+    private InterpolationUtils() {}\n+\n+    \/**\n+     * Utility function that interpolates between two double values.\n+     *\/\n+    public static double interpolate(double from, double to, double t) {\n+        return from + t * (to - from);\n+    }\n+\n+    \/**\n+     * Utility function that interpolates between two discrete values, returning {@code from}\n+     * when {@code t < 0.5}, and {@code to} otherwise.\n+     *\/\n+    public static <T> T interpolateDiscrete(T from, T to, double t) {\n+        return t < 0.5 ? from : to;\n+    }\n+\n+    \/**\n+     * Utility function that interpolates between two discrete values, returning {@code from}\n+     * when {@code t < 0.5}, and {@code to} otherwise.\n+     *\/\n+    public static double interpolateDiscrete(double from, double to, double t) {\n+        return t < 0.5 ? from : to;\n+    }\n+\n+    \/**\n+     * Computes an intermediate list that consists of the pairwise interpolation between two lists,\n+     * using the following rules:\n+     * <ol>\n+     *     <li>The size of the returned list corresponds to the size of the second list.\n+     *     <li>If the first list has fewer elements than the second list, the missing elements are copied\n+     *         from the second list.\n+     *     <li>If the first list has more elements than the second list, the excess elements are discarded.\n+     *     <li>If the intermediate list is shallow-equal to the first list passed into the method (i.e. its\n+     *         elements are references to the same objects), the existing list is returned.\n+     *     <li>If a new list is returned, it is unmodifiable.\n+     * <\/ol>\n+     * This method preferably returns existing list instances (i.e. the {@code firstList} or\n+     * {@code secondList} arguments) as an indication to the caller that the result is shallow-equal\n+     * to either of the input arguments.\n+     *\n+     * @param firstList the first list, not {@code null}\n+     * @param secondList the second list, not {@code null}\n+     * @return the intermediate list\n+     *\/\n+    public static <T extends Interpolatable<T>> List<T> interpolateListsPairwise(\n+            List<T> firstList, List<T> secondList, double t) {\n+        Objects.requireNonNull(firstList, \"firstList\");\n+        Objects.requireNonNull(secondList, \"secondList\");\n+\n+        if (secondList.isEmpty()) {\n+            return firstList.isEmpty() ? firstList : secondList;\n+        }\n+\n+        int listSize = firstList.size();\n+\n+        \/\/ For small equisized lists (up to 8 elements), we use an optimization to prevent the allocation\n+        \/\/ of a new array in case the intermediate list would be equal to the existing list.\n+        if (listSize <= 8 && listSize == secondList.size()) {\n+            return interpolateEquisizedListsPairwise(firstList, secondList, t);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newArray = (T[])new Interpolatable[secondList.size()];\n+        boolean equal = firstList.size() == secondList.size();\n+\n+        for (int i = 0, firstListSize = firstList.size(); i < newArray.length; ++i) {\n+            if (firstListSize > i) {\n+                newArray[i] = firstList.get(i).interpolate(secondList.get(i), t);\n+                equal &= newArray[i] == firstList.get(i);\n+            } else {\n+                newArray[i] = secondList.get(i);\n+            }\n+        }\n+\n+        return equal ? firstList : new UnmodifiableArrayList<>(newArray, newArray.length);\n+    }\n+\n+    \/**\n+     * Computes an intermediate list that consists of the pairwise interpolation between two lists\n+     * of equal size, each containing up to 8 elements.\n+     * <p>\n+     * This method is an optimization: it does not allocate memory when the intermediate list is\n+     * shallow-equal to the list that is passed into this method, i.e. its elements are references\n+     * to the same objects. The existing list is returned in this case.\n+     *\/\n+    private static <T extends Interpolatable<T>> List<T> interpolateEquisizedListsPairwise(\n+            List<T> firstList, List<T> secondList, double t) {\n+        int listSize = firstList.size();\n+        if (listSize > 8 || listSize != secondList.size()) {\n+            throw new AssertionError();\n+        }\n+\n+        T item0 = null, item1 = null, item2 = null, item3 = null, item4 = null, item5 = null, item6 = null, item7 = null;\n+        boolean same = true;\n+\n+        switch (listSize) { \/\/ fall-through intended\n+            case 8: item7 = firstList.get(7).interpolate(secondList.get(7), t);\n+                    same &= item7 == firstList.get(7);\n+            case 7: item6 = firstList.get(6).interpolate(secondList.get(6), t);\n+                    same &= item6 == firstList.get(6);\n+            case 6: item5 = firstList.get(5).interpolate(secondList.get(5), t);\n+                    same &= item5 == firstList.get(5);\n+            case 5: item4 = firstList.get(4).interpolate(secondList.get(4), t);\n+                    same &= item4 == firstList.get(4);\n+            case 4: item3 = firstList.get(3).interpolate(secondList.get(3), t);\n+                    same &= item3 == firstList.get(3);\n+            case 3: item2 = firstList.get(2).interpolate(secondList.get(2), t);\n+                    same &= item2 == firstList.get(2);\n+            case 2: item1 = firstList.get(1).interpolate(secondList.get(1), t);\n+                    same &= item1 == firstList.get(1);\n+            case 1: item0 = firstList.get(0).interpolate(secondList.get(0), t);\n+                    same &= item0 == firstList.get(0);\n+        }\n+\n+        if (same) {\n+            return firstList;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newArray = (T[])new Interpolatable[listSize];\n+\n+        switch (listSize) { \/\/ fall-through intended\n+            case 8: newArray[7] = item7;\n+            case 7: newArray[6] = item6;\n+            case 6: newArray[5] = item5;\n+            case 5: newArray[4] = item4;\n+            case 4: newArray[3] = item3;\n+            case 3: newArray[2] = item2;\n+            case 2: newArray[1] = item1;\n+            case 1: newArray[0] = item0;\n+        }\n+\n+        return new UnmodifiableArrayList<>(newArray, listSize);\n+    }\n+\n+    \/**\n+     * Computes an intermediate array series that consists of the pairwise interpolation between two\n+     * array series, using the same rules as described in {@link #interpolateArraysPairwise}.\n+     * <p>\n+     * This method preferably returns existing array instances (i.e. the {@code firstArraySeries} or\n+     * {@code secondArraySeries} arguments) as an indication to the caller that the result is shallow-equal\n+     * to either of the input arguments.\n+     *\n+     * @param firstArraySeries the first array series, not {@code null}\n+     * @param secondArraySeries the second array series, not {@code null}\n+     * @return the intermediate array series\n+     *\/\n+    public static <T extends Interpolatable<T>> T[][] interpolateArraySeriesPairwise(\n+            T[][] firstArraySeries, T[][] secondArraySeries, double t) {\n+        Objects.requireNonNull(firstArraySeries, \"firstArraySeries\");\n+        Objects.requireNonNull(secondArraySeries, \"secondArraySeries\");\n+\n+        if (secondArraySeries.length == 0) {\n+            return firstArraySeries.length == 0 ? firstArraySeries : secondArraySeries;\n+        }\n+\n+        Class<?> arrayType = firstArraySeries.getClass().componentType();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[][] newArray = (T[][]) Array.newInstance(arrayType, secondArraySeries.length);\n+        boolean equal = firstArraySeries.length == secondArraySeries.length;\n+\n+        for (int i = 0, firstListSize = firstArraySeries.length; i < newArray.length; ++i) {\n+            if (firstListSize > i) {\n+                newArray[i] = interpolateArraysPairwise(firstArraySeries[i], secondArraySeries[i], t);\n+                equal &= newArray[i] == firstArraySeries[i];\n+            } else {\n+                newArray[i] = secondArraySeries[i];\n+            }\n+        }\n+\n+        return equal ? firstArraySeries : newArray;\n+    }\n+\n+    \/**\n+     * Computes an intermediate array that consists of the pairwise interpolation between two arrays,\n+     * using the following rules:\n+     * <ol>\n+     *     <li>The size of the returned array corresponds to the size of the second array.\n+     *     <li>If the first array has fewer elements than the second array, the missing elements are copied\n+     *         from the second array.\n+     *     <li>If the first array has more elements than the second array, the excess elements are discarded.\n+     *     <li>If the intermediate array is shallow-equal to the first array passed into the method (i.e. its\n+     *         elements are references to the same objects), the existing array is returned.\n+     * <\/ol>\n+     * This method preferably returns existing array instances (i.e. the {@code firstArray} or\n+     * {@code secondArray} arguments) as an indication to the caller that the result is shallow-equal\n+     * to either of the input arguments.\n+     *\n+     * @param firstArray the first array, not {@code null}\n+     * @param secondArray the second array, not {@code null}\n+     * @return the intermediate list\n+     *\/\n+    public static <T extends Interpolatable<T>> T[] interpolateArraysPairwise(\n+            T[] firstArray, T[] secondArray, double t) {\n+        Objects.requireNonNull(firstArray, \"firstArray\");\n+        Objects.requireNonNull(secondArray, \"secondArray\");\n+\n+        if (secondArray.length == 0) {\n+            return firstArray.length == 0 ? firstArray : secondArray;\n+        }\n+\n+        int arraySize = firstArray.length;\n+\n+        \/\/ For small equisized arrays (up to 8 elements), we use an optimization to prevent the allocation\n+        \/\/ of a new array in case the intermediate array would be equal to the existing array.\n+        if (arraySize <= 8 && arraySize == secondArray.length) {\n+            return interpolateEquisizedArraysPairwise(firstArray, secondArray, t);\n+        }\n+\n+        Class<?> componentType = firstArray.getClass().componentType();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newArray = (T[])Array.newInstance(componentType, secondArray.length);\n+        boolean equal = firstArray.length == secondArray.length;\n+\n+        for (int i = 0; i < newArray.length; ++i) {\n+            if (arraySize > i) {\n+                newArray[i] = firstArray[i].interpolate(secondArray[i], t);\n+                equal &= newArray[i] == firstArray[i];\n+            } else {\n+                newArray[i] = secondArray[i];\n+            }\n+        }\n+\n+        return equal ? firstArray : newArray;\n+    }\n+\n+    \/**\n+     * Computes an intermediate array that consists of the pairwise interpolation between two arrays\n+     * of equal size, each containing up to 8 elements.\n+     * <p>\n+     * This method is an optimization: it does not allocate memory when the intermediate array is\n+     * shallow-equal to the array that is passed into this method, i.e. its elements are references\n+     * to the same objects. The existing array is returned in this case.\n+     *\/\n+    private static <T extends Interpolatable<T>> T[] interpolateEquisizedArraysPairwise(\n+            T[] firstArray, T[] secondArray, double t) {\n+        int arraySize = firstArray.length;\n+        if (arraySize > 8 || arraySize != secondArray.length) {\n+            throw new AssertionError();\n+        }\n+\n+        T item0 = null, item1 = null, item2 = null, item3 = null, item4 = null, item5 = null, item6 = null, item7 = null;\n+        boolean same = true;\n+\n+        switch (arraySize) { \/\/ fall-through intended\n+            case 8: item7 = firstArray[7].interpolate(secondArray[7], t);\n+                    same &= item7 == firstArray[7];\n+            case 7: item6 = firstArray[6].interpolate(secondArray[6], t);\n+                    same &= item6 == firstArray[6];\n+            case 6: item5 = firstArray[5].interpolate(secondArray[5], t);\n+                    same &= item5 == firstArray[5];\n+            case 5: item4 = firstArray[4].interpolate(secondArray[4], t);\n+                    same &= item4 == firstArray[4];\n+            case 4: item3 = firstArray[3].interpolate(secondArray[3], t);\n+                    same &= item3 == firstArray[3];\n+            case 3: item2 = firstArray[2].interpolate(secondArray[2], t);\n+                    same &= item2 == firstArray[2];\n+            case 2: item1 = firstArray[1].interpolate(secondArray[1], t);\n+                    same &= item1 == firstArray[1];\n+            case 1: item0 = firstArray[0].interpolate(secondArray[0], t);\n+                    same &= item0 == firstArray[0];\n+        }\n+\n+        if (same) {\n+            return firstArray;\n+        }\n+\n+        Class<?> componentType = firstArray.getClass().componentType();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newArray = (T[])Array.newInstance(componentType, arraySize);\n+\n+        switch (arraySize) { \/\/ fall-through intended\n+            case 8: newArray[7] = item7;\n+            case 7: newArray[6] = item6;\n+            case 6: newArray[5] = item5;\n+            case 5: newArray[4] = item4;\n+            case 4: newArray[3] = item3;\n+            case 3: newArray[2] = item2;\n+            case 2: newArray[1] = item1;\n+            case 1: newArray[0] = item0;\n+        }\n+\n+        return newArray;\n+    }\n+\n+    \/**\n+     * Interpolates between potentially different types of paint.\n+     * <p>\n+     * In addition to homogeneous interpolations between paints of the same type, the following\n+     * heterogeneous interpolations are supported:\n+     * <ul>\n+     *     <li>Color ↔ LinearGradient\n+     *     <li>Color ↔ RadialGradient\n+     * <\/ul>\n+     * If a paint is not interpolatable, {@code startValue} is returned for {@code t < 0.5},\n+     * and {@code endValue} is returned otherwise.\n+     *\/\n+    public static Paint interpolatePaint(Paint startValue, Paint endValue, double t) {\n+        if (startValue instanceof Color start) {\n+            if (endValue instanceof Color end) {\n+                return start.interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof LinearGradient end) {\n+                return newSolidGradient(end, start).interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof RadialGradient end) {\n+                return newSolidGradient(end, start).interpolate(end, t);\n+            }\n+        }\n+\n+        if (startValue instanceof LinearGradient start) {\n+            if (endValue instanceof LinearGradient end) {\n+                return start.interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof Color end) {\n+                return start.interpolate(newSolidGradient(start, end), t);\n+            }\n+        }\n+\n+        if (startValue instanceof RadialGradient start) {\n+            if (endValue instanceof RadialGradient end) {\n+                return start.interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof Color end) {\n+                return start.interpolate(newSolidGradient(start, end), t);\n+            }\n+        }\n+\n+        if (startValue instanceof ImagePattern start && endValue instanceof ImagePattern end) {\n+            return start.interpolate(end, t);\n+        }\n+\n+        return t < 0.5 ? startValue : endValue;\n+    }\n+\n+    \/**\n+     * Creates a new linear gradient that consists of two stops with the same color.\n+     *\/\n+    public static LinearGradient newSolidGradient(LinearGradient source, Color color) {\n+        return new LinearGradient(\n+                source.getStartX(), source.getStartY(),\n+                source.getEndX(), source.getEndY(),\n+                source.isProportional(),\n+                source.getCycleMethod(),\n+                List.of(new Stop(0, color), new Stop(1, color)));\n+    }\n+\n+    \/**\n+     * Creates a new radial gradient that consists of two stops with the same color.\n+     *\/\n+    public static RadialGradient newSolidGradient(RadialGradient source, Color color) {\n+        return new RadialGradient(\n+                source.getFocusAngle(), source.getFocusDistance(),\n+                source.getCenterX(), source.getCenterY(),\n+                source.getRadius(),\n+                source.isProportional(),\n+                source.getCycleMethod(),\n+                List.of(new Stop(0, color), new Stop(1, color)));\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/util\/InterpolationUtils.java","additions":409,"deletions":0,"binary":false,"changes":409,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import javafx.animation.Interpolatable;\n@@ -46,1 +45,0 @@\n-import java.lang.reflect.Array;\n@@ -52,2 +50,0 @@\n-import java.util.Objects;\n-import com.sun.javafx.UnmodifiableArrayList;\n@@ -150,277 +146,0 @@\n-    \/**\n-     * Utility function that interpolates between two double values.\n-     *\/\n-    public static double interpolate(double from, double to, double t) {\n-        return from + t * (to - from);\n-    }\n-\n-    \/**\n-     * Utility function that interpolates between two discrete values, returning {@code from}\n-     * when {@code t < 0.5}, and {@code to} otherwise.\n-     *\/\n-    public static <T> T interpolateDiscrete(T from, T to, double t) {\n-        return t < 0.5 ? from : to;\n-    }\n-\n-    \/**\n-     * Utility function that interpolates between two discrete values, returning {@code from}\n-     * when {@code t < 0.5}, and {@code to} otherwise.\n-     *\/\n-    public static double interpolateDiscrete(double from, double to, double t) {\n-        return t < 0.5 ? from : to;\n-    }\n-\n-    \/**\n-     * Computes an intermediate list that consists of the pairwise interpolation between two lists,\n-     * using the following rules:\n-     * <ol>\n-     *     <li>The size of the returned list corresponds to the size of the second list.\n-     *     <li>If the first list has fewer elements than the second list, the missing elements are copied\n-     *         from the second list.\n-     *     <li>If the first list has more elements than the second list, the excess elements are discarded.\n-     *     <li>If the intermediate list is shallow-equal to the first list passed into the method (i.e. its\n-     *         elements are references to the same objects), the existing list is returned.\n-     *     <li>If a new list is returned, it is unmodifiable.\n-     * <\/ol>\n-     *\n-     * @param firstList the first list, not {@code null}\n-     * @param secondList the second list, not {@code null}\n-     * @return the intermediate list\n-     *\/\n-    public static <T extends Interpolatable<T>> List<T> interpolateListsPairwise(\n-            List<T> firstList, List<T> secondList, double t) {\n-        Objects.requireNonNull(firstList, \"firstList\");\n-        Objects.requireNonNull(secondList, \"secondList\");\n-\n-        if (secondList.isEmpty()) {\n-            return firstList.isEmpty() ? firstList : secondList;\n-        }\n-\n-        int listSize = firstList.size();\n-\n-        \/\/ For small equisized lists (up to 8 elements), we use an optimization to prevent the allocation\n-        \/\/ of a new array in case the intermediate list would be equal to the existing list.\n-        if (listSize <= 8 && listSize == secondList.size()) {\n-            return interpolateEquisizedListsPairwise(firstList, secondList, t);\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        T[] newArray = (T[])new Interpolatable[secondList.size()];\n-        boolean equal = firstList.size() == secondList.size();\n-\n-        for (int i = 0, firstListSize = firstList.size(); i < newArray.length; ++i) {\n-            if (firstListSize > i) {\n-                newArray[i] = firstList.get(i).interpolate(secondList.get(i), t);\n-                equal &= newArray[i] == firstList.get(i);\n-            } else {\n-                newArray[i] = secondList.get(i);\n-            }\n-        }\n-\n-        return equal ? firstList : new UnmodifiableArrayList<>(newArray, newArray.length);\n-    }\n-\n-    \/**\n-     * Computes an intermediate list that consists of the pairwise interpolation between two lists\n-     * of equal size, each containing up to 8 elements.\n-     * <p>\n-     * This method is an optimization: it does not allocate memory when the intermediate list is\n-     * shallow-equal to the list that is passed into this method, i.e. its elements are references\n-     * to the same objects. The existing list is returned in this case.\n-     *\/\n-    private static <T extends Interpolatable<T>> List<T> interpolateEquisizedListsPairwise(\n-            List<T> firstList, List<T> secondList, double t) {\n-        int listSize = firstList.size();\n-        if (listSize > 8 || listSize != secondList.size()) {\n-            throw new AssertionError();\n-        }\n-\n-        T item0 = null, item1 = null, item2 = null, item3 = null, item4 = null, item5 = null, item6 = null, item7 = null;\n-        boolean same = true;\n-\n-        switch (listSize) { \/\/ fall-through intended\n-            case 8: item7 = firstList.get(7).interpolate(secondList.get(7), t);\n-                    same &= item7 == firstList.get(7);\n-            case 7: item6 = firstList.get(6).interpolate(secondList.get(6), t);\n-                    same &= item6 == firstList.get(6);\n-            case 6: item5 = firstList.get(5).interpolate(secondList.get(5), t);\n-                    same &= item5 == firstList.get(5);\n-            case 5: item4 = firstList.get(4).interpolate(secondList.get(4), t);\n-                    same &= item4 == firstList.get(4);\n-            case 4: item3 = firstList.get(3).interpolate(secondList.get(3), t);\n-                    same &= item3 == firstList.get(3);\n-            case 3: item2 = firstList.get(2).interpolate(secondList.get(2), t);\n-                    same &= item2 == firstList.get(2);\n-            case 2: item1 = firstList.get(1).interpolate(secondList.get(1), t);\n-                    same &= item1 == firstList.get(1);\n-            case 1: item0 = firstList.get(0).interpolate(secondList.get(0), t);\n-                    same &= item0 == firstList.get(0);\n-        }\n-\n-        if (same) {\n-            return firstList;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        T[] newArray = (T[])new Interpolatable[listSize];\n-\n-        switch (listSize) { \/\/ fall-through intended\n-            case 8: newArray[7] = item7;\n-            case 7: newArray[6] = item6;\n-            case 6: newArray[5] = item5;\n-            case 5: newArray[4] = item4;\n-            case 4: newArray[3] = item3;\n-            case 3: newArray[2] = item2;\n-            case 2: newArray[1] = item1;\n-            case 1: newArray[0] = item0;\n-        }\n-\n-        return new UnmodifiableArrayList<>(newArray, listSize);\n-    }\n-\n-    \/**\n-     * Computes an intermediate array series that consists of the pairwise interpolation between two\n-     * array series, using the same rules as described in {@link #interpolateArraysPairwise}.\n-     *\n-     * @param firstArraySeries the first array series, not {@code null}\n-     * @param secondArraySeries the second array series, not {@code null}\n-     * @return the intermediate array series\n-     *\/\n-    public static <T extends Interpolatable<T>> T[][] interpolateArraySeriesPairwise(\n-            T[][] firstArraySeries, T[][] secondArraySeries, double t) {\n-        Objects.requireNonNull(firstArraySeries, \"firstArraySeries\");\n-        Objects.requireNonNull(secondArraySeries, \"secondArraySeries\");\n-\n-        if (secondArraySeries.length == 0) {\n-            return firstArraySeries.length == 0 ? firstArraySeries : secondArraySeries;\n-        }\n-\n-        Class<?> arrayType = firstArraySeries.getClass().componentType();\n-\n-        @SuppressWarnings(\"unchecked\")\n-        T[][] newArray = (T[][])Array.newInstance(arrayType, secondArraySeries.length);\n-        boolean equal = firstArraySeries.length == secondArraySeries.length;\n-\n-        for (int i = 0, firstListSize = firstArraySeries.length; i < newArray.length; ++i) {\n-            if (firstListSize > i) {\n-                newArray[i] = interpolateArraysPairwise(firstArraySeries[i], secondArraySeries[i], t);\n-                equal &= newArray[i] == firstArraySeries[i];\n-            } else {\n-                newArray[i] = secondArraySeries[i];\n-            }\n-        }\n-\n-        return equal ? firstArraySeries : newArray;\n-    }\n-\n-    \/**\n-     * Computes an intermediate array that consists of the pairwise interpolation between two arrays,\n-     * using the following rules:\n-     * <ol>\n-     *     <li>The size of the returned array corresponds to the size of the second array.\n-     *     <li>If the first array has fewer elements than the second array, the missing elements are copied\n-     *         from the second array.\n-     *     <li>If the first array has more elements than the second array, the excess elements are discarded.\n-     *     <li>If the intermediate array is shallow-equal to the first array passed into the method (i.e. its\n-     *         elements are references to the same objects), the existing array is returned.\n-     * <\/ol>\n-     *\n-     * @param firstArray the first array, not {@code null}\n-     * @param secondArray the second array, not {@code null}\n-     * @return the intermediate list\n-     *\/\n-    public static <T extends Interpolatable<T>> T[] interpolateArraysPairwise(\n-            T[] firstArray, T[] secondArray, double t) {\n-        Objects.requireNonNull(firstArray, \"firstArray\");\n-        Objects.requireNonNull(secondArray, \"secondArray\");\n-\n-        if (secondArray.length == 0) {\n-            return firstArray.length == 0 ? firstArray : secondArray;\n-        }\n-\n-        int arraySize = firstArray.length;\n-\n-        \/\/ For small equisized arrays (up to 8 elements), we use an optimization to prevent the allocation\n-        \/\/ of a new array in case the intermediate array would be equal to the existing array.\n-        if (arraySize <= 8 && arraySize == secondArray.length) {\n-            return interpolateEquisizedArraysPairwise(firstArray, secondArray, t);\n-        }\n-\n-        Class<?> componentType = firstArray.getClass().componentType();\n-\n-        @SuppressWarnings(\"unchecked\")\n-        T[] newArray = (T[])Array.newInstance(componentType, secondArray.length);\n-        boolean equal = firstArray.length == secondArray.length;\n-\n-        for (int i = 0; i < newArray.length; ++i) {\n-            if (arraySize > i) {\n-                newArray[i] = firstArray[i].interpolate(secondArray[i], t);\n-                equal &= newArray[i] == firstArray[i];\n-            } else {\n-                newArray[i] = secondArray[i];\n-            }\n-        }\n-\n-        return equal ? firstArray : newArray;\n-    }\n-\n-    \/**\n-     * Computes an intermediate array that consists of the pairwise interpolation between two arrays\n-     * of equal size, each containing up to 8 elements.\n-     * <p>\n-     * This method is an optimization: it does not allocate memory when the intermediate array is\n-     * shallow-equal to the array that is passed into this method, i.e. its elements are references\n-     * to the same objects. The existing array is returned in this case.\n-     *\/\n-    private static <T extends Interpolatable<T>> T[] interpolateEquisizedArraysPairwise(\n-            T[] firstArray, T[] secondArray, double t) {\n-        int arraySize = firstArray.length;\n-        if (arraySize > 8 || arraySize != secondArray.length) {\n-            throw new AssertionError();\n-        }\n-\n-        T item0 = null, item1 = null, item2 = null, item3 = null, item4 = null, item5 = null, item6 = null, item7 = null;\n-        boolean same = true;\n-\n-        switch (arraySize) { \/\/ fall-through intended\n-            case 8: item7 = firstArray[7].interpolate(secondArray[7], t);\n-                    same &= item7 == firstArray[7];\n-            case 7: item6 = firstArray[6].interpolate(secondArray[6], t);\n-                    same &= item6 == firstArray[6];\n-            case 6: item5 = firstArray[5].interpolate(secondArray[5], t);\n-                    same &= item5 == firstArray[5];\n-            case 5: item4 = firstArray[4].interpolate(secondArray[4], t);\n-                    same &= item4 == firstArray[4];\n-            case 4: item3 = firstArray[3].interpolate(secondArray[3], t);\n-                    same &= item3 == firstArray[3];\n-            case 3: item2 = firstArray[2].interpolate(secondArray[2], t);\n-                    same &= item2 == firstArray[2];\n-            case 2: item1 = firstArray[1].interpolate(secondArray[1], t);\n-                    same &= item1 == firstArray[1];\n-            case 1: item0 = firstArray[0].interpolate(secondArray[0], t);\n-                    same &= item0 == firstArray[0];\n-        }\n-\n-        if (same) {\n-            return firstArray;\n-        }\n-\n-        Class<?> componentType = firstArray.getClass().componentType();\n-\n-        @SuppressWarnings(\"unchecked\")\n-        T[] newArray = (T[])Array.newInstance(componentType, arraySize);\n-\n-        switch (arraySize) { \/\/ fall-through intended\n-            case 8: newArray[7] = item7;\n-            case 7: newArray[6] = item6;\n-            case 6: newArray[5] = item5;\n-            case 5: newArray[4] = item4;\n-            case 4: newArray[3] = item3;\n-            case 3: newArray[2] = item2;\n-            case 2: newArray[1] = item1;\n-            case 1: newArray[0] = item0;\n-        }\n-\n-        return newArray;\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/util\/Utils.java","additions":0,"deletions":281,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import com.sun.javafx.util.Utils;\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -533,1 +533,1 @@\n-                    value = Utils.interpolateArraySeriesPairwise(ov, nv, progress);\n+                    value = InterpolationUtils.interpolateArraySeriesPairwise(ov, nv, progress);\n@@ -535,1 +535,1 @@\n-                    value = Utils.interpolateArraysPairwise(ov, nv, progress);\n+                    value = InterpolationUtils.interpolateArraysPairwise(ov, nv, progress);\n@@ -539,1 +539,1 @@\n-                    value = Utils.interpolateDiscrete(startValue, endValue, progress);\n+                    value = InterpolationUtils.interpolateDiscrete(startValue, endValue, progress);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableObjectProperty.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- import com.sun.javafx.util.Utils;\n+ import com.sun.javafx.util.InterpolationUtils;\n@@ -132,4 +132,4 @@\n-            Utils.interpolate(top, endValue.top, t),\n-            Utils.interpolate(right, endValue.right, t),\n-            Utils.interpolate(bottom, endValue.bottom, t),\n-            Utils.interpolate(left, endValue.left, t));\n+            InterpolationUtils.interpolate(top, endValue.top, t),\n+            InterpolationUtils.interpolate(right, endValue.right, t),\n+            InterpolationUtils.interpolate(bottom, endValue.bottom, t),\n+            InterpolationUtils.interpolate(left, endValue.left, t));\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/geometry\/Insets.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import com.sun.javafx.util.Utils;\n@@ -54,0 +53,1 @@\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -662,1 +662,1 @@\n-            fills : Utils.interpolateListsPairwise(fills, endValue.fills, t);\n+            fills : InterpolationUtils.interpolateListsPairwise(fills, endValue.fills, t);\n@@ -665,1 +665,1 @@\n-            images : Utils.interpolateListsPairwise(images, endValue.images, t);\n+            images : InterpolationUtils.interpolateListsPairwise(images, endValue.images, t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Background.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import com.sun.javafx.scene.paint.PaintUtils;\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -141,1 +141,1 @@\n-        Paint newFill = PaintUtils.interpolate(fill, endValue.fill, t);\n+        Paint newFill = InterpolationUtils.interpolatePaint(fill, endValue.fill, t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundFill.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import com.sun.javafx.util.Utils;\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -220,1 +220,1 @@\n-            newHorizontalPosition = Utils.interpolate(this.horizontalPosition, endValue.horizontalPosition, t);\n+            newHorizontalPosition = InterpolationUtils.interpolate(this.horizontalPosition, endValue.horizontalPosition, t);\n@@ -235,1 +235,1 @@\n-            newVerticalPosition = Utils.interpolate(this.verticalPosition, endValue.verticalPosition, t);\n+            newVerticalPosition = InterpolationUtils.interpolate(this.verticalPosition, endValue.verticalPosition, t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundPosition.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import com.sun.javafx.util.Utils;\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -266,2 +266,2 @@\n-            Utils.interpolate(start, end, t) :\n-            Utils.interpolateDiscrete(start, end, t);\n+            InterpolationUtils.interpolate(start, end, t) :\n+            InterpolationUtils.interpolateDiscrete(start, end, t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundSize.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import com.sun.javafx.util.Utils;\n@@ -54,0 +53,1 @@\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -435,1 +435,1 @@\n-            images : Utils.interpolateListsPairwise(images, endValue.images, t);\n+            images : InterpolationUtils.interpolateListsPairwise(images, endValue.images, t);\n@@ -438,1 +438,1 @@\n-            strokes : Utils.interpolateListsPairwise(strokes, endValue.strokes, t);\n+            strokes : InterpolationUtils.interpolateListsPairwise(strokes, endValue.strokes, t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Border.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import com.sun.javafx.scene.paint.PaintUtils;\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -415,4 +415,4 @@\n-        Paint newTopStroke = PaintUtils.interpolate(this.topStroke, endValue.topStroke, t);\n-        Paint newRightStroke = PaintUtils.interpolate(this.rightStroke, endValue.rightStroke, t);\n-        Paint newBottomStroke = PaintUtils.interpolate(this.bottomStroke, endValue.bottomStroke, t);\n-        Paint newLeftStroke = PaintUtils.interpolate(this.leftStroke, endValue.leftStroke, t);\n+        Paint newTopStroke = InterpolationUtils.interpolatePaint(this.topStroke, endValue.topStroke, t);\n+        Paint newRightStroke = InterpolationUtils.interpolatePaint(this.rightStroke, endValue.rightStroke, t);\n+        Paint newBottomStroke = InterpolationUtils.interpolatePaint(this.bottomStroke, endValue.bottomStroke, t);\n+        Paint newLeftStroke = InterpolationUtils.interpolatePaint(this.leftStroke, endValue.leftStroke, t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BorderStroke.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import com.sun.javafx.util.Utils;\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -340,2 +340,2 @@\n-            Utils.interpolate(start, end, t) :\n-            Utils.interpolateDiscrete(start, end, t);\n+            InterpolationUtils.interpolate(start, end, t) :\n+            InterpolationUtils.interpolateDiscrete(start, end, t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BorderWidths.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import com.sun.javafx.util.Utils;\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -550,2 +550,2 @@\n-            Utils.interpolate(start, end, t) :\n-            Utils.interpolateDiscrete(start, end, t);\n+            InterpolationUtils.interpolate(start, end, t) :\n+            InterpolationUtils.interpolateDiscrete(start, end, t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/CornerRadii.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.javafx.scene.paint.PaintUtils;\n@@ -32,0 +31,1 @@\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -1975,1 +1975,1 @@\n-        return PaintUtils.interpolate(this, endValue, t);\n+        return InterpolationUtils.interpolatePaint(this, endValue, t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/Color.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import com.sun.javafx.scene.paint.PaintUtils;\n-import com.sun.javafx.util.Utils;\n@@ -34,0 +32,1 @@\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -313,1 +312,1 @@\n-            return Utils.interpolateDiscrete(this, endValue, t);\n+            return InterpolationUtils.interpolateDiscrete(this, endValue, t);\n@@ -317,5 +316,5 @@\n-            Utils.interpolateDiscrete(image, endValue.image, t),\n-            Utils.interpolate(x, endValue.x, t),\n-            Utils.interpolate(y, endValue.y, t),\n-            Utils.interpolate(width, endValue.width, t),\n-            Utils.interpolate(height, endValue.height, t),\n+            InterpolationUtils.interpolateDiscrete(image, endValue.image, t),\n+            InterpolationUtils.interpolate(x, endValue.x, t),\n+            InterpolationUtils.interpolate(y, endValue.y, t),\n+            InterpolationUtils.interpolate(width, endValue.width, t),\n+            InterpolationUtils.interpolate(height, endValue.height, t),\n@@ -333,1 +332,1 @@\n-        return PaintUtils.interpolate(this, endValue, t);\n+        return InterpolationUtils.interpolatePaint(this, endValue, t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/ImagePattern.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import com.sun.javafx.scene.paint.PaintUtils;\n@@ -33,1 +32,1 @@\n-import com.sun.javafx.util.Utils;\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -358,4 +357,4 @@\n-            newStartX = Utils.interpolate(this.startX, endValue.startX, t);\n-            newStartY = Utils.interpolate(this.startY, endValue.startY, t);\n-            newEndX = Utils.interpolate(this.endX, endValue.endX, t);\n-            newEndY = Utils.interpolate(this.endY, endValue.endY, t);\n+            newStartX = InterpolationUtils.interpolate(this.startX, endValue.startX, t);\n+            newStartY = InterpolationUtils.interpolate(this.startY, endValue.startY, t);\n+            newEndX = InterpolationUtils.interpolate(this.endX, endValue.endX, t);\n+            newEndY = InterpolationUtils.interpolate(this.endY, endValue.endY, t);\n@@ -377,1 +376,1 @@\n-        CycleMethod newCycleMethod = Utils.interpolateDiscrete(this.cycleMethod, endValue.cycleMethod, t);\n+        CycleMethod newCycleMethod = InterpolationUtils.interpolateDiscrete(this.cycleMethod, endValue.cycleMethod, t);\n@@ -406,1 +405,1 @@\n-        return PaintUtils.interpolate(this, endValue, t);\n+        return InterpolationUtils.interpolatePaint(this, endValue, t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/LinearGradient.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import com.sun.javafx.scene.paint.PaintUtils;\n@@ -33,1 +32,1 @@\n-import com.sun.javafx.util.Utils;\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -374,3 +373,3 @@\n-            newCenterX = Utils.interpolate(this.centerX, endValue.centerX, t);\n-            newCenterY = Utils.interpolate(this.centerY, endValue.centerY, t);\n-            newRadius = Utils.interpolate(this.radius, endValue.radius, t);\n+            newCenterX = InterpolationUtils.interpolate(this.centerX, endValue.centerX, t);\n+            newCenterY = InterpolationUtils.interpolate(this.centerY, endValue.centerY, t);\n+            newRadius = InterpolationUtils.interpolate(this.radius, endValue.radius, t);\n@@ -390,3 +389,3 @@\n-        double newFocusAngle = Utils.interpolate(this.focusAngle, endValue.focusAngle, t);\n-        double newFocusDistance = Utils.interpolate(this.focusDistance, endValue.focusDistance, t);\n-        CycleMethod newCycleMethod = Utils.interpolateDiscrete(this.cycleMethod, endValue.cycleMethod, t);\n+        double newFocusAngle = InterpolationUtils.interpolate(this.focusAngle, endValue.focusAngle, t);\n+        double newFocusDistance = InterpolationUtils.interpolate(this.focusDistance, endValue.focusDistance, t);\n+        CycleMethod newCycleMethod = InterpolationUtils.interpolateDiscrete(this.cycleMethod, endValue.cycleMethod, t);\n@@ -432,1 +431,1 @@\n-        return PaintUtils.interpolate(this, endValue, t);\n+        return InterpolationUtils.interpolatePaint(this, endValue, t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/RadialGradient.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import com.sun.javafx.util.Utils;\n+import com.sun.javafx.util.InterpolationUtils;\n@@ -294,1 +294,1 @@\n-        double offset = Utils.interpolate(this.offset, endValue.offset, t);\n+        double offset = InterpolationUtils.interpolate(this.offset, endValue.offset, t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/Stop.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.javafx.scene.paint.PaintUtils;\n@@ -41,0 +40,1 @@\n+import static com.sun.javafx.util.InterpolationUtils.*;\n@@ -140,1 +140,1 @@\n-            assertEquals(gradient.interpolate(PaintUtils.newSolidGradient(gradient, Color.ORANGE), 0.5), actual.getFill());\n+            assertEquals(gradient.interpolate(newSolidGradient(gradient, Color.ORANGE), 0.5), actual.getFill());\n@@ -145,1 +145,1 @@\n-            assertEquals(PaintUtils.newSolidGradient(gradient, Color.ORANGE).interpolate(gradient, 0.5), actual.getFill());\n+            assertEquals(newSolidGradient(gradient, Color.ORANGE).interpolate(gradient, 0.5), actual.getFill());\n@@ -169,1 +169,1 @@\n-            assertEquals(gradient.interpolate(PaintUtils.newSolidGradient(gradient, Color.ORANGE), 0.5), actual.getFill());\n+            assertEquals(gradient.interpolate(newSolidGradient(gradient, Color.ORANGE), 0.5), actual.getFill());\n@@ -174,1 +174,1 @@\n-            assertEquals(PaintUtils.newSolidGradient(gradient, Color.ORANGE).interpolate(gradient, 0.5), actual.getFill());\n+            assertEquals(newSolidGradient(gradient, Color.ORANGE).interpolate(gradient, 0.5), actual.getFill());\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundFillTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}