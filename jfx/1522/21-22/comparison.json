{"files":[{"patch":"@@ -134,1 +134,1 @@\n-            set(progress > 0 ? endValue : startValue);\n+            set(progress < 0.5 ? startValue : endValue);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableBooleanProperty.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,11 +82,5 @@\n-        if (newValue != null) {\n-            CssMetaData<? extends Styleable, T> metadata = getCssMetaData();\n-            StyleConverter<?, T> converter = metadata.getConverter();\n-\n-            if (converter instanceof StyleConverter.WithReconstructionSupport c) {\n-                applyComponentTransition(newValue, metadata, c);\n-            } else if (newValue instanceof Interpolatable<?>) {\n-                applyInterpolatableTransition(newValue, metadata);\n-            } else {\n-                set(newValue);\n-            }\n+        CssMetaData<? extends Styleable, T> metadata = getCssMetaData();\n+        StyleConverter<?, T> converter = metadata.getConverter();\n+\n+        if (converter instanceof StyleConverter.WithReconstructionSupport c) {\n+            applyValueComponents(newValue, metadata, c);\n@@ -94,1 +88,1 @@\n-            set(null);\n+            applyValue(newValue, metadata);\n@@ -102,1 +96,1 @@\n-     * This method is used for {@link Interpolatable} values.\n+     * This method is used for values that don't support component-wise transitions.\n@@ -105,0 +99,1 @@\n+     * @param metadata the CSS metadata of the value\n@@ -106,1 +101,1 @@\n-    private void applyInterpolatableTransition(T newValue, CssMetaData<? extends Styleable, T> metadata) {\n+    private void applyValue(T newValue, CssMetaData<? extends Styleable, T> metadata) {\n@@ -113,7 +108,5 @@\n-        \/\/ 'oldValue' and 'newValue' could be objects that both implement Interpolatable, but with\n-        \/\/ different type arguments. We detect this case by checking whether 'newValue' is an instance\n-        \/\/ of 'oldValue' (so that oldValue.interpolate(newValue, t) succeeds), and only applying the\n-        \/\/ transition when the test succeeds.\n-        T oldValue;\n-\n-        if (transition == null || !newValue.getClass().isInstance(oldValue = get())) {\n+        \/\/ We only start a new transition if the new target value is different from the target\n+        \/\/ value of the existing transition. This scenario can sometimes happen when a CSS value\n+        \/\/ is redundantly applied, which would cause unexpected animations if we allowed the new\n+        \/\/ transition to interrupt the existing transition.\n+        if (transition == null) {\n@@ -122,5 +115,15 @@\n-            \/\/ We only start a new transition if the new target value is different from the target\n-            \/\/ value of the existing transition. This scenario can sometimes happen when a CSS value\n-            \/\/ is redundantly applied, which would cause unexpected animations if we allowed the new\n-            \/\/ transition to interrupt the existing transition.\n-            var controller = new InterpolatableTransitionController(oldValue, newValue);\n+            T oldValue = get();\n+            TransitionControllerBase controller;\n+\n+            \/\/ 'oldValue' and 'newValue' could be objects that both implement Interpolatable, but with\n+            \/\/ different type arguments. We detect this case by checking whether 'newValue' is an instance\n+            \/\/ of 'oldValue' (so that oldValue.interpolate(newValue, t) succeeds), and only applying the\n+            \/\/ transition when the test succeeds.\n+            if (oldValue instanceof Interpolatable<?>\n+                    && newValue instanceof Interpolatable<?>\n+                    && newValue.getClass().isInstance(oldValue)) {\n+                controller = new InterpolatableTransitionController(oldValue, newValue);\n+            } else {\n+                controller = new DiscreteTransitionController(oldValue, newValue);\n+            }\n+\n@@ -137,0 +140,2 @@\n+     * @param metadata the CSS metadata of the value\n+     * @param converter the style converter of the value\n@@ -138,3 +143,3 @@\n-    private void applyComponentTransition(T newValue,\n-                                          CssMetaData<? extends Styleable, T> metadata,\n-                                          StyleConverter.WithReconstructionSupport<T> converter) {\n+    private void applyValueComponents(T newValue,\n+                                      CssMetaData<? extends Styleable, T> metadata,\n+                                      StyleConverter.WithReconstructionSupport<T> converter) {\n@@ -275,1 +280,6 @@\n-     * Common interface for {@link Interpolatable} and component-wise transitions.\n+     * Common interface for transition controllers:\n+     * <ol>\n+     *     <li>{@link DiscreteTransitionController}\n+     *     <li>{@link InterpolatableTransitionController}\n+     *     <li>{@link AggregatingTransitionController}\n+     * <\/ol>\n@@ -285,1 +295,1 @@\n-     * Controller for transitions of {@link Interpolatable} values.\n+     * Base class for transition controllers that don't support component-wise transitions.\n@@ -287,4 +297,3 @@\n-    private final class InterpolatableTransitionController extends TransitionMediator\n-                                                           implements TransitionController<T> {\n-        private final T startValue;\n-        private final T endValue;\n+    private abstract class TransitionControllerBase extends TransitionMediator implements TransitionController<T> {\n+        final T startValue;\n+        final T endValue;\n@@ -293,1 +302,1 @@\n-        InterpolatableTransitionController(T startValue, T endValue) {\n+        TransitionControllerBase(T startValue, T endValue) {\n@@ -299,6 +308,0 @@\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void onUpdate(double progress) {\n-            set(progress < 1 ? ((Interpolatable<T>)startValue).interpolate(endValue, progress) : endValue);\n-        }\n-\n@@ -329,1 +332,1 @@\n-            var mediator = (InterpolatableTransitionController)existingMediator;\n+            var mediator = (TransitionControllerBase)existingMediator;\n@@ -340,0 +343,29 @@\n+    \/**\n+     * Controller for transitions of non-interpolatable values using discrete interpolation.\n+     *\/\n+    private final class DiscreteTransitionController extends TransitionControllerBase {\n+        DiscreteTransitionController(T startValue, T endValue) {\n+            super(startValue, endValue);\n+        }\n+\n+        @Override\n+        public void onUpdate(double progress) {\n+            set(progress < 0.5 ? startValue : endValue);\n+        }\n+    }\n+\n+    \/**\n+     * Controller for transitions of {@link Interpolatable} values.\n+     *\/\n+    private final class InterpolatableTransitionController extends TransitionControllerBase {\n+        InterpolatableTransitionController(T startValue, T endValue) {\n+            super(startValue, endValue);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public void onUpdate(double progress) {\n+            set(progress < 1 ? ((Interpolatable<T>)startValue).interpolate(endValue, progress) : endValue);\n+        }\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableObjectProperty.java","additions":75,"deletions":43,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import javafx.css.StyleConverter;\n@@ -283,1 +284,1 @@\n-    void testIntegersAreInterpolatedInRealNumberSpace() {\n+    void testIntegerTransitionsInRealNumberSpace() {\n@@ -306,1 +307,1 @@\n-    void testLongsAreInterpolatedInRealNumberSpace() {\n+    void testLongTransitionsInRealNumberSpace() {\n@@ -327,0 +328,80 @@\n+\n+    @Test\n+    void testBooleanTransitionsDiscretely() {\n+        ((Group)scene.getRoot()).getChildren().setAll(testBean);\n+        var property = new SimpleStyleableBooleanProperty(booleanPropertyMetadata, testBean, null);\n+\n+        \/\/ Setting a value for the first time doesn't start a transition.\n+        setAnimationTime(0);\n+        property.applyStyle(StyleOrigin.USER, false);\n+\n+        \/\/ Start the transition and sample the outputs.\n+        property.applyStyle(StyleOrigin.USER, true);\n+        setAnimationTime(499);\n+        assertFalse(property.get());\n+        setAnimationTime(500);\n+        assertTrue(property.get());\n+    }\n+\n+    @Test\n+    void testNonInterpolatableObjectTransitionsDiscretely() {\n+        enum Fruit { APPLE, ORANGE }\n+\n+        CssMetaData<Styleable, Fruit> metadata = new CssMetaData<>(\n+                \"-fx-fruit\", StyleConverter.getEnumConverter(Fruit.class), Fruit.APPLE) {\n+            @Override public boolean isSettable(Styleable styleable) { return true; }\n+            @Override public StyleableProperty<Fruit> getStyleableProperty(Styleable styleable) {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+\n+        var bean = new Group();\n+        NodeHelper.getTransitionProperty(bean).setValue(new TransitionDefinition[] {\n+            new TransitionDefinition(\"-fx-fruit\", ONE_SECOND, Duration.ZERO, Interpolator.LINEAR)\n+        });\n+\n+        ((Group)scene.getRoot()).getChildren().setAll(bean);\n+        var property = new SimpleStyleableObjectProperty<Fruit>(metadata, bean, null);\n+\n+        \/\/ Setting a value for the first time doesn't start a transition.\n+        setAnimationTime(0);\n+        property.applyStyle(StyleOrigin.USER, Fruit.APPLE);\n+\n+        \/\/ Start the transition and sample the outputs.\n+        property.applyStyle(StyleOrigin.USER, Fruit.ORANGE);\n+        setAnimationTime(499);\n+        assertSame(Fruit.APPLE, property.get());\n+        setAnimationTime(500);\n+        assertSame(Fruit.ORANGE, property.get());\n+\n+        \/\/ This is a reversing transition, so it only needs half the time to flip the value.\n+        property.applyStyle(StyleOrigin.USER, Fruit.APPLE);\n+        setAnimationTime(749);\n+        assertSame(Fruit.ORANGE, property.get());\n+        setAnimationTime(750);\n+        assertSame(Fruit.APPLE, property.get());\n+    }\n+\n+    @Test\n+    void testNullObjectTransitionsDiscretely() {\n+        ((Group)scene.getRoot()).getChildren().setAll(testBean);\n+        var property = new SimpleStyleableObjectProperty<>(interpolatableObjectPropertyMetadata, testBean, null);\n+\n+        \/\/ Setting a value for the first time doesn't start a transition.\n+        setAnimationTime(0);\n+        property.applyStyle(StyleOrigin.USER, Color.RED);\n+\n+        \/\/ Start the transition and sample the outputs.\n+        property.applyStyle(StyleOrigin.USER, null);\n+        setAnimationTime(499);\n+        assertSame(Color.RED, property.get());\n+        setAnimationTime(500);\n+        assertNull(property.get());\n+\n+        \/\/ This is a reversing transition, so it only needs half the time to flip the value.\n+        property.applyStyle(StyleOrigin.USER, Color.RED);\n+        setAnimationTime(749);\n+        assertNull(property.get());\n+        setAnimationTime(750);\n+        assertSame(Color.RED, property.get());\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/css\/StyleableProperty_transition_Test.java","additions":83,"deletions":2,"binary":false,"changes":85,"status":"modified"}]}