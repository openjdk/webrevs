{"files":[{"patch":"@@ -82,18 +82,11 @@\n-        if (newValue == null) {\n-            set(null);\n-            this.origin = origin;\n-            return;\n-        }\n-\n-        T oldValue = get();\n-        CssMetaData<? extends Styleable, T> metadata = getCssMetaData();\n-        StyleConverter<?, T> converter = metadata.getConverter();\n-\n-        if (converter instanceof StyleConverter.WithReconstructionSupport c) {\n-            applyComponentTransition(oldValue, newValue, metadata, c);\n-        } else if (newValue instanceof Interpolatable<?> && newValue.getClass().isInstance(oldValue)) {\n-            \/\/ 'oldValue' and 'newValue' could be objects that both implement Interpolatable, but with\n-            \/\/ different type arguments. We detect this case by checking whether 'newValue' is an instance\n-            \/\/ of 'oldValue' (so that oldValue.interpolate(newValue, t) succeeds), and only applying the\n-            \/\/ transition when the test succeeds.\n-            applyInterpolatableTransition(oldValue, newValue, metadata);\n+        if (newValue != null) {\n+            CssMetaData<? extends Styleable, T> metadata = getCssMetaData();\n+            StyleConverter<?, T> converter = metadata.getConverter();\n+\n+            if (converter instanceof StyleConverter.WithReconstructionSupport c) {\n+                applyComponentTransition(newValue, metadata, c);\n+            } else if (newValue instanceof Interpolatable<?>) {\n+                applyInterpolatableTransition(newValue, metadata);\n+            } else {\n+                set(newValue);\n+            }\n@@ -101,1 +94,1 @@\n-            set(newValue);\n+            set(null);\n@@ -111,1 +104,0 @@\n-     * @param oldValue the old value\n@@ -114,1 +106,1 @@\n-    private void applyInterpolatableTransition(T oldValue, T newValue, CssMetaData<? extends Styleable, T> metadata) {\n+    private void applyInterpolatableTransition(T newValue, CssMetaData<? extends Styleable, T> metadata) {\n@@ -121,1 +113,7 @@\n-        if (transition == null) {\n+        \/\/ 'oldValue' and 'newValue' could be objects that both implement Interpolatable, but with\n+        \/\/ different type arguments. We detect this case by checking whether 'newValue' is an instance\n+        \/\/ of 'oldValue' (so that oldValue.interpolate(newValue, t) succeeds), and only applying the\n+        \/\/ transition when the test succeeds.\n+        T oldValue;\n+\n+        if (transition == null || !newValue.getClass().isInstance(oldValue = get())) {\n@@ -138,1 +136,0 @@\n-     * @param oldValue the old value\n@@ -141,1 +138,1 @@\n-    private void applyComponentTransition(T oldValue, T newValue,\n+    private void applyComponentTransition(T newValue,\n@@ -155,1 +152,1 @@\n-            var oldCssValues = converter.convertBack(oldValue);\n+            var oldCssValues = converter.convertBack(get());\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableObjectProperty.java","additions":22,"deletions":25,"binary":false,"changes":47,"status":"modified"}]}