{"files":[{"patch":"@@ -30,0 +30,3 @@\n+\/**\n+ * Represents a full line of text that is all rendered on a single line.\n+ *\/\n@@ -32,1 +35,1 @@\n-     * Returns the list of GlyphList in the line. The list is visually orderded.\n+     * Returns the list of GlyphList in the line. The list is visually ordered.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/text\/TextLine.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,7 @@\n+\/**\n+ * Represents a sequence of characters all using the same font, or\n+ * an embedded object if no font is supplied.\n+ * <p>\n+ * A text span can contain line breaks if the text should span multiple\n+ * lines.\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/text\/TextSpan.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -933,1 +933,1 @@\n-    private TextLine createLine(int start, int end, int startOffset) {\n+    private TextLine createLine(int start, int end, int startOffset, float collapsedSpaceWidth) {\n@@ -935,0 +935,3 @@\n+\n+        assert count > 0 : \"number of TextRuns in a TextLine cannot be less than one: \" + count;\n+\n@@ -951,0 +954,3 @@\n+\n+        width -= collapsedSpaceWidth;\n+\n@@ -956,0 +962,29 @@\n+    \/**\n+     * Computes the size of the white space trailing a given run.\n+     *\n+     * @param run the run to compute trailing space width for, cannot be {@code null}\n+     * @return the X size of the white space trailing the run\n+     *\/\n+    private float computeTrailingSpaceWidth(TextRun run) {\n+        float trailingSpaceWidth = 0;\n+        char[] chars = getText();\n+\n+        \/*\n+         * As the loop below exits when encountering a non-white space character,\n+         * testing each trailing glyph in turn for white space is safe, as white\n+         * space is always represented with only a single glyph:\n+         *\/\n+\n+        for (int i = run.getGlyphCount() - 1; i >= 0; i--) {\n+            int textOffset = run.getStart() + run.getCharOffset(i);\n+\n+            if (!Character.isWhitespace(chars[textOffset])) {\n+                break;\n+            }\n+\n+            trailingSpaceWidth += run.getAdvance(i);\n+        }\n+\n+        return trailingSpaceWidth;\n+    }\n+\n@@ -1062,0 +1097,88 @@\n+    \/*\n+     * The way JavaFX lays out text:\n+     *\n+     * JavaFX distinguishes between soft wraps and hard wraps. Soft wraps\n+     * occur when a wrap width has been set and the text requires wrapping\n+     * to stay within the set wrap width. Hard wraps are explicitly part of\n+     * the text in the form of line feeds (LF) and carriage returns (CR).\n+     * Hard wrapping considers a singular LF or CR, or the combination of\n+     * CR+LF (or LF+CR) as a single wrap location. Hard wrapping also occurs\n+     * between TextSpans when multiple TextSpans were supplied (for wrapping\n+     * purposes, there is no difference between two TextSpans and a single\n+     * TextSpan where the text was concatenated with a line break in between).\n+     *\n+     * Soft wrapping occurs when a wrap width has been set. This occurs at\n+     * the first character that does not fit.\n+     *\n+     * - If that character is not a white space, the break is set immediately\n+     *   after the first white space encountered before that character\n+     *   - If there is no white space before the preferred break character, the\n+     *     break is done at the first character that does not fit (the wrap\n+     *     then occurs in the middle of a (long) word)\n+     * - If the preferred break character is white space, and it is followed by\n+     *   more white space, the break is moved to the end of the white space (thus\n+     *   a break in white space always occurs at first non white space character\n+     *   following a white space sequence)\n+     *\n+     * White space collapsing:\n+     *\n+     * Only white space that is present at soft wrapped locations is collapsed to\n+     * zero. Any other white space is preserved. This includes white space between\n+     * words, leading and trailing white space, and white space around hard wrapped\n+     * locations.\n+     *\n+     * Alignment:\n+     *\n+     * The alignment calculation only looks at the width of all the significant\n+     * characters in each line. Significant characters are any non white space\n+     * characters and any white space that has been preserved (white space that wasn't\n+     * collapsed due to soft wrapping).\n+     *\n+     * Alignment does not take text effects, such as strike through and underline, into\n+     * account. This means that such effects can appear unaligned. Trailing spaces at a\n+     * soft wrap location (that are underlined for example), may show the underline go\n+     * outside the logical bounds of the text.\n+     *\n+     * Example, where <SW> indicates a soft wrap location, and <LF> is a line feed:\n+     *\n+     *     \"   The   quick <SW>brown fox jumps <SW> over the <LF> lazy dog   \"\n+     *\n+     * Would be rendered as (left aligned):\n+     *\n+     *     \"   The   quick\"\n+     *     \"brown fox jumps\"\n+     *     \"over the \"\n+     *     \" lazy dog   \"\n+     *\n+     * The alignment calculation uses the above bounds indicated by the double\n+     * quotes, and so right aligned text would look like:\n+     *\n+     *      \"   The   quick\"\n+     *     \"brown fox jumps\"\n+     *           \"over the \"\n+     *        \" lazy dog   \"\n+     *\n+     * Note that only the white space at the soft wrap locations is collapsed.\n+     * In all other locations the space was preserved (the space between words\n+     * where no soft wrap occurred, the leading and trailing space, and the\n+     * space around the hard wrapped location).\n+     *\n+     * Text effects have no effect on the alignment, and so with underlining on\n+     * the right aligned text would look like:\n+     *\n+     *      \"___The___quick_\"     (one collapsed space becomes visible here)\n+     *     \"brown_fox_jumps__\"    (two collapsed spaces become visible here)\n+     *           \"over_the_\"\n+     *        \"_lazy_dog___\"\n+     *\n+     * Note that text alignment has not changed at all, but the bounds are exceeded\n+     * in some locations to allow for the underline. Controls displaying such texts\n+     * will likely clip the underlined parts exceeding the bounds.\n+     *\n+     * Users wishing to mitigate some of these perhaps surprising results can ensure\n+     * they use trimmed texts, and avoid the use of line breaks, or at least ensure\n+     * that line breaks are not preceded or succeeded by white space (activating\n+     * line wrapping is not equivalent to collapsing any consecutive white space\n+     * no matter where it occurs).\n+     *\/\n+\n@@ -1129,1 +1252,2 @@\n-                \/* Only keep whitespaces (not tabs) in the current run to avoid\n+                \/*\n+                 * Only keep white spaces (not tabs) in the current run to avoid\n@@ -1131,0 +1255,5 @@\n+                 *\n+                 * If the run is a tab, the run will be always of length 1 (see\n+                 * buildRuns()). As there is no \"next\" character that can be selected\n+                 * as the wrap index in this run, the white space skipping logic\n+                 * below won't skip tabs.\n@@ -1132,0 +1261,1 @@\n+\n@@ -1134,1 +1264,3 @@\n-                while (offset + 1 < runEnd && chars[offset] == ' ') {\n+\n+                \/\/ Don't take white space into account at the preferred wrap index:\n+                while (offset + 1 < runEnd && Character.isWhitespace(chars[offset])) {\n@@ -1136,4 +1268,0 @@\n-                    \/* Preserve behaviour: only keep one white space in the line\n-                     * before wrapping. Needed API to allow change.\n-                     *\/\n-                    break;\n@@ -1236,1 +1364,1 @@\n-                TextLine line = createLine(startIndex, i, startOffset);\n+                TextLine line = createLine(startIndex, i, startOffset, computeTrailingSpaceWidth(runs[i]));\n@@ -1245,1 +1373,1 @@\n-        linesList.add(createLine(startIndex, runCount - 1, startOffset));\n+        linesList.add(createLine(startIndex, runCount - 1, startOffset, 0));\n@@ -1249,1 +1377,1 @@\n-        float fullWidth = Math.max(wrapWidth, layoutWidth);\n+        float fullWidth = wrapWidth > 0 ? wrapWidth : layoutWidth;  \/\/ layoutWidth = widest line, wrapWidth is user set\n@@ -1266,1 +1394,2 @@\n-            float lineX = (fullWidth - bounds.getWidth()) * align;\n+            float unusedWidth = fullWidth - bounds.getWidth();\n+            float lineX = unusedWidth * align;\n@@ -1284,1 +1413,1 @@\n-                        float inc = (fullWidth - bounds.getWidth()) \/ wsCount;\n+                        float inc = unusedWidth \/ wsCount;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/PrismTextLayout.java","additions":141,"deletions":12,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -31,5 +31,7 @@\n-    TextRun[] runs;\n-    RectBounds bounds;\n-    float lsb, rsb, leading;\n-    int start;\n-    int length;\n+    private final TextRun[] runs;\n+    private final RectBounds bounds;\n+    private final int start;\n+    private final int length;\n+    private final float leading;\n+\n+    private float lsb, rsb;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/TextLine.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -346,0 +346,13 @@\n+\n+        \/*\n+         * When positions is null it means that the TextRun only contains\n+         * a line break, assuming that the class is used correctly (\"shape\"\n+         * must be called before calling this method, unless the class user is\n+         * sure that the run is empty). This class could benefit from better\n+         * encapsulation to make it easier to reason about.\n+         *\/\n+\n+        if (positions == null) {\n+            return 0;\n+        }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/TextRun.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,227 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package test.com.sun.javafx.text;\n-\n-import javafx.scene.text.Font;\n-\n-import com.sun.javafx.font.PGFont;\n-import com.sun.javafx.geom.RectBounds;\n-import com.sun.javafx.scene.text.GlyphList;\n-import com.sun.javafx.scene.text.TextSpan;\n-import com.sun.javafx.scene.text.TextLine;\n-import com.sun.javafx.scene.text.FontHelper;\n-import com.sun.javafx.font.CharToGlyphMapper;\n-import com.sun.javafx.text.PrismTextLayout;\n-\n-import org.junit.Ignore;\n-import org.junit.Test;\n-\n-import static org.junit.Assert.*;\n-\n-public class TextLayoutTest {\n-    private String J = \"\\u3041\";  \/\/Japanese not complex\n-    private String D = \"\\u0907\"; \/\/Devanagari complex\n-    private String T = \"\\u0E34\"; \/\/Devanagari complex\n-\n-    class TestSpan implements TextSpan {\n-        String text;\n-        Object font;\n-        TestSpan(Object text, Object font) {\n-            this.text = (String)text;\n-            this.font = font;\n-        }\n-        @Override public String getText() {\n-            return text;\n-        }\n-        @Override public Object getFont() {\n-            return font;\n-        }\n-        @Override public RectBounds getBounds() {\n-            return null;\n-        }\n-    }\n-\n-    public TextLayoutTest() {\n-    }\n-\n-    private void setContent(PrismTextLayout layout, Object... content) {\n-        int count = content.length \/ 2;\n-        TextSpan[] spans = new TextSpan[count];\n-        int i = 0;\n-        while (i < content.length) {\n-            spans[i>>1] = new TestSpan(content[i++], content[i++]);\n-        }\n-        layout.setContent(spans);\n-    }\n-\n-    private void verifyLayout(PrismTextLayout layout, int lineCount, int runCount, int... glyphCount) {\n-        TextLine[] lines = layout.getLines();\n-        assertEquals(\"lineCount\", lineCount, lines.length);\n-        GlyphList[] runs = layout.getRuns();\n-        assertEquals(\"runCount\", runCount, runs.length);\n-        assertEquals(\"runCount\", runCount, glyphCount.length);\n-        for (int i = 0; i < runs.length; i++) {\n-            assertEquals(\"run \" +i, glyphCount[i], runs[i].getGlyphCount());\n-        }\n-    }\n-\n-    private void verifyComplex(PrismTextLayout layout, boolean... complex) {\n-        GlyphList[] runs = layout.getRuns();\n-        for (int i = 0; i < runs.length; i++) {\n-            assertEquals(\"run \" +i, complex[i], runs[i].isComplex());\n-        }\n-    }\n-\n-    @Ignore(\"JDK-8087615\")\n-    @Test public void buildRuns() {\n-\n-        PrismTextLayout layout = new PrismTextLayout();\n-        PGFont font = (PGFont) FontHelper.getNativeFont(Font.font(\"Monaco\", 12));\n-        PGFont font2 = (PGFont) FontHelper.getNativeFont(Font.font(\"Tahoma\", 12));\n-\n-        \/* simple case *\/\n-        layout.setContent(\"hello\", font);\n-        verifyLayout(layout, 1, 1, 5);\n-\n-        \/* simple case, two workd*\/\n-        layout.setContent(\"hello world\", font);\n-        verifyLayout(layout, 1, 1, 11);\n-\n-        \/* empty string *\/\n-        layout.setContent(\"\", font);\n-        verifyLayout(layout, 1, 1, 0);\n-\n-        \/* line break *\/\n-        layout.setContent(\"\\n\", font); \/\/first line has the line break (glyphCount=0),\n-        verifyLayout(layout, 2, 2, 0,0);\n-        layout.setContent(\"\\r\", font);\n-        verifyLayout(layout, 2, 2, 0,0);\n-        layout.setContent(\"\\r\\n\", font);\n-        verifyLayout(layout, 2, 2, 0,0);\n-        layout.setContent(\"a\\nb\", font);\n-        verifyLayout(layout, 2, 3, 1, 0, 1);\n-        layout.setContent(\"\\n\\n\\r\\r\\n\", font);\n-        verifyLayout(layout, 5, 5, 0,0,0,0,0);\n-\n-        \/* tabs *\/\n-        layout.setContent(\"\\t\", font);\n-        verifyLayout(layout, 1, 1, 0);\n-        layout.setContent(\"\\t\\t\", font);\n-        verifyLayout(layout, 1, 2, 0,0);\n-        layout.setContent(\"a\\tb\", font);\n-        verifyLayout(layout, 1, 3, 1,0,1);\n-\n-        \/* complex *\/\n-        layout.setContent(\"aa\"+J+J, font);\n-        verifyLayout(layout, 1, 1, 4);\/\/ no complex (english to japanese)\n-        verifyComplex(layout, false);\n-\n-\n-        layout.setContent(D, font);\n-        verifyLayout(layout, 1, 1, 1);\/\/ complex (english to devanagari)\n-        verifyComplex(layout, true);\n-\n-        layout.setContent(\"aa\"+D+D, font);\n-        verifyLayout(layout, 1, 2, 2,2);\/\/ complex (english to devanagari)\n-        verifyComplex(layout, false, true);\n-\n-        layout.setContent(D+D+\"aa\", font);\n-        verifyLayout(layout, 1, 2, 2,2);\/\/ complex (devanagari to english)\n-        verifyComplex(layout, true, false);\n-\n-        layout.setContent(\"aa\"+D+D+J+J, font);\n-        verifyLayout(layout, 1, 3, 2,2,2);\/\/ complex (english to devanagari to japanese)\n-        verifyComplex(layout, false, true, false);\n-\n-        \/*Tahoma has Thai but no Hindi, font slot break expected*\/\n-        layout.setContent(D+D+T+T, font2);\n-        verifyLayout(layout, 1, 2, 2,2);\/\/ complex (devanagari to thai)\n-        verifyComplex(layout, true, true);\n-\n-        layout.setContent(T+T+D+D+T+T, font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, true, true, true);\n-\n-        layout.setContent(T+T+D+D+\"aa\", font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, true, true, false);\n-\n-        layout.setContent(T+T+\"aa\"+T+T, font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, true, false, true);\n-\n-        layout.setContent(\"aa\"+D+D+T+T, font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, false, true, true);\n-\n-        \/* Rich Text test *\/\n-\n-        setContent(layout, \"hello \", font, \"world\", font);\n-        verifyLayout(layout, 1, 2, 6,5);\n-        verifyComplex(layout, false, false);\n-\n-        setContent(layout, \"aaa\", font, J+J+J, font);\n-        verifyLayout(layout, 1, 2, 3,3);\n-        verifyComplex(layout, false, false);\n-\n-        setContent(layout, \"aaa\", font, D+D+D, font);\n-        verifyLayout(layout, 1, 2, 3,3);\n-        verifyComplex(layout, false, true);\n-\n-        \/* can't merge \\r\\n in different spans*\/\n-        setContent(layout, \"aa\\r\", font, \"\\nbb\", font);\n-        verifyLayout(layout, 3, 4, 2,0,0,2);\n-        verifyComplex(layout, false, false, false, false);\n-\n-        setContent(layout, \"aa\\r\\n\", font, \"bb\", font);\n-        verifyLayout(layout, 2, 3, 2,0,2);\n-        verifyComplex(layout, false, false, false);\n-\n-        \/* can't merge surrogate pairs in different spans*\/\n-        setContent(layout, \"\\uD840\\uDC0B\", font, \"\\uD840\\uDC89\\uD840\\uDCA2\", font);\n-        verifyLayout(layout, 1, 2, 2, 4);\n-        GlyphList[] runs = layout.getRuns();\n-        assertTrue(runs[0].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[0].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(2) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(3) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-\n-        \/* Split surrogate pair*\/\n-        setContent(layout, \"\\uD840\\uDC0B\\uD840\", font, \"\\uDC89\\uD840\\uDCA2\", font);\n-        verifyLayout(layout, 1, 2, 3, 3);\n-        runs = layout.getRuns();\n-        assertTrue(runs[0].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[0].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[0].getGlyphCode(2) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\/\/broken pair, results in missing glyph\n-        assertTrue(runs[1].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\/\/broken pair, results in missing glyph\n-        assertTrue(runs[1].getGlyphCode(1) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(2) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-\n-    }\n-\n-}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/text\/TextLayoutTest.java","additions":0,"deletions":227,"binary":false,"changes":227,"status":"deleted"},{"patch":"@@ -0,0 +1,604 @@\n+\/*\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.text;\n+\n+import static org.junit.Assume.assumeTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+import com.sun.javafx.PlatformUtil;\n+import com.sun.javafx.font.CharToGlyphMapper;\n+import com.sun.javafx.font.PGFont;\n+import com.sun.javafx.geom.Point2D;\n+import com.sun.javafx.geom.RectBounds;\n+import com.sun.javafx.scene.text.FontHelper;\n+import com.sun.javafx.scene.text.GlyphList;\n+import com.sun.javafx.scene.text.TextLine;\n+import com.sun.javafx.scene.text.TextSpan;\n+import com.sun.javafx.text.PrismTextLayout;\n+import com.sun.javafx.text.TextRun;\n+\n+import javafx.scene.text.Font;\n+\n+public class TextLayoutTest {\n+    private static final String J = \"\\u3041\";  \/\/ Japanese not complex\n+    private static final String D = \"\\u0907\";  \/\/ Devanagari complex\n+    private static final String T = \"\\u0E34\";  \/\/ Thai complex\n+\n+    private final PrismTextLayout layout = new PrismTextLayout();\n+    private final PGFont arialFont = (PGFont) FontHelper.getNativeFont(Font.font(\"Arial\", 12));\n+    private final PGFont tahomaFont = (PGFont) FontHelper.getNativeFont(Font.font(\"Tahoma\", 12));\n+\n+    record TestSpan(String text, Object font) implements TextSpan {\n+        @Override\n+        public String getText() {\n+            return text;\n+        }\n+\n+        @Override\n+        public Object getFont() {\n+            return font;\n+        }\n+\n+        @Override\n+        public RectBounds getBounds() {\n+            return null;\n+        }\n+    }\n+\n+    private void setContent(PrismTextLayout layout, Object... content) {\n+        int count = content.length \/ 2;\n+        TextSpan[] spans = new TextSpan[count];\n+        int i = 0;\n+        while (i < content.length) {\n+            spans[i>>1] = new TestSpan((String) content[i++], content[i++]);\n+        }\n+        layout.setContent(spans);\n+    }\n+\n+    private void assertLineCount(int lineCount) {\n+        assertEquals(lineCount, layout.getLines().length, \"lineCount\");\n+    }\n+\n+    private void assertLineBounds(RectBounds... rectBounds) {\n+        assertLineCount(rectBounds.length);\n+\n+        TextLine[] lines = layout.getLines();\n+\n+        for (int i = 0; i < lines.length; i++) {\n+            assertEquals(rectBounds[i], lines[i].getBounds(), \"line \" + i);\n+        }\n+    }\n+\n+    private void verifyLayout(int lineCount, int runCount, int... glyphCount) {\n+        TextLine[] lines = layout.getLines();\n+        assertEquals(lineCount, lines.length, \"lineCount\");\n+        GlyphList[] runs = layout.getRuns();\n+        assertEquals(runCount, runs.length, \"runCount\");\n+        assertEquals(runCount, glyphCount.length, \"runCount\");\n+        for (int i = 0; i < runs.length; i++) {\n+            assertEquals(glyphCount[i], runs[i].getGlyphCount(), \"run \" + i);\n+        }\n+    }\n+\n+    private void verifyComplex(boolean... complex) {\n+        GlyphList[] runs = layout.getRuns();\n+        for (int i = 0; i < runs.length; i++) {\n+            assertEquals(complex[i], runs[i].isComplex(), \"run \" + i);\n+        }\n+    }\n+\n+    \/**\n+     * These tests were broken for a long time (as early as 2013-06-28, see JDK-8087615).\n+     *\n+     * The reason they break is two fold:\n+     *\n+     * - Content that is split into multiple runs will have all runs set to \"complex\"\n+     *   if at least one run is set to \"complex\", while this test was expecting the\n+     *   runs containing non-complex characters to not become \"complex\".\n+     *\n+     * - The Tahoma font when used with a Thai character generates 2 glyphs per Thai\n+     *   character, while this test was expecting 1 glyph.\n+     *\/\n+    @Disabled(\"JDK-8087615\")\n+    @Test\n+    void complexTestsThatAreBrokenSince2013() {\n+        layout.setContent(\"aa\" + J + J, arialFont);\n+        verifyLayout(1, 1, 4);  \/\/ no complex (english to japanese)\n+        verifyComplex(false);\n+\n+        layout.setContent(D, arialFont);\n+        verifyLayout(1, 1, 1);  \/\/ complex (english to devanagari)\n+        verifyComplex(true);\n+\n+        layout.setContent(\"aa\" + D + D, arialFont);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (english to devanagari)\n+        verifyComplex(false, true);\n+\n+        layout.setContent(D + D + \"aa\", arialFont);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (devanagari to english)\n+        verifyComplex(true, false);\n+\n+        layout.setContent(\"aa\" + D + D + J + J, arialFont);\n+        verifyLayout(1, 3, 2, 2, 2);  \/\/ complex (english to devanagari to japanese)\n+        verifyComplex(false, true, false);\n+\n+        \/\/ Tahoma has Thai but no Hindi, font slot break expected\n+        layout.setContent(D + D + T + T, tahomaFont);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (devanagari to thai)\n+        verifyComplex(true, true);\n+\n+        layout.setContent(T + T + D + D + T + T, tahomaFont);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(true, true, true);\n+\n+        layout.setContent(T + T + D + D + \"aa\", tahomaFont);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(true, true, false);\n+\n+        layout.setContent(T + T + \"aa\" + T + T, tahomaFont);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(true, false, true);\n+\n+        layout.setContent(\"aa\" + D + D + T + T, tahomaFont);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(false, true, true);\n+    }\n+\n+    \/**\n+     * These are fixed versions of the above tests to avoid\n+     * further regressions.\n+     *\/\n+    @Test\n+    void fixedComplexTestsToEnsureNoFurtherRegressions() {\n+        assumeArialFontAvailable();\n+        assumeTahomaFontAvailable();\n+\n+        layout.setContent(\"aa\" + J + J, arialFont);\n+        verifyLayout(1, 1, 4);  \/\/ no complex (english to japanese)\n+        verifyComplex(false);\n+\n+        layout.setContent(D, arialFont);\n+        verifyLayout(1, 1, 1);  \/\/ complex (english to devanagari)\n+        verifyComplex(true);\n+\n+        layout.setContent(\"aa\" + D + D, arialFont);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (english to devanagari)\n+        verifyComplex(true, true);\n+\n+        layout.setContent(D + D + \"aa\", arialFont);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (devanagari to english)\n+        verifyComplex(true, true);\n+\n+        layout.setContent(\"aa\" + D + D + J + J, arialFont);\n+        verifyLayout(1, 3, 2, 2, 2);  \/\/ complex (english to devanagari to japanese)\n+        verifyComplex(true, true, true);\n+\n+        \/\/ Tahoma has Thai but no Hindi, font slot break expected\n+        layout.setContent(D + D + T + T, tahomaFont);\n+        verifyLayout(1, 2, 2, 4);  \/\/ complex (devanagari to thai)\n+        verifyComplex(true, true);\n+\n+        layout.setContent(T + T + D + D + T + T, tahomaFont);\n+        verifyLayout(1, 3, 4, 2, 4);\n+        verifyComplex(true, true, true);\n+\n+        layout.setContent(T + T + D + D + \"aa\", tahomaFont);\n+        verifyLayout(1, 3, 4, 2, 2);\n+        verifyComplex(true, true, true);\n+\n+        layout.setContent(T + T + \"aa\" + T + T, tahomaFont);\n+        verifyLayout(1, 3, 4, 2, 4);\n+        verifyComplex(true, true, true);\n+\n+        layout.setContent(\"aa\" + D + D + T + T, tahomaFont);\n+        verifyLayout(1, 3, 2, 2, 4);\n+        verifyComplex(true, true, true);\n+    }\n+\n+    @Test\n+    void basicTest() {\n+        assumeArialFontAvailable();\n+\n+        \/\/ simple case\n+        layout.setContent(\"hello\", arialFont);\n+        verifyLayout(1, 1, 5);\n+\n+        \/\/ simple case, two words\n+        layout.setContent(\"hello world\", arialFont);\n+        verifyLayout(1, 1, 11);\n+\n+        \/\/ empty string\n+        layout.setContent(\"\", arialFont);\n+        verifyLayout(1, 1, 0);\n+\n+        \/\/ line break\n+        layout.setContent(\"\\n\", arialFont);  \/\/ first line has the line break (glyphCount=0)\n+        verifyLayout(2, 2, 0, 0);\n+        layout.setContent(\"\\r\", arialFont);\n+        verifyLayout(2, 2, 0, 0);\n+        layout.setContent(\"\\r\\n\", arialFont);\n+        verifyLayout(2, 2, 0, 0);\n+        layout.setContent(\"a\\nb\", arialFont);\n+        verifyLayout(2, 3, 1, 0, 1);\n+        layout.setContent(\"\\n\\n\\r\\r\\n\", arialFont);\n+        verifyLayout(5, 5, 0, 0, 0, 0, 0);\n+\n+        \/\/ tabs\n+        layout.setContent(\"\\t\", arialFont);\n+        verifyLayout(1, 1, 0);\n+        layout.setContent(\"\\t\\t\", arialFont);\n+        verifyLayout(1, 2, 0, 0);\n+        layout.setContent(\"a\\tb\", arialFont);\n+        verifyLayout(1, 3, 1, 0, 1);\n+    }\n+\n+    @Test\n+    void richTextTest() {\n+        assumeArialFontAvailable();\n+\n+        setContent(layout, \"hello \", arialFont, \"world\", arialFont);\n+        verifyLayout(1, 2, 6, 5);\n+        verifyComplex(false, false);\n+\n+        setContent(layout, \"aaa\", arialFont, J + J + J, arialFont);\n+        verifyLayout(1, 2, 3, 3);\n+        verifyComplex(false, false);\n+\n+        setContent(layout, \"aaa\", arialFont, D + D + D, arialFont);\n+        verifyLayout(1, 2, 3, 3);\n+        verifyComplex(false, true);\n+\n+        \/\/ can't merge \\r\\n in different spans\n+        setContent(layout, \"aa\\r\", arialFont, \"\\nbb\", arialFont);\n+        verifyLayout(3, 4, 2, 0, 0, 2);\n+        verifyComplex(false, false, false, false);\n+\n+        setContent(layout, \"aa\\r\\n\", arialFont, \"bb\", arialFont);\n+        verifyLayout(2, 3, 2, 0, 2);\n+        verifyComplex(false, false, false);\n+\n+        \/\/ can't merge surrogate pairs in different spans\n+        setContent(layout, \"\\uD840\\uDC0B\", arialFont, \"\\uD840\\uDC89\\uD840\\uDCA2\", arialFont);\n+        verifyLayout(1, 2, 2, 4);\n+        GlyphList[] runs = layout.getRuns();\n+        assertTrue(runs[0].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[0].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(2) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(3) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+\n+        \/\/ Split surrogate pair\n+        setContent(layout, \"\\uD840\\uDC0B\\uD840\", arialFont, \"\\uDC89\\uD840\\uDCA2\", arialFont);\n+        verifyLayout(1, 2, 3, 3);\n+        runs = layout.getRuns();\n+        assertTrue(runs[0].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[0].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[0].getGlyphCode(2) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);  \/\/ broken pair, results in missing glyph\n+        assertTrue(runs[1].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);  \/\/ broken pair, results in missing glyph\n+        assertTrue(runs[1].getGlyphCode(1) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(2) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+    }\n+\n+    private static final float ARIAL_ASCENT = -10.863281f;\n+    private static final float ARIAL_DESCENT = 2.9355469f;\n+    private static final float ARIAL_SPACE_ADVANCE = 3.333984375f;\n+    private static final float ARIAL_TAB_ADVANCE = ARIAL_SPACE_ADVANCE * 8;\n+\n+    @Test\n+    void shouldIgnoreAlignmentWhenWrappingIsDisabled() {\n+        assumeArialFontAvailable();\n+\n+        layout.setContent(\"The quick brown fox jumps over the lazy dog\", arialFont);\n+\n+        for (int i = 0; i < 3; i++) {\n+            layout.setAlignment(i);\n+\n+            assertLineCount(1);\n+            assertLineBounds(new RectBounds(0, ARIAL_ASCENT, 237.45117f, ARIAL_DESCENT));\n+        }\n+    }\n+\n+    enum Case {\n+\n+        \/**\n+         * Checks that alignment variations have no effect when not wrapping.\n+         *\/\n+        NO_WRAP(\n+            \"The quick brown fox jumps over the lazy dog\",\n+            0.0f, List.of(237.45117f)\n+        ),\n+\n+        \/**\n+         * Checks that the individual lines of hard wrapped text are still\n+         * taking alignment into account (in this specific case, the first\n+         * line, which is the widest line, will not be aligned, but the 2nd\n+         * line will be aligned as it is less wide).\n+         *\/\n+        HARD_WRAP(\n+            \"The quick brown fox jumps\\nover the lazy dog\",\n+            0.0f, List.of(142.72852f, 91.38867f)\n+        ),\n+\n+        \/**\n+         * Checks that trailing white space is NOT ignored when wrapping\n+         * is not enabled.\n+         *\/\n+        HARD_WRAP_WITH_EXTRA_TRAILING_SPACE(\n+            \"The quick brown fox jumps           \\nover the lazy dog           \",\n+            0.0f, List.of(142.72852f + 11 * ARIAL_SPACE_ADVANCE, 91.38867f + 11 * ARIAL_SPACE_ADVANCE)\n+        ),\n+\n+        \/**\n+         * Checks that a character after tabs align, even if there were\n+         * some preceding characters (that don't exceed the tab advance width)\n+         *\/\n+        HARD_WRAP_WITH_TABS(\n+            \"\\tA A\\n\" + \"x\\tA A\\n\" + \"xx\\tA A\",  \/\/ expect same width for all three, as the \"x\" character falls within tab advance width\n+            0.0f, List.of(46.01367f, 46.01367f, 46.01367f)\n+        ),\n+\n+        \/**\n+         * Checks that tabs are a multiple of the tab advance.\n+         *\/\n+        HARD_WRAP_WITH_MULTIPLE_TABS(\n+            \"\\t\\n\" + \"\\t\\t\\n\" + \"\\t\\t\\t\",  \/\/ expect width ratio 1:2:3\n+            0.0f, List.of(ARIAL_TAB_ADVANCE, ARIAL_TAB_ADVANCE * 2, ARIAL_TAB_ADVANCE * 3)\n+        ),\n+\n+        \/**\n+         * Checks that single white spaces are ignored for alignment\n+         * purposes when wrapping is enabled in simple text. This soft\n+         * wraps after \"jumps\".\n+         *\/\n+        SOFT_WRAP(\n+            \"The quick brown fox jumps over the lazy dog\",\n+            145.0f, List.of(142.72852f, 91.38867f)\n+        ),\n+\n+        \/**\n+         * Checks that leading white spaces are NOT stripped even when\n+         * some lines are soft wrapped. This soft wraps after \"fox\"\n+         * and has 4 leading spaces on the 1st line where no soft\n+         * wrap occurs, and so they should be kept intact.\n+         *\/\n+        SOFT_WRAP_WITH_LEADING_SPACE(\n+            \"    The quick brown fox jumps over the lazy dog\",\n+            145.0f, List.of(107.384762f + 4 * ARIAL_SPACE_ADVANCE, 126.73242f)\n+        ),\n+\n+        \/**\n+         * Checks that trailing white spaces are NOT stripped even when\n+         * some lines are soft wrapped. This soft wraps after \"jumps\"\n+         * and has 4 trailing spaces on the 2nd line where no soft\n+         * wrap occurs, and so they should be kept intact.\n+         *\/\n+        SOFT_WRAP_WITH_TRAILING_SPACE(\n+            \"The quick brown fox jumps over the lazy dog    \",\n+            145.0f, List.of(142.72852f, 91.38867f + 4 * ARIAL_SPACE_ADVANCE)\n+        ),\n+\n+        \/**\n+         * Checks that multiple white spaces are ignored for alignment\n+         * purposes when wrapping is enabled in simple text. This soft\n+         * wraps after \"jumps\".\n+         *\/\n+        SOFT_WRAP_WITH_EXTRA_SPACE(\n+            \"The quick brown fox jumps           over the lazy dog\",\n+            145.0f, List.of(142.72852f, 91.38867f)\n+        ),\n+\n+        \/**\n+         * Checks that single white spaces are ignored for alignment\n+         * purposes when wrapping is enabled in complex text. This soft\n+         * wraps after \"jumps\".\n+         *\/\n+        SOFT_WRAP_WITH_COMPLEX_TEXT_ON_WINDOWS(\n+            TextLayoutTest::assumeWindows,\n+            \"The quick brown लोमड़ी jumps over the lazy कुत्ता\",\n+            160.0f, List.of(158.1914f, 93.134766f)\n+        ),\n+\n+        \/**\n+         * Checks that multiple white spaces are ignored for alignment\n+         * purposes when wrapping is enabled in complex text. This soft\n+         * wraps after \"jumps\".\n+         *\/\n+        SOFT_WRAP_WITH_COMPLEX_TEXT_AND_EXTRA_SPACE_ON_WINDOWS(\n+            TextLayoutTest::assumeWindows,\n+            \"The quick brown लोमड़ी jumps           over the lazy कुत्ता\",\n+            160.0f, List.of(158.1914f, 93.134766f)\n+        ),\n+\n+        \/**\n+         * Checks that single white spaces are ignored for alignment\n+         * purposes when wrapping is enabled in complex text. This soft\n+         * wraps after \"jumps\".\n+         *\/\n+        SOFT_WRAP_WITH_COMPLEX_TEXT_ON_MAC(\n+            TextLayoutTest::assumeMac,\n+            \"The quick brown लोमड़ी jumps over the lazy कुत्ता\",\n+            160.0f, List.of(155.3047f, 91.04719f)\n+        ),\n+\n+        \/**\n+         * Checks that multiple white spaces are ignored for alignment\n+         * purposes when wrapping is enabled in complex text. This soft\n+         * wraps after \"jumps\".\n+         *\/\n+        SOFT_WRAP_WITH_COMPLEX_TEXT_AND_EXTRA_SPACE_ON_MAC(\n+            TextLayoutTest::assumeMac,\n+            \"The quick brown लोमड़ी jumps           over the lazy कुत्ता\",\n+            160.0f, List.of(155.3047f, 91.04719f)\n+        );\n+\n+        Runnable assumption;\n+        String text;\n+        float wrapWidth;\n+        List<Float> lineWidths;\n+\n+        Case(Runnable assumption, String text, float wrapWidth, List<Float> lineWidths) {\n+            assert text != null;\n+            assert wrapWidth >= 0;\n+            assert lineWidths != null;\n+            assert lineWidths.size() > 0;\n+\n+            this.assumption = assumption == null ? () -> {} : assumption;\n+            this.text = text;\n+            this.wrapWidth = wrapWidth;\n+            this.lineWidths = List.copyOf(lineWidths);\n+        }\n+\n+        Case(String text, float wrapWidth, List<Float> lineWidths) {\n+            this(null, text, wrapWidth, lineWidths);\n+        }\n+\n+        int lineCount() {\n+            return lineWidths.size();\n+        }\n+\n+        float maxWidth() {\n+            return lineWidths.stream().max(Float::compareTo).orElseThrow();\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(Case.class)\n+    void caseTest(Case c) {\n+        assumeArialFontAvailable();\n+\n+        \/\/ Check test specific assumption:\n+        c.assumption.run();\n+\n+        final float ASCENT = -ARIAL_ASCENT;\n+        final float DESCENT = ARIAL_DESCENT;\n+        final float WRAP = c.wrapWidth == 0 ? c.maxWidth() : c.wrapWidth;\n+        final float CENTER = 0.5f * WRAP;\n+\n+        for (String contentType : new String[] {\"rich text (spans)\", \"plain text\"}) {\n+            if (contentType.equals(\"plain text\")) {\n+                layout.setContent(c.text, arialFont);\n+            }\n+            else {\n+                \/\/ split content on line feeds (without removing the line feeds):\n+                layout.setContent(Arrays.stream(c.text.split(\"(?<=\\n)\")).map(text -> new TestSpan(text, arialFont)).toArray(TextSpan[]::new));\n+            }\n+\n+            layout.setWrapWidth(c.wrapWidth);\n+\n+            \/\/ LEFT ALIGNMENT\n+\n+            layout.setAlignment(0);  \/\/ 0 == left\n+\n+            assertLineCount(c.lineCount());\n+\n+            for (int i = 0; i < c.lineCount(); i++) {\n+                TextLine line = layout.getLines()[i];\n+                String description = \"left aligned \" + contentType + \": line \" + i + \" for \" + c;\n+                RectBounds expectedBounds = new RectBounds(0, -ASCENT, c.lineWidths.get(i), DESCENT);\n+                Point2D expectedLocation = new Point2D(0, i * (ASCENT + DESCENT));\n+\n+                assertEquals(expectedBounds, line.getBounds(), description);\n+                assertEquals(expectedLocation, line.getRuns()[0].getLocation(), description);\n+            }\n+\n+            \/\/ CENTER ALIGNMENT\n+\n+            layout.setAlignment(1);  \/\/ 1 == center\n+\n+            assertLineCount(c.lineCount());\n+\n+            for (int i = 0; i < c.lineCount(); i++) {\n+                TextLine line = layout.getLines()[i];\n+                String description = \"centered \" + contentType + \": line \" + i + \" for \" + c;\n+                RectBounds expectedBounds = new RectBounds(CENTER - 0.5f * c.lineWidths.get(i), -ASCENT, CENTER + 0.5f * c.lineWidths.get(i), DESCENT);\n+                Point2D expectedLocation = new Point2D(CENTER - 0.5f * c.lineWidths.get(i), i * (ASCENT + DESCENT));\n+\n+                assertEquals(expectedBounds, line.getBounds(), description);\n+                assertEquals(expectedLocation, line.getRuns()[0].getLocation(), description);\n+            }\n+\n+            \/\/ RIGHT ALIGNMENT\n+\n+            layout.setAlignment(2);  \/\/ 2 == right\n+\n+            assertLineCount(c.lineCount());\n+\n+            for (int i = 0; i < c.lineCount(); i++) {\n+                TextLine line = layout.getLines()[i];\n+                String description = \"right aligned \" + contentType + \": line \" + i + \" for \" + c;\n+                RectBounds expectedBounds = new RectBounds(WRAP - c.lineWidths.get(i), -ASCENT, WRAP, DESCENT);\n+                Point2D expectedLocation = new Point2D(WRAP - c.lineWidths.get(i), i * (ASCENT + DESCENT));\n+\n+                assertEquals(expectedBounds, line.getBounds(), description);\n+                assertEquals(expectedLocation, line.getRuns()[0].getLocation(), description);\n+            }\n+\n+            \/\/ JUSTIFIED ALIGNMENT\n+\n+            layout.setAlignment(3);  \/\/ 3 == justified\n+\n+            assertLineCount(c.lineCount());\n+\n+            for (int i = 0; i < c.lineCount(); i++) {\n+                TextLine line = layout.getLines()[i];\n+                String description = \"justified \" + contentType + \": line \" + i + \" for \" + c;\n+                GlyphList[] runs = line.getRuns();\n+                boolean lastLine = i == c.lineCount() - 1 || (runs[runs.length - 1] instanceof TextRun tr && tr.isLinebreak());\n+                RectBounds expectedBounds = new RectBounds(0, -ASCENT, lastLine ? c.lineWidths.get(i) : WRAP, DESCENT);\n+                Point2D expectedLocation = new Point2D(0, i * (ASCENT + DESCENT));\n+\n+                assertEquals(expectedBounds, line.getBounds(), description);\n+                assertEquals(expectedLocation, line.getRuns()[0].getLocation(), description);\n+            }\n+        }\n+    }\n+\n+    private void assumeArialFontAvailable() {\n+        assumeTrue(\"Arial font missing\", arialFont.getName().equals(\"Arial\"));\n+    }\n+\n+    private void assumeTahomaFontAvailable() {\n+        assumeTrue(\"Tahoma font missing\", arialFont.getName().equals(\"Tahoma\"));\n+    }\n+\n+    private static void assumeMac() {\n+        assumeTrue(\"Platform is not Mac\", PlatformUtil.isMac());\n+    }\n+\n+    private static void assumeWindows() {\n+        assumeTrue(\"Platform is not Windows\", PlatformUtil.isWindows());\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/com\/sun\/javafx\/text\/TextLayoutTest.java","additions":604,"deletions":0,"binary":false,"changes":604,"status":"added"}]}