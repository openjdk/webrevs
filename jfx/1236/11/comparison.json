{"files":[{"patch":"@@ -30,0 +30,3 @@\n+\/**\n+ * Represents a full line of text that is all rendered on a single line.\n+ *\/\n@@ -32,1 +35,1 @@\n-     * Returns the list of GlyphList in the line. The list is visually orderded.\n+     * Returns the list of GlyphList in the line. The list is visually ordered.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/text\/TextLine.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,7 @@\n+\/**\n+ * Represents a sequence of characters all using the same font, or\n+ * an embedded object if no font is supplied.\n+ * <p>\n+ * A text span can contain line breaks if the text should span multiple\n+ * lines.\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/text\/TextSpan.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -457,1 +457,1 @@\n-                    for (TextRun r: lines[i].runs) {\n+                    for (TextRun r: lines[i].getRuns()) {\n@@ -762,1 +762,1 @@\n-                for (TextRun r : lines[index].runs) {\n+                for (TextRun r : lines[index].getRuns()) {\n@@ -994,1 +994,1 @@\n-    private TextLine createLine(int start, int end, int startOffset) {\n+    private TextLine createLine(int start, int end, int startOffset, float collapsedSpaceWidth) {\n@@ -996,0 +996,3 @@\n+\n+        assert count > 0 : \"number of TextRuns in a TextLine cannot be less than one: \" + count;\n+\n@@ -1012,0 +1015,3 @@\n+\n+        width -= collapsedSpaceWidth;\n+\n@@ -1017,0 +1023,29 @@\n+    \/**\n+     * Computes the size of the white space trailing a given run.\n+     *\n+     * @param run the run to compute trailing space width for, cannot be {@code null}\n+     * @return the X size of the white space trailing the run\n+     *\/\n+    private float computeTrailingSpaceWidth(TextRun run) {\n+        float trailingSpaceWidth = 0;\n+        char[] chars = getText();\n+\n+        \/*\n+         * As the loop below exits when encountering a non-white space character,\n+         * testing each trailing glyph in turn for white space is safe, as white\n+         * space is always represented with only a single glyph:\n+         *\/\n+\n+        for (int i = run.getGlyphCount() - 1; i >= 0; i--) {\n+            int textOffset = run.getStart() + run.getCharOffset(i);\n+\n+            if (!Character.isWhitespace(chars[textOffset])) {\n+                break;\n+            }\n+\n+            trailingSpaceWidth += run.getAdvance(i);\n+        }\n+\n+        return trailingSpaceWidth;\n+    }\n+\n@@ -1123,0 +1158,88 @@\n+    \/*\n+     * The way JavaFX lays out text:\n+     *\n+     * JavaFX distinguishes between soft wraps and hard wraps. Soft wraps\n+     * occur when a wrap width has been set and the text requires wrapping\n+     * to stay within the set wrap width. Hard wraps are explicitly part of\n+     * the text in the form of line feeds (LF) and carriage returns (CR).\n+     * Hard wrapping considers a singular LF or CR, or the combination of\n+     * CR+LF (or LF+CR) as a single wrap location. Hard wrapping also occurs\n+     * between TextSpans when multiple TextSpans were supplied (for wrapping\n+     * purposes, there is no difference between two TextSpans and a single\n+     * TextSpan where the text was concatenated with a line break in between).\n+     *\n+     * Soft wrapping occurs when a wrap width has been set. This occurs at\n+     * the first character that does not fit.\n+     *\n+     * - If that character is not a white space, the break is set immediately\n+     *   after the first white space encountered before that character\n+     *   - If there is no white space before the preferred break character, the\n+     *     break is done at the first character that does not fit (the wrap\n+     *     then occurs in the middle of a (long) word)\n+     * - If the preferred break character is white space, and it is followed by\n+     *   more white space, the break is moved to the end of the white space (thus\n+     *   a break in white space always occurs at first non white space character\n+     *   following a white space sequence)\n+     *\n+     * White space collapsing:\n+     *\n+     * Only white space that is present at soft wrapped locations is collapsed to\n+     * zero. Any other white space is preserved. This includes white space between\n+     * words, leading and trailing white space, and white space around hard wrapped\n+     * locations.\n+     *\n+     * Alignment:\n+     *\n+     * The alignment calculation only looks at the width of all the significant\n+     * characters in each line. Significant characters are any non white space\n+     * characters and any white space that has been preserved (white space that wasn't\n+     * collapsed due to soft wrapping).\n+     *\n+     * Alignment does not take text effects, such as strike through and underline, into\n+     * account. This means that such effects can appear unaligned. Trailing spaces at a\n+     * soft wrap location (that are underlined for example), may show the underline go\n+     * outside the logical bounds of the text.\n+     *\n+     * Example, where <SW> indicates a soft wrap location, and <LF> is a line feed:\n+     *\n+     *     \"   The   quick <SW>brown fox jumps <SW> over the <LF> lazy dog   \"\n+     *\n+     * Would be rendered as (left aligned):\n+     *\n+     *     \"   The   quick\"\n+     *     \"brown fox jumps\"\n+     *     \"over the \"\n+     *     \" lazy dog   \"\n+     *\n+     * The alignment calculation uses the above bounds indicated by the double\n+     * quotes, and so right aligned text would look like:\n+     *\n+     *      \"   The   quick\"\n+     *     \"brown fox jumps\"\n+     *           \"over the \"\n+     *        \" lazy dog   \"\n+     *\n+     * Note that only the white space at the soft wrap locations is collapsed.\n+     * In all other locations the space was preserved (the space between words\n+     * where no soft wrap occurred, the leading and trailing space, and the\n+     * space around the hard wrapped location).\n+     *\n+     * Text effects have no effect on the alignment, and so with underlining on\n+     * the right right aligned text would look like:\n+     *\n+     *      \"___The___quick_\"     (one collapsed space becomes visible here)\n+     *     \"brown_fox_jumps__\"    (two collapsed spaces become visible here)\n+     *           \"over_the_\"\n+     *        \"_lazy_dog___\"\n+     *\n+     * Note that text alignment has not changed at all, but the bounds are exceeded\n+     * in some locations to allow for the underline. Controls displaying such texts\n+     * will likely clip the underlined parts exceeding the bounds.\n+     *\n+     * Users wishing to mitigate some of these perhaps surprising results can ensure\n+     * they use trimmed texts, and avoid the use of line breaks, or at least ensure\n+     * that line breaks are not preceded or succeeded by white space (activating\n+     * line wrapping is not equivalent to collapsing any consecutive white space\n+     * no matter where it occurs).\n+     *\/\n+\n@@ -1190,1 +1313,2 @@\n-                \/* Only keep whitespaces (not tabs) in the current run to avoid\n+                \/*\n+                 * Only keep white spaces (not tabs) in the current run to avoid\n@@ -1192,0 +1316,5 @@\n+                 *\n+                 * If the run is a tab, the run will be always of length 1 (see\n+                 * buildRuns()). As there is no \"next\" character that can be selected\n+                 * as the wrap index in this run, the white space skipping logic\n+                 * below won't skip tabs.\n@@ -1193,0 +1322,1 @@\n+\n@@ -1195,1 +1325,3 @@\n-                while (offset + 1 < runEnd && chars[offset] == ' ') {\n+\n+                \/\/ Don't take white space into account at the preferred wrap index:\n+                while (offset + 1 < runEnd && Character.isWhitespace(chars[offset])) {\n@@ -1197,4 +1329,0 @@\n-                    \/* Preserve behaviour: only keep one white space in the line\n-                     * before wrapping. Needed API to allow change.\n-                     *\/\n-                    break;\n@@ -1297,1 +1425,1 @@\n-                TextLine line = createLine(startIndex, i, startOffset);\n+                TextLine line = createLine(startIndex, i, startOffset, computeTrailingSpaceWidth(runs[i]));\n@@ -1306,1 +1434,1 @@\n-        linesList.add(createLine(startIndex, runCount - 1, startOffset));\n+        linesList.add(createLine(startIndex, runCount - 1, startOffset, 0));\n@@ -1310,1 +1438,1 @@\n-        float fullWidth = Math.max(wrapWidth, layoutWidth);\n+        float fullWidth = wrapWidth > 0 ? wrapWidth : layoutWidth;  \/\/ layoutWidth = widest line, wrapWidth is user set\n@@ -1327,1 +1455,2 @@\n-            float lineX = (fullWidth - bounds.getWidth()) * align;\n+            float unusedWidth = fullWidth - bounds.getWidth();\n+            float lineX = unusedWidth * align;\n@@ -1345,1 +1474,1 @@\n-                        float inc = (fullWidth - bounds.getWidth()) \/ wsCount;\n+                        float inc = unusedWidth \/ wsCount;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/PrismTextLayout.java","additions":143,"deletions":14,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -31,5 +31,7 @@\n-    TextRun[] runs;\n-    RectBounds bounds;\n-    float lsb, rsb, leading;\n-    int start;\n-    int length;\n+    private final TextRun[] runs;\n+    private final RectBounds bounds;\n+    private final int start;\n+    private final int length;\n+    private final float leading;\n+\n+    private float lsb, rsb;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/TextLine.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -346,0 +346,13 @@\n+\n+        \/*\n+         * When positions is null it means that the TextRun only contains\n+         * a line break, assuming that the class is used correctly (\"shape\"\n+         * must be called before calling this method, unless the class user is\n+         * sure that the run is empty). This class could benefit from better\n+         * encapsulation to make it easier to reason about.\n+         *\/\n+\n+        if (positions == null) {\n+            return 0;\n+        }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/TextRun.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,227 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package test.com.sun.javafx.text;\n-\n-import javafx.scene.text.Font;\n-\n-import com.sun.javafx.font.PGFont;\n-import com.sun.javafx.geom.RectBounds;\n-import com.sun.javafx.scene.text.GlyphList;\n-import com.sun.javafx.scene.text.TextSpan;\n-import com.sun.javafx.scene.text.TextLine;\n-import com.sun.javafx.scene.text.FontHelper;\n-import com.sun.javafx.font.CharToGlyphMapper;\n-import com.sun.javafx.text.PrismTextLayout;\n-\n-import org.junit.Ignore;\n-import org.junit.Test;\n-\n-import static org.junit.Assert.*;\n-\n-public class TextLayoutTest {\n-    private String J = \"\\u3041\";  \/\/Japanese not complex\n-    private String D = \"\\u0907\"; \/\/Devanagari complex\n-    private String T = \"\\u0E34\"; \/\/Devanagari complex\n-\n-    class TestSpan implements TextSpan {\n-        String text;\n-        Object font;\n-        TestSpan(Object text, Object font) {\n-            this.text = (String)text;\n-            this.font = font;\n-        }\n-        @Override public String getText() {\n-            return text;\n-        }\n-        @Override public Object getFont() {\n-            return font;\n-        }\n-        @Override public RectBounds getBounds() {\n-            return null;\n-        }\n-    }\n-\n-    public TextLayoutTest() {\n-    }\n-\n-    private void setContent(PrismTextLayout layout, Object... content) {\n-        int count = content.length \/ 2;\n-        TextSpan[] spans = new TextSpan[count];\n-        int i = 0;\n-        while (i < content.length) {\n-            spans[i>>1] = new TestSpan(content[i++], content[i++]);\n-        }\n-        layout.setContent(spans);\n-    }\n-\n-    private void verifyLayout(PrismTextLayout layout, int lineCount, int runCount, int... glyphCount) {\n-        TextLine[] lines = layout.getLines();\n-        assertEquals(\"lineCount\", lineCount, lines.length);\n-        GlyphList[] runs = layout.getRuns();\n-        assertEquals(\"runCount\", runCount, runs.length);\n-        assertEquals(\"runCount\", runCount, glyphCount.length);\n-        for (int i = 0; i < runs.length; i++) {\n-            assertEquals(\"run \" +i, glyphCount[i], runs[i].getGlyphCount());\n-        }\n-    }\n-\n-    private void verifyComplex(PrismTextLayout layout, boolean... complex) {\n-        GlyphList[] runs = layout.getRuns();\n-        for (int i = 0; i < runs.length; i++) {\n-            assertEquals(\"run \" +i, complex[i], runs[i].isComplex());\n-        }\n-    }\n-\n-    @Ignore(\"JDK-8087615\")\n-    @Test public void buildRuns() {\n-\n-        PrismTextLayout layout = new PrismTextLayout();\n-        PGFont font = (PGFont) FontHelper.getNativeFont(Font.font(\"Monaco\", 12));\n-        PGFont font2 = (PGFont) FontHelper.getNativeFont(Font.font(\"Tahoma\", 12));\n-\n-        \/* simple case *\/\n-        layout.setContent(\"hello\", font);\n-        verifyLayout(layout, 1, 1, 5);\n-\n-        \/* simple case, two workd*\/\n-        layout.setContent(\"hello world\", font);\n-        verifyLayout(layout, 1, 1, 11);\n-\n-        \/* empty string *\/\n-        layout.setContent(\"\", font);\n-        verifyLayout(layout, 1, 1, 0);\n-\n-        \/* line break *\/\n-        layout.setContent(\"\\n\", font); \/\/first line has the line break (glyphCount=0),\n-        verifyLayout(layout, 2, 2, 0,0);\n-        layout.setContent(\"\\r\", font);\n-        verifyLayout(layout, 2, 2, 0,0);\n-        layout.setContent(\"\\r\\n\", font);\n-        verifyLayout(layout, 2, 2, 0,0);\n-        layout.setContent(\"a\\nb\", font);\n-        verifyLayout(layout, 2, 3, 1, 0, 1);\n-        layout.setContent(\"\\n\\n\\r\\r\\n\", font);\n-        verifyLayout(layout, 5, 5, 0,0,0,0,0);\n-\n-        \/* tabs *\/\n-        layout.setContent(\"\\t\", font);\n-        verifyLayout(layout, 1, 1, 0);\n-        layout.setContent(\"\\t\\t\", font);\n-        verifyLayout(layout, 1, 2, 0,0);\n-        layout.setContent(\"a\\tb\", font);\n-        verifyLayout(layout, 1, 3, 1,0,1);\n-\n-        \/* complex *\/\n-        layout.setContent(\"aa\"+J+J, font);\n-        verifyLayout(layout, 1, 1, 4);\/\/ no complex (english to japanese)\n-        verifyComplex(layout, false);\n-\n-\n-        layout.setContent(D, font);\n-        verifyLayout(layout, 1, 1, 1);\/\/ complex (english to devanagari)\n-        verifyComplex(layout, true);\n-\n-        layout.setContent(\"aa\"+D+D, font);\n-        verifyLayout(layout, 1, 2, 2,2);\/\/ complex (english to devanagari)\n-        verifyComplex(layout, false, true);\n-\n-        layout.setContent(D+D+\"aa\", font);\n-        verifyLayout(layout, 1, 2, 2,2);\/\/ complex (devanagari to english)\n-        verifyComplex(layout, true, false);\n-\n-        layout.setContent(\"aa\"+D+D+J+J, font);\n-        verifyLayout(layout, 1, 3, 2,2,2);\/\/ complex (english to devanagari to japanese)\n-        verifyComplex(layout, false, true, false);\n-\n-        \/*Tahoma has Thai but no Hindi, font slot break expected*\/\n-        layout.setContent(D+D+T+T, font2);\n-        verifyLayout(layout, 1, 2, 2,2);\/\/ complex (devanagari to thai)\n-        verifyComplex(layout, true, true);\n-\n-        layout.setContent(T+T+D+D+T+T, font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, true, true, true);\n-\n-        layout.setContent(T+T+D+D+\"aa\", font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, true, true, false);\n-\n-        layout.setContent(T+T+\"aa\"+T+T, font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, true, false, true);\n-\n-        layout.setContent(\"aa\"+D+D+T+T, font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, false, true, true);\n-\n-        \/* Rich Text test *\/\n-\n-        setContent(layout, \"hello \", font, \"world\", font);\n-        verifyLayout(layout, 1, 2, 6,5);\n-        verifyComplex(layout, false, false);\n-\n-        setContent(layout, \"aaa\", font, J+J+J, font);\n-        verifyLayout(layout, 1, 2, 3,3);\n-        verifyComplex(layout, false, false);\n-\n-        setContent(layout, \"aaa\", font, D+D+D, font);\n-        verifyLayout(layout, 1, 2, 3,3);\n-        verifyComplex(layout, false, true);\n-\n-        \/* can't merge \\r\\n in different spans*\/\n-        setContent(layout, \"aa\\r\", font, \"\\nbb\", font);\n-        verifyLayout(layout, 3, 4, 2,0,0,2);\n-        verifyComplex(layout, false, false, false, false);\n-\n-        setContent(layout, \"aa\\r\\n\", font, \"bb\", font);\n-        verifyLayout(layout, 2, 3, 2,0,2);\n-        verifyComplex(layout, false, false, false);\n-\n-        \/* can't merge surrogate pairs in different spans*\/\n-        setContent(layout, \"\\uD840\\uDC0B\", font, \"\\uD840\\uDC89\\uD840\\uDCA2\", font);\n-        verifyLayout(layout, 1, 2, 2, 4);\n-        GlyphList[] runs = layout.getRuns();\n-        assertTrue(runs[0].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[0].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(2) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(3) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-\n-        \/* Split surrogate pair*\/\n-        setContent(layout, \"\\uD840\\uDC0B\\uD840\", font, \"\\uDC89\\uD840\\uDCA2\", font);\n-        verifyLayout(layout, 1, 2, 3, 3);\n-        runs = layout.getRuns();\n-        assertTrue(runs[0].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[0].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[0].getGlyphCode(2) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\/\/broken pair, results in missing glyph\n-        assertTrue(runs[1].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\/\/broken pair, results in missing glyph\n-        assertTrue(runs[1].getGlyphCode(1) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(2) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-\n-    }\n-\n-}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/text\/TextLayoutTest.java","additions":0,"deletions":227,"binary":false,"changes":227,"status":"deleted"},{"patch":"@@ -17,1 +17,1 @@\n-\t\t\t<attribute name=\"add-exports\" value=\"javafx.graphics\/com.sun.glass.ui=ALL-UNNAMED:javafx.graphics\/com.sun.glass.ui.monocle=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.sg.prism=ALL-UNNAMED:javafx.graphics\/com.sun.prism.impl=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.image.impl=ALL-UNNAMED:javafx.graphics\/com.sun.glass.events=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.css=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.geom=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.tk=ALL-UNNAMED:javafx.graphics\/com.sun.glass.ui.mac=ALL-UNNAMED\"\/>\n+\t\t\t<attribute name=\"add-exports\" value=\"javafx.graphics\/com.sun.glass.ui=ALL-UNNAMED:javafx.graphics\/com.sun.glass.ui.monocle=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.sg.prism=ALL-UNNAMED:javafx.graphics\/com.sun.prism.impl=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.image.impl=ALL-UNNAMED:javafx.graphics\/com.sun.glass.events=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.css=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.geom=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.tk=ALL-UNNAMED:javafx.graphics\/com.sun.glass.ui.mac=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.scene.text=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.text=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.font=ALL-UNNAMED\"\/>\n","filename":"tests\/system\/src\/test\/.classpath","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+--add-exports javafx.graphics\/com.sun.javafx.scene.text=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.text=ALL-UNNAMED\n","filename":"tests\/system\/src\/test\/addExports","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,521 @@\n+\/*\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.text;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+import com.sun.javafx.font.CharToGlyphMapper;\n+import com.sun.javafx.font.PGFont;\n+import com.sun.javafx.geom.Point2D;\n+import com.sun.javafx.geom.RectBounds;\n+import com.sun.javafx.scene.text.FontHelper;\n+import com.sun.javafx.scene.text.GlyphList;\n+import com.sun.javafx.scene.text.TextLine;\n+import com.sun.javafx.scene.text.TextSpan;\n+import com.sun.javafx.text.PrismTextLayout;\n+\n+import javafx.scene.text.Font;\n+\n+public class TextLayoutTest {\n+    private static final String J = \"\\u3041\";  \/\/ Japanese not complex\n+    private static final String D = \"\\u0907\";  \/\/ Devanagari complex\n+    private static final String T = \"\\u0E34\";  \/\/ Thai complex\n+\n+    private final PrismTextLayout layout = new PrismTextLayout();\n+    private final PGFont font = (PGFont) FontHelper.getNativeFont(Font.font(\"Monaco\", 12));\n+    private final PGFont font2 = (PGFont) FontHelper.getNativeFont(Font.font(\"Tahoma\", 12));\n+\n+    class TestSpan implements TextSpan {\n+        String text;\n+        Object font;\n+        TestSpan(Object text, Object font) {\n+            this.text = (String)text;\n+            this.font = font;\n+        }\n+        @Override public String getText() {\n+            return text;\n+        }\n+        @Override public Object getFont() {\n+            return font;\n+        }\n+        @Override public RectBounds getBounds() {\n+            return null;\n+        }\n+    }\n+\n+    private void setContent(PrismTextLayout layout, Object... content) {\n+        int count = content.length \/ 2;\n+        TextSpan[] spans = new TextSpan[count];\n+        int i = 0;\n+        while (i < content.length) {\n+            spans[i>>1] = new TestSpan(content[i++], content[i++]);\n+        }\n+        layout.setContent(spans);\n+    }\n+\n+    private void assertLineCount(int lineCount) {\n+        assertEquals(lineCount, layout.getLines().length, \"lineCount\");\n+    }\n+\n+    private void assertLineBounds(RectBounds... rectBounds) {\n+        assertLineCount(rectBounds.length);\n+\n+        TextLine[] lines = layout.getLines();\n+\n+        for (int i = 0; i < lines.length; i++) {\n+            assertEquals(rectBounds[i], lines[i].getBounds(), \"line \" + i);\n+        }\n+    }\n+\n+    private void verifyLayout(int lineCount, int runCount, int... glyphCount) {\n+        TextLine[] lines = layout.getLines();\n+        assertEquals(lineCount, lines.length, \"lineCount\");\n+        GlyphList[] runs = layout.getRuns();\n+        assertEquals(runCount, runs.length, \"runCount\");\n+        assertEquals(runCount, glyphCount.length, \"runCount\");\n+        for (int i = 0; i < runs.length; i++) {\n+            assertEquals(glyphCount[i], runs[i].getGlyphCount(), \"run \" + i);\n+        }\n+    }\n+\n+    private void verifyComplex(boolean... complex) {\n+        GlyphList[] runs = layout.getRuns();\n+        for (int i = 0; i < runs.length; i++) {\n+            assertEquals(complex[i], runs[i].isComplex(), \"run \" + i);\n+        }\n+    }\n+\n+    \/**\n+     * These tests were broken for a long time (as early as 2013-06-28, see JDK-8087615).\n+     *\n+     * The reason they break is two fold:\n+     *\n+     * - Content that is split into multiple runs will have all runs set to \"complex\"\n+     *   if at least one run is set to \"complex\", while this test was expecting the\n+     *   runs containing non-complex characters to not become \"complex\".\n+     *\n+     * - The Tahoma font when used with a Thai character generates 2 glyphs per Thai\n+     *   character, while this test was expecting 1 glyph.\n+     *\/\n+    @Disabled(\"JDK-8087615\")\n+    @Test\n+    void complexTestsThatAreBrokenSince2013() {\n+        layout.setContent(\"aa\" + J + J, font);\n+        verifyLayout(1, 1, 4);  \/\/ no complex (english to japanese)\n+        verifyComplex(false);\n+\n+        layout.setContent(D, font);\n+        verifyLayout(1, 1, 1);  \/\/ complex (english to devanagari)\n+        verifyComplex(true);\n+\n+        layout.setContent(\"aa\" + D + D, font);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (english to devanagari)\n+        verifyComplex(false, true);\n+\n+        layout.setContent(D + D + \"aa\", font);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (devanagari to english)\n+        verifyComplex(true, false);\n+\n+        layout.setContent(\"aa\" + D + D + J + J, font);\n+        verifyLayout(1, 3, 2, 2, 2);  \/\/ complex (english to devanagari to japanese)\n+        verifyComplex(false, true, false);\n+\n+        \/\/ Tahoma has Thai but no Hindi, font slot break expected\n+        layout.setContent(D + D + T + T, font2);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (devanagari to thai)\n+        verifyComplex(true, true);\n+\n+        layout.setContent(T + T + D + D + T + T, font2);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(true, true, true);\n+\n+        layout.setContent(T + T + D + D + \"aa\", font2);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(true, true, false);\n+\n+        layout.setContent(T + T + \"aa\" + T + T, font2);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(true, false, true);\n+\n+        layout.setContent(\"aa\" + D + D + T + T, font2);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(false, true, true);\n+    }\n+\n+    \/**\n+     * These are fixed versions of the above tests to avoid\n+     * further regressions.\n+     *\/\n+    @Test\n+    void fixedComplexTestsToEnsureNoFurtherRegressions() {\n+        layout.setContent(\"aa\" + J + J, font);\n+        verifyLayout(1, 1, 4);  \/\/ no complex (english to japanese)\n+        verifyComplex(false);\n+\n+        layout.setContent(D, font);\n+        verifyLayout(1, 1, 1);  \/\/ complex (english to devanagari)\n+        verifyComplex(true);\n+\n+        layout.setContent(\"aa\" + D + D, font);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (english to devanagari)\n+        verifyComplex(true, true);\n+\n+        layout.setContent(D + D + \"aa\", font);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (devanagari to english)\n+        verifyComplex(true, true);\n+\n+        layout.setContent(\"aa\" + D + D + J + J, font);\n+        verifyLayout(1, 3, 2, 2, 2);  \/\/ complex (english to devanagari to japanese)\n+        verifyComplex(true, true, true);\n+\n+        \/\/ Tahoma has Thai but no Hindi, font slot break expected\n+        layout.setContent(D + D + T + T, font2);\n+        verifyLayout(1, 2, 2, 4);  \/\/ complex (devanagari to thai)\n+        verifyComplex(true, true);\n+\n+        layout.setContent(T + T + D + D + T + T, font2);\n+        verifyLayout(1, 3, 4, 2, 4);\n+        verifyComplex(true, true, true);\n+\n+        layout.setContent(T + T + D + D + \"aa\", font2);\n+        verifyLayout(1, 3, 4, 2, 2);\n+        verifyComplex(true, true, true);\n+\n+        layout.setContent(T + T + \"aa\" + T + T, font2);\n+        verifyLayout(1, 3, 4, 2, 4);\n+        verifyComplex(true, true, true);\n+\n+        layout.setContent(\"aa\" + D + D + T + T, font2);\n+        verifyLayout(1, 3, 2, 2, 4);\n+        verifyComplex(true, true, true);\n+    }\n+\n+    @Test\n+    void basicTest() {\n+        \/\/ simple case\n+        layout.setContent(\"hello\", font);\n+        verifyLayout(1, 1, 5);\n+\n+        \/\/ simple case, two words\n+        layout.setContent(\"hello world\", font);\n+        verifyLayout(1, 1, 11);\n+\n+        \/\/ empty string\n+        layout.setContent(\"\", font);\n+        verifyLayout(1, 1, 0);\n+\n+        \/\/ line break\n+        layout.setContent(\"\\n\", font);  \/\/ first line has the line break (glyphCount=0)\n+        verifyLayout(2, 2, 0, 0);\n+        layout.setContent(\"\\r\", font);\n+        verifyLayout(2, 2, 0, 0);\n+        layout.setContent(\"\\r\\n\", font);\n+        verifyLayout(2, 2, 0, 0);\n+        layout.setContent(\"a\\nb\", font);\n+        verifyLayout(2, 3, 1, 0, 1);\n+        layout.setContent(\"\\n\\n\\r\\r\\n\", font);\n+        verifyLayout(5, 5, 0, 0, 0, 0, 0);\n+\n+        \/\/ tabs\n+        layout.setContent(\"\\t\", font);\n+        verifyLayout(1, 1, 0);\n+        layout.setContent(\"\\t\\t\", font);\n+        verifyLayout(1, 2, 0, 0);\n+        layout.setContent(\"a\\tb\", font);\n+        verifyLayout(1, 3, 1, 0, 1);\n+    }\n+\n+    @Test\n+    void richTextTest() {\n+        setContent(layout, \"hello \", font, \"world\", font);\n+        verifyLayout(1, 2, 6, 5);\n+        verifyComplex(false, false);\n+\n+        setContent(layout, \"aaa\", font, J + J + J, font);\n+        verifyLayout(1, 2, 3, 3);\n+        verifyComplex(false, false);\n+\n+        setContent(layout, \"aaa\", font, D + D + D, font);\n+        verifyLayout(1, 2, 3, 3);\n+        verifyComplex(false, true);\n+\n+        \/\/ can't merge \\r\\n in different spans\n+        setContent(layout, \"aa\\r\", font, \"\\nbb\", font);\n+        verifyLayout(3, 4, 2, 0, 0, 2);\n+        verifyComplex(false, false, false, false);\n+\n+        setContent(layout, \"aa\\r\\n\", font, \"bb\", font);\n+        verifyLayout(2, 3, 2, 0, 2);\n+        verifyComplex(false, false, false);\n+\n+        \/\/ can't merge surrogate pairs in different spans\n+        setContent(layout, \"\\uD840\\uDC0B\", font, \"\\uD840\\uDC89\\uD840\\uDCA2\", font);\n+        verifyLayout(1, 2, 2, 4);\n+        GlyphList[] runs = layout.getRuns();\n+        assertTrue(runs[0].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[0].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(2) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(3) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+\n+        \/\/ Split surrogate pair\n+        setContent(layout, \"\\uD840\\uDC0B\\uD840\", font, \"\\uDC89\\uD840\\uDCA2\", font);\n+        verifyLayout(1, 2, 3, 3);\n+        runs = layout.getRuns();\n+        assertTrue(runs[0].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[0].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[0].getGlyphCode(2) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);  \/\/ broken pair, results in missing glyph\n+        assertTrue(runs[1].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);  \/\/ broken pair, results in missing glyph\n+        assertTrue(runs[1].getGlyphCode(1) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(2) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+    }\n+\n+    @Test\n+    void shouldIgnoreAlignmentWhenWrappingIsDisabled() {\n+        layout.setContent(\"The quick brown fox jumps over the lazy dog\", font);\n+\n+        for (int i = 0; i < 3; i++) {\n+            layout.setAlignment(i);\n+\n+            assertLineCount(1);\n+            assertLineBounds(new RectBounds(0, -12, 309.6504f, 4.001953f));\n+        }\n+    }\n+\n+    enum Case {\n+\n+        \/**\n+         * Checks that alignment variations have no effect when not wrapping.\n+         *\/\n+        NO_WRAP(new Parameters(\n+            \"The quick brown fox jumps over the lazy dog\",\n+            Font.font(\"Monaco\", 12),\n+            0.0f, List.of(309.6504f),\n+            12.0f, 4.001953f\n+        )),\n+\n+        \/**\n+         * Checks that the individual lines of hard wrapped text are still\n+         * taking alignment into account (in this specific case, the first\n+         * line, which is the widest line, will not be aligned, but the 2nd\n+         * line will be aligned as it is less wide).\n+         *\/\n+        HARD_WRAP(new Parameters(\n+            \"The quick brown fox jumps\\nover the lazy dog\",\n+            Font.font(\"Monaco\", 12),\n+            0.0f, List.of(180.0293f, 122.41992f),\n+            12.0f, 4.001953f\n+        )),\n+\n+        \/**\n+         * Checks that trailing white space is NOT ignored when wrapping\n+         * is not enabled.\n+         *\/\n+        HARD_WRAP_WITH_EXTRA_TRAILING_SPACE(new Parameters(\n+            \"The quick brown fox jumps           \\nover the lazy dog           \",\n+            Font.font(\"Monaco\", 12),\n+            0.0f, List.of(180.0293f + 79.2129f, 122.41992f + 79.2129f),\n+            12.0f, 4.001953f\n+        )),\n+\n+        \/**\n+         * Checks that single white spaces are ignored for alignment\n+         * purposes when wrapping is enabled in simple text. This soft\n+         * wraps after \"jumps\".\n+         *\/\n+        SOFT_WRAP(new Parameters(\n+            \"The quick brown fox jumps over the lazy dog\",\n+            Font.font(\"Monaco\", 12),\n+            200.0f, List.of(180.0293f, 122.41992f),\n+            12.0f, 4.001953f\n+        )),\n+\n+        \/**\n+         * Checks that trailing white spaces are NOT stripped even when\n+         * some lines are soft wrapped. This soft wraps after \"jumps\"\n+         * and has 4 trailing spaces on the 2nd line where no soft\n+         * wrap occurs, and so they should be kept intact.\n+         *\/\n+        SOFT_WRAP_WITH_TRAILING_SPACE(new Parameters(\n+            \"The quick brown fox jumps over the lazy dog    \",\n+            Font.font(\"Monaco\", 12),\n+            200.0f, List.of(180.0293f, 122.41992f + 28.80469f),\n+            12.0f, 4.001953f\n+        )),\n+\n+        \/**\n+         * Checks that multiple white spaces are ignored for alignment\n+         * purposes when wrapping is enabled in simple text. This soft\n+         * wraps after \"jumps\".\n+         *\/\n+        SOFT_WRAP_WITH_EXTRA_SPACE(new Parameters(\n+            \"The quick brown fox jumps           over the lazy dog\",\n+            Font.font(\"Monaco\", 12),\n+            200.0f, List.of(180.0293f, 122.41992f),\n+            12.0f, 4.001953f\n+        )),\n+\n+        \/**\n+         * Checks that single white spaces are ignored for alignment\n+         * purposes when wrapping is enabled in complex text. This soft\n+         * wraps after \"jumps\".\n+         *\/\n+        SOFT_WRAP_WITH_COMPLEX_TEXT(new Parameters(\n+            \"The quick brown लोमड़ी jumps over the lazy कुत्ता\",\n+            Font.font(\"Monaco\", 12),\n+            200.0f, List.of(189.89649f, 122.583984f),\n+            12.0f, 4.001953f\n+        )),\n+\n+        \/**\n+         * Checks that multiple white spaces are ignored for alignment\n+         * purposes when wrapping is enabled in complex text. This soft\n+         * wraps after \"jumps\".\n+         *\/\n+        SOFT_WRAP_WITH_COMPLEX_TEXT_AND_EXTRA_TRAILING_SPACE(new Parameters(\n+            \"The quick brown लोमड़ी jumps           over the lazy कुत्ता\",\n+            Font.font(\"Monaco\", 12),\n+            200.0f, List.of(189.89649f, 122.583984f),\n+            12.0f, 4.001953f\n+        ));\n+\n+        Parameters parameters;\n+\n+        Case(Parameters parameters) {\n+            this.parameters = parameters;\n+        }\n+\n+        record Parameters(String text, Font font, float wrapWidth, List<Float> lineWidths, float ascent, float descent) {\n+            Parameters {\n+                assert text != null;\n+                assert font != null;\n+                assert wrapWidth >= 0;\n+                assert lineWidths != null;\n+                assert ascent > 0;\n+                assert descent > 0;\n+                assert lineWidths.size() > 0;\n+            }\n+\n+            int lineCount() {\n+                return lineWidths.size();\n+            }\n+\n+            float maxWidth() {\n+                return lineWidths.stream().max(Float::compareTo).orElseThrow();\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(Case.class)\n+    void caseTest(Case c) {\n+        Case.Parameters p = c.parameters;\n+\n+        final float ASCENT = p.ascent;\n+        final float DESCENT = p.descent;\n+        final float WRAP = p.wrapWidth == 0 ? p.maxWidth() : p.wrapWidth;\n+        final float CENTER = 0.5f * WRAP;\n+\n+        \/\/ split content on line feeds (without removing the line feeds):\n+        layout.setContent(Arrays.stream(p.text.split(\"(?<=\\n)\")).map(text -> new TestSpan(text, FontHelper.getNativeFont(p.font))).toArray(TextSpan[]::new));\n+        layout.setWrapWidth(p.wrapWidth);\n+\n+        \/\/ LEFT ALIGNMENT\n+\n+        layout.setAlignment(0);  \/\/ 0 == left\n+\n+        assertLineCount(p.lineCount());\n+\n+        for (int i = 0; i < p.lineCount(); i++) {\n+            TextLine[] lines = layout.getLines();\n+            String description = \"left aligned: line \" + i + \" for \" + c.parameters;\n+            RectBounds expectedBounds = new RectBounds(0, -ASCENT, p.lineWidths.get(i), DESCENT);\n+            Point2D expectedLocation = new Point2D(0, i * (ASCENT + DESCENT));\n+\n+            assertEquals(expectedBounds, lines[i].getBounds(), description);\n+            assertEquals(expectedLocation, lines[i].getRuns()[0].getLocation(), description);\n+        }\n+\n+        \/\/ CENTER ALIGNMENT\n+\n+        layout.setAlignment(1);  \/\/ 1 == center\n+\n+        assertLineCount(p.lineCount());\n+\n+        for (int i = 0; i < p.lineCount(); i++) {\n+            TextLine[] lines = layout.getLines();\n+            String description = \"centered: line \" + i + \" for \" + p;\n+            RectBounds expectedBounds = new RectBounds(CENTER - 0.5f * p.lineWidths.get(i), -ASCENT, CENTER + 0.5f * p.lineWidths.get(i), DESCENT);\n+            Point2D expectedLocation = new Point2D(CENTER - 0.5f * p.lineWidths.get(i), i * (ASCENT + DESCENT));\n+\n+            assertEquals(expectedBounds, lines[i].getBounds(), description);\n+            assertEquals(expectedLocation, lines[i].getRuns()[0].getLocation(), description);\n+        }\n+\n+        \/\/ RIGHT ALIGNMENT\n+\n+        layout.setAlignment(2);  \/\/ 2 == right\n+\n+        assertLineCount(p.lineCount());\n+\n+        for (int i = 0; i < p.lineCount(); i++) {\n+            TextLine[] lines = layout.getLines();\n+            String description = \"right aligned: line \" + i + \" for \" + p;\n+            RectBounds expectedBounds = new RectBounds(WRAP - p.lineWidths.get(i), -ASCENT, WRAP, DESCENT);\n+            Point2D expectedLocation = new Point2D(WRAP - p.lineWidths.get(i), i * (ASCENT + DESCENT));\n+\n+            assertEquals(expectedBounds, lines[i].getBounds(), description);\n+            assertEquals(expectedLocation, lines[i].getRuns()[0].getLocation(), description);\n+        }\n+\n+        \/\/ JUSTIFIED ALIGNMENT\n+\n+        layout.setAlignment(3);  \/\/ 3 == justified\n+\n+        assertLineCount(p.lineCount());\n+\n+        for (int i = 0; i < p.lineCount(); i++) {\n+            TextLine[] lines = layout.getLines();\n+            String description = \"justified: line \" + i + \" for \" + p;\n+            boolean lastLine = i == p.lineCount() - 1;\n+            RectBounds expectedBounds = new RectBounds(0, -ASCENT, lastLine ? p.lineWidths.get(i) : WRAP, DESCENT);\n+            Point2D expectedLocation = new Point2D(0, i * (ASCENT + DESCENT));\n+\n+            assertEquals(expectedBounds, lines[i].getBounds(), description);\n+            assertEquals(expectedLocation, lines[i].getRuns()[0].getLocation(), description);\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/com\/sun\/javafx\/text\/TextLayoutTest.java","additions":521,"deletions":0,"binary":false,"changes":521,"status":"added"}]}