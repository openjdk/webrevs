{"files":[{"patch":"@@ -457,1 +457,1 @@\n-                    for (TextRun r: lines[i].runs) {\n+                    for (TextRun r: lines[i].getRuns()) {\n@@ -762,1 +762,1 @@\n-                for (TextRun r : lines[index].runs) {\n+                for (TextRun r : lines[index].getRuns()) {\n@@ -996,0 +996,3 @@\n+\n+        assert count > 0 : \"number of TextRuns in a TextLine cannot be less than one: \" + count;\n+\n@@ -1012,0 +1015,7 @@\n+\n+        \/*\n+         * Calculate the width of trailing spaces for the new TextLine so they\n+         * can be excluded when doing later alignment calculations:\n+         *\/\n+        float trailingSpaceWidth = computeTrailingSpaceWidth(lineRuns);\n+\n@@ -1014,1 +1024,34 @@\n-                            width, ascent, descent, leading);\n+                            width, ascent, descent, leading, trailingSpaceWidth);\n+    }\n+\n+    \/**\n+     * Computes the size of the white space trailing a given line defined by the start offset and length.\n+     *\n+     * <p>Note: textRuns is split in such a way that it matches the line, so the last text run's last\n+     * character is the point of a line break.\n+     *\n+     * @param textRuns the text runs the line consists off\n+     * @return the X size of the white space trailing the line\n+     *\/\n+    private float computeTrailingSpaceWidth(TextRun[] textRuns) {\n+        TextRun textRun = textRuns[textRuns.length - 1];\n+        float trailingSpaceWidth = 0;\n+        char[] chars = getText();\n+\n+        \/*\n+         * As the loop below exits when encountering a non-white space character,\n+         * testing each trailing glyph in turn for white space is safe, as white\n+         * space is always represented with only a single glyph:\n+         *\/\n+\n+        for (int i = textRun.getGlyphCount() - 1; i >= 0; i--) {\n+            int textOffset = textRun.getStart() + textRun.getCharOffset(i);\n+\n+            if (!Character.isWhitespace(chars[textOffset])) {\n+                break;\n+            }\n+\n+            trailingSpaceWidth += textRun.getAdvance(i);\n+        }\n+\n+        return trailingSpaceWidth;\n@@ -1195,1 +1238,3 @@\n-                while (offset + 1 < runEnd && chars[offset] == ' ') {\n+\n+                \/\/ Don't take spaces into account at the preferred wrap index:\n+                while (offset + 1 < runEnd && Character.isWhitespace(chars[offset])) {\n@@ -1197,4 +1242,0 @@\n-                    \/* Preserve behaviour: only keep one white space in the line\n-                     * before wrapping. Needed API to allow change.\n-                     *\/\n-                    break;\n@@ -1310,1 +1351,1 @@\n-        float fullWidth = Math.max(wrapWidth, layoutWidth);\n+        float fullWidth = wrapWidth > 0 ? wrapWidth : layoutWidth;  \/\/ layoutWidth = widest line, wrapWidth is user set\n@@ -1327,1 +1368,2 @@\n-            float lineX = (fullWidth - bounds.getWidth()) * align;\n+            float unusedWidth = fullWidth - bounds.getWidth() + (wrapWidth > 0 ? line.getTrailingSpaceWidth() : 0);\n+            float lineX = unusedWidth * align;\n@@ -1345,1 +1387,1 @@\n-                        float inc = (fullWidth - bounds.getWidth()) \/ wsCount;\n+                        float inc = unusedWidth \/ wsCount;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/PrismTextLayout.java","additions":53,"deletions":11,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -31,5 +31,8 @@\n-    TextRun[] runs;\n-    RectBounds bounds;\n-    float lsb, rsb, leading;\n-    int start;\n-    int length;\n+    private final TextRun[] runs;\n+    private final RectBounds bounds;\n+    private final int start;\n+    private final int length;\n+    private final float leading;\n+    private final float trailingSpaceWidth;\n+\n+    private float lsb, rsb;\n@@ -38,1 +41,1 @@\n-                    float width, float ascent, float descent, float leading) {\n+                    float width, float ascent, float descent, float leading, float trailingSpaceWidth) {\n@@ -44,0 +47,1 @@\n+        this.trailingSpaceWidth = trailingSpaceWidth;\n@@ -70,0 +74,4 @@\n+    public float getTrailingSpaceWidth() {\n+        return trailingSpaceWidth;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/TextLine.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -346,0 +346,13 @@\n+\n+        \/*\n+         * When positions is null it means that the TextRun only contains\n+         * a line break, assuming that the class is used correctly (\"shape\"\n+         * must be called before calling this method, unless the class user is\n+         * sure that the run is empty). This class could benefit from better\n+         * encapsulation to make it easier to reason about.\n+         *\/\n+\n+        if (positions == null) {\n+            return 0;\n+        }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/TextRun.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,227 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package test.com.sun.javafx.text;\n-\n-import javafx.scene.text.Font;\n-\n-import com.sun.javafx.font.PGFont;\n-import com.sun.javafx.geom.RectBounds;\n-import com.sun.javafx.scene.text.GlyphList;\n-import com.sun.javafx.scene.text.TextSpan;\n-import com.sun.javafx.scene.text.TextLine;\n-import com.sun.javafx.scene.text.FontHelper;\n-import com.sun.javafx.font.CharToGlyphMapper;\n-import com.sun.javafx.text.PrismTextLayout;\n-\n-import org.junit.Ignore;\n-import org.junit.Test;\n-\n-import static org.junit.Assert.*;\n-\n-public class TextLayoutTest {\n-    private String J = \"\\u3041\";  \/\/Japanese not complex\n-    private String D = \"\\u0907\"; \/\/Devanagari complex\n-    private String T = \"\\u0E34\"; \/\/Devanagari complex\n-\n-    class TestSpan implements TextSpan {\n-        String text;\n-        Object font;\n-        TestSpan(Object text, Object font) {\n-            this.text = (String)text;\n-            this.font = font;\n-        }\n-        @Override public String getText() {\n-            return text;\n-        }\n-        @Override public Object getFont() {\n-            return font;\n-        }\n-        @Override public RectBounds getBounds() {\n-            return null;\n-        }\n-    }\n-\n-    public TextLayoutTest() {\n-    }\n-\n-    private void setContent(PrismTextLayout layout, Object... content) {\n-        int count = content.length \/ 2;\n-        TextSpan[] spans = new TextSpan[count];\n-        int i = 0;\n-        while (i < content.length) {\n-            spans[i>>1] = new TestSpan(content[i++], content[i++]);\n-        }\n-        layout.setContent(spans);\n-    }\n-\n-    private void verifyLayout(PrismTextLayout layout, int lineCount, int runCount, int... glyphCount) {\n-        TextLine[] lines = layout.getLines();\n-        assertEquals(\"lineCount\", lineCount, lines.length);\n-        GlyphList[] runs = layout.getRuns();\n-        assertEquals(\"runCount\", runCount, runs.length);\n-        assertEquals(\"runCount\", runCount, glyphCount.length);\n-        for (int i = 0; i < runs.length; i++) {\n-            assertEquals(\"run \" +i, glyphCount[i], runs[i].getGlyphCount());\n-        }\n-    }\n-\n-    private void verifyComplex(PrismTextLayout layout, boolean... complex) {\n-        GlyphList[] runs = layout.getRuns();\n-        for (int i = 0; i < runs.length; i++) {\n-            assertEquals(\"run \" +i, complex[i], runs[i].isComplex());\n-        }\n-    }\n-\n-    @Ignore(\"JDK-8087615\")\n-    @Test public void buildRuns() {\n-\n-        PrismTextLayout layout = new PrismTextLayout();\n-        PGFont font = (PGFont) FontHelper.getNativeFont(Font.font(\"Monaco\", 12));\n-        PGFont font2 = (PGFont) FontHelper.getNativeFont(Font.font(\"Tahoma\", 12));\n-\n-        \/* simple case *\/\n-        layout.setContent(\"hello\", font);\n-        verifyLayout(layout, 1, 1, 5);\n-\n-        \/* simple case, two workd*\/\n-        layout.setContent(\"hello world\", font);\n-        verifyLayout(layout, 1, 1, 11);\n-\n-        \/* empty string *\/\n-        layout.setContent(\"\", font);\n-        verifyLayout(layout, 1, 1, 0);\n-\n-        \/* line break *\/\n-        layout.setContent(\"\\n\", font); \/\/first line has the line break (glyphCount=0),\n-        verifyLayout(layout, 2, 2, 0,0);\n-        layout.setContent(\"\\r\", font);\n-        verifyLayout(layout, 2, 2, 0,0);\n-        layout.setContent(\"\\r\\n\", font);\n-        verifyLayout(layout, 2, 2, 0,0);\n-        layout.setContent(\"a\\nb\", font);\n-        verifyLayout(layout, 2, 3, 1, 0, 1);\n-        layout.setContent(\"\\n\\n\\r\\r\\n\", font);\n-        verifyLayout(layout, 5, 5, 0,0,0,0,0);\n-\n-        \/* tabs *\/\n-        layout.setContent(\"\\t\", font);\n-        verifyLayout(layout, 1, 1, 0);\n-        layout.setContent(\"\\t\\t\", font);\n-        verifyLayout(layout, 1, 2, 0,0);\n-        layout.setContent(\"a\\tb\", font);\n-        verifyLayout(layout, 1, 3, 1,0,1);\n-\n-        \/* complex *\/\n-        layout.setContent(\"aa\"+J+J, font);\n-        verifyLayout(layout, 1, 1, 4);\/\/ no complex (english to japanese)\n-        verifyComplex(layout, false);\n-\n-\n-        layout.setContent(D, font);\n-        verifyLayout(layout, 1, 1, 1);\/\/ complex (english to devanagari)\n-        verifyComplex(layout, true);\n-\n-        layout.setContent(\"aa\"+D+D, font);\n-        verifyLayout(layout, 1, 2, 2,2);\/\/ complex (english to devanagari)\n-        verifyComplex(layout, false, true);\n-\n-        layout.setContent(D+D+\"aa\", font);\n-        verifyLayout(layout, 1, 2, 2,2);\/\/ complex (devanagari to english)\n-        verifyComplex(layout, true, false);\n-\n-        layout.setContent(\"aa\"+D+D+J+J, font);\n-        verifyLayout(layout, 1, 3, 2,2,2);\/\/ complex (english to devanagari to japanese)\n-        verifyComplex(layout, false, true, false);\n-\n-        \/*Tahoma has Thai but no Hindi, font slot break expected*\/\n-        layout.setContent(D+D+T+T, font2);\n-        verifyLayout(layout, 1, 2, 2,2);\/\/ complex (devanagari to thai)\n-        verifyComplex(layout, true, true);\n-\n-        layout.setContent(T+T+D+D+T+T, font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, true, true, true);\n-\n-        layout.setContent(T+T+D+D+\"aa\", font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, true, true, false);\n-\n-        layout.setContent(T+T+\"aa\"+T+T, font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, true, false, true);\n-\n-        layout.setContent(\"aa\"+D+D+T+T, font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, false, true, true);\n-\n-        \/* Rich Text test *\/\n-\n-        setContent(layout, \"hello \", font, \"world\", font);\n-        verifyLayout(layout, 1, 2, 6,5);\n-        verifyComplex(layout, false, false);\n-\n-        setContent(layout, \"aaa\", font, J+J+J, font);\n-        verifyLayout(layout, 1, 2, 3,3);\n-        verifyComplex(layout, false, false);\n-\n-        setContent(layout, \"aaa\", font, D+D+D, font);\n-        verifyLayout(layout, 1, 2, 3,3);\n-        verifyComplex(layout, false, true);\n-\n-        \/* can't merge \\r\\n in different spans*\/\n-        setContent(layout, \"aa\\r\", font, \"\\nbb\", font);\n-        verifyLayout(layout, 3, 4, 2,0,0,2);\n-        verifyComplex(layout, false, false, false, false);\n-\n-        setContent(layout, \"aa\\r\\n\", font, \"bb\", font);\n-        verifyLayout(layout, 2, 3, 2,0,2);\n-        verifyComplex(layout, false, false, false);\n-\n-        \/* can't merge surrogate pairs in different spans*\/\n-        setContent(layout, \"\\uD840\\uDC0B\", font, \"\\uD840\\uDC89\\uD840\\uDCA2\", font);\n-        verifyLayout(layout, 1, 2, 2, 4);\n-        GlyphList[] runs = layout.getRuns();\n-        assertTrue(runs[0].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[0].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(2) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(3) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-\n-        \/* Split surrogate pair*\/\n-        setContent(layout, \"\\uD840\\uDC0B\\uD840\", font, \"\\uDC89\\uD840\\uDCA2\", font);\n-        verifyLayout(layout, 1, 2, 3, 3);\n-        runs = layout.getRuns();\n-        assertTrue(runs[0].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[0].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[0].getGlyphCode(2) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\/\/broken pair, results in missing glyph\n-        assertTrue(runs[1].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\/\/broken pair, results in missing glyph\n-        assertTrue(runs[1].getGlyphCode(1) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-        assertTrue(runs[1].getGlyphCode(2) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n-\n-    }\n-\n-}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/text\/TextLayoutTest.java","additions":0,"deletions":227,"binary":false,"changes":227,"status":"deleted"},{"patch":"@@ -17,1 +17,1 @@\n-\t\t\t<attribute name=\"add-exports\" value=\"javafx.graphics\/com.sun.glass.ui=ALL-UNNAMED:javafx.graphics\/com.sun.glass.ui.monocle=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.sg.prism=ALL-UNNAMED:javafx.graphics\/com.sun.prism.impl=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.image.impl=ALL-UNNAMED:javafx.graphics\/com.sun.glass.events=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.css=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.geom=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.tk=ALL-UNNAMED:javafx.graphics\/com.sun.glass.ui.mac=ALL-UNNAMED\"\/>\n+\t\t\t<attribute name=\"add-exports\" value=\"javafx.graphics\/com.sun.glass.ui=ALL-UNNAMED:javafx.graphics\/com.sun.glass.ui.monocle=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.sg.prism=ALL-UNNAMED:javafx.graphics\/com.sun.prism.impl=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.image.impl=ALL-UNNAMED:javafx.graphics\/com.sun.glass.events=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.css=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.geom=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.tk=ALL-UNNAMED:javafx.graphics\/com.sun.glass.ui.mac=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.scene.text=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.text=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.font=ALL-UNNAMED\"\/>\n","filename":"tests\/system\/src\/test\/.classpath","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+--add-exports javafx.graphics\/com.sun.javafx.scene.text=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.text=ALL-UNNAMED\n","filename":"tests\/system\/src\/test\/addExports","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,506 @@\n+\/*\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.text;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+import com.sun.javafx.font.CharToGlyphMapper;\n+import com.sun.javafx.font.PGFont;\n+import com.sun.javafx.geom.Point2D;\n+import com.sun.javafx.geom.RectBounds;\n+import com.sun.javafx.scene.text.FontHelper;\n+import com.sun.javafx.scene.text.GlyphList;\n+import com.sun.javafx.scene.text.TextLine;\n+import com.sun.javafx.scene.text.TextSpan;\n+import com.sun.javafx.text.PrismTextLayout;\n+\n+import javafx.scene.text.Font;\n+\n+public class TextLayoutTest {\n+    private static final String J = \"\\u3041\";  \/\/ Japanese not complex\n+    private static final String D = \"\\u0907\";  \/\/ Devanagari complex\n+    private static final String T = \"\\u0E34\";  \/\/ Thai complex\n+\n+    private final PrismTextLayout layout = new PrismTextLayout();\n+    private final PGFont font = (PGFont) FontHelper.getNativeFont(Font.font(\"Monaco\", 12));\n+    private final PGFont font2 = (PGFont) FontHelper.getNativeFont(Font.font(\"Tahoma\", 12));\n+\n+    class TestSpan implements TextSpan {\n+        String text;\n+        Object font;\n+        TestSpan(Object text, Object font) {\n+            this.text = (String)text;\n+            this.font = font;\n+        }\n+        @Override public String getText() {\n+            return text;\n+        }\n+        @Override public Object getFont() {\n+            return font;\n+        }\n+        @Override public RectBounds getBounds() {\n+            return null;\n+        }\n+    }\n+\n+    private void setContent(PrismTextLayout layout, Object... content) {\n+        int count = content.length \/ 2;\n+        TextSpan[] spans = new TextSpan[count];\n+        int i = 0;\n+        while (i < content.length) {\n+            spans[i>>1] = new TestSpan(content[i++], content[i++]);\n+        }\n+        layout.setContent(spans);\n+    }\n+\n+    private void assertLineCount(int lineCount) {\n+        assertEquals(lineCount, layout.getLines().length, \"lineCount\");\n+    }\n+\n+    private void assertLineBounds(RectBounds... rectBounds) {\n+        assertLineCount(rectBounds.length);\n+\n+        TextLine[] lines = layout.getLines();\n+\n+        for (int i = 0; i < lines.length; i++) {\n+            assertEquals(rectBounds[i], lines[i].getBounds(), \"line \" + i);\n+        }\n+    }\n+\n+    private void verifyLayout(int lineCount, int runCount, int... glyphCount) {\n+        TextLine[] lines = layout.getLines();\n+        assertEquals(lineCount, lines.length, \"lineCount\");\n+        GlyphList[] runs = layout.getRuns();\n+        assertEquals(runCount, runs.length, \"runCount\");\n+        assertEquals(runCount, glyphCount.length, \"runCount\");\n+        for (int i = 0; i < runs.length; i++) {\n+            assertEquals(glyphCount[i], runs[i].getGlyphCount(), \"run \" + i);\n+        }\n+    }\n+\n+    private void verifyComplex(boolean... complex) {\n+        GlyphList[] runs = layout.getRuns();\n+        for (int i = 0; i < runs.length; i++) {\n+            assertEquals(complex[i], runs[i].isComplex(), \"run \" + i);\n+        }\n+    }\n+\n+    \/**\n+     * These tests were broken for a long time (as early as 2013-06-28, see JDK-8087615).\n+     *\n+     * The reason they break is two fold:\n+     *\n+     * - Content that is split into multiple runs will have all runs set to \"complex\"\n+     *   if at least one run is set to \"complex\", while this test was expecting the\n+     *   runs containing non-complex characters to not become \"complex\".\n+     *\n+     * - The Tahoma font when used with a Thai character generates 2 glyphs per Thai\n+     *   character, while this test was expecting 1 glyph.\n+     *\/\n+    @Disabled(\"JDK-8087615\")\n+    @Test\n+    void complexTestsThatAreBrokenSince2013() {\n+        layout.setContent(\"aa\" + J + J, font);\n+        verifyLayout(1, 1, 4);  \/\/ no complex (english to japanese)\n+        verifyComplex(false);\n+\n+        layout.setContent(D, font);\n+        verifyLayout(1, 1, 1);  \/\/ complex (english to devanagari)\n+        verifyComplex(true);\n+\n+        layout.setContent(\"aa\" + D + D, font);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (english to devanagari)\n+        verifyComplex(false, true);\n+\n+        layout.setContent(D + D + \"aa\", font);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (devanagari to english)\n+        verifyComplex(true, false);\n+\n+        layout.setContent(\"aa\" + D + D + J + J, font);\n+        verifyLayout(1, 3, 2, 2, 2);  \/\/ complex (english to devanagari to japanese)\n+        verifyComplex(false, true, false);\n+\n+        \/\/ Tahoma has Thai but no Hindi, font slot break expected\n+        layout.setContent(D + D + T + T, font2);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (devanagari to thai)\n+        verifyComplex(true, true);\n+\n+        layout.setContent(T + T + D + D + T + T, font2);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(true, true, true);\n+\n+        layout.setContent(T + T + D + D + \"aa\", font2);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(true, true, false);\n+\n+        layout.setContent(T + T + \"aa\" + T + T, font2);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(true, false, true);\n+\n+        layout.setContent(\"aa\" + D + D + T + T, font2);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(false, true, true);\n+    }\n+\n+    \/**\n+     * These are fixed versions of the above tests to avoid\n+     * further regressions.\n+     *\/\n+    @Test\n+    void fixedComplexTestsToEnsureNoFurtherRegressions() {\n+        layout.setContent(\"aa\" + J + J, font);\n+        verifyLayout(1, 1, 4);  \/\/ no complex (english to japanese)\n+        verifyComplex(false);\n+\n+        layout.setContent(D, font);\n+        verifyLayout(1, 1, 1);  \/\/ complex (english to devanagari)\n+        verifyComplex(true);\n+\n+        layout.setContent(\"aa\" + D + D, font);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (english to devanagari)\n+        verifyComplex(true, true);\n+\n+        layout.setContent(D + D + \"aa\", font);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (devanagari to english)\n+        verifyComplex(true, true);\n+\n+        layout.setContent(\"aa\" + D + D + J + J, font);\n+        verifyLayout(1, 3, 2, 2, 2);  \/\/ complex (english to devanagari to japanese)\n+        verifyComplex(true, true, true);\n+\n+        \/\/ Tahoma has Thai but no Hindi, font slot break expected\n+        layout.setContent(D + D + T + T, font2);\n+        verifyLayout(1, 2, 2, 4);  \/\/ complex (devanagari to thai)\n+        verifyComplex(true, true);\n+\n+        layout.setContent(T + T + D + D + T + T, font2);\n+        verifyLayout(1, 3, 4, 2, 4);\n+        verifyComplex(true, true, true);\n+\n+        layout.setContent(T + T + D + D + \"aa\", font2);\n+        verifyLayout(1, 3, 4, 2, 2);\n+        verifyComplex(true, true, true);\n+\n+        layout.setContent(T + T + \"aa\" + T + T, font2);\n+        verifyLayout(1, 3, 4, 2, 4);\n+        verifyComplex(true, true, true);\n+\n+        layout.setContent(\"aa\" + D + D + T + T, font2);\n+        verifyLayout(1, 3, 2, 2, 4);\n+        verifyComplex(true, true, true);\n+    }\n+\n+    @Test\n+    void basicTest() {\n+        \/\/ simple case\n+        layout.setContent(\"hello\", font);\n+        verifyLayout(1, 1, 5);\n+\n+        \/\/ simple case, two words\n+        layout.setContent(\"hello world\", font);\n+        verifyLayout(1, 1, 11);\n+\n+        \/\/ empty string\n+        layout.setContent(\"\", font);\n+        verifyLayout(1, 1, 0);\n+\n+        \/\/ line break\n+        layout.setContent(\"\\n\", font);  \/\/ first line has the line break (glyphCount=0)\n+        verifyLayout(2, 2, 0, 0);\n+        layout.setContent(\"\\r\", font);\n+        verifyLayout(2, 2, 0, 0);\n+        layout.setContent(\"\\r\\n\", font);\n+        verifyLayout(2, 2, 0, 0);\n+        layout.setContent(\"a\\nb\", font);\n+        verifyLayout(2, 3, 1, 0, 1);\n+        layout.setContent(\"\\n\\n\\r\\r\\n\", font);\n+        verifyLayout(5, 5, 0, 0, 0, 0, 0);\n+\n+        \/\/ tabs\n+        layout.setContent(\"\\t\", font);\n+        verifyLayout(1, 1, 0);\n+        layout.setContent(\"\\t\\t\", font);\n+        verifyLayout(1, 2, 0, 0);\n+        layout.setContent(\"a\\tb\", font);\n+        verifyLayout(1, 3, 1, 0, 1);\n+    }\n+\n+    @Test\n+    void richTextTest() {\n+        setContent(layout, \"hello \", font, \"world\", font);\n+        verifyLayout(1, 2, 6, 5);\n+        verifyComplex(false, false);\n+\n+        setContent(layout, \"aaa\", font, J + J + J, font);\n+        verifyLayout(1, 2, 3, 3);\n+        verifyComplex(false, false);\n+\n+        setContent(layout, \"aaa\", font, D + D + D, font);\n+        verifyLayout(1, 2, 3, 3);\n+        verifyComplex(false, true);\n+\n+        \/\/ can't merge \\r\\n in different spans\n+        setContent(layout, \"aa\\r\", font, \"\\nbb\", font);\n+        verifyLayout(3, 4, 2, 0, 0, 2);\n+        verifyComplex(false, false, false, false);\n+\n+        setContent(layout, \"aa\\r\\n\", font, \"bb\", font);\n+        verifyLayout(2, 3, 2, 0, 2);\n+        verifyComplex(false, false, false);\n+\n+        \/\/ can't merge surrogate pairs in different spans\n+        setContent(layout, \"\\uD840\\uDC0B\", font, \"\\uD840\\uDC89\\uD840\\uDCA2\", font);\n+        verifyLayout(1, 2, 2, 4);\n+        GlyphList[] runs = layout.getRuns();\n+        assertTrue(runs[0].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[0].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(2) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(3) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+\n+        \/\/ Split surrogate pair\n+        setContent(layout, \"\\uD840\\uDC0B\\uD840\", font, \"\\uDC89\\uD840\\uDCA2\", font);\n+        verifyLayout(1, 2, 3, 3);\n+        runs = layout.getRuns();\n+        assertTrue(runs[0].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[0].getGlyphCode(1) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[0].getGlyphCode(2) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);  \/\/ broken pair, results in missing glyph\n+        assertTrue(runs[1].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);  \/\/ broken pair, results in missing glyph\n+        assertTrue(runs[1].getGlyphCode(1) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+        assertTrue(runs[1].getGlyphCode(2) == CharToGlyphMapper.INVISIBLE_GLYPH_ID);\n+    }\n+\n+    @Test\n+    void shouldIgnoreAlignmentWhenWrappingIsDisabled() {\n+        layout.setContent(\"The quick brown fox jumps over the lazy dog\", font);\n+\n+        for (int i = 0; i < 3; i++) {\n+            layout.setAlignment(i);\n+\n+            assertLineCount(1);\n+            assertLineBounds(new RectBounds(0, -12, 309.6504f, 4.001953f));\n+        }\n+    }\n+\n+    enum Case {\n+\n+        \/**\n+         * Checks that alignment variations have no effect when not wrapping.\n+         *\/\n+        NO_WRAP(new Parameters(\n+            \"The quick brown fox jumps over the lazy dog\",\n+            Font.font(\"Monaco\", 12),\n+            0.0f, List.of(309.6504f), List.of(0.0f),\n+            12.0f, 4.001953f\n+        )),\n+\n+        \/**\n+         * Checks that the individual lines of hard wrapped text are still\n+         * taking alignment into account (in this specific case, the first\n+         * line, which is the widest line, will not be aligned, but the 2nd\n+         * line will be aligned as it is less wide).\n+         *\/\n+        HARD_WRAP(new Parameters(\n+            \"The quick brown fox jumps\\nover the lazy dog\",\n+            Font.font(\"Monaco\", 12),\n+            0.0f, List.of(180.0293f, 122.41992f), List.of(0.0f, 0.0f),\n+            12.0f, 4.001953f\n+        )),\n+\n+        \/**\n+         * Checks that trailing white space is NOT ignored when wrapping\n+         * is not enabled.\n+         *\/\n+        HARD_WRAP_WITH_EXTRA_TRAILING_SPACE(new Parameters(\n+            \"The quick brown fox jumps           \\nover the lazy dog           \",\n+            Font.font(\"Monaco\", 12),\n+            0.0f, List.of(180.0293f + 79.2129f, 122.41992f + 79.2129f), List.of(0.0f, 0.0f),\n+            12.0f, 4.001953f\n+        )),\n+\n+        \/**\n+         * Checks that single trailing white spaces are ignored for alignment\n+         * purposes when wrapping is enabled in simple text.\n+         *\/\n+        SIMPLE(new Parameters(\n+            \"The quick brown fox jumps over the lazy dog\",\n+            Font.font(\"Monaco\", 12),\n+            200.0f, List.of(180.0293f, 122.41992f), List.of(7.20117f, 0.0f),\n+            12.0f, 4.001953f\n+        )),\n+\n+        \/**\n+         * Checks that multiple trailing white spaces are ignored for alignment\n+         * purposes when wrapping is enabled in simple text.\n+         *\/\n+        SIMPLE_WITH_EXTRA_TRAILING_SPACE(new Parameters(\n+            \"The quick brown fox jumps           over the lazy dog\",\n+            Font.font(\"Monaco\", 12),\n+            200.0f, List.of(180.0293f, 122.41992f), List.of(79.2129f, 0.0f),\n+            12.0f, 4.001953f\n+        )),\n+\n+        \/**\n+         * Checks that single trailing white spaces are ignored for alignment\n+         * purposes when wrapping is enabled in complex text.\n+         *\/\n+        COMPLEX(new Parameters(\n+            \"The quick brown लोमड़ी jumps over the lazy कुत्ता\",\n+            Font.font(\"Monaco\", 12),\n+            200.0f, List.of(189.89649f, 122.583984f), List.of(7.20117f, 0.0f),\n+            12.0f, 4.001953f\n+        )),\n+\n+        \/**\n+         * Checks that multiple trailing white spaces are ignored for alignment\n+         * purposes when wrapping is enabled in complex text.\n+         *\/\n+        COMPLEX_WITH_EXTRA_TRAILING_SPACE(new Parameters(\n+            \"The quick brown लोमड़ी jumps           over the lazy कुत्ता\",\n+            Font.font(\"Monaco\", 12),\n+            200.0f, List.of(189.89649f, 122.583984f), List.of(79.2129f, 0.0f),\n+            12.0f, 4.001953f\n+        ));\n+\n+        Parameters parameters;\n+\n+        Case(Parameters parameters) {\n+            this.parameters = parameters;\n+        }\n+\n+        record Parameters(String text, Font font, float wrapWidth, List<Float> lineWidths, List<Float> trailingWhiteSpaceWidths, float ascent, float descent) {\n+            Parameters {\n+                assert text != null;\n+                assert font != null;\n+                assert wrapWidth >= 0;\n+                assert lineWidths != null;\n+                assert trailingWhiteSpaceWidths != null;\n+                assert ascent > 0;\n+                assert descent > 0;\n+                assert lineWidths.size() > 0;\n+                assert lineWidths.size() == trailingWhiteSpaceWidths.size();\n+            }\n+\n+            int lineCount() {\n+                return lineWidths.size();\n+            }\n+\n+            float maxWidth() {\n+                return lineWidths.stream().max(Float::compareTo).orElseThrow();\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(Case.class)\n+    void caseTest(Case c) {\n+        Case.Parameters p = c.parameters;\n+\n+        final float ASCENT = p.ascent;\n+        final float DESCENT = p.descent;\n+        final float WRAP = p.wrapWidth == 0 ? p.maxWidth() : p.wrapWidth;\n+        final float CENTER = 0.5f * WRAP;\n+\n+        \/\/ split content on line feeds (without removing the line feeds):\n+        layout.setContent(Arrays.stream(p.text.split(\"(?<=\\n)\")).map(text -> new TestSpan(text, FontHelper.getNativeFont(p.font))).toArray(TextSpan[]::new));\n+        layout.setWrapWidth(p.wrapWidth);\n+\n+        \/\/ LEFT ALIGNMENT\n+\n+        layout.setAlignment(0);  \/\/ 0 == left\n+\n+        assertLineCount(p.lineCount());\n+\n+        for (int i = 0; i < p.lineCount(); i++) {\n+            TextLine[] lines = layout.getLines();\n+            String description = \"left aligned: line \" + i + \" for \" + c.parameters;\n+            RectBounds expectedBounds = new RectBounds(0, -ASCENT, p.lineWidths.get(i) + p.trailingWhiteSpaceWidths.get(i), DESCENT);\n+            Point2D expectedLocation = new Point2D(0, i * (ASCENT + DESCENT));\n+\n+            assertEquals(expectedBounds, lines[i].getBounds(), description);\n+            assertEquals(expectedLocation, lines[i].getRuns()[0].getLocation(), description);\n+        }\n+\n+        \/\/ CENTER ALIGNMENT\n+\n+        layout.setAlignment(1);  \/\/ 1 == center\n+\n+        assertLineCount(p.lineCount());\n+\n+        for (int i = 0; i < p.lineCount(); i++) {\n+            TextLine[] lines = layout.getLines();\n+            String description = \"centered: line \" + i + \" for \" + p;\n+            RectBounds expectedBounds = new RectBounds(CENTER - 0.5f * p.lineWidths.get(i), -ASCENT, CENTER + 0.5f * p.lineWidths.get(i) + p.trailingWhiteSpaceWidths.get(i), DESCENT);\n+            Point2D expectedLocation = new Point2D(CENTER - 0.5f * p.lineWidths.get(i), i * (ASCENT + DESCENT));\n+\n+            assertEquals(expectedBounds, lines[i].getBounds(), description);\n+            assertEquals(expectedLocation, lines[i].getRuns()[0].getLocation(), description);\n+        }\n+\n+        \/\/ RIGHT ALIGNMENT\n+\n+        layout.setAlignment(2);  \/\/ 2 == right\n+\n+        assertLineCount(p.lineCount());\n+\n+        for (int i = 0; i < p.lineCount(); i++) {\n+            TextLine[] lines = layout.getLines();\n+            String description = \"right aligned: line \" + i + \" for \" + p;\n+            RectBounds expectedBounds = new RectBounds(WRAP - p.lineWidths.get(i), -ASCENT, WRAP + p.trailingWhiteSpaceWidths.get(i), DESCENT);\n+            Point2D expectedLocation = new Point2D(WRAP - p.lineWidths.get(i), i * (ASCENT + DESCENT));\n+\n+            assertEquals(expectedBounds, lines[i].getBounds(), description);\n+            assertEquals(expectedLocation, lines[i].getRuns()[0].getLocation(), description);\n+        }\n+\n+        \/\/ JUSTIFIED ALIGNMENT\n+\n+        layout.setAlignment(3);  \/\/ 3 == justified\n+\n+        assertLineCount(p.lineCount());\n+\n+        for (int i = 0; i < p.lineCount(); i++) {\n+            TextLine[] lines = layout.getLines();\n+            String description = \"justified: line \" + i + \" for \" + p;\n+            boolean lastLine = i == p.lineCount() - 1;\n+            RectBounds expectedBounds = new RectBounds(0, -ASCENT, lastLine ? p.lineWidths.get(i) : WRAP, DESCENT);\n+            Point2D expectedLocation = new Point2D(0, i * (ASCENT + DESCENT));\n+\n+            assertEquals(expectedBounds, lines[i].getBounds(), description);\n+            assertEquals(expectedLocation, lines[i].getRuns()[0].getLocation(), description);\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/com\/sun\/javafx\/text\/TextLayoutTest.java","additions":506,"deletions":0,"binary":false,"changes":506,"status":"added"}]}