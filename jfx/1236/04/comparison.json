{"files":[{"patch":"@@ -457,1 +457,1 @@\n-                    for (TextRun r: lines[i].runs) {\n+                    for (TextRun r: lines[i].getRuns()) {\n@@ -762,1 +762,1 @@\n-                for (TextRun r : lines[index].runs) {\n+                for (TextRun r : lines[index].getRuns()) {\n@@ -1012,0 +1012,7 @@\n+\n+        \/*\n+         * Calculate the width of trailing spaces for the new TextLine so they're\n+         * can be excluded when doing later alignment calculations:\n+         *\/\n+        float trailingSpaceWidth = computeTrailingSpaceWidth(startOffset, length, lineRuns);\n+\n@@ -1014,1 +1021,32 @@\n-                            width, ascent, descent, leading);\n+                            width, ascent, descent, leading, trailingSpaceWidth);\n+    }\n+\n+    \/**\n+     * Computes the size of the white space trailing a given line defined by the start offset and length.\n+     *\n+     * <p>Note: textRuns is split in such a way that it matches the line, so the last text run's last\n+     * character is the point of a line break.\n+     *\n+     * @param startOffset the character offset of the start of a line in the text\n+     * @param length the length of the line\n+     * @param textRuns the text runs the line consists off\n+     * @return the X size of the white space trailing the line\n+     *\/\n+    private float computeTrailingSpaceWidth(int startOffset, int length, TextRun[] textRuns) {\n+        int run = textRuns.length;\n+        TextRun textRun = textRuns[--run];\n+        int textOffset = startOffset + length;\n+        int runOffset = textRun.getLength();\n+        float trailingSpaceWidth = 0;\n+        char[] chars = getText();\n+\n+        while (--textOffset >= startOffset && Character.isWhitespace(chars[textOffset])) {\n+            while (runOffset < 0) {  \/\/ just in case the trailing white spaces are split over multiple runs (unsure if this can ever happen)\n+                textRun = textRuns[--run];\n+                runOffset = textRun.getLength();\n+            }\n+\n+            trailingSpaceWidth += textRun.getAdvance(--runOffset);\n+        }\n+\n+        return trailingSpaceWidth;\n@@ -1195,1 +1233,3 @@\n-                while (offset + 1 < runEnd && chars[offset] == ' ') {\n+\n+                \/\/ Don't take spaces into account at the preferred wrap index:\n+                while (offset + 1 < runEnd && Character.isWhitespace(chars[offset])) {\n@@ -1197,4 +1237,0 @@\n-                    \/* Preserve behaviour: only keep one white space in the line\n-                     * before wrapping. Needed API to allow change.\n-                     *\/\n-                    break;\n@@ -1327,1 +1363,2 @@\n-            float lineX = (fullWidth - bounds.getWidth()) * align;\n+            float unusedWidth = wrapWidth - bounds.getWidth() + line.getTrailingSpaceWidth();\n+            float lineX = unusedWidth * align;\n@@ -1345,1 +1382,1 @@\n-                        float inc = (fullWidth - bounds.getWidth()) \/ wsCount;\n+                        float inc = unusedWidth \/ wsCount;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/PrismTextLayout.java","additions":47,"deletions":10,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -31,5 +31,8 @@\n-    TextRun[] runs;\n-    RectBounds bounds;\n-    float lsb, rsb, leading;\n-    int start;\n-    int length;\n+    private final TextRun[] runs;\n+    private final RectBounds bounds;\n+    private final int start;\n+    private final int length;\n+    private final float leading;\n+    private final float trailingSpaceWidth;\n+\n+    private float lsb, rsb;\n@@ -38,1 +41,1 @@\n-                    float width, float ascent, float descent, float leading) {\n+                    float width, float ascent, float descent, float leading, float trailingSpaceWidth) {\n@@ -44,0 +47,1 @@\n+        this.trailingSpaceWidth = trailingSpaceWidth;\n@@ -70,0 +74,4 @@\n+    public float getTrailingSpaceWidth() {\n+        return trailingSpaceWidth;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/TextLine.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -346,0 +346,13 @@\n+\n+        \/*\n+         * When positions is null it means that the TextRun only contains\n+         * a line break, assuming that the class is used correctly (\"shape\"\n+         * must be called before calling this method, unless the class user is\n+         * sure that the run is empty). This class could benefit from better\n+         * encapsulation to make it easier to reason about.\n+         *\/\n+\n+        if (positions == null) {\n+            return 0;\n+        }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/TextRun.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,5 @@\n-import javafx.scene.text.Font;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n@@ -30,0 +34,1 @@\n+import com.sun.javafx.font.CharToGlyphMapper;\n@@ -31,0 +36,1 @@\n+import com.sun.javafx.geom.Point2D;\n@@ -32,0 +38,1 @@\n+import com.sun.javafx.scene.text.FontHelper;\n@@ -33,1 +40,0 @@\n-import com.sun.javafx.scene.text.TextSpan;\n@@ -35,2 +41,1 @@\n-import com.sun.javafx.scene.text.FontHelper;\n-import com.sun.javafx.font.CharToGlyphMapper;\n+import com.sun.javafx.scene.text.TextSpan;\n@@ -39,4 +44,1 @@\n-import org.junit.Ignore;\n-import org.junit.Test;\n-\n-import static org.junit.Assert.*;\n+import javafx.scene.text.Font;\n@@ -45,3 +47,7 @@\n-    private String J = \"\\u3041\";  \/\/Japanese not complex\n-    private String D = \"\\u0907\"; \/\/Devanagari complex\n-    private String T = \"\\u0E34\"; \/\/Devanagari complex\n+    private static final String J = \"\\u3041\";  \/\/ Japanese not complex\n+    private static final String D = \"\\u0907\";  \/\/ Devanagari complex\n+    private static final String T = \"\\u0E34\";  \/\/ Thai complex\n+\n+    private final PrismTextLayout layout = new PrismTextLayout();\n+    private final PGFont font = (PGFont) FontHelper.getNativeFont(Font.font(\"Monaco\", 12));\n+    private final PGFont font2 = (PGFont) FontHelper.getNativeFont(Font.font(\"Tahoma\", 12));\n@@ -67,3 +73,0 @@\n-    public TextLayoutTest() {\n-    }\n-\n@@ -80,1 +83,7 @@\n-    private void verifyLayout(PrismTextLayout layout, int lineCount, int runCount, int... glyphCount) {\n+    private void assertLineCount(int lineCount) {\n+        assertEquals(lineCount, layout.getLines().length, \"lineCount\");\n+    }\n+\n+    private void assertLineBounds(RectBounds... rectBounds) {\n+        assertLineCount(rectBounds.length);\n+\n@@ -82,1 +91,17 @@\n-        assertEquals(\"lineCount\", lineCount, lines.length);\n+\n+        for (int i = 0; i < lines.length; i++) {\n+            assertEquals(rectBounds[i], lines[i].getBounds(), \"line \" + i);\n+        }\n+    }\n+\n+    private void assertLineLocations(Point2D... locations) {\n+        assertLineCount(locations.length);\n+\n+        TextLine[] lines = layout.getLines();\n+\n+        for (int i = 0; i < lines.length; i++) {\n+            assertEquals(locations[i], lines[i].getRuns()[0].getLocation(), \"line \" + i);\n+        }\n+    }\n+\n+    private void assertGlyphsPerRun(int... glyphCount) {\n@@ -84,2 +109,3 @@\n-        assertEquals(\"runCount\", runCount, runs.length);\n-        assertEquals(\"runCount\", runCount, glyphCount.length);\n+\n+        assertEquals(glyphCount.length, runs.length, \"number of glyph counts given does not match number of runs\");\n+\n@@ -87,1 +113,1 @@\n-            assertEquals(\"run \" +i, glyphCount[i], runs[i].getGlyphCount());\n+            assertEquals(glyphCount[i], runs[i].getGlyphCount(), \"run \" + i);\n@@ -91,1 +117,3 @@\n-    private void verifyComplex(PrismTextLayout layout, boolean... complex) {\n+    private void verifyLayout(int lineCount, int runCount, int... glyphCount) {\n+        TextLine[] lines = layout.getLines();\n+        assertEquals(lineCount, lines.length, \"lineCount\");\n@@ -93,0 +121,2 @@\n+        assertEquals(runCount, runs.length, \"runCount\");\n+        assertEquals(runCount, glyphCount.length, \"runCount\");\n@@ -94,1 +124,1 @@\n-            assertEquals(\"run \" +i, complex[i], runs[i].isComplex());\n+            assertEquals(glyphCount[i], runs[i].getGlyphCount(), \"run \" + i);\n@@ -98,2 +128,6 @@\n-    @Ignore(\"JDK-8087615\")\n-    @Test public void buildRuns() {\n+    private void verifyComplex(boolean... complex) {\n+        GlyphList[] runs = layout.getRuns();\n+        for (int i = 0; i < runs.length; i++) {\n+            assertEquals(complex[i], runs[i].isComplex(), \"run \" + i);\n+        }\n+    }\n@@ -101,3 +135,18 @@\n-        PrismTextLayout layout = new PrismTextLayout();\n-        PGFont font = (PGFont) FontHelper.getNativeFont(Font.font(\"Monaco\", 12));\n-        PGFont font2 = (PGFont) FontHelper.getNativeFont(Font.font(\"Tahoma\", 12));\n+    \/**\n+     * These tests were broken for a long time (as early as 2013-06-28, see JDK-8087615).\n+     *\n+     * The reason they break is two fold:\n+     *\n+     * - Content that is split into multiple runs will have all runs set to \"complex\"\n+     *   if at least one run is set to \"complex\", while this test was expecting the\n+     *   runs containing non-complex characters to not become \"complex\".\n+     *\n+     * - The Tahoma font when used with a Thai character generates 2 glyphs per Thai\n+     *   character, while this test was expecting 1 glyph.\n+     *\/\n+    @Disabled\n+    @Test\n+    void complexTestsThatAreBrokenSince2013() {\n+        layout.setContent(\"aa\" + J + J, font);\n+        verifyLayout(1, 1, 4);  \/\/ no complex (english to japanese)\n+        verifyComplex(false);\n@@ -105,3 +154,3 @@\n-        \/* simple case *\/\n-        layout.setContent(\"hello\", font);\n-        verifyLayout(layout, 1, 1, 5);\n+        layout.setContent(D, font);\n+        verifyLayout(1, 1, 1);  \/\/ complex (english to devanagari)\n+        verifyComplex(true);\n@@ -109,3 +158,3 @@\n-        \/* simple case, two workd*\/\n-        layout.setContent(\"hello world\", font);\n-        verifyLayout(layout, 1, 1, 11);\n+        layout.setContent(\"aa\" + D + D, font);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (english to devanagari)\n+        verifyComplex(false, true);\n@@ -113,3 +162,3 @@\n-        \/* empty string *\/\n-        layout.setContent(\"\", font);\n-        verifyLayout(layout, 1, 1, 0);\n+        layout.setContent(D + D + \"aa\", font);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (devanagari to english)\n+        verifyComplex(true, false);\n@@ -117,11 +166,3 @@\n-        \/* line break *\/\n-        layout.setContent(\"\\n\", font); \/\/first line has the line break (glyphCount=0),\n-        verifyLayout(layout, 2, 2, 0,0);\n-        layout.setContent(\"\\r\", font);\n-        verifyLayout(layout, 2, 2, 0,0);\n-        layout.setContent(\"\\r\\n\", font);\n-        verifyLayout(layout, 2, 2, 0,0);\n-        layout.setContent(\"a\\nb\", font);\n-        verifyLayout(layout, 2, 3, 1, 0, 1);\n-        layout.setContent(\"\\n\\n\\r\\r\\n\", font);\n-        verifyLayout(layout, 5, 5, 0,0,0,0,0);\n+        layout.setContent(\"aa\" + D + D + J + J, font);\n+        verifyLayout(1, 3, 2, 2, 2);  \/\/ complex (english to devanagari to japanese)\n+        verifyComplex(false, true, false);\n@@ -129,7 +170,8 @@\n-        \/* tabs *\/\n-        layout.setContent(\"\\t\", font);\n-        verifyLayout(layout, 1, 1, 0);\n-        layout.setContent(\"\\t\\t\", font);\n-        verifyLayout(layout, 1, 2, 0,0);\n-        layout.setContent(\"a\\tb\", font);\n-        verifyLayout(layout, 1, 3, 1,0,1);\n+        \/\/ Tahoma has Thai but no Hindi, font slot break expected\n+        layout.setContent(D + D + T + T, font2);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (devanagari to thai)\n+        verifyComplex(true, true);\n+\n+        layout.setContent(T + T + D + D + T + T, font2);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(true, true, true);\n@@ -137,4 +179,3 @@\n-        \/* complex *\/\n-        layout.setContent(\"aa\"+J+J, font);\n-        verifyLayout(layout, 1, 1, 4);\/\/ no complex (english to japanese)\n-        verifyComplex(layout, false);\n+        layout.setContent(T + T + D + D + \"aa\", font2);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(true, true, false);\n@@ -142,0 +183,18 @@\n+        layout.setContent(T + T + \"aa\" + T + T, font2);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(true, false, true);\n+\n+        layout.setContent(\"aa\" + D + D + T + T, font2);\n+        verifyLayout(1, 3, 2, 2, 2);\n+        verifyComplex(false, true, true);\n+    }\n+\n+    \/**\n+     * These are fixed versions of the above tests to avoid\n+     * further regressions.\n+     *\/\n+    @Test\n+    void fixedComplexTestsToEnsureNoFurtherRegressions() {\n+        layout.setContent(\"aa\" + J + J, font);\n+        verifyLayout(1, 1, 4);  \/\/ no complex (english to japanese)\n+        verifyComplex(false);\n@@ -144,2 +203,6 @@\n-        verifyLayout(layout, 1, 1, 1);\/\/ complex (english to devanagari)\n-        verifyComplex(layout, true);\n+        verifyLayout(1, 1, 1);  \/\/ complex (english to devanagari)\n+        verifyComplex(true);\n+\n+        layout.setContent(\"aa\" + D + D, font);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (english to devanagari)\n+        verifyComplex(true, true);\n@@ -147,3 +210,3 @@\n-        layout.setContent(\"aa\"+D+D, font);\n-        verifyLayout(layout, 1, 2, 2,2);\/\/ complex (english to devanagari)\n-        verifyComplex(layout, false, true);\n+        layout.setContent(D + D + \"aa\", font);\n+        verifyLayout(1, 2, 2, 2);  \/\/ complex (devanagari to english)\n+        verifyComplex(true, true);\n@@ -151,3 +214,3 @@\n-        layout.setContent(D+D+\"aa\", font);\n-        verifyLayout(layout, 1, 2, 2,2);\/\/ complex (devanagari to english)\n-        verifyComplex(layout, true, false);\n+        layout.setContent(\"aa\" + D + D + J + J, font);\n+        verifyLayout(1, 3, 2, 2, 2);  \/\/ complex (english to devanagari to japanese)\n+        verifyComplex(true, true, true);\n@@ -155,3 +218,4 @@\n-        layout.setContent(\"aa\"+D+D+J+J, font);\n-        verifyLayout(layout, 1, 3, 2,2,2);\/\/ complex (english to devanagari to japanese)\n-        verifyComplex(layout, false, true, false);\n+        \/\/ Tahoma has Thai but no Hindi, font slot break expected\n+        layout.setContent(D + D + T + T, font2);\n+        verifyLayout(1, 2, 2, 4);  \/\/ complex (devanagari to thai)\n+        verifyComplex(true, true);\n@@ -159,4 +223,3 @@\n-        \/*Tahoma has Thai but no Hindi, font slot break expected*\/\n-        layout.setContent(D+D+T+T, font2);\n-        verifyLayout(layout, 1, 2, 2,2);\/\/ complex (devanagari to thai)\n-        verifyComplex(layout, true, true);\n+        layout.setContent(T + T + D + D + T + T, font2);\n+        verifyLayout(1, 3, 4, 2, 4);\n+        verifyComplex(true, true, true);\n@@ -164,3 +227,3 @@\n-        layout.setContent(T+T+D+D+T+T, font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, true, true, true);\n+        layout.setContent(T + T + D + D + \"aa\", font2);\n+        verifyLayout(1, 3, 4, 2, 2);\n+        verifyComplex(true, true, true);\n@@ -168,3 +231,3 @@\n-        layout.setContent(T+T+D+D+\"aa\", font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, true, true, false);\n+        layout.setContent(T + T + \"aa\" + T + T, font2);\n+        verifyLayout(1, 3, 4, 2, 4);\n+        verifyComplex(true, true, true);\n@@ -172,3 +235,18 @@\n-        layout.setContent(T+T+\"aa\"+T+T, font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, true, false, true);\n+        layout.setContent(\"aa\" + D + D + T + T, font2);\n+        verifyLayout(1, 3, 2, 2, 4);\n+        verifyComplex(true, true, true);\n+    }\n+\n+    @Test\n+    void basicTest() {\n+        \/\/ simple case\n+        layout.setContent(\"hello\", font);\n+        verifyLayout(1, 1, 5);\n+\n+        \/\/ simple case, two words\n+        layout.setContent(\"hello world\", font);\n+        verifyLayout(1, 1, 11);\n+\n+        \/\/ empty string\n+        layout.setContent(\"\", font);\n+        verifyLayout(1, 1, 0);\n@@ -176,3 +254,11 @@\n-        layout.setContent(\"aa\"+D+D+T+T, font2);\n-        verifyLayout(layout, 1, 3, 2,2,2);\n-        verifyComplex(layout, false, true, true);\n+        \/\/ line break\n+        layout.setContent(\"\\n\", font);  \/\/ first line has the line break (glyphCount=0)\n+        verifyLayout(2, 2, 0, 0);\n+        layout.setContent(\"\\r\", font);\n+        verifyLayout(2, 2, 0, 0);\n+        layout.setContent(\"\\r\\n\", font);\n+        verifyLayout(2, 2, 0, 0);\n+        layout.setContent(\"a\\nb\", font);\n+        verifyLayout(2, 3, 1, 0, 1);\n+        layout.setContent(\"\\n\\n\\r\\r\\n\", font);\n+        verifyLayout(5, 5, 0, 0, 0, 0, 0);\n@@ -180,1 +266,8 @@\n-        \/* Rich Text test *\/\n+        \/\/ tabs\n+        layout.setContent(\"\\t\", font);\n+        verifyLayout(1, 1, 0);\n+        layout.setContent(\"\\t\\t\", font);\n+        verifyLayout(1, 2, 0, 0);\n+        layout.setContent(\"a\\tb\", font);\n+        verifyLayout(1, 3, 1, 0, 1);\n+    }\n@@ -182,0 +275,2 @@\n+    @Test\n+    void richTextTest() {\n@@ -183,2 +278,2 @@\n-        verifyLayout(layout, 1, 2, 6,5);\n-        verifyComplex(layout, false, false);\n+        verifyLayout(1, 2, 6, 5);\n+        verifyComplex(false, false);\n@@ -186,3 +281,3 @@\n-        setContent(layout, \"aaa\", font, J+J+J, font);\n-        verifyLayout(layout, 1, 2, 3,3);\n-        verifyComplex(layout, false, false);\n+        setContent(layout, \"aaa\", font, J + J + J, font);\n+        verifyLayout(1, 2, 3, 3);\n+        verifyComplex(false, false);\n@@ -190,3 +285,3 @@\n-        setContent(layout, \"aaa\", font, D+D+D, font);\n-        verifyLayout(layout, 1, 2, 3,3);\n-        verifyComplex(layout, false, true);\n+        setContent(layout, \"aaa\", font, D + D + D, font);\n+        verifyLayout(1, 2, 3, 3);\n+        verifyComplex(false, true);\n@@ -194,1 +289,1 @@\n-        \/* can't merge \\r\\n in different spans*\/\n+        \/\/ can't merge \\r\\n in different spans\n@@ -196,2 +291,2 @@\n-        verifyLayout(layout, 3, 4, 2,0,0,2);\n-        verifyComplex(layout, false, false, false, false);\n+        verifyLayout(3, 4, 2, 0, 0, 2);\n+        verifyComplex(false, false, false, false);\n@@ -200,2 +295,2 @@\n-        verifyLayout(layout, 2, 3, 2,0,2);\n-        verifyComplex(layout, false, false, false);\n+        verifyLayout(2, 3, 2, 0, 2);\n+        verifyComplex(false, false, false);\n@@ -203,1 +298,1 @@\n-        \/* can't merge surrogate pairs in different spans*\/\n+        \/\/ can't merge surrogate pairs in different spans\n@@ -205,1 +300,1 @@\n-        verifyLayout(layout, 1, 2, 2, 4);\n+        verifyLayout(1, 2, 2, 4);\n@@ -214,1 +309,1 @@\n-        \/* Split surrogate pair*\/\n+        \/\/ Split surrogate pair\n@@ -216,1 +311,1 @@\n-        verifyLayout(layout, 1, 2, 3, 3);\n+        verifyLayout(1, 2, 3, 3);\n@@ -220,2 +315,2 @@\n-        assertTrue(runs[0].getGlyphCode(2) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\/\/broken pair, results in missing glyph\n-        assertTrue(runs[1].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);\/\/broken pair, results in missing glyph\n+        assertTrue(runs[0].getGlyphCode(2) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);  \/\/ broken pair, results in missing glyph\n+        assertTrue(runs[1].getGlyphCode(0) != CharToGlyphMapper.INVISIBLE_GLYPH_ID);  \/\/ broken pair, results in missing glyph\n@@ -224,0 +319,1 @@\n+    }\n@@ -225,0 +321,107 @@\n+    @Test\n+    void shouldWrap() {\n+        layout.setWrapWidth(200);\n+\n+        setContent(layout, \"The quick brown fox jumps over the lazy dog\", font);\n+\n+        layout.setAlignment(0);  \/\/ 0 == left\n+\n+        assertGlyphsPerRun(26, 17);\n+        assertLineBounds(\n+            new RectBounds(0, -12, 187.23047f, 4.001953f),\n+            new RectBounds(0, -12, 122.41992f, 4.001953f)\n+        );\n+        assertLineLocations(\n+            new Point2D(0, 0),\n+            new Point2D(0, 16.001953f)\n+        );\n+\n+        layout.setAlignment(1);  \/\/ 1 == center\n+\n+        assertGlyphsPerRun(26, 17);\n+        assertLineBounds(\n+            new RectBounds(9.985352f, -12, 197.21582f, 4.001953f),\n+            new RectBounds(38.79004f, -12, 161.20996f, 4.001953f)\n+        );\n+        assertLineLocations(\n+            new Point2D(9.985352f, 0),\n+            new Point2D(38.79004f, 16.001953f)\n+        );\n+\n+        layout.setAlignment(2);  \/\/ 2 == right\n+\n+        assertGlyphsPerRun(26, 17);\n+        assertLineBounds(\n+            new RectBounds(19.970703f, -12, 207.20117f, 4.001953f),\n+            new RectBounds(77.58008f, -12, 200.0f, 4.001953f)\n+        );\n+        assertLineLocations(\n+            new Point2D(19.970703f, 0),\n+            new Point2D(77.58008f, 16.001953f)\n+        );\n+\n+        layout.setAlignment(3);  \/\/ 3 == justify\n+\n+        assertGlyphsPerRun(26, 17);\n+        assertLineBounds(\n+            new RectBounds(0, -12, 200.0f, 4.001953f),\n+            new RectBounds(0, -12, 122.41992f, 4.001953f)\n+        );\n+        assertLineLocations(\n+            new Point2D(0, 0),\n+            new Point2D(0, 16.001953f)\n+        );\n+\n+        \/\/ Same tests with 10 additional spaces on the break point;\n+        \/\/ note how starting location of each line doesn't change for the same\n+        \/\/ alignment (but the bound width does) despite the different content:\n+\n+        setContent(layout, \"The quick brown fox jumps           over the lazy dog\", font);\n+\n+        layout.setAlignment(0);  \/\/ 0 == left\n+\n+        assertGlyphsPerRun(36, 17);\n+        assertLineBounds(\n+            new RectBounds(0, -12, 259.2422f, 4.001953f),\n+            new RectBounds(0, -12, 122.41992f, 4.001953f)\n+        );\n+        assertLineLocations(\n+            new Point2D(0, 0),\n+            new Point2D(0, 16.001953f)\n+        );\n+\n+        layout.setAlignment(1);  \/\/ 1 == center\n+\n+        assertGlyphsPerRun(36, 17);\n+        assertLineBounds(\n+            new RectBounds(9.985352f, -12, 269.22754f, 4.001953f),\n+            new RectBounds(38.79004f, -12, 161.20996f, 4.001953f)\n+        );\n+        assertLineLocations(\n+            new Point2D(9.985352f, 0),\n+            new Point2D(38.79004f, 16.001953f)\n+        );\n+\n+        layout.setAlignment(2);  \/\/ 2 == right\n+\n+        assertGlyphsPerRun(36, 17);\n+        assertLineBounds(\n+            new RectBounds(19.970703f, -12, 279.2129f, 4.001953f),\n+            new RectBounds(77.58008f, -12, 200.0f, 4.001953f)\n+        );\n+        assertLineLocations(\n+            new Point2D(19.970703f, 0),\n+            new Point2D(77.58008f, 16.001953f)\n+        );\n+\n+        layout.setAlignment(3);  \/\/ 3 == justify\n+\n+        assertGlyphsPerRun(36, 17);\n+        assertLineBounds(\n+            new RectBounds(0, -12, 259.2422f, 4.001953f),\n+            new RectBounds(0, -12, 122.41992f, 4.001953f)\n+        );\n+        assertLineLocations(\n+            new Point2D(0, 0),\n+            new Point2D(0, 16.001953f)\n+        );\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/text\/TextLayoutTest.java","additions":308,"deletions":105,"binary":false,"changes":413,"status":"modified"}]}