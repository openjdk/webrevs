{"files":[{"patch":"@@ -156,0 +156,1 @@\n+        \"-framework\", \"Carbon\",\n","filename":"buildSrc\/mac.gradle","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#import <Carbon\/Carbon.h>\n+\n@@ -181,0 +183,160 @@\n+static BOOL macKeyCodeIsLayoutSensitive(unsigned int keyCode)\n+{\n+    \/\/ Mac key codes that generate different characters based on the keyboard layout\n+    \/\/ lie in two ranges with a few exceptions.\n+    switch (keyCode)\n+    {\n+        case 0x24: \/\/ Enter\n+        case 0x30: \/\/ Tab\n+        case 0x31: \/\/ Space\n+            return NO;\n+    }\n+\n+    if (keyCode >= 0x00 && keyCode <= 0x32)\n+        return YES;\n+\n+    if (keyCode >= 0x5D && keyCode <= 0x5F)\n+        return YES;\n+\n+    return NO;\n+}\n+\n+static jint getJavaCodeForASCII(UniChar ascii)\n+{\n+    if (ascii >= L'0' && ascii <= L'9')\n+        return ascii;\n+    if (ascii >= L'a' && ascii <= L'z')\n+        return ascii + (L'A' - L'a');\n+    if (ascii >= L'A' && ascii <= L'Z')\n+        return ascii;\n+\n+    switch (ascii)\n+    {\n+        case L' ': return com_sun_glass_events_KeyEvent_VK_SPACE;\n+        case L'!': return com_sun_glass_events_KeyEvent_VK_EXCLAMATION;\n+        case L'\"': return com_sun_glass_events_KeyEvent_VK_DOUBLE_QUOTE;\n+        case L'#': return com_sun_glass_events_KeyEvent_VK_NUMBER_SIGN;\n+        case L'$': return com_sun_glass_events_KeyEvent_VK_DOLLAR;\n+        case L'&': return com_sun_glass_events_KeyEvent_VK_AMPERSAND;\n+        case L'\\'':return com_sun_glass_events_KeyEvent_VK_QUOTE;\n+        case L'(': return com_sun_glass_events_KeyEvent_VK_LEFT_PARENTHESIS;\n+        case L')': return com_sun_glass_events_KeyEvent_VK_RIGHT_PARENTHESIS;\n+        case L'*': return com_sun_glass_events_KeyEvent_VK_ASTERISK;\n+        case L'+': return com_sun_glass_events_KeyEvent_VK_PLUS;\n+        case L',': return com_sun_glass_events_KeyEvent_VK_COMMA;\n+        case L'-': return com_sun_glass_events_KeyEvent_VK_MINUS;\n+        case L'.': return com_sun_glass_events_KeyEvent_VK_PERIOD;\n+        case L'\/': return com_sun_glass_events_KeyEvent_VK_SLASH;\n+        case L':': return com_sun_glass_events_KeyEvent_VK_COLON;\n+        case L';': return com_sun_glass_events_KeyEvent_VK_SEMICOLON;\n+        case L'<': return com_sun_glass_events_KeyEvent_VK_LESS;\n+        case L'=': return com_sun_glass_events_KeyEvent_VK_EQUALS;\n+        case L'>': return com_sun_glass_events_KeyEvent_VK_GREATER;\n+        case L'@': return com_sun_glass_events_KeyEvent_VK_AT;\n+        case L'[': return com_sun_glass_events_KeyEvent_VK_OPEN_BRACKET;\n+        case L'\\\\':return com_sun_glass_events_KeyEvent_VK_BACK_SLASH;\n+        case L']': return com_sun_glass_events_KeyEvent_VK_CLOSE_BRACKET;\n+        case L'^': return com_sun_glass_events_KeyEvent_VK_CIRCUMFLEX;\n+        case L'_': return com_sun_glass_events_KeyEvent_VK_UNDERSCORE;\n+        case L'`': return com_sun_glass_events_KeyEvent_VK_BACK_QUOTE;\n+        case L'{': return com_sun_glass_events_KeyEvent_VK_BRACELEFT;\n+        case L'}': return com_sun_glass_events_KeyEvent_VK_BRACERIGHT;\n+    }\n+\n+    return com_sun_glass_events_KeyEvent_VK_UNDEFINED;\n+};\n+\n+static UniCharCount queryKeyboard(TISInputSourceRef keyboard, unsigned short keyCode, UInt32 modifiers,\n+                                  UniChar* buffer, UniCharCount bufferSize)\n+{\n+    CFDataRef uchr = (CFDataRef)TISGetInputSourceProperty(keyboard,\n+                                                          kTISPropertyUnicodeKeyLayoutData);\n+    if (uchr == NULL)\n+        return 0;\n+    const UCKeyboardLayout *layout = (const UCKeyboardLayout*)CFDataGetBytePtr(uchr);\n+\n+    UInt32 deadKeyState = 0;\n+    UniCharCount actualLength = 0;\n+    OSStatus status = UCKeyTranslate(layout,\n+                                     keyCode, kUCKeyActionDown,\n+                                     modifiers >> 8,\n+                                     LMGetKbdType(),\n+                                     kUCKeyTranslateNoDeadKeysMask, &deadKeyState,\n+                                     bufferSize, &actualLength,\n+                                     buffer);\n+    if (status != noErr)\n+        actualLength = 0;\n+\n+    \/\/ The Unicode Hex layout can yield a string of length 1 consisting of a\n+    \/\/ code point of 0.\n+    if (actualLength == 1 && buffer[0] == 0)\n+        actualLength = 0;\n+\n+    return actualLength;\n+}\n+\n+static BOOL isLetterOrDigit(jint javaKeyCode)\n+{\n+    if (javaKeyCode >= '0' && javaKeyCode <= '9')\n+        return YES;\n+    if (javaKeyCode >= 'A' && javaKeyCode <= 'Z')\n+        return YES;\n+    return NO;\n+}\n+\n+\/\/ This is only valid for keys in the layout-sensitive area.\n+static jint getJavaCodeForMacKeyAndModifiers(TISInputSourceRef keyboard, unsigned short keyCode, UInt32 modifiers)\n+{\n+    jint result = com_sun_glass_events_KeyEvent_VK_UNDEFINED;\n+    UniChar unicode[8];\n+    UniCharCount length = queryKeyboard(keyboard, keyCode, modifiers, unicode, 8);\n+    if (length == 1)\n+        result = getJavaCodeForASCII(unicode[0]);\n+    return result;\n+}\n+\n+\/\/ This is only valid for keys in the layout-sensitive area.\n+static jint getJavaCodeForMacKey(unsigned short keyCode)\n+{\n+    jint result = com_sun_glass_events_KeyEvent_VK_UNDEFINED;\n+    TISInputSourceRef keyboard = TISCopyCurrentKeyboardLayoutInputSource();\n+    if (keyboard == NULL)\n+        return result;\n+\n+    \/\/ Java key codes are used in accelerator processing so we will try to match them\n+    \/\/ the same way Apple handles key equivalents e.g. by asking for the Cmd character.\n+    \/\/ This is necessary on non-ASCII layouts such as Cyrillic or Arabic to ensure the\n+    \/\/ translation produces an ASCII key. Exactly how this is done is specific to the\n+    \/\/ keyboard but for non-ASCII keyboards it generally generates some variant of\n+    \/\/ QWERTY.\n+\n+    \/\/ First just Cmd.\n+    result = getJavaCodeForMacKeyAndModifiers(keyboard, keyCode, cmdKey);\n+\n+    \/\/ If we didn't get a hit try looking at the Shifted variant. Even if we did get a\n+    \/\/ hit we favor numerals and letters over punctuation. This brings the French\n+    \/\/ keyboard in line with Windows; the digits are shifted but are still considered\n+    \/\/ the canonical key codes.\n+    if (!isLetterOrDigit(result))\n+    {\n+        jint trial = getJavaCodeForMacKeyAndModifiers(keyboard, keyCode, cmdKey | shiftKey);\n+        if (isLetterOrDigit(trial))\n+            result = trial;\n+        else if (result == com_sun_glass_events_KeyEvent_VK_UNDEFINED)\n+            result = trial;\n+\n+        \/\/ A handful of keyboards (Azeri, Turkmen, and Sami variants) can only access\n+        \/\/ critical letters like Q by using the Option key in conjunction with Cmd.\n+        \/\/ In this API the Cmd flag suppresses the Option flag so we ommit Cmd.\n+        if (!isLetterOrDigit(result))\n+        {\n+            jint trial = getJavaCodeForMacKeyAndModifiers(keyboard, keyCode, optionKey);\n+            if (isLetterOrDigit(trial))\n+                result = trial;\n+        }\n+    }\n+\n+    CFRelease(keyboard);\n+    return result;\n+}\n+\n@@ -237,0 +399,5 @@\n+    if (macKeyCodeIsLayoutSensitive(keyCode))\n+    {\n+        return getJavaCodeForMacKey(keyCode);\n+    }\n+\n@@ -284,0 +451,5 @@\n+    if (javaKeyCode == com_sun_glass_events_KeyEvent_VK_UNDEFINED)\n+        return NO;\n+\n+    BOOL found = NO;\n+    \/\/ Find a key code based on the US QWERTY layout\n@@ -289,1 +461,22 @@\n-            return YES;\n+            found = YES;\n+            break;\n+        }\n+    }\n+\n+    \/\/ The table only covers US QWERTY so it's missing entries like PLUS that\n+    \/\/ don't appear on that layout.\n+    if (found && !macKeyCodeIsLayoutSensitive(*outMacKeyCode))\n+        return YES;\n+\n+    \/\/ If the QWERTY key is in the layout sensitive area search the other keys in that\n+    \/\/ area. We may not find a key so returning NO is possible.\n+    for (unsigned short trialKey = 0x00; trialKey <= 0x7E; ++trialKey)\n+    {\n+        if (macKeyCodeIsLayoutSensitive(trialKey))\n+        {\n+            jint trialCode = getJavaCodeForMacKey(trialKey);\n+            if (trialCode == javaKeyCode)\n+            {\n+                *outMacKeyCode = trialKey;\n+                return YES;\n+            }\n@@ -293,1 +486,0 @@\n-    \/\/ ??? unknown VK\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassKey.m","additions":194,"deletions":2,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -0,0 +1,812 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.event.EventHandler;\n+import javafx.geometry.Insets;\n+import javafx.scene.Node;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.ChoiceBox;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.input.KeyCharacterCombination;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyEvent;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.Priority;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.robot.Robot;\n+import javafx.scene.Scene;\n+import javafx.stage.Stage;\n+\n+\/*\n+ * This application tests key event handling in JavaFX. Each test uses a Robot\n+ * to send platform key events and then verifies that the correct JavaFX\n+ * KeyEvents are generated.\n+ *\n+ * To provide thorough coverage a test has to be targeted at a specific layout.\n+ * Currently there are tests for U.S. (QWERTY), French (AZERTY), and German\n+ * (QWERTZ) on Mac, Windows, and Linux. Since there's no way for JavaFX to force\n+ * the layout or verify which layout is currently active it is up to the tester\n+ * to configure the correct layout before running the test.\n+ *\n+ * Each language-specific test must be run against the default layout for that\n+ * language. For example, the German test is designed to work with the layout\n+ * labeled \"German\" on a Mac, not \"German - Standard\" or any other variant.\n+ *\n+ * There is also a generic test for Latin layouts which verifies that KeyCodes A\n+ * through Z are reachable and generate the letters 'a' through 'z'. An even\n+ * more generic test is available for non-Latin layouts which verifies that\n+ * KeyCodes A through Z generate characters.\n+ *\n+ * None of these tests cover the top-row function keys or the Caps Lock key.\n+ * They also do not cover dead keys or keys which generate accented characters\n+ * (the latter don't have KeyCodes so the Robot cannot access them).\n+ *\n+ * These tests always check that the given KeyCode generates the expected\n+ * character (if any). They can optionally check that KeyCharacterCombinations\n+ * match for characters on that key. This option is disabled by default since\n+ * KeyCharacterCombinations don't work reliably on most platforms (for now).\n+ *\/\n+\n+public class KeyboardTest extends Application {\n+\n+    public static void main(String[] args) {\n+        Application.launch(args);\n+    }\n+\n+    private static final String os = System.getProperty(\"os.name\");\n+    private static final boolean onMac = os.startsWith(\"Mac\");\n+    private static final boolean onLinux = os.startsWith(\"Linux\");\n+    private static final boolean onWindows = os.startsWith(\"Windows\");\n+\n+    \/**\n+     * Data for testing one key including the code and expected character.\n+     *\/\n+    static private class KeyData {\n+        \/*\n+         * If character is null it means we don't expect a TYPED event. If\n+         * character is \"wild\" it means we'll accept anything (used for testing\n+         * non-Latin layouts).\n+         *\/\n+        public final KeyCode   code;\n+        public final String    character;\n+\n+        \/*\n+         * Optional characters on this key accessed using modifiers like Shift,\n+         * Option, or AltGr.\n+         *\/\n+        public String          comboChar;\n+        public String          comboChar2;\n+\n+        \/*\n+         * We also test a handful of KeyCodes which should not generate any\n+         * events, like UNDEFINED. For these we set the absent flag.\n+         *\/\n+        public boolean         absent;\n+\n+        public KeyData(KeyCode cd, String ch, String combo1, String combo2) {\n+            code = cd;\n+            character = ch;\n+            comboChar = combo1;\n+            comboChar2 = combo2;\n+            absent = false;\n+        }\n+    }\n+\n+    \/**\n+     * List of keys to test for one layout\n+     *\/\n+    @SuppressWarnings(\"serial\")\n+    static private class KeyList extends ArrayList<KeyData> {}\n+\n+    static private class KeyListBuilder {\n+\n+        private final KeyList list = new KeyList();\n+        public final KeyList getList() {\n+            return list;\n+        }\n+\n+        private static final String DOUBLE_QUOTE = \"\\\"\";\n+        private static final String QUOTE        = \"\\'\";\n+        private static final String BACK_SLASH   = \"\\\\\";\n+        private static final String A_GRAVE      = \"\\u00E0\";\n+        private static final String E_GRAVE      = \"\\u00E8\";\n+        private static final String E_ACUTE      = \"\\u00E9\";\n+        private static final String SECTION      = \"\\u00A7\";\n+        private static final String C_CEDILLA    = \"\\u00E7\";\n+        private static final String DEGREE_SIGN  = \"\\u00B0\";\n+        private static final String POUND_SIGN   = \"\\u00A3\";\n+\n+        \/* Add a key with unshifted and shifted characters *\/\n+        private void add(KeyCode cd, String base, String shifted) {\n+            list.add(new KeyData(cd, base, shifted, null));\n+        }\n+\n+        \/* Add a key with an unshifted character *\/\n+        private void add(KeyCode cd, String base) {\n+            list.add(new KeyData(cd, base, null, null));\n+        }\n+\n+        \/* Add a key that does not generate a TYPED event *\/\n+        private void add(KeyCode cd) {\n+            list.add(new KeyData(cd, null, null, null));\n+        }\n+\n+        \/* Add a key with unshifted, shifted, and AltGr\/Option characters *\/\n+        private void add(KeyCode cd, String base, String shifted, String altGr) {\n+            list.add(new KeyData(cd, base, shifted, altGr));\n+        }\n+\n+        \/* Add a key that should not generate any events *\/\n+        public void addAbsent(KeyCode cd) {\n+            KeyData missing = new KeyData(cd, null, null, null);\n+            missing.absent = true;\n+            list.add(missing);\n+        }\n+\n+        \/*\n+         * Add keys A through Z assuming they generate 'a' through 'z' unshifted\n+         * and 'A' to 'Z' shifted\n+         *\/\n+        private void addLetters() {\n+            for (Character c = 'A'; c <= 'Z'; ++c) {\n+                String s = String.valueOf(c);\n+                KeyCode code = KeyCode.valueOf(s);\n+                add(code, s.toLowerCase(Locale.ENGLISH), s);\n+            }\n+        }\n+\n+        private void addDigits() {\n+            add(KeyCode.DIGIT0, \"0\");\n+            add(KeyCode.DIGIT1, \"1\");\n+            add(KeyCode.DIGIT2, \"2\");\n+            add(KeyCode.DIGIT3, \"3\");\n+            add(KeyCode.DIGIT4, \"4\");\n+            add(KeyCode.DIGIT5, \"5\");\n+            add(KeyCode.DIGIT6, \"6\");\n+            add(KeyCode.DIGIT7, \"7\");\n+            add(KeyCode.DIGIT8, \"8\");\n+            add(KeyCode.DIGIT9, \"9\");\n+        }\n+\n+        private void addKeypad() {\n+            add(KeyCode.NUMPAD0,  \"0\");\n+            add(KeyCode.NUMPAD1,  \"1\");\n+            add(KeyCode.NUMPAD2,  \"2\");\n+            add(KeyCode.NUMPAD3,  \"3\");\n+            add(KeyCode.NUMPAD4,  \"4\");\n+            add(KeyCode.NUMPAD5,  \"5\");\n+            add(KeyCode.NUMPAD6,  \"6\");\n+            add(KeyCode.NUMPAD7,  \"7\");\n+            add(KeyCode.NUMPAD8,  \"8\");\n+            add(KeyCode.NUMPAD9,  \"9\");\n+            add(KeyCode.ADD,      \"+\");\n+            add(KeyCode.SUBTRACT, \"-\");\n+            add(KeyCode.MULTIPLY, \"*\");\n+            add(KeyCode.DIVIDE,   \"\/\");\n+            if (onMac) {\n+                add(KeyCode.CLEAR, \"\");\n+            }\n+            \/*\n+             * We do not add DECIMAL since the character it generates varies by\n+             * platform and language. It will be added later.\n+             *\/\n+        }\n+\n+        private void addNavigation() {\n+            add(KeyCode.HOME);\n+            add(KeyCode.END);\n+            add(KeyCode.PAGE_UP);\n+            add(KeyCode.PAGE_DOWN);\n+            add(KeyCode.UP);\n+            add(KeyCode.DOWN);\n+            add(KeyCode.LEFT);\n+            add(KeyCode.RIGHT);\n+        }\n+\n+        private void addMiscellaneous() {\n+            add(KeyCode.SHIFT);\n+            add(KeyCode.ALT);\n+            add(KeyCode.CONTROL);\n+\n+            add(KeyCode.SPACE, \" \");\n+            add(KeyCode.TAB,   \"\\t\");\n+\n+            \/*\n+             * ENTER is assigned to both Return and Enter which generate\n+             * different characters.\n+             *\/\n+            add(KeyCode.ENTER, \"wild\");\n+\n+            if (onMac) {\n+                add(KeyCode.COMMAND);\n+                add(KeyCode.BACK_SPACE, \"\");\n+                add(KeyCode.DELETE,     \"\");\n+                add(KeyCode.ESCAPE,     \"\");\n+            } else {\n+                add(KeyCode.BACK_SPACE, \"\\u0008\");\n+                add(KeyCode.DELETE,     \"\\u007F\");\n+                add(KeyCode.ESCAPE,     \"\\u001B\");\n+                add(KeyCode.INSERT);\n+\n+                \/\/ Sent twice to toggle off and back on\n+                add(KeyCode.NUM_LOCK);\n+                add(KeyCode.NUM_LOCK);\n+            }\n+\n+            \/*\n+             * We do not test CAPS. Every platform has special case code for\n+             * CAPS that generates multiple PRESSED and RELEASED events in\n+             * succession.\n+             *\/\n+\n+            \/*\n+             * Clearly this KeyCode should not generate any events.\n+             *\/\n+            addAbsent(KeyCode.UNDEFINED);\n+        }\n+\n+        \/*\n+         * Add all of the keys common to all layouts\n+         *\/\n+        private void addCommon() {\n+            addKeypad();\n+            addNavigation();\n+            addMiscellaneous();\n+        }\n+\n+        \/*\n+         * The U.S. English QWERTY layout. Same on all platforms.\n+         *\/\n+        public static KeyList usEnglishKeys() {\n+            KeyListBuilder builder = new KeyListBuilder();\n+            builder.addCommon();\n+            builder.addLetters();\n+\n+            builder.add(KeyCode.DIGIT0, \"0\", \")\");\n+            builder.add(KeyCode.DIGIT1, \"1\", \"!\");\n+            builder.add(KeyCode.DIGIT2, \"2\", \"@\");\n+            builder.add(KeyCode.DIGIT3, \"3\", \"#\");\n+            builder.add(KeyCode.DIGIT4, \"4\", \"$\");\n+            builder.add(KeyCode.DIGIT5, \"5\", \"%\");\n+            builder.add(KeyCode.DIGIT6, \"6\", \"^\");\n+            builder.add(KeyCode.DIGIT7, \"7\", \"&\");\n+            builder.add(KeyCode.DIGIT8, \"8\", \"*\");\n+            builder.add(KeyCode.DIGIT9, \"9\", \"(\");\n+\n+            builder.add(KeyCode.BACK_QUOTE,    \"`\",  \"~\");\n+            builder.add(KeyCode.MINUS,         \"-\",  \"_\");\n+            builder.add(KeyCode.EQUALS,        \"=\",  \"+\");\n+            builder.add(KeyCode.OPEN_BRACKET,  \"[\",  \"{\");\n+            builder.add(KeyCode.CLOSE_BRACKET, \"]\",  \"}\");\n+            builder.add(KeyCode.BACK_SLASH,    BACK_SLASH, \"|\");\n+            builder.add(KeyCode.SEMICOLON,     \";\",  \":\");\n+            builder.add(KeyCode.QUOTE,         QUOTE, DOUBLE_QUOTE);\n+            builder.add(KeyCode.COMMA,         \",\",  \"<\");\n+            builder.add(KeyCode.PERIOD,        \".\",  \">\");\n+            builder.add(KeyCode.SLASH,         \"\/\",  \"?\");\n+\n+            builder.add(KeyCode.DECIMAL,       \".\");\n+\n+            builder.addAbsent(KeyCode.PLUS);\n+\n+            return builder.getList();\n+        }\n+\n+        \/* The French AZERTY layout *\/\n+        public static KeyList frenchKeys() {\n+            KeyListBuilder builder = new KeyListBuilder();\n+            builder.addCommon();\n+            builder.addLetters();\n+\n+            \/* Include one combination that involves AltGr\/Option. *\/\n+            final String altGrFive = (onMac ? \"{\" : \"[\");\n+\n+            \/*\n+             * On a French layout the unshifted top-row keys (which generate\n+             * digits in most other languages) generate punctuation or accented\n+             * characters. Linux uses these characters to generate KeyCodes; Mac\n+             * and Windows still encode these keys as digits.\n+             *\/\n+            if (onLinux) {\n+                builder.add(KeyCode.AMPERSAND,        \"&\",          \"1\");\n+                builder.add(KeyCode.QUOTEDBL,         DOUBLE_QUOTE, \"3\");\n+                builder.add(KeyCode.QUOTE,            QUOTE,        \"4\");\n+                builder.add(KeyCode.LEFT_PARENTHESIS, \"(\",          \"5\", altGrFive);\n+                builder.add(KeyCode.MINUS,            \"-\",          \"6\");\n+                builder.add(KeyCode.UNDERSCORE,       \"_\",          \"8\");\n+            } else {\n+                builder.add(KeyCode.DIGIT0, A_GRAVE,      \"0\");\n+                builder.add(KeyCode.DIGIT1, \"&\",          \"1\");\n+                builder.add(KeyCode.DIGIT2, E_ACUTE,      \"2\");\n+                builder.add(KeyCode.DIGIT3, DOUBLE_QUOTE, \"3\");\n+                builder.add(KeyCode.DIGIT4, QUOTE,        \"4\");\n+                builder.add(KeyCode.DIGIT5, \"(\",          \"5\", altGrFive);\n+                \/* Six and eight require some tweaking, below *\/\n+                builder.add(KeyCode.DIGIT7, E_GRAVE,      \"7\");\n+                builder.add(KeyCode.DIGIT9, C_CEDILLA,    \"9\");\n+\n+                if (onMac) {\n+                    builder.add(KeyCode.DIGIT6, SECTION,  \"6\");\n+                    builder.add(KeyCode.DIGIT8, \"!\",      \"8\");\n+                } else {\n+                    builder.add(KeyCode.DIGIT6, \"-\",      \"6\");\n+                    builder.add(KeyCode.DIGIT8, \"_\",      \"8\");\n+                }\n+            }\n+\n+            builder.add(KeyCode.LESS,              \"<\", \">\");\n+            builder.add(KeyCode.RIGHT_PARENTHESIS, \")\", DEGREE_SIGN);\n+            builder.add(KeyCode.COMMA,             \",\", \"?\");\n+            builder.add(KeyCode.SEMICOLON,         \";\", \".\");\n+            builder.add(KeyCode.COLON,             \":\", \"\/\");\n+            builder.add(KeyCode.EQUALS,            \"=\", \"+\");\n+\n+            if (onMac) {\n+                builder.add(KeyCode.DOLLAR,        \"$\", \"*\");\n+                builder.add(KeyCode.MINUS,         \"-\", \"_\");\n+                builder.add(KeyCode.DECIMAL,       \",\");\n+            } else {\n+                builder.add(KeyCode.DOLLAR,           \"$\", POUND_SIGN);\n+                builder.add(KeyCode.EXCLAMATION_MARK, \"!\", SECTION);\n+                builder.add(KeyCode.DECIMAL,          \".\");\n+            }\n+\n+            builder.addAbsent(KeyCode.PLUS);\n+\n+            return builder.getList();\n+        }\n+\n+        \/* The German QWERTZ layout *\/\n+        public static KeyList germanKeys() {\n+            KeyListBuilder builder = new KeyListBuilder();\n+            builder.addCommon();\n+            builder.addLetters();\n+\n+            \/* Include one combination that involves Option\/AltGr *\/\n+            final String altGrSeven = (onMac ? \"|\" : \"{\");\n+            final String decimalCharacter = (onLinux ? \".\" : \",\");\n+\n+            builder.add(KeyCode.DIGIT0, \"0\", \"=\");\n+            builder.add(KeyCode.DIGIT1, \"1\", \"!\");\n+            builder.add(KeyCode.DIGIT2, \"2\", DOUBLE_QUOTE);\n+            builder.add(KeyCode.DIGIT3, \"3\", SECTION);\n+            builder.add(KeyCode.DIGIT4, \"4\", \"$\");\n+            builder.add(KeyCode.DIGIT5, \"5\", \"%\");\n+            builder.add(KeyCode.DIGIT6, \"6\", \"&\");\n+            builder.add(KeyCode.DIGIT7, \"7\", \"\/\", altGrSeven);\n+            builder.add(KeyCode.DIGIT8, \"8\", \"(\");\n+            builder.add(KeyCode.DIGIT9, \"9\", \")\");\n+\n+            builder.add(KeyCode.LESS,        \"<\", \">\");\n+            builder.add(KeyCode.PLUS,        \"+\", \"*\");\n+            builder.add(KeyCode.NUMBER_SIGN, \"#\", QUOTE);\n+            builder.add(KeyCode.COMMA,       \",\", \";\");\n+            builder.add(KeyCode.PERIOD,      \".\", \":\");\n+            builder.add(KeyCode.MINUS,       \"-\", \"_\");\n+\n+            builder.add(KeyCode.DECIMAL,     decimalCharacter);\n+\n+            builder.addAbsent(KeyCode.COLON);\n+\n+            return builder.getList();\n+        }\n+\n+        \/*\n+         * A generic Latin layout. No digits since layouts derived from French\n+         * won't generate digit characters and may not even be encoded as digits\n+         * on Linux.\n+         *\/\n+        public static KeyList latinKeys() {\n+            KeyListBuilder builder = new KeyListBuilder();\n+            builder.addCommon();\n+            builder.addLetters();\n+            return builder.getList();\n+        }\n+\n+        \/*\n+         * For non-Latin layouts (Greek, Cyrillic) we should be able to access\n+         * the letter KeyCodes though we have no idea what characters they\n+         * generate.\n+         *\/\n+        public static KeyList nonLatinKeys() {\n+            KeyListBuilder builder = new KeyListBuilder();\n+            builder.addCommon();\n+            builder.addDigits();\n+            for (Character c = 'A'; c <= 'Z'; ++c) {\n+                String s = String.valueOf(c);\n+                KeyCode code = KeyCode.valueOf(s);\n+                builder.add(code, \"wild\");\n+            }\n+            return builder.getList();\n+        }\n+    }\n+\n+    private enum Layout {\n+        US_ENGLISH(\"U.S. English\", KeyListBuilder.usEnglishKeys()),\n+        FRENCH(\"French\", KeyListBuilder.frenchKeys()),\n+        GERMAN(\"German\", KeyListBuilder.germanKeys()),\n+        LATIN(\"Latin\", KeyListBuilder.latinKeys()),\n+        NON_LATIN(\"non-Latin\", KeyListBuilder.nonLatinKeys());\n+\n+        private final String label;\n+        private final KeyList keys;\n+\n+        private Layout(String l, KeyList k) {\n+            this.label = l;\n+            this.keys = k;\n+        }\n+\n+        public String toString() {\n+            return label;\n+        }\n+\n+        public KeyList getKeys() {\n+            return keys;\n+        }\n+    }\n+\n+    \/*\n+     * KeyCharacterCombinations should really work on the numeric keypad but\n+     * currently don't on Windows and Linux. The tests can exclude combinations\n+     * entirely, exclude just the numeric keypad, or cover both the main\n+     * keyboard and the keypad.\n+     *\/\n+    private enum CombinationScope {\n+        NONE(\"without combinations\"),\n+        NO_KEYPAD(\"without keypad combinations\"),\n+        ALL(\"with all combinations\");\n+\n+        private final String label;\n+\n+        private CombinationScope(String l) {\n+            this.label = l;\n+        }\n+\n+        public String toString() {\n+            return label;\n+        }\n+    }\n+\n+    private interface Logging {\n+        public void clear();\n+        public void addLine(String s);\n+    }\n+\n+    \/*\n+     * The class that walks through the key list sending Robot events and\n+     * verifies the expected KeyEvents come back.\n+     *\/\n+    private class TestRunner {\n+\n+        \/*\n+         * Configured during initialization\n+         *\/\n+        private final Layout layout;\n+        private final CombinationScope combinationScope;\n+        private final Node focusNode;\n+        private final Logging log;\n+        private final KeyList keys;\n+\n+        \/*\n+         * Our progress\n+         *\/\n+        private int currentIndex = -1;\n+        private int numSent = 0;\n+        private int numFailed = 0;\n+\n+        \/* The character in the last TYPED event *\/\n+        private String characterReceived = null;\n+\n+        private final Robot robot = new Robot();\n+        private Timer timer = null;\n+\n+        private final EventHandler<KeyEvent> pressedHandler = this::pressedEvent;\n+        private final EventHandler<KeyEvent> releasedHandler = this::releasedEvent;\n+        private final EventHandler<KeyEvent> typedHandler = this::typedEvent;\n+\n+        private Runnable runAtEnd = null;\n+\n+        public TestRunner(Layout layout, CombinationScope scope,\n+                          Node focusNode, Logging log) {\n+            this.layout = layout;\n+            this.combinationScope = scope;\n+            this.focusNode = focusNode;\n+            this.log = log;\n+            this.keys = layout.getKeys();\n+        }\n+\n+        private String toPrintable(String s) {\n+            if (s == null) {\n+                return \"null\";\n+            } else if (!s.isEmpty()) {\n+                char c = s.charAt(0);\n+                int codePoint = s.codePointAt(0);\n+                if (Character.isISOControl(c) || Character.isWhitespace(c)) {\n+                    return String.format(\"U+%04X\", codePoint);\n+                } else {\n+                    return s;\n+                }\n+            }\n+            return \"empty\";\n+        }\n+\n+        private void fail(String s) {\n+            numFailed += 1;\n+            log.addLine(\"Failed: \" + s);\n+        }\n+\n+        private void start(Runnable atEnd) {\n+            runAtEnd = atEnd;\n+\n+            log.clear();\n+\n+            Optional<Boolean> capsLockOn = Platform.isKeyLocked(KeyCode.CAPS);\n+            Optional<Boolean> numLockOn = Platform.isKeyLocked(KeyCode.NUM_LOCK);\n+            boolean proceed = true;\n+            if (capsLockOn.isPresent() && capsLockOn.get() == Boolean.TRUE) {\n+                log.addLine(\"Disable Caps Lock before running test.\");\n+                proceed = false;\n+            }\n+            if (numLockOn.isPresent() && numLockOn.get() == Boolean.FALSE) {\n+                log.addLine(\"Enable Num Lock before running test.\");\n+                proceed = false;\n+            }\n+            if (!proceed) {\n+                if (runAtEnd != null) {\n+                    runAtEnd.run();\n+                }\n+                return;\n+            }\n+\n+            String osName = \"unknown\";\n+            if (onWindows) {\n+                osName = \"Win\";\n+            } else if (onMac) {\n+                osName = \"Mac\";\n+            } else if (onLinux) {\n+                osName = \"Linux\";\n+            }\n+\n+            log.addLine(\"[\" + osName + \"] Testing \" + keys.size() + \" keys on \"\n+                    + layout + \" \" + combinationScope);\n+\n+            focusNode.addEventFilter(KeyEvent.KEY_PRESSED, pressedHandler);\n+            focusNode.addEventFilter(KeyEvent.KEY_RELEASED, releasedHandler);\n+            focusNode.addEventFilter(KeyEvent.KEY_TYPED, typedHandler);\n+            focusNode.requestFocus();\n+\n+            currentIndex = -1;\n+            advance();\n+        }\n+\n+        private void advance() {\n+            if (timer != null) {\n+                timer.cancel();\n+                timer = null;\n+            }\n+            currentIndex += 1;\n+            if (currentIndex >= keys.size()) {\n+                cleanup();\n+            } else {\n+                characterReceived = null;\n+                numSent += 1;\n+                KeyData data = keys.get(currentIndex);\n+                Platform.runLater(() -> sendCode(data.code));\n+            }\n+        }\n+\n+        private void sendCode(KeyCode code) {\n+            \/*\n+            * This timer is cleared when the RELEASED event calls advance().\n+            *\/\n+            TimerTask task = new TimerTask() {\n+                public void run() {\n+                    Platform.runLater(() -> keyTimedOut());\n+                }\n+            };\n+            timer = new Timer();\n+            timer.schedule(task, 100);\n+            robot.keyPress(code);\n+            robot.keyRelease(code);\n+        }\n+\n+        \/*\n+        * No RELEASED event arrived. Acceptable if the key was supposed to be\n+        * absent.\n+        *\/\n+        private void keyTimedOut() {\n+            KeyData key = keys.get(currentIndex);\n+            if (!key.absent) {\n+                fail(\"code \" + key.code.getName() + \" did not produce any events\");\n+            }\n+            advance();\n+        }\n+\n+        private static boolean isOnKeypad(KeyCode code) {\n+            switch (code) {\n+                case DIVIDE, MULTIPLY, SUBTRACT, ADD, DECIMAL:\n+                case NUMPAD0, NUMPAD1, NUMPAD2, NUMPAD3, NUMPAD4:\n+                case NUMPAD5, NUMPAD6, NUMPAD7, NUMPAD8, NUMPAD9:\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n+        private void checkCombination(KeyEvent event, String comboString) {\n+            if (combinationScope == CombinationScope.NONE) {\n+                return;\n+            }\n+            if (comboString == null || comboString.isEmpty() || comboString.equals(\"wild\")) {\n+                return;\n+            }\n+            if (isOnKeypad(event.getCode()) && (combinationScope != CombinationScope.ALL)) {\n+                return;\n+            }\n+\n+            KeyCharacterCombination combo = new KeyCharacterCombination(comboString);\n+            if (!combo.match(event)) {\n+                fail(\"code \" + event.getCode().getName() + \" did not match combination \" + combo.getName());\n+            }\n+        }\n+\n+        private void pressedEvent(KeyEvent e) {\n+            KeyData key = keys.get(currentIndex);\n+            KeyCode got = e.getCode();\n+            KeyCode expected = key.code;\n+            String preamble = \"code \" + key.code.getName() + \" \";\n+\n+            if (key.absent) {\n+                fail(preamble + \"produced an unexpected PRESSED event\");\n+            } else if (expected != got) {\n+                fail(preamble + \"was sent but code \" + got.getName() + \" was received\");\n+            } else {\n+                checkCombination(e, key.character);\n+                checkCombination(e, key.comboChar);\n+                checkCombination(e, key.comboChar2);\n+            }\n+            e.consume();\n+        }\n+\n+        private void typedEvent(KeyEvent e) {\n+            KeyData key = keys.get(currentIndex);\n+            String preamble = \"code \" + key.code.getName() + \" \";\n+            characterReceived = e.getCharacter();\n+\n+            if (key.character == null) {\n+                String printable = toPrintable(characterReceived);\n+                fail(preamble + \"produced an unexpected TYPED event (\" + printable + \")\");\n+            } else if (key.character.equals(\"wild\")) {\n+                if (characterReceived == null || characterReceived.isEmpty()) {\n+                    fail(preamble + \"produced a TYPED event with no character\");\n+                }\n+            } else if (!key.character.equals(characterReceived)) {\n+                fail(preamble + \"generated \" + toPrintable(characterReceived)\n+                    + \" instead of \" + toPrintable(key.character));\n+            }\n+            e.consume();\n+        }\n+\n+        private void releasedEvent(KeyEvent e) {\n+            KeyData key = keys.get(currentIndex);\n+            String preamble = \"code \" + key.code.getName() + \" \";\n+\n+            if (key.absent) {\n+                fail(preamble + \"produced an unexpected RELEASED event\");\n+            } else if ((key.character != null) && (characterReceived == null)) {\n+                fail(preamble + \"did not produce a TYPED event\");\n+            }\n+            e.consume();\n+            advance();\n+        }\n+\n+        \/*\n+         * Called after the list of keys is exhausted.\n+         *\/\n+        private void cleanup() {\n+            if (timer != null) {\n+                timer.cancel();\n+                timer = null;\n+            }\n+\n+            focusNode.removeEventFilter(KeyEvent.KEY_PRESSED, pressedHandler);\n+            focusNode.removeEventFilter(KeyEvent.KEY_RELEASED, releasedHandler);\n+            focusNode.removeEventFilter(KeyEvent.KEY_TYPED, typedHandler);\n+\n+            log.addLine(\"Tested \" + numSent + \" keys with \"\n+                    + (numFailed == 1 ? \"1 failure\" : numFailed + \" failures\"));\n+\n+            if (runAtEnd != null) {\n+                runAtEnd.run();\n+            }\n+        }\n+    }\n+\n+    private class TextLogging implements Logging {\n+        private final TextArea textArea;\n+        public TextLogging(TextArea ta) {\n+            textArea = ta;\n+        }\n+\n+        public void clear() {\n+            textArea.setText(\"\");\n+        }\n+\n+        public void addLine(String s) {\n+            textArea.appendText(s + \"\\n\");\n+        }\n+    }\n+\n+    @Override\n+    public void start(Stage stage) {\n+\n+        final TextArea logArea = new TextArea();\n+        logArea.setEditable(false);\n+        Logging logger = new TextLogging(logArea);\n+\n+        ChoiceBox<Layout> layoutChoice = new ChoiceBox<>();\n+        layoutChoice.getItems().setAll(Layout.values());\n+        layoutChoice.setValue(Layout.US_ENGLISH);\n+\n+        ChoiceBox<CombinationScope> combinationChoice = new ChoiceBox<>();\n+        combinationChoice.getItems().setAll(CombinationScope.values());\n+        combinationChoice.setValue(CombinationScope.NONE);\n+\n+        Button testButton = new Button(\"Run test\");\n+        testButton.setOnAction(b -> {\n+            testButton.setDisable(true);\n+            Layout layout = layoutChoice.getValue();\n+            CombinationScope comboScope = combinationChoice.getValue();\n+            TestRunner testRunner = new TestRunner(layout, comboScope, logArea, logger);\n+            testRunner.start(() -> {\n+                testButton.setDisable(false);\n+                testButton.requestFocus();\n+            });\n+        });\n+\n+        HBox testControls = new HBox();\n+        testControls.setSpacing(5);\n+        testControls.getChildren().addAll(testButton, layoutChoice, combinationChoice);\n+\n+        VBox root = new VBox();\n+        root.setPadding(new Insets(5));\n+        root.setSpacing(5);\n+        VBox.setVgrow(logArea, Priority.ALWAYS);\n+        root.getChildren().addAll(testControls, logArea);\n+\n+        Scene scene = new Scene(root, 640, 640);\n+        stage.setScene(scene);\n+        stage.setTitle(\"Keyboard Test\");\n+        stage.show();\n+\n+        Platform.runLater(testButton::requestFocus);\n+    }\n+}\n","filename":"tests\/manual\/events\/KeyboardTest.java","additions":812,"deletions":0,"binary":false,"changes":812,"status":"added"}]}