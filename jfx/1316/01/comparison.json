{"files":[{"patch":"@@ -0,0 +1,569 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.css;\n+\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+\n+\/**\n+ * Provides set implementations which have a fixed capacity. These are highly optimized\n+ * and only suitable for very specific use cases where the maximum size is known in advance\n+ * and when items are expected to never be removed from the sets. Fixed capacity sets will\n+ * throw {@link IllegalStateException} if adding an element would exceed the maximum capacity.\n+ *\n+ * <p>These sets do not allow {@code null} elements, and unless otherwise specified, passing\n+ * {@code null} for any argument will result in a {@link NullPointerException}.\n+ *\n+ * <p>Specifically, these sets are optimized for holding sets of style class names, which\n+ * have the following characteristics:\n+ *\n+ * <ul>\n+ * <li>Never {@code null}<\/li>\n+ * <li>Sets in almost all cases contain just 1 or 2 elements, only rarely containing 3 or more<\/li>\n+ * <li>Sets are often compared using containsAll; to avoid creating an iterator when the input is not\n+ *   a {@code FixedSizeSet}, the inverse function {@link #isSuperSetOf(Collection)} is provided<\/li>\n+ * <\/ul>\n+ *\n+ * The provided implementations are optimized for memory use, fast containsAll and\n+ * fast iteration. Generally, these sets will use half the memory of an equivalent\n+ * {@code HashSet} (and comparable to the immutable sets provided by {@code Set.of()})\n+ * as they do not require a wrapper to hold each element.\n+ *\n+ * <p>These sets can only be appended, reject {@code null}s, have a fixed maximum size (which will throw\n+ * an exception if exceeded), and can be frozen (made read-only without using a wrapper).\n+ *\n+ * <p>The fall back set implementation for large sets uses open addressing. It is\n+ * only lightly optimized as the expectation is that it will see little to no use.\n+ * It is still preferred over {@code HashSet} due to its low memory foot print, and\n+ * faster iteration.\n+ *\n+ * @param <T> the element type\n+ *\/\n+public sealed abstract class FixedCapacitySet<T> extends AbstractSet<T> {\n+    private static final FixedCapacitySet<?> EMPTY;\n+\n+    static {\n+        EMPTY = new Single<>();\n+\n+        EMPTY.freeze();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> FixedCapacitySet<T> empty() {\n+        return (FixedCapacitySet<T>) EMPTY;\n+    }\n+\n+    \/**\n+     * Creates a new {@link FixedCapacitySet} with the given maximum capacity.\n+     * If the capacity is exceeded, fixed capacity sets do not grow, but instead\n+     * throw an {@link IllegalStateException}.\n+     *\n+     * @param <T> the element type\n+     * @param maximumCapacity the maximum possible number of elements the set can hold, cannot be negative\n+     * @return a new empty set, never {@code null}\n+     *\/\n+    public static <T> FixedCapacitySet<T> of(int maximumCapacity) {\n+        return maximumCapacity == 0 ? empty()\n+             : maximumCapacity == 1 ? new Single<>()\n+             : maximumCapacity == 2 ? new Duo<>()\n+             : maximumCapacity < 10 ? new Hashless<>(maximumCapacity)  \/\/ will reject negative values\n+                                    : new OpenAddressed<>(maximumCapacity);\n+    }\n+\n+    private boolean frozen;\n+\n+    \/**\n+     * Checks if the given collection contains all elements\n+     * of this collection. This is the same as {@link #containsAll(Collection)}\n+     * with the source and target reversed, ie. {@code \"a.containsAll(b)\"} is equivalent\n+     * to {@code \"b.isSuperSetOf(a)\"}.\n+     *\n+     * <p>If the given collection is small, or has good {@link #contains(Object)}\n+     * performance, using this inverse function avoids creating an {@link Iterator}\n+     * for this collection.\n+     *\n+     * @param c a collection to check, cannot be {@code null}\n+     * @return {@code true} if the given collection contains all elements of this\n+     *   collection, otherwise {@code false}\n+     *\/\n+    public abstract boolean isSuperSetOf(Collection<?> c);\n+\n+    \/**\n+     * Freezes this collection, turning it permanently read-only. After freezing,\n+     * any method that would modify the collection will instead throw\n+     * {@link UnsupportedOperationException}.\n+     *\n+     * <p>This can be used to avoid wrapping the collection with an unmodifiable\n+     * collection or making a read-only copy.\n+     *\/\n+    public final void freeze() {\n+        this.frozen = true;\n+    }\n+\n+    \/**\n+     * Checks if the set is allowed to be mutated, and throws an\n+     * {@link UnsupportedEncodingException} otherwise.\n+     *\/\n+    protected final void ensureNotFrozen() {\n+        if (frozen) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    \/**\n+     * A set that can hold 0 or 1 elements.\n+     *\n+     * @param <T> the element type\n+     *\/\n+    private static final class Single<T> extends FixedCapacitySet<T> {\n+        private T element;\n+\n+        @Override\n+        public int size() {\n+            return element == null ? 0 : 1;\n+        }\n+\n+        @Override\n+        public Iterator<T> iterator() {\n+            return new Iterator<>() {\n+                private boolean hasNext = element != null;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return hasNext;\n+                }\n+\n+                @Override\n+                public T next() {\n+                    if (!hasNext()) {\n+                        throw new NoSuchElementException();\n+                    }\n+\n+                    hasNext = false;\n+\n+                    return element;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public boolean isSuperSetOf(Collection<?> c) {\n+            return element == null || c.contains(element);\n+        }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+            return element != null && element.equals(o);\n+        }\n+\n+        @Override\n+        public boolean add(T e) {\n+            ensureNotFrozen();\n+\n+            if (contains(Objects.requireNonNull(e, \"e\"))) {\n+                return false;\n+            }\n+\n+            if (element != null) {\n+                throw new IllegalStateException(\"set is full\");\n+            }\n+\n+            element = e;\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean addAll(Collection<? extends T> c) {\n+            boolean modified = false;\n+\n+            for (T element : c) {\n+                modified |= add(element);\n+            }\n+\n+            return modified;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return element == null ? 0 : element.hashCode();\n+        }\n+    }\n+\n+    \/**\n+     * A set that can hold 0, 1 or 2 elements.\n+     *\n+     * @param <T> the element type\n+     *\/\n+    private static final class Duo<T> extends FixedCapacitySet<T> {\n+        private T element1;\n+        private T element2;\n+        private int size;\n+\n+        @Override\n+        public int size() {\n+            return size;\n+        }\n+\n+        @Override\n+        public Iterator<T> iterator() {\n+            return new Iterator<>() {\n+                private int index;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return index < size;\n+                }\n+\n+                @Override\n+                public T next() {\n+                    if (!hasNext()) {\n+                        throw new NoSuchElementException();\n+                    }\n+\n+                    return index++ == 0 ? element1 : element2;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public boolean isSuperSetOf(Collection<?> c) {\n+            return element1 == null || (c.contains(element1) && (element2 == null || c.contains(element2)));\n+        }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+            return (element1 != null && element1.equals(o)) || (element2 != null && element2.equals(o));\n+        }\n+\n+        @Override\n+        public boolean add(T e) {\n+            ensureNotFrozen();\n+\n+            if (contains(Objects.requireNonNull(e, \"e\"))) {\n+                return false;\n+            }\n+\n+            if (size == 2) {\n+                throw new IllegalStateException(\"set is full\");\n+            }\n+\n+            if (size == 0) {\n+                element1 = e;\n+            }\n+            else {\n+                element2 = e;\n+            }\n+\n+            size++;\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean addAll(Collection<? extends T> c) {\n+            boolean modified = false;\n+\n+            for (T element : c) {\n+                modified |= add(element);\n+            }\n+\n+            return modified;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return element1 == null ? 0 : element1.hashCode() + (element2 == null ? 0 : element2.hashCode());\n+        }\n+    }\n+\n+    \/**\n+     * A set which can hold a fixed maximum number of elements. This implementation\n+     * does not use hashing, but does eliminate duplicates (as per the set contract).\n+     * Performance is better than sets which use hashing when the number of elements\n+     * is small enough (cut off point is somewhere around 10 elements, but it will\n+     * depend on the cost of the hash function).\n+     *\n+     * @param <T> the element type\n+     *\/\n+    private static final class Hashless<T> extends FixedCapacitySet<T> {\n+        private final T[] elements;\n+\n+        private int size;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private Hashless(int capacity) {\n+            this.elements = (T[]) new Object[capacity];\n+        }\n+\n+        @Override\n+        public int size() {\n+            return size;\n+        }\n+\n+        @Override\n+        public Iterator<T> iterator() {\n+            return new Iterator<>() {\n+                private int index;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return index < size;\n+                }\n+\n+                @Override\n+                public T next() {\n+                    if (!hasNext()) {\n+                        throw new NoSuchElementException();\n+                    }\n+\n+                    return elements[index++];\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+            for (int i = 0; i < size; i++) {\n+                if (elements[i].equals(o)) {\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isSuperSetOf(Collection<?> c) {\n+            for (int i = 0; i < size; i++) {\n+                if (!c.contains(elements[i])) {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean add(T e) {\n+            ensureNotFrozen();\n+\n+            if (contains(Objects.requireNonNull(e, \"e\"))) {\n+                return false; \/\/ already present, set unchanged\n+            }\n+\n+            if (size == elements.length) {\n+                throw new IllegalStateException(\"set is full\");\n+            }\n+\n+            elements[size++] = e;\n+\n+            return true; \/\/ not present, set changed\n+        }\n+\n+        @Override\n+        public boolean addAll(Collection<? extends T> c) {\n+            boolean modified = false;\n+\n+            for (T element : c) {\n+                modified |= add(element);\n+            }\n+\n+            return modified;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = 0;\n+\n+            for (int i = 0; i < size; i++) {\n+                h += elements[i].hashCode();\n+            }\n+\n+            return h;\n+        }\n+    }\n+\n+    \/**\n+     * A set which can hold a fixed maximum number of elements. This implementation\n+     * uses open addressing to handle hash collisions using linear probing. It has a\n+     * memory footprint which is much smaller than an equivalent {@code HashSet} but\n+     * has worse worst case performance (for modification and contains) when there\n+     * are many collisions. Iteration speed will be similar to other array based\n+     * collections (which is to say, faster than {@code HashSet}).\n+     *\n+     * @param <T> the element type\n+     *\/\n+    private static final class OpenAddressed<T> extends FixedCapacitySet<T> {\n+        private final T[] elements;\n+\n+        private int size;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private OpenAddressed(int capacity) {\n+            this.elements = (T[]) new Object[capacity];\n+        }\n+\n+        @Override\n+        public int size() {\n+            return size;\n+        }\n+\n+        @Override\n+        public Iterator<T> iterator() {\n+            return new Iterator<>() {\n+                private int index = findFilledBucket(0);\n+\n+                private int findFilledBucket(int start) {\n+                    for (int i = start; i < elements.length; i++) {\n+                        if (elements[i] != null) {\n+                            return i;\n+                        }\n+                    }\n+\n+                    return -1;\n+                }\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return index >= 0;\n+                }\n+\n+                @Override\n+                public T next() {\n+                    if (!hasNext()) {\n+                        throw new NoSuchElementException();\n+                    }\n+\n+                    T element = elements[index];\n+\n+                    index = findFilledBucket(index + 1);\n+\n+                    return element;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+            int bucket = determineBucketIndex(o);\n+            int start = bucket;\n+\n+            while (elements[bucket] != null) {\n+                if (elements[bucket].equals(o)) {\n+                    return true;\n+                }\n+\n+                bucket++;  \/\/ linear probing for simplicity\n+\n+                if (bucket >= elements.length) {\n+                    bucket = 0;\n+                }\n+\n+                if (bucket == start) {\n+                    return false;  \/\/ all elements were checked, none matched\n+                }\n+            }\n+\n+            return false;  \/\/ empty bucket encountered, not contained\n+        }\n+\n+        @Override\n+        public boolean isSuperSetOf(Collection<?> c) {\n+            for (int i = 0; i < elements.length; i++) {\n+                T element = elements[i];\n+\n+                if (element != null && !c.contains(element)) {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean add(T e) {\n+            ensureNotFrozen();\n+\n+            int bucket = determineBucketIndex(e);  \/\/ implicit null check here\n+            boolean reset = false;\n+\n+            while (elements[bucket] != null) {\n+                if (elements[bucket].equals(e)) {\n+                    return false; \/\/ already present, set unchanged\n+                }\n+\n+                bucket++;  \/\/ linear probing for simplicity\n+\n+                if (bucket >= elements.length) {\n+                    bucket = 0;\n+\n+                    if (reset) {\n+                        throw new IllegalStateException(\"set is full\");\n+                    }\n+\n+                    reset = true;\n+                }\n+            }\n+\n+            elements[bucket] = e;\n+            size++;\n+\n+            return true; \/\/ not present, set changed\n+        }\n+\n+        @Override\n+        public boolean addAll(Collection<? extends T> c) {\n+            boolean modified = false;\n+\n+            for (T element : c) {\n+                modified |= add(element);\n+            }\n+\n+            return modified;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = 0;\n+\n+            for (int i = 0; i < elements.length; i++) {\n+                T element = elements[i];\n+\n+                h += element == null ? 0 : element.hashCode();\n+            }\n+\n+            return h;\n+        }\n+\n+        private int determineBucketIndex(Object o) {\n+            return (o.hashCode() & 0x7fffffff) % elements.length;  \/\/ implicit null check here\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/FixedCapacitySet.java","additions":569,"deletions":0,"binary":false,"changes":569,"status":"added"},{"patch":"@@ -31,1 +31,0 @@\n-import javafx.css.StyleClass;\n@@ -257,1 +256,1 @@\n-        final Set<StyleClass> selectorStyleClass = simpleSelector.getStyleClassSet();\n+        final Set<String> selectorStyleClass = simpleSelector.getStyleClassNames();\n@@ -307,1 +306,1 @@\n-    public List<Selector> match(String selectorId, String selectorType, Set<StyleClass> selectorStyleClass) {\n+    public List<Selector> match(String selectorId, String selectorType, Set<String> selectorStyleClass) {\n@@ -357,1 +356,1 @@\n-                                    Set<StyleClass> key = (Set<StyleClass>)styleClassKey.key;\n+                                    Set<String> key = (Set<String>)styleClassKey.key;\n@@ -360,1 +359,1 @@\n-                                        Set<StyleClass> other = (Set<StyleClass>)s.partition.key.key;\n+                                        Set<String> other = (Set<String>)s.partition.key.key;\n@@ -399,1 +398,1 @@\n-                                Set<StyleClass> key = (Set<StyleClass>)styleClassKey.key;\n+                                Set<String> key = (Set<String>)styleClassKey.key;\n@@ -402,1 +401,1 @@\n-                                    Set<StyleClass> other = (Set<StyleClass>)s.partition.key.key;\n+                                    Set<String> other = (Set<String>)s.partition.key.key;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/SelectorPartitioning.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,133 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.javafx.css;\n-\n-import javafx.css.StyleClass;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-\n-\n-\/**\n- * States represents a set of State. A {@code Node} may be in more than\n- * one pseudo-class state. {@code States} is used to aggregate the active\n- * pseudo-class state of a {@code Node}.\n- *\/\n-public final class StyleClassSet  extends BitSet<StyleClass> {\n-\n-    \/** Create an empty set of StyleClass *\/\n-    public StyleClassSet() {\n-        super();\n-    }\n-\n-    StyleClassSet(List<String> styleClassNames) {\n-\n-        int nMax = styleClassNames != null ? styleClassNames.size() : 0;\n-        for(int n=0; n<nMax; n++) {\n-            final String styleClass = styleClassNames.get(n);\n-            if (styleClass == null || styleClass.isEmpty()) continue;\n-\n-            final StyleClass sc = getStyleClass(styleClass);\n-            add(sc);\n-        }\n-\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder builder = new StringBuilder(\"style-classes: [\");\n-        Iterator<StyleClass> iter = iterator();\n-        while (iter.hasNext()) {\n-            builder.append(iter.next().getStyleClassName());\n-            if (iter.hasNext()) {\n-                builder.append(\", \");\n-            }\n-        }\n-        builder.append(']');\n-        return builder.toString();\n-    }\n-\n-    @Override\n-    protected Class<StyleClass> getElementType() {\n-        return StyleClass.class;\n-    }\n-\n-    @Override\n-    protected StyleClass getT(int index) {\n-        return getStyleClass(index);\n-    }\n-\n-    @Override\n-    protected int getIndex(StyleClass t) {\n-        return t.getIndex();\n-    }\n-\n-\n-    \/**\n-     *\/\n-    public static StyleClass getStyleClass(String styleClass) {\n-\n-        if (styleClass == null || styleClass.trim().isEmpty()) {\n-            throw new IllegalArgumentException(\"styleClass cannot be null or empty String\");\n-        }\n-\n-        StyleClass instance = null;\n-\n-        final Integer value = styleClassMap.get(styleClass);\n-        final int index = value != null ? value.intValue() : -1;\n-\n-        final int size = styleClasses.size();\n-        assert index < size;\n-\n-        if (index != -1 && index < size) {\n-            instance = styleClasses.get(index);\n-        }\n-\n-        if (instance == null) {\n-            instance = new StyleClass(styleClass, size);\n-            styleClasses.add(instance);\n-            styleClassMap.put(styleClass, Integer.valueOf(size));\n-        }\n-\n-        return instance;\n-    }\n-\n-   static StyleClass getStyleClass(int index) {\n-       if (0 <= index && index < styleClasses.size()) {\n-           return styleClasses.get(index);\n-       }\n-       return null;\n-   }\n-\n-    \/\/ package private for unit test purposes\n-    static final Map<String,Integer> styleClassMap = new HashMap<>(64);\n-\n-    static final List<StyleClass> styleClasses = new ArrayList<>();\n-\n-}\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/StyleClassSet.java","additions":0,"deletions":133,"binary":false,"changes":133,"status":"deleted"},{"patch":"@@ -1771,0 +1771,1 @@\n+            key.styleClasses = FixedCapacitySet.of(styleClasses.size());\n@@ -1776,1 +1777,1 @@\n-                key.styleClasses.add(StyleClassSet.getStyleClass(styleClass));\n+                key.styleClasses.add(styleClass);\n@@ -1782,5 +1783,1 @@\n-            if (cache != null) {\n-                \/\/ key will be reused, so clear the styleClasses for next use\n-                key.styleClasses.clear();\n-\n-            } else {\n+            if (cache == null) {\n@@ -2310,5 +2307,1 @@\n-        final StyleClassSet styleClasses;\n-\n-        private Key() {\n-            styleClasses = new StyleClassSet();\n-        }\n+        Set<String> styleClasses;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/StyleManager.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.util.Collections;\n+import java.util.HashMap;\n@@ -38,0 +38,1 @@\n+import java.util.Map;\n@@ -39,0 +40,1 @@\n+import java.util.stream.Collectors;\n@@ -40,0 +42,1 @@\n+import com.sun.javafx.css.FixedCapacitySet;\n@@ -42,1 +45,0 @@\n-import com.sun.javafx.css.StyleClassSet;\n@@ -76,0 +78,1 @@\n+     * @deprecated use {@link #getStyleClassNames()} instead\n@@ -77,0 +80,1 @@\n+    @Deprecated(forRemoval = true)\n@@ -78,0 +82,24 @@\n+        return List.copyOf(selectorStyleClassNames);\n+    }\n+\n+    \/**\n+     * Gets the immutable {@code Set} of {@code StyleClass}es of the {@code Selector}.\n+     * @return the {@code Set} of {@code StyleClass}es\n+     * @deprecated {@code StyleClass} wrapper has become unnecessary, use {@link #getStyleClassNames()} instead\n+     *\/\n+    @Deprecated(forRemoval = true)\n+    public Set<StyleClass> getStyleClassSet() {\n+        if (cachedStyleClasses == null) {\n+            cachedStyleClasses = getStyleClassNames().stream().map(SimpleSelector::getStyleClass).collect(Collectors.toUnmodifiableSet());\n+        }\n+\n+        return cachedStyleClasses;\n+    }\n+\n+    \/*\n+     * Copied from removed StyleClassSet to give StyleClasses a fixed index when\n+     * first encountered. No longer needed once StyleClass is removed.\n+     *\/\n+\n+    private static final Map<String, Integer> styleClassMap = new HashMap<>(64);\n+    private static final List<StyleClass> styleClasses = new ArrayList<>();\n@@ -79,1 +107,1 @@\n-        final List<String> names = new ArrayList<>();\n+    private static StyleClass getStyleClass(String styleClass) {\n@@ -81,3 +109,2 @@\n-        Iterator<StyleClass> iter = styleClassSet.iterator();\n-        while (iter.hasNext()) {\n-            names.add(iter.next().getStyleClassName());\n+        if (styleClass == null || styleClass.trim().isEmpty()) {\n+            throw new IllegalArgumentException(\"styleClass cannot be null or empty String\");\n@@ -86,1 +113,19 @@\n-        return Collections.unmodifiableList(names);\n+        StyleClass instance = null;\n+\n+        final Integer value = styleClassMap.get(styleClass);\n+        final int index = value != null ? value.intValue() : -1;\n+\n+        final int size = styleClasses.size();\n+        assert index < size;\n+\n+        if (index != -1 && index < size) {\n+            instance = styleClasses.get(index);\n+        }\n+\n+        if (instance == null) {\n+            instance = new StyleClass(styleClass, size);\n+            styleClasses.add(instance);\n+            styleClassMap.put(styleClass, Integer.valueOf(size));\n+        }\n+\n+        return instance;\n@@ -90,2 +135,4 @@\n-     * Gets the immutable {@code Set} of {@code StyleClass}es of the {@code Selector}.\n-     * @return the {@code Set} of {@code StyleClass}es\n+     * Gets the immutable {@code Set} of style class names of this {@code Selector}.\n+     *\n+     * @return a set of style class names, never {@code null}, or contains {@code null}s but can be empty\n+     * @since 23\n@@ -93,2 +140,2 @@\n-    public Set<StyleClass> getStyleClassSet() {\n-        return styleClassSet;\n+    public Set<String> getStyleClassNames() {\n+        return selectorStyleClassNames;\n@@ -100,2 +147,6 @@\n-    private final Set<StyleClass> styleClassSet;\n-    private final Set<StyleClass> unwrappedStyleClassSet;\n+    private final FixedCapacitySet<String> selectorStyleClassNames;\n+\n+    \/**\n+     * Cache to avoid having to recreate this set on each call.\n+     *\/\n+    private transient Set<StyleClass> cachedStyleClasses;\n@@ -152,11 +203,2 @@\n-        this.unwrappedStyleClassSet = new StyleClassSet();\n-\n-        if (styleClasses != null) {\n-            for (int n = 0; n < styleClasses.size(); n++) {\n-\n-                final String styleClassName = styleClasses.get(n);\n-                if (styleClassName == null || styleClassName.isEmpty()) continue;\n-\n-                unwrappedStyleClassSet.add(StyleClassSet.getStyleClass(styleClassName));\n-            }\n-        }\n+        this.selectorStyleClassNames = styleClasses == null ? FixedCapacitySet.of(0) : convertStyleClassNamesToSet(styleClasses);\n+        this.selectorStyleClassNames.freeze();  \/\/ turns it read only without having to wrap it\n@@ -164,2 +206,1 @@\n-        this.styleClassSet = Collections.unmodifiableSet(unwrappedStyleClassSet);\n-        this.matchOnStyleClass = (this.styleClassSet.size() > 0);\n+        this.matchOnStyleClass = (this.selectorStyleClassNames.size() > 0);\n@@ -195,0 +236,16 @@\n+    private FixedCapacitySet<String> convertStyleClassNamesToSet(List<String> styleClasses) {\n+        FixedCapacitySet<String> scs = FixedCapacitySet.of(styleClasses.size());\n+\n+        for (int n = 0, nMax = styleClasses.size(); n < nMax; n++) {\n+            String styleClassName = styleClasses.get(n);\n+\n+            if (styleClassName == null || styleClassName.isEmpty()) {\n+                continue;\n+            }\n+\n+            scs.add(styleClassName);\n+        }\n+\n+        return scs;\n+    }\n+\n@@ -197,1 +254,1 @@\n-        int styleClassCount = styleClassSet.size();\n+        int styleClassCount = selectorStyleClassNames.size();\n@@ -236,10 +293,2 @@\n-\n-            final StyleClassSet otherStyleClassSet = new StyleClassSet();\n-            final List<String> styleClasses = styleable.getStyleClass();\n-            for(int n=0, nMax = styleClasses.size(); n<nMax; n++) {\n-\n-                final String styleClassName = styleClasses.get(n);\n-                if (styleClassName == null || styleClassName.isEmpty()) continue;\n-\n-                final StyleClass styleClass = StyleClassSet.getStyleClass(styleClassName);\n-                otherStyleClassSet.add(styleClass);\n+            if (!matchesStyleClasses(styleable.getStyleClass())) {\n+                return false;\n@@ -247,3 +296,0 @@\n-\n-            boolean styleClassMatch = matchStyleClasses(otherStyleClassSet);\n-            if (!styleClassMatch) return false;\n@@ -292,3 +338,12 @@\n-    private boolean matchStyleClasses(StyleClassSet otherStyleClasses) {\n-        \/\/ checks against unwrapped version so BitSet can do its special casing for performance\n-        return otherStyleClasses.containsAll(unwrappedStyleClassSet);\n+    private boolean matchesStyleClasses(List<String> styleClassNames) {\n+\n+        \/*\n+         * Exit early if the input list is too small to possibly match all the styles\n+         * of this selector:\n+         *\/\n+\n+        if (styleClassNames.size() < selectorStyleClassNames.size()) {\n+            return false;\n+        }\n+\n+        return selectorStyleClassNames.isSuperSetOf(styleClassNames);\n@@ -311,1 +366,1 @@\n-        if (this.styleClassSet.equals(other.styleClassSet) == false) {\n+        if (this.selectorStyleClassNames.equals(other.selectorStyleClassNames) == false) {\n@@ -326,2 +381,2 @@\n-        hash = 31 * (hash + styleClassSet.hashCode());\n-        hash = 31 * (hash + styleClassSet.hashCode());\n+        hash = 31 * (hash + selectorStyleClassNames.hashCode());\n+        hash = 31 * (hash + selectorStyleClassNames.hashCode());\n@@ -339,1 +394,1 @@\n-        Iterator<StyleClass> iter1 = styleClassSet.iterator();\n+        Iterator<String> iter1 = selectorStyleClassNames.iterator();\n@@ -341,2 +396,2 @@\n-            final StyleClass styleClass = iter1.next();\n-            sbuf.append('.').append(styleClass.getStyleClassName());\n+            final String styleClass = iter1.next();\n+            sbuf.append('.').append(styleClass);\n@@ -362,2 +417,2 @@\n-        os.writeShort(styleClassSet.size());\n-        Iterator<StyleClass> iter1 = styleClassSet.iterator();\n+        os.writeShort(selectorStyleClassNames.size());\n+        Iterator<String> iter1 = selectorStyleClassNames.iterator();\n@@ -365,2 +420,2 @@\n-            final StyleClass sc = iter1.next();\n-            os.writeShort(stringStore.addString(sc.getStyleClassName()));\n+            final String sc = iter1.next();\n+            os.writeShort(stringStore.addString(sc));\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/SimpleSelector.java","additions":108,"deletions":53,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @deprecated for removal\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import com.sun.javafx.css.PseudoClassStateShim;\n-import com.sun.javafx.css.StyleClassSet;\n@@ -45,1 +43,0 @@\n-import javafx.css.StyleClass;\n@@ -144,19 +141,20 @@\n-    @Test\n-    void twoNonEmptyBitSetsWithSamePatternAndSizeShouldNotBeConsideredEqualsWhenElementTypesAreDifferent() {\n-        StyleClassSet set1 = new StyleClassSet();\n-        PseudoClassState set2 = new PseudoClassState();\n-\n-        PseudoClass pseudoClass = PseudoClass.getPseudoClass(\"abc\");\n-\n-        int index = PseudoClassStateShim.pseudoClassMap.get(pseudoClass.getPseudoClassName());\n-\n-        set1.add(new StyleClass(\"xyz\", index));  \/\/ no idea why this is public API, but I'll take it\n-        set2.add(pseudoClass);\n-\n-        \/*\n-         * The two sets above contain elements of different types (PseudoClass and StyleClass)\n-         * and therefore should never be equal, despite their bit pattern being the same:\n-         *\/\n-\n-        assertNotEquals(set1, set2);\n-    }\n+\/\/ This test can be reinstated if there ever is another implementation of com.sun.javafx.css.BitSet\n+\/\/    @Test\n+\/\/    void twoNonEmptyBitSetsWithSamePatternAndSizeShouldNotBeConsideredEqualsWhenElementTypesAreDifferent() {\n+\/\/        StyleClassSet set1 = new StyleClassSet();\n+\/\/        PseudoClassState set2 = new PseudoClassState();\n+\/\/\n+\/\/        PseudoClass pseudoClass = PseudoClass.getPseudoClass(\"abc\");\n+\/\/\n+\/\/        int index = PseudoClassStateShim.pseudoClassMap.get(pseudoClass.getPseudoClassName());\n+\/\/\n+\/\/        set1.add(new StyleClass(\"xyz\", index));  \/\/ no idea why this is public API, but I'll take it\n+\/\/        set2.add(pseudoClass);\n+\/\/\n+\/\/        \/*\n+\/\/         * The two sets above contain elements of different types (PseudoClass and StyleClass)\n+\/\/         * and therefore should never be equal, despite their bit pattern being the same:\n+\/\/         *\/\n+\/\/\n+\/\/        assertNotEquals(set1, set2);\n+\/\/    }\n@@ -166,2 +164,2 @@\n-        StyleClassSet set1 = new StyleClassSet();\n-        StyleClassSet set2 = new StyleClassSet();\n+        PseudoClassState set1 = new PseudoClassState();\n+        PseudoClassState set2 = new PseudoClassState();\n@@ -169,2 +167,2 @@\n-        set1.add(StyleClassSet.getStyleClass(\"abc\"));\n-        set2.add(StyleClassSet.getStyleClass(\"abc\"));\n+        set1.add(PseudoClassState.getPseudoClass(\"abc\"));\n+        set2.add(PseudoClassState.getPseudoClass(\"abc\"));\n@@ -176,1 +174,1 @@\n-            set1.add(StyleClassSet.getStyleClass(\"\" + i));\n+            set1.add(PseudoClassState.getPseudoClass(\"\" + i));\n@@ -182,1 +180,1 @@\n-            set1.remove(StyleClassSet.getStyleClass(\"\" + i));\n+            set1.remove(PseudoClassState.getPseudoClass(\"\" + i));\n@@ -196,2 +194,0 @@\n-        assertEquals(new StyleClassSet(), new PseudoClassState());\n-        assertEquals(new PseudoClassState(), new StyleClassSet());\n@@ -200,2 +196,0 @@\n-        assertEquals(Set.of(), new StyleClassSet());\n-        assertEquals(new StyleClassSet(), Set.of());\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/css\/BitSetTest.java","additions":26,"deletions":32,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-        List<Selector> matched = instance.match(simple.getId(), simple.getName(), simple.getStyleClassSet());\n+        List<Selector> matched = instance.match(simple.getId(), simple.getName(), simple.getStyleClassNames());\n@@ -239,1 +239,1 @@\n-        List<Selector> matched = instance.match(simple.getId(), simple.getName(), simple.getStyleClassSet());\n+        List<Selector> matched = instance.match(simple.getId(), simple.getName(), simple.getStyleClassNames());\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/css\/SelectorPartitioningTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}