{"files":[{"patch":"@@ -425,0 +425,2 @@\n+        private final int requestedCapacity;\n+        private final int mask;\n@@ -430,1 +432,13 @@\n-            this.elements = (T[]) new Object[capacity];\n+            this.requestedCapacity = capacity;\n+\n+            int shift = Integer.SIZE - Integer.numberOfLeadingZeros(capacity * 2 - capacity \/ 2);\n+\n+            \/*\n+             * The shift calculated ensures the elements array's size will be a power\n+             * of 2, and ensures that the load factor of this hash map will be roughly\n+             * between 0.3 and 0.7; high load factors are detrimental to performance,\n+             * while low load factors will consume more memory than necessary.\n+             *\/\n+\n+            this.elements = (T[]) new Object[1 << shift];\n+            this.mask = (1 << shift) - 1;\n@@ -515,1 +529,0 @@\n-            boolean reset = false;\n@@ -525,7 +538,1 @@\n-                    bucket = 0;\n-\n-                    if (reset) {\n-                        throw new IllegalStateException(\"set is full\");\n-                    }\n-\n-                    reset = true;\n+                    bucket = 0;  \/\/ there is no risk of this becoming an infinite loop as there is always spare capacity\n@@ -535,0 +542,4 @@\n+            if (size == requestedCapacity) {  \/\/ this check is \"late\" so that adding the same element to an already \"full\" set will correctly return \"false\"\n+                throw new IllegalStateException(\"set is full\");\n+            }\n+\n@@ -566,1 +577,3 @@\n-            return (o.hashCode() & 0x7fffffff) % elements.length;  \/\/ implicit null check here\n+            int h = o.hashCode();\n+\n+            return (h ^ (h >>> 16)) & mask;  \/\/ inspired by HashMap\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/FixedCapacitySet.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"}]}