{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"Utils.h\"\n@@ -143,1 +144,1 @@\n-    BOOL res = ::GetWindowRect(hwnd, r);\n+    BOOL res = ::GetExtendedFrameBounds(hwnd, r);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/BaseWnd.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -349,1 +349,1 @@\n-        ::GetWindowRect(hWnd, &rect1);\n+        ::GetExtendedFrameBounds(hWnd, &rect1);\n@@ -379,1 +379,1 @@\n-        ::GetWindowRect(hWnd, &rect1);\n+        ::GetExtendedFrameBounds(hWnd, &rect1);\n@@ -456,1 +456,1 @@\n-            ::GetWindowRect(hWnd, &rect);\n+            ::GetWindowRect(hWnd, &rect); \/\/ no point in calling GetExtendedFrameBounds() for a transparent window\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassView.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,15 +66,0 @@\n-namespace\n-{\n-    BOOL GetExtendedFrameBounds(HWND hwnd, RECT* r) {\n-        if (r == NULL) {\n-            return FALSE;\n-        }\n-\n-        if (FAILED(::DwmGetWindowAttribute(hwnd, DWMWA_EXTENDED_FRAME_BOUNDS, r, sizeof(RECT)))) {\n-            return ::GetWindowRect(hwnd, r);\n-        }\n-\n-        return TRUE;\n-    }\n-}\n-\n@@ -750,0 +735,3 @@\n+    RECT wBounds = {};\n+    ::GetWindowRect(hWnd, &wBounds);\n+\n@@ -751,2 +739,0 @@\n-        RECT wBounds;\n-        ::GetWindowRect(hWnd, &wBounds);\n@@ -763,0 +749,18 @@\n+    \/\/ pWinPos holds the full window rect, but we need to convert it to the visible frame rect\n+    \/\/ because that's what we pass to JavaFX in the next JNI upcall. In JavaFX, we always reason\n+    \/\/ about the visual bounds of the window, not including the invisible resize\/shadow areas.\n+    RECT extBounds = {};\n+    ::GetExtendedFrameBounds(hWnd, &extBounds);\n+\n+    RECT extInsets = {\n+        extBounds.left - wBounds.left,\n+        extBounds.top - wBounds.top,\n+        wBounds.right - extBounds.right,\n+        wBounds.bottom - extBounds.bottom\n+    };\n+\n+    pWinPos->x += extInsets.left;\n+    pWinPos->y += extInsets.top;\n+    pWinPos->cx -= extInsets.left + extInsets.right;\n+    pWinPos->cy -= extInsets.top + extInsets.bottom;\n+\n@@ -809,0 +813,7 @@\n+\n+    \/\/ pWinPos currently holds the visible frame rect; we need to convert it back to the\n+    \/\/ full window rect because that's what Windows expects in the WINDOWPOS structure.\n+    pWinPos->x -= extInsets.left;\n+    pWinPos->y -= extInsets.top;\n+    pWinPos->cx += extInsets.left + extInsets.right;\n+    pWinPos->cy += extInsets.top + extInsets.bottom;;\n@@ -948,1 +959,1 @@\n-        if (m_isResizable && ::GetWindowRect(GetHWND(), &windowRect) && y < windowRect.top + topBorderHeight) {\n+        if (m_isResizable && ::GetExtendedFrameBounds(GetHWND(), &windowRect) && y < windowRect.top + topBorderHeight) {\n@@ -1211,0 +1222,2 @@\n+    \/\/ We use GetWindowRect() instead of GetExtendedFrameBounds() because we simply pass\n+    \/\/ the bounds back to SetWindowPos() when we exit full-screen mode.\n@@ -1811,1 +1824,1 @@\n-        if (::GetCursorPos(&anchor) && ::GetWindowRect(hWnd, &wRect)) {\n+        if (::GetCursorPos(&anchor) && ::GetExtendedFrameBounds(hWnd, &wRect)) {\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassWindow.cpp","additions":32,"deletions":19,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include <shellscalingapi.h> \/\/ for PROCESS_DPI_AWARENESS\n@@ -110,0 +111,170 @@\n+\/*\n+ * Returns the visible window bounds (excluding the DWM shadow \/ invisible resize borders) in the same\n+ * coordinate space that the rest of Glass expects: logical coordinates in the caller's DPI-awareness space.\n+ *\n+ * While DwmGetWindowAttribute(DWMWA_EXTENDED_FRAME_BOUNDS) reports the visible frame bounds in physical\n+ * coordinates (it is not DPI-virtualized for the caller), GetWindowRect() returns the window rectangle\n+ * in the caller's DPI-awareness space. If the caller is DPI-unaware or system-DPI-aware, Windows may\n+ * DPI-virtualize the returned coordinates.\n+ *\n+ * It is possible (though uncommon) for the JVM to run in a DPI-unaware or system-DPI-aware context.\n+ * For example, the JVM may be hosted in a DPI-unaware process, or the launcher (java.exe) may be forced\n+ * into DPI-unaware mode via compatibility settings (as of JDK9+, java.exe has an embedded manifest that\n+ * declares DPI awareness that can not be downgraded by code).\n+ *\n+ * If we cannot reliably map the visible window bounds into the caller's coordinate space, we fall back to\n+ * GetWindowRect() rather than risk returning incorrectly mapped bounds.\n+ *\/\n+BOOL GetExtendedFrameBounds(HWND hwnd, RECT* r) {\n+\n+    struct impl_t {\n+        typedef HRESULT WINAPI FnGetProcessDpiAwareness(HANDLE, PROCESS_DPI_AWARENESS*);\n+        typedef DPI_AWARENESS_CONTEXT WINAPI FnSetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT);\n+        typedef DPI_AWARENESS_CONTEXT WINAPI FnGetThreadDpiAwarenessContext(VOID);\n+\n+        impl_t() {\n+            HMODULE hModule = GetModuleHandleW(L\"user32.dll\"); \/\/ user32 is already loaded\n+\n+            pGetThreadDpiAwarenessContext = reinterpret_cast<FnGetThreadDpiAwarenessContext*>(\n+                GetProcAddress(hModule, \"GetThreadDpiAwarenessContext\"));\n+\n+            pSetThreadDpiAwarenessContext = reinterpret_cast<FnSetThreadDpiAwarenessContext*>(\n+                GetProcAddress(hModule, \"SetThreadDpiAwarenessContext\"));\n+\n+            \/\/ Only load GetProcessDpiAwareness if GetThreadDpiAwarenessContext is not available (pre-Win10).\n+            if (!pGetThreadDpiAwarenessContext) {\n+                wchar_t path[MAX_PATH];\n+                wchar_t file[MAX_PATH];\n+\n+                UINT pathSize = sizeof(path) \/ sizeof(wchar_t);\n+                UINT rval = GetSystemDirectoryW(path, pathSize);\n+                if (rval == 0 || rval >= pathSize) {\n+                    fprintf(stderr, \"BaseWnd: Failed to get system directory\");\n+                    return;\n+                }\n+\n+                HMODULE hModule;\n+                memcpy_s(file, sizeof(file), path, sizeof(path));\n+                if (wcscat_s(file, MAX_PATH-1, L\"\\\\shcore.dll\") != 0 || !(hModule = LoadLibraryW(file))) {\n+                    fprintf(stderr, \"BaseWnd: Failed to load shcore.dll\");\n+                    return;\n+                }\n+\n+                pGetProcessDpiAwareness = reinterpret_cast<FnGetProcessDpiAwareness*>(\n+                    GetProcAddress(hModule, \"GetProcessDpiAwareness\"));\n+            }\n+        }\n+\n+        FnGetProcessDpiAwareness* pGetProcessDpiAwareness = NULL;\n+        FnGetThreadDpiAwarenessContext* pGetThreadDpiAwarenessContext = NULL;\n+        FnSetThreadDpiAwarenessContext* pSetThreadDpiAwarenessContext = NULL;\n+\n+        \/*\n+         * We can only safely skip mapping when we know the current process is per-monitor DPI aware.\n+         * In that case, caller-space coordinates are already physical pixels, matching DWMWA_EXTENDED_FRAME_BOUNDS.\n+         * If we can't prove that we're PM-aware, we don't skip mapping.\n+         *\/\n+        BOOL canSkipMapping() const {\n+            \/\/ Supported on Windows 10+\n+            if (pGetThreadDpiAwarenessContext) {\n+                DPI_AWARENESS_CONTEXT currentAwareness = pGetThreadDpiAwarenessContext();\n+\n+                return currentAwareness == DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE ||\n+                       currentAwareness == DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2;\n+            }\n+\n+            \/\/ Supported on Windows 8.1+\n+            PROCESS_DPI_AWARENESS awareness;\n+            if (pGetProcessDpiAwareness && SUCCEEDED(pGetProcessDpiAwareness(NULL, &awareness))) {\n+                return awareness == PROCESS_PER_MONITOR_DPI_AWARE;\n+            }\n+\n+            return FALSE;\n+        }\n+\n+        \/*\n+         * We sample GetWindowRect() in the current caller context (\"callerBounds\") and again while temporarily\n+         * switching the thread to a per-monitor aware context (\"physBounds\"). From these two rectangles we\n+         * derive an affine transform that maps physical pixels into the caller's virtualized coordinate space.\n+         *\/\n+        BOOL mapToCallerSpace(HWND hwnd, const RECT& extBounds, RECT* r) const {\n+            if (!pSetThreadDpiAwarenessContext) {\n+                return FALSE;\n+            }\n+\n+            \/\/ callerBounds are in caller-space, and may be DPI-virtualized\n+            RECT callerBounds = {};\n+            if (!GetWindowRect(hwnd, &callerBounds)) {\n+                return FALSE;\n+            }\n+\n+            \/\/ Switch thread to per-monitor DPI awareness to obtain non-virtualized (\"physical\") bounds.\n+            DPI_AWARENESS_CONTEXT oldAwareness =\n+                pSetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);\n+\n+            if (!oldAwareness) {\n+                oldAwareness = pSetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE);\n+            }\n+\n+            RECT physBounds = {};\n+            BOOL res = GetWindowRect(hwnd, &physBounds);\n+\n+            \/\/ If SetThreadDpiAwarenessContext failed, oldAwareness will be NULL and physBounds is not a\n+            \/\/ reliable physical baseline; return to the fallback path.\n+            if (!oldAwareness) {\n+                return FALSE;\n+            }\n+\n+            \/\/ Switch thread back to the original DPI awareness context.\n+            pSetThreadDpiAwarenessContext(oldAwareness);\n+\n+            if (!res) {\n+                return FALSE;\n+            }\n+\n+            \/\/ Derive an affine mapping from physical space to caller space:\n+            int physW = physBounds.right - physBounds.left;\n+            int physH = physBounds.bottom - physBounds.top;\n+            int callerW = callerBounds.right - callerBounds.left;\n+            int callerH = callerBounds.bottom - callerBounds.top;\n+\n+            if (physW == 0 || physH == 0) {\n+                *r = callerBounds;\n+                return TRUE;\n+            }\n+\n+            double sx = double(callerW) \/ double(physW);\n+            double sy = double(callerH) \/ double(physH);\n+            double ox = double(callerBounds.left) - double(physBounds.left) * sx;\n+            double oy = double(callerBounds.top) - double(physBounds.top) * sy;\n+\n+            \/\/ Apply the mapping to the extended frame bounds to produce caller-space coordinates.\n+            r->left = (LONG)llround(double(extBounds.left) * sx + ox);\n+            r->top = (LONG)llround(double(extBounds.top) * sy + oy);\n+            r->right = (LONG)llround(double(extBounds.right) * sx + ox);\n+            r->bottom = (LONG)llround(double(extBounds.bottom) * sy + oy);\n+            return TRUE;\n+        }\n+    } static const impl;\n+\n+    if (r == NULL) {\n+        return FALSE;\n+    }\n+\n+    RECT extBounds = {};\n+    if (FAILED(DwmGetWindowAttribute(hwnd, DWMWA_EXTENDED_FRAME_BOUNDS, &extBounds, sizeof(extBounds)))) {\n+        return GetWindowRect(hwnd, r);\n+    }\n+\n+    if (impl.canSkipMapping()) {\n+        *r = extBounds;\n+        return TRUE;\n+    }\n+\n+    if (impl.mapToCallerSpace(hwnd, extBounds, r)) {\n+        return TRUE;\n+    }\n+\n+    return GetWindowRect(hwnd, r);\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/Utils.cpp","additions":172,"deletions":1,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+BOOL GetExtendedFrameBounds(HWND, RECT*);\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/Utils.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}