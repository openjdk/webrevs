{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"Utils.h\"\n@@ -143,1 +144,1 @@\n-    BOOL res = ::GetWindowRect(hwnd, r);\n+    BOOL res = ::GetExtendedFrameBounds(hwnd, r);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/BaseWnd.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -349,1 +349,1 @@\n-        ::GetWindowRect(hWnd, &rect1);\n+        ::GetExtendedFrameBounds(hWnd, &rect1);\n@@ -379,1 +379,1 @@\n-        ::GetWindowRect(hWnd, &rect1);\n+        ::GetExtendedFrameBounds(hWnd, &rect1);\n@@ -456,1 +456,1 @@\n-            ::GetWindowRect(hWnd, &rect);\n+            ::GetWindowRect(hWnd, &rect); \/\/ no point in calling GetExtendedFrameBounds() for a transparent window\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassView.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -327,2 +327,2 @@\n-                HandleMoveEvent(NULL);\n-                HandleSizeEvent(com_sun_glass_events_WindowEvent_RESIZE, NULL);\n+                HandleMoveEvent();\n+                HandleSizeEvent(com_sun_glass_events_WindowEvent_RESIZE);\n@@ -359,1 +359,1 @@\n-                        HandleSizeEvent(com_sun_glass_events_WindowEvent_RESTORE, NULL);\n+                        HandleSizeEvent(com_sun_glass_events_WindowEvent_RESTORE);\n@@ -362,1 +362,1 @@\n-                        HandleSizeEvent(com_sun_glass_events_WindowEvent_RESIZE, NULL);\n+                        HandleSizeEvent(com_sun_glass_events_WindowEvent_RESIZE);\n@@ -366,1 +366,1 @@\n-                    HandleSizeEvent(com_sun_glass_events_WindowEvent_MINIMIZE, NULL);\n+                    HandleSizeEvent(com_sun_glass_events_WindowEvent_MINIMIZE);\n@@ -370,1 +370,1 @@\n-                    HandleSizeEvent(com_sun_glass_events_WindowEvent_MAXIMIZE, NULL);\n+                    HandleSizeEvent(com_sun_glass_events_WindowEvent_MAXIMIZE);\n@@ -390,1 +390,1 @@\n-                HandleMoveEvent(NULL);\n+                HandleMoveEvent();\n@@ -445,0 +445,7 @@\n+                int extraW = 0, extraH = 0;\n+                RECT shadowBounds, extBounds;\n+                if (GetWindowRect(GetHWND(), &shadowBounds) && GetExtendedFrameBounds(GetHWND(), &extBounds)) {\n+                    extraW = (extBounds.left - shadowBounds.left) + (shadowBounds.right - extBounds.right);\n+                    extraH = (extBounds.top - shadowBounds.top) + (shadowBounds.bottom - extBounds.bottom);\n+                }\n+\n@@ -447,1 +454,1 @@\n-                    info->ptMinTrackSize.x = m_minSize.x;\n+                    info->ptMinTrackSize.x = m_minSize.x + extraW;\n@@ -450,1 +457,1 @@\n-                    info->ptMinTrackSize.y = m_minSize.y;\n+                    info->ptMinTrackSize.y = m_minSize.y + extraH;\n@@ -453,1 +460,1 @@\n-                    info->ptMaxTrackSize.x = m_maxSize.x;\n+                    info->ptMaxTrackSize.x = m_maxSize.x + extraW;\n@@ -456,1 +463,1 @@\n-                    info->ptMaxTrackSize.y = m_maxSize.y;\n+                    info->ptMaxTrackSize.y = m_maxSize.y + extraH;\n@@ -832,0 +839,3 @@\n+    RECT wBounds = {};\n+    ::GetWindowRect(hWnd, &wBounds);\n+\n@@ -833,2 +843,0 @@\n-        RECT wBounds;\n-        ::GetWindowRect(hWnd, &wBounds);\n@@ -845,0 +853,18 @@\n+    \/\/ pWinPos holds the full window rect, but we need to convert it to the visible frame rect\n+    \/\/ because that's what we pass to JavaFX in the next JNI upcall. In JavaFX, we always reason\n+    \/\/ about the visual bounds of the window, not including the invisible resize\/shadow areas.\n+    RECT extBounds = {};\n+    ::GetExtendedFrameBounds(hWnd, &extBounds);\n+\n+    RECT extInsets = {\n+        extBounds.left - wBounds.left,\n+        extBounds.top - wBounds.top,\n+        wBounds.right - extBounds.right,\n+        wBounds.bottom - extBounds.bottom\n+    };\n+\n+    pWinPos->x += extInsets.left;\n+    pWinPos->y += extInsets.top;\n+    pWinPos->cx -= extInsets.left + extInsets.right;\n+    pWinPos->cy -= extInsets.top + extInsets.bottom;\n+\n@@ -891,0 +917,7 @@\n+\n+    \/\/ pWinPos currently holds the visible frame rect; we need to convert it back to the\n+    \/\/ full window rect because that's what Windows expects in the WINDOWPOS structure.\n+    pWinPos->x -= extInsets.left;\n+    pWinPos->y -= extInsets.top;\n+    pWinPos->cx += extInsets.left + extInsets.right;\n+    pWinPos->cy += extInsets.top + extInsets.bottom;;\n@@ -893,2 +926,1 @@\n-\/\/ if pRect == NULL => get position\/size by GetWindowRect\n-void GlassWindow::HandleMoveEvent(RECT *pRect)\n+void GlassWindow::HandleMoveEvent()\n@@ -897,1 +929,0 @@\n-\n@@ -899,4 +930,0 @@\n-    if (pRect == NULL) {\n-        ::GetWindowRect(GetHWND(), &r);\n-        pRect = &r;\n-    }\n@@ -904,2 +931,4 @@\n-    env->CallVoidMethod(m_grefThis, midNotifyMove, pRect->left, pRect->top);\n-    CheckAndClearException(env);\n+    if (GetExtendedFrameBounds(GetHWND(), &r)) {\n+        env->CallVoidMethod(m_grefThis, midNotifyMove, r.left, r.top);\n+        CheckAndClearException(env);\n+    }\n@@ -908,2 +937,1 @@\n-\/\/ if pRect == NULL => get position\/size by GetWindowRect\n-void GlassWindow::HandleSizeEvent(int type, RECT *pRect)\n+void GlassWindow::HandleSizeEvent(int type)\n@@ -912,1 +940,0 @@\n-\n@@ -914,4 +941,0 @@\n-    if (pRect == NULL) {\n-        ::GetWindowRect(GetHWND(), &r);\n-        pRect = &r;\n-    }\n@@ -919,3 +942,4 @@\n-    env->CallVoidMethod(m_grefThis, midNotifyResize,\n-                        type, pRect->right-pRect->left, pRect->bottom-pRect->top);\n-    CheckAndClearException(env);\n+    if (GetExtendedFrameBounds(GetHWND(), &r)) {\n+        env->CallVoidMethod(m_grefThis, midNotifyResize, type, r.right - r.left, r.bottom - r.top);\n+        CheckAndClearException(env);\n+    }\n@@ -1051,1 +1075,1 @@\n-        if (m_isResizable && ::GetWindowRect(GetHWND(), &windowRect) && y < windowRect.top + topBorderHeight) {\n+        if (m_isResizable && ::GetExtendedFrameBounds(GetHWND(), &windowRect) && y < windowRect.top + topBorderHeight) {\n@@ -1118,2 +1142,2 @@\n-    ::GetWindowRect(GetHWND(), &outer);\n-    ::GetClientRect(GetHWND(), &inner);\n+    \/\/ Clear last error because the return value of MapWindowPoints is not sufficient to detect failure\n+    SetLastError(0);\n@@ -1121,1 +1145,5 @@\n-    ::MapWindowPoints(GetHWND(), (HWND)NULL, (LPPOINT)&inner, (sizeof(RECT)\/sizeof(POINT)));\n+    if (!GetClientRect(GetHWND(), &inner) ||\n+            !GetExtendedFrameBounds(GetHWND(), &outer) ||\n+            (MapWindowPoints(GetHWND(), (HWND)NULL, (LPPOINT)&inner, 2) == 0 && GetLastError() != 0)) {\n+        return;\n+    }\n@@ -1318,0 +1346,2 @@\n+    \/\/ We use GetWindowRect() instead of GetExtendedFrameBounds() because we simply pass\n+    \/\/ the bounds back to SetWindowPos() when we exit full-screen mode.\n@@ -1918,1 +1948,1 @@\n-        if (::GetCursorPos(&anchor) && ::GetWindowRect(hWnd, &wRect)) {\n+        if (::GetCursorPos(&anchor) && ::GetExtendedFrameBounds(hWnd, &wRect)) {\n@@ -1968,2 +1998,9 @@\n-        RECT r;\n-        ::GetWindowRect(hWnd, &r);\n+        RECT shadowBounds = {};\n+        if (!GetWindowRect(hWnd, &shadowBounds)) {\n+            return;\n+        }\n+\n+        RECT extBounds = {};\n+        if (!GetExtendedFrameBounds(hWnd, &extBounds)) {\n+            return;\n+        }\n@@ -1971,2 +2008,2 @@\n-        int newX = jbool_to_bool(xSet) ? x : r.left;\n-        int newY = jbool_to_bool(ySet) ? y : r.top;\n+        int newX = jbool_to_bool(xSet) ? x : extBounds.left;\n+        int newY = jbool_to_bool(ySet) ? y : extBounds.top;\n@@ -1974,1 +2011,1 @@\n-                       cw > 0 ? cw + is.right + is.left : r.right - r.left;\n+                       cw > 0 ? cw + is.right + is.left : extBounds.right - extBounds.left;\n@@ -1976,1 +2013,1 @@\n-                       ch > 0 ? ch + is.bottom + is.top : r.bottom - r.top;\n+                       ch > 0 ? ch + is.bottom + is.top : extBounds.bottom - extBounds.top;\n@@ -1985,0 +2022,9 @@\n+        int shadowL = extBounds.left - shadowBounds.left;\n+        int shadowR = shadowBounds.right - extBounds.right;\n+        int shadowT = extBounds.top - shadowBounds.top;\n+        int shadowB = shadowBounds.bottom - extBounds.bottom;\n+        newX = newX - shadowL;\n+        newY = newY - shadowT;\n+        newW = newW + shadowL + shadowR;\n+        newH = newH + shadowT + shadowB;\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassWindow.cpp","additions":89,"deletions":43,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -131,1 +131,6 @@\n-    \/\/ -1 for x or y indicate the values aren't set\n+    \/\/ Minimum\/maximum sizes and insets are specified with respect to the extended frame bounds as returned by\n+    \/\/ DwmGetWindowAttribute(DWMWA_EXTENDED_FRAME_BOUNDS), not with respect to the window size as returned by\n+    \/\/ GetWindowRect(). Beginning with Windows 10, an invisible border is added to the windows's frame to make\n+    \/\/ it easier to grab the thin border. The extended frame bounds only include the visible borders, but not\n+    \/\/ the invisible resize border (GetWindowRect also includes the invisible resize border).\n+    \/\/ Specify -1 for x or y to indicate the values aren't set.\n@@ -135,0 +140,4 @@\n+    \/\/ NOTE: this is not a rectangle.\n+    \/\/ The left, top, right, and bottom components contain corresponding insets values.\n+    RECT m_insets;\n+\n@@ -160,4 +169,0 @@\n-    \/\/NOTE: this is not a rectangle. The left, top, right, and bottom\n-    \/\/components contain corresponding insets values.\n-    RECT m_insets;\n-\n@@ -189,1 +194,0 @@\n-    \/\/ if pRect == NULL => get position\/size by GetWindowRect\n@@ -191,3 +195,2 @@\n-    void HandleMoveEvent(RECT *pRect);\n-    \/\/ if pRect == NULL => get position\/size by GetWindowRect\n-    void HandleSizeEvent(int type, RECT *pRect);\n+    void HandleMoveEvent();\n+    void HandleSizeEvent(int type);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassWindow.h","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include <shellscalingapi.h> \/\/ for PROCESS_DPI_AWARENESS\n@@ -110,0 +111,169 @@\n+\/*\n+ * Returns the visible window bounds (excluding the DWM shadow \/ invisible resize borders) in the same\n+ * coordinate space that the rest of Glass expects: logical coordinates in the caller's DPI-awareness space.\n+ *\n+ * While DwmGetWindowAttribute(DWMWA_EXTENDED_FRAME_BOUNDS) reports the visible frame bounds in physical\n+ * coordinates (it is not DPI-virtualized for the caller), GetWindowRect() returns the window rectangle\n+ * in the caller's DPI-awareness space. If the caller is DPI-unaware or system-DPI-aware, Windows may\n+ * DPI-virtualize the returned coordinates.\n+ *\n+ * It is possible (though uncommon) for the JVM to run in a DPI-unaware or system-DPI-aware context.\n+ * For example, the JVM may be hosted in a DPI-unaware process, or the launcher (java.exe) may be forced\n+ * into DPI-unaware mode via compatibility settings (as of JDK9+, java.exe has an embedded manifest that\n+ * declares DPI awareness that can not be downgraded by code).\n+ *\n+ * If we cannot reliably map the visible window bounds into the caller's coordinate space, we fall back to\n+ * GetWindowRect() rather than risk returning incorrectly mapped bounds.\n+ *\/\n+BOOL GetExtendedFrameBounds(HWND hwnd, RECT* r) {\n+\n+    struct impl_t {\n+        typedef HRESULT WINAPI FnGetProcessDpiAwareness(HANDLE, PROCESS_DPI_AWARENESS*);\n+        typedef DPI_AWARENESS_CONTEXT WINAPI FnSetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT);\n+        typedef DPI_AWARENESS_CONTEXT WINAPI FnGetThreadDpiAwarenessContext(VOID);\n+\n+        impl_t() {\n+            HMODULE hModule = GetModuleHandleW(L\"user32.dll\"); \/\/ user32 is already loaded\n+\n+            pGetThreadDpiAwarenessContext = reinterpret_cast<FnGetThreadDpiAwarenessContext*>(\n+                GetProcAddress(hModule, \"GetThreadDpiAwarenessContext\"));\n+\n+            pSetThreadDpiAwarenessContext = reinterpret_cast<FnSetThreadDpiAwarenessContext*>(\n+                GetProcAddress(hModule, \"SetThreadDpiAwarenessContext\"));\n+\n+            \/\/ Only load GetProcessDpiAwareness if GetThreadDpiAwarenessContext is not available (pre-Win10).\n+            if (!pGetThreadDpiAwarenessContext) {\n+                wchar_t path[MAX_PATH];\n+                wchar_t file[MAX_PATH];\n+\n+                UINT pathSize = sizeof(path) \/ sizeof(wchar_t);\n+                UINT rval = GetSystemDirectoryW(path, pathSize);\n+                if (rval == 0 || rval >= pathSize) {\n+                    fprintf(stderr, \"GetExtendedFrameBounds: Failed to get system directory\");\n+                    return;\n+                }\n+\n+                HMODULE hModule;\n+                memcpy_s(file, sizeof(file), path, sizeof(path));\n+                if (wcscat_s(file, MAX_PATH-1, L\"\\\\shcore.dll\") != 0 || !(hModule = LoadLibraryW(file))) {\n+                    fprintf(stderr, \"GetExtendedFrameBounds: Failed to load shcore.dll\");\n+                    return;\n+                }\n+\n+                pGetProcessDpiAwareness = reinterpret_cast<FnGetProcessDpiAwareness*>(\n+                    GetProcAddress(hModule, \"GetProcessDpiAwareness\"));\n+            }\n+        }\n+\n+        FnGetProcessDpiAwareness* pGetProcessDpiAwareness = NULL;\n+        FnGetThreadDpiAwarenessContext* pGetThreadDpiAwarenessContext = NULL;\n+        FnSetThreadDpiAwarenessContext* pSetThreadDpiAwarenessContext = NULL;\n+\n+        \/*\n+         * We can only safely skip mapping when we know the current process is per-monitor DPI aware.\n+         * In that case, caller-space coordinates are already physical pixels, matching DWMWA_EXTENDED_FRAME_BOUNDS.\n+         * If we can't prove that we're PM-aware, we don't skip mapping.\n+         *\/\n+        BOOL canSkipMapping() const {\n+            \/\/ Supported on Windows 10+\n+            if (pGetThreadDpiAwarenessContext) {\n+                DPI_AWARENESS_CONTEXT currentAwareness = pGetThreadDpiAwarenessContext();\n+\n+                return currentAwareness == DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE ||\n+                       currentAwareness == DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2;\n+            }\n+\n+            \/\/ Supported on Windows 8.1+\n+            PROCESS_DPI_AWARENESS awareness;\n+            if (pGetProcessDpiAwareness && SUCCEEDED(pGetProcessDpiAwareness(NULL, &awareness))) {\n+                return awareness == PROCESS_PER_MONITOR_DPI_AWARE;\n+            }\n+\n+            return FALSE;\n+        }\n+\n+        \/*\n+         * We sample GetWindowRect() in the current caller context (\"callerBounds\") and again while temporarily\n+         * switching the thread to a per-monitor aware context (\"physBounds\"). From these two rectangles we\n+         * derive an affine transform that maps physical pixels into the caller's virtualized coordinate space.\n+         *\/\n+        BOOL mapToCallerSpace(HWND hwnd, const RECT& extBounds, RECT* r) const {\n+            if (!pSetThreadDpiAwarenessContext) {\n+                return FALSE;\n+            }\n+\n+            \/\/ callerBounds are in caller-space, and may be DPI-virtualized\n+            RECT callerBounds = {};\n+            if (!GetWindowRect(hwnd, &callerBounds)) {\n+                return FALSE;\n+            }\n+\n+            \/\/ Switch thread to per-monitor DPI awareness to obtain non-virtualized (\"physical\") bounds.\n+            DPI_AWARENESS_CONTEXT oldAwareness =\n+                pSetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);\n+\n+            if (!oldAwareness) {\n+                oldAwareness = pSetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE);\n+            }\n+\n+            \/\/ If SetThreadDpiAwarenessContext failed, oldAwareness will be NULL; return to the fallback path.\n+            if (!oldAwareness) {\n+                return FALSE;\n+            }\n+\n+            RECT physBounds = {};\n+            BOOL res = GetWindowRect(hwnd, &physBounds);\n+\n+            \/\/ Switch thread back to the original DPI awareness context.\n+            pSetThreadDpiAwarenessContext(oldAwareness);\n+\n+            if (!res) {\n+                return FALSE;\n+            }\n+\n+            \/\/ Derive an affine mapping from physical space to caller space:\n+            int physW = physBounds.right - physBounds.left;\n+            int physH = physBounds.bottom - physBounds.top;\n+            int callerW = callerBounds.right - callerBounds.left;\n+            int callerH = callerBounds.bottom - callerBounds.top;\n+\n+            if (physW == 0 || physH == 0) {\n+                *r = callerBounds;\n+                return TRUE;\n+            }\n+\n+            double sx = double(callerW) \/ double(physW);\n+            double sy = double(callerH) \/ double(physH);\n+            double ox = double(callerBounds.left) - double(physBounds.left) * sx;\n+            double oy = double(callerBounds.top) - double(physBounds.top) * sy;\n+\n+            \/\/ Apply the mapping to the extended frame bounds to produce caller-space coordinates.\n+            r->left = (LONG)llround(double(extBounds.left) * sx + ox);\n+            r->top = (LONG)llround(double(extBounds.top) * sy + oy);\n+            r->right = (LONG)llround(double(extBounds.right) * sx + ox);\n+            r->bottom = (LONG)llround(double(extBounds.bottom) * sy + oy);\n+            return TRUE;\n+        }\n+    } static const impl;\n+\n+    if (r == NULL) {\n+        return FALSE;\n+    }\n+\n+    RECT extBounds = {};\n+    if (FAILED(DwmGetWindowAttribute(hwnd, DWMWA_EXTENDED_FRAME_BOUNDS, &extBounds, sizeof(extBounds)))) {\n+        return GetWindowRect(hwnd, r);\n+    }\n+\n+    if (impl.canSkipMapping()) {\n+        *r = extBounds;\n+        return TRUE;\n+    }\n+\n+    if (impl.mapToCallerSpace(hwnd, extBounds, r)) {\n+        return TRUE;\n+    }\n+\n+    return GetWindowRect(hwnd, r);\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/Utils.cpp","additions":171,"deletions":1,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+BOOL GetExtendedFrameBounds(HWND, RECT*);\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/Utils.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}