{"files":[{"patch":"@@ -32,1 +32,0 @@\n-import java.util.ArrayList;\n@@ -34,0 +33,1 @@\n+import java.util.TreeSet;\n@@ -36,1 +36,0 @@\n-\n@@ -38,4 +37,0 @@\n-    private boolean isInPreeditMode = false;\n-    private final StringBuilder preedit = new StringBuilder();\n-    private ByteBuffer attributes;\n-    private int lastCaret;\n@@ -48,3 +43,1 @@\n-        if (imEnabled) {\n-            preedit.setLength(0);\n-        }\n+\n@@ -116,4 +109,2 @@\n-        if (imEnabled && isInPreeditMode) {\n-            \/\/ Discard any pre-edited text\n-            preedit.setLength(0);\n-            notifyInputMethod(preedit.toString(), null, null, null, 0, 0, 0);\n+        if (imEnabled) {\n+            enableInputMethodEventsImpl(ptr, true);\n@@ -123,2 +114,2 @@\n-    private void notifyPreeditMode(boolean enabled){\n-        isInPreeditMode = enabled;\n+    protected double[] notifyInputMethodCandidateRelativePosRequest(int offset) {\n+        return convertPosToRelative(super.notifyInputMethodCandidatePosRequest(offset));\n@@ -127,0 +118,4 @@\n+    private double[] convertPosToRelative(double[] pos) {\n+        var w = getWindow();\n+        pos[0] -= (pos[0] > 0) ? ((w.getX() + getX())) : 0;\n+        pos[1] -= (pos[1] > 0) ? ((w.getY() + getY())) : 0;\n@@ -128,11 +123,2 @@\n-    protected void notifyInputMethodDraw(String text, int first, int length, int caret, byte[] attr) {\n-        int[] boundary = null;\n-        byte[] values = null;\n-\n-        if (attributes == null ) {\n-            attributes = ByteBuffer.allocate(32);\n-        }\n-\n-        if (length > 0) {\n-            preedit.replace(first, first + length, \"\");\n-        }\n+        return pos;\n+    }\n@@ -140,2 +126,3 @@\n-        if (text != null) {\n-            preedit.insert(first, text);\n+    protected void notifyInputMethodLinux(String str, int commitLength, int cursor, byte attr) {\n+        if (commitLength > 0) {\n+            notifyInputMethod(str, null, null, null, commitLength, cursor, 0);\n@@ -143,56 +130,2 @@\n-            if (attr == null) {\n-                preedit.setLength(0);\n-            }\n-        }\n-\n-        if (attributes.capacity() < preedit.length()) {\n-            ByteBuffer tmp  = ByteBuffer.allocate((int) (preedit.length() * 1.5));\n-            tmp.put(attributes);\n-            attributes = tmp;\n-        }\n-\n-        attributes.limit(preedit.length());\n-\n-        if (attr != null && attributes.limit() >= (first + attr.length)) {\n-            attributes.position(first);\n-            attributes.put(attr);\n-        }\n-\n-        if (attributes.limit() > 0) {\n-            ArrayList<Integer> boundaryList = new ArrayList<>();\n-            ArrayList<Byte> valuesList = new ArrayList<>();\n-            attributes.rewind();\n-            byte lastAttribute = attributes.get();\n-\n-            boundaryList.add(0);\n-            valuesList.add(lastAttribute);\n-\n-            int i = 1;\n-            while (attributes.hasRemaining()) {\n-                byte a = attributes.get();\n-                if (lastAttribute != a) {\n-                    boundaryList.add(i);\n-                    valuesList.add(a);\n-                }\n-                lastAttribute = a;\n-                i++;\n-            }\n-\n-            boundaryList.add(attributes.limit());\n-\n-            boundary = new int[boundaryList.size()];\n-            i = 0;\n-            for (Integer e : boundaryList) {\n-                boundary[i++] = e;\n-            }\n-\n-            values = new byte[valuesList.size()];\n-            i = 0;\n-            for (Byte e: valuesList) {\n-                values[i++] = e;\n-            }\n-        }\n-\n-        notifyInputMethod(preedit.toString(), boundary, boundary, values, 0, caret, 0);\n-        lastCaret = caret;\n-    }\n+            int[] attBounds = new int[] { 0, str.length() };\n+            byte[] attValues = new byte[] { attr };\n@@ -200,15 +133,1 @@\n-    protected void notifyInputMethodCaret(int pos, int direction, int style) {\n-        switch (direction) {\n-            case 0: \/\/XIMForwardChar\n-                lastCaret += pos;\n-                break;\n-            case 1: \/\/XIMBackwardChar\n-                lastCaret -= pos;\n-                break;\n-            case 10: \/\/XIMAbsolute\n-                lastCaret = pos;\n-                break;\n-            default:\n-                \/\/TODO: as we don't know the text structure, we cannot compute the position\n-                \/\/ for other directions (like forward words, lines, etc...).\n-                \/\/ Luckily, vast majority of IM uses XIMAbsolute (10)\n+            notifyInputMethod(str, attBounds, attBounds, attValues, 0, cursor, 0);\n@@ -216,1 +135,0 @@\n-        notifyInputMethod(preedit.toString(), null, null, null, 0, lastCaret, 0);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkView.java","additions":18,"deletions":100,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-    if (ctx != NULL && ctx->hasIME() && ctx->filterIME(event)) {\n+    if ((event->type == GDK_KEY_PRESS || event->type == GDK_KEY_RELEASE) && ctx != NULL && ctx->filterIME(event)) {\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassApplication.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,4 +64,2 @@\n-jmethodID jViewNotifyInputMethod;\n-jmethodID jViewNotifyInputMethodDraw;\n-jmethodID jViewNotifyInputMethodCaret;\n-jmethodID jViewNotifyPreeditMode;\n+jmethodID jViewNotifyInputMethodLinux;\n+jmethodID jViewNotifyInputMethodCandidateRelativePosRequest;\n@@ -232,2 +230,0 @@\n-    jViewNotifyInputMethod = env->GetMethodID(clazz, \"notifyInputMethod\", \"(Ljava\/lang\/String;[I[I[BIII)V\");\n-    if (env->ExceptionCheck()) return JNI_ERR;\n@@ -241,3 +237,1 @@\n-    jViewNotifyInputMethodDraw = env->GetMethodID(clazz, \"notifyInputMethodDraw\", \"(Ljava\/lang\/String;III[B)V\");\n-    if (env->ExceptionCheck()) return JNI_ERR;\n-    jViewNotifyInputMethodCaret = env->GetMethodID(clazz, \"notifyInputMethodCaret\", \"(III)V\");\n+    jViewNotifyInputMethodLinux = env->GetMethodID(clazz, \"notifyInputMethodLinux\", \"(Ljava\/lang\/String;IIB)V\");\n@@ -245,1 +239,2 @@\n-    jViewNotifyPreeditMode = env->GetMethodID(clazz, \"notifyPreeditMode\", \"(Z)V\");\n+    jViewNotifyInputMethodCandidateRelativePosRequest\n+        = env->GetMethodID(clazz, \"notifyInputMethodCandidateRelativePosRequest\", \"(I)[D\");\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -176,4 +176,3 @@\n-    extern jmethodID jViewNotifyInputMethod; \/\/com.sun.glass.ui.View#notifyInputMethod (Ljava\/lang\/String;[I[I[BIII)V\n-    extern jmethodID jViewNotifyInputMethodDraw; \/\/com.sun.glass.ui.gtk.GtkView#notifyInputMethodDraw (Ljava\/lang\/String;III[B)V\n-    extern jmethodID jViewNotifyInputMethodCaret; \/\/com.sun.glass.ui.gtk.GtkView#notifyInputMethodCaret (III)V\n-    extern jmethodID jViewNotifyPreeditMode; \/\/com.sun.glass.ui.gtk.GtkView#notifyPreeditMode (Z)V\n+    extern jmethodID jViewNotifyInputMethodLinux; \/\/com.sun.glass.ui.View#notifyInputMethodLinux (Ljava\/lang\/String;IIB)V\n+    extern jmethodID jViewNotifyInputMethodCandidateRelativePosRequest; \/\/com.sun.glass.ui.gtk.GtkView#notifyInputMethodCandidateRelativePosRequest (I)[D\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.h","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    if (xim.enabled && xim.ic) {\n+    if (im_ctx.enabled && im_ctx.ctx) {\n@@ -143,1 +143,1 @@\n-            XSetICFocus(xim.ic);\n+            gtk_im_context_focus_in(im_ctx.ctx);\n@@ -145,1 +145,1 @@\n-            XUnsetICFocus(xim.ic);\n+            gtk_im_context_focus_out(im_ctx.ctx);\n@@ -462,16 +462,0 @@\n-    } else {\n-#ifdef GLASS_GTK2\n-        if (key == 0) {\n-            \/\/ Work around \"bug\" fixed in gtk-3.0:\n-            \/\/ http:\/\/mail.gnome.org\/archives\/commits-list\/2011-March\/msg06832.html\n-            switch (event->keyval) {\n-            case 0xFF08 \/* Backspace *\/: key =  '\\b';\n-            case 0xFF09 \/* Tab       *\/: key =  '\\t';\n-            case 0xFF0A \/* Linefeed  *\/: key =  '\\n';\n-            case 0xFF0B \/* Vert. Tab *\/: key =  '\\v';\n-            case 0xFF0D \/* Return    *\/: key =  '\\r';\n-            case 0xFF1B \/* Escape    *\/: key =  '\\033';\n-            case 0xFFFF \/* Delete    *\/: key =  '\\177';\n-            }\n-        }\n-#endif\n@@ -489,8 +473,0 @@\n-    if (jview) {\n-        if (press) {\n-            mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n-                    com_sun_glass_events_KeyEvent_PRESS,\n-                    glassKey,\n-                    jChars,\n-                    glassModifier);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n@@ -498,16 +474,20 @@\n-            if (jview && key > 0) { \/\/ TYPED events should only be sent for printable characters.\n-                mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n-                        com_sun_glass_events_KeyEvent_TYPED,\n-                        com_sun_glass_events_KeyEvent_VK_UNDEFINED,\n-                        jChars,\n-                        glassModifier);\n-                CHECK_JNI_EXCEPTION(mainEnv)\n-            }\n-        } else {\n-            mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n-                    com_sun_glass_events_KeyEvent_RELEASE,\n-                    glassKey,\n-                    jChars,\n-                    glassModifier);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n+    if (!jview) {\n+        return;\n+    }\n+\n+    mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n+            (press) ? com_sun_glass_events_KeyEvent_PRESS\n+                    : com_sun_glass_events_KeyEvent_RELEASE,\n+            glassKey,\n+            jChars,\n+            glassModifier);\n+    CHECK_JNI_EXCEPTION(mainEnv)\n+\n+    \/\/ jview is checked again because previous call might be an exit key\n+    if (press && key > 0 && jview) { \/\/ TYPED events should only be sent for printable characters.\n+        mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n+                com_sun_glass_events_KeyEvent_TYPED,\n+                com_sun_glass_events_KeyEvent_VK_UNDEFINED,\n+                jChars,\n+                glassModifier);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n@@ -660,9 +640,1 @@\n-    if (xim.ic) {\n-        XDestroyIC(xim.ic);\n-        xim.ic = NULL;\n-    }\n-    if (xim.im) {\n-        XCloseIM(xim.im);\n-        xim.im = NULL;\n-    }\n-\n+    disableIME();\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.cpp","additions":24,"deletions":52,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+    virtual void updateCaretPos() = 0;\n@@ -102,0 +103,3 @@\n+    virtual void setOnPreEdit(bool) = 0;\n+    virtual void commitIME(gchar *) = 0;\n+\n@@ -169,3 +173,2 @@\n-    struct _XIM {\n-        XIM im;\n-        XIC ic;\n+    struct ImContext {\n+        GtkIMContext *ctx;\n@@ -173,1 +176,3 @@\n-    } xim;\n+        bool on_preedit;\n+        bool send_keypress;\n+    } im_ctx;\n@@ -213,0 +218,3 @@\n+    void setOnPreEdit(bool);\n+    void commitIME(gchar *);\n+    void updateCaretPos();\n@@ -253,2 +261,0 @@\n-private:\n-    bool im_filter_keypress(GdkEventKey*);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include <com_sun_glass_events_KeyEvent.h>\n+\n@@ -29,0 +31,1 @@\n+#include \"glass_key.h\"\n@@ -30,5 +33,3 @@\n-#include <cstring>\n-#include <cstdlib>\n-\n-bool WindowContextBase::hasIME() {\n-    return xim.enabled;\n+static void on_preedit_start(GtkIMContext *im_context, gpointer user_data) {\n+    WindowContext *ctx = (WindowContext *) user_data;\n+    ctx->setOnPreEdit(true);\n@@ -37,16 +38,5 @@\n-static XKeyPressedEvent convert_event(GdkEventKey *event) {\n-    XKeyPressedEvent result;\n-    memset(&result, 0, sizeof (result));\n-\n-    result.type = (event->type == GDK_KEY_PRESS) ? KeyPress : KeyRelease;\n-    result.send_event = event->send_event;\n-    result.display = gdk_x11_display_get_xdisplay(gdk_window_get_display(event->window));\n-    result.window = result.subwindow = GDK_WINDOW_XID(event->window);\n-    result.root = GDK_WINDOW_XID(gdk_screen_get_root_window(glass_gdk_window_get_screen(event->window)));\n-    result.time = event->time;\n-    result.state = event->state;\n-    result.keycode = event->hardware_keycode;\n-    result.same_screen = True;\n-\n-    return result;\n-}\n+static void on_preedit_changed(GtkIMContext *im_context, gpointer user_data) {\n+    WindowContext *ctx = (WindowContext *) user_data;\n+    gchar *preedit_text;\n+    PangoAttrList* attrList;\n+    int cursor_pos;\n@@ -54,3 +44,2 @@\n-bool WindowContextBase::im_filter_keypress(GdkEventKey* event) {\n-    static size_t buf_len = 12;\n-    static char *buffer = NULL;\n+    gtk_im_context_get_preedit_string(im_context, &preedit_text, &attrList, &cursor_pos);\n+    ctx->updateCaretPos();\n@@ -58,3 +47,2 @@\n-    if (buffer == NULL) {\n-        buffer = (char*)malloc(buf_len * sizeof (char));\n-    }\n+    jstring jstr = mainEnv->NewStringUTF(preedit_text);\n+    EXCEPTION_OCCURED(mainEnv);\n@@ -62,5 +50,1 @@\n-    if (buffer == NULL) {\n-        \/\/ dont process the key event\n-        fprintf(stderr, \"malloc failed in im_filter_keypress\\n\");\n-        return false;\n-    }\n+    jsize slen = mainEnv->GetStringLength(jstr);\n@@ -68,48 +52,2 @@\n-    KeySym keysym;\n-    Status status;\n-    XKeyPressedEvent xevent = convert_event(event);\n-    if (XFilterEvent((XEvent*) & xevent, GDK_WINDOW_XID(gdk_window))) {\n-        return TRUE;\n-    }\n-\n-    if (event->type == GDK_KEY_RELEASE) {\n-        process_key(event);\n-        return TRUE;\n-    }\n-\n-    int len = Xutf8LookupString(xim.ic, &xevent, buffer, buf_len - 1, &keysym, &status);\n-    if (status == XBufferOverflow) {\n-        buf_len = len + 1;\n-        char *tmpBuffer = (char*)realloc(buffer, buf_len * sizeof (char));\n-        if (tmpBuffer == NULL) {\n-            SAFE_FREE(buffer);\n-            \/\/ dont process the key event\n-            fprintf(stderr, \"realloc failed in im_filter_keypress\\n\");\n-            return false;\n-        }\n-        buffer = tmpBuffer;\n-        len = Xutf8LookupString(xim.ic, &xevent, buffer, buf_len - 1,\n-                &keysym, &status);\n-    }\n-    switch (status) {\n-        case XLookupKeySym:\n-        case XLookupBoth:\n-            if (xevent.keycode) {\n-                \/\/process it as a normal key\n-                process_key(event);\n-                break;\n-            }\n-            \/\/ fall-through\n-        case XLookupChars:\n-            buffer[len] = 0;\n-            jstring str = mainEnv->NewStringUTF(buffer);\n-            EXCEPTION_OCCURED(mainEnv);\n-            jsize slen = mainEnv->GetStringLength(str);\n-            mainEnv->CallVoidMethod(jview,\n-                    jViewNotifyInputMethod,\n-                    str,\n-                    NULL, NULL, NULL,\n-                    slen,\n-                    slen,\n-                    0);\n-            LOG_EXCEPTION(mainEnv)\n+    PangoAttrIterator *iter = pango_attr_list_get_iterator(attrList);\n+    PangoAttribute *pangoAttr;\n@@ -117,0 +55,8 @@\n+    jbyte attr = com_sun_glass_ui_View_IME_ATTR_INPUT;\n+    do {\n+        if (pangoAttr = pango_attr_iterator_get(iter, PANGO_ATTR_BACKGROUND)) {\n+             attr = com_sun_glass_ui_View_IME_ATTR_TARGET_NOTCONVERTED;\n+             break;\n+        } else if ((pangoAttr = pango_attr_iterator_get(iter, PANGO_ATTR_UNDERLINE))\n+                && (((PangoAttrInt *)pangoAttr)->value == PANGO_UNDERLINE_SINGLE)) {\n+            attr = com_sun_glass_ui_View_IME_ATTR_CONVERTED;\n@@ -118,1 +64,15 @@\n-    }\n+        }\n+    } while (pango_attr_iterator_next(iter));\n+\n+    pango_attr_list_unref(attrList);\n+    pango_attr_iterator_destroy(iter);\n+    g_free(preedit_text);\n+\n+    mainEnv->CallVoidMethod(ctx->get_jview(),\n+            jViewNotifyInputMethodLinux,\n+            jstr,\n+            0,\n+            cursor_pos,\n+            attr);\n+    LOG_EXCEPTION(mainEnv)\n+}\n@@ -120,1 +80,3 @@\n-    return TRUE;\n+static void on_preedit_end(GtkIMContext *im_context, gpointer user_data) {\n+    WindowContext *ctx = (WindowContext *) user_data;\n+    ctx->setOnPreEdit(false);\n@@ -123,4 +85,4 @@\n-bool WindowContextBase::filterIME(GdkEvent * event) {\n-    if (!hasIME()) {\n-        return false;\n-    }\n+static void on_commit(GtkIMContext *im_context, gchar* str, gpointer user_data) {\n+    WindowContext *ctx = (WindowContext *) user_data;\n+    ctx->commitIME(str);\n+}\n@@ -128,6 +90,15 @@\n-    switch (event->type) {\n-        case GDK_KEY_PRESS:\n-        case GDK_KEY_RELEASE:\n-            return im_filter_keypress(reinterpret_cast<GdkEventKey*> (event));\n-        default:\n-            return FALSE;\n+void WindowContextBase::commitIME(gchar *str) {\n+    if (im_ctx.on_preedit) {\n+        jstring jstr = mainEnv->NewStringUTF(str);\n+        EXCEPTION_OCCURED(mainEnv);\n+        jsize slen = mainEnv->GetStringLength(jstr);\n+\n+        mainEnv->CallVoidMethod(jview,\n+                jViewNotifyInputMethodLinux,\n+                jstr,\n+                slen,\n+                slen,\n+                NULL);\n+        LOG_EXCEPTION(mainEnv)\n+    } else {\n+        im_ctx.send_keypress = true;\n@@ -137,9 +108,2 @@\n-\/\/Note: this function must return int, despite the fact it doesn't conform to XIMProc type.\n-\/\/ This is required in documentation of XIM\n-static int im_preedit_start(XIM im_xim, XPointer client, XPointer call) {\n-    (void)im_xim;\n-    (void)call;\n-\n-    mainEnv->CallVoidMethod((jobject) client, jViewNotifyPreeditMode, JNI_TRUE);\n-    CHECK_JNI_EXCEPTION_RET(mainEnv, -1);\n-    return -1; \/\/ No restrictions\n+bool WindowContextBase::hasIME() {\n+    return im_ctx.enabled;\n@@ -148,7 +112,4 @@\n-static void im_preedit_done(XIM im_xim, XPointer client, XPointer call) {\n-    (void)im_xim;\n-    (void)call;\n-\n-    mainEnv->CallVoidMethod((jobject) client, jViewNotifyPreeditMode, JNI_FALSE);\n-    CHECK_JNI_EXCEPTION(mainEnv);\n-}\n+bool WindowContextBase::filterIME(GdkEvent *event) {\n+    if (!hasIME()) {\n+        return false;\n+    }\n@@ -156,22 +117,1 @@\n-static void im_preedit_draw(XIM im_xim, XPointer client, XPointer call) {\n-    (void)im_xim;\n-    (void)call;\n-\n-    XIMPreeditDrawCallbackStruct *data = (XIMPreeditDrawCallbackStruct*) call;\n-    jstring text = NULL;\n-    jbyteArray attr = NULL;\n-\n-    if (data->text != NULL) {\n-        if (data->text->string.multi_byte) {\n-            if (data->text->encoding_is_wchar) {\n-                size_t csize = wcstombs(NULL, data->text->string.wide_char, 0);\n-                char *ctext = new char[csize + 1];\n-                wcstombs(ctext, data->text->string.wide_char, csize + 1);\n-                text = mainEnv->NewStringUTF(ctext);\n-                delete[] ctext;\n-                CHECK_JNI_EXCEPTION(mainEnv);\n-            } else {\n-                text = mainEnv->NewStringUTF(data->text->string.multi_byte);\n-                CHECK_JNI_EXCEPTION(mainEnv);\n-            }\n-        }\n+    bool filtered = gtk_im_context_filter_keypress(im_ctx.ctx, &event->key);\n@@ -179,18 +119,3 @@\n-        if (XIMFeedback* fb = data->text->feedback) {\n-            attr = mainEnv->NewByteArray(data->text->length);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-            jbyte v[data->text->length];\n-            for (int i = 0; i < data->text->length; i++) {\n-                if (fb[i] & XIMReverse) {\n-                    v[i] = com_sun_glass_ui_View_IME_ATTR_TARGET_NOTCONVERTED;\n-                } else if (fb[i] & XIMHighlight) {\n-                    v[i] = com_sun_glass_ui_View_IME_ATTR_TARGET_CONVERTED;\n-                } else if (fb[i] & XIMUnderline) {\n-                    v[i] = com_sun_glass_ui_View_IME_ATTR_CONVERTED;\n-                } else {\n-                    v[i] = com_sun_glass_ui_View_IME_ATTR_INPUT;\n-                }\n-            }\n-            mainEnv->SetByteArrayRegion(attr, 0, data->text->length, v);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n+    if (filtered && im_ctx.send_keypress) {\n+        process_key(&event->key);\n+        im_ctx.send_keypress = false;\n@@ -199,3 +124,1 @@\n-    mainEnv->CallVoidMethod((jobject)client, jViewNotifyInputMethodDraw,\n-            text, data->chg_first, data->chg_length, data->caret, attr);\n-    CHECK_JNI_EXCEPTION(mainEnv)\n+    return filtered;\n@@ -204,7 +127,2 @@\n-static void im_preedit_caret(XIM im_xim, XPointer client, XPointer call) {\n-    (void)im_xim;\n-\n-    XIMPreeditCaretCallbackStruct *data = (XIMPreeditCaretCallbackStruct*) call;\n-    mainEnv->CallVoidMethod((jobject)client, jViewNotifyInputMethodCaret,\n-            data->position, data->direction, data->style);\n-    CHECK_JNI_EXCEPTION(mainEnv)\n+void WindowContextBase::setOnPreEdit(bool preedit) {\n+    im_ctx.on_preedit = preedit;\n@@ -213,5 +131,2 @@\n-static XIMStyle get_best_supported_style(XIM im_xim)\n-{\n-    XIMStyles* styles;\n-    int i;\n-    XIMStyle result = 0;\n+void WindowContextBase::updateCaretPos() {\n+    double *nativePos;\n@@ -219,3 +134,3 @@\n-    if (XGetIMValues(im_xim, XNQueryInputStyle, &styles, NULL) != NULL) { \/\/ NULL means it's OK\n-        return 0;\n-    }\n+    jdoubleArray pos = (jdoubleArray)mainEnv->CallObjectMethod(get_jview(),\n+                                      jViewNotifyInputMethodCandidateRelativePosRequest,\n+                                      0);\n@@ -223,7 +138,1 @@\n-    for (i = 0; i < styles->count_styles; ++i) {\n-        if (styles->supported_styles[i] == (XIMPreeditCallbacks | XIMStatusNothing)\n-                || styles->supported_styles[i] == (XIMPreeditNothing | XIMStatusNothing)) {\n-            result = styles->supported_styles[i];\n-            break;\n-        }\n-    }\n+    nativePos = mainEnv->GetDoubleArrayElements(pos, NULL);\n@@ -231,1 +140,6 @@\n-    XFree(styles);\n+    GdkRectangle rect;\n+    if (nativePos) {\n+        rect.x = (int) nativePos[0];\n+        rect.y = (int) nativePos[1];\n+        rect.width = 0;\n+        rect.height = 0;\n@@ -233,1 +147,3 @@\n-    return result;\n+        mainEnv->ReleaseDoubleArrayElements(pos, nativePos, 0);\n+        gtk_im_context_set_cursor_location(im_ctx.ctx, &rect);\n+    }\n@@ -237,35 +153,2 @@\n-    Display *display = gdk_x11_display_get_xdisplay(gdk_window_get_display(gdk_window));\n-    if (xim.im == NULL || xim.ic == NULL) {\n-        xim.im = XOpenIM(display, NULL, NULL, NULL);\n-        if (xim.im == NULL) {\n-            return;\n-        }\n-\n-        XIMStyle styles = get_best_supported_style(xim.im);\n-        if (styles == 0) {\n-            return;\n-        }\n-\n-        XIMCallback startCallback = {(XPointer) jview, (XIMProc) (void *) im_preedit_start};\n-        XIMCallback doneCallback = {(XPointer) jview, im_preedit_done};\n-        XIMCallback drawCallback = {(XPointer) jview, im_preedit_draw};\n-        XIMCallback caretCallback = {(XPointer) jview, im_preedit_caret};\n-\n-        XVaNestedList list = XVaCreateNestedList(0,\n-                XNPreeditStartCallback, &startCallback,\n-                XNPreeditDoneCallback, &doneCallback,\n-                XNPreeditDrawCallback, &drawCallback,\n-                XNPreeditCaretCallback, &caretCallback,\n-                NULL);\n-\n-        xim.ic = XCreateIC(xim.im,\n-                XNInputStyle, styles,\n-                XNClientWindow, GDK_WINDOW_XID(gdk_window),\n-                XNPreeditAttributes, list,\n-                NULL);\n-\n-        XFree(list);\n-\n-        if (xim.ic == NULL) {\n-            return;\n-        }\n+    if (im_ctx.on_preedit) {\n+        gtk_im_context_focus_out(im_ctx.ctx);\n@@ -274,2 +157,7 @@\n-    if (xim.enabled) { \/\/called when changed focus to different input\n-        XmbResetIC(xim.ic);\n+    if (!im_ctx.enabled) {\n+        im_ctx.ctx = gtk_im_multicontext_new();\n+        gtk_im_context_set_client_window(GTK_IM_CONTEXT(im_ctx.ctx), gdk_window);\n+        g_signal_connect(im_ctx.ctx, \"preedit-start\", G_CALLBACK(on_preedit_start), this);\n+        g_signal_connect(im_ctx.ctx, \"preedit-changed\", G_CALLBACK(on_preedit_changed), this);\n+        g_signal_connect(im_ctx.ctx, \"preedit-end\", G_CALLBACK(on_preedit_end), this);\n+        g_signal_connect(im_ctx.ctx, \"commit\", G_CALLBACK(on_commit), this);\n@@ -278,0 +166,2 @@\n+    gtk_im_context_reset(im_ctx.ctx);\n+    gtk_im_context_focus_in(im_ctx.ctx);\n@@ -279,3 +169,2 @@\n-    XSetICFocus(xim.ic);\n-\n-    xim.enabled = TRUE;\n+    im_ctx.on_preedit = false;\n+    im_ctx.enabled = true;\n@@ -285,2 +174,4 @@\n-    if (xim.ic != NULL) {\n-        XUnsetICFocus(xim.ic);\n+    if (im_ctx.ctx != NULL) {\n+        g_signal_handlers_disconnect_matched(im_ctx.ctx, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, NULL);\n+        g_object_unref(im_ctx.ctx);\n+        im_ctx.ctx = NULL;\n@@ -288,0 +179,2 @@\n+\n+    im_ctx.enabled = false;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window_ime.cpp","additions":110,"deletions":217,"binary":false,"changes":327,"status":"modified"}]}