{"files":[{"patch":"@@ -38,1 +38,0 @@\n-import javafx.beans.InvalidationListener;\n@@ -396,0 +395,5 @@\n+                }\n+\n+                @java.lang.Override\n+                public Point2D getTextLocationRelative(int offset) {\n+                    return newTextField.getInputMethodRequests().getTextLocationRelative(offset);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ComboBoxPopupControl.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -345,0 +345,1 @@\n+                    Point2D p = getTextLocationRelative(offset);\n@@ -350,3 +351,0 @@\n-                    \/\/ Don't use imstart here because it isn't initialized yet.\n-                    Rectangle2D characterBounds = getCharacterBounds(control.getSelection().getStart() + offset);\n-                    Point2D p = control.localToScene(characterBounds.getMinX(), characterBounds.getMaxY());\n@@ -358,0 +356,6 @@\n+                @Override public Point2D getTextLocationRelative(int offset) {\n+                    \/\/ Don't use imstart here because it isn't initialized yet.\n+                    Rectangle2D characterBounds = getCharacterBounds(control.getSelection().getStart() + offset);\n+                    return control.localToScene(characterBounds.getMinX(), characterBounds.getMaxY());\n+                }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TextInputControlSkin.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1400,0 +1400,5 @@\n+            @Override\n+            public Point2D getTextLocationRelative(int offset) {\n+                return new Point2D(0, 0);\n+            }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/SkinCleanupTest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.Objects;\n@@ -122,0 +123,4 @@\n+        public double[] getInputMethodCandidateRelativePos(int offset) {\n+            return null;\n+        }\n+\n@@ -668,0 +673,7 @@\n+    private double[] getInputMethodCandidateRelativePos(int offset) {\n+        if (this.eventHandler != null) {\n+            return this.eventHandler.getInputMethodCandidateRelativePos(offset);\n+        }\n+        return null;\n+    }\n+\n@@ -986,0 +998,4 @@\n+    protected double[] notifyInputMethodCandidateRelativePosRequest(int offset) {\n+        return Objects.requireNonNullElseGet(getInputMethodCandidateRelativePos(offset), () -> new double[] { 0.0, 0.0});\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/View.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -32,1 +33,0 @@\n-import java.util.ArrayList;\n@@ -36,7 +36,0 @@\n-\n-    private boolean imEnabled = false;\n-    private boolean isInPreeditMode = false;\n-    private final StringBuilder preedit = new StringBuilder();\n-    private ByteBuffer attributes;\n-    private int lastCaret;\n-\n@@ -48,4 +41,0 @@\n-        if (imEnabled) {\n-            preedit.setLength(0);\n-        }\n-        imEnabled = enable;\n@@ -116,101 +105,1 @@\n-        if (imEnabled && isInPreeditMode) {\n-            \/\/ Discard any pre-edited text\n-            preedit.setLength(0);\n-            notifyInputMethod(preedit.toString(), null, null, null, 0, 0, 0);\n-        }\n-    }\n-\n-    private void notifyPreeditMode(boolean enabled){\n-        isInPreeditMode = enabled;\n-    }\n-\n-\n-    protected void notifyInputMethodDraw(String text, int first, int length, int caret, byte[] attr) {\n-        int[] boundary = null;\n-        byte[] values = null;\n-\n-        if (attributes == null ) {\n-            attributes = ByteBuffer.allocate(32);\n-        }\n-\n-        if (length > 0) {\n-            preedit.replace(first, first + length, \"\");\n-        }\n-\n-        if (text != null) {\n-            preedit.insert(first, text);\n-        } else {\n-            if (attr == null) {\n-                preedit.setLength(0);\n-            }\n-        }\n-\n-        if (attributes.capacity() < preedit.length()) {\n-            ByteBuffer tmp  = ByteBuffer.allocate((int) (preedit.length() * 1.5));\n-            tmp.put(attributes);\n-            attributes = tmp;\n-        }\n-\n-        attributes.limit(preedit.length());\n-\n-        if (attr != null && attributes.limit() >= (first + attr.length)) {\n-            attributes.position(first);\n-            attributes.put(attr);\n-        }\n-\n-        if (attributes.limit() > 0) {\n-            ArrayList<Integer> boundaryList = new ArrayList<>();\n-            ArrayList<Byte> valuesList = new ArrayList<>();\n-            attributes.rewind();\n-            byte lastAttribute = attributes.get();\n-\n-            boundaryList.add(0);\n-            valuesList.add(lastAttribute);\n-\n-            int i = 1;\n-            while (attributes.hasRemaining()) {\n-                byte a = attributes.get();\n-                if (lastAttribute != a) {\n-                    boundaryList.add(i);\n-                    valuesList.add(a);\n-                }\n-                lastAttribute = a;\n-                i++;\n-            }\n-\n-            boundaryList.add(attributes.limit());\n-\n-            boundary = new int[boundaryList.size()];\n-            i = 0;\n-            for (Integer e : boundaryList) {\n-                boundary[i++] = e;\n-            }\n-\n-            values = new byte[valuesList.size()];\n-            i = 0;\n-            for (Byte e: valuesList) {\n-                values[i++] = e;\n-            }\n-        }\n-\n-        notifyInputMethod(preedit.toString(), boundary, boundary, values, 0, caret, 0);\n-        lastCaret = caret;\n-    }\n-\n-    protected void notifyInputMethodCaret(int pos, int direction, int style) {\n-        switch (direction) {\n-            case 0: \/\/XIMForwardChar\n-                lastCaret += pos;\n-                break;\n-            case 1: \/\/XIMBackwardChar\n-                lastCaret -= pos;\n-                break;\n-            case 10: \/\/XIMAbsolute\n-                lastCaret = pos;\n-                break;\n-            default:\n-                \/\/TODO: as we don't know the text structure, we cannot compute the position\n-                \/\/ for other directions (like forward words, lines, etc...).\n-                \/\/ Luckily, vast majority of IM uses XIMAbsolute (10)\n-        }\n-        notifyInputMethod(preedit.toString(), null, null, null, 0, lastCaret, 0);\n+        \/\/nothing\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkView.java","additions":2,"deletions":113,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -678,0 +678,6 @@\n+    @Override\n+    public double[] getInputMethodCandidateRelativePos(int offset) {\n+        Point2D p2d = scene.inputMethodRequests.getTextLocationRelative(offset);\n+        return new double[] { p2d.getX(), p2d.getY() };\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/GlassViewEventHandler.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4175,0 +4175,10 @@\n+        @Override\n+        public Point2D getTextLocationRelative(int offset) {\n+            InputMethodRequests requests = getClientRequests();\n+            if (requests != null) {\n+                return requests.getTextLocationRelative(offset);\n+            } else {\n+                return new Point2D(0, 0);\n+            }\n+        }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,0 +54,13 @@\n+    \/**\n+     * Gets the location of a specified offset in the current composed text,\n+     * or of the selection in committed text. This information is, for example,\n+     * used to position the candidate window near the composed text, or a\n+     * composition window near the location where committed text will be\n+     * inserted.\n+     *\n+     * @param offset the offset within the composed text, if there is\n+     *         composed text; null otherwise\n+     * @return a point representing the Scene location of the offset\n+     *\/\n+    Point2D getTextLocationRelative(int offset);\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/input\/InputMethodRequests.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-    if (ctx != NULL && ctx->hasIME() && ctx->filterIME(event)) {\n+    if (event->type == GDK_KEY_PRESS && ctx != NULL && ctx->filterIME(event)) {\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassApplication.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,3 +65,1 @@\n-jmethodID jViewNotifyInputMethodDraw;\n-jmethodID jViewNotifyInputMethodCaret;\n-jmethodID jViewNotifyPreeditMode;\n+jmethodID jViewNotifyInputMethodCandidateRelativePosRequest;\n@@ -215,0 +213,3 @@\n+    jViewNotifyInputMethodCandidateRelativePosRequest\n+        = env->GetMethodID(clazz, \"notifyInputMethodCandidateRelativePosRequest\", \"(I)[D\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n@@ -220,9 +221,0 @@\n-    clazz = env->FindClass(\"com\/sun\/glass\/ui\/gtk\/GtkView\");\n-    if (env->ExceptionCheck()) return JNI_ERR;\n-    jViewNotifyInputMethodDraw = env->GetMethodID(clazz, \"notifyInputMethodDraw\", \"(Ljava\/lang\/String;III[B)V\");\n-    if (env->ExceptionCheck()) return JNI_ERR;\n-    jViewNotifyInputMethodCaret = env->GetMethodID(clazz, \"notifyInputMethodCaret\", \"(III)V\");\n-    if (env->ExceptionCheck()) return JNI_ERR;\n-    jViewNotifyPreeditMode = env->GetMethodID(clazz, \"notifyPreeditMode\", \"(Z)V\");\n-    if (env->ExceptionCheck()) return JNI_ERR;\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.cpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -176,4 +176,3 @@\n-    extern jmethodID jViewNotifyInputMethod; \/\/com.sun.glass.ui.View#notifyInputMethod (Ljava\/lang\/String;[I[I[BIII)V\n-    extern jmethodID jViewNotifyInputMethodDraw; \/\/com.sun.glass.ui.gtk.GtkView#notifyInputMethodDraw (Ljava\/lang\/String;III[B)V\n-    extern jmethodID jViewNotifyInputMethodCaret; \/\/com.sun.glass.ui.gtk.GtkView#notifyInputMethodCaret (III)V\n-    extern jmethodID jViewNotifyPreeditMode; \/\/com.sun.glass.ui.gtk.GtkView#notifyPreeditMode (Z)V\n+    extern jmethodID jViewNotifyInputMethod; \/\/com.sun.glass.ui.View#jViewNotifyInputMethod (Ljava\/lang\/String;[I[I[BIII)V\n+    extern jmethodID jViewNotifyInputMethodCandidateRelativePosRequest; \/\/com.sun.glass.ui.View#notifyInputMethodCandidateRelativePosRequest (I)[D\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.h","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    if (xim.enabled && xim.ic) {\n+    if (im_ctx.enabled && im_ctx.ctx) {\n@@ -143,1 +143,1 @@\n-            XSetICFocus(xim.ic);\n+            gtk_im_context_focus_in(im_ctx.ctx);\n@@ -145,1 +145,1 @@\n-            XUnsetICFocus(xim.ic);\n+            gtk_im_context_focus_out(im_ctx.ctx);\n@@ -462,16 +462,0 @@\n-    } else {\n-#ifdef GLASS_GTK2\n-        if (key == 0) {\n-            \/\/ Work around \"bug\" fixed in gtk-3.0:\n-            \/\/ http:\/\/mail.gnome.org\/archives\/commits-list\/2011-March\/msg06832.html\n-            switch (event->keyval) {\n-            case 0xFF08 \/* Backspace *\/: key =  '\\b';\n-            case 0xFF09 \/* Tab       *\/: key =  '\\t';\n-            case 0xFF0A \/* Linefeed  *\/: key =  '\\n';\n-            case 0xFF0B \/* Vert. Tab *\/: key =  '\\v';\n-            case 0xFF0D \/* Return    *\/: key =  '\\r';\n-            case 0xFF1B \/* Escape    *\/: key =  '\\033';\n-            case 0xFFFF \/* Delete    *\/: key =  '\\177';\n-            }\n-        }\n-#endif\n@@ -489,8 +473,0 @@\n-    if (jview) {\n-        if (press) {\n-            mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n-                    com_sun_glass_events_KeyEvent_PRESS,\n-                    glassKey,\n-                    jChars,\n-                    glassModifier);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n@@ -498,16 +474,20 @@\n-            if (jview && key > 0) { \/\/ TYPED events should only be sent for printable characters.\n-                mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n-                        com_sun_glass_events_KeyEvent_TYPED,\n-                        com_sun_glass_events_KeyEvent_VK_UNDEFINED,\n-                        jChars,\n-                        glassModifier);\n-                CHECK_JNI_EXCEPTION(mainEnv)\n-            }\n-        } else {\n-            mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n-                    com_sun_glass_events_KeyEvent_RELEASE,\n-                    glassKey,\n-                    jChars,\n-                    glassModifier);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n+    if (!jview) {\n+        return;\n+    }\n+\n+    g_print(\"PROCESS_KEY -> press: %d\\n\", press);\n+    mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n+            (press) ? com_sun_glass_events_KeyEvent_PRESS\n+                    : com_sun_glass_events_KeyEvent_RELEASE,\n+            glassKey,\n+            jChars,\n+            glassModifier);\n+    CHECK_JNI_EXCEPTION(mainEnv)\n+\n+    if (press && key > 0) { \/\/ TYPED events should only be sent for printable characters.\n+        mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n+                com_sun_glass_events_KeyEvent_TYPED,\n+                com_sun_glass_events_KeyEvent_VK_UNDEFINED,\n+                jChars,\n+                glassModifier);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n@@ -679,9 +659,1 @@\n-    if (xim.ic) {\n-        XDestroyIC(xim.ic);\n-        xim.ic = NULL;\n-    }\n-    if (xim.im) {\n-        XCloseIM(xim.im);\n-        xim.im = NULL;\n-    }\n-\n+    disableIME();\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.cpp","additions":24,"deletions":52,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include <queue>\n@@ -101,0 +102,1 @@\n+    virtual void updateCaretPos() = 0;\n@@ -102,0 +104,3 @@\n+    virtual void setOnPreEdit(bool) = 0;\n+    virtual void commitIME(gchar *) = 0;\n+\n@@ -169,3 +174,2 @@\n-    struct _XIM {\n-        XIM im;\n-        XIC ic;\n+    struct ImContext {\n+        GtkIMContext *ctx;\n@@ -173,1 +177,3 @@\n-    } xim;\n+        bool on_preedit;\n+        bool send_keypress;\n+    } im_ctx;\n@@ -213,0 +219,3 @@\n+    void setOnPreEdit(bool);\n+    void commitIME(gchar *);\n+    void updateCaretPos();\n@@ -254,2 +263,0 @@\n-private:\n-    bool im_filter_keypress(GdkEventKey*);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include <com_sun_glass_events_KeyEvent.h>\n+\n@@ -29,0 +31,1 @@\n+#include \"glass_key.h\"\n@@ -30,22 +33,4 @@\n-#include <cstring>\n-#include <cstdlib>\n-\n-bool WindowContextBase::hasIME() {\n-    return xim.enabled;\n-}\n-\n-static XKeyPressedEvent convert_event(GdkEventKey *event) {\n-    XKeyPressedEvent result;\n-    memset(&result, 0, sizeof (result));\n-\n-    result.type = (event->type == GDK_KEY_PRESS) ? KeyPress : KeyRelease;\n-    result.send_event = event->send_event;\n-    result.display = gdk_x11_display_get_xdisplay(gdk_window_get_display(event->window));\n-    result.window = result.subwindow = GDK_WINDOW_XID(event->window);\n-    result.root = GDK_WINDOW_XID(gdk_screen_get_root_window(glass_gdk_window_get_screen(event->window)));\n-    result.time = event->time;\n-    result.state = event->state;\n-    result.keycode = event->hardware_keycode;\n-    result.same_screen = True;\n-\n-    return result;\n+static void on_preedit_start(GtkIMContext *im_context, gpointer user_data) {\n+    g_print(\"preedit_start\\n\");\n+    WindowContext *ctx = (WindowContext *) user_data;\n+    ctx->setOnPreEdit(true);\n@@ -54,3 +39,4 @@\n-bool WindowContextBase::im_filter_keypress(GdkEventKey* event) {\n-    static size_t buf_len = 12;\n-    static char *buffer = NULL;\n+static void on_preedit_changed(GtkIMContext *im_context, gpointer user_data) {\n+    WindowContext *ctx = (WindowContext *) user_data;\n+    gchar *preedit_text;\n+    PangoAttrList* attrList;\n@@ -58,3 +44,2 @@\n-    if (buffer == NULL) {\n-        buffer = (char*)malloc(buf_len * sizeof (char));\n-    }\n+    gtk_im_context_get_preedit_string(im_context, &preedit_text, &attrList, NULL);\n+    ctx->updateCaretPos();\n@@ -62,5 +47,2 @@\n-    if (buffer == NULL) {\n-        \/\/ dont process the key event\n-        fprintf(stderr, \"malloc failed in im_filter_keypress\\n\");\n-        return false;\n-    }\n+    jstring jstr = mainEnv->NewStringUTF(preedit_text);\n+    EXCEPTION_OCCURED(mainEnv);\n@@ -68,6 +50,1 @@\n-    KeySym keysym;\n-    Status status;\n-    XKeyPressedEvent xevent = convert_event(event);\n-    if (XFilterEvent((XEvent*) & xevent, GDK_WINDOW_XID(gdk_window))) {\n-        return TRUE;\n-    }\n+    jsize slen = mainEnv->GetStringLength(jstr);\n@@ -75,4 +52,1 @@\n-    if (event->type == GDK_KEY_RELEASE) {\n-        process_key(event);\n-        return TRUE;\n-    }\n+    int cursor = 0;\n@@ -80,39 +54,2 @@\n-    int len = Xutf8LookupString(xim.ic, &xevent, buffer, buf_len - 1, &keysym, &status);\n-    if (status == XBufferOverflow) {\n-        buf_len = len + 1;\n-        char *tmpBuffer = (char*)realloc(buffer, buf_len * sizeof (char));\n-        if (tmpBuffer == NULL) {\n-            SAFE_FREE(buffer);\n-            \/\/ dont process the key event\n-            fprintf(stderr, \"realloc failed in im_filter_keypress\\n\");\n-            return false;\n-        }\n-        buffer = tmpBuffer;\n-        len = Xutf8LookupString(xim.ic, &xevent, buffer, buf_len - 1,\n-                &keysym, &status);\n-    }\n-    switch (status) {\n-        case XLookupKeySym:\n-        case XLookupBoth:\n-            if (xevent.keycode) {\n-                \/\/process it as a normal key\n-                process_key(event);\n-                break;\n-            }\n-            \/\/ fall-through\n-        case XLookupChars:\n-            buffer[len] = 0;\n-            jstring str = mainEnv->NewStringUTF(buffer);\n-            EXCEPTION_OCCURED(mainEnv);\n-            jsize slen = mainEnv->GetStringLength(str);\n-            mainEnv->CallVoidMethod(jview,\n-                    jViewNotifyInputMethod,\n-                    str,\n-                    NULL, NULL, NULL,\n-                    slen,\n-                    slen,\n-                    0);\n-            LOG_EXCEPTION(mainEnv)\n-\n-            break;\n-    }\n+    PangoAttrIterator* iter = pango_attr_list_get_iterator(attrList);\n+    PangoAttribute  *attr;\n@@ -120,2 +57,5 @@\n-    return TRUE;\n-}\n+    int boundaryCount = 0;\n+    do {\n+        int start, end;\n+        pango_attr_iterator_range(iter, &start, &end);\n+        g_print(\"attr_range: %d, %d\\n\", start, end);\n@@ -123,4 +63,2 @@\n-bool WindowContextBase::filterIME(GdkEvent * event) {\n-    if (!hasIME()) {\n-        return false;\n-    }\n+        if (attr = pango_attr_iterator_get(iter, PANGO_ATTR_BACKGROUND)) {\n+            const PangoColor *color = &((PangoAttrColor *)attr)->color;\n@@ -128,8 +66,1 @@\n-    switch (event->type) {\n-        case GDK_KEY_PRESS:\n-        case GDK_KEY_RELEASE:\n-            return im_filter_keypress(reinterpret_cast<GdkEventKey*> (event));\n-        default:\n-            return FALSE;\n-    }\n-}\n+            g_print(\"attr_color: %d, %d, %d\\n\", color->red, color->green, color->blue);\n@@ -137,5 +68,12 @@\n-\/\/Note: this function must return int, despite the fact it doesn't conform to XIMProc type.\n-\/\/ This is required in documentation of XIM\n-static int im_preedit_start(XIM im_xim, XPointer client, XPointer call) {\n-    (void)im_xim;\n-    (void)call;\n+            if ((color->red | color->green | color->blue) == 0) {\n+\/\/                v[i] = com_sun_glass_ui_View_IME_ATTR_TARGET_NOTCONVERTED;\n+            } else {\n+\/\/                v[i] = com_sun_glass_ui_View_IME_ATTR_TARGET_CONVERTED;\n+            }\n+        } else if ((attr = pango_attr_iterator_get(iter, PANGO_ATTR_UNDERLINE))\n+                && (((PangoAttrInt *)attr)->value != PANGO_UNDERLINE_NONE)) {\n+            g_print(\"underline\\n\");\n+\/\/            v[i] = com_sun_glass_ui_View_IME_ATTR_CONVERTED;\n+        } else {\n+\/\/            v[i] = com_sun_glass_ui_View_IME_ATTR_INPUT;\n+        }\n@@ -143,3 +81,25 @@\n-    mainEnv->CallVoidMethod((jobject) client, jViewNotifyPreeditMode, JNI_TRUE);\n-    CHECK_JNI_EXCEPTION_RET(mainEnv, -1);\n-    return -1; \/\/ No restrictions\n+        boundaryCount++;\n+    } while (pango_attr_iterator_next(iter));\n+\n+    pango_attr_iterator_destroy (iter);\n+    g_free(preedit_text);\n+\n+\/\/    boundary = mainEnv->newIntArray(slen);\n+\/\/    CHECK_JNI_EXCEPTION(mainEnv)\n+\/\/\n+\/\/    attr = mainEnv->NewByteArray(slen);\n+\/\/    CHECK_JNI_EXCEPTION(mainEnv)\n+\/\/\n+\/\/    mainEnv->SetByteArrayRegion(attr, 0, slen, v);\n+\/\/    CHECK_JNI_EXCEPTION(mainEnv)\n+\n+    mainEnv->CallVoidMethod(ctx->get_jview(),\n+            jViewNotifyInputMethod,\n+            jstr,\n+            NULL,\n+            NULL,\n+            NULL,\n+            0,\n+            cursor,\n+            0);\n+    LOG_EXCEPTION(mainEnv)\n@@ -148,3 +108,2 @@\n-static void im_preedit_done(XIM im_xim, XPointer client, XPointer call) {\n-    (void)im_xim;\n-    (void)call;\n+static void on_preedit_end(GtkIMContext *im_context, gpointer user_data) {\n+    g_print(\"on_preedit_end\\n\");\n@@ -152,2 +111,2 @@\n-    mainEnv->CallVoidMethod((jobject) client, jViewNotifyPreeditMode, JNI_FALSE);\n-    CHECK_JNI_EXCEPTION(mainEnv);\n+    WindowContext *ctx = (WindowContext *) user_data;\n+    ctx->setOnPreEdit(false);\n@@ -156,22 +115,5 @@\n-static void im_preedit_draw(XIM im_xim, XPointer client, XPointer call) {\n-    (void)im_xim;\n-    (void)call;\n-\n-    XIMPreeditDrawCallbackStruct *data = (XIMPreeditDrawCallbackStruct*) call;\n-    jstring text = NULL;\n-    jbyteArray attr = NULL;\n-\n-    if (data->text != NULL) {\n-        if (data->text->string.multi_byte) {\n-            if (data->text->encoding_is_wchar) {\n-                size_t csize = wcstombs(NULL, data->text->string.wide_char, 0);\n-                char *ctext = new char[csize + 1];\n-                wcstombs(ctext, data->text->string.wide_char, csize + 1);\n-                text = mainEnv->NewStringUTF(ctext);\n-                delete[] ctext;\n-                CHECK_JNI_EXCEPTION(mainEnv);\n-            } else {\n-                text = mainEnv->NewStringUTF(data->text->string.multi_byte);\n-                CHECK_JNI_EXCEPTION(mainEnv);\n-            }\n-        }\n+static void on_commit(GtkIMContext *im_context, gchar* str, gpointer user_data) {\n+    g_print(\"on_commit\\n\");\n+    WindowContext *ctx = (WindowContext *) user_data;\n+    ctx->commitIME(str);\n+}\n@@ -179,18 +121,18 @@\n-        if (XIMFeedback* fb = data->text->feedback) {\n-            attr = mainEnv->NewByteArray(data->text->length);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-            jbyte v[data->text->length];\n-            for (int i = 0; i < data->text->length; i++) {\n-                if (fb[i] & XIMReverse) {\n-                    v[i] = com_sun_glass_ui_View_IME_ATTR_TARGET_NOTCONVERTED;\n-                } else if (fb[i] & XIMHighlight) {\n-                    v[i] = com_sun_glass_ui_View_IME_ATTR_TARGET_CONVERTED;\n-                } else if (fb[i] & XIMUnderline) {\n-                    v[i] = com_sun_glass_ui_View_IME_ATTR_CONVERTED;\n-                } else {\n-                    v[i] = com_sun_glass_ui_View_IME_ATTR_INPUT;\n-                }\n-            }\n-            mainEnv->SetByteArrayRegion(attr, 0, data->text->length, v);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n+void WindowContextBase::commitIME(gchar *str) {\n+    if (im_ctx.on_preedit) {\n+        jstring jstr = mainEnv->NewStringUTF(str);\n+        EXCEPTION_OCCURED(mainEnv);\n+        jsize slen = mainEnv->GetStringLength(jstr);\n+\n+        mainEnv->CallVoidMethod(jview,\n+                jViewNotifyInputMethod,\n+                jstr,\n+                NULL,\n+                NULL,\n+                NULL,\n+                slen,\n+                slen,\n+                0);\n+        LOG_EXCEPTION(mainEnv)\n+    } else {\n+        im_ctx.send_keypress = true;\n@@ -198,4 +140,0 @@\n-\n-    mainEnv->CallVoidMethod((jobject)client, jViewNotifyInputMethodDraw,\n-            text, data->chg_first, data->chg_length, data->caret, attr);\n-    CHECK_JNI_EXCEPTION(mainEnv)\n@@ -204,7 +142,2 @@\n-static void im_preedit_caret(XIM im_xim, XPointer client, XPointer call) {\n-    (void)im_xim;\n-\n-    XIMPreeditCaretCallbackStruct *data = (XIMPreeditCaretCallbackStruct*) call;\n-    mainEnv->CallVoidMethod((jobject)client, jViewNotifyInputMethodCaret,\n-            data->position, data->direction, data->style);\n-    CHECK_JNI_EXCEPTION(mainEnv)\n+bool WindowContextBase::hasIME() {\n+    return im_ctx.enabled;\n@@ -213,8 +146,3 @@\n-static XIMStyle get_best_supported_style(XIM im_xim)\n-{\n-    XIMStyles* styles;\n-    int i;\n-    XIMStyle result = 0;\n-\n-    if (XGetIMValues(im_xim, XNQueryInputStyle, &styles, NULL) != NULL) { \/\/ NULL means it's OK\n-        return 0;\n+bool WindowContextBase::filterIME(GdkEvent *event) {\n+    if (!hasIME()) {\n+        return false;\n@@ -223,6 +151,6 @@\n-    for (i = 0; i < styles->count_styles; ++i) {\n-        if (styles->supported_styles[i] == (XIMPreeditCallbacks | XIMStatusNothing)\n-                || styles->supported_styles[i] == (XIMPreeditNothing | XIMStatusNothing)) {\n-            result = styles->supported_styles[i];\n-            break;\n-        }\n+    g_print(\"will filter?\\n\");\n+    bool filtered = gtk_im_context_filter_keypress(im_ctx.ctx, &event->key);\n+\n+    if (im_ctx.send_keypress) {\n+        process_key(&event->key);\n+        im_ctx.send_keypress = false;\n@@ -231,1 +159,1 @@\n-    XFree(styles);\n+    g_print(\"filterIME -> keyval: %d, press: %d, filtered: %d\\n\", event->key.keyval, (event->key.type == GDK_KEY_PRESS), filtered);\n@@ -233,1 +161,1 @@\n-    return result;\n+    return filtered;\n@@ -236,12 +164,3 @@\n-void WindowContextBase::enableOrResetIME() {\n-    Display *display = gdk_x11_display_get_xdisplay(gdk_window_get_display(gdk_window));\n-    if (xim.im == NULL || xim.ic == NULL) {\n-        xim.im = XOpenIM(display, NULL, NULL, NULL);\n-        if (xim.im == NULL) {\n-            return;\n-        }\n-\n-        XIMStyle styles = get_best_supported_style(xim.im);\n-        if (styles == 0) {\n-            return;\n-        }\n+void WindowContextBase::setOnPreEdit(bool preedit) {\n+    im_ctx.on_preedit = preedit;\n+}\n@@ -249,4 +168,2 @@\n-        XIMCallback startCallback = {(XPointer) jview, (XIMProc) (void *) im_preedit_start};\n-        XIMCallback doneCallback = {(XPointer) jview, im_preedit_done};\n-        XIMCallback drawCallback = {(XPointer) jview, im_preedit_draw};\n-        XIMCallback caretCallback = {(XPointer) jview, im_preedit_caret};\n+void WindowContextBase::updateCaretPos() {\n+    double *nativePos;\n@@ -254,6 +171,3 @@\n-        XVaNestedList list = XVaCreateNestedList(0,\n-                XNPreeditStartCallback, &startCallback,\n-                XNPreeditDoneCallback, &doneCallback,\n-                XNPreeditDrawCallback, &drawCallback,\n-                XNPreeditCaretCallback, &caretCallback,\n-                NULL);\n+    jdoubleArray pos = (jdoubleArray)mainEnv->CallObjectMethod(get_jview(),\n+                                      jViewNotifyInputMethodCandidateRelativePosRequest,\n+                                      0);\n@@ -261,5 +175,1 @@\n-        xim.ic = XCreateIC(xim.im,\n-                XNInputStyle, styles,\n-                XNClientWindow, GDK_WINDOW_XID(gdk_window),\n-                XNPreeditAttributes, list,\n-                NULL);\n+    nativePos = mainEnv->GetDoubleArrayElements(pos, NULL);\n@@ -267,1 +177,6 @@\n-        XFree(list);\n+    GdkRectangle rect;\n+    if (nativePos) {\n+        rect.x = (int) nativePos[0];\n+        rect.y = (int) nativePos[1];\n+        rect.width = 0;\n+        rect.height = 0;\n@@ -269,3 +184,2 @@\n-        if (xim.ic == NULL) {\n-            return;\n-        }\n+        mainEnv->ReleaseDoubleArrayElements(pos, nativePos, 0);\n+        gtk_im_context_set_cursor_location(im_ctx.ctx, &rect);\n@@ -273,0 +187,1 @@\n+}\n@@ -274,2 +189,8 @@\n-    if (xim.enabled) { \/\/called when changed focus to different input\n-        XmbResetIC(xim.ic);\n+void WindowContextBase::enableOrResetIME() {\n+    if (!im_ctx.enabled) {\n+        im_ctx.ctx = gtk_im_multicontext_new();\n+        gtk_im_context_set_client_window(GTK_IM_CONTEXT(im_ctx.ctx), gdk_window);\n+        g_signal_connect(im_ctx.ctx, \"preedit-start\", G_CALLBACK(on_preedit_start), this);\n+        g_signal_connect(im_ctx.ctx, \"preedit-changed\", G_CALLBACK(on_preedit_changed), this);\n+        g_signal_connect(im_ctx.ctx, \"preedit-end\", G_CALLBACK(on_preedit_end), this);\n+        g_signal_connect(im_ctx.ctx, \"commit\", G_CALLBACK(on_commit), this);\n@@ -278,0 +199,2 @@\n+    gtk_im_context_reset(im_ctx.ctx);\n+    gtk_im_context_focus_in(im_ctx.ctx);\n@@ -279,3 +202,2 @@\n-    XSetICFocus(xim.ic);\n-\n-    xim.enabled = TRUE;\n+    im_ctx.on_preedit = false;\n+    im_ctx.enabled = true;\n@@ -285,2 +207,3 @@\n-    if (xim.ic != NULL) {\n-        XUnsetICFocus(xim.ic);\n+    if (im_ctx.ctx != NULL) {\n+        g_signal_handlers_disconnect_matched(im_ctx.ctx, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, NULL);\n+        g_object_unref(im_ctx.ctx);\n@@ -288,0 +211,2 @@\n+\n+    im_ctx.enabled = false;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window_ime.cpp","additions":139,"deletions":214,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -128,0 +128,5 @@\n+                       @Override\n+                       public Point2D getTextLocationRelative(int offset) {\n+                           return new Point2D(0, 0);\n+                       }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/Node_properties_Test.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -136,1 +136,15 @@\n-        Invoker.getInvoker().invokeOnEventThread(f);\n+        return getPoint2DTextLocationFuture(f);\n+    }\n+\n+    @Override\n+    public Point2D getTextLocationRelative(int offset) {\n+        FutureTask<Point2D> f = new FutureTask<>(() -> {\n+            int[] loc = webPage.getClientTextLocation(offset);\n+            return new Point2D(loc[0], loc[1] + loc[3]);\n+        });\n+\n+        return getPoint2DTextLocationFuture(f);\n+    }\n+\n+    private Point2D getPoint2DTextLocationFuture(FutureTask<Point2D> future) {\n+        Invoker.getInvoker().invokeOnEventThread(future);\n@@ -139,1 +153,1 @@\n-            result = f.get();\n+            result = future.get();\n","filename":"modules\/javafx.web\/src\/main\/java\/com\/sun\/javafx\/webkit\/InputMethodClientImpl.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"}]}