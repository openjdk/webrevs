{"files":[{"patch":"@@ -925,0 +925,4 @@\n+                \/\/ Note: this check should be after the value was added to the cache\n+                \/\/ as the cache is shared between all properties with the same pseudo states,\n+                \/\/ and not all of the nodes will have the property set manually.\n+                \/\/\n@@ -1163,23 +1167,0 @@\n-        } else { \/\/ style != null\n-\n-            \/\/ RT-10522:\n-            \/\/ If the user set the property and there is a style and\n-            \/\/ the style came from the user agent stylesheet, then\n-            \/\/ skip the value. A style from a user agent stylesheet should\n-            \/\/ not override the user set style.\n-            if (style.getOrigin() == StyleOrigin.USER_AGENT) {\n-\n-                StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(originatingStyleable);\n-                \/\/ if styleableProperty is null, then we're dealing with a sub-property.\n-                if (styleableProperty != null && styleableProperty.getStyleOrigin() == StyleOrigin.USER) {\n-                    return SKIP;\n-                }\n-            }\n-\n-            \/\/ If there was a style found, then we want to check whether the\n-            \/\/ value was \"inherit\". If so, then we will simply inherit.\n-            final ParsedValue cssValue = style.getParsedValue();\n-            if (cssValue != null && \"inherit\".equals(cssValue.getValue())) {\n-                style = getInheritedStyle(styleable, property);\n-                if (style == null) return SKIP;\n-            }\n@@ -1188,3 +1169,18 @@\n-\/\/        System.out.println(\"lookup \" + property +\n-\/\/                \", selector = \\'\" + style.selector.toString() + \"\\'\" +\n-\/\/                \", node = \" + node.toString());\n+        \/*\n+         * Even if this style comes from the user agent stylesheet,\n+         * and the user has set the property directly, the value should\n+         * still be calculated as it may be cached and shared for all nodes\n+         * with the same pseudo states.\n+         *\n+         * The caller of this function should decide (after potentially\n+         * caching the value) whether or not to proceed with applying\n+         * the style.\n+         *\/\n+\n+        \/\/ If there was a style found, then we want to check whether the\n+        \/\/ value was \"inherit\". If so, then we will simply inherit.\n+        final ParsedValue cssValue = style.getParsedValue();\n+        if (cssValue != null && \"inherit\".equals(cssValue.getValue())) {\n+            style = getInheritedStyle(styleable, property);\n+            if (style == null) return SKIP;\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/CssStyleHelper.java","additions":22,"deletions":26,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import javafx.geometry.Insets;\n@@ -611,0 +612,49 @@\n+\n+    @Test\n+    public void initialNodeWithUserSetValueShouldNotResetValuesOnOtherNodesWithoutOverridenValue() throws IOException {\n+        Stylesheet stylesheet = new CssParser().parse(\n+            \"initialNodeWithUserSetValueShouldNotResetValuesOnOtherNodesWithoutOverridenValue\",\n+            \"\"\"\n+                .pane {\n+                    -fx-padding: 4;\n+                }\n+            \"\"\"\n+        );\n+\n+        StyleManager.getInstance().setDefaultUserAgentStylesheet(stylesheet);\n+        Pane a = new Pane();\n+        Pane b = new Pane();\n+\n+        a.getStyleClass().add(\"pane\");\n+        a.setPadding(new Insets(10));\n+\n+        b.getStyleClass().add(\"pane\");\n+\n+        root.getChildren().addAll(a, b);\n+\n+        stage.show();\n+        Toolkit.getToolkit().firePulse();\n+\n+        assertEquals(new Insets(10), a.getPadding());\n+        assertEquals(new Insets(4), b.getPadding());\n+\n+        \/\/ When changing a to focused, this will be the first time that the padding\n+        \/\/ property is seen in the state focused. A new cache entry is created, which\n+        \/\/ despite the padding value being overridden, should still add the padding value\n+        \/\/ that comes from the USER_AGENT stylesheet as this entry is shared with\n+        \/\/ all other nodes with the same property, with the same state at the same nesting level.\n+        a.pseudoClassStateChanged(PseudoClass.getPseudoClass(\"focused\"), true);\n+        Toolkit.getToolkit().firePulse();\n+\n+        assertEquals(new Insets(10), a.getPadding());\n+        assertEquals(new Insets(4), b.getPadding());\n+\n+        \/\/ When changing b to focused, it should not have its padding changed. If b\n+        \/\/ padding does change, then the cache entry was incorrect.\n+        a.pseudoClassStateChanged(PseudoClass.getPseudoClass(\"focused\"), false);\n+        b.pseudoClassStateChanged(PseudoClass.getPseudoClass(\"focused\"), true);\n+        Toolkit.getToolkit().firePulse();\n+\n+        assertEquals(new Insets(10), a.getPadding());\n+        assertEquals(new Insets(4), b.getPadding());\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/CssStyleHelperTest.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"}]}