{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,4 @@\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Control;\n+import javafx.scene.control.Skin;\n@@ -447,0 +451,56 @@\n+\n+    \/**\n+     * Adds a disonnectable machinery to listen to {@code control}'s Scene and Scene.focusOwner properties,\n+     * for the purpose of invoking the supplied callback when focused node is in the {@code control}'s hierarchy\n+     * or is the control itself.\n+     *\n+     * @param control the control\n+     * @param callback the callback\n+     *\/\n+    public void addSceneFocusOwnerListener(Control control, Consumer<Node> callback) {\n+        items.add(new ChLi<Scene>() {\n+            private ChangeListener<Node> focusListener = (s, p, n) -> {\n+                if (isParent(control, n)) {\n+                    callback.accept(n);\n+                }\n+            };\n+\n+            {\n+                control.sceneProperty().addListener(this);\n+                Scene scene = control.getScene();\n+                if (scene != null) {\n+                    scene.focusOwnerProperty().addListener(focusListener);\n+                }\n+            }\n+\n+            private static boolean isParent(Node parent, Node n) {\n+                while (n != null) {\n+                    if (parent == n) {\n+                        return true;\n+                    }\n+                    n = n.getParent();\n+                }\n+                return false;\n+            }\n+\n+            @Override\n+            public void disconnect() {\n+                control.sceneProperty().removeListener(this);\n+                Scene scene = control.getScene();\n+                if (scene != null) {\n+                    scene.focusOwnerProperty().removeListener(focusListener);\n+                }\n+                focusListener = null;\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue<? extends Scene> p, Scene old, Scene scene) {\n+                if (old != null) {\n+                    old.focusOwnerProperty().removeListener(focusListener);\n+                }\n+                if (scene != null) {\n+                    scene.focusOwnerProperty().addListener(focusListener);\n+                }\n+            }\n+        });\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/ListenerHelper.java","additions":61,"deletions":1,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-import javafx.scene.traversal.TraversalEvent;\n@@ -274,1 +273,1 @@\n-        lh.addEventHandler(control, TraversalEvent.NODE_TRAVERSED, (ev) -> {\n+        lh.addSceneFocusOwnerListener(control, (n) -> {\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/MenuBarSkin.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-import javafx.scene.traversal.TraversalEvent;\n@@ -663,1 +662,1 @@\n-        lh.addEventFilter(control, TraversalEvent.NODE_TRAVERSED, (ev) -> {\n+        lh.addSceneFocusOwnerListener(control, (n) -> {\n@@ -665,1 +664,1 @@\n-            Bounds b = TraversalUtils.getLayoutBounds(ev.getNode(), getSkinnable());\n+            Bounds b = TraversalUtils.getLayoutBounds(n, control);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ScrollPaneSkin.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javafx.scene.traversal.TraversalEvent;\n@@ -100,2 +99,0 @@\n-\n-        n.fireEvent(new TraversalEvent(n, TraversalEvent.NODE_TRAVERSED));\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/TopMostTraversalEngine.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javafx.scene.traversal;\n-\n-import javafx.beans.NamedArg;\n-import javafx.event.Event;\n-import javafx.event.EventType;\n-import javafx.scene.Node;\n-\n-\/**\n- * An event for representing node traversals that occur within the scenegraph. Traversal events, like all\n- * other events JavaFX, occur using the standard event filter \/ handling APIs. Therefore, to listen to\n- * when a node is traversed, use code along the following lines:\n- * <pre>{@code  Node node = ...;\n- * node.addEventHandler(TraversalEvent.NODE_TRAVERSED, (ev) -> {\n- *   \/\/ Use properties of the TraversalEvent to appropriately react to this event\n- *   Node n = ev.getNode();\n- * });}<\/pre>\n- *\n- * @see TraversalPolicy\n- * @since 24\n- *\/\n-public class TraversalEvent extends Event {\n-\n-    private static final long serialVersionUID = 202407011641L;\n-\n-    \/**\n-     * Common supertype for all traversal event types.\n-     *\/\n-    public static final EventType<TraversalEvent> ANY = new EventType<> (Event.ANY, \"ANY\");\n-\n-    \/**\n-     * Traversal event type for representing that a node has been traversed.\n-     *\/\n-    public static final EventType<TraversalEvent> NODE_TRAVERSED = new EventType<> (ANY, \"NODE_TRAVERSED\");\n-\n-    private transient final Node node;\n-\n-    \/**\n-     * Creates new instance of TraversalEvent.\n-     * @param node the {@link Node} which received the traversal event\n-     * @param eventType Type of the event\n-     *\/\n-    public TraversalEvent(\n-        final @NamedArg(\"node\") Node node,\n-        final @NamedArg(\"eventType\") EventType<? extends TraversalEvent> eventType\n-    ) {\n-        super(node, node, eventType);\n-        this.node = node;\n-    }\n-\n-    @Override\n-    public EventType<? extends TraversalEvent> getEventType() {\n-        return (EventType<? extends TraversalEvent>) super.getEventType();\n-    }\n-\n-    \/**\n-     * Returns the {@link Node} which received the traversal event (same object as {@link Event#getTarget()}).\n-     * @return the Node\n-     *\/\n-    public Node getNode() {\n-        return node;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return\n-            getClass().getName() +\n-            \"[node=\" + getNode() +\n-            \", source=\" + source +\n-            \"]\";\n-    }\n-}\n\\ No newline at end of file\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/traversal\/TraversalEvent.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -37,1 +37,0 @@\n-import javafx.scene.traversal.TraversalEvent;\n@@ -55,0 +54,1 @@\n+    private static Scene scene;\n@@ -69,1 +69,0 @@\n-    private Node fromEvent;\n@@ -116,0 +115,1 @@\n+        scene = new Scene(bp, 500, 400);\n@@ -117,5 +117,1 @@\n-        stage.setScene(new Scene(bp, 500, 400));\n-        stage.addEventHandler(TraversalEvent.ANY, (ev) -> {\n-            \/\/System.out.println(ev);\n-            fromEvent = ev.getNode();\n-        });\n+        stage.setScene(scene);\n@@ -123,2 +119,0 @@\n-\n-        fromEvent = null;\n@@ -138,0 +132,5 @@\n+        if (stage != null) {\n+            stage.hide();\n+            stage = null;\n+        }\n+        scene = null;\n@@ -154,1 +153,0 @@\n-            fromEvent = null;\n@@ -169,0 +167,1 @@\n+        Node fromEvent = scene.getFocusOwner();\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/traversal\/TraversalPolicyTest.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import java.util.Arrays;\n-import java.util.Collection;\n-import javafx.event.EventHandler;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -32,1 +30,0 @@\n-import javafx.geometry.Bounds;\n@@ -38,1 +35,0 @@\n-import javafx.scene.traversal.TraversalEvent;\n@@ -41,1 +37,0 @@\n-import com.sun.javafx.scene.traversal.TopMostTraversalEngine;\n@@ -47,3 +42,1 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import com.sun.javafx.scene.traversal.TopMostTraversalEngine;\n@@ -131,0 +124,3 @@\n+        if (stage != null) {\n+            stage.hide();\n+        }\n@@ -163,20 +159,0 @@\n-    @ParameterizedTest\n-    @MethodSource(\"parameters\")\n-    public void traverseListenerTest(\n-        int fromNumber,\n-        TraversalDirection direction,\n-        int toNumber,\n-        int toNumberTransformed)\n-    {\n-        TraverseListenerImpl h = new TraverseListenerImpl();\n-        scene.addEventHandler(TraversalEvent.ANY, h);\n-        keypadNodes[fromNumber - 1].requestFocus();\n-        TopMostTraversalEngine.trav(scene.getRoot(), keypadNodes[fromNumber - 1], direction, TraversalMethod.DEFAULT);\n-        if (fromNumber != toNumber) {\n-            assertEquals(1, h.getCallCounter());\n-            assertSame(keypadNodes[toNumber - 1], h.getLastNode());\n-        } else {\n-            assertEquals(0, h.getCallCounter());\n-        }\n-    }\n-\n@@ -201,19 +177,0 @@\n-\n-    private static final class TraverseListenerImpl implements EventHandler<TraversalEvent> {\n-        private int callCounter;\n-        private Node lastNode;\n-\n-        public int getCallCounter() {\n-            return callCounter;\n-        }\n-\n-        public Node getLastNode() {\n-            return lastNode;\n-        }\n-\n-        @Override\n-        public void handle(TraversalEvent ev) {\n-            ++callCounter;\n-            lastNode = ev.getNode();\n-        }\n-    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/traversal\/TraversalTest.java","additions":5,"deletions":48,"binary":false,"changes":53,"status":"modified"}]}