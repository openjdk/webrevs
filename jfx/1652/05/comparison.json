{"files":[{"patch":"@@ -89,1 +89,1 @@\n-            .csspropertytable thead th, .csspropertytable thead td {\n+            .csspropertytable thead th, .csspropertytable thead td, .csspropertytable tbody th.subheader {\n@@ -542,2 +542,1 @@\n-        supported by each Node type are given in the tables within this reference. Note that JavaFX does not currently\n-        support structural pseudo&#8209;classes.\n+        supported by each Node type are given in the tables within this reference.\n@@ -872,1 +871,0 @@\n-    <li>The structural pseudo&#8209;classes are not supported. <\/li>\n@@ -1532,1 +1530,1 @@\n-    <p class=\"example\">.root { abc: #f00 }<br>\n+    <p class=\"example\">:root { abc: #f00 }<br>\n@@ -1828,1 +1826,1 @@\n-    <p class=\"styleclass\">Style class: .root.popup<\/p>\n+    <p class=\"styleclass\">Style class: :root.popup<\/p>\n@@ -1830,1 +1828,1 @@\n-        Scene's root gets the .root style-class by default. If the Scene is the root scene of a PopupWindow, then the\n+        Scene's root gets the :root pseudo-class by default. If the Scene is the root scene of a PopupWindow, then the\n@@ -1832,1 +1830,1 @@\n-        the CSS rule <code>.root.popup { \/* declarations *\/ }<\/code>\n+        the CSS rule <code>:root.popup { \/* declarations *\/ }<\/code>\n@@ -2005,6 +2003,0 @@\n-      <thead>\n-        <tr>\n-        <th class=\"propertyname\" scope=\"col\">CSS Pseudo-class<\/th>\n-        <th scope=\"col\">Comments<\/th>\n-        <\/tr>\n-      <\/thead>\n@@ -2013,2 +2005,2 @@\n-        <th class=\"propertyname\" scope=\"row\">disabled<\/th>\n-          <td>applies when the <strong>disabled<\/strong> variable is true<\/td>\n+          <th class=\"propertyname subheader\" scope=\"col\">User Action Pseudo-classes<\/th>\n+          <th class=\"subheader\" scope=\"col\">Comments<\/th>\n@@ -2017,1 +2009,1 @@\n-        <th class=\"propertyname\" scope=\"row\">focused<\/th>\n+          <th class=\"propertyname\" scope=\"row\">focused<\/th>\n@@ -2021,1 +2013,1 @@\n-        <th class=\"propertyname\" scope=\"row\">focus-visible<\/th>\n+          <th class=\"propertyname\" scope=\"row\">focus-visible<\/th>\n@@ -2025,1 +2017,1 @@\n-        <th class=\"propertyname\" scope=\"row\">focus-within<\/th>\n+          <th class=\"propertyname\" scope=\"row\">focus-within<\/th>\n@@ -2029,1 +2021,1 @@\n-        <th class=\"propertyname\" scope=\"row\">hover<\/th>\n+          <th class=\"propertyname\" scope=\"row\">hover<\/th>\n@@ -2033,1 +2025,1 @@\n-        <th class=\"propertyname\" scope=\"row\">pressed<\/th>\n+          <th class=\"propertyname\" scope=\"row\">pressed<\/th>\n@@ -2037,3 +2029,31 @@\n-        <th class=\"propertyname\" scope=\"row\">show-mnemonic<\/th>\n-          <td>apples when the mnemonic affordance (typically an underscore)\n-            should be shown.<\/td>\n+          <th class=\"propertyname subheader\" scope=\"col\">Input Pseudo-classes<\/th>\n+          <th class=\"subheader\" scope=\"col\">Comments<\/th>\n+        <\/tr>\n+        <tr>\n+          <th class=\"propertyname\" scope=\"row\">disabled<\/th>\n+          <td>applies when the <strong>disabled<\/strong> variable is true<\/td>\n+        <\/tr>\n+        <tr>\n+          <th class=\"propertyname\" scope=\"row\">show-mnemonic<\/th>\n+          <td>applies when the mnemonic affordance (typically an underscore) should be shown<\/td>\n+        <\/tr>\n+        <tr>\n+          <th class=\"propertyname subheader\" scope=\"col\">Tree-Structural Pseudo-classes<\/th>\n+          <th class=\"subheader\" scope=\"col\">Comments<\/th>\n+        <\/tr>\n+        <tr>\n+          <th class=\"propertyname\" scope=\"row\">first-child<\/th>\n+          <td>applies when the node is the first child in its <code>Parent<\/code> container<\/td>\n+        <\/tr>\n+        <tr>\n+          <th class=\"propertyname\" scope=\"row\">last-child<\/th>\n+          <td>applies when the node is the last child in its <code>Parent<\/code> container<\/td>\n+        <\/tr>\n+        <tr>\n+          <th class=\"propertyname\" scope=\"row\">only-child<\/th>\n+          <td>applies when the node is the only child in its <code>Parent<\/code> container<\/td>\n+        <\/tr>\n+        <tr>\n+          <th class=\"propertyname\" scope=\"row\">nth-child()<\/th>\n+          <td>applies when the node is the n-th child in its <code>Parent<\/code> container\n+              (the only acceptable arguments are \"even\" and \"odd\")<\/td>\n@@ -2065,0 +2085,19 @@\n+    <h4>Pseudo-classes<\/h4>\n+    <table class=\"csspropertytable\">\n+        <caption>Available CSS Pseudo-classes<\/caption>\n+        <thead>\n+        <tr>\n+            <th class=\"propertyname\" scope=\"col\">CSS Pseudo-class<\/th>\n+            <th scope=\"col\">Comments<\/th>\n+        <\/tr>\n+        <\/thead>\n+        <tbody>\n+        <tr>\n+            <th class=\"propertyname\" scope=\"row\">root<\/th>\n+            <td>applies when the <code>Parent<\/code> is the root node of a <code>Scene<\/code> or <code>SubScene<\/code><\/td>\n+        <\/tr>\n+        <tr>\n+            <td colspan=\"2\" class=\"parents\" scope=\"row\">Also has all pseudo&#8209;classes of <a href=\"#node\">Node<\/a><\/td>\n+        <\/tr>\n+        <\/tbody>\n+    <\/table>\n@@ -4297,1 +4336,1 @@\n-    style-class .root.popup<\/p>\n+    style-class :root.popup<\/p>\n","filename":"modules\/javafx.graphics\/src\/main\/docs\/javafx\/scene\/doc-files\/cssref.html","additions":64,"deletions":25,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import javafx.css.PseudoClass;\n@@ -319,1 +320,19 @@\n-\n+        private static final PseudoClass FIRST_CHILD_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"first-child\");\n+        private static final PseudoClass LAST_CHILD_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"last-child\");\n+        private static final PseudoClass ONLY_CHILD_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"only-child\");\n+        private static final PseudoClass NTH_EVEN_CHILD_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"nth-child(even)\");\n+        private static final PseudoClass NTH_ODD_CHILD_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"nth-child(odd)\");\n+\n+        private static final List<PseudoClass> ONLY_CHILD_CLASSES = List.of(ONLY_CHILD_PSEUDO_CLASS,\n+                                                                            FIRST_CHILD_PSEUDO_CLASS,\n+                                                                            LAST_CHILD_PSEUDO_CLASS);\n+\n+        private static final List<PseudoClass> FIRST_CHILD_CLASSES = List.of(FIRST_CHILD_PSEUDO_CLASS);\n+\n+        private static void toggleStructuralPseudoClasses(Node node, List<PseudoClass> active) {\n+            node.pseudoClassStateChanged(FIRST_CHILD_PSEUDO_CLASS, active.contains(FIRST_CHILD_PSEUDO_CLASS));\n+            node.pseudoClassStateChanged(LAST_CHILD_PSEUDO_CLASS, active.contains(LAST_CHILD_PSEUDO_CLASS));\n+            node.pseudoClassStateChanged(ONLY_CHILD_PSEUDO_CLASS, active.contains(ONLY_CHILD_PSEUDO_CLASS));\n+            node.pseudoClassStateChanged(NTH_EVEN_CHILD_PSEUDO_CLASS, active.contains(NTH_EVEN_CHILD_PSEUDO_CLASS));\n+            node.pseudoClassStateChanged(NTH_ODD_CHILD_PSEUDO_CLASS, active.contains(NTH_ODD_CHILD_PSEUDO_CLASS));\n+        }\n@@ -327,0 +346,1 @@\n+            int firstDirtyChildIndex = -1;\n@@ -354,0 +374,8 @@\n+\n+                        toggleStructuralPseudoClasses(n, List.of());\n+                    }\n+\n+                    \/\/ Sub-changes are sorted by their 'from' index, so it is sufficient to record\n+                    \/\/ the index of the first change to separate unchanged from changed elements.\n+                    if (firstDirtyChildIndex < 0) {\n+                        firstDirtyChildIndex = from;\n@@ -405,0 +433,6 @@\n+                    \/\/ Sub-changes are sorted by their 'from' index, so it is sufficient to record\n+                    \/\/ the index of the first change to separate unchanged from changed elements.\n+                    if (firstDirtyChildIndex < 0) {\n+                        firstDirtyChildIndex = c.getFrom();\n+                    }\n+\n@@ -422,0 +456,25 @@\n+            \/\/ Toggle the \"only-child\" \/ \"first-child\" pseudo-classes on the first child.\n+            if (size() == 1) {\n+                toggleStructuralPseudoClasses(getFirst(), ONLY_CHILD_CLASSES);\n+            } else if (size() > 1 && firstDirtyChildIndex == 0) {\n+                toggleStructuralPseudoClasses(getFirst(), FIRST_CHILD_CLASSES);\n+            }\n+\n+            \/\/ Clear the \"last-child\" pseudo-class if it was set on the last non-modified child.\n+            if (firstDirtyChildIndex > 0) {\n+                get(firstDirtyChildIndex - 1).pseudoClassStateChanged(LAST_CHILD_PSEUDO_CLASS, false);\n+            }\n+\n+            \/\/ Add the \"last-child\" pseudo-class to the last child.\n+            if (size() > 0) {\n+                getLast().pseudoClassStateChanged(LAST_CHILD_PSEUDO_CLASS, true);\n+            }\n+\n+            \/\/ Toggle the \"nth-child(even)\" and \"nth-child(odd)\" pseudo-classes on all modified children.\n+            if (firstDirtyChildIndex >= 0) {\n+                for (int i = firstDirtyChildIndex, max = size(); i < max; ++i) {\n+                    Node n = get(i);\n+                    n.pseudoClassStateChanged(NTH_EVEN_CHILD_PSEUDO_CLASS, i % 2 != 0);\n+                    n.pseudoClassStateChanged(NTH_ODD_CHILD_PSEUDO_CLASS, i % 2 == 0);\n+                }\n+            }\n@@ -452,4 +511,2 @@\n-            c.reset();\n-            c.next();\n-            if (startIdx > c.getFrom()) {\n-                startIdx = c.getFrom();\n+            if (startIdx > firstDirtyChildIndex) {\n+                startIdx = firstDirtyChildIndex;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Parent.java","additions":62,"deletions":5,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+import javafx.css.PseudoClass;\n@@ -1209,1 +1210,3 @@\n-     *\n+     * <p>\n+     * The {@code :root} pseudo-class matches the root node.\n+     * <p>\n@@ -1227,1 +1230,0 @@\n-\n@@ -1261,0 +1263,1 @@\n+                        oldRoot.pseudoClassStateChanged(PseudoClass.getPseudoClass(\"root\"), false);\n@@ -1264,0 +1267,1 @@\n+                    _value.pseudoClassStateChanged(PseudoClass.getPseudoClass(\"root\"), true);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import javafx.css.PseudoClass;\n@@ -259,1 +260,3 @@\n-     *\n+     * <p>\n+     * The {@code :root} pseudo-class matches the root node.\n+     * <p>\n@@ -320,0 +323,1 @@\n+                        oldRoot.pseudoClassStateChanged(PseudoClass.getPseudoClass(\"root\"), false);\n@@ -323,0 +327,1 @@\n+                    _value.pseudoClassStateChanged(PseudoClass.getPseudoClass(\"root\"), true);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/SubScene.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -65,0 +66,1 @@\n+import javafx.scene.layout.Background;\n@@ -76,4 +78,1 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertNull;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -781,0 +780,17 @@\n+    @Test\n+    public void testRootPseudoClassSelectsRootNode() {\n+        var root = new StackPane();\n+\n+        root.getStylesheets().add(\"data:base64,\" + Base64.getEncoder().encodeToString(\"\"\"\n+            :root {\n+                -fx-background-color: red;\n+            }\n+            \"\"\".getBytes(StandardCharsets.UTF_8)));\n+\n+        assertNotEquals(Background.fill(Color.RED), root.getBackground());\n+\n+        Scene scene = new Scene(root);\n+        scene.getRoot().applyCss();\n+\n+        assertEquals(Background.fill(Color.RED), root.getBackground());\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/css\/StylesheetTest.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene;\n+\n+import javafx.css.PseudoClass;\n+import javafx.scene.Group;\n+import javafx.scene.Node;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class Parent_pseudoClasses_Test {\n+\n+    static final PseudoClass FIRST_CHILD = PseudoClass.getPseudoClass(\"first-child\");\n+    static final PseudoClass LAST_CHILD = PseudoClass.getPseudoClass(\"last-child\");\n+    static final PseudoClass ONLY_CHILD = PseudoClass.getPseudoClass(\"only-child\");\n+    static final PseudoClass NTH_EVEN_CHILD = PseudoClass.getPseudoClass(\"nth-child(even)\");\n+    static final PseudoClass NTH_ODD_CHILD = PseudoClass.getPseudoClass(\"nth-child(odd)\");\n+\n+    @Test\n+    void onlyChildPseudoClass() {\n+        var group = new Group();\n+        var child1 = new Group();\n+        var child2 = new Group();\n+        assertNotPseudoClass(ONLY_CHILD, child1);\n+        assertNotPseudoClass(ONLY_CHILD, child2);\n+        group.getChildren().add(child1);\n+        assertPseudoClass(ONLY_CHILD, child1);\n+        group.getChildren().removeFirst();\n+        assertNotPseudoClass(ONLY_CHILD, child1);\n+        group.getChildren().addAll(child1, child2);\n+        assertNotPseudoClass(ONLY_CHILD, child1);\n+        assertNotPseudoClass(ONLY_CHILD, child2);\n+        group.getChildren().removeFirst();\n+        assertNotPseudoClass(ONLY_CHILD, child1);\n+        assertPseudoClass(ONLY_CHILD, child2);\n+    }\n+\n+    @Test\n+    void firstChildPseudoClass() {\n+        var group = new Group();\n+        var child1 = new Group();\n+        var child2 = new Group();\n+        assertNotPseudoClass(FIRST_CHILD, child1);\n+        assertNotPseudoClass(FIRST_CHILD, child2);\n+        group.getChildren().add(child1);\n+        assertPseudoClass(FIRST_CHILD, child1);\n+        group.getChildren().add(child2);\n+        assertPseudoClass(FIRST_CHILD, child1);\n+        assertNotPseudoClass(FIRST_CHILD, child2);\n+        group.getChildren().removeFirst();\n+        assertNotPseudoClass(FIRST_CHILD, child1);\n+        assertPseudoClass(FIRST_CHILD, child2);\n+    }\n+\n+    @Test\n+    void lastChildPseudoClass() {\n+        var group = new Group();\n+        var child1 = new Group();\n+        var child2 = new Group();\n+        assertNotPseudoClass(LAST_CHILD, child1);\n+        assertNotPseudoClass(LAST_CHILD, child2);\n+        group.getChildren().add(child1);\n+        assertPseudoClass(LAST_CHILD, child1);\n+        group.getChildren().add(child2);\n+        assertNotPseudoClass(LAST_CHILD, child1);\n+        assertPseudoClass(LAST_CHILD, child2);\n+        group.getChildren().removeFirst();\n+        assertNotPseudoClass(LAST_CHILD, child1);\n+        assertPseudoClass(LAST_CHILD, child2);\n+        group.getChildren().removeFirst();\n+        assertNotPseudoClass(LAST_CHILD, child2);\n+    }\n+\n+    @Test\n+    void nthChildEvenOddPseudoClass() {\n+        var group = new Group();\n+        var child1 = new Group();\n+        var child2 = new Group();\n+        var child3 = new Group();\n+        var child4 = new Group();\n+\n+        \/\/ [child1, child2, child3, child4]\n+        group.getChildren().addAll(child1, child2, child3, child4);\n+        assertPseudoClass(NTH_EVEN_CHILD, child2, child4);\n+        assertNotPseudoClass(NTH_EVEN_CHILD, child1, child3);\n+        assertPseudoClass(NTH_ODD_CHILD, child1, child3);\n+        assertNotPseudoClass(NTH_ODD_CHILD, child2, child4);\n+\n+        \/\/ [child1, child2, child2b, child3, child4]\n+        var child2b = new Group();\n+        group.getChildren().add(2, child2b);\n+        assertPseudoClass(NTH_EVEN_CHILD, child2, child3);\n+        assertNotPseudoClass(NTH_EVEN_CHILD, child1, child2b, child4);\n+        assertPseudoClass(NTH_ODD_CHILD, child1, child2b, child4);\n+        assertNotPseudoClass(NTH_ODD_CHILD, child2, child3);\n+\n+        \/\/ [child1, child3, child4]\n+        group.getChildren().remove(1, 3);\n+        assertPseudoClass(NTH_EVEN_CHILD, child3);\n+        assertNotPseudoClass(NTH_EVEN_CHILD, child1, child2, child2b, child4);\n+        assertPseudoClass(NTH_ODD_CHILD, child1, child4);\n+        assertNotPseudoClass(NTH_ODD_CHILD, child2, child2b, child3);\n+    }\n+\n+    private void assertPseudoClass(PseudoClass pseudoClass, Node... nodes) {\n+        for (Node node : nodes) {\n+            assertTrue(node.getPseudoClassStates().contains(pseudoClass));\n+        }\n+    }\n+\n+    private void assertNotPseudoClass(PseudoClass pseudoClass, Node... nodes) {\n+        for (Node node : nodes) {\n+            assertFalse(node.getPseudoClassStates().contains(pseudoClass));\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/Parent_pseudoClasses_Test.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+import javafx.css.PseudoClass;\n@@ -240,0 +241,12 @@\n+    @Test\n+    public void testRootPseudoClassIsSetOnRootNode() {\n+        var root = PseudoClass.getPseudoClass(\"root\");\n+        Scene scene = new Scene(new Group());\n+        Group g = new Group();\n+        assertFalse(g.getPseudoClassStates().contains(root));\n+        scene.setRoot(g);\n+        assertTrue(g.getPseudoClassStates().contains(root));\n+        scene.setRoot(new Group());\n+        assertFalse(g.getPseudoClassStates().contains(root));\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/SceneTest.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import javafx.css.PseudoClass;\n@@ -152,0 +153,12 @@\n+    @Test\n+    public void testRootPseudoClassIsSetOnRootNode() {\n+        var root = PseudoClass.getPseudoClass(\"root\");\n+        SubScene scene = new SubScene(new Group(), 10, 10);\n+        Group g = new Group();\n+        assertFalse(g.getPseudoClassStates().contains(root));\n+        scene.setRoot(g);\n+        assertTrue(g.getPseudoClassStates().contains(root));\n+        scene.setRoot(new Group());\n+        assertFalse(g.getPseudoClassStates().contains(root));\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/SubSceneTest.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}