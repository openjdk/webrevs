{"files":[{"patch":"@@ -89,1 +89,1 @@\n-            .csspropertytable thead th, .csspropertytable thead td {\n+            .csspropertytable thead th, .csspropertytable thead td, .csspropertytable tbody th.subheader {\n@@ -542,2 +542,1 @@\n-        supported by each Node type are given in the tables within this reference. Note that JavaFX does not currently\n-        support structural pseudo&#8209;classes.\n+        supported by each Node type are given in the tables within this reference.\n@@ -872,1 +871,0 @@\n-    <li>The structural pseudo&#8209;classes are not supported. <\/li>\n@@ -1532,1 +1530,1 @@\n-    <p class=\"example\">.root { abc: #f00 }<br>\n+    <p class=\"example\">:root { abc: #f00 }<br>\n@@ -1828,1 +1826,1 @@\n-    <p class=\"styleclass\">Style class: .root.popup<\/p>\n+    <p class=\"styleclass\">Style class: :root.popup<\/p>\n@@ -1830,1 +1828,1 @@\n-        Scene's root gets the .root style-class by default. If the Scene is the root scene of a PopupWindow, then the\n+        Scene's root gets the :root pseudo-class by default. If the Scene is the root scene of a PopupWindow, then the\n@@ -1832,1 +1830,1 @@\n-        the CSS rule <code>.root.popup { \/* declarations *\/ }<\/code>\n+        the CSS rule <code>:root.popup { \/* declarations *\/ }<\/code>\n@@ -2005,6 +2003,0 @@\n-      <thead>\n-        <tr>\n-        <th class=\"propertyname\" scope=\"col\">CSS Pseudo-class<\/th>\n-        <th scope=\"col\">Comments<\/th>\n-        <\/tr>\n-      <\/thead>\n@@ -2013,2 +2005,2 @@\n-        <th class=\"propertyname\" scope=\"row\">disabled<\/th>\n-          <td>applies when the <strong>disabled<\/strong> variable is true<\/td>\n+          <th class=\"propertyname subheader\" scope=\"col\">User Action Pseudo-classes<\/th>\n+          <th class=\"subheader\" scope=\"col\">Comments<\/th>\n@@ -2017,1 +2009,1 @@\n-        <th class=\"propertyname\" scope=\"row\">focused<\/th>\n+          <th class=\"propertyname\" scope=\"row\">focused<\/th>\n@@ -2021,1 +2013,1 @@\n-        <th class=\"propertyname\" scope=\"row\">focus-visible<\/th>\n+          <th class=\"propertyname\" scope=\"row\">focus-visible<\/th>\n@@ -2025,1 +2017,1 @@\n-        <th class=\"propertyname\" scope=\"row\">focus-within<\/th>\n+          <th class=\"propertyname\" scope=\"row\">focus-within<\/th>\n@@ -2029,1 +2021,1 @@\n-        <th class=\"propertyname\" scope=\"row\">hover<\/th>\n+          <th class=\"propertyname\" scope=\"row\">hover<\/th>\n@@ -2033,1 +2025,1 @@\n-        <th class=\"propertyname\" scope=\"row\">pressed<\/th>\n+          <th class=\"propertyname\" scope=\"row\">pressed<\/th>\n@@ -2037,3 +2029,32 @@\n-        <th class=\"propertyname\" scope=\"row\">show-mnemonic<\/th>\n-          <td>apples when the mnemonic affordance (typically an underscore)\n-            should be shown.<\/td>\n+          <th class=\"propertyname subheader\" scope=\"col\">Input Pseudo-classes<\/th>\n+          <th class=\"subheader\" scope=\"col\">Comments<\/th>\n+        <\/tr>\n+        <tr>\n+          <th class=\"propertyname\" scope=\"row\">disabled<\/th>\n+          <td>applies when the <strong>disabled<\/strong> variable is true<\/td>\n+        <\/tr>\n+        <tr>\n+          <th class=\"propertyname\" scope=\"row\">show-mnemonic<\/th>\n+          <td>applies when the mnemonic affordance (typically an underscore) should be shown<\/td>\n+        <\/tr>\n+        <tr>\n+          <th class=\"propertyname subheader\" scope=\"col\">Tree-Structural Pseudo-classes<\/th>\n+          <th class=\"subheader\" scope=\"col\">Comments<\/th>\n+        <\/tr>\n+        <tr>\n+          <th class=\"propertyname\" scope=\"row\">first-child<\/th>\n+          <td>applies when the node is the first child in its <code>Parent<\/code> container<\/td>\n+        <\/tr>\n+        <tr>\n+          <th class=\"propertyname\" scope=\"row\">last-child<\/th>\n+          <td>applies when the node is the last child in its <code>Parent<\/code> container<\/td>\n+        <\/tr>\n+        <tr>\n+          <th class=\"propertyname\" scope=\"row\">only-child<\/th>\n+          <td>applies when the node is the only child in its <code>Parent<\/code> container<\/td>\n+        <\/tr>\n+        <tr>\n+          <th class=\"propertyname\" scope=\"row\">nth-child()<\/th>\n+          <td>applies when the node is the n-th child in its <code>Parent<\/code> container\n+              (the only acceptable arguments are \"even\" and \"odd\": the first child at index 0\n+              matches \"odd\", the second child at index 1 matches \"even\", etc.)<\/td>\n@@ -2065,0 +2086,19 @@\n+    <h4>Pseudo-classes<\/h4>\n+    <table class=\"csspropertytable\">\n+        <caption>Available CSS Pseudo-classes<\/caption>\n+        <thead>\n+        <tr>\n+            <th class=\"propertyname\" scope=\"col\">CSS Pseudo-class<\/th>\n+            <th scope=\"col\">Comments<\/th>\n+        <\/tr>\n+        <\/thead>\n+        <tbody>\n+        <tr>\n+            <th class=\"propertyname\" scope=\"row\">root<\/th>\n+            <td>applies when the <code>Parent<\/code> is the root node of a <code>Scene<\/code> or <code>SubScene<\/code><\/td>\n+        <\/tr>\n+        <tr>\n+            <td colspan=\"2\" class=\"parents\" scope=\"row\">Also has all pseudo&#8209;classes of <a href=\"#node\">Node<\/a><\/td>\n+        <\/tr>\n+        <\/tbody>\n+    <\/table>\n@@ -2070,1 +2110,2 @@\n-      pseudo&#8209;classes. However, the root node of the scene is assigned the style\n+      pseudo&#8209;classes. However, the root node of the scene matches the\n+      structural pseudo-class <code>:root<\/code>, as well as the legacy style\n@@ -4297,1 +4338,1 @@\n-    style-class .root.popup<\/p>\n+    style-class :root.popup<\/p>\n","filename":"modules\/javafx.graphics\/src\/main\/docs\/javafx\/scene\/doc-files\/cssref.html","additions":67,"deletions":26,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import javafx.css.PseudoClass;\n@@ -319,1 +320,5 @@\n-\n+        private static final PseudoClass FIRST_CHILD_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"first-child\");\n+        private static final PseudoClass LAST_CHILD_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"last-child\");\n+        private static final PseudoClass ONLY_CHILD_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"only-child\");\n+        private static final PseudoClass NTH_EVEN_CHILD_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"nth-child(even)\");\n+        private static final PseudoClass NTH_ODD_CHILD_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"nth-child(odd)\");\n@@ -327,0 +332,1 @@\n+            int firstDirtyChildIndex = -1;\n@@ -356,0 +362,6 @@\n+                    \/\/ Sub-changes are sorted by their 'from' index, so it is sufficient to record\n+                    \/\/ the index of the first change to separate unchanged from changed elements.\n+                    if (firstDirtyChildIndex < 0) {\n+                        firstDirtyChildIndex = from;\n+                    }\n+\n@@ -405,0 +417,6 @@\n+                    \/\/ Sub-changes are sorted by their 'from' index, so it is sufficient to record\n+                    \/\/ the index of the first change to separate unchanged from changed elements.\n+                    if (firstDirtyChildIndex < 0) {\n+                        firstDirtyChildIndex = c.getFrom();\n+                    }\n+\n@@ -422,1 +440,0 @@\n-\n@@ -452,4 +469,2 @@\n-            c.reset();\n-            c.next();\n-            if (startIdx > c.getFrom()) {\n-                startIdx = c.getFrom();\n+            if (startIdx > firstDirtyChildIndex) {\n+                startIdx = firstDirtyChildIndex;\n@@ -466,0 +481,3 @@\n+\n+            c.reset();\n+            updateStructuralPseudoClasses(c, firstDirtyChildIndex);\n@@ -468,0 +486,46 @@\n+        private void updateStructuralPseudoClasses(Change<Node> change, int firstDirtyChildIndex) {\n+            while (change.next()) {\n+                if (change.wasRemoved()) {\n+                    for (Node node : change.getRemoved()) {\n+                        node.pseudoClassStateChanged(FIRST_CHILD_PSEUDO_CLASS, false);\n+                        node.pseudoClassStateChanged(LAST_CHILD_PSEUDO_CLASS, false);\n+                        node.pseudoClassStateChanged(ONLY_CHILD_PSEUDO_CLASS, false);\n+                        node.pseudoClassStateChanged(NTH_EVEN_CHILD_PSEUDO_CLASS, false);\n+                        node.pseudoClassStateChanged(NTH_ODD_CHILD_PSEUDO_CLASS, false);\n+                    }\n+                }\n+            }\n+\n+            int size = size();\n+\n+            \/\/ Toggle the \"only-child\" \/ \"first-child\" \/ \"last-child\" pseudo-classes.\n+            if (size == 1) {\n+                Node first = getFirst();\n+                first.pseudoClassStateChanged(FIRST_CHILD_PSEUDO_CLASS, true);\n+                first.pseudoClassStateChanged(LAST_CHILD_PSEUDO_CLASS, true);\n+                first.pseudoClassStateChanged(ONLY_CHILD_PSEUDO_CLASS, true);\n+            } else if (size > 1) {\n+                Node first = getFirst(), last = getLast();\n+                first.pseudoClassStateChanged(FIRST_CHILD_PSEUDO_CLASS, true);\n+                first.pseudoClassStateChanged(LAST_CHILD_PSEUDO_CLASS, false);\n+                first.pseudoClassStateChanged(ONLY_CHILD_PSEUDO_CLASS, false);\n+                last.pseudoClassStateChanged(LAST_CHILD_PSEUDO_CLASS, true);\n+\n+                if (firstDirtyChildIndex > 0) {\n+                    \/\/ Clear the \"last-child\" pseudo-class on the last non-modified child.\n+                    Node lastNonModified = get(firstDirtyChildIndex - 1);\n+                    if (last != lastNonModified) {\n+                        lastNonModified.pseudoClassStateChanged(LAST_CHILD_PSEUDO_CLASS, false);\n+                    }\n+                }\n+            }\n+\n+            \/\/ Toggle the \"nth-child(even)\" and \"nth-child(odd)\" pseudo-classes on all modified children.\n+            if (firstDirtyChildIndex >= 0) {\n+                for (int i = firstDirtyChildIndex; i < size; ++i) {\n+                    Node n = get(i);\n+                    n.pseudoClassStateChanged(NTH_EVEN_CHILD_PSEUDO_CLASS, i % 2 != 0);\n+                    n.pseudoClassStateChanged(NTH_ODD_CHILD_PSEUDO_CLASS, i % 2 == 0);\n+                }\n+            }\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Parent.java","additions":70,"deletions":6,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+import javafx.css.PseudoClass;\n@@ -1209,1 +1210,3 @@\n-     *\n+     * <p>\n+     * The {@code :root} pseudo-class matches the root node.\n+     * <p>\n@@ -1227,1 +1230,0 @@\n-\n@@ -1261,0 +1263,1 @@\n+                        oldRoot.pseudoClassStateChanged(PseudoClass.getPseudoClass(\"root\"), false);\n@@ -1264,0 +1267,1 @@\n+                    _value.pseudoClassStateChanged(PseudoClass.getPseudoClass(\"root\"), true);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import javafx.css.PseudoClass;\n@@ -259,1 +260,3 @@\n-     *\n+     * <p>\n+     * The {@code :root} pseudo-class matches the root node.\n+     * <p>\n@@ -320,0 +323,1 @@\n+                        oldRoot.pseudoClassStateChanged(PseudoClass.getPseudoClass(\"root\"), false);\n@@ -323,0 +327,1 @@\n+                    _value.pseudoClassStateChanged(PseudoClass.getPseudoClass(\"root\"), true);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/SubScene.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -65,0 +66,1 @@\n+import javafx.scene.layout.Background;\n@@ -76,4 +78,1 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertNull;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -781,0 +780,17 @@\n+    @Test\n+    public void testRootPseudoClassSelectsRootNode() {\n+        var root = new StackPane();\n+        var _ = new Scene(root);\n+\n+        root.applyCss();\n+        assertNotEquals(Background.fill(Color.RED), root.getBackground());\n+\n+        root.getStylesheets().add(\"data:base64,\" + Base64.getEncoder().encodeToString(\"\"\"\n+            :root {\n+                -fx-background-color: red;\n+            }\n+            \"\"\".getBytes(StandardCharsets.UTF_8)));\n+\n+        root.applyCss();\n+        assertEquals(Background.fill(Color.RED), root.getBackground());\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/css\/StylesheetTest.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,340 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javafx.css.PseudoClass;\n+import javafx.scene.Group;\n+import javafx.scene.Node;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class Parent_structuralPseudoClasses_Test {\n+\n+    static final PseudoClass FIRST_CHILD = PseudoClass.getPseudoClass(\"first-child\");\n+    static final PseudoClass LAST_CHILD = PseudoClass.getPseudoClass(\"last-child\");\n+    static final PseudoClass ONLY_CHILD = PseudoClass.getPseudoClass(\"only-child\");\n+    static final PseudoClass NTH_EVEN_CHILD = PseudoClass.getPseudoClass(\"nth-child(even)\");\n+    static final PseudoClass NTH_ODD_CHILD = PseudoClass.getPseudoClass(\"nth-child(odd)\");\n+    static final PseudoClass[] EMPTY = new PseudoClass[0];\n+    static final PseudoClass[] ALL = new PseudoClass[] { FIRST_CHILD, LAST_CHILD, ONLY_CHILD, NTH_EVEN_CHILD, NTH_ODD_CHILD };\n+\n+    @Test\n+    void multipleNodes_removeFromFront() {\n+        var group = new Group();\n+        var child1 = new Group();\n+        var child2 = new Group();\n+        var child3 = new Group();\n+        var child4 = new Group();\n+\n+        \/\/ child1 = [first-child, nth-child(odd)]\n+        \/\/ child2 = [nth-child(even)]\n+        \/\/ child3 = [nth-child(odd)]\n+        \/\/ child4 = [last-child, nth-child(even)]\n+        group.getChildren().addAll(child1, child2, child3, child4);\n+        assertOnlyPseudoClasses(child1, FIRST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child2, NTH_EVEN_CHILD);\n+        assertOnlyPseudoClasses(child3, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child4, LAST_CHILD, NTH_EVEN_CHILD);\n+\n+        \/\/ child1 = []\n+        \/\/ child2 = [first-child, last-child, nth-child(odd)]\n+        \/\/ child3 = [nth-child(even)]\n+        \/\/ child4 = [last-child, nth-child(odd)]\n+        group.getChildren().removeFirst();\n+        assertOnlyPseudoClasses(child1, EMPTY);\n+        assertOnlyPseudoClasses(child2, FIRST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child3, NTH_EVEN_CHILD);\n+        assertOnlyPseudoClasses(child4, LAST_CHILD, NTH_ODD_CHILD);\n+\n+        \/\/ child1 = []\n+        \/\/ child2 = []\n+        \/\/ child3 = [first-child, nth-child(odd)]\n+        \/\/ child4 = [last-child, nth-child(even)]\n+        group.getChildren().removeFirst();\n+        assertOnlyPseudoClasses(child1, EMPTY);\n+        assertOnlyPseudoClasses(child2, EMPTY);\n+        assertOnlyPseudoClasses(child3, FIRST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child4, LAST_CHILD, NTH_EVEN_CHILD);\n+\n+        \/\/ child1 = []\n+        \/\/ child2 = []\n+        \/\/ child3 = []\n+        \/\/ child4 = [only-child, first-child, last-child, nth-child(odd)]\n+        group.getChildren().removeFirst();\n+        assertOnlyPseudoClasses(child1, EMPTY);\n+        assertOnlyPseudoClasses(child2, EMPTY);\n+        assertOnlyPseudoClasses(child3, EMPTY);\n+        assertOnlyPseudoClasses(child4, ONLY_CHILD, FIRST_CHILD, LAST_CHILD, NTH_ODD_CHILD);\n+    }\n+\n+    @Test\n+    void multipleNodes_removeFromBack() {\n+        var group = new Group();\n+        var child1 = new Group();\n+        var child2 = new Group();\n+        var child3 = new Group();\n+        var child4 = new Group();\n+\n+        \/\/ child1 = [first-child, nth-child(odd)]\n+        \/\/ child2 = [nth-child(even)]\n+        \/\/ child3 = [nth-child(odd)]\n+        \/\/ child4 = [last-child, nth-child(even)]\n+        group.getChildren().addAll(child1, child2, child3, child4);\n+        assertOnlyPseudoClasses(child1, FIRST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child2, NTH_EVEN_CHILD);\n+        assertOnlyPseudoClasses(child3, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child4, LAST_CHILD, NTH_EVEN_CHILD);\n+\n+        \/\/ child1 = [first-child, last-child, nth-child(odd)]\n+        \/\/ child2 = [nth-child(even)]\n+        \/\/ child3 = [last-child, nth-child(odd)]\n+        \/\/ child4 = []\n+        group.getChildren().removeLast();\n+        assertOnlyPseudoClasses(child1, FIRST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child2, NTH_EVEN_CHILD);\n+        assertOnlyPseudoClasses(child3, LAST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child4, EMPTY);\n+\n+        \/\/ child1 = [first-child, nth-child(odd)]\n+        \/\/ child2 = [last-child, nth-child(even)]\n+        \/\/ child3 = []\n+        \/\/ child4 = []\n+        group.getChildren().removeLast();\n+        assertOnlyPseudoClasses(child1, FIRST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child2, LAST_CHILD, NTH_EVEN_CHILD);\n+        assertOnlyPseudoClasses(child3, EMPTY);\n+        assertOnlyPseudoClasses(child4, EMPTY);\n+\n+        \/\/ child1 = [only-child, first-child, last-child, nth-child(odd)]\n+        \/\/ child2 = []\n+        \/\/ child3 = []\n+        \/\/ child4 = []\n+        group.getChildren().removeLast();\n+        assertOnlyPseudoClasses(child1, ONLY_CHILD, FIRST_CHILD, LAST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child2, EMPTY);\n+        assertOnlyPseudoClasses(child3, EMPTY);\n+        assertOnlyPseudoClasses(child4, EMPTY);\n+    }\n+\n+    @Test\n+    void multipleNodes_removeInterior() {\n+        var group = new Group();\n+        var child1 = new Group();\n+        var child2 = new Group();\n+        var child3 = new Group();\n+        var child4 = new Group();\n+\n+        \/\/ child1 = [first-child, nth-child(odd)]\n+        \/\/ child2 = [nth-child(even)]\n+        \/\/ child3 = [nth-child(odd)]\n+        \/\/ child4 = [last-child, nth-child(even)]\n+        group.getChildren().addAll(child1, child2, child3, child4);\n+        assertOnlyPseudoClasses(child1, FIRST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child2, NTH_EVEN_CHILD);\n+        assertOnlyPseudoClasses(child3, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child4, LAST_CHILD, NTH_EVEN_CHILD);\n+\n+        \/\/ child1 = [first-child, nth-child(odd)]\n+        \/\/ child2 = []\n+        \/\/ child3 = [nth-child(even)]\n+        \/\/ child4 = [last-child, nth-child(odd)]\n+        group.getChildren().remove(1);\n+        assertOnlyPseudoClasses(child1, FIRST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child2, EMPTY);\n+        assertOnlyPseudoClasses(child3, NTH_EVEN_CHILD);\n+        assertOnlyPseudoClasses(child4, LAST_CHILD, NTH_ODD_CHILD);\n+\n+        \/\/ child1 = [first-child, nth-child(odd)]\n+        \/\/ child2 = []\n+        \/\/ child3 = []\n+        \/\/ child4 = [last-child, nth-child(even)]\n+        group.getChildren().remove(1);\n+        assertOnlyPseudoClasses(child1, FIRST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child2, EMPTY);\n+        assertOnlyPseudoClasses(child3, EMPTY);\n+        assertOnlyPseudoClasses(child4, LAST_CHILD, NTH_EVEN_CHILD);\n+    }\n+\n+    @Test\n+    void multipleNodes_removeInteriorRange() {\n+        var group = new Group();\n+        var child1 = new Group();\n+        var child2 = new Group();\n+        var child3 = new Group();\n+        var child4 = new Group();\n+\n+        \/\/ child1 = [first-child, nth-child(odd)]\n+        \/\/ child2 = [nth-child(even)]\n+        \/\/ child3 = [nth-child(odd)]\n+        \/\/ child4 = [last-child, nth-child(even)]\n+        group.getChildren().addAll(child1, child2, child3, child4);\n+        assertOnlyPseudoClasses(child1, FIRST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child2, NTH_EVEN_CHILD);\n+        assertOnlyPseudoClasses(child3, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child4, LAST_CHILD, NTH_EVEN_CHILD);\n+\n+        \/\/ child1 = [first-child, nth-child(odd)]\n+        \/\/ child2 = []\n+        \/\/ child3 = []\n+        \/\/ child4 = [last-child, nth-child(even)]\n+        group.getChildren().removeAll(child2, child3);\n+        assertOnlyPseudoClasses(child1, FIRST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child2, EMPTY);\n+        assertOnlyPseudoClasses(child3, EMPTY);\n+        assertOnlyPseudoClasses(child4, LAST_CHILD, NTH_EVEN_CHILD);\n+    }\n+\n+    @Test\n+    @Disabled(\"JDK-8233179\")\n+    void multipleNodes_permutation() {\n+        var group = new Group();\n+        var child1 = new Group();\n+        var child2 = new Group();\n+        var child3 = new Group();\n+        var child4 = new Group();\n+\n+        \/\/ child1 = [first-child, nth-child(odd)]\n+        \/\/ child2 = [nth-child(even)]\n+        \/\/ child3 = [nth-child(odd)]\n+        \/\/ child4 = [last-child, nth-child(even)]\n+        group.getChildren().addAll(child1, child2, child3, child4);\n+        assertOnlyPseudoClasses(child1, FIRST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child2, NTH_EVEN_CHILD);\n+        assertOnlyPseudoClasses(child3, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child4, LAST_CHILD, NTH_EVEN_CHILD);\n+\n+        \/\/ child1 = [first-child, nth-child(odd)]\n+        \/\/ child2 = [nth-child(even)]\n+        \/\/ child4 = [nth-child(odd)]\n+        \/\/ child3 = [last-child, nth-child(even)]\n+        group.getChildren().sort((o1, o2) -> { \/\/ swap child3 and child4\n+            if (o1 == child3) return o2 == child4 ? 1 : 0;\n+            if (o1 == child4) return o2 == child3 ? -1 : 0;\n+            return 0;\n+        });\n+\n+        assertOnlyPseudoClasses(child1, FIRST_CHILD, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child2, NTH_EVEN_CHILD);\n+        assertOnlyPseudoClasses(child4, NTH_ODD_CHILD);\n+        assertOnlyPseudoClasses(child3, LAST_CHILD, NTH_EVEN_CHILD);\n+    }\n+\n+    @Test\n+    void firstChildPseudoClass() {\n+        var group = new Group();\n+        var child1 = new Group();\n+        var child2 = new Group();\n+        assertNotPseudoClass(FIRST_CHILD, child1);\n+        assertNotPseudoClass(FIRST_CHILD, child2);\n+        group.getChildren().add(child1);\n+        assertPseudoClass(FIRST_CHILD, child1);\n+        group.getChildren().add(child2);\n+        assertPseudoClass(FIRST_CHILD, child1);\n+        assertNotPseudoClass(FIRST_CHILD, child2);\n+        group.getChildren().removeFirst();\n+        assertNotPseudoClass(FIRST_CHILD, child1);\n+        assertPseudoClass(FIRST_CHILD, child2);\n+    }\n+\n+    @Test\n+    void lastChildPseudoClass() {\n+        var group = new Group();\n+        var child1 = new Group();\n+        var child2 = new Group();\n+        assertNotPseudoClass(LAST_CHILD, child1);\n+        assertNotPseudoClass(LAST_CHILD, child2);\n+        group.getChildren().add(child1);\n+        assertPseudoClass(LAST_CHILD, child1);\n+        group.getChildren().add(child2);\n+        assertNotPseudoClass(LAST_CHILD, child1);\n+        assertPseudoClass(LAST_CHILD, child2);\n+        group.getChildren().removeFirst();\n+        assertNotPseudoClass(LAST_CHILD, child1);\n+        assertPseudoClass(LAST_CHILD, child2);\n+        group.getChildren().removeFirst();\n+        assertNotPseudoClass(LAST_CHILD, child2);\n+    }\n+\n+    @Test\n+    void nthChildEvenOddPseudoClass() {\n+        var group = new Group();\n+        var child1 = new Group();\n+        var child2 = new Group();\n+        var child3 = new Group();\n+        var child4 = new Group();\n+\n+        \/\/ [child1, child2, child3, child4]\n+        group.getChildren().addAll(child1, child2, child3, child4);\n+        assertPseudoClass(NTH_EVEN_CHILD, child2, child4);\n+        assertNotPseudoClass(NTH_EVEN_CHILD, child1, child3);\n+        assertPseudoClass(NTH_ODD_CHILD, child1, child3);\n+        assertNotPseudoClass(NTH_ODD_CHILD, child2, child4);\n+\n+        \/\/ [child1, child2, child2b, child3, child4]\n+        var child2b = new Group();\n+        group.getChildren().add(2, child2b);\n+        assertPseudoClass(NTH_EVEN_CHILD, child2, child3);\n+        assertNotPseudoClass(NTH_EVEN_CHILD, child1, child2b, child4);\n+        assertPseudoClass(NTH_ODD_CHILD, child1, child2b, child4);\n+        assertNotPseudoClass(NTH_ODD_CHILD, child2, child3);\n+\n+        \/\/ [child1, child3, child4]\n+        group.getChildren().remove(1, 3);\n+        assertPseudoClass(NTH_EVEN_CHILD, child3);\n+        assertNotPseudoClass(NTH_EVEN_CHILD, child1, child2, child2b, child4);\n+        assertPseudoClass(NTH_ODD_CHILD, child1, child4);\n+        assertNotPseudoClass(NTH_ODD_CHILD, child2, child2b, child3);\n+    }\n+\n+    private void assertOnlyPseudoClasses(Node node, PseudoClass... pseudoClass) {\n+        List<PseudoClass> remaining = new ArrayList<>(List.of(ALL));\n+\n+        for (PseudoClass pc : pseudoClass) {\n+            assertTrue(node.getPseudoClassStates().contains(pc));\n+            remaining.remove(pc);\n+        }\n+\n+        for (PseudoClass pc : remaining) {\n+            assertFalse(node.getPseudoClassStates().contains(pc));\n+        }\n+    }\n+\n+    private void assertPseudoClass(PseudoClass pseudoClass, Node... nodes) {\n+        for (Node node : nodes) {\n+            assertTrue(node.getPseudoClassStates().contains(pseudoClass));\n+        }\n+    }\n+\n+    private void assertNotPseudoClass(PseudoClass pseudoClass, Node... nodes) {\n+        for (Node node : nodes) {\n+            assertFalse(node.getPseudoClassStates().contains(pseudoClass));\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/Parent_structuralPseudoClasses_Test.java","additions":340,"deletions":0,"binary":false,"changes":340,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+import javafx.css.PseudoClass;\n@@ -240,0 +241,12 @@\n+    @Test\n+    public void testRootPseudoClassIsSetOnRootNode() {\n+        var root = PseudoClass.getPseudoClass(\"root\");\n+        Scene scene = new Scene(new Group());\n+        Group g = new Group();\n+        assertFalse(g.getPseudoClassStates().contains(root));\n+        scene.setRoot(g);\n+        assertTrue(g.getPseudoClassStates().contains(root));\n+        scene.setRoot(new Group());\n+        assertFalse(g.getPseudoClassStates().contains(root));\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/SceneTest.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import javafx.css.PseudoClass;\n@@ -152,0 +153,12 @@\n+    @Test\n+    public void testRootPseudoClassIsSetOnRootNode() {\n+        var root = PseudoClass.getPseudoClass(\"root\");\n+        SubScene scene = new SubScene(new Group(), 10, 10);\n+        Group g = new Group();\n+        assertFalse(g.getPseudoClassStates().contains(root));\n+        scene.setRoot(g);\n+        assertTrue(g.getPseudoClassStates().contains(root));\n+        scene.setRoot(new Group());\n+        assertFalse(g.getPseudoClassStates().contains(root));\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/SubSceneTest.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}