{"files":[{"patch":"@@ -41,1 +41,2 @@\n-    ;\n+    STAGE_STYLE_EXTENDED(\"StageStyle.EXTENDED\"),\n+    HEADER_BAR(\"HeaderBar\");\n@@ -55,0 +56,10 @@\n+    private static boolean enabledForTesting;\n+\n+    \/**\n+     * Enables preview features and suppresses the warning.\n+     * <p>\n+     * This method is only used for testing purposes.\n+     *\/\n+    public static void enableForTesting() {\n+        enabledForTesting = true;\n+    }\n@@ -65,1 +76,3 @@\n-        if (!enabled) {\n+        if (enabledForTesting) {\n+            \/\/ do nothing\n+        } else if (!enabled) {\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/PreviewFeature.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n@@ -33,0 +35,2 @@\n+    private ReflectionUtils() {}\n+\n@@ -37,1 +41,2 @@\n-    public static Object getFieldValue(Object object, String fieldName) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T getFieldValue(Object object, String fieldName) {\n@@ -53,1 +58,1 @@\n-                    return field.get(object);\n+                    return (T)field.get(object);\n@@ -64,0 +69,37 @@\n+\n+    \/**\n+     * Invokes the specified method on the object, and returns a value.\n+     * The method can be declared on any of the object's inherited classes.\n+     *\n+     * @param object the object on which the method will be invoked\n+     * @param methodName the method name\n+     * @param args the arguments\n+     * @return the return value\n+     *\/\n+    public static Object invokeMethod(Object object, String methodName, Class<?>[] parameterTypes, Object... args) {\n+        Function<Class<?>, Method> getMethod = cls -> {\n+            try {\n+                var method = cls.getDeclaredMethod(methodName, parameterTypes);\n+                method.setAccessible(true);\n+                return method;\n+            } catch (NoSuchMethodException e) {\n+                return null;\n+            }\n+        };\n+\n+        Class<?> cls = object.getClass();\n+        while (cls != null) {\n+            Method method = getMethod.apply(cls);\n+            if (method != null) {\n+                try {\n+                    return method.invoke(object, args);\n+                } catch (IllegalAccessException | InvocationTargetException e) {\n+                    throw new AssertionError(e);\n+                }\n+            }\n+\n+            cls = cls.getSuperclass();\n+        }\n+\n+        throw new AssertionError(\"Method not found: \" + methodName);\n+    }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/util\/ReflectionUtils.java","additions":45,"deletions":3,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -714,0 +714,6 @@\n+    protected abstract boolean _supportsExtendedWindows();\n+    public final boolean supportsExtendedWindows() {\n+        checkEventThread();\n+        return _supportsExtendedWindows();\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/Application.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui;\n+\n+import javafx.geometry.Dimension2D;\n+import javafx.scene.layout.HeaderBar;\n+import javafx.stage.StageStyle;\n+import java.util.Objects;\n+\n+\/**\n+ * Provides metrics about the header buttons of {@link StageStyle#EXTENDED} windows.\n+ *\n+ * @param leftInset the size of the left inset\n+ * @param rightInset the size of the right inset\n+ * @param minHeight the minimum height of the window buttons\n+ * @see HeaderButtonOverlay\n+ * @see HeaderBar\n+ *\/\n+public record HeaderButtonMetrics(Dimension2D leftInset, Dimension2D rightInset, double minHeight) {\n+\n+    public static HeaderButtonMetrics EMPTY = new HeaderButtonMetrics(new Dimension2D(0, 0), new Dimension2D(0, 0), 0);\n+\n+    public HeaderButtonMetrics {\n+        Objects.requireNonNull(leftInset);\n+        Objects.requireNonNull(rightInset);\n+\n+        if (minHeight < 0) {\n+            throw new IllegalArgumentException(\"minHeight cannot be negative\");\n+        }\n+    }\n+\n+    public double totalInsetWidth() {\n+        return leftInset.getWidth() + rightInset.getWidth();\n+    }\n+\n+    public double maxInsetHeight() {\n+        return Math.max(leftInset.getHeight(), rightInset.getHeight());\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/HeaderButtonMetrics.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,683 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui;\n+\n+import com.sun.glass.events.MouseEvent;\n+import com.sun.javafx.binding.ObjectConstant;\n+import com.sun.javafx.util.Utils;\n+import javafx.beans.property.DoubleProperty;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.ReadOnlyObjectProperty;\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.beans.value.ObservableValue;\n+import javafx.css.CssMetaData;\n+import javafx.css.PseudoClass;\n+import javafx.css.SimpleStyleableDoubleProperty;\n+import javafx.css.SimpleStyleableIntegerProperty;\n+import javafx.css.SimpleStyleableObjectProperty;\n+import javafx.css.StyleConverter;\n+import javafx.css.Styleable;\n+import javafx.css.StyleableDoubleProperty;\n+import javafx.css.StyleableIntegerProperty;\n+import javafx.css.StyleableObjectProperty;\n+import javafx.css.StyleableProperty;\n+import javafx.geometry.Dimension2D;\n+import javafx.geometry.HPos;\n+import javafx.geometry.Insets;\n+import javafx.geometry.VPos;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.HeaderBar;\n+import javafx.scene.layout.HeaderButtonType;\n+import javafx.scene.layout.Region;\n+import javafx.scene.paint.Paint;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.util.Subscription;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Contains the visuals and behaviors for the minimize\/maximize\/close buttons on an {@link StageStyle#EXTENDED}\n+ * window for platforms that use client-side decorations (Windows and Linux\/GTK). This control supports\n+ * left-to-right and right-to-left orientations, as well as a customizable layout order of buttons.\n+ *\n+ * <h2>Substructure<\/h2>\n+ * <ul>\n+ *     <li>{@link Region} — {@code header-button-container}\n+ *     <ul>\n+ *         <li>{@link Region} — {@code header-button}, {@code iconify-button}\n+ *         <li>{@link Region} — {@code header-button}, {@code maximize-button}\n+ *         <li>{@link Region} — {@code header-button}, {@code close-button}\n+ *     <\/ul>\n+ * <\/ul>\n+ *\n+ * <table style=\"white-space: nowrap\">\n+ *     <caption>CSS properties of {@code header-button-container}<\/caption>\n+ *     <thead>\n+ *         <tr><th>CSS property<\/th><th>Values<\/th><th>Default<\/th><th>Comment<\/th><\/tr>\n+ *     <\/thead>\n+ *     <tbody>\n+ *         <tr>\n+ *             <th>-fx-button-placement<\/th><td>[ left | right ]<\/td><td>right<\/td>\n+ *             <td style=\"white-space: break-line\">\n+ *                 Specifies the placement of the header buttons on the left or the right side of the window.\n+ *             <\/td>\n+ *         <\/tr>\n+ *         <tr>\n+ *             <th>-fx-button-vertical-alignment<\/th><td>[ center | stretch ]<\/td><td>center<\/td>\n+ *             <td style=\"white-space: break-line\">\n+ *                 Specifies the vertical alignment of the header buttons, either centering the buttons\n+ *                 within the preferred height or stretching the buttons to fill the preferred height.\n+ *             <\/td>\n+ *         <\/tr>\n+ *         <tr>\n+ *             <th>-fx-button-default-height<\/th><td>&lt;double&gt;<\/td><td>0<\/td>\n+ *             <td style=\"white-space: break-line\">\n+ *                 Specifies the default height of the header buttons, which is used when the application\n+ *                 does not specify a preferred button height.\n+ *             <\/td>\n+ *         <\/tr>\n+ *     <\/tbody>\n+ * <\/table>\n+ *\n+ * <table style=\"white-space: nowrap\">\n+ *     <caption>CSS properties of {@code iconify-button}, {@code maximize-button}, {@code close-button}<\/caption>\n+ *     <thead>\n+ *         <tr><th>CSS property<\/th><th>Values<\/th><th>Default<\/th><th>Comment<\/th><\/tr>\n+ *     <\/thead>\n+ *     <tbody><tr>\n+ *         <th>-fx-button-order<\/th><td>&lt;integer&gt;<\/td><td>0\/1\/2<\/td>\n+ *         <td style=\"white-space: break-line\">\n+ *             Specifies the layout order of a button relative to the other buttons.\n+ *             Lower values are laid out before higher values.<\/td>\n+ *     <\/tr><\/tbody>\n+ * <\/table>\n+ *\n+ * <table style=\"white-space: nowrap\">\n+ *     <caption>Conditional style classes of window buttons<\/caption>\n+ *     <thead>\n+ *         <tr style=\"min-width: 200\"><th>Style class<\/th><th>Applies to<\/th><th>Comment<\/th><\/tr>\n+ *     <\/thead>\n+ *     <tbody>\n+ *         <tr><th>.dark<\/th>\n+ *             <td>all buttons<\/td>\n+ *             <td style=\"white-space: break-line\">\n+ *                 This style class will be present if the brightness of {@link Scene#fillProperty()}\n+ *                 as determined by {@link Utils#calculateAverageBrightness(Paint)} is less than 0.5\n+ *             <\/td>\n+ *         <\/tr>\n+ *         <tr><th>.restore<\/th><th>{@code maximize-button}<\/th><td style=\"white-space: break-line\">\n+ *             This style class will be present if {@link Stage#isMaximized()} is {@code true}<\/td>\n+ *         <\/tr>\n+ *     <\/tbody>\n+ * <\/table>\n+ *\n+ * @implNote This control is used by the WinWindow.createHeaderButtonOverlay() and\n+ *           GtkWindow.createHeaderButtonOverlay() implementations for {@link StageStyle#EXTENDED}\n+ *           windows. It is not used by the macOS implementation.\n+ *\/\n+public class HeaderButtonOverlay extends Region {\n+\n+    private static final CssMetaData<HeaderButtonOverlay, Number> BUTTON_DEFAULT_HEIGHT_METADATA =\n+        new CssMetaData<>(\"-fx-button-default-height\", StyleConverter.getSizeConverter()) {\n+            @Override\n+            public boolean isSettable(HeaderButtonOverlay overlay) {\n+                return true;\n+            }\n+\n+            @Override\n+            public StyleableProperty<Number> getStyleableProperty(HeaderButtonOverlay overlay) {\n+                return overlay.buttonDefaultHeight;\n+            }\n+        };\n+\n+    private static final CssMetaData<HeaderButtonOverlay, ButtonPlacement> BUTTON_PLACEMENT_METADATA =\n+        new CssMetaData<>(\"-fx-button-placement\",\n+                StyleConverter.getEnumConverter(ButtonPlacement.class),\n+                ButtonPlacement.RIGHT) {\n+            @Override\n+            public boolean isSettable(HeaderButtonOverlay overlay) {\n+                return true;\n+            }\n+\n+            @Override\n+            public StyleableProperty<ButtonPlacement> getStyleableProperty(HeaderButtonOverlay overlay) {\n+                return overlay.buttonPlacement;\n+            }\n+        };\n+\n+    private static final CssMetaData<HeaderButtonOverlay, ButtonVerticalAlignment> BUTTON_VERTICAL_ALIGNMENT_METADATA =\n+        new CssMetaData<>(\"-fx-button-vertical-alignment\",\n+                StyleConverter.getEnumConverter(ButtonVerticalAlignment.class),\n+                ButtonVerticalAlignment.CENTER) {\n+            @Override\n+            public boolean isSettable(HeaderButtonOverlay overlay) {\n+                return true;\n+            }\n+\n+            @Override\n+            public StyleableProperty<ButtonVerticalAlignment> getStyleableProperty(HeaderButtonOverlay overlay) {\n+                return overlay.buttonVerticalAlignment;\n+            }\n+        };\n+\n+    private static final List<CssMetaData<?, ?>> METADATA =\n+        Stream.concat(getClassCssMetaData().stream(),\n+        Stream.of(BUTTON_DEFAULT_HEIGHT_METADATA,\n+                  BUTTON_PLACEMENT_METADATA,\n+                  BUTTON_VERTICAL_ALIGNMENT_METADATA)).toList();\n+\n+    private static final PseudoClass HOVER_PSEUDOCLASS = PseudoClass.getPseudoClass(\"hover\");\n+    private static final PseudoClass PRESSED_PSEUDOCLASS = PseudoClass.getPseudoClass(\"pressed\");\n+    private static final PseudoClass ACTIVE_PSEUDOCLASS = PseudoClass.getPseudoClass(\"active\");\n+    private static final String DARK_STYLE_CLASS = \"dark\";\n+    private static final String RESTORE_STYLE_CLASS = \"restore\";\n+    private static final String UTILITY_STYLE_CLASS = \"utility\";\n+\n+    \/**\n+     * The metrics (placement and size) of header buttons.\n+     *\/\n+    private final ObjectProperty<HeaderButtonMetrics> metrics = new SimpleObjectProperty<>(\n+        this, \"metrics\", new HeaderButtonMetrics(new Dimension2D(0, 0), new Dimension2D(0, 0), 0));\n+\n+    \/**\n+     * Specifies the preferred height of header buttons.\n+     * <p>\n+     * Negative values are interpreted as \"no preference\", which causes the buttons to be laid out\n+     * with their preferred height set to the value of {@link #buttonDefaultHeight}.\n+     *\/\n+    private final DoubleProperty prefButtonHeight = new SimpleDoubleProperty(\n+        this, \"prefButtonHeight\", HeaderBar.USE_DEFAULT_SIZE);\n+\n+    \/**\n+     * Specifies the default height of header buttons.\n+     * <p>\n+     * This property corresponds to the {@code -fx-button-default-height} CSS property.\n+     *\/\n+    private final StyleableDoubleProperty buttonDefaultHeight = new SimpleStyleableDoubleProperty(\n+        BUTTON_DEFAULT_HEIGHT_METADATA, this, \"buttonDefaultHeight\");\n+\n+    \/**\n+     * Specifies the placement of the header buttons on the left or the right side of the window.\n+     * <p>\n+     * This property corresponds to the {@code -fx-button-placement} CSS property.\n+     *\/\n+    private final StyleableObjectProperty<ButtonPlacement> buttonPlacement =\n+        new SimpleStyleableObjectProperty<>(\n+                BUTTON_PLACEMENT_METADATA, this, \"buttonPlacement\", ButtonPlacement.RIGHT) {\n+            @Override\n+            protected void invalidated() {\n+                requestLayout();\n+            }\n+        };\n+\n+    \/**\n+     * Specifies the vertical alignment of the header buttons.\n+     * <p>\n+     * This property corresponds to the {@code -fx-button-vertical-alignment} CSS property.\n+     *\/\n+    private final StyleableObjectProperty<ButtonVerticalAlignment> buttonVerticalAlignment =\n+        new SimpleStyleableObjectProperty<>(\n+                BUTTON_VERTICAL_ALIGNMENT_METADATA, this, \"buttonVerticalAlignment\",\n+                ButtonVerticalAlignment.CENTER) {\n+            @Override\n+            protected void invalidated() {\n+                requestLayout();\n+            }\n+        };\n+\n+    \/**\n+     * Contains the buttons in the order as they will appear on the window.\n+     * This list is automatically updated by the implementation of {@link ButtonRegion#buttonOrder}.\n+     *\/\n+    private final List<ButtonRegion> orderedButtons = new ArrayList<>(3);\n+    private final ButtonRegion iconifyButton = new ButtonRegion(HeaderButtonType.ICONIFY, \"iconify-button\", 0);\n+    private final ButtonRegion maximizeButton = new ButtonRegion(HeaderButtonType.MAXIMIZE, \"maximize-button\", 1);\n+    private final ButtonRegion closeButton = new ButtonRegion(HeaderButtonType.CLOSE, \"close-button\", 2);\n+    private final Subscription subscriptions;\n+    private final boolean utility;\n+    private final boolean rightToLeft;\n+\n+    private Node buttonAtMouseDown;\n+\n+    public HeaderButtonOverlay(ObservableValue<String> stylesheet, boolean utility, boolean rightToLeft) {\n+        this.utility = utility;\n+        this.rightToLeft = rightToLeft;\n+\n+        var stage = sceneProperty()\n+            .flatMap(Scene::windowProperty)\n+            .map(w -> w instanceof Stage ? (Stage)w : null);\n+\n+        var focusedSubscription = stage\n+            .flatMap(Stage::focusedProperty)\n+            .orElse(true)\n+            .subscribe(this::onFocusedChanged);\n+\n+        var resizableSubscription = stage\n+            .flatMap(Stage::resizableProperty)\n+            .orElse(true)\n+            .subscribe(this::onResizableChanged);\n+\n+        var maximizedSubscription = stage\n+            .flatMap(Stage::maximizedProperty)\n+            .orElse(false)\n+            .subscribe(this::onMaximizedChanged);\n+\n+        var updateStylesheetSubscription = sceneProperty()\n+            .flatMap(Scene::fillProperty)\n+            .map(this::isDarkBackground)\n+            .orElse(false)\n+            .subscribe(_ -> updateStyleClass()); \/\/ use a value subscriber, not an invalidation subscriber\n+\n+        subscriptions = Subscription.combine(\n+            focusedSubscription,\n+            resizableSubscription,\n+            maximizedSubscription,\n+            updateStylesheetSubscription,\n+            stylesheet.subscribe(this::updateStylesheet),\n+            prefButtonHeight.subscribe(this::requestLayout),\n+            buttonDefaultHeight.subscribe(this::requestLayout));\n+\n+        getStyleClass().setAll(\"header-button-container\");\n+\n+        if (utility) {\n+            iconifyButton.managedProperty().bind(ObjectConstant.valueOf(false));\n+            maximizeButton.managedProperty().bind(ObjectConstant.valueOf(false));\n+            getChildren().add(closeButton);\n+            getStyleClass().add(UTILITY_STYLE_CLASS);\n+        } else {\n+            getChildren().addAll(iconifyButton, maximizeButton, closeButton);\n+        }\n+    }\n+\n+    public void dispose() {\n+        subscriptions.unsubscribe();\n+    }\n+\n+    public ReadOnlyObjectProperty<HeaderButtonMetrics> metricsProperty() {\n+        return metrics;\n+    }\n+\n+    public DoubleProperty prefButtonHeightProperty() {\n+        return prefButtonHeight;\n+    }\n+\n+    protected Region getButtonGlyph(HeaderButtonType buttonType) {\n+         return (Region)(switch (buttonType) {\n+            case ICONIFY -> iconifyButton;\n+            case MAXIMIZE -> maximizeButton;\n+            case CLOSE -> closeButton;\n+        }).getChildrenUnmodifiable().getFirst();\n+    }\n+\n+    \/**\n+     * Classifies and returns the button type at the specified coordinate, or returns\n+     * {@code null} if the specified coordinate does not intersect a button.\n+     *\n+     * @param x the X coordinate, in pixels relative to the window\n+     * @param y the Y coordinate, in pixels relative to the window\n+     * @return the {@code ButtonType} or {@code null}\n+     *\/\n+    public HeaderButtonType buttonAt(double x, double y) {\n+        if (!utility) {\n+            for (var button : orderedButtons) {\n+                if (button.isVisible() && button.getBoundsInParent().contains(x, y)) {\n+                    return button.getButtonType();\n+                }\n+            }\n+        } else if (closeButton.isVisible() && closeButton.getBoundsInParent().contains(x, y)) {\n+            return HeaderButtonType.CLOSE;\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * Handles the specified mouse event.\n+     *\n+     * @param type the event type\n+     * @param button the button type\n+     * @param x the X coordinate, in pixels relative to the window\n+     * @param y the Y coordinate, in pixels relative to the window\n+     * @return {@code true} if the event was handled, {@code false} otherwise\n+     *\/\n+    public boolean handleMouseEvent(int type, int button, double x, double y) {\n+        HeaderButtonType buttonType = buttonAt(x, y);\n+        Node node = buttonType != null ? switch (buttonType) {\n+            case ICONIFY -> iconifyButton;\n+            case MAXIMIZE -> maximizeButton;\n+            case CLOSE -> closeButton;\n+        } : null;\n+\n+        if (type == MouseEvent.ENTER || type == MouseEvent.MOVE || type == MouseEvent.DRAG) {\n+            handleMouseOver(node);\n+        } else if (type == MouseEvent.EXIT) {\n+            handleMouseExit();\n+        } else if (type == MouseEvent.UP && button == MouseEvent.BUTTON_LEFT) {\n+            handleMouseUp(node, buttonType);\n+        } else if (node != null && type == MouseEvent.DOWN && button == MouseEvent.BUTTON_LEFT) {\n+            handleMouseDown(node);\n+        }\n+\n+        if (type == MouseEvent.ENTER || type == MouseEvent.EXIT) {\n+            return false;\n+        }\n+\n+        return node != null || buttonAtMouseDown != null;\n+    }\n+\n+    private void handleMouseOver(Node button) {\n+        iconifyButton.pseudoClassStateChanged(HOVER_PSEUDOCLASS, button == iconifyButton);\n+        maximizeButton.pseudoClassStateChanged(HOVER_PSEUDOCLASS, button == maximizeButton);\n+        closeButton.pseudoClassStateChanged(HOVER_PSEUDOCLASS, button == closeButton);\n+\n+        if (buttonAtMouseDown != null && buttonAtMouseDown != button) {\n+            buttonAtMouseDown.pseudoClassStateChanged(PRESSED_PSEUDOCLASS, false);\n+        }\n+    }\n+\n+    private void handleMouseExit() {\n+        buttonAtMouseDown = null;\n+\n+        for (var node : new Node[] {iconifyButton, maximizeButton, closeButton}) {\n+            node.pseudoClassStateChanged(HOVER_PSEUDOCLASS, false);\n+            node.pseudoClassStateChanged(PRESSED_PSEUDOCLASS, false);\n+        }\n+    }\n+\n+    private void handleMouseDown(Node node) {\n+        buttonAtMouseDown = node;\n+\n+        if (!node.isDisabled()) {\n+            node.pseudoClassStateChanged(PRESSED_PSEUDOCLASS, true);\n+        }\n+    }\n+\n+    private void handleMouseUp(Node node, HeaderButtonType buttonType) {\n+        boolean releasedOnButton = (buttonAtMouseDown == node);\n+        buttonAtMouseDown = null;\n+        Scene scene = getScene();\n+\n+        if (node == null || node.isDisabled()\n+                || scene == null || !(scene.getWindow() instanceof Stage stage)) {\n+            return;\n+        }\n+\n+        node.pseudoClassStateChanged(PRESSED_PSEUDOCLASS, false);\n+\n+        if (releasedOnButton) {\n+            switch (buttonType) {\n+                case ICONIFY -> stage.setIconified(true);\n+                case MAXIMIZE -> stage.setMaximized(!stage.isMaximized());\n+                case CLOSE -> stage.close();\n+            }\n+        }\n+    }\n+\n+    private void onFocusedChanged(boolean focused) {\n+        iconifyButton.pseudoClassStateChanged(ACTIVE_PSEUDOCLASS, focused);\n+        maximizeButton.pseudoClassStateChanged(ACTIVE_PSEUDOCLASS, focused);\n+        closeButton.pseudoClassStateChanged(ACTIVE_PSEUDOCLASS, focused);\n+    }\n+\n+    private void onResizableChanged(boolean resizable) {\n+        maximizeButton.setDisable(!resizable);\n+    }\n+\n+    private void onMaximizedChanged(boolean maximized) {\n+        toggleStyleClass(maximizeButton, RESTORE_STYLE_CLASS, maximized);\n+    }\n+\n+    private void updateStyleClass() {\n+        boolean darkScene = isDarkBackground(getScene() != null ? getScene().getFill() : null);\n+        toggleStyleClass(iconifyButton, DARK_STYLE_CLASS, darkScene);\n+        toggleStyleClass(maximizeButton, DARK_STYLE_CLASS, darkScene);\n+        toggleStyleClass(closeButton, DARK_STYLE_CLASS, darkScene);\n+    }\n+\n+    private void updateStylesheet(String stylesheet) {\n+        getStylesheets().setAll(stylesheet);\n+    }\n+\n+    private void toggleStyleClass(Node node, String styleClass, boolean enabled) {\n+        if (enabled && !node.getStyleClass().contains(styleClass)) {\n+            node.getStyleClass().add(styleClass);\n+        } else if (!enabled) {\n+            node.getStyleClass().remove(styleClass);\n+        }\n+    }\n+\n+    private boolean isDarkBackground(Paint paint) {\n+        return paint != null && Utils.calculateAverageBrightness(paint) < 0.5;\n+    }\n+\n+    private double getEffectiveButtonHeight() {\n+        double prefHeight = prefButtonHeight.get();\n+        return prefHeight >= 0 ? prefHeight : buttonDefaultHeight.get();\n+    }\n+\n+    private double getButtonOffsetY(double buttonHeight) {\n+        return switch (buttonVerticalAlignment.get()) {\n+            case STRETCH -> 0;\n+            case CENTER -> (getEffectiveButtonHeight() - buttonHeight) \/ 2;\n+        };\n+    }\n+\n+    private void ensureRegionPrefHeight(Region region, double height) {\n+        var prefHeight = (StyleableDoubleProperty)region.prefHeightProperty();\n+\n+        if (prefHeight.getStyleOrigin() == null) {\n+            prefHeight.applyStyle(null, height);\n+        }\n+    }\n+\n+    @Override\n+    protected void layoutChildren() {\n+        boolean left;\n+        Region button1, button2, button3;\n+\n+        if (rightToLeft) {\n+            button1 = orderedButtons.get(2);\n+            button2 = orderedButtons.get(1);\n+            button3 = orderedButtons.get(0);\n+            left = buttonPlacement.get() != ButtonPlacement.LEFT;\n+        } else {\n+            button1 = orderedButtons.get(0);\n+            button2 = orderedButtons.get(1);\n+            button3 = orderedButtons.get(2);\n+            left = buttonPlacement.get() == ButtonPlacement.LEFT;\n+        }\n+\n+        double buttonHeight = switch (buttonVerticalAlignment.get()) {\n+            case STRETCH -> getEffectiveButtonHeight();\n+            case CENTER -> buttonDefaultHeight.get();\n+        };\n+\n+        ensureRegionPrefHeight(button1, buttonHeight);\n+        ensureRegionPrefHeight(button2, buttonHeight);\n+        ensureRegionPrefHeight(button3, buttonHeight);\n+\n+        double width = getWidth();\n+        double button1Width = snapSizeX(boundedWidth(button1));\n+        double button2Width = snapSizeX(boundedWidth(button2));\n+        double button3Width = snapSizeX(boundedWidth(button3));\n+        double button1Height = snapSizeY(boundedHeight(button1));\n+        double button2Height = snapSizeY(boundedHeight(button2));\n+        double button3Height = snapSizeY(boundedHeight(button3));\n+        double button1X = snapPositionX(left ? 0 : width - button1Width - button2Width - button3Width);\n+        double button2X = snapPositionX(left ? button1Width : width - button3Width - button2Width);\n+        double button3X = snapPositionX(left ? button1Width + button2Width : width - button3Width);\n+        double totalWidth = snapSizeX(button1Width + button2Width + button3Width);\n+        double totalHeight;\n+\n+        \/\/ A centered button doesn't stretch to fill the preferred height. Instead, we center the button\n+        \/\/ vertically within the preferred height, and also add a horizontal offset so that the buttons\n+        \/\/ have the same distance from the top and the left\/right side of the window.\n+        if (buttonVerticalAlignment.get() == ButtonVerticalAlignment.CENTER) {\n+            if (left) {\n+                double offset = getButtonOffsetY(button1Height);\n+                button1X = snapPositionX(button1X + offset);\n+                button2X = snapPositionX(button2X + offset);\n+                button3X = snapPositionX(button3X + offset);\n+                totalWidth = snapSizeX(totalWidth + offset * 2);\n+            } else {\n+                double offset = getButtonOffsetY(button3Height);\n+                button1X = snapPositionX(button1X - offset);\n+                button2X = snapPositionX(button2X - offset);\n+                button3X = snapPositionX(button3X - offset);\n+                totalWidth = snapSizeX(totalWidth + offset * 2);\n+            }\n+\n+            totalHeight = snapSizeY(getEffectiveButtonHeight());\n+        } else {\n+            totalHeight = snapSizeY(Math.max(button1Height, Math.max(button2Height, button3Height)));\n+        }\n+\n+        Dimension2D currentSize = left ? metrics.get().leftInset() : metrics.get().rightInset();\n+\n+        \/\/ Update the overlay metrics if they have changed.\n+        if (currentSize.getWidth() != totalWidth || currentSize.getHeight() != totalHeight) {\n+            var empty = new Dimension2D(0, 0);\n+            var size = new Dimension2D(totalWidth, totalHeight);\n+            HeaderButtonMetrics newMetrics = left\n+                ? new HeaderButtonMetrics(size, empty, buttonDefaultHeight.get())\n+                : new HeaderButtonMetrics(empty, size, buttonDefaultHeight.get());\n+            metrics.set(newMetrics);\n+        }\n+\n+        layoutInArea(button1, button1X, getButtonOffsetY(button1Height), button1Width, button1Height,\n+                     BASELINE_OFFSET_SAME_AS_HEIGHT, Insets.EMPTY, true, true,\n+                     HPos.LEFT, VPos.TOP, false);\n+\n+        layoutInArea(button2, button2X, getButtonOffsetY(button2Height), button2Width, button2Height,\n+                     BASELINE_OFFSET_SAME_AS_HEIGHT, Insets.EMPTY, true, true,\n+                     HPos.LEFT, VPos.TOP, false);\n+\n+        layoutInArea(button3, button3X, getButtonOffsetY(button3Height), button3Width, button3Height,\n+                     BASELINE_OFFSET_SAME_AS_HEIGHT, Insets.EMPTY, true, true,\n+                     HPos.LEFT, VPos.TOP, false);\n+    }\n+\n+    @Override\n+    public boolean usesMirroring() {\n+        return false;\n+    }\n+\n+    @Override\n+    public List<CssMetaData<? extends Styleable, ?>> getCssMetaData() {\n+        return METADATA;\n+    }\n+\n+    private static double boundedWidth(Node node) {\n+        return node.isManaged() ? boundedSize(node.minWidth(-1), node.prefWidth(-1), node.maxWidth(-1)) : 0;\n+    }\n+\n+    private static double boundedHeight(Node node) {\n+        return node.isManaged() ? boundedSize(node.minHeight(-1), node.prefHeight(-1), node.maxHeight(-1)) : 0;\n+    }\n+\n+    private static double boundedSize(double min, double pref, double max) {\n+        return Math.min(Math.max(pref, min), Math.max(min, max));\n+    }\n+\n+    private class ButtonRegion extends Region {\n+\n+        private static final CssMetaData<ButtonRegion, Number> BUTTON_ORDER_METADATA =\n+            new CssMetaData<>(\"-fx-button-order\", StyleConverter.getSizeConverter()) {\n+                @Override\n+                public boolean isSettable(ButtonRegion node) {\n+                    return true;\n+                }\n+\n+                @Override\n+                public StyleableProperty<Number> getStyleableProperty(ButtonRegion region) {\n+                    return region.buttonOrder;\n+                }\n+            };\n+\n+        private static final List<CssMetaData<?, ?>> METADATA =\n+            Stream.concat(getClassCssMetaData().stream(), Stream.of(BUTTON_ORDER_METADATA)).toList();\n+\n+        \/**\n+         * Specifies the layout order of this button relative to the other buttons.\n+         * Buttons with a lower value are laid out before buttons with a higher value.\n+         * <p>\n+         * This property corresponds to the {@code -fx-button-order} CSS property.\n+         *\/\n+        private final StyleableIntegerProperty buttonOrder =\n+            new SimpleStyleableIntegerProperty(BUTTON_ORDER_METADATA, this, \"buttonOrder\") {\n+                @Override\n+                protected void invalidated() {\n+                    requestParentLayout();\n+\n+                    HeaderButtonOverlay.this.orderedButtons.sort(\n+                        Comparator.comparing(ButtonRegion::getButtonOrder));\n+                }\n+            };\n+\n+        private final Region glyph = new Region();\n+        private final HeaderButtonType type;\n+\n+        ButtonRegion(HeaderButtonType type, String styleClass, int order) {\n+            this.type = type;\n+            orderedButtons.add(this);\n+            buttonOrder.set(order);\n+            glyph.getStyleClass().setAll(\"glyph\");\n+            getChildren().add(glyph);\n+            getStyleClass().setAll(\"header-button\", styleClass);\n+        }\n+\n+        public HeaderButtonType getButtonType() {\n+            return type;\n+        }\n+\n+        public int getButtonOrder() {\n+            return buttonOrder.get();\n+        }\n+\n+        @Override\n+        protected void layoutChildren() {\n+            layoutInArea(glyph, 0, 0, getWidth(), getHeight(), 0, HPos.LEFT, VPos.TOP);\n+        }\n+\n+        @Override\n+        public List<CssMetaData<? extends Styleable, ?>> getCssMetaData() {\n+            return METADATA;\n+        }\n+    }\n+\n+    private enum ButtonPlacement {\n+        LEFT, RIGHT\n+    }\n+\n+    private enum ButtonVerticalAlignment {\n+        STRETCH, CENTER\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/HeaderButtonOverlay.java","additions":683,"deletions":0,"binary":false,"changes":683,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-\n+import com.sun.javafx.tk.HeaderAreaType;\n@@ -70,1 +70,1 @@\n-        public void handleMenuEvent(View view, int x, int y, int xAbs,\n+        public boolean handleMenuEvent(View view, int x, int y, int xAbs,\n@@ -72,0 +72,1 @@\n+            return false;\n@@ -366,0 +367,12 @@\n+        \/**\n+         * Returns the header area type at the specified coordinates, or {@code null}\n+         * if the specified coordinates do not intersect with a header area.\n+         *\n+         * @param x the X coordinate\n+         * @param y the Y coordinate\n+         * @return the header area type, or {@code null}\n+         *\/\n+        public HeaderAreaType pickHeaderArea(double x, double y) {\n+            return null;\n+        }\n+\n@@ -530,1 +543,1 @@\n-    private boolean shouldHandleEvent() {\n+    protected boolean shouldHandleEvent() {\n@@ -555,4 +568,4 @@\n-    private void handleMouseEvent(long time, int type, int button, int x, int y,\n-                                  int xAbs, int yAbs,\n-                                  int modifiers, boolean isPopupTrigger,\n-                                  boolean isSynthesized) {\n+    protected void handleMouseEvent(long time, int type, int button, int x, int y,\n+                                    int xAbs, int yAbs,\n+                                    int modifiers, boolean isPopupTrigger,\n+                                    boolean isSynthesized) {\n@@ -566,1 +579,6 @@\n-    private void handleMenuEvent(int x, int y, int xAbs, int yAbs, boolean isKeyboardTrigger) {\n+    protected boolean handleNonClientMouseEvent(long time, int type, int button, int x, int y,\n+                                                int xAbs, int yAbs, int modifiers, int clickCount) {\n+        return false;\n+    }\n+\n+    protected boolean handleMenuEvent(int x, int y, int xAbs, int yAbs, boolean isKeyboardTrigger) {\n@@ -568,1 +586,1 @@\n-            this.eventHandler.handleMenuEvent(this, x, y, xAbs, yAbs, isKeyboardTrigger);\n+            return this.eventHandler.handleMenuEvent(this, x, y, xAbs, yAbs, isKeyboardTrigger);\n@@ -570,0 +588,1 @@\n+        return false;\n@@ -914,9 +933,0 @@\n-        \/\/ gznote: optimize - only call for undecorated Windows!\n-        if (this.window != null) {\n-            \/\/ handled by window (programmatical move\/resize)\n-            if (this.window.handleMouseEvent(type, button, x, y, xAbs, yAbs)) {\n-                \/\/ The evnet has been processed by Glass\n-                return;\n-            }\n-        }\n-\n@@ -946,0 +956,19 @@\n+        \/\/ If this is an extended window, we give the non-client handler the first chance to handle the event.\n+        \/\/ Note that a full-screen window has no non-client area, and thus the non-client event handler\n+        \/\/ is not notified.\n+        \/\/ Some implementations (like GTK) can fire synthesized events when they receive a mouse button\n+        \/\/ event on the resize border. These events, even though happening on non-client regions, must\n+        \/\/ not be processed by the non-client event handler. For example, if a mouse click happens on\n+        \/\/ the resize border that straddles the window close button, we don't want the close button to\n+        \/\/ act on this click, because we just started a resize-drag operation.\n+        boolean handled = window != null\n+            && window.isExtendedWindow()\n+            && !isSynthesized\n+            && !inFullscreen\n+            && shouldHandleEvent()\n+            && handleNonClientMouseEvent(now, type, button, x, y, xAbs, yAbs, modifiers, clickCount);\n+\n+        if (handled) {\n+            return;\n+        }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/View.java","additions":48,"deletions":19,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import com.sun.glass.events.MouseEvent;\n@@ -30,1 +29,11 @@\n-\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.DoubleProperty;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.ReadOnlyBooleanProperty;\n+import javafx.beans.property.ReadOnlyDoubleProperty;\n+import javafx.beans.property.ReadOnlyObjectProperty;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.scene.layout.HeaderBar;\n+import javafx.scene.layout.Region;\n@@ -32,1 +41,0 @@\n-\n@@ -119,0 +127,1 @@\n+    public static final int EXTENDED        = 1 << 2;\n@@ -133,1 +142,1 @@\n-    @Native public static final int UTILITY         = 1 << 2;\n+    @Native public static final int UTILITY         = 1 << 3;\n@@ -141,1 +150,1 @@\n-    @Native public static final int POPUP           = 1 << 3;\n+    @Native public static final int POPUP           = 1 << 4;\n@@ -145,3 +154,3 @@\n-    @Native public static final int CLOSABLE        = 1 << 4;\n-    @Native public static final int MINIMIZABLE     = 1 << 5;\n-    @Native public static final int MAXIMIZABLE     = 1 << 6;\n+    @Native public static final int CLOSABLE        = 1 << 5;\n+    @Native public static final int MINIMIZABLE     = 1 << 6;\n+    @Native public static final int MAXIMIZABLE     = 1 << 7;\n@@ -152,1 +161,1 @@\n-    @Native public static final int RIGHT_TO_LEFT     = 1 << 7;\n+    @Native public static final int RIGHT_TO_LEFT     = 1 << 8;\n@@ -160,1 +169,1 @@\n-    @Native public static final int UNIFIED = 1 << 8;\n+    @Native public static final int UNIFIED = 1 << 9;\n@@ -165,1 +174,1 @@\n-    @Native public static final int MODAL = 1 << 9;\n+    @Native public static final int MODAL = 1 << 10;\n@@ -200,1 +209,0 @@\n-    private boolean shouldStartUndecoratedMove = false;\n@@ -206,1 +214,0 @@\n-    private UndecoratedMoveResizeHelper helper = null;\n@@ -240,1 +247,1 @@\n-        switch (styleMask & (TITLED | TRANSPARENT)) {\n+        switch (styleMask & (TITLED | TRANSPARENT | EXTENDED)) {\n@@ -244,0 +251,1 @@\n+            case EXTENDED:\n@@ -246,1 +254,1 @@\n-                throw new RuntimeException(\"The visual kind should be UNTITLED, TITLED, or TRANSPARENT, but not a combination of these\");\n+                throw new RuntimeException(\"The visual kind should be UNTITLED, TITLED, TRANSPARENT, or EXTENDED, but not a combination of these\");\n@@ -257,0 +265,4 @@\n+        if ((styleMask & UNIFIED) != 0 && (styleMask & EXTENDED) != 0) {\n+            throw new RuntimeException(\"UNIFIED and EXTENDED cannot be combined\");\n+        }\n+\n@@ -267,1 +279,0 @@\n-\n@@ -288,0 +299,48 @@\n+    \/**\n+     * Specifies the preferred header button height. Sub-classes can use this value in their header button\n+     * visualization, but they are not required to accommodate the preferred height.\n+     * <p>\n+     * Implementations should choose a sensible default height for their header button visualization if\n+     * {@link HeaderBar#USE_DEFAULT_SIZE} is specified.\n+     *\/\n+    private final DoubleProperty prefHeaderButtonHeight =\n+        new SimpleDoubleProperty(this, \"prefHeaderButtonHeight\", HeaderBar.USE_DEFAULT_SIZE);\n+\n+    public final ReadOnlyDoubleProperty prefHeaderButtonHeightProperty() {\n+        return prefHeaderButtonHeight;\n+    }\n+\n+    \/**\n+     * Sets the preferred header button height.\n+     * <p>\n+     * Note: Sub-classes must not use this method to change the preferred header button height.\n+     *       It is only invoked by the toolkit's {@link com.sun.javafx.tk.TKStage} implementation.\n+     *\/\n+    public final void setPrefHeaderButtonHeight(double height) {\n+        prefHeaderButtonHeight.set(height);\n+    }\n+\n+    \/**\n+     * Specifies the header button overlay. This property is managed by sub-classes that provide an overlay\n+     * for header buttons. It is not required to use an overlay for header buttons; implementations can also\n+     * use other ways of visualizing header buttons.\n+     *\/\n+    protected final ObjectProperty<Region> headerButtonOverlay =\n+        new SimpleObjectProperty<>(this, \"headerButtonOverlay\");\n+\n+    public final ReadOnlyObjectProperty<Region> headerButtonOverlayProperty() {\n+        return headerButtonOverlay;\n+    }\n+\n+    \/**\n+     * Specifies the metrics for header buttons, which applications can use for layout purposes. This property\n+     * is managed by sub-classes that support header buttons. Implementations are required to provide metrics\n+     * for header buttons even if they don't use a header button overlay.\n+     *\/\n+    protected final ObjectProperty<HeaderButtonMetrics> headerButtonMetrics =\n+        new SimpleObjectProperty<>(this, \"headerButtonMetrics\", HeaderButtonMetrics.EMPTY);\n+\n+    public final ReadOnlyObjectProperty<HeaderButtonMetrics> headerButtonMetricsProperty() {\n+        return headerButtonMetrics;\n+    }\n+\n@@ -378,3 +437,0 @@\n-            if (this.isDecorated == false) {\n-                this.helper = new UndecoratedMoveResizeHelper();\n-            }\n@@ -628,14 +684,6 @@\n-        if (this.isVisible != visible) {\n-            if (!visible) {\n-                if (getView() != null) {\n-                    getView().setVisible(visible);\n-                }\n-                \/\/ Avoid native call if the window has been closed already\n-                if (this.ptr != 0L) {\n-                    this.isVisible = _setVisible(this.ptr, visible);\n-                } else {\n-                    this.isVisible = visible;\n-                }\n-                remove(this);\n-            } else {\n-                checkNotClosed();\n+        if (!visible) {\n+            if (getView() != null) {\n+                getView().setVisible(visible);\n+            }\n+            \/\/ Avoid native call if the window has been closed already\n+            if (this.ptr != 0L) {\n@@ -643,0 +691,7 @@\n+            } else {\n+                this.isVisible = visible;\n+            }\n+            remove(this);\n+        } else {\n+            checkNotClosed();\n+            this.isVisible = _setVisible(this.ptr, visible);\n@@ -644,6 +699,2 @@\n-                if (getView() != null) {\n-                    getView().setVisible(this.isVisible);\n-                }\n-                add(this);\n-\n-                synthesizeViewMoveEvent();\n+            if (getView() != null) {\n+                getView().setVisible(this.isVisible);\n@@ -651,0 +702,3 @@\n+            add(this);\n+\n+            synthesizeViewMoveEvent();\n@@ -658,5 +712,3 @@\n-        if (this.isResizable != resizable) {\n-            if (_setResizable(this.ptr, resizable)) {\n-                this.isResizable = resizable;\n-                synthesizeViewMoveEvent();\n-            }\n+        if (_setResizable(this.ptr, resizable)) {\n+            this.isResizable = resizable;\n+            synthesizeViewMoveEvent();\n@@ -677,0 +729,8 @@\n+    public boolean isExtendedWindow() {\n+        return (this.styleMask & Window.EXTENDED) != 0;\n+    }\n+\n+    public boolean isUtilityWindow() {\n+        return (this.styleMask & Window.UTILITY) != 0;\n+    }\n+\n@@ -1151,9 +1211,0 @@\n-    \/**\n-     * Enables unconditional start of window move operation when\n-     * mouse is dragged in the client area.\n-     *\/\n-    public void setShouldStartUndecoratedMove(boolean v) {\n-        Application.checkEventThread();\n-        this.shouldStartUndecoratedMove = v;\n-    }\n-\n@@ -1217,5 +1268,0 @@\n-\n-            \/\/ update moveRect\/resizeRect\n-            if (this.helper != null){\n-                this.helper.updateRectangles();\n-            }\n@@ -1272,96 +1318,0 @@\n-    \/\/ *****************************************************\n-    \/\/ programmatical move\/resize\n-    \/\/ *****************************************************\n-    \/** Sets \"programmatical move\" rectangle.\n-     * The rectangle is measured from top of the View:\n-     * width is View.width, height is size.\n-     *\n-     * throws RuntimeException for decorated window.\n-     *\/\n-    public void setUndecoratedMoveRectangle(int size) {\n-        Application.checkEventThread();\n-        if (this.isDecorated == true) {\n-            \/\/throw new RuntimeException(\"setUndecoratedMoveRectangle is only valid for Undecorated Window\");\n-            System.err.println(\"Glass Window.setUndecoratedMoveRectangle is only valid for Undecorated Window. In the future this will be hard error.\");\n-            Thread.dumpStack();\n-            return;\n-        }\n-\n-        if (this.helper != null) {\n-            this.helper.setMoveRectangle(size);\n-        }\n-    }\n-    \/** The method called only for undecorated windows\n-     * x, y: mouse coordinates (in View space).\n-     *\n-     * throws RuntimeException for decorated window.\n-     *\/\n-    public boolean shouldStartUndecoratedMove(final int x, final int y) {\n-        Application.checkEventThread();\n-        if (this.shouldStartUndecoratedMove == true) {\n-            return true;\n-        }\n-        if (this.isDecorated == true) {\n-            return false;\n-        }\n-\n-        if (this.helper != null) {\n-            return this.helper.shouldStartMove(x, y);\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    \/** Sets \"programmatical resize\" rectangle.\n-     * The rectangle is measured from top of the View:\n-     * width is View.width, height is size.\n-     *\n-     * throws RuntimeException for decorated window.\n-     *\/\n-    public void setUndecoratedResizeRectangle(int size) {\n-        Application.checkEventThread();\n-        if ((this.isDecorated == true) || (this.isResizable == false)) {\n-            \/\/throw new RuntimeException(\"setUndecoratedMoveRectangle is only valid for Undecorated Resizable Window\");\n-            System.err.println(\"Glass Window.setUndecoratedResizeRectangle is only valid for Undecorated Resizable Window. In the future this will be hard error.\");\n-            Thread.dumpStack();\n-            return;\n-        }\n-\n-        if (this.helper != null) {\n-            this.helper.setResizeRectangle(size);\n-        }\n-    }\n-\n-    \/** The method called only for undecorated windows\n-     * x, y: mouse coordinates (in View space).\n-     *\n-     * throws RuntimeException for decorated window.\n-     *\/\n-    public boolean shouldStartUndecoratedResize(final int x, final int y) {\n-        Application.checkEventThread();\n-        if ((this.isDecorated == true) || (this.isResizable == false)) {\n-            return false;\n-        }\n-\n-        if (this.helper != null) {\n-            return this.helper.shouldStartResize(x, y);\n-        }  else {\n-            return false;\n-        }\n-    }\n-\n-    \/** Mouse event handler for processing programmatical resize\/move\n-     * (for undecorated windows only).\n-     * Must be called by View.\n-     * x & y are View coordinates.\n-     * NOTE: it's package private!\n-     * @return true if the event is processed by the window,\n-     *         false if it has to be delivered to the app\n-     *\/\n-    boolean handleMouseEvent(int type, int button, int x, int y, int xAbs, int yAbs) {\n-        if (this.isDecorated == false) {\n-            return this.helper.handleMouseEvent(type, button, x, y, xAbs, yAbs);\n-        }\n-        return false;\n-    }\n-\n@@ -1403,137 +1353,0 @@\n-    private class UndecoratedMoveResizeHelper {\n-        TrackingRectangle moveRect = null;\n-        TrackingRectangle resizeRect = null;\n-\n-        boolean inMove = false;         \/\/ we are in \"move\" mode\n-        boolean inResize = false;       \/\/ we are in \"resize\" mode\n-\n-        int startMouseX, startMouseY;   \/\/ start mouse coords\n-        int startX, startY;             \/\/ start window location (for move)\n-        int startWidth, startHeight;    \/\/ start window size (for resize)\n-\n-        UndecoratedMoveResizeHelper() {\n-            this.moveRect = new TrackingRectangle();\n-            this.resizeRect = new TrackingRectangle();\n-        }\n-\n-        void setMoveRectangle(final int size) {\n-            this.moveRect.size = size;\n-\n-            this.moveRect.x = 0;\n-            this.moveRect.y = 0;\n-            this.moveRect.width = getWidth();\n-            this.moveRect.height = this.moveRect.size;\n-        }\n-\n-        boolean shouldStartMove(final int x, final int y) {\n-            return this.moveRect.contains(x, y);\n-        }\n-\n-        boolean inMove() {\n-            return this.inMove;\n-        }\n-\n-        void startMove(final int x, final int y) {\n-            this.inMove = true;\n-\n-            this.startMouseX = x;\n-            this.startMouseY = y;\n-\n-            this.startX = getX();\n-            this.startY = getY();\n-        }\n-\n-        void deltaMove(final int x, final int y) {\n-            int deltaX = x - this.startMouseX;\n-            int deltaY = y - this.startMouseY;\n-\n-            setPosition(this.startX + deltaX, this.startY + deltaY);\n-        }\n-\n-        void stopMove() {\n-            this.inMove = false;\n-        }\n-\n-        void setResizeRectangle(final int size) {\n-            this.resizeRect.size = size;\n-\n-            \/\/ set the rect (bottom right corner of the Window)\n-            this.resizeRect.x = getWidth() - this.resizeRect.size;\n-            this.resizeRect.y = getHeight() - this.resizeRect.size;\n-            this.resizeRect.width = this.resizeRect.size;\n-            this.resizeRect.height = this.resizeRect.size;\n-        }\n-\n-        boolean shouldStartResize(final int x, final int y) {\n-            return this.resizeRect.contains(x, y);\n-        }\n-\n-        boolean inResize() {\n-            return this.inResize;\n-        }\n-\n-        void startResize(final int x, final int y) {\n-            this.inResize = true;\n-\n-            this.startMouseX = x;\n-            this.startMouseY = y;\n-\n-            this.startWidth = getWidth();\n-            this.startHeight = getHeight();\n-        }\n-\n-        void deltaResize(final int x, final int y) {\n-            int deltaX = x - this.startMouseX;\n-            int deltaY = y - this.startMouseY;\n-\n-            setSize(this.startWidth + deltaX, this.startHeight + deltaY);\n-        }\n-\n-        protected void stopResize() {\n-            this.inResize = false;\n-        }\n-\n-        void updateRectangles() {\n-            if (this.moveRect.size > 0) {\n-                setMoveRectangle(this.moveRect.size);\n-            }\n-            if (this.resizeRect.size > 0) {\n-                setResizeRectangle(this.resizeRect.size);\n-            }\n-        }\n-\n-        boolean handleMouseEvent(final int type, final int button, final int x, final int y, final int xAbs, final int yAbs) {\n-            switch (type) {\n-                case MouseEvent.DOWN:\n-                    if (button == MouseEvent.BUTTON_LEFT) {\n-                        if (shouldStartUndecoratedMove(x, y) == true) {\n-                            startMove(xAbs, yAbs);\n-                            return true;\n-                        } else if (shouldStartUndecoratedResize(x, y) == true) {\n-                            startResize(xAbs, yAbs);\n-                            return true;\n-                        }\n-                    }\n-                    break;\n-\n-                case MouseEvent.MOVE:\n-                case MouseEvent.DRAG:\n-                    if (inMove() == true) {\n-                        deltaMove(xAbs, yAbs);\n-                        return true;\n-                    } else if (inResize() == true) {\n-                        deltaResize(xAbs, yAbs);\n-                        return true;\n-                    }\n-                    break;\n-\n-                case MouseEvent.UP:\n-                    boolean wasProcessed = inMove() || inResize();\n-                    stopResize();\n-                    stopMove();\n-                    return wasProcessed;\n-            }\n-            return false;\n-        }\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/Window.java","additions":105,"deletions":292,"binary":false,"changes":397,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -441,0 +441,5 @@\n+    @Override\n+    protected boolean _supportsExtendedWindows() {\n+        return true;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkApplication.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.glass.ui.HeaderButtonOverlay;\n@@ -29,0 +30,1 @@\n+import com.sun.javafx.tk.HeaderAreaType;\n@@ -139,0 +141,30 @@\n+\n+    @Override\n+    protected void notifyMenu(int x, int y, int xAbs, int yAbs, boolean isKeyboardTrigger) {\n+        \/\/ If all of the following conditions are satisfied, we open a system menu at the specified coordinates:\n+        \/\/ 1. The application didn't consume the menu event.\n+        \/\/ 2. The window is an EXTENDED window and is not in full-screen mode.\n+        \/\/ 3. The menu event occurred on a draggable area.\n+        if (!handleMenuEvent(x, y, xAbs, yAbs, isKeyboardTrigger)) {\n+            var window = (GtkWindow)getWindow();\n+            if (!window.isExtendedWindow() || isInFullscreen()) {\n+                return;\n+            }\n+\n+            double wx = x \/ window.getPlatformScaleX();\n+            double wy = y \/ window.getPlatformScaleY();\n+\n+            EventHandler eventHandler = getEventHandler();\n+            if (eventHandler != null && eventHandler.pickHeaderArea(wx, wy) == HeaderAreaType.DRAGBAR) {\n+                window.showSystemMenu(x, y);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected boolean handleNonClientMouseEvent(long time, int type, int button, int x, int y, int xAbs, int yAbs,\n+                                                int modifiers, int clickCount) {\n+        return getWindow() instanceof GtkWindow window\n+            && window.headerButtonOverlayProperty().get() instanceof HeaderButtonOverlay overlay\n+            && overlay.handleMouseEvent(type, button, x \/ window.getPlatformScaleX(), y \/ window.getPlatformScaleY());\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkView.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.glass.ui.HeaderButtonMetrics;\n@@ -33,0 +34,2 @@\n+import com.sun.glass.ui.HeaderButtonOverlay;\n+import com.sun.javafx.tk.HeaderAreaType;\n@@ -38,0 +41,4 @@\n+\n+        if (isExtendedWindow()) {\n+            prefHeaderButtonHeightProperty().subscribe(this::onPrefHeaderButtonHeightChanged);\n+        }\n@@ -94,0 +101,2 @@\n+    private native boolean _setSystemMinimumSize(long ptr, int width, int height);\n+\n@@ -120,0 +129,2 @@\n+    private native void _showSystemMenu(long ptr, int x, int y);\n+\n@@ -201,0 +212,90 @@\n+\n+    \/**\n+     * Opens a system menu at the specified coordinates.\n+     *\n+     * @param x the X coordinate in physical pixels\n+     * @param y the Y coordinate in physical pixels\n+     *\/\n+    public void showSystemMenu(int x, int y) {\n+        _showSystemMenu(super.getRawHandle(), x, y);\n+    }\n+\n+    \/**\n+     * Creates or disposes the {@link HeaderButtonOverlay} when the preferred header button height has changed.\n+     * <p>\n+     * If the preferred height is zero, the overlay is disposed; if the preferred height is non-zero, the\n+     * {@link #headerButtonOverlay} and {@link #headerButtonMetrics} properties will hold the overlay and\n+     * its metrics.\n+     *\n+     * @param height the preferred header button height\n+     *\/\n+    private void onPrefHeaderButtonHeightChanged(Number height) {\n+        \/\/ Return early if we can keep the existing overlay instance.\n+        if (height.doubleValue() != 0 && headerButtonOverlay.get() != null) {\n+            return;\n+        }\n+\n+        if (headerButtonOverlay.get() instanceof HeaderButtonOverlay overlay) {\n+            overlay.dispose();\n+        }\n+\n+        if (height.doubleValue() == 0) {\n+            headerButtonOverlay.set(null);\n+            headerButtonMetrics.set(HeaderButtonMetrics.EMPTY);\n+        } else {\n+            HeaderButtonOverlay overlay = createHeaderButtonOverlay();\n+            overlay.metricsProperty().subscribe(headerButtonMetrics::set);\n+            headerButtonOverlay.set(overlay);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new {@code HeaderButtonOverlay} instance.\n+     *\/\n+    private HeaderButtonOverlay createHeaderButtonOverlay() {\n+        var overlay = new HeaderButtonOverlay(\n+            PlatformThemeObserver.getInstance().stylesheetProperty(),\n+            isUtilityWindow(),\n+            (getStyleMask() & RIGHT_TO_LEFT) != 0);\n+\n+        \/\/ Set the system-defined absolute minimum size to the size of the window buttons area,\n+        \/\/ regardless of whether the application has specified a smaller minimum size.\n+        overlay.metricsProperty().subscribe(metrics -> {\n+            int w = (int)(metrics.totalInsetWidth() * platformScaleX);\n+            int h = (int)(metrics.maxInsetHeight() * platformScaleY);\n+            _setSystemMinimumSize(super.getRawHandle(), w, h);\n+        });\n+\n+        overlay.prefButtonHeightProperty().bind(prefHeaderButtonHeightProperty());\n+        return overlay;\n+    }\n+\n+    \/**\n+     * Returns whether the window is draggable at the specified coordinate.\n+     * <p>\n+     * This method is called from native code.\n+     *\n+     * @param x the X coordinate in physical pixels\n+     * @param y the Y coordinate in physical pixels\n+     *\/\n+    @SuppressWarnings(\"unused\")\n+    private boolean dragAreaHitTest(int x, int y) {\n+        \/\/ A full-screen window has no draggable area.\n+        if (view == null || view.isInFullscreen() || !isExtendedWindow()) {\n+            return false;\n+        }\n+\n+        double wx = x \/ platformScaleX;\n+        double wy = y \/ platformScaleY;\n+\n+        if (headerButtonOverlay.get() instanceof HeaderButtonOverlay overlay && overlay.buttonAt(wx, wy) != null) {\n+            return false;\n+        }\n+\n+        View.EventHandler eventHandler = view.getEventHandler();\n+        if (eventHandler == null) {\n+            return false;\n+        }\n+\n+        return eventHandler.pickHeaderArea(wx, wy) == HeaderAreaType.DRAGBAR;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkWindow.java","additions":102,"deletions":1,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui.gtk;\n+\n+import com.sun.javafx.application.PlatformImpl;\n+import javafx.beans.property.ReadOnlyStringProperty;\n+import javafx.beans.property.ReadOnlyStringWrapper;\n+import javafx.collections.MapChangeListener;\n+\n+final class PlatformThemeObserver {\n+\n+    private static final String THEME_NAME_KEY = \"GTK.theme_name\";\n+\n+    private final ReadOnlyStringWrapper stylesheet = new ReadOnlyStringWrapper(this, \"stylesheet\");\n+\n+    private PlatformThemeObserver() {\n+        PlatformImpl.getPlatformPreferences().addListener((MapChangeListener<String, Object>) change -> {\n+            if (THEME_NAME_KEY.equals(change.getKey())) {\n+                updateThemeStylesheets();\n+            }\n+        });\n+\n+        updateThemeStylesheets();\n+    }\n+\n+    public static PlatformThemeObserver getInstance() {\n+        class Holder {\n+            static final PlatformThemeObserver instance = new PlatformThemeObserver();\n+        }\n+\n+        return Holder.instance;\n+    }\n+\n+    public ReadOnlyStringProperty stylesheetProperty() {\n+        return stylesheet.getReadOnlyProperty();\n+    }\n+\n+    private void updateThemeStylesheets() {\n+        stylesheet.set(WindowDecorationTheme.findBestTheme().getStylesheet());\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/PlatformThemeObserver.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui.gtk;\n+\n+import com.sun.javafx.application.PlatformImpl;\n+import javafx.stage.StageStyle;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+\/**\n+ * The client-side window decoration theme used for {@link StageStyle#EXTENDED} windows.\n+ *\/\n+enum WindowDecorationTheme {\n+\n+    GNOME(\"WindowDecorationGnome.css\"),\n+    KDE(\"WindowDecorationKDE.css\");\n+\n+    WindowDecorationTheme(String stylesheet) {\n+        this.stylesheet = stylesheet;\n+    }\n+\n+    private static final String THEME_NAME_KEY = \"GTK.theme_name\";\n+\n+    \/**\n+     * A mapping of platform theme names to the most similar window decoration theme.\n+     *\/\n+    private static final Map<String, WindowDecorationTheme> SIMILAR_THEMES = Map.of(\n+        \"adwaita\", WindowDecorationTheme.GNOME,\n+        \"yaru\", WindowDecorationTheme.GNOME,\n+        \"breeze\", WindowDecorationTheme.KDE\n+    );\n+\n+    private final String stylesheet;\n+\n+    \/**\n+     * Determines the best window decoration theme for the current window manager theme.\n+     * <p>\n+     * Since we can't ship decorations for all possible window manager themes, we need to choose the\n+     * theme most similar to the native window manager theme. If we can't choose a theme by name, we\n+     * fall back to choosing a theme by determining the current window manager.\n+     *\/\n+    public static WindowDecorationTheme findBestTheme() {\n+        return PlatformImpl.getPlatformPreferences()\n+            .getString(THEME_NAME_KEY)\n+            .map(name -> {\n+                for (Map.Entry<String, WindowDecorationTheme> entry : SIMILAR_THEMES.entrySet()) {\n+                    if (name.toLowerCase(Locale.ROOT).startsWith(entry.getKey())) {\n+                        return entry.getValue();\n+                    }\n+                }\n+\n+                return null;\n+            })\n+            .orElse(switch (WindowManager.current()) {\n+                case GNOME -> WindowDecorationTheme.GNOME;\n+                case KDE -> WindowDecorationTheme.KDE;\n+                default -> WindowDecorationTheme.GNOME;\n+            });\n+    }\n+\n+    public String getStylesheet() {\n+        var url = getClass().getResource(stylesheet);\n+        if (url == null) {\n+            throw new RuntimeException(\"Resource not found: \" + stylesheet);\n+        }\n+\n+        return url.toExternalForm();\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/WindowDecorationTheme.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui.gtk;\n+\n+import java.util.Locale;\n+\n+\/**\n+ * The window manager of the current desktop environment.\n+ *\/\n+enum WindowManager {\n+    UNKNOWN,\n+    GNOME,\n+    KDE;\n+\n+    \/**\n+     * Returns the window manager of the current desktop environment.\n+     *\/\n+    public static WindowManager current() {\n+        var result = parse(System.getenv(\"XDG_CURRENT_DESKTOP\"));\n+        if (result != UNKNOWN) {\n+            return result;\n+        }\n+\n+        result = parse(System.getenv(\"GDMSESSION\"));\n+        if (result != UNKNOWN) {\n+            return result;\n+        }\n+\n+        if (System.getenv(\"KDE_FULL_SESSION\") != null) {\n+            return KDE;\n+        }\n+\n+        return UNKNOWN;\n+    }\n+\n+    private static WindowManager parse(String value) {\n+        if (value == null) {\n+            return UNKNOWN;\n+        }\n+\n+        String v = value.toLowerCase(Locale.ROOT);\n+\n+        if (v.contains(\"gnome\")) {\n+            return GNOME;\n+        }\n+\n+        if (v.contains(\"kde\")) {\n+            return KDE;\n+        }\n+\n+        return UNKNOWN;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/WindowManager.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,0 +225,5 @@\n+    @Override\n+    protected boolean _supportsExtendedWindows() {\n+        return false;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/ios\/IosApplication.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -400,0 +400,5 @@\n+    @Override\n+    protected boolean _supportsExtendedWindows() {\n+        return true;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/mac\/MacApplication.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.glass.events.MouseEvent;\n@@ -30,0 +31,2 @@\n+import com.sun.javafx.tk.HeaderAreaType;\n+\n@@ -185,1 +188,0 @@\n-}\n@@ -187,0 +189,21 @@\n+    @Override\n+    protected boolean handleNonClientMouseEvent(long time, int type, int button, int x, int y, int xAbs, int yAbs,\n+                                                int modifiers, int clickCount) {\n+        if (shouldHandleEvent() && type == MouseEvent.DOWN) {\n+            var window = (MacWindow)getWindow();\n+            double wx = x \/ window.getPlatformScaleX();\n+            double wy = y \/ window.getPlatformScaleY();\n+\n+            View.EventHandler eventHandler = getEventHandler();\n+            if (eventHandler != null && eventHandler.pickHeaderArea(wx, wy) == HeaderAreaType.DRAGBAR) {\n+                if (clickCount == 2) {\n+                    window.performTitleBarDoubleClickAction();\n+                } else if (clickCount == 1) {\n+                    window.performWindowDrag();\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/mac\/MacView.java","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.glass.ui.HeaderButtonMetrics;\n@@ -33,0 +34,2 @@\n+import javafx.geometry.Dimension2D;\n+import javafx.scene.layout.HeaderBar;\n@@ -47,0 +50,4 @@\n+\n+        if (isExtendedWindow()) {\n+            prefHeaderButtonHeightProperty().subscribe(this::onPrefHeaderButtonHeightChanged);\n+        }\n@@ -153,0 +160,59 @@\n+\n+    public void performWindowDrag() {\n+        _performWindowDrag(getRawHandle());\n+    }\n+\n+    public void performTitleBarDoubleClickAction() {\n+        _performTitleBarDoubleClickAction(getRawHandle());\n+    }\n+\n+    private native void _performWindowDrag(long ptr);\n+\n+    private native void _performTitleBarDoubleClickAction(long ptr);\n+\n+    private native boolean _isRightToLeftLayoutDirection();\n+\n+    private native void _setWindowButtonStyle(long ptr, int toolbarStyle, boolean buttonsVisible);\n+\n+    private void onPrefHeaderButtonHeightChanged(Number height) {\n+        double h = height != null ? height.doubleValue() : HeaderBar.USE_DEFAULT_SIZE;\n+        var toolbarStyle = NSWindowToolbarStyle.ofHeight(h);\n+        _setWindowButtonStyle(getRawHandle(), toolbarStyle.style, h != 0);\n+        updateHeaderButtonMetrics(toolbarStyle, h);\n+    }\n+\n+    private void updateHeaderButtonMetrics(NSWindowToolbarStyle toolbarStyle, double prefButtonHeight) {\n+        double minHeight = NSWindowToolbarStyle.SMALL.size.getHeight();\n+        var empty = new Dimension2D(0, 0);\n+        var size = isUtilityWindow() ? toolbarStyle.utilitySize : toolbarStyle.size;\n+\n+        HeaderButtonMetrics metrics = prefButtonHeight != 0\n+            ? _isRightToLeftLayoutDirection()\n+                ? new HeaderButtonMetrics(empty, size, minHeight)\n+                : new HeaderButtonMetrics(size, empty, minHeight)\n+            : new HeaderButtonMetrics(empty, empty, minHeight);\n+\n+        headerButtonMetrics.set(metrics);\n+    }\n+\n+    private enum NSWindowToolbarStyle {\n+        SMALL(68, 28, 1), \/\/ NSWindowToolbarStyleExpanded\n+        MEDIUM(78, 38, 4), \/\/ NSWindowToolbarStyleUnifiedCompact\n+        LARGE(90, 52, 3); \/\/ NSWindowToolbarStyleUnified\n+\n+        NSWindowToolbarStyle(double width, double height, int style) {\n+            this.size = new Dimension2D(width, height);\n+            this.utilitySize = new Dimension2D(height, height); \/\/ width intentionally set to height\n+            this.style = style;\n+        }\n+\n+        final Dimension2D size;\n+        final Dimension2D utilitySize;\n+        final int style;\n+\n+        static NSWindowToolbarStyle ofHeight(double height) {\n+            if (height >= LARGE.size.getHeight()) return LARGE;\n+            if (height >= MEDIUM.size.getHeight()) return MEDIUM;\n+            return SMALL;\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/mac\/MacWindow.java","additions":67,"deletions":1,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -304,0 +304,5 @@\n+    @Override\n+    protected boolean _supportsExtendedWindows() {\n+        return false;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/monocle\/MonocleApplication.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -339,0 +339,5 @@\n+    @Override\n+    protected boolean _supportsExtendedWindows() {\n+        return true;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinApplication.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui.win;\n+\n+import com.sun.glass.ui.HeaderButtonOverlay;\n+import com.sun.javafx.binding.StringConstant;\n+import javafx.beans.value.ObservableValue;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.HeaderButtonType;\n+import javafx.stage.Window;\n+\n+\/**\n+ * Windows-specific version of {@link HeaderButtonOverlay} that tweaks the scaling of header button glyphs.\n+ *\/\n+public class WinHeaderButtonOverlay extends HeaderButtonOverlay {\n+\n+    private static final String HEADER_BUTTONS_STYLESHEET = \"WindowDecoration.css\";\n+\n+    \/**\n+     * These are additional scale factors for the header button glyphs at various DPI scales to account\n+     * for differences in the way the glyphs are rendered by JavaFX and Windows. Slightly adjusting\n+     * the scaling makes the JavaFX glyphs look more similar to the native glyphs drawn by Windows.\n+     * The values must be listed in 25% increments. DPI scales outside of the listed range default\n+     * to an additional scaling factor of 1.\n+     *\/\n+    private static final double[][] SCALE_FACTORS = new double[][] {\n+        { 1.0, 1.15 },\n+        { 1.25, 1.1 },\n+        { 1.5, 1.15 },\n+        { 1.75, 1.0 },\n+        { 2.0, 1.15 },\n+        { 2.25, 1.05 },\n+        { 2.5, 0.95 },\n+    };\n+\n+    public WinHeaderButtonOverlay(boolean utility, boolean rightToLeft) {\n+        super(getStylesheet(), utility, rightToLeft);\n+\n+        var windowProperty = sceneProperty().flatMap(Scene::windowProperty);\n+\n+        windowProperty\n+            .flatMap(Window::renderScaleXProperty)\n+            .orElse(1.0)\n+            .map(v -> getGlyphScaleFactor(v.doubleValue()))\n+            .subscribe(this::updateGlyphScaleX);\n+\n+        windowProperty\n+            .flatMap(Window::renderScaleYProperty)\n+            .orElse(1.0)\n+            .map(v -> getGlyphScaleFactor(v.doubleValue()))\n+            .subscribe(this::updateGlyphScaleY);\n+    }\n+\n+    private double getGlyphScaleFactor(double scale) {\n+        for (double[] mapping : SCALE_FACTORS) {\n+            if (scale >= (mapping[0] - 0.125) && scale <= (mapping[0] + 0.125)) {\n+                return mapping[1];\n+            }\n+        }\n+\n+        return 1.0;\n+    }\n+\n+    private void updateGlyphScaleX(double scale) {\n+        for (var buttonType : HeaderButtonType.values()) {\n+            getButtonGlyph(buttonType).setScaleX(scale);\n+        }\n+    }\n+\n+    private void updateGlyphScaleY(double scale) {\n+        for (var buttonType : HeaderButtonType.values()) {\n+            getButtonGlyph(buttonType).setScaleY(scale);\n+        }\n+    }\n+\n+    private static ObservableValue<String> getStylesheet() {\n+        var url = WinHeaderButtonOverlay.class.getResource(HEADER_BUTTONS_STYLESHEET);\n+        if (url == null) {\n+            throw new RuntimeException(\"Resource not found: \" + HEADER_BUTTONS_STYLESHEET);\n+        }\n+\n+        return StringConstant.valueOf(url.toExternalForm());\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinHeaderButtonOverlay.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.glass.ui.HeaderButtonOverlay;\n@@ -29,0 +30,2 @@\n+import com.sun.javafx.tk.HeaderAreaType;\n+\n@@ -98,1 +101,0 @@\n-}\n@@ -100,0 +102,45 @@\n+    @Override\n+    protected void notifyMenu(int x, int y, int xAbs, int yAbs, boolean isKeyboardTrigger) {\n+        \/\/ If all of the following conditions are satisfied, we open a system menu at the specified coordinates:\n+        \/\/ 1. The application didn't consume the menu event.\n+        \/\/ 2. The window is an EXTENDED window and is not in full-screen mode.\n+        \/\/ 3. The menu event occurred on a draggable area.\n+        if (!handleMenuEvent(x, y, xAbs, yAbs, isKeyboardTrigger)) {\n+            var window = (WinWindow)getWindow();\n+            if (!window.isExtendedWindow() || isInFullscreen()) {\n+                return;\n+            }\n+\n+            double wx = x \/ window.getPlatformScaleX();\n+            double wy = y \/ window.getPlatformScaleY();\n+\n+            EventHandler eventHandler = getEventHandler();\n+            if (eventHandler != null && eventHandler.pickHeaderArea(wx, wy) == HeaderAreaType.DRAGBAR) {\n+                window.showSystemMenu(x, y);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected boolean handleNonClientMouseEvent(long time, int type, int button, int x, int y, int xAbs, int yAbs,\n+                                                int modifiers, int clickCount) {\n+        if (!shouldHandleEvent()) {\n+            return false;\n+        }\n+\n+        if (getWindow() instanceof WinWindow window &&\n+                window.headerButtonOverlayProperty().get() instanceof HeaderButtonOverlay overlay) {\n+            double wx = x \/ window.getPlatformScaleX();\n+            double wy = y \/ window.getPlatformScaleY();\n+\n+            \/\/ Give the header button overlay the first chance to handle the event.\n+            if (overlay.handleMouseEvent(type, button, wx, wy)) {\n+                return true;\n+            }\n+        }\n+\n+        \/\/ If the overlay didn't handle the event, we pass it down to the application.\n+        handleMouseEvent(time, type, button, x, y, xAbs, yAbs, modifiers, false, false);\n+        return true;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinView.java","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.glass.ui.HeaderButtonMetrics;\n+import com.sun.glass.ui.HeaderButtonOverlay;\n@@ -43,4 +45,4 @@\n-    float fxReqWidth;\n-    float fxReqHeight;\n-    int pfReqWidth;\n-    int pfReqHeight;\n+    private float fxReqWidth;\n+    private float fxReqHeight;\n+    private int pfReqWidth;\n+    private int pfReqHeight;\n@@ -55,0 +57,4 @@\n+\n+        if (isExtendedWindow()) {\n+            prefHeaderButtonHeightProperty().subscribe(this::onPrefHeaderButtonHeightChanged);\n+        }\n@@ -118,0 +124,4 @@\n+            int maxW = getMaximumWidth(), maxH = getMaximumHeight();\n+            pw = Math.max(Math.min(pw, maxW > 0 ? maxW : Integer.MAX_VALUE), getMinimumWidth());\n+            ph = Math.max(Math.min(ph, maxH > 0 ? maxH : Integer.MAX_VALUE), getMinimumHeight());\n+\n@@ -260,0 +270,1 @@\n+    native private void _showSystemMenu(long ptr, int x, int y);\n@@ -318,0 +329,4 @@\n+            if (headerButtonOverlay.get() instanceof HeaderButtonOverlay overlay) {\n+                overlay.dispose();\n+            }\n+\n@@ -324,0 +339,96 @@\n+\n+    \/**\n+     * Opens a system menu at the specified coordinates.\n+     *\n+     * @param x the X coordinate in physical pixels\n+     * @param y the Y coordinate in physical pixels\n+     *\/\n+    public void showSystemMenu(int x, int y) {\n+        _showSystemMenu(getRawHandle(), x, y);\n+    }\n+\n+    \/**\n+     * Creates or disposes the {@link HeaderButtonOverlay} when the preferred header button height has changed.\n+     * <p>\n+     * If the preferred height is zero, the overlay is disposed; if the preferred height is non-zero, the\n+     * {@link #headerButtonOverlay} and {@link #headerButtonMetrics} properties will hold the overlay and\n+     * its metrics.\n+     *\n+     * @param height the preferred header button height\n+     *\/\n+    private void onPrefHeaderButtonHeightChanged(Number height) {\n+        \/\/ Return early if we can keep the existing overlay instance.\n+        if (height.doubleValue() != 0 && headerButtonOverlay.get() != null) {\n+            return;\n+        }\n+\n+        if (headerButtonOverlay.get() instanceof HeaderButtonOverlay overlay) {\n+            overlay.dispose();\n+        }\n+\n+        if (height.doubleValue() == 0) {\n+            headerButtonOverlay.set(null);\n+            headerButtonMetrics.set(HeaderButtonMetrics.EMPTY);\n+        } else {\n+            HeaderButtonOverlay overlay = createHeaderButtonOverlay();\n+            overlay.metricsProperty().subscribe(headerButtonMetrics::set);\n+            headerButtonOverlay.set(overlay);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new {@code HeaderButtonOverlay} instance.\n+     *\/\n+    private HeaderButtonOverlay createHeaderButtonOverlay() {\n+        var overlay = new WinHeaderButtonOverlay(\n+            isUtilityWindow(),\n+            (getStyleMask() & RIGHT_TO_LEFT) != 0);\n+\n+        overlay.prefButtonHeightProperty().bind(prefHeaderButtonHeightProperty());\n+        return overlay;\n+    }\n+\n+    \/**\n+     * Classifies the window region at the specified physical coordinate.\n+     * <p>\n+     * This method is called from native code.\n+     *\n+     * @param x the X coordinate in physical pixels\n+     * @param y the Y coordinate in physical pixels\n+     *\/\n+    @SuppressWarnings(\"unused\")\n+    private int nonClientHitTest(int x, int y) {\n+        \/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/inputdev\/wm-nchittest\n+        enum HT {\n+            CLIENT(1), CAPTION(2), MINBUTTON(8), MAXBUTTON(9), CLOSE(20);\n+            HT(int value) { this.value = value; }\n+            final int value;\n+        }\n+\n+        \/\/ A full-screen window has no non-client area.\n+        if (view == null || view.isInFullscreen() || !isExtendedWindow()) {\n+            return HT.CLIENT.value;\n+        }\n+\n+        double wx = x \/ platformScaleX;\n+        double wy = y \/ platformScaleY;\n+\n+        \/\/ If the cursor is over one of the window buttons (minimize, maximize, close), we need to\n+        \/\/ report the value of HTMINBUTTON, HTMAXBUTTON, or HTCLOSE back to the native layer.\n+        switch (headerButtonOverlay.get() instanceof HeaderButtonOverlay overlay ? overlay.buttonAt(wx, wy) : null) {\n+            case ICONIFY: return HT.MINBUTTON.value;\n+            case MAXIMIZE: return HT.MAXBUTTON.value;\n+            case CLOSE: return HT.CLOSE.value;\n+            case null: break;\n+        }\n+\n+        \/\/ Otherwise, test if the cursor is over a draggable area and return HTCAPTION.\n+        View.EventHandler eventHandler = view.getEventHandler();\n+        return switch (eventHandler != null ? eventHandler.pickHeaderArea(wx, wy) : null) {\n+            case DRAGBAR -> HT.CAPTION.value;\n+            case ICONIFY -> HT.MINBUTTON.value;\n+            case MAXIMIZE -> HT.MAXBUTTON.value;\n+            case CLOSE -> HT.CLOSE.value;\n+            case null -> HT.CLIENT.value;\n+        };\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinWindow.java","additions":116,"deletions":5,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import javafx.scene.Scene;\n@@ -193,0 +194,8 @@\n+    public static void setScenes(Node node, Scene newScene, SubScene newSubScene) {\n+        nodeAccessor.setScenes(node, newScene, newSubScene);\n+    }\n+\n+    public static void updateBounds(Node node) {\n+        nodeAccessor.updateBounds(node);\n+    }\n+\n@@ -361,0 +370,2 @@\n+        void setScenes(Node node, Scene newScene, SubScene newSubScene);\n+        void updateBounds(Node node);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/NodeHelper.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene.layout;\n+\n+import com.sun.javafx.PlatformUtil;\n+import javafx.beans.value.ObservableValue;\n+import javafx.css.PseudoClass;\n+import javafx.event.EventHandler;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.layout.HeaderButtonType;\n+import javafx.stage.Modality;\n+import javafx.stage.Stage;\n+import javafx.util.Subscription;\n+import java.util.Objects;\n+\n+public final class HeaderButtonBehavior implements EventHandler<MouseEvent> {\n+\n+    private static final PseudoClass MAXIMIZED_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"maximized\");\n+\n+    private final Node node;\n+    private final HeaderButtonType type;\n+    private final Subscription subscription;\n+\n+    public HeaderButtonBehavior(Node node, HeaderButtonType type) {\n+        this.node = Objects.requireNonNull(node);\n+        this.type = Objects.requireNonNull(type);\n+\n+        ObservableValue<Stage> stage = node.sceneProperty()\n+            .flatMap(Scene::windowProperty)\n+            .map(w -> w instanceof Stage s ? s : null);\n+\n+        if (type == HeaderButtonType.MAXIMIZE) {\n+            subscription = Subscription.combine(\n+                stage.flatMap(Stage::resizableProperty).subscribe(this::onResizableChanged),\n+                stage.flatMap(Stage::fullScreenProperty).subscribe(this::onFullScreenChanged),\n+                stage.flatMap(Stage::maximizedProperty).subscribe(this::onMaximizedChanged),\n+                () -> node.removeEventHandler(MouseEvent.MOUSE_RELEASED, this)\n+            );\n+        } else {\n+            subscription = Subscription.combine(\n+                stage.flatMap(Stage::fullScreenProperty).subscribe(this::onFullScreenChanged),\n+                () -> node.removeEventHandler(MouseEvent.MOUSE_RELEASED, this)\n+            );\n+        }\n+\n+        node.addEventHandler(MouseEvent.MOUSE_RELEASED, this);\n+\n+        if (!node.focusTraversableProperty().isBound()) {\n+            node.setFocusTraversable(false);\n+        }\n+    }\n+\n+    public void dispose() {\n+        subscription.unsubscribe();\n+    }\n+\n+    @Override\n+    public void handle(MouseEvent event) {\n+        if (!node.getLayoutBounds().contains(event.getX(), event.getY())) {\n+            return;\n+        }\n+\n+        Stage stage = getStage();\n+        if (stage == null) {\n+            return;\n+        }\n+\n+        switch (type) {\n+            case CLOSE -> stage.close();\n+            case ICONIFY -> stage.setIconified(true);\n+            case MAXIMIZE -> {\n+                \/\/ On macOS, a non-modal window is put into full-screen mode when the maximize button is clicked,\n+                \/\/ but enlarged to cover the desktop when the option key is pressed at the same time.\n+                if (PlatformUtil.isMac() && stage.getModality() == Modality.NONE && !event.isAltDown()) {\n+                    stage.setFullScreen(!stage.isFullScreen());\n+                } else {\n+                    stage.setMaximized(!stage.isMaximized());\n+                }\n+            }\n+        }\n+    }\n+\n+    private Stage getStage() {\n+        Scene scene = node.getScene();\n+        if (scene == null) {\n+            return null;\n+        }\n+\n+        return scene.getWindow() instanceof Stage stage ? stage : null;\n+    }\n+\n+    private void onResizableChanged(Boolean resizable) {\n+        if (!node.disableProperty().isBound()) {\n+            node.setDisable(resizable == Boolean.FALSE);\n+        }\n+    }\n+\n+    private void onFullScreenChanged(Boolean fullScreen) {\n+        if (!node.visibleProperty().isBound() && !node.managedProperty().isBound()) {\n+            node.setVisible(fullScreen != Boolean.TRUE);\n+            node.setManaged(fullScreen != Boolean.TRUE);\n+        }\n+    }\n+\n+    private void onMaximizedChanged(Boolean maximized) {\n+        node.pseudoClassStateChanged(MAXIMIZED_PSEUDO_CLASS, maximized == Boolean.TRUE);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/layout\/HeaderButtonBehavior.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.glass.ui.HeaderButtonMetrics;\n@@ -29,0 +30,1 @@\n+import javafx.beans.value.ObservableValue;\n@@ -74,0 +76,12 @@\n+    public static void setPrefHeaderButtonHeight(Stage stage, double height) {\n+        stageAccessor.setPrefHeaderButtonHeight(stage, height);\n+    }\n+\n+    public static double getPrefHeaderButtonHeight(Stage stage) {\n+        return stageAccessor.getPrefHeaderButtonHeight(stage);\n+    }\n+\n+    public static ObservableValue<HeaderButtonMetrics> getHeaderButtonMetrics(Stage stage) {\n+        return stageAccessor.getHeaderButtonMetrics(stage);\n+    }\n+\n@@ -89,2 +103,5 @@\n-        public void setPrimary(Stage stage,  boolean primary);\n-        public void setImportant(Stage stage,  boolean important);\n+        void setPrimary(Stage stage,  boolean primary);\n+        void setImportant(Stage stage,  boolean important);\n+        void setPrefHeaderButtonHeight(Stage stage, double height);\n+        double getPrefHeaderButtonHeight(Stage stage);\n+        ObservableValue<HeaderButtonMetrics> getHeaderButtonMetrics(Stage stage);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/stage\/StageHelper.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.glass.ui.HeaderButtonMetrics;\n@@ -41,0 +42,1 @@\n+        public void setHeaderButtonMetrics(Stage stage, HeaderButtonMetrics metrics);\n@@ -75,1 +77,3 @@\n-\n+    public void changedHeaderButtonMetrics(HeaderButtonMetrics metrics) {\n+        stageAccessor.setHeaderButtonMetrics(stage, metrics);\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/stage\/StagePeerListener.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.tk;\n+\n+\/**\n+ * Identifies the semantic parts of the header area.\n+ *\/\n+public enum HeaderAreaType {\n+    DRAGBAR,\n+    ICONIFY,\n+    MAXIMIZE,\n+    CLOSE\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/HeaderAreaType.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,6 @@\n+\n+    default void processOverlayCSS() {}\n+\n+    default void layoutOverlay() {}\n+\n+    default void synchronizeOverlay() {}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/TKScene.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,6 @@\n-    public void menuEvent(double x, double y, double xAbs, double yAbs,\n+    \/**\n+     * Pass a menu event to the scene to handle.\n+     *\n+     * @return {@code true} if the event was handled by the scene, {@code false} otherwise\n+     *\/\n+    public boolean menuEvent(double x, double y, double xAbs, double yAbs,\n@@ -123,0 +128,10 @@\n+\n+    \/**\n+     * Returns the header area type at the specified coordinates, or {@code null}\n+     * if the specified coordinates do not intersect with a header area.\n+     *\n+     * @param x the X coordinate relative to the scene\n+     * @param y the Y coordinate relative to the scene\n+     * @return the header area type, or {@code null}\n+     *\/\n+    public HeaderAreaType pickHeaderArea(double x, double y);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/TKSceneListener.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,0 +125,2 @@\n+    public void setPrefHeaderButtonHeight(double height);\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/TKStage.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,3 @@\n+    @Override\n+    public void setPrefHeaderButtonHeight(double height) {}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/GlassStage.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import com.sun.javafx.tk.HeaderAreaType;\n@@ -389,3 +390,3 @@\n-    @Override public void handleMenuEvent(final View view,\n-                                          final int x, final int y, final int xAbs, final int yAbs,\n-                                          final boolean isKeyboardTrigger)\n+    @Override public boolean handleMenuEvent(final View view,\n+                                             final int x, final int y, final int xAbs, final int yAbs,\n+                                             final boolean isKeyboardTrigger)\n@@ -398,1 +399,1 @@\n-            QuantumToolkit.runWithoutRenderLock(() -> {\n+            return QuantumToolkit.runWithoutRenderLock(() -> {\n@@ -418,4 +419,4 @@\n-                    scene.sceneListener.menuEvent(x \/ pScaleX, y \/ pScaleY,\n-                                                  sx + (xAbs - spx) \/ pScaleX,\n-                                                  sy + (yAbs - spy) \/ pScaleY,\n-                                                  isKeyboardTrigger);\n+                    return scene.sceneListener.menuEvent(x \/ pScaleX, y \/ pScaleY,\n+                                                         sx + (xAbs - spx) \/ pScaleX,\n+                                                         sy + (yAbs - spy) \/ pScaleY,\n+                                                         isKeyboardTrigger);\n@@ -423,1 +424,1 @@\n-                return null;\n+                return false;\n@@ -800,2 +801,1 @@\n-                    scene.sceneListener.changedSize(view.getWidth()  \/ pScaleX,\n-                                                    view.getHeight() \/ pScaleY);\n+                    scene.setViewSize(view.getWidth() \/ pScaleX, view.getHeight() \/ pScaleY);\n@@ -1249,0 +1249,11 @@\n+\n+    @Override\n+    public HeaderAreaType pickHeaderArea(double x, double y) {\n+        return QuantumToolkit.runWithoutRenderLock(() -> {\n+            if (scene.sceneListener != null) {\n+                return scene.sceneListener.pickHeaderArea(x, y);\n+            }\n+\n+            return null;\n+        });\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/GlassViewEventHandler.java","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import com.sun.javafx.scene.DirtyBits;\n-import com.sun.javafx.scene.NodeHelper;\n@@ -36,1 +34,0 @@\n-import javafx.scene.Node;\n@@ -45,16 +42,0 @@\n-    static {\n-        \/\/ This is used by classes in different packages to get access to\n-        \/\/ private and package private methods.\n-        OverlayWarningHelper.setOverlayWarningAccessor(\n-                new OverlayWarningHelper.OverlayWarningAccessor() {\n-            @Override\n-            public void doUpdatePeer(Node node) {\n-                ((OverlayWarning) node).doUpdatePeer();\n-            }\n-\n-            @Override\n-            public void doMarkDirty(Node node, DirtyBits dirtyBit) {\n-                ((OverlayWarning) node).doMarkDirty(dirtyBit);\n-            }\n-        });\n-    }\n@@ -72,5 +53,0 @@\n-    {\n-        \/\/ To initialize the class helper at the begining each constructor of this class\n-        OverlayWarningHelper.initHelper(this);\n-    }\n-\n@@ -173,20 +149,0 @@\n-\n-    \/*\n-     * Note: This method MUST only be called via its accessor method.\n-     *\/\n-    private void doUpdatePeer() {\n-        NodeHelper.updatePeer(text);\n-        NodeHelper.updatePeer(background);\n-    }\n-\n-    @Override\n-    protected void updateBounds() {\n-        super.updateBounds();\n-    }\n-\n-    \/*\n-     * Note: This method MUST only be called via its accessor method.\n-     *\/\n-    private void doMarkDirty(DirtyBits dirtyBit) {\n-        view.synchroniseOverlayWarning();\n-    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/OverlayWarning.java","additions":1,"deletions":45,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.tk.quantum;\n-\n-import com.sun.javafx.scene.DirtyBits;\n-import com.sun.javafx.scene.GroupHelper;\n-import com.sun.javafx.util.Utils;\n-import javafx.scene.Node;\n-\n-\/**\n- * Used to access internal methods of OverlayWarning.\n- *\/\n-public class OverlayWarningHelper extends GroupHelper {\n-\n-    private static final OverlayWarningHelper theInstance;\n-    private static OverlayWarningAccessor overlayWarningAccessor;\n-\n-    static {\n-        theInstance = new OverlayWarningHelper();\n-        Utils.forceInit(OverlayWarning.class);\n-    }\n-\n-    private static OverlayWarningHelper getInstance() {\n-        return theInstance;\n-    }\n-\n-    public static void initHelper(OverlayWarning overlayWarning) {\n-        setHelper(overlayWarning, getInstance());\n-    }\n-\n-    @Override\n-    protected void updatePeerImpl(Node node) {\n-        overlayWarningAccessor.doUpdatePeer(node);\n-        super.updatePeerImpl(node);\n-    }\n-\n-    @Override\n-    protected void markDirtyImpl(Node node, DirtyBits dirtyBit) {\n-        super.markDirtyImpl(node, dirtyBit);\n-        overlayWarningAccessor.doMarkDirty(node, dirtyBit);\n-    }\n-\n-    public static void setOverlayWarningAccessor(final OverlayWarningAccessor newAccessor) {\n-        if (overlayWarningAccessor != null) {\n-            throw new IllegalStateException();\n-        }\n-\n-        overlayWarningAccessor = newAccessor;\n-    }\n-\n-    public interface OverlayWarningAccessor {\n-        void doMarkDirty(Node node, DirtyBits dirtyBit);\n-        void doUpdatePeer(Node node);\n-    }\n-\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/OverlayWarningHelper.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1235,0 +1235,2 @@\n+            case EXTENDED_WINDOW:\n+                return Application.GetApplication().supportsExtendedWindows();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/QuantumToolkit.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import com.sun.javafx.scene.NodeHelper;\n@@ -39,0 +38,1 @@\n+import javafx.scene.Parent;\n@@ -45,0 +45,1 @@\n+    private final javafx.scene.Scene fxScene;\n@@ -47,1 +48,0 @@\n-\n@@ -49,0 +49,2 @@\n+    private ViewSceneOverlay viewSceneOverlay;\n+    private Parent overlayRoot;\n@@ -50,1 +52,1 @@\n-    public ViewScene(boolean depthBuffer, boolean msaa) {\n+    public ViewScene(javafx.scene.Scene fxScene, boolean depthBuffer, boolean msaa) {\n@@ -53,0 +55,1 @@\n+        this.fxScene = fxScene;\n@@ -84,0 +87,8 @@\n+\n+            if (fxScene != null) {\n+                viewSceneOverlay = new ViewSceneOverlay(fxScene, painter);\n+                viewSceneOverlay.setRoot(overlayRoot);\n+            } else {\n+                viewSceneOverlay = null;\n+            }\n+\n@@ -104,0 +115,1 @@\n+                viewSceneOverlay = null;\n@@ -155,3 +167,5 @@\n-    @Override public String toString() {\n-        View view = getPlatformView();\n-        return (\" scene: \" + hashCode() + \" @ (\" + view.getWidth() + \",\" + view.getHeight() + \")\");\n+    @Override\n+    public void processOverlayCSS() {\n+        if (viewSceneOverlay != null) {\n+            viewSceneOverlay.processCSS();\n+        }\n@@ -160,14 +174,19 @@\n-    void synchroniseOverlayWarning() {\n-        try {\n-            waitForSynchronization();\n-            OverlayWarning warning = getWindowStage().getWarning();\n-            if (warning == null) {\n-                painter.setOverlayRoot(null);\n-            } else {\n-                painter.setOverlayRoot(NodeHelper.getPeer(warning));\n-                warning.updateBounds();\n-                NodeHelper.updatePeer(warning);\n-            }\n-        } finally {\n-            releaseSynchronization(true);\n-            entireSceneNeedsRepaint();\n+    @Override\n+    public void layoutOverlay() {\n+        if (viewSceneOverlay != null) {\n+            viewSceneOverlay.layout();\n+        }\n+    }\n+\n+    @Override\n+    public void synchronizeOverlay() {\n+        if (viewSceneOverlay != null) {\n+            viewSceneOverlay.synchronize();\n+        }\n+    }\n+\n+    public void setViewSize(float width, float height) {\n+        sceneListener.changedSize(width, height);\n+\n+        if (viewSceneOverlay != null) {\n+            viewSceneOverlay.resize(width, height);\n@@ -176,0 +195,13 @@\n+\n+    public void setOverlay(Parent root) {\n+        overlayRoot = root;\n+\n+        if (viewSceneOverlay != null) {\n+            viewSceneOverlay.setRoot(root);\n+        }\n+    }\n+\n+    @Override public String toString() {\n+        View view = getPlatformView();\n+        return (\" scene: \" + hashCode() + \" @ (\" + view.getWidth() + \",\" + view.getHeight() + \")\");\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/ViewScene.java","additions":53,"deletions":21,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.tk.quantum;\n+\n+import com.sun.javafx.scene.NodeHelper;\n+import com.sun.javafx.scene.SceneHelper;\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+import javafx.scene.SubScene;\n+\n+\/**\n+ * Shows an overlay over a {@link javafx.scene.Scene}.\n+ * The overlay is not part of the scene graph, and not accessible by applications.\n+ *\/\n+final class ViewSceneOverlay {\n+\n+    private final javafx.scene.Scene fxScene;\n+    private final ViewPainter painter;\n+    private Parent root;\n+    private boolean rootDirty;\n+    private double width, height;\n+\n+    ViewSceneOverlay(javafx.scene.Scene fxScene, ViewPainter painter) {\n+        this.fxScene = fxScene;\n+        this.painter = painter;\n+    }\n+\n+    public void processCSS() {\n+        if (root != null) {\n+            NodeHelper.processCSS(root);\n+        }\n+    }\n+\n+    public void resize(double width, double height) {\n+        this.width = width;\n+        this.height = height;\n+    }\n+\n+    public void layout() {\n+        if (fxScene == null) {\n+            return;\n+        }\n+\n+        var window = fxScene.getWindow();\n+\n+        if (root != null && window != null) {\n+            root.resize(width, height);\n+            root.layout();\n+            NodeHelper.updateBounds(root);\n+        }\n+    }\n+\n+    public void setRoot(Parent root) {\n+        if (this.root == root) {\n+            return;\n+        }\n+\n+        if (this.root != null) {\n+            NodeHelper.setScenes(this.root, null, null);\n+        }\n+\n+        this.root = root;\n+\n+        if (root != null) {\n+            NodeHelper.setScenes(root, fxScene, null);\n+        }\n+\n+        rootDirty = true;\n+    }\n+\n+    public void synchronize() {\n+        if (rootDirty || (root != null && !NodeHelper.isDirtyEmpty(root))) {\n+            rootDirty = false;\n+\n+            if (root != null) {\n+                syncPeer(root);\n+                painter.setOverlayRoot(NodeHelper.getPeer(root));\n+            } else {\n+                painter.setOverlayRoot(null);\n+                SceneHelper.getPeer(fxScene).entireSceneNeedsRepaint();\n+            }\n+        }\n+    }\n+\n+    private void syncPeer(Node node) {\n+        NodeHelper.syncPeer(node);\n+\n+        if (node instanceof Parent parent) {\n+            for (Node child : parent.getChildrenUnmodifiable()) {\n+                syncPeer(child);\n+            }\n+        } else if (node instanceof SubScene subScene) {\n+            syncPeer(subScene.getRoot());\n+        }\n+\n+        if (node.getClip() != null) {\n+            syncPeer(node.getClip());\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/ViewSceneOverlay.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import com.sun.javafx.stage.StagePeerListener;\n@@ -48,0 +49,1 @@\n+import com.sun.javafx.tk.TKStageListener;\n@@ -132,1 +134,1 @@\n-            boolean resizable = false;\n+            boolean resizable = fxStage != null && fxStage.isResizable();\n@@ -141,0 +143,1 @@\n+                resizable = false;\n@@ -142,0 +145,7 @@\n+                \/\/ Downgrade conditional stage styles if not supported\n+                if (style == StageStyle.UNIFIED && !app.supportsUnifiedWindows()) {\n+                    style = StageStyle.DECORATED;\n+                } else if (style == StageStyle.EXTENDED && !app.supportsExtendedWindows()) {\n+                    style = StageStyle.DECORATED;\n+                }\n+\n@@ -144,3 +154,1 @@\n-                        if (app.supportsUnifiedWindows()) {\n-                            windowMask |= Window.UNIFIED;\n-                        }\n+                        windowMask |= Window.UNIFIED;\n@@ -149,8 +157,4 @@\n-                        windowMask |=\n-                            Window.TITLED | Window.CLOSABLE |\n-                            Window.MINIMIZABLE | Window.MAXIMIZABLE;\n-                        if (ownerWindow != null || modality != Modality.NONE) {\n-                            windowMask &=\n-                                ~(Window.MINIMIZABLE | Window.MAXIMIZABLE);\n-                        }\n-                        resizable = true;\n+                        windowMask |= Window.TITLED | Window.CLOSABLE | Window.MINIMIZABLE | Window.MAXIMIZABLE;\n+                        break;\n+                    case EXTENDED:\n+                        windowMask |= Window.EXTENDED | Window.CLOSABLE | Window.MINIMIZABLE | Window.MAXIMIZABLE;\n@@ -162,2 +166,1 @@\n-                        windowMask |=\n-                                (transparent ? Window.TRANSPARENT : Window.UNTITLED) | Window.CLOSABLE;\n+                        windowMask |= (transparent ? Window.TRANSPARENT : Window.UNTITLED) | Window.CLOSABLE;\n@@ -166,0 +169,4 @@\n+\n+                if (ownerWindow != null || modality != Modality.NONE) {\n+                    windowMask &= ~(Window.MINIMIZABLE | Window.MAXIMIZABLE);\n+                }\n@@ -167,0 +174,1 @@\n+\n@@ -170,2 +178,2 @@\n-            platformWindow =\n-                    app.createWindow(ownerWindow, Screen.getMainScreen(), windowMask);\n+\n+            platformWindow = app.createWindow(ownerWindow, Screen.getMainScreen(), windowMask);\n@@ -174,0 +182,12 @@\n+\n+            if (platformWindow.isExtendedWindow()) {\n+                platformWindow.headerButtonOverlayProperty().subscribe(overlay -> {\n+                    ViewScene scene = getViewScene();\n+                    if (scene != null) {\n+                        scene.setOverlay(isInFullScreen ? null : overlay);\n+                    }\n+                });\n+\n+                platformWindow.headerButtonMetricsProperty().subscribe(this::notifyHeaderButtonMetricsChanged);\n+            }\n+\n@@ -208,0 +228,6 @@\n+    private void notifyHeaderButtonMetricsChanged() {\n+        if (stageListener instanceof StagePeerListener listener && platformWindow != null) {\n+            listener.changedHeaderButtonMetrics(platformWindow.headerButtonMetricsProperty().get());\n+        }\n+    }\n+\n@@ -228,0 +254,6 @@\n+    @Override\n+    public void setTKStageListener(TKStageListener listener) {\n+        super.setTKStageListener(listener);\n+        notifyHeaderButtonMetricsChanged();\n+    }\n+\n@@ -229,1 +261,7 @@\n-        ViewScene scene = new ViewScene(depthBuffer, msaa);\n+        ViewScene scene = new ViewScene(fxStage != null ? fxStage.getScene() : null, depthBuffer, msaa);\n+\n+        \/\/ The window-provided overlay is not visible in full-screen mode.\n+        if (!isInFullScreen) {\n+            scene.setOverlay(platformWindow.headerButtonOverlayProperty().get());\n+        }\n+\n@@ -638,1 +676,0 @@\n-                    setWarning(null);\n@@ -640,0 +677,2 @@\n+\n+                setWarning(null);\n@@ -651,5 +690,5 @@\n-        getViewScene().synchroniseOverlayWarning();\n-    }\n-\n-    OverlayWarning getWarning() {\n-        return warning;\n+        if (newWarning != null) {\n+            getViewScene().setOverlay(newWarning);\n+        } else if (!isInFullScreen) {\n+            getViewScene().setOverlay(platformWindow.headerButtonOverlayProperty().get());\n+        }\n@@ -859,0 +898,6 @@\n+    @Override\n+    public void setPrefHeaderButtonHeight(double height) {\n+        if (platformWindow != null) {\n+            platformWindow.setPrefHeaderButtonHeight(height);\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/WindowStage.java","additions":69,"deletions":24,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,3 @@\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.Paint;\n+import javafx.scene.paint.RadialGradient;\n@@ -218,1 +221,1 @@\n-     * Calculates a perceptual brightness for a color between 0.0 black and 1.0 while\n+     * Calculates a perceptual brightness for a color between 0.0 (black) and 1.0 (white).\n@@ -224,0 +227,25 @@\n+    \/**\n+     * Calculates an average perceptual brightness for a paint between 0.0 (black) and 1.0 (white).\n+     * <p>\n+     * The average brightness of gradient paints only takes into account the colors of gradient stops,\n+     * but not the distribution of the gradient stops across the paint area.\n+     * <p>\n+     * The brightness of {@code ImagePattern} paints is 1.0 by convention.\n+     *\/\n+    public static double calculateAverageBrightness(Paint paint) {\n+        return switch (paint) {\n+            case Color color -> calculateBrightness(color);\n+            case LinearGradient gradient -> calculateAverageGradientBrightness(gradient.getStops());\n+            case RadialGradient gradient -> calculateAverageGradientBrightness(gradient.getStops());\n+            default -> 1.0;\n+        };\n+    }\n+\n+    private static double calculateAverageGradientBrightness(List<Stop> stops) {\n+        return stops.stream()\n+            .map(Stop::getColor)\n+            .mapToDouble(Utils::calculateBrightness)\n+            .average()\n+            .orElse(1.0);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/util\/Utils.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import javafx.stage.StageStyle;\n+\n@@ -142,1 +144,1 @@\n-     *  Indicates that a system supports {@link javafx.stage.StageStyle#UNIFIED}\n+     *  Indicates that a system supports {@link StageStyle#UNIFIED}\n@@ -153,0 +155,11 @@\n+    \/**\n+     * Indicates that a system supports {@link StageStyle#EXTENDED}.\n+     * <p>\n+     * This feature is currently supported on Windows, Linux, and macOS.\n+     *\n+     * @since 25\n+     * @deprecated This is a preview feature which may be changed or removed in a future release.\n+     *\/\n+    @Deprecated(since = \"25\")\n+    EXTENDED_WINDOW,\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/application\/ConditionalFeature.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -501,0 +501,10 @@\n+            @Override\n+            public void setScenes(Node node, Scene newScene, SubScene newSubScene) {\n+                node.setScenes(newScene, newSubScene);\n+            }\n+\n+            @Override\n+            public void updateBounds(Node node) {\n+                node.updateBounds();\n+            }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+import javafx.scene.layout.HeaderBar;\n+import javafx.scene.layout.HeaderButtonType;\n+import javafx.scene.layout.HeaderDragType;\n@@ -83,0 +86,1 @@\n+import javafx.scene.transform.NonInvertibleTransformException;\n@@ -590,0 +594,4 @@\n+        if (peer != null) {\n+            peer.processOverlayCSS();\n+        }\n+\n@@ -639,0 +647,4 @@\n+        if (peer != null) {\n+            peer.layoutOverlay();\n+        }\n+\n@@ -1937,1 +1949,1 @@\n-    private void processMenuEvent(double x2, double y2, double xAbs, double yAbs, boolean isKeyboardTrigger) {\n+    private boolean processMenuEvent(double x2, double y2, double xAbs, double yAbs, boolean isKeyboardTrigger) {\n@@ -1971,0 +1983,2 @@\n+        boolean handled = false;\n+\n@@ -1974,1 +1988,1 @@\n-            Event.fireEvent(eventTarget, context);\n+            handled = EventUtil.fireEvent(eventTarget, context) == null;\n@@ -1977,0 +1991,2 @@\n+\n+        return handled;\n@@ -2524,0 +2540,4 @@\n+            if (peer != null) {\n+                peer.synchronizeOverlay();\n+            }\n+\n@@ -2784,1 +2804,1 @@\n-        public void menuEvent(double x, double y, double xAbs, double yAbs,\n+        public boolean menuEvent(double x, double y, double xAbs, double yAbs,\n@@ -2786,1 +2806,1 @@\n-            Scene.this.processMenuEvent(x, y, xAbs,yAbs, isKeyboardTrigger);\n+            return Scene.this.processMenuEvent(x, y, xAbs,yAbs, isKeyboardTrigger);\n@@ -3041,0 +3061,50 @@\n+        private final PickRay pickRay = new PickRay();\n+\n+        @Override\n+        public HeaderAreaType pickHeaderArea(double x, double y) {\n+            Node root = Scene.this.getRoot();\n+            if (root == null) {\n+                return null;\n+            }\n+\n+            try {\n+                Point2D p = root.getLocalToSceneTransform().inverseTransform(x, y);\n+                pickRay.set(p.getX(), p.getY(), 1, 0, Double.POSITIVE_INFINITY);\n+            } catch (NonInvertibleTransformException e) {\n+                return null;\n+            }\n+\n+            var chooser = new PickResultChooser();\n+            root.pickNode(pickRay, chooser);\n+            Node intersectedNode = chooser.getIntersectedNode();\n+            HeaderDragType dragType = intersectedNode instanceof HeaderBar ? HeaderDragType.DRAGGABLE : null;\n+\n+            while (intersectedNode != null) {\n+                if (intersectedNode instanceof HeaderBar) {\n+                    return dragType == HeaderDragType.DRAGGABLE_SUBTREE\n+                        || dragType == HeaderDragType.DRAGGABLE\n+                        || HeaderBar.getDragType(chooser.getIntersectedNode()) == HeaderDragType.DRAGGABLE\n+                            ? HeaderAreaType.DRAGBAR\n+                            : null;\n+                }\n+\n+                if (HeaderBar.getButtonType(intersectedNode) instanceof HeaderButtonType type) {\n+                    return switch (type) {\n+                        case ICONIFY -> HeaderAreaType.ICONIFY;\n+                        case MAXIMIZE -> HeaderAreaType.MAXIMIZE;\n+                        case CLOSE -> HeaderAreaType.CLOSE;\n+                    };\n+                }\n+\n+                if (dragType == null\n+                        && HeaderBar.getDragType(intersectedNode) instanceof HeaderDragType type\n+                        && type != HeaderDragType.DRAGGABLE) {\n+                    dragType = type;\n+                }\n+\n+                intersectedNode = intersectedNode.getParent();\n+            }\n+\n+            return null;\n+        }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":74,"deletions":4,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -0,0 +1,898 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.layout;\n+\n+import com.sun.glass.ui.HeaderButtonMetrics;\n+import com.sun.javafx.PreviewFeature;\n+import com.sun.javafx.geom.Vec2d;\n+import com.sun.javafx.scene.layout.HeaderButtonBehavior;\n+import com.sun.javafx.stage.StageHelper;\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.BooleanPropertyBase;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.ObjectPropertyBase;\n+import javafx.beans.property.ReadOnlyDoubleProperty;\n+import javafx.beans.property.ReadOnlyDoubleWrapper;\n+import javafx.beans.property.ReadOnlyObjectProperty;\n+import javafx.beans.property.ReadOnlyObjectWrapper;\n+import javafx.beans.value.ObservableValue;\n+import javafx.css.StyleableDoubleProperty;\n+import javafx.event.Event;\n+import javafx.geometry.Dimension2D;\n+import javafx.geometry.HPos;\n+import javafx.geometry.Insets;\n+import javafx.geometry.NodeOrientation;\n+import javafx.geometry.Orientation;\n+import javafx.geometry.Pos;\n+import javafx.geometry.VPos;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.input.ContextMenuEvent;\n+import javafx.scene.input.MouseEvent;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.util.Subscription;\n+\n+\/**\n+ * A client-area header bar that is used as a replacement for the system-provided header bar in stages\n+ * with the {@link StageStyle#EXTENDED} style. This class enables the <em>click-and-drag to move<\/em> and\n+ * <em>double-click to maximize<\/em> behaviors that are usually afforded by system-provided header bars.\n+ * The entire {@code HeaderBar} background is draggable by default, but its content is not. Applications\n+ * can specify draggable content nodes of the {@code HeaderBar} with the {@link #setDragType(Node, HeaderDragType)}\n+ * method.\n+ * <p>\n+ * {@code HeaderBar} is a layout container that allows applications to place scene graph nodes in three areas:\n+ * {@link #leadingProperty() leading}, {@link #centerProperty() center}, and {@link #trailingProperty() trailing}.\n+ * All areas can be {@code null}. The default {@link #minHeightProperty() minHeight} of the {@code HeaderBar} is\n+ * set to match the height of the platform-specific default header buttons.\n+ *\n+ * <h2>Single header bar<\/h2>\n+ * Most applications should only add a single {@code HeaderBar} to the scene graph, placed at the top of the\n+ * scene and extending its entire width. This ensures that the reported values for\n+ * {@link #leftSystemInsetProperty() leftSystemInset} and {@link #rightSystemInsetProperty() rightSystemInset},\n+ * which describe the area reserved for the system-provided window buttons, correctly align with the location\n+ * of the {@code HeaderBar} and are taken into account when the contents of the {@code HeaderBar} are laid out.\n+ *\n+ * <h2>Multiple header bars<\/h2>\n+ * Applications that use multiple header bars might need to configure the additional padding inserted into the\n+ * layout to account for the system-reserved areas. For example, when two header bars are placed next to each\n+ * other in the horizontal direction, the default configuration incorrectly adds additional padding between the\n+ * two header bars. In this case, the {@link #leadingSystemPaddingProperty() leadingSystemPadding} and\n+ * {@link #trailingSystemPaddingProperty() trailingSystemPadding} properties can be used to remove the padding\n+ * that is not needed.\n+ *\n+ * <h2>Header button height<\/h2>\n+ * Applications can specify the preferred height for system-provided header buttons by setting the static\n+ * {@link #setPrefButtonHeight(Stage, double)} property on the {@code Stage} associated with the header bar.\n+ * This can be used to achieve a more cohesive visual appearance by having the system-provided header buttons\n+ * match the height of the client-area header bar.\n+ *\n+ * <h2>Custom header buttons<\/h2>\n+ * If more control over the header buttons is desired, applications can opt out of the system-provided header\n+ * buttons by setting {@link #setPrefButtonHeight(Stage, double)} to zero and place custom header buttons in\n+ * the JavaFX scene graph instead. Any JavaFX control can be used as a custom header button by setting its\n+ * semantic type with the {@link #setButtonType(Node, HeaderButtonType)} method.\n+ *\n+ * <h2>System menu<\/h2>\n+ * Some platforms support a system menu that can be summoned by right-clicking the draggable area.\n+ * The system menu will not be shown when:\n+ * <ol>\n+ *     <li>the {@code Stage} is in {@link Stage#fullScreenProperty() full-screen mode}, or\n+ *     <li>the {@code HeaderBar} has {@link Event#consume() consumed} the\n+ *         {@link ContextMenuEvent#CONTEXT_MENU_REQUESTED} event.\n+ * <\/ol>\n+ *\n+ * <h2>Layout constraints<\/h2>\n+ * The {@code leading} and {@code trailing} children will be resized to their preferred widths and extend the\n+ * height of the {@code HeaderBar}. The {@code center} child will be resized to fill the available space.\n+ * {@code HeaderBar} honors the minimum, preferred, and maximum sizes of its children. If a child's resizable\n+ * range prevents it from be resized to fit within its position, it will be vertically centered relative to the\n+ * available space; this alignment can be customized with a layout constraint.\n+ * <p>\n+ * An application may set constraints on individual children to customize their layout.\n+ * For each constraint, {@code HeaderBar} provides static getter and setter methods.\n+ * <table style=\"white-space: nowrap\">\n+ *     <caption>Layout constraints of {@code HeaderBar}<\/caption>\n+ *     <thead>\n+ *         <tr><th>Constraint<\/th><th>Type<\/th><th>Description<\/th><\/tr>\n+ *     <\/thead>\n+ *     <tbody>\n+ *         <tr><th>alignment<\/th><td>{@link Pos}<\/td>\n+ *             <td>The alignment of the child within its area of the {@code HeaderBar}.<\/td>\n+ *         <\/tr>\n+ *         <tr><th>margin<\/th>\n+ *             <td>{@link Insets}<\/td><td>Margin space around the outside of the child.<\/td>\n+ *         <\/tr>\n+ *     <\/tbody>\n+ * <\/table>\n+ *\n+ * <h2>Special layout of centered child<\/h2>\n+ * If a child is configured to be centered in the {@link #centerProperty() center} area (i.e. its {@code alignment}\n+ * constraint is either {@code null}, {@link Pos#CENTER}, {@link Pos#TOP_CENTER}, or {@link Pos#BOTTOM_CENTER}),\n+ * it will be centered with respect to the entire header bar, and not with respect to the {@code center} area only.\n+ * This means that, for a header bar that extends the entire width of the {@code Stage}, the child will appear to\n+ * be horizontally centered within the {@code Stage}.\n+ * <p>\n+ * If a child should instead be centered with respect to the {@code center} area only, a possible solution is to\n+ * place another layout container like {@link BorderPane} in the {@code center} area, and then center the child\n+ * within the other layout container.\n+ *\n+ * <h2>Example<\/h2>\n+ * Usually, {@code HeaderBar} is placed in a root container like {@code BorderPane} to align it\n+ * with the top of the scene:\n+ * <pre>{@code\n+ * public class MyApp extends Application {\n+ *     @Override\n+ *     public void start(Stage stage) {\n+ *         var button = new Button(\"My button\");\n+ *         HeaderBar.setAlignment(button, Pos.CENTER_LEFT);\n+ *         HeaderBar.setMargin(button, new Insets(5));\n+ *\n+ *         var headerBar = new HeaderBar();\n+ *         headerBar.setCenter(button);\n+ *\n+ *         var root = new BorderPane();\n+ *         root.setTop(headerBar);\n+ *\n+ *         stage.setScene(new Scene(root));\n+ *         stage.initStyle(StageStyle.EXTENDED);\n+ *         stage.show();\n+ *     }\n+ * }\n+ * }<\/pre>\n+ *\n+ * @since 25\n+ * @deprecated This is a preview feature which may be changed or removed in a future release.\n+ *\/\n+@Deprecated(since = \"25\")\n+public class HeaderBar extends Region {\n+\n+    private static final Dimension2D EMPTY = new Dimension2D(0, 0);\n+    private static final String DRAG_TYPE = \"headerbar-drag-type\";\n+    private static final String BUTTON_TYPE = \"headerbar-button-type\";\n+    private static final String ALIGNMENT = \"headerbar-alignment\";\n+    private static final String MARGIN = \"headerbar-margin\";\n+\n+    \/**\n+     * Specifies the {@code HeaderDragType} of the child, indicating whether it is a draggable\n+     * part of the {@code HeaderBar}.\n+     * <p>\n+     * Setting the value to {@code null} will remove the flag.\n+     *\n+     * @param child the child node\n+     * @param value the {@code HeaderDragType}, or {@code null} to remove the flag\n+     *\/\n+    public static void setDragType(Node child, HeaderDragType value) {\n+        Pane.setConstraint(child, DRAG_TYPE, value);\n+    }\n+\n+    \/**\n+     * Returns the {@code HeaderDragType} of the specified child.\n+     *\n+     * @param child the child node\n+     * @return the {@code HeaderDragType}, or {@code null} if not set\n+     *\/\n+    public static HeaderDragType getDragType(Node child) {\n+        return (HeaderDragType)Pane.getConstraint(child, DRAG_TYPE);\n+    }\n+\n+    \/**\n+     * Specifies the {@code HeaderButtonType} of the child, indicating its semantic use in the header bar.\n+     * <p>\n+     * This property can be set on any {@link Node}. Specifying a header button type also provides the behavior\n+     * associated with the button type. If the default behavior is not desired, applications can register an\n+     * event filter on the child node that consumes the {@link MouseEvent#MOUSE_RELEASED} event.\n+     *\n+     * @param child the child node\n+     * @param value the {@code HeaderButtonType}, or {@code null}\n+     *\/\n+    public static void setButtonType(Node child, HeaderButtonType value) {\n+        Pane.setConstraint(child, BUTTON_TYPE, value);\n+\n+        if (child.getProperties().get(HeaderButtonBehavior.class) instanceof HeaderButtonBehavior behavior) {\n+            behavior.dispose();\n+        }\n+\n+        if (value != null) {\n+            child.getProperties().put(HeaderButtonBehavior.class, new HeaderButtonBehavior(child, value));\n+        } else {\n+            child.getProperties().remove(HeaderButtonBehavior.class);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the {@code HeaderButtonType} of the specified child.\n+     *\n+     * @param child the child node\n+     * @return the {@code HeaderButtonType}, or {@code null}\n+     *\/\n+    public static HeaderButtonType getButtonType(Node child) {\n+        return (HeaderButtonType)Pane.getConstraint(child, BUTTON_TYPE);\n+    }\n+\n+    \/**\n+     * Sentinel value that can be used for {@link #setPrefButtonHeight(Stage, double)} to indicate that\n+     * the platform should choose the platform-specific default button height.\n+     *\/\n+    public static final double USE_DEFAULT_SIZE = -1;\n+\n+    \/**\n+     * Specifies the preferred height of the system-provided header buttons of the specified stage.\n+     * <p>\n+     * Any value except zero and {@link #USE_DEFAULT_SIZE} is only a hint for the platform window toolkit.\n+     * The platform might accommodate the preferred height in various ways, such as by stretching the header\n+     * buttons (fully or partially) to fill the preferred height, or centering the header buttons (fully or\n+     * partially) within the preferred height. Some platforms might only accommodate the preferred height\n+     * within platform-specific constraints, or ignore it entirely.\n+     * <p>\n+     * Setting the preferred height to zero hides the system-provided header buttons, allowing applications to\n+     * use custom header buttons instead (see {@link #setButtonType(Node, HeaderButtonType)}).\n+     * <p>\n+     * The default value {@code #USE_DEFAULT_SIZE} indicates that the platform should choose the button height.\n+     *\n+     * @param stage the {@code Stage}\n+     * @param height the preferred height, or 0 to hide the system-provided header buttons\n+     *\/\n+    public static void setPrefButtonHeight(Stage stage, double height) {\n+        StageHelper.setPrefHeaderButtonHeight(stage, height);\n+    }\n+\n+    \/**\n+     * Returns the preferred height of the system-provided header buttons of the specified stage.\n+     *\n+     * @param stage the {@code Stage}\n+     * @return the preferred height of the system-provided header buttons\n+     *\/\n+    public static double getPrefButtonHeight(Stage stage) {\n+        return StageHelper.getPrefHeaderButtonHeight(stage);\n+    }\n+\n+    \/**\n+     * Sets the alignment for the child when contained in a {@code HeaderBar}.\n+     * If set, will override the header bar's default alignment for the child's position.\n+     * Setting the value to {@code null} will remove the constraint.\n+     *\n+     * @param child the child node\n+     * @param value the alignment position\n+     *\/\n+    public static void setAlignment(Node child, Pos value) {\n+        Pane.setConstraint(child, ALIGNMENT, value);\n+    }\n+\n+    \/**\n+     * Returns the child's alignment in the {@code HeaderBar}.\n+     *\n+     * @param child the child node\n+     * @return the alignment position for the child, or {@code null} if no alignment was set\n+     *\/\n+    public static Pos getAlignment(Node child) {\n+        return (Pos)Pane.getConstraint(child, ALIGNMENT);\n+    }\n+\n+    \/**\n+     * Sets the margin for the child when contained in a {@code HeaderBar}.\n+     * If set, the header bar will lay it out with the margin space around it.\n+     * Setting the value to {@code null} will remove the constraint.\n+     *\n+     * @param child the child node\n+     * @param value the margin of space around the child\n+     *\/\n+    public static void setMargin(Node child, Insets value) {\n+        Pane.setConstraint(child, MARGIN, value);\n+    }\n+\n+    \/**\n+     * Returns the child's margin.\n+     *\n+     * @param child the child node\n+     * @return the margin for the child, or {@code null} if no margin was set\n+     *\/\n+    public static Insets getMargin(Node child) {\n+        return (Insets)Pane.getConstraint(child, MARGIN);\n+    }\n+\n+    private Subscription subscription = Subscription.EMPTY;\n+    private HeaderButtonMetrics currentMetrics;\n+    private boolean currentFullScreen;\n+\n+    \/**\n+     * Creates a new {@code HeaderBar}.\n+     *\/\n+    public HeaderBar() {\n+        PreviewFeature.HEADER_BAR.checkEnabled();\n+\n+        \/\/ Inflate the minHeight property. This is important so that we can track whether a stylesheet or\n+        \/\/ user code changes the property value before we set it to the height of the native title bar.\n+        minHeightProperty();\n+\n+        ObservableValue<Stage> stage = sceneProperty()\n+            .flatMap(Scene::windowProperty)\n+            .map(w -> w instanceof Stage s ? s : null);\n+\n+        stage.flatMap(Stage::fullScreenProperty)\n+            .orElse(false)\n+            .subscribe(this::onFullScreenChanged);\n+\n+        stage.subscribe(this::onStageChanged);\n+    }\n+\n+    \/**\n+     * Creates a new {@code HeaderBar} with the specified children.\n+     *\n+     * @param leading the leading node\n+     * @param center the center node\n+     * @param trailing the trailing node\n+     *\/\n+    public HeaderBar(Node leading, Node center, Node trailing) {\n+        this();\n+        setLeading(leading);\n+        setCenter(center);\n+        setTrailing(trailing);\n+    }\n+\n+    private void onStageChanged(Stage stage) {\n+        subscription.unsubscribe();\n+\n+        if (stage != null) {\n+            subscription = StageHelper.getHeaderButtonMetrics(stage).subscribe(this::onMetricsChanged);\n+        }\n+    }\n+\n+    private void onMetricsChanged(HeaderButtonMetrics metrics) {\n+        currentMetrics = metrics;\n+        updateInsets();\n+    }\n+\n+    private void onFullScreenChanged(boolean fullScreen) {\n+        currentFullScreen = fullScreen;\n+        updateInsets();\n+    }\n+\n+    private void updateInsets() {\n+        if (currentFullScreen || currentMetrics == null) {\n+            leftSystemInset.set(EMPTY);\n+            rightSystemInset.set(EMPTY);\n+            minSystemHeight.set(0);\n+        } else {\n+            leftSystemInset.set(currentMetrics.leftInset());\n+            rightSystemInset.set(currentMetrics.rightInset());\n+            minSystemHeight.set(currentMetrics.minHeight());\n+        }\n+    }\n+\n+    \/**\n+     * Describes the size of the left system-reserved inset, which is an area reserved for the iconify, maximize,\n+     * and close window buttons. If there are no window buttons on the left side of the window, the returned area\n+     * is an empty {@code Dimension2D}.\n+     * <p>\n+     * Note that the left system inset refers to the left side of the window, independent of layout orientation.\n+     *\/\n+    private final ReadOnlyObjectWrapper<Dimension2D> leftSystemInset =\n+        new ReadOnlyObjectWrapper<>(this, \"leftSystemInset\", EMPTY) {\n+            @Override\n+            protected void invalidated() {\n+                requestLayout();\n+            }\n+        };\n+\n+    public final ReadOnlyObjectProperty<Dimension2D> leftSystemInsetProperty() {\n+        return leftSystemInset.getReadOnlyProperty();\n+    }\n+\n+    public final Dimension2D getLeftSystemInset() {\n+        return leftSystemInset.get();\n+    }\n+\n+    \/**\n+     * Describes the size of the right system-reserved inset, which is an area reserved for the iconify, maximize,\n+     * and close window buttons. If there are no window buttons on the right side of the window, the returned area\n+     * is an empty {@code Dimension2D}.\n+     * <p>\n+     * Note that the right system inset refers to the right side of the window, independent of layout orientation.\n+     *\/\n+    private final ReadOnlyObjectWrapper<Dimension2D> rightSystemInset =\n+        new ReadOnlyObjectWrapper<>(this, \"rightSystemInset\", EMPTY) {\n+            @Override\n+            protected void invalidated() {\n+                requestLayout();\n+            }\n+        };\n+\n+    public final ReadOnlyObjectProperty<Dimension2D> rightSystemInsetProperty() {\n+        return rightSystemInset.getReadOnlyProperty();\n+    }\n+\n+    public final Dimension2D getRightSystemInset() {\n+        return rightSystemInset.get();\n+    }\n+\n+    \/**\n+     * The system-provided minimum recommended height for the {@code HeaderBar}, which usually corresponds\n+     * to the height of the default header buttons. Applications can use this value as a sensible lower limit\n+     * for the height of the {@code HeaderBar}.\n+     * <p>\n+     * By default, {@link #minHeightProperty() minHeight} is set to the value of {@code minSystemHeight},\n+     * unless {@code minHeight} is explicitly set by a stylesheet or application code.\n+     *\/\n+    private final ReadOnlyDoubleWrapper minSystemHeight =\n+        new ReadOnlyDoubleWrapper(this, \"minSystemHeight\") {\n+            @Override\n+            protected void invalidated() {\n+                double height = get();\n+                var minHeight = (StyleableDoubleProperty)minHeightProperty();\n+\n+                \/\/ Only change minHeight if it was not set by a stylesheet or application code.\n+                if (minHeight.getStyleOrigin() == null) {\n+                    minHeight.applyStyle(null, height);\n+                }\n+            }\n+        };\n+\n+    public final ReadOnlyDoubleProperty minSystemHeightProperty() {\n+        return minSystemHeight.getReadOnlyProperty();\n+    }\n+\n+    public final double getMinSystemHeight() {\n+        return minSystemHeight.get();\n+    }\n+\n+    \/**\n+     * The leading area of the {@code HeaderBar}.\n+     * <p>\n+     * The leading area corresponds to the left area in a left-to-right layout, and to the right area\n+     * in a right-to-left layout.\n+     *\n+     * @defaultValue {@code null}\n+     *\/\n+    private final ObjectProperty<Node> leading = new NodeProperty(\"leading\");\n+\n+    public final ObjectProperty<Node> leadingProperty() {\n+        return leading;\n+    }\n+\n+    public final Node getLeading() {\n+        return leading.get();\n+    }\n+\n+    public final void setLeading(Node value) {\n+        leading.set(value);\n+    }\n+\n+    \/**\n+     * The center area of the {@code HeaderBar}.\n+     *\n+     * @defaultValue {@code null}\n+     *\/\n+    private final ObjectProperty<Node> center = new NodeProperty(\"center\");\n+\n+    public final ObjectProperty<Node> centerProperty() {\n+        return center;\n+    }\n+\n+    public final Node getCenter() {\n+        return center.get();\n+    }\n+\n+    public final void setCenter(Node value) {\n+        center.set(value);\n+    }\n+\n+    \/**\n+     * The trailing area of the {@code HeaderBar}.\n+     * <p>\n+     * The trailing area corresponds to the right area in a left-to-right layout, and to the left area\n+     * in a right-to-left layout.\n+     *\n+     * @defaultValue {@code null}\n+     *\/\n+    private final ObjectProperty<Node> trailing = new NodeProperty(\"trailing\");\n+\n+    public final ObjectProperty<Node> trailingProperty() {\n+        return trailing;\n+    }\n+\n+    public final Node getTrailing() {\n+        return trailing.get();\n+    }\n+\n+    public final void setTrailing(Node value) {\n+        trailing.set(value);\n+    }\n+\n+    \/**\n+     * Specifies whether additional padding should be added to the leading side of the {@code HeaderBar}.\n+     * The size of the additional padding corresponds to the size of the system-reserved area that contains\n+     * the default header buttons (iconify, maximize, and close). If the system-reserved area contains no\n+     * header buttons, no additional padding is added to the leading side of the {@code HeaderBar}.\n+     * <p>\n+     * Applications that use a single {@code HeaderBar} extending the entire width of the window should\n+     * set this property to {@code true} to prevent the header buttons from overlapping the content of the\n+     * {@code HeaderBar}.\n+     *\n+     * @defaultValue {@code true}\n+     * @see #trailingSystemPaddingProperty() trailingSystemPadding\n+     *\/\n+    private final BooleanProperty leadingSystemPadding = new BooleanPropertyBase(true) {\n+        @Override\n+        public Object getBean() {\n+            return HeaderBar.this;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return \"leadingSystemPadding\";\n+        }\n+\n+        @Override\n+        protected void invalidated() {\n+            requestLayout();\n+        }\n+    };\n+\n+    public final BooleanProperty leadingSystemPaddingProperty() {\n+        return leadingSystemPadding;\n+    }\n+\n+    public final boolean isLeadingSystemPadding() {\n+        return leadingSystemPadding.get();\n+    }\n+\n+    public final void setLeadingSystemPadding(boolean value) {\n+        leadingSystemPadding.set(value);\n+    }\n+\n+    \/**\n+     * Specifies whether additional padding should be added to the trailing side of the {@code HeaderBar}.\n+     * The size of the additional padding corresponds to the size of the system-reserved area that contains\n+     * the default header buttons (iconify, maximize, and close). If the system-reserved area contains no\n+     * header buttons, no additional padding is added to the trailing side of the {@code HeaderBar}.\n+     * <p>\n+     * Applications that use a single {@code HeaderBar} extending the entire width of the window should\n+     * set this property to {@code true} to prevent the header buttons from overlapping the content of the\n+     * {@code HeaderBar}.\n+     *\n+     * @defaultValue {@code true}\n+     * @see #leadingSystemPaddingProperty() leadingSystemPadding\n+     *\/\n+    private final BooleanProperty trailingSystemPadding = new BooleanPropertyBase(true) {\n+        @Override\n+        public Object getBean() {\n+            return HeaderBar.this;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return \"trailingSystemPadding\";\n+        }\n+\n+        @Override\n+        protected void invalidated() {\n+            requestLayout();\n+        }\n+    };\n+\n+    public final BooleanProperty trailingSystemPaddingProperty() {\n+        return trailingSystemPadding;\n+    }\n+\n+    public final boolean isTrailingSystemPadding() {\n+        return trailingSystemPadding.get();\n+    }\n+\n+    public final void setTrailingSystemPadding(boolean value) {\n+        trailingSystemPadding.set(value);\n+    }\n+\n+    private boolean isLeftSystemPadding(NodeOrientation nodeOrientation) {\n+        return nodeOrientation == NodeOrientation.LEFT_TO_RIGHT && isLeadingSystemPadding()\n+            || nodeOrientation == NodeOrientation.RIGHT_TO_LEFT && isTrailingSystemPadding();\n+    }\n+\n+    private boolean isRightSystemPadding(NodeOrientation nodeOrientation) {\n+        return nodeOrientation == NodeOrientation.LEFT_TO_RIGHT && isTrailingSystemPadding()\n+            || nodeOrientation == NodeOrientation.RIGHT_TO_LEFT && isLeadingSystemPadding();\n+    }\n+\n+    @Override\n+    protected double computeMinWidth(double height) {\n+        Node leading = getLeading();\n+        Node center = getCenter();\n+        Node trailing = getTrailing();\n+        Insets insets = getInsets();\n+        double leftPrefWidth;\n+        double rightPrefWidth;\n+        double centerMinWidth;\n+        double systemPaddingWidth = 0;\n+\n+        if (height != -1\n+                && (childHasContentBias(leading, Orientation.VERTICAL) ||\n+                    childHasContentBias(trailing, Orientation.VERTICAL) ||\n+                    childHasContentBias(center, Orientation.VERTICAL))) {\n+            double areaHeight = Math.max(0, height);\n+            leftPrefWidth = getAreaWidth(leading, areaHeight, false);\n+            rightPrefWidth = getAreaWidth(trailing, areaHeight, false);\n+            centerMinWidth = getAreaWidth(center, areaHeight, true);\n+        } else {\n+            leftPrefWidth = getAreaWidth(leading, -1, false);\n+            rightPrefWidth = getAreaWidth(trailing, -1, false);\n+            centerMinWidth = getAreaWidth(center, -1, true);\n+        }\n+\n+        NodeOrientation nodeOrientation = getEffectiveNodeOrientation();\n+\n+        if (isLeftSystemPadding(nodeOrientation)) {\n+            systemPaddingWidth += getLeftSystemInset().getWidth();\n+        }\n+\n+        if (isRightSystemPadding(nodeOrientation)) {\n+            systemPaddingWidth += getRightSystemInset().getWidth();\n+        }\n+\n+        return insets.getLeft()\n+             + leftPrefWidth\n+             + centerMinWidth\n+             + rightPrefWidth\n+             + insets.getRight()\n+             + systemPaddingWidth;\n+    }\n+\n+    @Override\n+    protected double computeMinHeight(double width) {\n+        Node leading = getLeading();\n+        Node center = getCenter();\n+        Node trailing = getTrailing();\n+        Insets insets = getInsets();\n+        double leadingMinHeight = getAreaHeight(leading, -1, true);\n+        double trailingMinHeight = getAreaHeight(trailing, -1, true);\n+        double centerMinHeight;\n+\n+        if (width != -1 && childHasContentBias(center, Orientation.HORIZONTAL)) {\n+            double leadingPrefWidth = getAreaWidth(leading, -1, false);\n+            double trailingPrefWidth = getAreaWidth(trailing, -1, false);\n+            centerMinHeight = getAreaHeight(center, Math.max(0, width - leadingPrefWidth - trailingPrefWidth), true);\n+        } else {\n+            centerMinHeight = getAreaHeight(center, -1, true);\n+        }\n+\n+        return insets.getTop()\n+             + insets.getBottom()\n+             + Math.max(centerMinHeight, Math.max(trailingMinHeight, leadingMinHeight));\n+    }\n+\n+    @Override\n+    protected double computePrefHeight(double width) {\n+        Node leading = getLeading();\n+        Node center = getCenter();\n+        Node trailing = getTrailing();\n+        Insets insets = getInsets();\n+        double leadingPrefHeight = getAreaHeight(leading, -1, false);\n+        double trailingPrefHeight = getAreaHeight(trailing, -1, false);\n+        double centerPrefHeight;\n+\n+        if (width != -1 && childHasContentBias(center, Orientation.HORIZONTAL)) {\n+            double leadingPrefWidth = getAreaWidth(leading, -1, false);\n+            double trailingPrefWidth = getAreaWidth(trailing, -1, false);\n+            centerPrefHeight = getAreaHeight(center, Math.max(0, width - leadingPrefWidth - trailingPrefWidth), false);\n+        } else {\n+            centerPrefHeight = getAreaHeight(center, -1, false);\n+        }\n+\n+        return insets.getTop()\n+             + insets.getBottom()\n+             + Math.max(centerPrefHeight, Math.max(trailingPrefHeight, leadingPrefHeight));\n+    }\n+\n+    @Override\n+    public boolean usesMirroring() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected void layoutChildren() {\n+        Node center = getCenter();\n+        Node left, right;\n+        Insets insets = getInsets();\n+        NodeOrientation nodeOrientation = getEffectiveNodeOrientation();\n+        boolean rtl = nodeOrientation == NodeOrientation.RIGHT_TO_LEFT;\n+        double width = Math.max(getWidth(), minWidth(-1));\n+        double height = Math.max(getHeight(), minHeight(-1));\n+        double leftWidth = 0;\n+        double rightWidth = 0;\n+        double insideY = insets.getTop();\n+        double insideHeight = height - insideY - insets.getBottom();\n+        double insideX, insideWidth;\n+        double leftSystemPaddingWidth = isLeftSystemPadding(nodeOrientation) ? getLeftSystemInset().getWidth() : 0;\n+        double rightSystemPaddingWidth = isRightSystemPadding(nodeOrientation) ? getRightSystemInset().getWidth() : 0;\n+\n+        if (rtl) {\n+            left = getTrailing();\n+            right = getLeading();\n+            insideX = insets.getRight() + leftSystemPaddingWidth;\n+            insideWidth = width - insideX - insets.getLeft() - rightSystemPaddingWidth;\n+        } else {\n+            left = getLeading();\n+            right = getTrailing();\n+            insideX = insets.getLeft() + leftSystemPaddingWidth;\n+            insideWidth = width - insideX - insets.getRight() - rightSystemPaddingWidth;\n+        }\n+\n+        if (left != null && left.isManaged()) {\n+            Insets leftMargin = adjustMarginForRTL(getNodeMargin(left), rtl);\n+            double adjustedWidth = adjustWidthByMargin(insideWidth, leftMargin);\n+            double childWidth = resizeChild(left, adjustedWidth, false, insideHeight, leftMargin);\n+            leftWidth = snapSpaceX(leftMargin.getLeft()) + childWidth + snapSpaceX(leftMargin.getRight());\n+            Pos alignment = getAlignment(left);\n+\n+            positionInArea(\n+                left, insideX, insideY,\n+                leftWidth, insideHeight, 0,\n+                leftMargin,\n+                alignment != null ? alignment.getHpos() : HPos.CENTER,\n+                alignment != null ? alignment.getVpos() : VPos.CENTER,\n+                isSnapToPixel());\n+        }\n+\n+        if (right != null && right.isManaged()) {\n+            Insets rightMargin = adjustMarginForRTL(getNodeMargin(right), rtl);\n+            double adjustedWidth = adjustWidthByMargin(insideWidth - leftWidth, rightMargin);\n+            double childWidth = resizeChild(right, adjustedWidth, false, insideHeight, rightMargin);\n+            rightWidth = snapSpaceX(rightMargin.getLeft()) + childWidth + snapSpaceX(rightMargin.getRight());\n+            Pos alignment = getAlignment(right);\n+\n+            positionInArea(\n+                right, insideX + insideWidth - rightWidth, insideY,\n+                rightWidth, insideHeight, 0,\n+                rightMargin,\n+                alignment != null ? alignment.getHpos() : HPos.CENTER,\n+                alignment != null ? alignment.getVpos() : VPos.CENTER,\n+                isSnapToPixel());\n+        }\n+\n+        if (center != null && center.isManaged()) {\n+            Insets centerMargin = adjustMarginForRTL(getNodeMargin(center), rtl);\n+            Pos alignment = getAlignment(center);\n+\n+            if (alignment == null || alignment.getHpos() == HPos.CENTER) {\n+                double adjustedWidth = adjustWidthByMargin(insideWidth - leftWidth - rightWidth, centerMargin);\n+                double childWidth = resizeChild(center, adjustedWidth, true, insideHeight, centerMargin);\n+                double idealX = width \/ 2 - childWidth \/ 2;\n+                double minX = insideX + leftWidth + centerMargin.getLeft();\n+                double maxX = insideX + insideWidth - rightWidth - centerMargin.getRight();\n+                double adjustedX;\n+\n+                if (idealX < minX) {\n+                    adjustedX = minX;\n+                } else if (idealX + childWidth > maxX) {\n+                    adjustedX = maxX - childWidth;\n+                } else {\n+                    adjustedX = idealX;\n+                }\n+\n+                positionInArea(\n+                    center,\n+                    adjustedX, insideY,\n+                    childWidth, insideHeight, 0,\n+                    new Insets(centerMargin.getTop(), 0, centerMargin.getBottom(), 0),\n+                    HPos.LEFT, alignment != null ? alignment.getVpos() : VPos.CENTER,\n+                    isSnapToPixel());\n+            } else {\n+                layoutInArea(\n+                    center,\n+                    insideX + leftWidth, insideY,\n+                    insideWidth - leftWidth - rightWidth, insideHeight, 0,\n+                    centerMargin,\n+                    alignment.getHpos(), alignment.getVpos());\n+            }\n+        }\n+    }\n+\n+    private Insets adjustMarginForRTL(Insets margin, boolean rtl) {\n+        if (margin == null) {\n+            return null;\n+        }\n+\n+        return rtl\n+            ? new Insets(margin.getTop(), margin.getLeft(), margin.getBottom(), margin.getRight())\n+            : margin;\n+    }\n+\n+    private boolean childHasContentBias(Node child, Orientation orientation) {\n+        if (child != null && child.isManaged()) {\n+            return child.getContentBias() == orientation;\n+        }\n+\n+        return false;\n+    }\n+\n+    private double resizeChild(Node child, double adjustedWidth, boolean fillWidth, double insideHeight, Insets margin) {\n+        double adjustedHeight = adjustHeightByMargin(insideHeight, margin);\n+        double childWidth = fillWidth ? adjustedWidth : Math.min(snapSizeX(child.prefWidth(adjustedHeight)), adjustedWidth);\n+        Vec2d size = boundedNodeSizeWithBias(child, childWidth, adjustedHeight, true, true, TEMP_VEC2D);\n+        size.x = snapSizeX(size.x);\n+        size.y = snapSizeX(size.y);\n+        child.resize(size.x, size.y);\n+        return size.x;\n+    }\n+\n+    private double getAreaWidth(Node child, double height, boolean minimum) {\n+        if (child != null && child.isManaged()) {\n+            Insets margin = getNodeMargin(child);\n+            return minimum\n+                ? computeChildMinAreaWidth(child, -1, margin, height, false)\n+                : computeChildPrefAreaWidth(child, -1, margin, height, false);\n+        }\n+\n+        return 0;\n+    }\n+\n+    private double getAreaHeight(Node child, double width, boolean minimum) {\n+        if (child != null && child.isManaged()) {\n+            Insets margin = getNodeMargin(child);\n+            return minimum\n+                ? computeChildMinAreaHeight(child, -1, margin, width, false)\n+                : computeChildPrefAreaHeight(child, -1, margin, width, false);\n+        }\n+\n+        return 0;\n+    }\n+\n+    private Insets getNodeMargin(Node child) {\n+        Insets margin = getMargin(child);\n+        return margin != null ? margin : Insets.EMPTY;\n+    }\n+\n+    private final class NodeProperty extends ObjectPropertyBase<Node> {\n+        private final String name;\n+        private Node value;\n+\n+        NodeProperty(String name) {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public Object getBean() {\n+            return HeaderBar.this;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        protected void invalidated() {\n+            if (value != null) {\n+                getChildren().remove(value);\n+            }\n+\n+            value = get();\n+\n+            if (value != null) {\n+                getChildren().add(value);\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HeaderBar.java","additions":898,"deletions":0,"binary":false,"changes":898,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.layout;\n+\n+import javafx.scene.Node;\n+import javafx.stage.Stage;\n+\n+\/**\n+ * Identifies the semantic type of a button in a custom {@link HeaderBar}, which enables integrations\n+ * with the platform window manager. For example, hovering over a {@link #MAXIMIZE} button on Windows\n+ * will summon snap layouts.\n+ *\n+ * @since 25\n+ * @deprecated This is a preview feature which may be changed or removed in a future release.\n+ * @see HeaderBar#setButtonType(Node, HeaderButtonType)\n+ *\/\n+@Deprecated(since = \"25\")\n+public enum HeaderButtonType {\n+\n+    \/**\n+     * Identifies the iconify button.\n+     *\n+     * @see Stage#isIconified()\n+     * @see Stage#setIconified(boolean)\n+     *\/\n+    ICONIFY,\n+\n+    \/**\n+     * Identifies the maximize button.\n+     * <p>\n+     * This button toggles the {@link Stage#isMaximized()} or {@link Stage#isFullScreen()} property,\n+     * depending on platform-specific invocation semantics. For example, on macOS the button will\n+     * put the window into full-screen mode by default, but maximize it to cover the desktop when\n+     * the option key is pressed.\n+     * <p>\n+     * If the window is maximized, the button will have the {@code maximized} pseudo-class.\n+     *\n+     * @see Stage#isMaximized()\n+     * @see Stage#setMaximized(boolean)\n+     * @see Stage#isFullScreen()\n+     * @see Stage#setFullScreen(boolean)\n+     *\/\n+    MAXIMIZE,\n+\n+    \/**\n+     * Identifies the close button.\n+     *\n+     * @see Stage#close()\n+     *\/\n+    CLOSE\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HeaderButtonType.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.layout;\n+\n+import javafx.scene.Node;\n+\n+\/**\n+ * Specifies whether a node is a draggable part of a {@link HeaderBar}.\n+ *\n+ * @since 25\n+ * @deprecated This is a preview feature which may be changed or removed in a future release.\n+ * @see HeaderBar#setDragType(Node, HeaderDragType)\n+ *\/\n+@Deprecated(since = \"25\")\n+public enum HeaderDragType {\n+\n+    \/**\n+     * The node is not a draggable part of the {@code HeaderBar}.\n+     * <p>\n+     * If the node inherits {@link #DRAGGABLE_SUBTREE} from its parent, the inheritance stops and\n+     * descendants of the node will not inherit {@code DRAGGABLE_SUBTREE}.\n+     *\/\n+    NONE,\n+\n+    \/**\n+     * The node is a draggable part of the {@code HeaderBar}.\n+     * <p>\n+     * This drag type does not apply to descendants of the node. However, it does not stop an inherited\n+     * {@link #DRAGGABLE_SUBTREE} drag type from being inherited by descendants of the node.\n+     *\/\n+    DRAGGABLE,\n+\n+    \/**\n+     * The node and its descendants are a draggable part of the {@code HeaderBar}.\n+     * <p>\n+     * This drag type is inherited by descendants of the node until a descendant specifies {@link #NONE}.\n+     *\/\n+    DRAGGABLE_SUBTREE\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HeaderDragType.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import javafx.scene.layout.HeaderBar;\n@@ -43,0 +44,2 @@\n+import com.sun.glass.ui.HeaderButtonMetrics;\n+import com.sun.javafx.PreviewFeature;\n@@ -201,0 +204,15 @@\n+\n+            @Override\n+            public void setPrefHeaderButtonHeight(Stage stage, double height) {\n+                stage.setPrefHeaderButtonHeight(height);\n+            }\n+\n+            @Override\n+            public double getPrefHeaderButtonHeight(Stage stage) {\n+                return stage.getPrefHeaderButtonHeight();\n+            }\n+\n+            @Override\n+            public ObservableValue<HeaderButtonMetrics> getHeaderButtonMetrics(Stage stage) {\n+                return stage.headerButtonMetricsProperty();\n+            }\n@@ -230,0 +248,5 @@\n+\n+        @Override\n+        public void setHeaderButtonMetrics(Stage stage, HeaderButtonMetrics metrics) {\n+            stage.headerButtonMetricsProperty().set(metrics);\n+        }\n@@ -437,3 +460,1 @@\n-     * Specifies the style for this stage. This must be done prior to making\n-     * the stage visible. The style is one of: StageStyle.DECORATED,\n-     * StageStyle.UNDECORATED, StageStyle.TRANSPARENT, or StageStyle.UTILITY.\n+     * Specifies the style for this stage. This must be done prior to making the stage visible.\n@@ -448,0 +469,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -449,0 +471,3 @@\n+        if (style == StageStyle.EXTENDED) {\n+            PreviewFeature.STAGE_STYLE_EXTENDED.checkEnabled();\n+        }\n@@ -1097,0 +1122,1 @@\n+            getPeer().setPrefHeaderButtonHeight(getPrefHeaderButtonHeight());\n@@ -1262,0 +1288,25 @@\n+\n+    private ObjectProperty<HeaderButtonMetrics> headerButtonMetrics;\n+\n+    private ObjectProperty<HeaderButtonMetrics> headerButtonMetricsProperty() {\n+        if (headerButtonMetrics == null) {\n+            headerButtonMetrics = new SimpleObjectProperty<>(this, \"headerButtonMetrics\");\n+        }\n+\n+        return headerButtonMetrics;\n+    }\n+\n+    private double prefHeaderButtonHeight = HeaderBar.USE_DEFAULT_SIZE;\n+\n+    private double getPrefHeaderButtonHeight() {\n+        return prefHeaderButtonHeight;\n+    }\n+\n+    private void setPrefHeaderButtonHeight(double height) {\n+        prefHeaderButtonHeight = height;\n+\n+        TKStage peer = getPeer();\n+        if (peer != null) {\n+            peer.setPrefHeaderButtonHeight(height);\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/Stage.java","additions":55,"deletions":4,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,8 @@\n+import javafx.application.ConditionalFeature;\n+import javafx.application.Platform;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.HeaderBar;\n+import javafx.scene.layout.HeaderButtonType;\n+\n@@ -77,1 +85,55 @@\n-    UNIFIED\n+    UNIFIED,\n+\n+    \/**\n+     * Defines a {@code Stage} style in which the client area is extended into the header bar area, removing\n+     * the separation between the two areas and allowing applications to place scene graph nodes in the header\n+     * bar area of the stage.\n+     * <p>\n+     * This is a conditional feature, to check if it is supported see {@link Platform#isSupported(ConditionalFeature)}.\n+     * If the feature is not supported by the platform, this style downgrades to {@link StageStyle#DECORATED}.\n+     *\n+     * <h4>Usage<\/h4>\n+     * An extended window has the default header buttons (iconify, maximize, close), but no system-provided\n+     * draggable header bar. Applications need to provide their own header bar by placing a {@link HeaderBar}\n+     * control in the scene graph. The {@code HeaderBar} control should be positioned at the top of the window\n+     * and its width should extend the entire width of the window, as otherwise the layout of the default window\n+     * buttons and the header bar content might not be aligned correctly. Usually, {@code HeaderBar} is combined\n+     * with a {@link BorderPane} root container:\n+     * <pre>{@code\n+     * public class MyApp extends Application {\n+     *     @Override\n+     *     public void start(Stage stage) {\n+     *         var headerBar = new HeaderBar();\n+     *         var root = new BorderPane();\n+     *         root.setTop(headerBar);\n+     *\n+     *         stage.setScene(new Scene(root));\n+     *         stage.initStyle(StageStyle.EXTENDED);\n+     *         stage.show();\n+     *     }\n+     * }\n+     * }<\/pre>\n+     *\n+     * <h4>Color scheme<\/h4>\n+     * The color scheme of the default header buttons is automatically adjusted to remain easily recognizable\n+     * by inspecting the {@link Scene#fillProperty() Scene.fill} property to gauge the brightness of the user\n+     * interface. Applications should set the scene fill to a color that matches the user interface of the header\n+     * bar area, even if the scene fill is not visible because it is obscured by other controls.\n+     *\n+     * <h4>Custom header buttons<\/h4>\n+     * If more control over the header buttons is desired, applications can opt out of the default header buttons\n+     * by setting {@link HeaderBar#setPrefButtonHeight(Stage, double)} to zero and providing custom header buttons\n+     * instead. Any JavaFX control can be used as a custom header button by setting its semantic type with the\n+     * {@link HeaderBar#setButtonType(Node, HeaderButtonType)} method.\n+     *\n+     * <h4>Title text<\/h4>\n+     * An extended stage has no title text. Applications that require title text need to provide their own\n+     * implementation by placing a {@code Label} or a similar control in the custom header bar.\n+     * Note that the value of {@link Stage#titleProperty()} may still be used by the platform, for example\n+     * in the title of miniaturized preview windows.\n+     *\n+     * @since 25\n+     * @deprecated This is a preview feature which may be changed or removed in a future release.\n+     *\/\n+    @Deprecated(since = \"25\")\n+    EXTENDED\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/StageStyle.java","additions":64,"deletions":2,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -513,0 +513,1 @@\n+                case GDK_2BUTTON_PRESS:\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassApplication.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,3 @@\n+    if (mask & com_sun_glass_ui_gtk_GtkWindow_EXTENDED) {\n+        return EXTENDED;\n+    }\n@@ -378,0 +381,17 @@\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setSystemMinimumSize\n+ * Signature: (JII)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setSystemMinimumSize\n+  (JNIEnv * env, jobject obj, jlong ptr, jint w, jint h)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    if (w < 0 || h < 0) return JNI_FALSE;\n+    ctx->set_system_minimum_size(w, h);\n+    return JNI_TRUE;\n+}\n+\n@@ -527,0 +547,15 @@\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _showSystemMenu\n+ * Signature: (JII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1showSystemMenu\n+    (JNIEnv * env, jobject obj, jlong ptr, jint x, jint y)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->show_system_menu(x, y);\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassWindow.cpp","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+jmethodID jGtkWindowDragAreaHitTest;\n@@ -272,2 +273,3 @@\n-    jGtkWindowNotifyStateChanged =\n-            env->GetMethodID(clazz, \"notifyStateChanged\", \"(I)V\");\n+    jGtkWindowNotifyStateChanged = env->GetMethodID(clazz, \"notifyStateChanged\", \"(I)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jGtkWindowDragAreaHitTest = env->GetMethodID(clazz, \"dragAreaHitTest\", \"(II)Z\");\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -197,1 +197,2 @@\n-    extern jmethodID jGtkWindowNotifyStateChanged; \/\/ com.sun.glass.ui.GtkWindow#notifyStateChanged (I)V\n+    extern jmethodID jGtkWindowNotifyStateChanged; \/\/ com.sun.glass.ui.gtk.GtkWindow#notifyStateChanged (I)V\n+    extern jmethodID jGtkWindowDragAreaHitTest; \/\/com.sun.glass.ui.gtk.GtkWindow#dragAreaHitTest (II)Z\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,3 @@\n+\/\/ Resize border width of EXTENDED windows\n+#define RESIZE_BORDER_WIDTH 5\n+\n@@ -262,1 +265,6 @@\n-void WindowContextBase::process_mouse_button(GdkEventButton* event) {\n+void WindowContextBase::process_mouse_button(GdkEventButton* event, bool synthesized) {\n+    \/\/ We only handle single press\/release events here.\n+    if (event->type != GDK_BUTTON_PRESS && event->type != GDK_BUTTON_RELEASE) {\n+        return;\n+    }\n+\n@@ -327,1 +335,1 @@\n-                JNI_FALSE);\n+                synthesized);\n@@ -560,0 +568,4 @@\n+bool WindowContextBase::is_resizable() {\n+    return false;\n+}\n+\n@@ -631,1 +643,20 @@\n-    gdk_window_set_cursor(gdk_window, cursor);\n+\n+    gdk_cursor = cursor;\n+\n+    if (gdk_cursor_override == NULL) {\n+        gdk_window_set_cursor(gdk_window, cursor);\n+    }\n+}\n+\n+void WindowContextBase::set_cursor_override(GdkCursor* cursor) {\n+    if (gdk_cursor_override == cursor) {\n+        return;\n+    }\n+\n+    gdk_cursor_override = cursor;\n+\n+    if (cursor != NULL) {\n+        gdk_window_set_cursor(gdk_window, cursor);\n+    } else {\n+        gdk_window_set_cursor(gdk_window, gdk_cursor);\n+    }\n@@ -639,0 +670,4 @@\n+bool WindowContextBase::get_window_edge(int x, int y, GdkWindowEdge* window_edge) {\n+    return false;\n+}\n+\n@@ -725,1 +760,1 @@\n-    if (type == UTILITY) {\n+    if (type == UTILITY && frame_type != EXTENDED) {\n@@ -1014,5 +1049,6 @@\n-    if (resizable.value && !is_disabled) {\n-        int min_w = (resizable.minw == -1) ? 1\n-                      : resizable.minw - geometry.extents.left - geometry.extents.right;\n-        int min_h =  (resizable.minh == -1) ? 1\n-                      : resizable.minh - geometry.extents.top - geometry.extents.bottom;\n+    if (is_resizable() && !is_disabled) {\n+        int w = std::max(resizable.sysminw, resizable.minw);\n+        int h = std::max(resizable.sysminh, resizable.minh);\n+\n+        int min_w = (w == -1) ? 1 : w - geometry.extents.left - geometry.extents.right;\n+        int min_h =  (h == -1) ? 1 : h - geometry.extents.top - geometry.extents.bottom;\n@@ -1047,0 +1083,4 @@\n+bool WindowContextTop::is_resizable() {\n+    return resizable.value;\n+}\n+\n@@ -1199,0 +1239,6 @@\n+void WindowContextTop::set_system_minimum_size(int w, int h) {\n+    resizable.sysminw = w;\n+    resizable.sysminh = h;\n+    update_window_constraints();\n+}\n+\n@@ -1349,0 +1395,177 @@\n+void WindowContextTop::show_system_menu(int x, int y) {\n+    GdkDisplay* display = gdk_display_get_default();\n+    if (!display) {\n+        return;\n+    }\n+\n+    GdkSeat* seat = gdk_display_get_default_seat(display);\n+    GdkDevice* device = gdk_seat_get_pointer(seat);\n+    if (!device) {\n+        return;\n+    }\n+\n+    gint rx = 0, ry = 0;\n+    gdk_window_get_root_coords(gdk_window, x, y, &rx, &ry);\n+\n+    GdkEvent* event = (GdkEvent*)gdk_event_new(GDK_BUTTON_PRESS);\n+    GdkEventButton* buttonEvent = (GdkEventButton*)event;\n+    buttonEvent->x_root = rx;\n+    buttonEvent->y_root = ry;\n+    buttonEvent->window = g_object_ref(gdk_window);\n+    buttonEvent->device = g_object_ref(device);\n+\n+    gdk_window_show_window_menu(gdk_window, event);\n+    gdk_event_free(event);\n+}\n+\n+\/*\n+ * Handles mouse button events of EXTENDED windows and adds the window behaviors for non-client\n+ * regions that are usually provided by the window manager. Note that a full-screen window has\n+ * no non-client regions.\n+ *\/\n+void WindowContextTop::process_mouse_button(GdkEventButton* event, bool synthesized) {\n+    \/\/ Non-EXTENDED or full-screen windows don't have additional behaviors, so we delegate\n+    \/\/ directly to the base implementation.\n+    if (is_fullscreen || frame_type != EXTENDED || jwindow == NULL) {\n+        WindowContextBase::process_mouse_button(event);\n+        return;\n+    }\n+\n+    \/\/ Double-clicking on the drag area maximizes the window (or restores its size).\n+    if (is_resizable() && event->type == GDK_2BUTTON_PRESS) {\n+        jboolean dragArea = mainEnv->CallBooleanMethod(\n+            jwindow, jGtkWindowDragAreaHitTest, (jint)event->x, (jint)event->y);\n+        CHECK_JNI_EXCEPTION(mainEnv);\n+\n+        if (dragArea) {\n+            set_maximized(!is_maximized);\n+        }\n+\n+        \/\/ We don't process the GDK_2BUTTON_PRESS event in the base implementation.\n+        return;\n+    }\n+\n+    if (event->button == 1 && event->type == GDK_BUTTON_PRESS) {\n+        GdkWindowEdge edge;\n+        bool shouldStartResizeDrag = is_resizable() && !is_maximized && get_window_edge(event->x, event->y, &edge);\n+\n+        \/\/ Clicking on a window edge starts a move-resize operation.\n+        if (shouldStartResizeDrag) {\n+            \/\/ Send a synthetic PRESS + RELEASE to FX. This allows FX to do things that need to be done\n+            \/\/ prior to resizing the window, like closing a popup menu. We do this because we won't be\n+            \/\/ sending events to FX once the resize operation has started.\n+            WindowContextBase::process_mouse_button(event, true);\n+            event->type = GDK_BUTTON_RELEASE;\n+            WindowContextBase::process_mouse_button(event, true);\n+\n+            gint rx = 0, ry = 0;\n+            gdk_window_get_root_coords(get_gdk_window(), event->x, event->y, &rx, &ry);\n+            gtk_window_begin_resize_drag(get_gtk_window(), edge, 1, rx, ry, event->time);\n+            return;\n+        }\n+\n+        bool shouldStartMoveDrag = mainEnv->CallBooleanMethod(\n+            jwindow, jGtkWindowDragAreaHitTest, (jint)event->x, (jint)event->y);\n+        CHECK_JNI_EXCEPTION(mainEnv);\n+\n+        \/\/ Clicking on a draggable area starts a move-drag operation.\n+        if (shouldStartMoveDrag) {\n+            \/\/ Send a synthetic PRESS + RELEASE to FX.\n+            WindowContextBase::process_mouse_button(event, true);\n+            event->type = GDK_BUTTON_RELEASE;\n+            WindowContextBase::process_mouse_button(event, true);\n+\n+            gint rx = 0, ry = 0;\n+            gdk_window_get_root_coords(get_gdk_window(), event->x, event->y, &rx, &ry);\n+            gtk_window_begin_move_drag(get_gtk_window(), 1, rx, ry, event->time);\n+            return;\n+        }\n+    }\n+\n+    \/\/ Call the base implementation for client area events.\n+    WindowContextBase::process_mouse_button(event);\n+}\n+\n+\/*\n+ * Handles mouse motion events of EXTENDED windows and changes the cursor when it is on top\n+ * of the internal resize border. Note that a full-screen window or maximized window has no\n+ * resize border.\n+ *\/\n+void WindowContextTop::process_mouse_motion(GdkEventMotion* event) {\n+    GdkWindowEdge edge;\n+\n+    \/\/ Call the base implementation for client area events.\n+    if (is_fullscreen\n+            || is_maximized\n+            || frame_type != EXTENDED\n+            || !is_resizable()\n+            || !get_window_edge(event->x, event->y, &edge)) {\n+        set_cursor_override(NULL);\n+        WindowContextBase::process_mouse_motion(event);\n+        return;\n+    }\n+\n+    static const struct Cursors {\n+        GdkCursor* NORTH = gdk_cursor_new(GDK_TOP_SIDE);\n+        GdkCursor* NORTH_EAST = gdk_cursor_new(GDK_TOP_RIGHT_CORNER);\n+        GdkCursor* EAST = gdk_cursor_new(GDK_RIGHT_SIDE);\n+        GdkCursor* SOUTH_EAST = gdk_cursor_new(GDK_BOTTOM_RIGHT_CORNER);\n+        GdkCursor* SOUTH = gdk_cursor_new(GDK_BOTTOM_SIDE);\n+        GdkCursor* SOUTH_WEST = gdk_cursor_new(GDK_BOTTOM_LEFT_CORNER);\n+        GdkCursor* WEST = gdk_cursor_new(GDK_LEFT_SIDE);\n+        GdkCursor* NORTH_WEST = gdk_cursor_new(GDK_TOP_LEFT_CORNER);\n+    } cursors;\n+\n+    GdkCursor* cursor = NULL;\n+\n+    switch (edge) {\n+        case GDK_WINDOW_EDGE_NORTH: cursor = cursors.NORTH; break;\n+        case GDK_WINDOW_EDGE_NORTH_EAST: cursor = cursors.NORTH_EAST; break;\n+        case GDK_WINDOW_EDGE_EAST: cursor = cursors.EAST; break;\n+        case GDK_WINDOW_EDGE_SOUTH_EAST: cursor = cursors.SOUTH_EAST; break;\n+        case GDK_WINDOW_EDGE_SOUTH: cursor = cursors.SOUTH; break;\n+        case GDK_WINDOW_EDGE_SOUTH_WEST: cursor = cursors.SOUTH_WEST; break;\n+        case GDK_WINDOW_EDGE_WEST: cursor = cursors.WEST; break;\n+        case GDK_WINDOW_EDGE_NORTH_WEST: cursor = cursors.NORTH_WEST; break;\n+    }\n+\n+    set_cursor_override(cursor);\n+\n+    \/\/ If the cursor is not on a resize border, call the base handler.\n+    if (cursor == NULL) {\n+        WindowContextBase::process_mouse_motion(event);\n+    }\n+}\n+\n+\/*\n+ * Determines the GdkWindowEdge at the specified coordinate; returns true if the coordinate\n+ * identifies a window edge, false otherwise.\n+ *\/\n+bool WindowContextTop::get_window_edge(int x, int y, GdkWindowEdge* window_edge) {\n+    GdkWindowEdge edge;\n+    gint width, height;\n+    gtk_window_get_size(get_gtk_window(), &width, &height);\n+\n+    if (x <= RESIZE_BORDER_WIDTH) {\n+        if (y <= 2 * RESIZE_BORDER_WIDTH) edge = GDK_WINDOW_EDGE_NORTH_WEST;\n+        else if (y >= height - 2 * RESIZE_BORDER_WIDTH) edge = GDK_WINDOW_EDGE_SOUTH_WEST;\n+        else edge = GDK_WINDOW_EDGE_WEST;\n+    } else if (x >= width - RESIZE_BORDER_WIDTH) {\n+        if (y <= 2 * RESIZE_BORDER_WIDTH) edge = GDK_WINDOW_EDGE_NORTH_EAST;\n+        else if (y >= height - 2 * RESIZE_BORDER_WIDTH) edge = GDK_WINDOW_EDGE_SOUTH_EAST;\n+        else edge = GDK_WINDOW_EDGE_EAST;\n+    } else if (y <= RESIZE_BORDER_WIDTH) {\n+        edge = GDK_WINDOW_EDGE_NORTH;\n+    } else if (y >= height - RESIZE_BORDER_WIDTH) {\n+        edge = GDK_WINDOW_EDGE_SOUTH;\n+    } else {\n+        return false;\n+    }\n+\n+    if (window_edge != NULL) {\n+        *window_edge = edge;\n+    }\n+\n+    return true;\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.cpp","additions":232,"deletions":9,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -47,1 +47,2 @@\n-    TRANSPARENT\n+    TRANSPARENT,\n+    EXTENDED\n@@ -114,0 +115,1 @@\n+    virtual void show_system_menu(int x, int y) = 0;\n@@ -120,0 +122,1 @@\n+    virtual bool is_resizable() = 0;\n@@ -129,0 +132,1 @@\n+    virtual void set_system_minimum_size(int, int) = 0;\n@@ -148,1 +152,1 @@\n-    virtual void process_mouse_button(GdkEventButton*) = 0;\n+    virtual void process_mouse_button(GdkEventButton*, bool synthesized = false) = 0;\n@@ -172,0 +176,1 @@\n+    virtual bool get_window_edge(int x, int y, GdkWindowEdge*) = 0;\n@@ -194,0 +199,2 @@\n+    GdkCursor* gdk_cursor = NULL;\n+    GdkCursor* gdk_cursor_override = NULL;\n@@ -237,0 +244,1 @@\n+    bool is_resizable();\n@@ -243,0 +251,1 @@\n+    void set_cursor_override(GdkCursor*);\n@@ -250,1 +259,1 @@\n-    void process_mouse_button(GdkEventButton*);\n+    void process_mouse_button(GdkEventButton*, bool synthesized = false);\n@@ -262,0 +271,1 @@\n+    bool get_window_edge(int x, int y, GdkWindowEdge*);\n@@ -277,1 +287,1 @@\n-                minw(-1), minh(-1), maxw(-1), maxh(-1) {}\n+                minw(-1), minh(-1), maxw(-1), maxh(-1), sysminw(-1), sysminh(-1) {}\n@@ -280,0 +290,1 @@\n+        int sysminw, sysminh; \/\/ size of window button area of EXTENDED windows\n@@ -297,0 +308,2 @@\n+    void process_mouse_motion(GdkEventMotion*);\n+    void process_mouse_button(GdkEventButton*, bool synthesized = false);\n@@ -305,0 +318,1 @@\n+    bool is_resizable();\n@@ -310,0 +324,1 @@\n+    void set_system_minimum_size(int, int);\n@@ -322,0 +337,1 @@\n+    void show_system_menu(int x, int y);\n@@ -344,0 +360,1 @@\n+    bool get_window_edge(int x, int y, GdkWindowEdge*);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,2 @@\n+- (void)performWindowDrag;\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassViewDelegate.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1143,0 +1143,5 @@\n+- (void)performWindowDrag\n+{\n+    [[nsView window] performWindowDragWithEvent:[NSApp currentEvent]];\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassViewDelegate.m","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,0 +197,9 @@\n+\n+    \/\/ When we switch to full-screen mode, we always need the standard window buttons to be shown.\n+    [[self->nsWindow standardWindowButton:NSWindowCloseButton] setHidden:NO];\n+    [[self->nsWindow standardWindowButton:NSWindowMiniaturizeButton] setHidden:NO];\n+    [[self->nsWindow standardWindowButton:NSWindowZoomButton] setHidden:NO];\n+\n+    if (nsWindow.toolbar != nil) {\n+        nsWindow.toolbar.visible = NO;\n+    }\n@@ -209,0 +218,7 @@\n+\n+    \/\/ When we exit full-screen mode, hide the standard window buttons if they were previously hidden.\n+    if (!self->isStandardButtonsVisible) {\n+        [[self->nsWindow standardWindowButton:NSWindowCloseButton] setHidden:YES];\n+        [[self->nsWindow standardWindowButton:NSWindowMiniaturizeButton] setHidden:YES];\n+        [[self->nsWindow standardWindowButton:NSWindowZoomButton] setHidden:YES];\n+    }\n@@ -215,0 +231,4 @@\n+    if (nsWindow.toolbar != nil) {\n+        nsWindow.toolbar.visible = YES;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow+Overrides.m","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+    BOOL                isStandardButtonsVisible;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -377,0 +377,10 @@\n+        bool isTitled = (jStyleMask & com_sun_glass_ui_Window_TITLED) != 0;\n+        bool isClosable = (jStyleMask & com_sun_glass_ui_Window_CLOSABLE) != 0;\n+        bool isMinimizable = (jStyleMask & com_sun_glass_ui_Window_MINIMIZABLE) != 0;\n+        bool isMaximizable = (jStyleMask & com_sun_glass_ui_Window_MAXIMIZABLE) != 0;\n+        bool isTransparent = (jStyleMask & com_sun_glass_ui_Window_TRANSPARENT) != 0;\n+        bool isUtility = (jStyleMask & com_sun_glass_ui_Window_UTILITY) != 0;\n+        bool isPopup = (jStyleMask & com_sun_glass_ui_Window_POPUP) != 0;\n+        bool isUnified = (jStyleMask & com_sun_glass_ui_Window_UNIFIED) != 0;\n+        bool isExtended = (jStyleMask & com_sun_glass_ui_Window_EXTENDED) != 0;\n+\n@@ -379,1 +389,1 @@\n-        if ((jStyleMask&com_sun_glass_ui_Window_TITLED) != 0)\n+        if (isTitled)\n@@ -384,3 +394,0 @@\n-        bool isUtility = (jStyleMask & com_sun_glass_ui_Window_UTILITY) != 0;\n-        bool isPopup = (jStyleMask & com_sun_glass_ui_Window_POPUP) != 0;\n-\n@@ -388,1 +395,1 @@\n-        if ((jStyleMask&com_sun_glass_ui_Window_TRANSPARENT) == 0)\n+        if (!isTransparent)\n@@ -390,1 +397,1 @@\n-            if ((jStyleMask&com_sun_glass_ui_Window_CLOSABLE) != 0)\n+            if (isClosable)\n@@ -395,2 +402,1 @@\n-            if (((jStyleMask&com_sun_glass_ui_Window_MINIMIZABLE) != 0) ||\n-                ((jStyleMask&com_sun_glass_ui_Window_MAXIMIZABLE) != 0))\n+            if (isMinimizable || isMaximizable)\n@@ -403,1 +409,5 @@\n-            if ((jStyleMask&com_sun_glass_ui_Window_UNIFIED) != 0) {\n+            if (isExtended) {\n+                styleMask = styleMask | NSWindowStyleMaskTitled | NSWindowStyleMaskFullSizeContentView;\n+            }\n+\n+            if (isUnified) {\n@@ -409,1 +419,9 @@\n-                styleMask = styleMask | NSWindowStyleMaskUtilityWindow | NSWindowStyleMaskNonactivatingPanel;\n+                styleMask = styleMask | NSWindowStyleMaskNonactivatingPanel;\n+\n+                \/\/ The NSWindowStyleMaskUtilityWindow style makes the close button appear very small (because the\n+                \/\/ title bar is thinner than normal). This doesn't work well with client-side title bars in extended\n+                \/\/ windows: the point of a client-side title bar is its ability to host custom controls, so it can't\n+                \/\/ be very thin. We therefore only add this style for non-extended windows.\n+                if (!isExtended) {\n+                    styleMask |= NSWindowStyleMaskUtilityWindow;\n+                }\n@@ -427,0 +445,7 @@\n+        window->isStandardButtonsVisible = YES;\n+\n+        if (isExtended) {\n+            [window->nsWindow setTitleVisibility:NSWindowTitleHidden];\n+            [window->nsWindow setTitlebarAppearsTransparent:YES];\n+            [window->nsWindow setToolbar:[NSToolbar new]];\n+        }\n@@ -428,1 +453,1 @@\n-        if ((jStyleMask & com_sun_glass_ui_Window_UNIFIED) != 0) {\n+        if (isUnified) {\n@@ -433,3 +458,8 @@\n-        if ((jStyleMask & com_sun_glass_ui_Window_UTILITY) != 0) {\n-            [[window->nsWindow standardWindowButton:NSWindowMiniaturizeButton] setHidden:YES];\n-            [[window->nsWindow standardWindowButton:NSWindowZoomButton] setHidden:YES];\n+        if (isUtility) {\n+            \/\/ When we hide the standard window buttons, they are still part of the button group that activates\n+            \/\/ the hover appearance (the icons inside the buttons) when the cursor is over any of the buttons.\n+            \/\/ This leads to the close button receiving the hover appearance when the mouse cursor is over one\n+            \/\/ of the hidden buttons. Setting the hidden buttons' frame to an empty rectangle fixes this.\n+            [[window->nsWindow standardWindowButton:NSWindowMiniaturizeButton] setFrame:CGRectMake(0, 0, 0, 0)];\n+            [[window->nsWindow standardWindowButton:NSWindowZoomButton] setFrame:CGRectMake(0, 0, 0, 0)];\n+\n@@ -446,1 +476,1 @@\n-        window->isDecorated = (jStyleMask&com_sun_glass_ui_Window_TITLED) != 0;\n+        window->isDecorated = isTitled || isExtended;\n@@ -464,2 +494,1 @@\n-        window->isTransparent = (jStyleMask & com_sun_glass_ui_Window_TRANSPARENT) != 0;\n-        if (window->isTransparent == YES)\n+        if (isTransparent)\n@@ -477,0 +506,1 @@\n+        window->isTransparent = isTransparent;\n@@ -1440,0 +1470,103 @@\n+\n+\/*\n+ * Class:     com_sun_glass_ui_mac_MacWindow\n+ * Method:    _performWindowDrag\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1performWindowDrag\n+(JNIEnv *env, jobject jWindow, jlong jPtr)\n+{\n+    LOG(\"Java_com_sun_glass_ui_mac_MacWindow__1performWindowDrag\");\n+    if (!jPtr) return;\n+\n+    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n+    GLASS_POOL_ENTER;\n+    {\n+        GlassWindow *window = getGlassWindow(env, jPtr);\n+        [[window->view delegate] performWindowDrag];\n+    }\n+    GLASS_POOL_EXIT;\n+    GLASS_CHECK_EXCEPTION(env);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_mac_MacWindow\n+ * Method:    _performTitleBarDoubleClickAction\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1performTitleBarDoubleClickAction\n+(JNIEnv *env, jobject jWindow, jlong jPtr)\n+{\n+    LOG(\"Java_com_sun_glass_ui_mac_MacWindow__1performTitleBarDoubleClickAction\");\n+    if (!jPtr) return;\n+\n+    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n+    GLASS_POOL_ENTER;\n+    {\n+        GlassWindow *window = getGlassWindow(env, jPtr);\n+        NSString* action = [NSUserDefaults.standardUserDefaults stringForKey:@\"AppleActionOnDoubleClick\"];\n+\n+        if ([action isEqualToString:@\"Minimize\"]) {\n+            [window->nsWindow performMiniaturize:nil];\n+        } else if ([action isEqualToString:@\"Maximize\"]) {\n+            [window->nsWindow performZoom:nil];\n+        }\n+    }\n+    GLASS_POOL_EXIT;\n+    GLASS_CHECK_EXCEPTION(env);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_mac_MacWindow\n+ * Method:    _setWindowButtonStyle\n+ * Signature: (JIZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setWindowButtonStyle\n+(JNIEnv *env, jobject jWindow, jlong jPtr, jint toolbarStyle, jboolean buttonsVisible)\n+{\n+    LOG(\"Java_com_sun_glass_ui_mac_MacWindow__1setWindowButtonStyle\");\n+    if (!jPtr) return;\n+\n+    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n+    GLASS_POOL_ENTER;\n+    {\n+        GlassWindow *window = getGlassWindow(env, jPtr);\n+        if (window) {\n+            window->isStandardButtonsVisible = buttonsVisible;\n+\n+            if (window->nsWindow) {\n+                [window->nsWindow setToolbarStyle:toolbarStyle];\n+                [[window->nsWindow standardWindowButton:NSWindowCloseButton] setHidden:!buttonsVisible];\n+                [[window->nsWindow standardWindowButton:NSWindowMiniaturizeButton] setHidden:!buttonsVisible];\n+                [[window->nsWindow standardWindowButton:NSWindowZoomButton] setHidden:!buttonsVisible];\n+            }\n+        }\n+    }\n+    GLASS_POOL_EXIT;\n+    GLASS_CHECK_EXCEPTION(env);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_mac_MacWindow\n+ * Method:    _isRightToLeftLayoutDirection\n+ * Signature: ()Z;\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1isRightToLeftLayoutDirection\n+(JNIEnv *env, jobject self)\n+{\n+    LOG(\"Java_com_sun_glass_ui_mac_MacWindow__1isRightToLeftLayoutDirection\");\n+    jboolean result = false;\n+\n+    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n+    GLASS_POOL_ENTER;\n+    {\n+        NSString* preferredLanguage = [[NSLocale preferredLanguages] objectAtIndex:0];\n+        NSLocale* locale = [NSLocale localeWithLocaleIdentifier:preferredLanguage];\n+        NSString* languageCode = [locale objectForKey:NSLocaleLanguageCode];\n+        result = [NSLocale characterDirectionForLanguage:languageCode] == NSLocaleLanguageDirectionRightToLeft;\n+    }\n+    GLASS_POOL_EXIT;\n+    GLASS_CHECK_EXCEPTION(env);\n+\n+    return result;\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow.m","additions":151,"deletions":18,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -332,1 +332,1 @@\n-            BOOL handled = HandleViewMouseEvent(GetHWND(), msg, wParam, lParam);\n+            BOOL handled = HandleViewMouseEvent(GetHWND(), msg, wParam, lParam, FALSE);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/FullScreenWindow.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+#define ABM_GETAUTOHIDEBAREX 0x0000000b \/\/ multimon aware autohide bars\n@@ -65,1 +66,2 @@\n-GlassWindow::GlassWindow(jobject jrefThis, bool isTransparent, bool isDecorated, bool isUnified, HWND parentOrOwner)\n+GlassWindow::GlassWindow(jobject jrefThis, bool isTransparent, bool isDecorated, bool isUnified,\n+                         bool isExtended, HWND parentOrOwner)\n@@ -77,0 +79,1 @@\n+    m_isExtended(isExtended),\n@@ -455,0 +458,10 @@\n+\n+            if (BOOL(wParam) && m_isExtended) {\n+                return HandleNCCalcSizeEvent(msg, wParam, lParam);\n+            }\n+            break;\n+        case WM_NCHITTEST: {\n+            LRESULT res;\n+            if (m_isExtended && HandleNCHitTestEvent(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), res)) {\n+                return res;\n+            }\n@@ -456,0 +469,1 @@\n+        }\n@@ -480,17 +494,1 @@\n-            if (IsEnabled()) {\n-                if (msg == WM_MOUSELEAVE && GetDelegateWindow()) {\n-                    \/\/ Skip generating MouseEvent.EXIT when entering FullScreen\n-                    return 0;\n-                }\n-                BOOL handled = HandleViewMouseEvent(GetHWND(), msg, wParam, lParam);\n-                if (handled && msg == WM_RBUTTONUP) {\n-                    \/\/ By default, DefWindowProc() sends WM_CONTEXTMENU from WM_LBUTTONUP\n-                    \/\/ Since DefWindowProc() is not called, call the mouse menu handler directly\n-                    HandleViewMenuEvent(GetHWND(), WM_CONTEXTMENU, (WPARAM) GetHWND(), ::GetMessagePos ());\n-                    \/\/::DefWindowProc(GetHWND(), msg, wParam, lParam);\n-                }\n-                if (handled) {\n-                    \/\/ Do not call the DefWindowProc() for mouse events that were handled\n-                    return 0;\n-                }\n-            } else {\n+            if (!IsEnabled()) {\n@@ -499,0 +497,2 @@\n+            } else if (HandleMouseEvents(msg, wParam, lParam)) {\n+                return 0;\n@@ -549,0 +549,11 @@\n+\n+            if (m_isExtended) {\n+                HandleNonClientMouseEvents(msg, wParam, lParam);\n+\n+                \/\/ We need to return 0 for clicks on the min\/max\/close regions, as otherwise Windows will\n+                \/\/ draw very ugly buttons on top of our window.\n+                if (wParam == HTMINBUTTON || wParam == HTMAXBUTTON || wParam == HTCLOSE) {\n+                    return 0;\n+                }\n+            }\n+\n@@ -551,0 +562,18 @@\n+        case WM_NCLBUTTONUP:\n+        case WM_NCLBUTTONDBLCLK:\n+        case WM_NCRBUTTONUP:\n+        case WM_NCRBUTTONDBLCLK:\n+        case WM_NCMBUTTONUP:\n+        case WM_NCMBUTTONDBLCLK:\n+        case WM_NCXBUTTONUP:\n+        case WM_NCXBUTTONDBLCLK:\n+        case WM_NCMOUSELEAVE:\n+        case WM_NCMOUSEMOVE:\n+            if (m_isExtended) {\n+                HandleNonClientMouseEvents(msg, wParam, lParam);\n+\n+                if (wParam == HTMINBUTTON || wParam == HTMAXBUTTON || wParam == HTCLOSE) {\n+                    return 0;\n+                }\n+            }\n+            break;\n@@ -576,0 +605,37 @@\n+bool GlassWindow::HandleMouseEvents(UINT msg, WPARAM wParam, LPARAM lParam)\n+{\n+    if (msg == WM_MOUSELEAVE && GetDelegateWindow()) {\n+        \/\/ Skip generating MouseEvent.EXIT when entering FullScreen\n+        return true;\n+    }\n+\n+    BOOL handled = HandleViewMouseEvent(GetHWND(), msg, wParam, lParam, m_isExtended);\n+    if (handled && msg == WM_RBUTTONUP) {\n+        \/\/ By default, DefWindowProc() sends WM_CONTEXTMENU from WM_LBUTTONUP\n+        \/\/ Since DefWindowProc() is not called, call the mouse menu handler directly\n+        HandleViewMenuEvent(GetHWND(), WM_CONTEXTMENU, (WPARAM) GetHWND(), ::GetMessagePos());\n+        \/\/::DefWindowProc(GetHWND(), msg, wParam, lParam);\n+    }\n+\n+    if (handled) {\n+        \/\/ Do not call the DefWindowProc() for mouse events that were handled\n+        return true;\n+    }\n+\n+    return false;\n+}\n+\n+void GlassWindow::HandleNonClientMouseEvents(UINT msg, WPARAM wParam, LPARAM lParam)\n+{\n+    HandleViewNonClientMouseEvent(GetHWND(), msg, wParam, lParam);\n+    LRESULT result;\n+\n+    \/\/ If the right mouse button was released on a HTCAPTION area, we synthesize a WM_CONTEXTMENU event.\n+    \/\/ This allows JavaFX applications to respond to context menu events in the non-client header bar area.\n+    if (msg == WM_NCRBUTTONUP\n+            && HandleNCHitTestEvent(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), result)\n+            && result == HTCAPTION) {\n+        HandleViewMenuEvent(GetHWND(), WM_CONTEXTMENU, (WPARAM)GetHWND(), ::GetMessagePos());\n+    }\n+}\n+\n@@ -766,0 +832,105 @@\n+LRESULT GlassWindow::HandleNCCalcSizeEvent(UINT msg, WPARAM wParam, LPARAM lParam)\n+{\n+    \/\/ Capture the top and size before DefWindowProc applies the default frame.\n+    NCCALCSIZE_PARAMS *p = (NCCALCSIZE_PARAMS*)lParam;\n+    LONG originalTop = p->rgrc[0].top;\n+    RECT originalSize = p->rgrc[0];\n+\n+    \/\/ Apply the default window frame.\n+    LRESULT res = DefWindowProc(GetHWND(), msg, wParam, lParam);\n+    if (res != 0) {\n+        return res;\n+    }\n+\n+    \/\/ Restore the original top, which might have been overwritten by DefWindowProc.\n+    RECT newSize = p->rgrc[0];\n+    newSize.top = originalTop;\n+\n+    \/\/ A maximized window extends slightly beyond the screen, so we need to account for that\n+    \/\/ by adding the border width to the top.\n+    bool maximized = (::GetWindowLong(GetHWND(), GWL_STYLE) & WS_MAXIMIZE) != 0;\n+    if (maximized && !m_isInFullScreen) {\n+        \/\/ Note: there is no SM_CYPADDEDBORDER\n+        newSize.top += ::GetSystemMetrics(SM_CXPADDEDBORDER) + ::GetSystemMetrics(SM_CYSIZEFRAME);\n+    }\n+\n+    \/\/ If we have an auto-hide taskbar, we need to reduce the size of a maximized or fullscreen\n+    \/\/ window a little bit where the taskbar is located, as otherwise the taskbar cannot be\n+    \/\/ summoned.\n+    HMONITOR monitor = ::MonitorFromWindow(GetHWND(), MONITOR_DEFAULTTONEAREST);\n+    if (monitor && (maximized || m_isInFullScreen)) {\n+        MONITORINFO monitorInfo = { 0 };\n+        monitorInfo.cbSize = sizeof(MONITORINFO);\n+        ::GetMonitorInfo(monitor, &monitorInfo);\n+\n+        APPBARDATA data = { 0 };\n+        data.cbSize = sizeof(data);\n+\n+        if ((::SHAppBarMessage(ABM_GETSTATE, &data) & ABS_AUTOHIDE) == ABS_AUTOHIDE) {\n+            data.rc = monitorInfo.rcMonitor;\n+            DWORD appBarMsg = ::IsWindows8OrGreater() ? ABM_GETAUTOHIDEBAREX : ABM_GETAUTOHIDEBAR;\n+\n+            \/\/ Reduce the window size by one pixel on the taskbar side.\n+            if ((data.uEdge = ABE_TOP), ::SHAppBarMessage(appBarMsg, &data) != NULL) {\n+                newSize.top += 1;\n+            } else if ((data.uEdge = ABE_BOTTOM), ::SHAppBarMessage(appBarMsg, &data) != NULL) {\n+                newSize.bottom -= 1;\n+            } else if ((data.uEdge = ABE_LEFT), ::SHAppBarMessage(appBarMsg, &data) != NULL) {\n+                newSize.left += 1;\n+            } else if ((data.uEdge = ABE_RIGHT), ::SHAppBarMessage(appBarMsg, &data) != NULL) {\n+                newSize.right -= 1;\n+            }\n+        }\n+    }\n+\n+    p->rgrc[0] = newSize;\n+    return 0;\n+}\n+\n+\/\/ Handling this message tells Windows which parts of the window are non-client regions.\n+\/\/ This enables window behaviors like dragging or snap layouts.\n+BOOL GlassWindow::HandleNCHitTestEvent(SHORT x, SHORT y, LRESULT& result)\n+{\n+    if (::DefWindowProc(GetHWND(), WM_NCHITTEST, 0, MAKELONG(x, y)) != HTCLIENT) {\n+        return FALSE;\n+    }\n+\n+    POINT pt = { x, y };\n+\n+    if (!::ScreenToClient(GetHWND(), &pt)) {\n+        return FALSE;\n+    }\n+\n+    \/\/ Unmirror the X coordinate we send to JavaFX if this is a RTL window.\n+    LONG style = ::GetWindowLong(GetHWND(), GWL_EXSTYLE);\n+    if (style & WS_EX_LAYOUTRTL) {\n+        RECT rect = {0};\n+        ::GetClientRect(GetHWND(), &rect);\n+        pt.x = max(0, rect.right - rect.left) - pt.x;\n+    }\n+\n+    JNIEnv* env = GetEnv();\n+    jint res = env->CallIntMethod(m_grefThis, javaIDs.WinWindow.nonClientHitTest, pt.x, pt.y);\n+    CheckAndClearException(env);\n+\n+    \/\/ The left, right, and bottom resize borders are outside of the client area and are provided for free.\n+    \/\/ In contrast, the top resize border is not outside, but inside the client area and below user controls.\n+    \/\/ For example, if a control extends to the top of the client area, it covers the resize border at that\n+    \/\/ location. We know that the cursor is on top of the caption area (and not on top of a control) when\n+    \/\/ the nonClientHitTest() function returns HTCAPTION (instead of HTCLIENT). In this case, we apply the\n+    \/\/ default resize border.\n+    if (res == HTCAPTION) {\n+        \/\/ Note: there is no SM_CYPADDEDBORDER\n+        int topBorderHeight = ::GetSystemMetrics(SM_CXPADDEDBORDER) + ::GetSystemMetrics(SM_CYSIZEFRAME);\n+        RECT windowRect;\n+\n+        if (::GetWindowRect(GetHWND(), &windowRect) && y < windowRect.top + topBorderHeight) {\n+            result = LRESULT(HTTOP);\n+            return TRUE;\n+        }\n+    }\n+\n+    result = LRESULT(res);\n+    return TRUE;\n+}\n+\n@@ -1090,0 +1261,54 @@\n+void GlassWindow::ShowSystemMenu(int x, int y)\n+{\n+    WINDOWPLACEMENT placement;\n+    if (!::GetWindowPlacement(GetHWND(), &placement)) {\n+        return;\n+    }\n+\n+    \/\/ Mirror the X coordinate we get from JavaFX if this is a RTL window.\n+    LONG exStyle = ::GetWindowLong(GetHWND(), GWL_EXSTYLE);\n+    if (exStyle & WS_EX_LAYOUTRTL) {\n+        RECT rect = {0};\n+        ::GetClientRect(GetHWND(), &rect);\n+        x = max(0, rect.right - rect.left) - x;\n+    }\n+\n+    HMENU systemMenu = GetSystemMenu(GetHWND(), FALSE);\n+    bool maximized = placement.showCmd == SW_SHOWMAXIMIZED;\n+\n+    LONG style = ::GetWindowLong(GetHWND(), GWL_STYLE);\n+    bool canMinimize = (style & WS_MINIMIZEBOX) && !(exStyle & WS_EX_TOOLWINDOW);\n+    bool canMaximize = (style & WS_MAXIMIZEBOX) && !maximized;\n+\n+    MENUITEMINFO menuItemInfo { sizeof(MENUITEMINFO) };\n+    menuItemInfo.fMask = MIIM_STATE;\n+    menuItemInfo.fType = MFT_STRING;\n+\n+    menuItemInfo.fState = maximized ? MF_ENABLED : MF_DISABLED;\n+    SetMenuItemInfo(systemMenu, SC_RESTORE, FALSE, &menuItemInfo);\n+\n+    menuItemInfo.fState = maximized ? MF_DISABLED : MF_ENABLED;\n+    SetMenuItemInfo(systemMenu, SC_MOVE, FALSE, &menuItemInfo);\n+\n+    menuItemInfo.fState = !m_isResizable || maximized ? MF_DISABLED : MF_ENABLED;\n+    SetMenuItemInfo(systemMenu, SC_SIZE, FALSE, &menuItemInfo);\n+\n+    menuItemInfo.fState = canMinimize ? MF_ENABLED : MF_DISABLED;\n+    SetMenuItemInfo(systemMenu, SC_MINIMIZE, FALSE, &menuItemInfo);\n+\n+    menuItemInfo.fState = canMaximize ? MF_ENABLED : MF_DISABLED;\n+    SetMenuItemInfo(systemMenu, SC_MAXIMIZE, FALSE, &menuItemInfo);\n+\n+    menuItemInfo.fState = MF_ENABLED;\n+    SetMenuItemInfo(systemMenu, SC_CLOSE, FALSE, &menuItemInfo);\n+    SetMenuDefaultItem(systemMenu, UINT_MAX, FALSE);\n+\n+    POINT ptAbs = { x, y };\n+    ::ClientToScreen(GetHWND(), &ptAbs);\n+\n+    BOOL menuItem = TrackPopupMenu(systemMenu, TPM_RETURNCMD, ptAbs.x, ptAbs.y, 0, GetHWND(), NULL);\n+    if (menuItem != 0) {\n+        PostMessage(GetHWND(), WM_SYSCOMMAND, menuItem, 0);\n+    }\n+}\n+\n@@ -1148,0 +1373,4 @@\n+\n+     javaIDs.WinWindow.nonClientHitTest = env->GetMethodID(cls, \"nonClientHitTest\", \"(II)I\");\n+     ASSERT(javaIDs.WinWindow.nonClientHitTest);\n+     if (env->ExceptionCheck()) return;\n@@ -1167,0 +1396,4 @@\n+        if (mask & com_sun_glass_ui_Window_EXTENDED) {\n+            mask |= com_sun_glass_ui_Window_TITLED;\n+        }\n+\n@@ -1209,0 +1442,1 @@\n+                (mask & com_sun_glass_ui_Window_EXTENDED) != 0,\n@@ -1911,0 +2145,23 @@\n+\/*\n+ * Class:     com_sun_glass_ui_win_WinWindow\n+ * Method:    _showSystemMenu\n+ * Signature: (JII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinWindow__1showSystemMenu\n+    (JNIEnv *env, jobject jThis, jlong ptr, jint x, jint y)\n+{\n+    ENTER_MAIN_THREAD()\n+    {\n+        GlassWindow *pWindow = GlassWindow::FromHandle(hWnd);\n+        if (pWindow) {\n+            pWindow->ShowSystemMenu(x, y);\n+        }\n+    }\n+    jint x, y;\n+    LEAVE_MAIN_THREAD_WITH_hWnd;\n+\n+    ARG(x) = x;\n+    ARG(y) = y;\n+    PERFORM();\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassWindow.cpp","additions":276,"deletions":19,"binary":false,"changes":295,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,2 @@\n-    GlassWindow(jobject jrefThis, bool isTransparent, bool isDecorated, bool isUnified, HWND parentOrOwner);\n+    GlassWindow(jobject jrefThis, bool isTransparent, bool isDecorated, bool isUnified,\n+                bool isExtended, HWND parentOrOwner);\n@@ -105,0 +106,1 @@\n+    void ShowSystemMenu(int x, int y);\n@@ -147,0 +149,1 @@\n+    const bool m_isExtended;\n@@ -187,0 +190,4 @@\n+    bool HandleMouseEvents(UINT msg, WPARAM wParam, LPARAM lParam);\n+    void HandleNonClientMouseEvents(UINT msg, WPARAM wParam, LPARAM lParam);\n+    LRESULT HandleNCCalcSizeEvent(UINT msg, WPARAM wParam, LPARAM lParam);\n+    BOOL HandleNCHitTestEvent(SHORT, SHORT, LRESULT&);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassWindow.h","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -493,0 +493,3 @@\n+    struct {\n+        jmethodID nonClientHitTest;\n+    } WinWindow;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/Utils.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -693,1 +693,1 @@\n-BOOL ViewContainer::HandleViewMouseEvent(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\n+BOOL ViewContainer::HandleViewMouseEvent(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, BOOL extendedWindow)\n@@ -704,1 +704,48 @@\n-    if (msg == WM_MOUSELEAVE) {\n+    \/\/ Windows with the EXTENDED style have an unusual anatomy: the entire window (excluding borders) comprises\n+    \/\/ the client area with regards to geometry, but not with regards to hit testing. The title bar is classified\n+    \/\/ as a non-client hit-testing area (by responding to the WM_NCHITTEST message), which enables window manager\n+    \/\/ interactions (dragging, snap layouts, etc).\n+    \/\/ When the mouse cursor moves from the client area to the title bar, we technically receive a WM_MOUSELEAVE\n+    \/\/ message that would normally cause a MouseEvent.EXIT event to be emitted. However, from the point of view\n+    \/\/ of the JavaFX application, the mouse cursor is still on the client-side title bar and therefore we wouldn't\n+    \/\/ expect to receive an MouseEvent.EXIT event. The following code detects this situation and prevents the\n+    \/\/ MouseEvent.EXIT event from being fired.\n+    if (msg == WM_MOUSELEAVE && extendedWindow) {\n+        DWORD msgPos = ::GetMessagePos(); \/\/ screen coordinates\n+        pt.x = GET_X_LPARAM(msgPos);\n+        pt.y = GET_Y_LPARAM(msgPos);\n+        RECT windowRect;\n+\n+        \/\/ We know that the cursor has moved from the client area to the title bar when the following two\n+        \/\/ conditions are met:\n+        \/\/   1. The window under the cursor is our own window. This allows us to disambiguate the situation\n+        \/\/      when the cursor was moved to another overlapping window that just happens to be placed over\n+        \/\/      our title bar.\n+        \/\/   2. The cursor position is still within the client area of our window. This allows us to detect\n+        \/\/      when the cursor was moved to the resize border of our window, which isn't part of the client\n+        \/\/      area and should therefore emit an EXIT event.\n+        if (::ChildWindowFromPointEx(::GetDesktopWindow(), pt, CWP_SKIPINVISIBLE) == hwnd\n+                && ::GetClientRect(hwnd, &windowRect)\n+                && ::ClientToScreen(hwnd, reinterpret_cast<POINT*>(&windowRect.left))\n+                && ::ClientToScreen(hwnd, reinterpret_cast<POINT*>(&windowRect.right))\n+                && ::PtInRect(&windowRect, pt)) { \/\/ pt is still in screen coordinates here\n+            TRACKMOUSEEVENT trackData;\n+            trackData.cbSize = sizeof(trackData);\n+            trackData.dwFlags = TME_LEAVE | TME_NONCLIENT;\n+            trackData.hwndTrack = hwnd;\n+            trackData.dwHoverTime = HOVER_DEFAULT;\n+\n+            \/\/ The cursor is now on the non-client hit-testing area of our window, and we need to enable\n+            \/\/ non-client mouse tracking to get a WM_NCMOUSELEAVE message when the cursor leaves the\n+            \/\/ non-client hit-testing area.\n+            if (::TrackMouseEvent(&trackData)) {\n+                m_bTrackingMouse = TRUE;\n+            }\n+        } else {\n+            type = com_sun_glass_events_MouseEvent_EXIT;\n+            m_bTrackingMouse = FALSE;\n+            m_lastMouseMovePosition = -1;\n+        }\n+\n+        ::ScreenToClient(hwnd, &pt);\n+    } else if (msg == WM_MOUSELEAVE) {\n@@ -937,0 +984,154 @@\n+void ViewContainer::HandleViewNonClientMouseEvent(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\n+{\n+    if (!GetGlassView()) {\n+        return;\n+    }\n+\n+    int type = 0;\n+    int button = com_sun_glass_events_MouseEvent_BUTTON_NONE;\n+    POINT pt;   \/\/ client coords\n+\n+    \/\/ Windows with the EXTENDED style have an unusual anatomy: the entire window (excluding borders) comprises\n+    \/\/ the client area with regards to geometry, but not with regards to hit testing. The title bar is classified\n+    \/\/ as a non-client hit-testing area (by responding to the WM_NCHITTEST message), which enables window manager\n+    \/\/ interactions (dragging, snap layouts, etc).\n+    \/\/ When the mouse cursor moves from the title bar to the client area, we technically receive a WM_NCMOUSELEAVE\n+    \/\/ message that would normally cause a MouseEvent.EXIT event to be emitted. However, from the point of view\n+    \/\/ of the JavaFX application, the mouse cursor is still on the window's client area and therefore we wouldn't\n+    \/\/ expect to receive an MouseEvent.EXIT event. The following code detects this situation and prevents the\n+    \/\/ MouseEvent.EXIT event from being fired.\n+    if (msg == WM_NCMOUSELEAVE) {\n+        DWORD msgPos = ::GetMessagePos(); \/\/ screen coordinates\n+        pt.x = GET_X_LPARAM(msgPos);\n+        pt.y = GET_Y_LPARAM(msgPos);\n+\n+        \/\/ Skip the MouseEvent.EXIT event when the cursor is now directly over our window. In contrast to\n+        \/\/ similar code in ViewContainer::HandleViewMouseEvent(), we don't need to test whether the cursor\n+        \/\/ is within the client area. If the cursor has left the non-client area, but is still directly over\n+        \/\/ our window, it can't be anywhere else but in the client area.\n+        if (::ChildWindowFromPointEx(::GetDesktopWindow(), pt, CWP_SKIPINVISIBLE) == hwnd) {\n+            TRACKMOUSEEVENT trackData;\n+            trackData.cbSize = sizeof(trackData);\n+            trackData.dwFlags = TME_LEAVE;\n+            trackData.hwndTrack = hwnd;\n+            trackData.dwHoverTime = HOVER_DEFAULT;\n+\n+            \/\/ Since the cursor is now on the client area of our window, we need to enable mouse tracking\n+            \/\/ to get a WM_MOUSELEAVE message when the cursor leaves the client area.\n+            if (::TrackMouseEvent(&trackData)) {\n+                m_bTrackingMouse = TRUE;\n+            }\n+        } else {\n+            type = com_sun_glass_events_MouseEvent_EXIT;\n+            m_bTrackingMouse = FALSE;\n+            m_lastMouseMovePosition = -1;\n+        }\n+\n+        ::ScreenToClient(hwnd, &pt);\n+    } else if (msg >= WM_NCMOUSEMOVE\n+                   && msg <= WM_NCXBUTTONDBLCLK\n+                   && (wParam == HTCAPTION || wParam == HTMINBUTTON || wParam == HTMAXBUTTON || wParam == HTCLOSE)) {\n+        pt.x = GET_X_LPARAM(lParam);\n+        pt.y = GET_Y_LPARAM(lParam);\n+        ::MapWindowPoints(NULL, hwnd, &pt, 1);\n+\n+        switch (msg) {\n+            case WM_NCMOUSEMOVE:\n+                if (lParam == m_lastMouseMovePosition) {\n+                    \/\/ Avoid sending synthetic NC_MOVE events if\n+                    \/\/ the pointer hasn't moved actually.\n+                    \/\/ Just consume the messages.\n+                    return;\n+                }\n+\n+                m_lastMouseMovePosition = lParam;\n+                type = com_sun_glass_events_MouseEvent_MOVE;\n+                break;\n+            case WM_NCLBUTTONDOWN:\n+                type = com_sun_glass_events_MouseEvent_DOWN;\n+                button = com_sun_glass_events_MouseEvent_BUTTON_LEFT;\n+                break;\n+            case WM_NCLBUTTONUP:\n+                type = com_sun_glass_events_MouseEvent_UP;\n+                button = com_sun_glass_events_MouseEvent_BUTTON_LEFT;\n+                break;\n+            case WM_NCRBUTTONDOWN:\n+                type = com_sun_glass_events_MouseEvent_DOWN;\n+                button = com_sun_glass_events_MouseEvent_BUTTON_RIGHT;\n+                break;\n+            case WM_NCRBUTTONUP:\n+                type = com_sun_glass_events_MouseEvent_UP;\n+                button = com_sun_glass_events_MouseEvent_BUTTON_RIGHT;\n+                break;\n+            case WM_NCMBUTTONDOWN:\n+                type = com_sun_glass_events_MouseEvent_DOWN;\n+                button = com_sun_glass_events_MouseEvent_BUTTON_OTHER;\n+                break;\n+            case WM_NCMBUTTONUP:\n+                type = com_sun_glass_events_MouseEvent_UP;\n+                button = com_sun_glass_events_MouseEvent_BUTTON_OTHER;\n+                break;\n+            case WM_NCXBUTTONDOWN:\n+                type = com_sun_glass_events_MouseEvent_DOWN;\n+                button = GET_XBUTTON_WPARAM(wParam) == XBUTTON1\n+                    ? com_sun_glass_events_MouseEvent_BUTTON_BACK\n+                    : com_sun_glass_events_MouseEvent_BUTTON_FORWARD;\n+                break;\n+            case WM_NCXBUTTONUP:\n+                type = com_sun_glass_events_MouseEvent_UP;\n+                button = GET_XBUTTON_WPARAM(wParam) == XBUTTON1\n+                    ? com_sun_glass_events_MouseEvent_BUTTON_BACK\n+                    : com_sun_glass_events_MouseEvent_BUTTON_FORWARD;\n+                break;\n+        }\n+    }\n+\n+    \/\/ Event was not handled\n+    if (type == 0) {\n+        return;\n+    }\n+\n+    \/\/ get screen coords\n+    POINT ptAbs = pt;\n+    ::ClientToScreen(hwnd, &ptAbs);\n+\n+    \/\/ unmirror the x coordinate\n+    LONG style = ::GetWindowLong(hwnd, GWL_EXSTYLE);\n+    if (style & WS_EX_LAYOUTRTL) {\n+        RECT rect = {0};\n+        ::GetClientRect(hwnd, &rect);\n+        pt.x = max(0, rect.right - rect.left) - pt.x;\n+    }\n+\n+    jint jModifiers = GetModifiers();\n+    jboolean isSynthesized = jboolean(IsTouchEvent());\n+    JNIEnv* env = GetEnv();\n+\n+    if (!m_bTrackingMouse && type != com_sun_glass_events_MouseEvent_EXIT) {\n+        TRACKMOUSEEVENT trackData;\n+        trackData.cbSize = sizeof(trackData);\n+        trackData.dwFlags = TME_LEAVE | TME_NONCLIENT;\n+        trackData.hwndTrack = hwnd;\n+        trackData.dwHoverTime = HOVER_DEFAULT;\n+\n+        if (::TrackMouseEvent(&trackData)) {\n+            \/\/ Mouse tracking will be canceled automatically upon receiving WM_NCMOUSELEAVE\n+            m_bTrackingMouse = TRUE;\n+        }\n+\n+        env->CallVoidMethod(GetView(), javaIDs.View.notifyMouse,\n+            com_sun_glass_events_MouseEvent_ENTER,\n+            com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+            pt.x, pt.y, ptAbs.x, ptAbs.y,\n+            jModifiers, JNI_FALSE, isSynthesized);\n+        CheckAndClearException(env);\n+    }\n+\n+    env->CallVoidMethod(GetView(), javaIDs.View.notifyMouse,\n+        type, button, pt.x, pt.y, ptAbs.x, ptAbs.y,\n+        jModifiers,\n+        type == com_sun_glass_events_MouseEvent_UP && button == com_sun_glass_events_MouseEvent_BUTTON_RIGHT,\n+        isSynthesized);\n+    CheckAndClearException(env);\n+}\n+\n@@ -951,1 +1152,1 @@\n-    trackData.dwFlags = TME_LEAVE | TME_CANCEL;\n+    trackData.dwFlags = TME_LEAVE | TME_NONCLIENT | TME_CANCEL;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/ViewContainer.cpp","additions":205,"deletions":4,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,2 @@\n-        BOOL HandleViewMouseEvent(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);\n+        BOOL HandleViewMouseEvent(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, BOOL extendedWindow);\n+        void HandleViewNonClientMouseEvent(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/ViewContainer.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,2 @@\n+#include <shellapi.h>\n+#include <versionhelpers.h>\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/common.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+.header-button-container {\n+    -fx-button-placement: right;\n+    -fx-button-vertical-alignment: center;\n+    -fx-button-default-height: 36;\n+}\n+\n+.iconify-button,\n+.maximize-button,\n+.close-button {\n+    -fx-background-color: #00000009;\n+    -fx-background-radius: 15;\n+    -fx-background-insets: 6;\n+    -fx-pref-width: 36;\n+}\n+\n+.iconify-button.dark,\n+.maximize-button.dark,\n+.close-button.dark {\n+    -fx-background-color: #ffffff09;\n+}\n+\n+.iconify-button:active,\n+.maximize-button:active,\n+.close-button:active {\n+    -fx-background-color: #00000015;\n+}\n+\n+.iconify-button.dark:active,\n+.maximize-button.dark:active,\n+.close-button.dark:active {\n+    -fx-background-color: #ffffff15\n+}\n+\n+.iconify-button:active:hover,\n+.maximize-button:active:hover,\n+.close-button:active:hover {\n+    -fx-background-color: #00000025;\n+}\n+\n+.iconify-button.dark:active:hover,\n+.maximize-button.dark:active:hover,\n+.close-button.dark:active:hover {\n+    -fx-background-color: #ffffff25;\n+}\n+\n+.iconify-button:pressed,\n+.maximize-button:pressed,\n+.close-button:pressed {\n+    -fx-background-color: #00000035 !important;\n+}\n+\n+.iconify-button.dark:pressed,\n+.maximize-button.dark:pressed,\n+.close-button.dark:pressed {\n+    -fx-background-color: #ffffff35 !important;\n+}\n+\n+.iconify-button > .glyph,\n+.maximize-button > .glyph,\n+.close-button > .glyph {\n+    -fx-background-color: #777;\n+    -fx-background-insets: 6 -6 -6 6;\n+    -fx-scale-shape: false;\n+    -fx-position-shape: false;\n+}\n+\n+.iconify-button:active > .glyph,\n+.maximize-button:active > .glyph,\n+.close-button:active > .glyph {\n+    -fx-background-color: #333;\n+}\n+\n+.iconify-button.dark:active > .glyph,\n+.maximize-button.dark:active > .glyph,\n+.close-button.dark:active > .glyph {\n+    -fx-background-color: white;\n+}\n+\n+.maximize-button:disabled {\n+    -fx-background-color: transparent;\n+}\n+\n+.maximize-button:disabled > .glyph {\n+    -fx-background-color: #777;\n+}\n+\n+.iconify-button > .glyph {\n+    -fx-shape: \"m 8,13 v 1 h 8 v -1 z\";\n+}\n+\n+.maximize-button > .glyph {\n+    -fx-shape: \"M 15,8.934 V 15 H 9 V 8.934 Z M 8,8 v 8 h 8 V 8 Z\";\n+}\n+\n+.maximize-button.restore > .glyph {\n+    -fx-shape: \"M 10 7 L 10 8 L 16 8 L 16 14 L 17 14 L 17 7 L 10 7 z M 8 9 L 8 16 L 15 16 L 15 9 L 8 9 z M 9 9.9238 L 14 9.9238 L 14 15 L 9 15 L 9 9.9238 z\";\n+}\n+\n+.close-button > .glyph {\n+    -fx-shape: \"m 8.1465,8.1465 a 0.5,0.5 0 0 0 0,0.707 L 11.293,12 8.1465,15.1465 a 0.5,0.5 0 0 0 0,0.707 0.5,0.5 0 0 0 0.707,0 L 12,12.707 l 3.1465,3.1465 a 0.5,0.5 0 0 0 0.707,0 0.5,0.5 0 0 0 0,-0.707 L 12.707,12 15.8535,8.8535 a 0.5,0.5 0 0 0 0,-0.707 0.5,0.5 0 0 0 -0.707,0 L 12,11.293 8.8535,8.1465 a 0.5,0.5 0 0 0 -0.707,0 z\";\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/glass\/ui\/gtk\/WindowDecorationGnome.css","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+.header-button-container {\n+    -fx-button-placement: right;\n+    -fx-button-vertical-alignment: center;\n+    -fx-button-default-height: 36;\n+}\n+\n+.iconify-button,\n+.maximize-button,\n+.close-button {\n+    -fx-background-color: transparent;\n+    -fx-background-radius: 13;\n+    -fx-background-insets: 8;\n+    -fx-pref-width: 36;\n+}\n+\n+.iconify-button > .glyph,\n+.maximize-button > .glyph,\n+.close-button > .glyph {\n+    -fx-background-color: #1d1d1e;\n+    -fx-background-insets: 8 -8 -8 8;\n+    -fx-scale-shape: false;\n+    -fx-position-shape: false;\n+}\n+\n+.iconify-button.dark > .glyph,\n+.maximize-button.dark > .glyph,\n+.close-button.dark > .glyph {\n+    -fx-background-color: #ced0d6;\n+}\n+\n+.iconify-button:hover,\n+.maximize-button:hover,\n+.close-button:hover {\n+    -fx-background-color: #27292d;\n+}\n+\n+.iconify-button.dark:hover,\n+.maximize-button.dark:hover,\n+.close-button.dark:hover {\n+    -fx-background-color: #dfe1e6;\n+}\n+\n+.iconify-button:hover > .glyph,\n+.maximize-button:hover > .glyph,\n+.close-button:hover > .glyph {\n+    -fx-background-color: #ced0d6;\n+}\n+\n+.iconify-button.dark:hover > .glyph,\n+.maximize-button.dark:hover > .glyph,\n+.close-button.dark:hover > .glyph {\n+    -fx-background-color: #393b40;\n+}\n+\n+.iconify-button:pressed,\n+.maximize-button:pressed,\n+.close-button:pressed {\n+    -fx-background-color: #474b52 !important;\n+}\n+\n+.iconify-button.dark:pressed,\n+.maximize-button.dark:pressed,\n+.close-button.dark:pressed {\n+    -fx-background-color: #6c7076 !important;\n+}\n+\n+.maximize-button:disabled {\n+    -fx-managed: false;\n+    visibility: hidden;\n+}\n+\n+.iconify-button > .glyph {\n+    -fx-shape: \"m 5,7.5 a 0.5,0.5 0 0 0 -0.3535,0.1465 0.5,0.5 0 0 0 0,0.707 l 5,5 a 0.5001,0.5001 0 0 0 0.707,0 l 5,-5 a 0.5,0.5 0 0 0 0,-0.707 0.5,0.5 0 0 0 -0.707,0 L 10,12.293 5.3535,7.6465 A 0.5,0.5 0 0 0 5,7.5 Z\";\n+}\n+\n+.maximize-button > .glyph {\n+    -fx-shape: \"m 9.6465,6.6465 -5,5 a 0.5,0.5 0 0 0 0,0.707 0.5,0.5 0 0 0 0.707,0 L 10,7.707 14.6465,12.3535 a 0.5,0.5 0 0 0 0.707,0 0.5,0.5 0 0 0 0,-0.707 l -5,-5 a 0.5001,0.5001 0 0 0 -0.707,0 z\";\n+}\n+\n+.maximize-button.restore > .glyph {\n+    -fx-shape: \"m 9.6465,5.1465 -4.5,4.5 a 0.5001,0.5001 0 0 0 0,0.707 l 4.5,4.5 a 0.5001,0.5001 0 0 0 0.707,0 l 4.5,-4.5 a 0.5001,0.5001 0 0 0 0,-0.707 l -4.5,-4.5 a 0.5001,0.5001 0 0 0 -0.707,0 z M 10,6.207 13.793,10 10,13.793 6.207,10 Z\";\n+}\n+\n+.close-button > .glyph {\n+    -fx-shape: \"m 6,5.5 a 0.5,0.5 0 0 0 -0.3535,0.1465 0.5,0.5 0 0 0 0,0.707 L 9.293,10 5.6465,13.6465 a 0.5,0.5 0 0 0 0,0.707 0.5,0.5 0 0 0 0.707,0 L 10,10.707 l 3.6465,3.6465 a 0.5,0.5 0 0 0 0.707,0 0.5,0.5 0 0 0 0,-0.707 L 10.707,10 14.3535,6.3535 a 0.5,0.5 0 0 0 0,-0.707 0.5,0.5 0 0 0 -0.707,0 L 10,9.293 6.3535,5.6465 A 0.5,0.5 0 0 0 6,5.5 Z\";\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/glass\/ui\/gtk\/WindowDecorationKDE.css","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+.header-button-container {\n+    -fx-button-placement: right;\n+    -fx-button-vertical-alignment: stretch;\n+    -fx-button-default-height: 29;\n+}\n+\n+.iconify-button,\n+.maximize-button,\n+.close-button {\n+    -fx-background-color: transparent;\n+    -fx-pref-width: 46;\n+}\n+\n+.header-button-container.utility > .close-button {\n+    -fx-pref-width: 29;\n+}\n+\n+.iconify-button:hover,\n+.maximize-button:hover {\n+    -fx-background-color: #00000015;\n+}\n+\n+.iconify-button.dark:hover,\n+.maximize-button.dark:hover {\n+    -fx-background-color: #ffffff15;\n+}\n+\n+.close-button:hover {\n+    -fx-background-color: #c42b1c;\n+}\n+\n+.iconify-button:pressed,\n+.maximize-button:pressed,\n+.close-button:pressed {\n+    -fx-opacity: 0.8;\n+}\n+\n+.iconify-button > .glyph,\n+.maximize-button > .glyph,\n+.close-button > .glyph {\n+    -fx-background-color: #777;\n+    -fx-scale-shape: false;\n+}\n+\n+.iconify-button:active > .glyph,\n+.maximize-button:active > .glyph,\n+.close-button:active > .glyph {\n+    -fx-background-color: black;\n+}\n+\n+.iconify-button.dark:active > .glyph,\n+.maximize-button.dark:active > .glyph,\n+.close-button.dark:active > .glyph {\n+    -fx-background-color: white;\n+}\n+\n+.close-button:hover > .glyph {\n+    -fx-background-color: white;\n+}\n+\n+.iconify-button.dark:pressed > .glyph {\n+    -fx-background-color: white;\n+}\n+\n+.maximize-button:disabled {\n+    -fx-background-color: transparent !important;\n+}\n+\n+.maximize-button:disabled > .glyph {\n+    -fx-background-color: #00000020 !important;\n+}\n+\n+.maximize-button.dark:disabled > .glyph {\n+    -fx-background-color: #ffffff20 !important;\n+}\n+\n+.iconify-button > .glyph {\n+    -fx-shape: \"m 0.4234,4.6755 q -0.0872,0 -0.164,-0.0332 Q 0.1827,4.6091 0.1245,4.551 0.0664,4.4929 0.0332,4.4161 0,4.3393 0,4.2521 0,4.1649 0.0332,4.0881 0.0664,4.0113 0.1245,3.9511 0.1827,3.8909 0.2595,3.8577 0.3362,3.8245 0.4234,3.8245 H 8.0783 q 0.0872,0 0.164,0.0332 0.0768,0.0332 0.1349,0.0934 0.0581,0.0602 0.0913,0.137 0.0332,0.0768 0.0332,0.164 0,0.0872 -0.0332,0.164 -0.0332,0.0768 -0.0913,0.1349 -0.0581,0.0581 -0.1349,0.0913 -0.0768,0.0332 -0.164,0.0332 z\";\n+}\n+\n+.maximize-button > .glyph {\n+    -fx-shape: \"M 1.2534,8.5 Q 1.0044,8.5 0.7761,8.3983 0.5479,8.2966 0.3756,8.1244 0.2034,7.9521 0.1017,7.7239 0,7.4956 0,7.2466 V 1.2534 Q 0,1.0044 0.1017,0.7761 0.2034,0.5479 0.3756,0.3756 0.5479,0.2034 0.7761,0.1017 1.0044,0 1.2534,0 H 7.2466 Q 7.4956,0 7.7239,0.1017 7.9521,0.2034 8.1244,0.3756 8.2966,0.5479 8.3983,0.7761 8.5,1.0044 8.5,1.2534 V 7.2466 Q 8.5,7.4956 8.3983,7.7239 8.2966,7.9521 8.1244,8.1244 7.9521,8.2966 7.7239,8.3983 7.4956,8.5 7.2466,8.5 Z M 7.2258,7.6492 q 0.0872,0 0.1639,-0.0332 0.0768,-0.0332 0.1349,-0.0913 0.0581,-0.0581 0.0913,-0.1349 0.0332,-0.0768 0.0332,-0.1639 V 1.2742 q 0,-0.0872 -0.0332,-0.1639 Q 7.5828,1.0334 7.5247,0.9753 7.4666,0.9172 7.3898,0.884 7.313,0.8508 7.2258,0.8508 H 1.2742 q -0.0872,0 -0.1639,0.0332 -0.0768,0.0332 -0.1349,0.0913 Q 0.9172,1.0334 0.884,1.1102 0.8508,1.187 0.8508,1.2742 v 5.9517 q 0,0.0872 0.0332,0.1639 0.0332,0.0768 0.0913,0.1349 0.0581,0.0581 0.1349,0.0913 0.0768,0.0332 0.1639,0.0332 z\";\n+}\n+\n+.maximize-button.restore > .glyph {\n+    -fx-shape: \"m 7.6492,2.5193 q 0,-0.3445 -0.1370,-0.6495 Q 7.3752,1.5647 7.1407,1.3385 6.9063,1.1123 6.5970,0.9816 6.2878,0.8508 5.9475,0.8508 H 1.7722 Q 1.8386,0.6599 1.9590,0.5022 2.0793,0.3445 2.2371,0.2324 2.3948,0.1204 2.5836,0.0602 2.7725,0 2.9758,0 H 5.9475 Q 6.4746,0 6.9395,0.2013 7.4043,0.4026 7.7509,0.7471 8.0974,1.0916 8.2987,1.5564 8.5,2.0212 8.5,2.5483 V 5.5242 Q 8.5,5.7275 8.4398,5.9164 8.3796,6.1052 8.2676,6.2629 8.1555,6.4207 7.9978,6.541 7.8401,6.6614 7.6492,6.7278 Z M 1.2534,8.5 Q 1.0044,8.5 0.7761,8.3983 0.5479,8.2966 0.3756,8.1244 0.2034,7.9521 0.1017,7.7239 0,7.4956 0,7.2466 V 2.9551 Q 0,2.7019 0.1017,2.4757 0.2034,2.2495 0.3756,2.0773 0.5479,1.905 0.774,1.8033 1.0002,1.7017 1.2534,1.7017 h 4.2915 q 0.2532,0 0.4814,0.1017 0.2283,0.1017 0.3984,0.2719 0.1702,0.1702 0.2719,0.3984 0.1017,0.2283 0.1017,0.4814 V 7.2466 q 0,0.2532 -0.1017,0.4794 Q 6.595,7.9521 6.4227,8.1244 6.2505,8.2966 6.0243,8.3983 5.7981,8.5 5.5449,8.5 Z M 5.5242,7.6492 q 0.0872,0 0.1639,-0.0332 0.0768,-0.0332 0.1370,-0.0913 0.0602,-0.0581 0.0934,-0.1349 0.0332,-0.0768 0.0332,-0.1639 v -4.25 q 0,-0.0872 -0.0332,-0.166 Q 5.8853,2.731 5.8271,2.6729 5.769,2.6147 5.6902,2.5815 5.6113,2.5483 5.5242,2.5483 h -4.25 q -0.0872,0 -0.1639,0.0332 -0.0768,0.0332 -0.1349,0.0934 -0.0581,0.0602 -0.0913,0.137 -0.0332,0.0768 -0.0332,0.1639 v 4.25 q 0,0.0872 0.0332,0.1639 0.0332,0.0768 0.0913,0.1349 0.0581,0.0581 0.1349,0.0913 0.0768,0.0332 0.1639,0.0332 z\";\n+}\n+\n+.close-button > .glyph {\n+    -fx-shape: \"M 4.25,4.8518 0.7263,8.3755 Q 0.6018,8.5 0.4275,8.5 0.2449,8.5 0.1224,8.3776 0,8.2551 0,8.0725 0,7.8982 0.1245,7.7737 L 3.6482,4.25 0.1245,0.7263 Q 0,0.6018 0,0.4233 0,0.3362 0.0332,0.2573 0.0664,0.1785 0.1245,0.1224 0.1826,0.0664 0.2615,0.0332 0.3403,0 0.4275,0 0.6018,0 0.7263,0.1245 L 4.25,3.6482 7.7737,0.1245 Q 7.8982,0 8.0767,0 q 0.0872,0 0.1639,0.0332 0.0768,0.0332 0.1349,0.0913 0.0581,0.0581 0.0913,0.1349 Q 8.5,0.3362 8.5,0.4233 8.5,0.6018 8.3755,0.7263 L 4.8518,4.25 8.3755,7.7737 Q 8.5,7.8982 8.5,8.0725 8.5,8.1597 8.4668,8.2385 8.4336,8.3174 8.3776,8.3755 8.3215,8.4336 8.2427,8.4668 8.1638,8.5 8.0767,8.5 7.8982,8.5 7.7737,8.3755 Z\";\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/glass\/ui\/win\/WindowDecoration.css","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -4,0 +4,1 @@\n+--add-exports javafx.base\/com.sun.javafx.binding=ALL-UNNAMED\n@@ -57,0 +58,1 @@\n+--add-opens javafx.graphics\/javafx.stage=ALL-UNNAMED\n","filename":"modules\/javafx.graphics\/src\/test\/addExports","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,459 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.glass.ui;\n+\n+import com.sun.glass.ui.HeaderButtonOverlay;\n+import com.sun.javafx.binding.ObjectConstant;\n+import javafx.beans.value.ObservableValue;\n+import javafx.geometry.Dimension2D;\n+import javafx.geometry.NodeOrientation;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.HeaderButtonType;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Stage;\n+import org.junit.jupiter.api.Test;\n+import test.util.ReflectionUtils;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+@SuppressWarnings(\"unused\")\n+public class HeaderButtonOverlayTest {\n+\n+    private static final Dimension2D EMPTY = new Dimension2D(0, 0);\n+\n+    \/**\n+     * Asserts that the buttons are laid out on the right side of the control (left-to-right orientation).\n+     *\/\n+    @Test\n+    void rightPlacement_stretchAlignment() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-placement: right;\n+                                           -fx-button-default-height: 20;\n+                                           -fx-button-vertical-alignment: stretch; }\n+                .header-button { -fx-pref-width: 20; }\n+            \"\"\"), false, false);\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertSize(overlay, 200, 100);\n+        assertLayoutBounds(children.get(0), 140, 0, 20, 20);\n+        assertLayoutBounds(children.get(1), 160, 0, 20, 20);\n+        assertLayoutBounds(children.get(2), 180, 0, 20, 20);\n+        assertEquals(EMPTY, overlay.metricsProperty().get().leftInset());\n+        assertEquals(new Dimension2D(60, 20), overlay.metricsProperty().get().rightInset());\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out on the right side of the control (right-to-left orientation).\n+     *\/\n+    @Test\n+    void rightPlacement_stretchAlignment_rightToLeft() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-placement: right;\n+                                           -fx-button-default-height: 20;\n+                                           -fx-button-vertical-alignment: stretch; }\n+                .header-button { -fx-pref-width: 20; }\n+            \"\"\"), false, true);\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertSize(overlay, 200, 100);\n+        assertLayoutBounds(children.get(0), 40, 0, 20, 20);\n+        assertLayoutBounds(children.get(1), 20, 0, 20, 20);\n+        assertLayoutBounds(children.get(2), 0, 0, 20, 20);\n+        assertEquals(new Dimension2D(60, 20), overlay.metricsProperty().get().leftInset());\n+        assertEquals(EMPTY, overlay.metricsProperty().get().rightInset());\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out on the right side of the control (left-to-right orientation)\n+     * with center alignment (including offsets caused by center alignment).\n+     *\/\n+    @Test\n+    void rightPlacement_centerAlignment() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-placement: right;\n+                                           -fx-button-default-height: 20;\n+                                           -fx-button-vertical-alignment: center; }\n+                .header-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"), false, false);\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertSize(overlay, 200, 100);\n+        assertLayoutBounds(children.get(0), 135, 5, 20, 10);\n+        assertLayoutBounds(children.get(1), 155, 5, 20, 10);\n+        assertLayoutBounds(children.get(2), 175, 5, 20, 10);\n+        assertEquals(EMPTY, overlay.metricsProperty().get().leftInset());\n+        assertEquals(new Dimension2D(70, 20), overlay.metricsProperty().get().rightInset());\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out on the left side of the control (right-to-left orientation)\n+     * with center alignment (including offsets caused by center alignment).\n+     *\/\n+    @Test\n+    void rightPlacement_centerAlignment_rightToLeft() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-placement: right;\n+                                           -fx-button-default-height: 20;\n+                                           -fx-button-vertical-alignment: center; }\n+                .header-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"), false, true);\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertSize(overlay, 200, 100);\n+        assertLayoutBounds(children.get(0), 45, 5, 20, 10);\n+        assertLayoutBounds(children.get(1), 25, 5, 20, 10);\n+        assertLayoutBounds(children.get(2), 5, 5, 20, 10);\n+        assertEquals(new Dimension2D(70, 20), overlay.metricsProperty().get().leftInset());\n+        assertEquals(EMPTY, overlay.metricsProperty().get().rightInset());\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out on the left side of the control (left-to-right orientation).\n+     *\/\n+    @Test\n+    void leftPlacement_stretchAlignment() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-placement: left;\n+                                           -fx-button-default-height: 20;\n+                                           -fx-button-vertical-alignment: stretch; }\n+                .header-button { -fx-pref-width: 20; }\n+            \"\"\"), false, false);\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertSize(overlay, 200, 100);\n+        assertLayoutBounds(children.get(0), 0, 0, 20, 20);\n+        assertLayoutBounds(children.get(1), 20, 0, 20, 20);\n+        assertLayoutBounds(children.get(2), 40, 0, 20, 20);\n+        assertEquals(new Dimension2D(60, 20), overlay.metricsProperty().get().leftInset());\n+        assertEquals(EMPTY, overlay.metricsProperty().get().rightInset());\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out on the left side of the control (right-to-left orientation).\n+     *\/\n+    @Test\n+    void leftPlacement_stretchAlignment_rightToLeft() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-placement: left;\n+                                           -fx-button-default-height: 20;\n+                                           -fx-button-vertical-alignment: stretch; }\n+                .header-button { -fx-pref-width: 20; }\n+            \"\"\"), false, true);\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertSize(overlay, 200, 100);\n+        assertLayoutBounds(children.get(0), 180, 0, 20, 20);\n+        assertLayoutBounds(children.get(1), 160, 0, 20, 20);\n+        assertLayoutBounds(children.get(2), 140, 0, 20, 20);\n+        assertEquals(EMPTY, overlay.metricsProperty().get().leftInset());\n+        assertEquals(new Dimension2D(60, 20), overlay.metricsProperty().get().rightInset());\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out on the left side of the control (left-to-right orientation)\n+     * with center alignment (including offsets caused by center alignment).\n+     *\/\n+    @Test\n+    void leftPlacement_centerAlignment() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-placement: left;\n+                                           -fx-button-default-height: 20;\n+                                           -fx-button-vertical-alignment: center; }\n+                .header-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"), false, false);\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertSize(overlay, 200, 100);\n+        assertLayoutBounds(children.get(0), 5, 5, 20, 10);\n+        assertLayoutBounds(children.get(1), 25, 5, 20, 10);\n+        assertLayoutBounds(children.get(2), 45, 5, 20, 10);\n+        assertEquals(new Dimension2D(70, 20), overlay.metricsProperty().get().leftInset());\n+        assertEquals(EMPTY, overlay.metricsProperty().get().rightInset());\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out on the left side of the control (right-to-left orientation)\n+     * with center alignment (including offsets caused by center alignment).\n+     *\/\n+    @Test\n+    void leftPlacement_centerAlignment_rightToLeft() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-placement: left;\n+                                           -fx-button-default-height: 20;\n+                                           -fx-button-vertical-alignment: center; }\n+                .header-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"), false, true);\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertSize(overlay, 200, 100);\n+        assertLayoutBounds(children.get(0), 175, 5, 20, 10);\n+        assertLayoutBounds(children.get(1), 155, 5, 20, 10);\n+        assertLayoutBounds(children.get(2), 135, 5, 20, 10);\n+        assertEquals(EMPTY, overlay.metricsProperty().get().leftInset());\n+        assertEquals(new Dimension2D(70, 20), overlay.metricsProperty().get().rightInset());\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out in a custom order (left-to-right orientation).\n+     *\/\n+    @Test\n+    void customButtonOrder() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-vertical-alignment: stretch; }\n+                .header-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+                .iconify-button { -fx-button-order: 5; }\n+                .maximize-button { -fx-button-order: 1; }\n+                .close-button { -fx-button-order: 3; }\n+            \"\"\"), false, false);\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertTrue(children.get(0).getStyleClass().contains(\"iconify-button\"));\n+        assertLayoutBounds(children.get(0), 180, 0, 20, 10);\n+        assertTrue(children.get(1).getStyleClass().contains(\"maximize-button\"));\n+        assertLayoutBounds(children.get(1), 140, 0, 20, 10);\n+        assertTrue(children.get(2).getStyleClass().contains(\"close-button\"));\n+        assertLayoutBounds(children.get(2), 160, 0, 20, 10);\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out in a custom order (right-to-left orientation).\n+     *\/\n+    @Test\n+    void customButtonOrder_rightToLeft() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-vertical-alignment: stretch; }\n+                .header-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+                .iconify-button { -fx-button-order: 5; }\n+                .maximize-button { -fx-button-order: 1; }\n+                .close-button { -fx-button-order: 3; }\n+            \"\"\"), false, true);\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertTrue(children.get(0).getStyleClass().contains(\"iconify-button\"));\n+        assertLayoutBounds(children.get(0), 0, 0, 20, 10);\n+        assertTrue(children.get(1).getStyleClass().contains(\"maximize-button\"));\n+        assertLayoutBounds(children.get(1), 40, 0, 20, 10);\n+        assertTrue(children.get(2).getStyleClass().contains(\"close-button\"));\n+        assertLayoutBounds(children.get(2), 20, 0, 20, 10);\n+    }\n+\n+    @Test\n+    void utilityDecorationIsOnlyCloseButton() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"), true, false);\n+\n+        var children = overlay.getChildrenUnmodifiable();\n+        assertEquals(1, children.size());\n+        assertTrue(children.getFirst().getStyleClass().contains(\"close-button\"));\n+    }\n+\n+    @Test\n+    void activePseudoClassCorrespondsToStageFocusedProperty() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-placement: right; }\n+                .header-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"), false, false);\n+\n+        var scene = new Scene(overlay);\n+        var stage = new Stage();\n+        stage.setScene(scene);\n+        stage.show();\n+\n+        assertTrue(stage.isFocused());\n+        assertTrue(overlay.getChildrenUnmodifiable().getFirst().getPseudoClassStates().stream().anyMatch(\n+                pc -> pc.getPseudoClassName().equals(\"active\")));\n+\n+        ReflectionUtils.invokeMethod(stage, \"setFocused\", new Class[] { boolean.class }, false);\n+\n+        assertFalse(stage.isFocused());\n+        assertTrue(overlay.getChildrenUnmodifiable().getFirst().getPseudoClassStates().stream().noneMatch(\n+                pc -> pc.getPseudoClassName().equals(\"active\")));\n+    }\n+\n+    \/**\n+     * Asserts that the maximize button is disabled when the stage is not resizable.\n+     *\/\n+    @Test\n+    void maximizeButtonIsDisabledWhenStageIsNotResizable() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-placement: right; }\n+                .header-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"), false, false);\n+\n+        var scene = new Scene(overlay);\n+        var stage = new Stage();\n+        stage.setScene(scene);\n+        stage.show();\n+\n+        var maxButton = overlay.getChildrenUnmodifiable().get(1);\n+        assertTrue(maxButton.getStyleClass().contains(\"maximize-button\"));\n+        assertTrue(stage.isResizable());\n+        assertFalse(maxButton.isDisabled());\n+\n+        stage.setResizable(false);\n+        assertTrue(maxButton.isDisabled());\n+    }\n+\n+    \/**\n+     * Asserts that the .restore style class is added to the maximize button when the stage is maximized.\n+     *\/\n+    @Test\n+    void restoreStyleClassIsPresentWhenStageIsMaximized() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-placement: right; }\n+                .header-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"), false, false);\n+\n+        var scene = new Scene(overlay);\n+        var stage = new Stage();\n+        stage.setScene(scene);\n+        stage.show();\n+\n+        var maxButton = overlay.getChildrenUnmodifiable().get(1);\n+        assertTrue(maxButton.getStyleClass().contains(\"maximize-button\"));\n+        assertFalse(maxButton.getStyleClass().contains(\"restore\"));\n+\n+        stage.setMaximized(true);\n+        assertTrue(maxButton.getStyleClass().contains(\"restore\"));\n+    }\n+\n+    \/**\n+     * Asserts that the .dark style class is added to all buttons when {@link Scene#getFill()} is dark.\n+     *\/\n+    @Test\n+    void darkStyleClassIsPresentWhenSceneFillIsDark() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-placement: right; }\n+                .header-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"), false, false);\n+\n+        var scene = new Scene(overlay);\n+\n+        scene.setFill(Color.WHITE);\n+        assertTrue(overlay.getChildrenUnmodifiable().stream().noneMatch(b -> b.getStyleClass().contains(\"dark\")));\n+\n+        scene.setFill(Color.BLACK);\n+        assertTrue(overlay.getChildrenUnmodifiable().stream().allMatch(b -> b.getStyleClass().contains(\"dark\")));\n+    }\n+\n+    \/**\n+     * Tests button picking using {@link HeaderButtonOverlay#buttonAt(double, double)}.\n+     *\/\n+    @Test\n+    void pickButtonAtCoordinates() {\n+        var overlay = new HeaderButtonOverlay(getStylesheet(\"\"\"\n+                .header-button-container { -fx-button-placement: right; -fx-button-vertical-alignment: stretch; }\n+                .header-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"), false, false);\n+\n+        var unused = new Scene(overlay);\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertNull(overlay.buttonAt(139, 5));\n+        assertEquals(HeaderButtonType.ICONIFY, overlay.buttonAt(140, 0));\n+        assertEquals(HeaderButtonType.MAXIMIZE, overlay.buttonAt(165, 5));\n+        assertEquals(HeaderButtonType.CLOSE, overlay.buttonAt(181, 10));\n+    }\n+\n+    private static ObservableValue<String> getStylesheet(String text) {\n+        String stylesheet = \"data:text\/css;base64,\"\n+            + Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));\n+\n+        return ObjectConstant.valueOf(stylesheet);\n+    }\n+\n+    private static void assertLayoutBounds(Node node, double x, double y, double width, double height) {\n+        assertEquals(x, node.getLayoutX());\n+        assertEquals(y, node.getLayoutY());\n+        assertSize(node, width, height);\n+    }\n+\n+    private static void assertSize(Node node, double width, double height) {\n+        assertEquals(width, node.getLayoutBounds().getWidth());\n+        assertEquals(height, node.getLayoutBounds().getHeight());\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/glass\/ui\/HeaderButtonOverlayTest.java","additions":459,"deletions":0,"binary":false,"changes":459,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,0 +222,4 @@\n+    @Override\n+    public void setPrefHeaderButtonHeight(double height) {\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/pgstub\/StubStage.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import javafx.scene.image.Image;\n@@ -39,0 +40,6 @@\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.CycleMethod;\n+import javafx.scene.paint.ImagePattern;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.RadialGradient;\n+import javafx.scene.paint.Stop;\n@@ -184,0 +191,41 @@\n+\n+    @Test\n+    void testAveragePerceptualBrightness_LinearGradient() {\n+        var gradient = new LinearGradient(\n+            0, 0, 1, 1, true, CycleMethod.NO_CYCLE,\n+            new Stop(0, Color.RED), new Stop(0.5, Color.GREEN), new Stop(1, Color.BLUE));\n+\n+        double actual = Utils.calculateAverageBrightness(gradient);\n+        double expect = (Utils.calculateBrightness(Color.RED)\n+            + Utils.calculateBrightness(Color.GREEN)\n+            + Utils.calculateBrightness(Color.BLUE)) \/ 3;\n+\n+        assertEquals(expect, actual);\n+    }\n+\n+    @Test\n+    void testAveragePerceptualBrightness_RadialGradient() {\n+        var gradient = new RadialGradient(\n+            0, 0, 0, 0, 1, true, CycleMethod.NO_CYCLE,\n+            new Stop(0, Color.RED), new Stop(0.5, Color.GREEN), new Stop(1, Color.BLUE));\n+\n+        double actual = Utils.calculateAverageBrightness(gradient);\n+        double expect = (Utils.calculateBrightness(Color.RED)\n+            + Utils.calculateBrightness(Color.GREEN)\n+            + Utils.calculateBrightness(Color.BLUE)) \/ 3;\n+\n+        assertEquals(expect, actual);\n+    }\n+\n+    @Test\n+    void testAveragePerceptualBrightness_ImagePattern() {\n+        var pattern = new ImagePattern(new Image(\"test\"));\n+        assertEquals(1, Utils.calculateAverageBrightness(pattern));\n+    }\n+\n+    @Test\n+    void testAveragePerceptualBrightness_Color() {\n+        var actual = Utils.calculateAverageBrightness(Color.RED);\n+        var expect = Utils.calculateBrightness(Color.RED);\n+        assertEquals(expect, actual);\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/util\/UtilsTest.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,586 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.layout;\n+\n+import com.sun.javafx.PreviewFeature;\n+import com.sun.javafx.scene.SceneHelper;\n+import com.sun.javafx.tk.HeaderAreaType;\n+import com.sun.javafx.tk.TKSceneListener;\n+import javafx.beans.property.DoubleProperty;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.geometry.Dimension2D;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Pos;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.HeaderBar;\n+import javafx.scene.layout.HeaderDragType;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.shape.Rectangle;\n+import javafx.stage.Stage;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import test.com.sun.javafx.pgstub.StubScene;\n+import test.util.ReflectionUtils;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+@SuppressWarnings(\"deprecation\")\n+public class HeaderBarTest {\n+\n+    HeaderBar headerBar;\n+\n+    @BeforeEach\n+    void setup() {\n+        PreviewFeature.enableForTesting();\n+        headerBar = new HeaderBar();\n+    }\n+\n+    @Test\n+    void emptyHeaderBar() {\n+        assertNull(headerBar.getLeading());\n+        assertNull(headerBar.getCenter());\n+        assertNull(headerBar.getTrailing());\n+    }\n+\n+    @Test\n+    void minHeight_correspondsToMinSystemHeight_ifNotSetByUser() {\n+        DoubleProperty minSystemHeight = ReflectionUtils.getFieldValue(headerBar, \"minSystemHeight\");\n+        minSystemHeight.set(100);\n+        assertEquals(100, headerBar.minHeight(-1));\n+\n+        headerBar.setMinHeight(50);\n+        minSystemHeight.set(200);\n+        assertEquals(50, headerBar.minHeight(-1));\n+    }\n+\n+    @Nested\n+    class LayoutTest {\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_LEFT, 10, 10, 100, 80\",\n+            \"TOP_CENTER, 10, 10, 100, 80\",\n+            \"TOP_RIGHT, 10, 10, 100, 80\",\n+            \"CENTER_LEFT, 10, 10, 100, 80\",\n+            \"CENTER, 10, 10, 100, 80\",\n+            \"CENTER_RIGHT, 10, 10, 100, 80\",\n+            \"BOTTOM_LEFT, 10, 10, 100, 80\",\n+            \"BOTTOM_CENTER, 10, 10, 100, 80\",\n+            \"BOTTOM_RIGHT, 10, 10, 100, 80\"\n+        })\n+        void alignmentOfLeadingChildOnly_resizable(Pos pos, double x, double y, double width, double height) {\n+            var content = new MockResizable(100, 50);\n+            HeaderBar.setAlignment(content, pos);\n+            HeaderBar.setMargin(content, new Insets(10));\n+            headerBar.setLeading(content);\n+            headerBar.resize(1000, 100);\n+            headerBar.layout();\n+\n+            assertBounds(x, y, width, height, content);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_LEFT, 10, 10, 100, 50\",\n+            \"TOP_CENTER, 10, 10, 100, 50\",\n+            \"TOP_RIGHT, 10, 10, 100, 50\",\n+            \"CENTER_LEFT, 10, 25, 100, 50\",\n+            \"CENTER, 10, 25, 100, 50\",\n+            \"CENTER_RIGHT, 10, 25, 100, 50\",\n+            \"BOTTOM_LEFT, 10, 40, 100, 50\",\n+            \"BOTTOM_CENTER, 10, 40, 100, 50\",\n+            \"BOTTOM_RIGHT, 10, 40, 100, 50\"\n+        })\n+        void alignmentOfLeadingChildOnly_notResizable(Pos pos, double x, double y, double width, double height) {\n+            var content = new Rectangle(100, 50);\n+            HeaderBar.setAlignment(content, pos);\n+            HeaderBar.setMargin(content, new Insets(10));\n+            headerBar.setLeading(content);\n+            headerBar.resize(1000, 100);\n+            headerBar.layout();\n+\n+            assertBounds(x, y, width, height, content);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_LEFT, 890, 10, 100, 80\",\n+            \"TOP_CENTER, 890, 10, 100, 80\",\n+            \"TOP_RIGHT, 890, 10, 100, 80\",\n+            \"CENTER_LEFT, 890, 10, 100, 80\",\n+            \"CENTER, 890, 10, 100, 80\",\n+            \"CENTER_RIGHT, 890, 10, 100, 80\",\n+            \"BOTTOM_LEFT, 890, 10, 100, 80\",\n+            \"BOTTOM_CENTER, 890, 10, 100, 80\",\n+            \"BOTTOM_RIGHT, 890, 10, 100, 80\"\n+        })\n+        void alignmentOfTrailingChildOnly_resizable(Pos pos, double x, double y, double width, double height) {\n+            var content = new MockResizable(100, 50);\n+            HeaderBar.setAlignment(content, pos);\n+            HeaderBar.setMargin(content, new Insets(10));\n+            headerBar.setTrailing(content);\n+            headerBar.resize(1000, 100);\n+            headerBar.layout();\n+\n+            assertBounds(x, y, width, height, content);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_LEFT, 890, 10, 100, 50\",\n+            \"TOP_CENTER, 890, 10, 100, 50\",\n+            \"TOP_RIGHT, 890, 10, 100, 50\",\n+            \"CENTER_LEFT, 890, 25, 100, 50\",\n+            \"CENTER, 890, 25, 100, 50\",\n+            \"CENTER_RIGHT, 890, 25, 100, 50\",\n+            \"BOTTOM_LEFT, 890, 40, 100, 50\",\n+            \"BOTTOM_CENTER, 890, 40, 100, 50\",\n+            \"BOTTOM_RIGHT, 890, 40, 100, 50\"\n+        })\n+        void alignmentOfTrailingChildOnly_notResizable(Pos pos, double x, double y, double width, double height) {\n+            var content = new Rectangle(100, 50);\n+            HeaderBar.setAlignment(content, pos);\n+            HeaderBar.setMargin(content, new Insets(10));\n+            headerBar.setTrailing(content);\n+            headerBar.resize(1000, 100);\n+            headerBar.layout();\n+\n+            assertBounds(x, y, width, height, content);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_LEFT, 10, 10, 200, 80\",\n+            \"TOP_CENTER, 400, 10, 200, 80\",\n+            \"TOP_RIGHT, 790, 10, 200, 80\",\n+            \"CENTER_LEFT, 10, 10, 200, 80\",\n+            \"CENTER, 400, 10, 200, 80\",\n+            \"CENTER_RIGHT, 790, 10, 200, 80\",\n+            \"BOTTOM_LEFT, 10, 10, 200, 80\",\n+            \"BOTTOM_CENTER, 400, 10, 200, 80\",\n+            \"BOTTOM_RIGHT, 790, 10, 200, 80\"\n+        })\n+        void alignmentOfCenterChildOnly_resizable(\n+                Pos pos, double x, double y, double width, double height) {\n+            var content = new MockResizable(0, 0, 100, 50, 200, 100);\n+            HeaderBar.setAlignment(content, pos);\n+            HeaderBar.setMargin(content, new Insets(10));\n+            headerBar.setCenter(content);\n+            headerBar.resize(1000, 100);\n+            headerBar.layout();\n+\n+            assertBounds(x, y, width, height, content);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_LEFT, 10, 10, 100, 50\",\n+            \"TOP_CENTER, 450, 10, 100, 50\",\n+            \"TOP_RIGHT, 890, 10, 100, 50\",\n+            \"CENTER_LEFT, 10, 25, 100, 50\",\n+            \"CENTER, 450, 25, 100, 50\",\n+            \"CENTER_RIGHT, 890, 25, 100, 50\",\n+            \"BOTTOM_LEFT, 10, 40, 100, 50\",\n+            \"BOTTOM_CENTER, 450, 40, 100, 50\",\n+            \"BOTTOM_RIGHT, 890, 40, 100, 50\"\n+        })\n+        void alignmentOfCenterChildOnly_notResizable(Pos pos, double x, double y, double width, double height) {\n+            var content = new Rectangle(100, 50);\n+            HeaderBar.setAlignment(content, pos);\n+            HeaderBar.setMargin(content, new Insets(10));\n+            headerBar.setCenter(content);\n+            headerBar.resize(1000, 100);\n+            headerBar.layout();\n+\n+            assertBounds(x, y, width, height, content);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_LEFT, 60, 10, 200, 80\",\n+            \"TOP_CENTER, 400, 10, 200, 80\",\n+            \"TOP_RIGHT, 640, 10, 200, 80\",\n+            \"CENTER_LEFT, 60, 10, 200, 80\",\n+            \"CENTER, 400, 10, 200, 80\",\n+            \"CENTER_RIGHT, 640, 10, 200, 80\",\n+            \"BOTTOM_LEFT, 60, 10, 200, 80\",\n+            \"BOTTOM_CENTER, 400, 10, 200, 80\",\n+            \"BOTTOM_RIGHT, 640, 10, 200, 80\"\n+        })\n+        void alignmentOfCenterChild_resizable_withNonEmptyLeadingAndTrailingChild(\n+                Pos pos, double x, double y, double width, double height) {\n+            var leading = new MockResizable(50, 50);\n+            var center = new MockResizable(0, 0, 100, 50, 200, 100);\n+            var trailing = new MockResizable(150, 50);\n+            HeaderBar.setAlignment(center, pos);\n+            HeaderBar.setMargin(center, new Insets(10));\n+            headerBar.setLeading(leading);\n+            headerBar.setCenter(center);\n+            headerBar.setTrailing(trailing);\n+            headerBar.resize(1000, 100);\n+            headerBar.layout();\n+\n+            assertBounds(x, y, width, height, center);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_LEFT, 60, 10, 100, 50\",\n+            \"TOP_CENTER, 450, 10, 100, 50\",\n+            \"TOP_RIGHT, 740, 10, 100, 50\",\n+            \"CENTER_LEFT, 60, 25, 100, 50\",\n+            \"CENTER, 450, 25, 100, 50\",\n+            \"CENTER_RIGHT, 740, 25, 100, 50\",\n+            \"BOTTOM_LEFT, 60, 40, 100, 50\",\n+            \"BOTTOM_CENTER, 450, 40, 100, 50\",\n+            \"BOTTOM_RIGHT, 740, 40, 100, 50\"\n+        })\n+        void alignmentOfCenterChild_notResizable_withNonEmptyLeadingAndTrailingChild(\n+                Pos pos, double x, double y, double width, double height) {\n+            var leading = new Rectangle(50, 50);\n+            var center = new Rectangle(100, 50);\n+            var trailing = new Rectangle(150, 50);\n+            HeaderBar.setAlignment(center, pos);\n+            HeaderBar.setMargin(center, new Insets(10));\n+            headerBar.setLeading(leading);\n+            headerBar.setCenter(center);\n+            headerBar.setTrailing(trailing);\n+            headerBar.resize(1000, 100);\n+            headerBar.layout();\n+\n+            assertBounds(x, y, width, height, center);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_LEFT, 160, 10, 680, 80\",\n+            \"TOP_CENTER, 160, 10, 680, 80\",\n+            \"TOP_RIGHT, 160, 10, 680, 80\",\n+            \"CENTER_LEFT, 160, 10, 680, 80\",\n+            \"CENTER, 160, 10, 680, 80\",\n+            \"CENTER_RIGHT, 160, 10, 680, 80\",\n+            \"BOTTOM_LEFT, 160, 10, 680, 80\",\n+            \"BOTTOM_CENTER, 160, 10, 680, 80\",\n+            \"BOTTOM_RIGHT, 160, 10, 680, 80\"\n+        })\n+        void alignmentOfCenterChild_withLeftSystemInset(Pos pos, double x, double y, double width, double height) {\n+            ObjectProperty<Dimension2D> leftSystemInset = ReflectionUtils.getFieldValue(headerBar, \"leftSystemInset\");\n+            leftSystemInset.set(new Dimension2D(100, 100));\n+            alignmentOfCenterChildImpl(pos, 1000, 1000, x, y, width, height);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_LEFT, 160, 10, 100, 80\",\n+            \"TOP_CENTER, 450, 10, 100, 80\",\n+            \"TOP_RIGHT, 740, 10, 100, 80\",\n+            \"CENTER_LEFT, 160, 10, 100, 80\",\n+            \"CENTER, 450, 10, 100, 80\",\n+            \"CENTER_RIGHT, 740, 10, 100, 80\",\n+            \"BOTTOM_LEFT, 160, 10, 100, 80\",\n+            \"BOTTOM_CENTER, 450, 10, 100, 80\",\n+            \"BOTTOM_RIGHT, 740, 10, 100, 80\"\n+        })\n+        void alignmentOfCenterChild_withLeftSystemInset_andMaxWidthConstraint(\n+                Pos pos, double x, double y, double width, double height) {\n+            ObjectProperty<Dimension2D> leftSystemInset = ReflectionUtils.getFieldValue(headerBar, \"leftSystemInset\");\n+            leftSystemInset.set(new Dimension2D(100, 100));\n+            alignmentOfCenterChildImpl(pos, 1000, 100, x, y, width, height);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_LEFT, 60, 10, 680, 80\",\n+            \"TOP_CENTER, 60, 10, 680, 80\",\n+            \"TOP_RIGHT, 60, 10, 680, 80\",\n+            \"CENTER_LEFT, 60, 10, 680, 80\",\n+            \"CENTER, 60, 10, 680, 80\",\n+            \"CENTER_RIGHT, 60, 10, 680, 80\",\n+            \"BOTTOM_LEFT, 60, 10, 680, 80\",\n+            \"BOTTOM_CENTER, 60, 10, 680, 80\",\n+            \"BOTTOM_RIGHT, 60, 10, 680, 80\"\n+        })\n+        void alignmentOfCenterChild_withRightSystemInset(Pos pos, double x, double y, double width, double height) {\n+            ObjectProperty<Dimension2D> rightSystemInset = ReflectionUtils.getFieldValue(headerBar, \"rightSystemInset\");\n+            rightSystemInset.set(new Dimension2D(100, 100));\n+            alignmentOfCenterChildImpl(pos, 1000, 1000, x, y, width, height);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_LEFT, 60, 10, 100, 80\",\n+            \"TOP_CENTER, 450, 10, 100, 80\",\n+            \"TOP_RIGHT, 640, 10, 100, 80\",\n+            \"CENTER_LEFT, 60, 10, 100, 80\",\n+            \"CENTER, 450, 10, 100, 80\",\n+            \"CENTER_RIGHT, 640, 10, 100, 80\",\n+            \"BOTTOM_LEFT, 60, 10, 100, 80\",\n+            \"BOTTOM_CENTER, 450, 10, 100, 80\",\n+            \"BOTTOM_RIGHT, 640, 10, 100, 80\"\n+        })\n+        void alignmentOfCenterChild_withRightSystemInset_andMaxWidthConstraint(\n+                Pos pos, double x, double y, double width, double height) {\n+            ObjectProperty<Dimension2D> rightSystemInset = ReflectionUtils.getFieldValue(headerBar, \"rightSystemInset\");\n+            rightSystemInset.set(new Dimension2D(100, 100));\n+            alignmentOfCenterChildImpl(pos, 1000, 100, x, y, width, height);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_CENTER, 260, 10, 80, 80\",\n+            \"CENTER, 260, 10, 80, 80\",\n+            \"BOTTOM_CENTER, 260, 10, 80, 80\"\n+        })\n+        void alignmentOfCenterChild_withLeftSystemInset_andOffsetCausedByInsufficientHorizontalSpace(\n+                Pos pos, double x, double y, double width, double height) {\n+            ObjectProperty<Dimension2D> leftSystemInset = ReflectionUtils.getFieldValue(headerBar, \"leftSystemInset\");\n+            leftSystemInset.set(new Dimension2D(200, 100));\n+            alignmentOfCenterChildImpl(pos, 500, 100, x, y, width, height);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_CENTER, 60, 10, 80, 80\",\n+            \"CENTER, 60, 10, 80, 80\",\n+            \"BOTTOM_CENTER, 60, 10, 80, 80\"\n+        })\n+        void alignmentOfCenterChild_withRightSystemInset_andOffsetCausedByInsufficientHorizontalSpace(\n+                Pos pos, double x, double y, double width, double height) {\n+            ObjectProperty<Dimension2D> rightSystemInset = ReflectionUtils.getFieldValue(headerBar, \"rightSystemInset\");\n+            rightSystemInset.set(new Dimension2D(200, 100));\n+            alignmentOfCenterChildImpl(pos, 500, 100, x, y, width, height);\n+        }\n+\n+        private void alignmentOfCenterChildImpl(Pos pos, double headerBarWidth, double maxWidth,\n+                                                double x, double y, double width, double height) {\n+            var leading = new MockResizable(50, 50);\n+            var center = new MockResizable(0, 0, 100, 50, maxWidth, 100);\n+            var trailing = new MockResizable(150, 50);\n+            HeaderBar.setAlignment(center, pos);\n+            HeaderBar.setMargin(center, new Insets(10));\n+            headerBar.setLeading(leading);\n+            headerBar.setCenter(center);\n+            headerBar.setTrailing(trailing);\n+            headerBar.resize(headerBarWidth, 100);\n+            headerBar.layout();\n+\n+            assertBounds(x, y, width, height, center);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_LEFT, 10, 10, 50, 50\",\n+            \"CENTER, 10, 25, 50, 50\",\n+            \"BOTTOM_LEFT, 10, 40, 50, 50\"\n+        })\n+        void alignmentOfLeadingChild_notResizable_withoutReservedArea(\n+                Pos pos, double x, double y, double width, double height) {\n+            ObjectProperty<Dimension2D> leftSystemInset = ReflectionUtils.getFieldValue(headerBar, \"leftSystemInset\");\n+            leftSystemInset.set(new Dimension2D(100, 100));\n+            var leading = new Rectangle(50, 50);\n+            HeaderBar.setAlignment(leading, pos);\n+            HeaderBar.setMargin(leading, new Insets(10));\n+            headerBar.setLeadingSystemPadding(false);\n+            headerBar.setLeading(leading);\n+            headerBar.resize(1000, 100);\n+            headerBar.layout();\n+\n+            assertBounds(x, y, width, height, leading);\n+        }\n+\n+        @ParameterizedTest\n+        @CsvSource({\n+            \"TOP_RIGHT, 940, 10, 50, 50\",\n+            \"CENTER, 940, 25, 50, 50\",\n+            \"BOTTOM_RIGHT, 940, 40, 50, 50\"\n+        })\n+        void alignmentOfTrailingChild_notResizable_withoutReservedArea(\n+                Pos pos, double x, double y, double width, double height) {\n+            ObjectProperty<Dimension2D> rightSystemInset = ReflectionUtils.getFieldValue(headerBar, \"rightSystemInset\");\n+            rightSystemInset.set(new Dimension2D(100, 100));\n+            var trailing = new Rectangle(50, 50);\n+            HeaderBar.setAlignment(trailing, pos);\n+            HeaderBar.setMargin(trailing, new Insets(10));\n+            headerBar.setTrailingSystemPadding(false);\n+            headerBar.setTrailing(trailing);\n+            headerBar.resize(1000, 100);\n+            headerBar.layout();\n+\n+            assertBounds(x, y, width, height, trailing);\n+        }\n+\n+        private void assertBounds(double x, double y, double width, double height, Node node) {\n+            var bounds = node.getLayoutBounds();\n+            assertEquals(x, node.getLayoutX());\n+            assertEquals(y, node.getLayoutY());\n+            assertEquals(width, bounds.getWidth());\n+            assertEquals(height, bounds.getHeight());\n+        }\n+    }\n+\n+    @Nested\n+    class PickingTest {\n+        \/**\n+         * For picking tests, we use a header bar with four nested boxes, arranged from left to right.\n+         *\n+         * <pre>\n+         *     0        50       100      150      200\n+         *     ┌────────┬───────────────────────────────────┐\n+         *     │  (HB)  │  box1  ┌──────────────────────────┤\n+         *     │        │        │  box2  ┌─────────────────┤\n+         *     │        │        │        │  box3  ┌────────┤\n+         *     │        │        │        │        │  box4  │\n+         *     ╞════════╧════════╧════════╧════════╧════════╡\n+         *     │                                            │\n+         * <\/pre>\n+         *\/\n+        private static class TestHeaderBar extends HeaderBar {\n+            final Box box4 = new Box(null, 50, 0, 50, 100);\n+            final Box box3 = new Box(box4, 50, 0, 100, 100);\n+            final Box box2 = new Box(box3, 50, 0, 150, 100);\n+            final Box box1 = new Box(box2, 50, 0, 200, 100);\n+\n+            TestHeaderBar() {\n+                resize(250, 100);\n+                setCenter(box1);\n+            }\n+        }\n+\n+        private static class Box extends StackPane {\n+            Box(Node child, double x, double y, double width, double height) {\n+                setManaged(false);\n+                resizeRelocate(x, y, width, height);\n+\n+                if (child != null) {\n+                    getChildren().add(child);\n+                }\n+            }\n+        }\n+\n+        @Test\n+         void pickDraggableNode() {\n+            var headerBar = new TestHeaderBar();\n+            HeaderBar.setDragType(headerBar.box1, HeaderDragType.DRAGGABLE);\n+\n+            var scene = new Scene(headerBar, 250, 200);\n+            var stage = new Stage();\n+            stage.setScene(scene);\n+            stage.show();\n+\n+            \/\/ 1. HeaderBar is always draggable\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 10, 10));\n+\n+            \/\/ 2. box1 is draggable because its drag type is DRAGGABLE\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 60, 10));\n+\n+            \/\/ 3. box2\/box3\/box4 are not draggable, because they don't inherit DRAGGABLE from box1\n+            assertNull(pickHeaderArea(scene, 110, 10));\n+            assertNull(pickHeaderArea(scene, 160, 10));\n+            assertNull(pickHeaderArea(scene, 210, 10));\n+        }\n+\n+        @Test\n+        void pickDraggableNodeInSubtree() {\n+            var headerBar = new TestHeaderBar();\n+            HeaderBar.setDragType(headerBar.box1, HeaderDragType.DRAGGABLE_SUBTREE);\n+\n+            var scene = new Scene(headerBar, 250, 200);\n+            var stage = new Stage();\n+            stage.setScene(scene);\n+            stage.show();\n+\n+            \/\/ 1. HeaderBar is always draggable\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 10, 10));\n+\n+            \/\/ 2. box1 is draggable because its drag type is DRAGGABLE_SUBTREE\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 60, 10));\n+\n+            \/\/ 3. box2\/box3\/box4 are draggable, because they inherit DRAGGABLE_SUBTREE from box1\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 110, 10));\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 160, 10));\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 210, 10));\n+        }\n+\n+        @Test\n+        void stopInheritanceOfDraggableSubtree() {\n+            var headerBar = new TestHeaderBar();\n+            HeaderBar.setDragType(headerBar.box1, HeaderDragType.DRAGGABLE_SUBTREE);\n+            HeaderBar.setDragType(headerBar.box3, HeaderDragType.NONE);\n+\n+            var scene = new Scene(headerBar, 250, 200);\n+            var stage = new Stage();\n+            stage.setScene(scene);\n+            stage.show();\n+\n+            \/\/ 1. HeaderBar is always draggable\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 10, 10));\n+\n+            \/\/ 2. box1 is draggable because its drag type is DRAGGABLE_SUBTREE\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 60, 10));\n+\n+            \/\/ 3. box2 is draggable, because it inherits DRAGGABLE_SUBTREE from box1\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 110, 10));\n+\n+            \/\/ 4. box3\/box4 are not draggable, because NONE stops the inherited DRAGGABLE_SUBTREE\n+            assertNull(pickHeaderArea(scene, 160, 10));\n+            assertNull(pickHeaderArea(scene, 210, 10));\n+        }\n+\n+        @Test\n+        void draggableNodeDoesNotStopInheritanceOfDraggableSubtree() {\n+            var headerBar = new TestHeaderBar();\n+            HeaderBar.setDragType(headerBar.box1, HeaderDragType.DRAGGABLE_SUBTREE);\n+            HeaderBar.setDragType(headerBar.box3, HeaderDragType.DRAGGABLE);\n+\n+            var scene = new Scene(headerBar, 250, 200);\n+            var stage = new Stage();\n+            stage.setScene(scene);\n+            stage.show();\n+\n+            \/\/ 1. HeaderBar is always draggable\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 10, 10));\n+\n+            \/\/ 2. box1 is draggable because its drag type is DRAGGABLE_SUBTREE\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 60, 10));\n+\n+            \/\/ 3. box2 is draggable, because it inherits DRAGGABLE_SUBTREE from box1\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 110, 10));\n+\n+            \/\/ 4. box3\/box4 are draggable, because DRAGGABLE doesn't stop the inherited DRAGGABLE_SUBTREE from box1\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 160, 10));\n+            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 210, 10));\n+        }\n+\n+        private static HeaderAreaType pickHeaderArea(Scene scene, double x, double y) {\n+            var peer = (StubScene)SceneHelper.getPeer(scene);\n+            TKSceneListener listener = ReflectionUtils.getFieldValue(peer, \"listener\");\n+            return listener.pickHeaderArea(x, y);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/HeaderBarTest.java","additions":586,"deletions":0,"binary":false,"changes":586,"status":"added"},{"patch":"@@ -54,1 +54,0 @@\n-import com.oracle.tools.fx.monkey.tools.ModalWindow;\n@@ -56,0 +55,1 @@\n+import com.oracle.tools.fx.monkey.tools.StageTesterWindow;\n@@ -152,0 +152,1 @@\n+        FX.item(m, \"Stage Tester\", this::openStageTesterWindow);\n@@ -159,2 +160,1 @@\n-        FX.separator(m);\n-        FX.item(m, \"Open Modal Window\", this::openModalWindow);\n+\n@@ -219,2 +219,2 @@\n-    private void openModalWindow() {\n-        new ModalWindow(this).show();\n+    private void openStageTesterWindow() {\n+        new StageTesterWindow(this).show();\n","filename":"tests\/manual\/monkey\/src\/com\/oracle\/tools\/fx\/monkey\/MainWindow.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.oracle.tools.fx.monkey.tools;\n-\n-import javafx.application.Platform;\n-import javafx.scene.Scene;\n-import javafx.scene.control.Button;\n-import javafx.scene.layout.BorderPane;\n-import javafx.scene.layout.HBox;\n-import javafx.stage.Modality;\n-import javafx.stage.Stage;\n-import javafx.stage.Window;\n-\n-\/**\n- * Test Modal Window\n- *\/\n-public class ModalWindow extends Stage {\n-    public ModalWindow(Window owner) {\n-        Button b1 = new Button(\"Does Nothing\");\n-        b1.setDefaultButton(false);\n-\n-        Button b2 = new Button(\"Platform.exit()\");\n-        b2.setDefaultButton(false);\n-        b2.setOnAction((ev) -> Platform.exit());\n-\n-        Button b3 = new Button(\"OK\");\n-        b3.setOnAction((ev) -> hide());\n-\n-        HBox bp = new HBox(b1, b2, b3);\n-        \/\/ FIX BUG: default button property ignored on macOS, ENTER goes to the first button\n-        b3.setDefaultButton(true);\n-\n-        BorderPane p = new BorderPane();\n-        p.setBottom(bp);\n-        System.out.println(b2.isDefaultButton() + \" \" + b3.isDefaultButton());\n-\n-        setTitle(\"Modal Window\");\n-        setScene(new Scene(p));\n-        initModality(Modality.APPLICATION_MODAL);\n-        initOwner(owner);\n-        setWidth(500);\n-        setHeight(200);\n-    }\n-}\n","filename":"tests\/manual\/monkey\/src\/com\/oracle\/tools\/fx\/monkey\/tools\/ModalWindow.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -0,0 +1,325 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.tools.fx.monkey.tools;\n+\n+import javafx.application.Platform;\n+import javafx.collections.FXCollections;\n+import javafx.css.PseudoClass;\n+import javafx.geometry.Insets;\n+import javafx.geometry.NodeOrientation;\n+import javafx.geometry.Pos;\n+import javafx.scene.Parent;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.CheckBox;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Menu;\n+import javafx.scene.control.MenuBar;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.SplitPane;\n+import javafx.scene.control.TextField;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.HeaderBar;\n+import javafx.scene.layout.HeaderButtonType;\n+import javafx.scene.layout.HeaderDragType;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Modality;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.stage.Window;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+\n+public final class StageTesterWindow extends Stage {\n+\n+    public StageTesterWindow(Stage owner) {\n+        var pane = new GridPane();\n+        pane.setHgap(10);\n+        pane.setVgap(10);\n+\n+        pane.add(new Label(\"Title\"), 0, 0);\n+        var titleTextField = new TextField(\"My Stage\");\n+        pane.add(titleTextField, 1, 0);\n+\n+        pane.add(new Label(\"Modality\"), 0, 1);\n+        var modalities = Arrays.stream(Modality.values()).map(Enum::name).toList();\n+        var modalityComboBox = new ComboBox<>(FXCollections.observableArrayList(modalities));\n+        modalityComboBox.getSelectionModel().select(0);\n+        pane.add(modalityComboBox, 1, 1);\n+\n+        pane.add(new Label(\"StageStyle\"), 0, 2);\n+        var stageStyles = Arrays.stream(StageStyle.values()).map(Enum::name).toList();\n+        var stageStyleComboBox = new ComboBox<>(FXCollections.observableArrayList(stageStyles));\n+        stageStyleComboBox.getSelectionModel().select(0);\n+        pane.add(stageStyleComboBox, 1, 2);\n+\n+        pane.add(new Label(\"NodeOrientation\"), 0, 3);\n+        var nodeOrientations = Arrays.stream(NodeOrientation.values()).map(Enum::name).toList();\n+        var nodeOrientationComboBox = new ComboBox<>(FXCollections.observableArrayList(nodeOrientations));\n+        nodeOrientationComboBox.getSelectionModel().select(2);\n+        pane.add(nodeOrientationComboBox, 1, 3);\n+\n+        pane.add(new Label(\"HeaderBar\"), 0, 4);\n+        var headerBarComboBox = new ComboBox<>(FXCollections.observableArrayList(\n+            \"None\", \"Simple\", \"Simple \/ custom buttons\", \"Split\", \"Split \/ custom buttons\"));\n+        headerBarComboBox.getSelectionModel().select(0);\n+        pane.add(headerBarComboBox, 1, 4);\n+\n+        pane.add(new Label(\"AlwaysOnTop\"), 0, 5);\n+        var alwaysOnTopCheckBox = new CheckBox();\n+        pane.add(alwaysOnTopCheckBox, 1, 5);\n+\n+        pane.add(new Label(\"Resizable\"), 0, 6);\n+        var resizableCheckBox = new CheckBox();\n+        resizableCheckBox.setSelected(true);\n+        pane.add(resizableCheckBox, 1, 6);\n+\n+        pane.add(new Label(\"Iconified\"), 0, 7);\n+        var iconifiedCheckBox = new CheckBox();\n+        pane.add(iconifiedCheckBox, 1, 7);\n+\n+        pane.add(new Label(\"Maximized\"), 0, 8);\n+        var maximizedCheckBox = new CheckBox();\n+        pane.add(maximizedCheckBox, 1, 8);\n+\n+        pane.add(new Label(\"FullScreen\"), 0, 9);\n+        var fullScreenCheckBox = new CheckBox();\n+        pane.add(fullScreenCheckBox, 1, 9);\n+\n+        pane.add(new Label(\"FullScreenExitHint\"), 0, 10);\n+        var fullScreenExitHintTextField = new TextField();\n+        pane.add(fullScreenExitHintTextField, 1, 10);\n+\n+        var showStageButton = new Button(\"Show Stage\");\n+        showStageButton.setOnAction(event -> {\n+            var newStage = new Stage();\n+            newStage.initStyle(StageStyle.valueOf(stageStyleComboBox.getValue()));\n+            newStage.initModality(Modality.valueOf(modalityComboBox.getValue()));\n+            newStage.setTitle(titleTextField.getText());\n+            newStage.setAlwaysOnTop(alwaysOnTopCheckBox.isSelected());\n+            newStage.setResizable(resizableCheckBox.isSelected());\n+            newStage.setIconified(iconifiedCheckBox.isSelected());\n+            newStage.setMaximized(maximizedCheckBox.isSelected());\n+            newStage.setFullScreen(fullScreenCheckBox.isSelected());\n+            newStage.setFullScreenExitHint(fullScreenExitHintTextField.getText().isEmpty()\n+                                           ? null : fullScreenExitHintTextField.getText());\n+\n+            if (newStage.getModality() != Modality.NONE) {\n+                newStage.initOwner(StageTesterWindow.this);\n+            }\n+\n+            Parent root = switch (headerBarComboBox.getValue().toLowerCase(Locale.ROOT)) {\n+                case \"simple\" -> createSimpleHeaderBarRoot(newStage, false);\n+                case \"simple \/ custom buttons\" -> createSimpleHeaderBarRoot(newStage, true);\n+                case \"split\" -> createSplitHeaderBarRoot(newStage, false);\n+                case \"split \/ custom buttons\" -> createSplitHeaderBarRoot(newStage, true);\n+                default -> new BorderPane(createWindowActions(newStage));\n+            };\n+\n+            var scene = new Scene(root);\n+            scene.setNodeOrientation(NodeOrientation.valueOf(nodeOrientationComboBox.getValue()));\n+\n+            newStage.setWidth(800);\n+            newStage.setHeight(500);\n+            newStage.setScene(scene);\n+            newStage.show();\n+        });\n+\n+        var root = new BorderPane(pane);\n+        root.setPadding(new Insets(20));\n+        root.setBottom(showStageButton);\n+        BorderPane.setAlignment(showStageButton, Pos.CENTER);\n+        BorderPane.setMargin(showStageButton, new Insets(30, 0, 0, 0));\n+\n+        initModality(Modality.APPLICATION_MODAL);\n+        initOwner(owner);\n+        setScene(new Scene(root));\n+        setTitle(\"Stage Tester\");\n+    }\n+\n+    private Parent createSimpleHeaderBarRoot(Stage stage, boolean customWindowButtons) {\n+        var headerBar = new HeaderBar();\n+        headerBar.setBackground(Background.fill(Color.LIGHTSKYBLUE));\n+        headerBar.setCenter(new TextField() {{ setPromptText(\"Search...\"); setMaxWidth(300); }});\n+\n+        var sizeComboBox = new ComboBox<>(FXCollections.observableArrayList(\"Small\", \"Medium\", \"Large\"));\n+        sizeComboBox.getSelectionModel().select(0);\n+\n+        Runnable updateMinHeight = () -> headerBar.setMinHeight(\n+            switch (sizeComboBox.getValue().toLowerCase(Locale.ROOT)) {\n+                case \"large\" -> 80;\n+                case \"medium\" -> 50;\n+                default -> headerBar.getMinSystemHeight();\n+            });\n+\n+        sizeComboBox.valueProperty().subscribe(event -> updateMinHeight.run());\n+        headerBar.minSystemHeightProperty().subscribe(event -> updateMinHeight.run());\n+\n+        var menuBar = new MenuBar(\n+            new Menu(\"File\", null,\n+                new MenuItem(\"New\"),\n+                new MenuItem(\"Open\"),\n+                new MenuItem(\"Save\"),\n+                new MenuItem(\"Close\")),\n+            new Menu(\"Edit\", null,\n+                new MenuItem(\"Undo\"),\n+                new MenuItem(\"Redo\"),\n+                new MenuItem(\"Copy\"),\n+                new MenuItem(\"Paste\")));\n+\n+        var leadingContent = new HBox(menuBar);\n+        HeaderBar.setDragType(leadingContent, HeaderDragType.DRAGGABLE);\n+        headerBar.setLeading(leadingContent);\n+\n+        if (customWindowButtons) {\n+            HeaderBar.setPrefButtonHeight(stage, 0);\n+        } else {\n+            var adaptiveButtonHeight = new CheckBox(\"Adaptive button height\");\n+\n+            headerBar.heightProperty().subscribe(h -> {\n+                if (adaptiveButtonHeight.isSelected()) {\n+                    HeaderBar.setPrefButtonHeight(stage, h.doubleValue());\n+                }\n+            });\n+\n+            adaptiveButtonHeight.selectedProperty().subscribe(value -> {\n+                if (value) {\n+                    HeaderBar.setPrefButtonHeight(stage, headerBar.getHeight());\n+                } else {\n+                    HeaderBar.setPrefButtonHeight(stage, HeaderBar.USE_DEFAULT_SIZE);\n+                }\n+            });\n+\n+            HBox.setMargin(adaptiveButtonHeight, new Insets(4));\n+            leadingContent.getChildren().add(adaptiveButtonHeight);\n+        }\n+\n+        var trailingNodes = new HBox(sizeComboBox);\n+        trailingNodes.setAlignment(Pos.CENTER);\n+        trailingNodes.setSpacing(5);\n+        headerBar.setTrailing(trailingNodes);\n+\n+        if (customWindowButtons) {\n+            trailingNodes.getChildren().addAll(createCustomWindowButtons());\n+        }\n+\n+        var borderPane = new BorderPane();\n+        borderPane.setTop(headerBar);\n+        borderPane.setCenter(createWindowActions(stage));\n+\n+        return borderPane;\n+    }\n+\n+    private Parent createSplitHeaderBarRoot(Stage stage, boolean customWindowButtons) {\n+        var leftHeaderBar = new HeaderBar();\n+        leftHeaderBar.setBackground(Background.fill(Color.VIOLET));\n+        leftHeaderBar.setLeading(new Button(\"\\u2728\"));\n+        leftHeaderBar.setCenter(new TextField() {{ setPromptText(\"Search...\"); setMaxWidth(200); }});\n+        leftHeaderBar.setTrailingSystemPadding(false);\n+\n+        var rightHeaderBar = new HeaderBar();\n+        rightHeaderBar.setBackground(Background.fill(Color.LIGHTSKYBLUE));\n+        rightHeaderBar.setLeadingSystemPadding(false);\n+\n+        var sizeComboBox = new ComboBox<>(FXCollections.observableArrayList(\"Small\", \"Medium\", \"Large\"));\n+        sizeComboBox.getSelectionModel().select(0);\n+\n+        Runnable updateMinHeight = () -> rightHeaderBar.setMinHeight(\n+            switch (sizeComboBox.getValue().toLowerCase(Locale.ROOT)) {\n+                case \"large\" -> 80;\n+                case \"medium\" -> 50;\n+                default -> rightHeaderBar.getMinSystemHeight();\n+            });\n+\n+        sizeComboBox.valueProperty().subscribe(event -> updateMinHeight.run());\n+        rightHeaderBar.minSystemHeightProperty().subscribe(event -> updateMinHeight.run());\n+\n+        var trailingNodes = new HBox(sizeComboBox);\n+        trailingNodes.setAlignment(Pos.CENTER);\n+        trailingNodes.setSpacing(5);\n+        rightHeaderBar.setTrailing(trailingNodes);\n+\n+        if (customWindowButtons) {\n+            trailingNodes.getChildren().addAll(createCustomWindowButtons());\n+            HeaderBar.setPrefButtonHeight(stage, 0);\n+        }\n+\n+        rightHeaderBar.setTrailing(trailingNodes);\n+\n+        var left = new BorderPane();\n+        left.setTop(leftHeaderBar);\n+        left.setCenter(createWindowActions(stage));\n+\n+        var right = new BorderPane();\n+        right.setTop(rightHeaderBar);\n+\n+        return new SplitPane(left, right);\n+    }\n+\n+    private List<Parent> createCustomWindowButtons() {\n+        var closeButton = new Button(\"Close\");\n+        var iconifyButton = new Button(\"Iconify\");\n+        var maximizeButton = new Button(\"Maximize\");\n+\n+        maximizeButton.getPseudoClassStates().subscribe(() -> {\n+            if (maximizeButton.getPseudoClassStates().contains(PseudoClass.getPseudoClass(\"maximized\"))) {\n+                maximizeButton.setText(\"Restore\");\n+            } else {\n+                maximizeButton.setText(\"Maximize\");\n+            }\n+        });\n+\n+        HeaderBar.setButtonType(iconifyButton, HeaderButtonType.ICONIFY);\n+        HeaderBar.setButtonType(maximizeButton, HeaderButtonType.MAXIMIZE);\n+        HeaderBar.setButtonType(closeButton, HeaderButtonType.CLOSE);\n+        return List.of(iconifyButton, maximizeButton, closeButton);\n+    }\n+\n+    private Parent createWindowActions(Stage stage) {\n+        var toggleFullScreenButton = new Button(\"Enter\/Exit Full Screen\");\n+        toggleFullScreenButton.setOnAction(event -> stage.setFullScreen(!stage.isFullScreen()));\n+\n+        var toggleMaximizedButton = new Button(\"Maximize\/Restore\");\n+        toggleMaximizedButton.setOnAction(event -> stage.setMaximized(!stage.isMaximized()));\n+\n+        var toggleIconifiedButton = new Button(\"Iconify\");\n+        toggleIconifiedButton.setOnAction(event -> stage.setIconified(true));\n+\n+        var closeButton = new Button(\"Close\");\n+        closeButton.setOnAction(event -> stage.close());\n+\n+        var root = new VBox(toggleFullScreenButton, toggleMaximizedButton, toggleIconifiedButton, closeButton);\n+        root.setSpacing(10);\n+        root.setAlignment(Pos.CENTER);\n+        return root;\n+    }\n+}\n","filename":"tests\/manual\/monkey\/src\/com\/oracle\/tools\/fx\/monkey\/tools\/StageTesterWindow.java","additions":325,"deletions":0,"binary":false,"changes":325,"status":"added"}]}