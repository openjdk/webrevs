{"files":[{"patch":"@@ -327,1 +327,1 @@\n-        \"winmm.lib\", \"imm32.lib\", \"shell32.lib\", \"Uiautomationcore.lib\", \"dwmapi.lib\",\n+        \"winmm.lib\", \"imm32.lib\", \"shell32.lib\", \"Uiautomationcore.lib\", \"dwmapi.lib\", \"uxtheme.lib\",\n@@ -329,1 +329,1 @@\n-        \"\/DELAYLOAD:Uiautomationcore.dll\", \"\/DELAYLOAD:dwmapi.dll\"]).flatten()\n+        \"\/DELAYLOAD:Uiautomationcore.dll\", \"\/DELAYLOAD:dwmapi.dll\", \"\/DELAYLOAD:uxtheme.dll\"]).flatten()\n","filename":"buildSrc\/win.gradle","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n@@ -33,0 +35,2 @@\n+    private ReflectionUtils() {}\n+\n@@ -64,0 +68,37 @@\n+\n+    \/**\n+     * Invokes the specified method on the object, and returns a value.\n+     * The method can be declared on any of the object's inherited classes.\n+     *\n+     * @param object the object on which the method will be invoked\n+     * @param methodName the method name\n+     * @param args the arguments\n+     * @return the return value\n+     *\/\n+    public static Object invokeMethod(Object object, String methodName, Class<?>[] parameterTypes, Object... args) {\n+        Function<Class<?>, Method> getMethod = cls -> {\n+            try {\n+                var method = cls.getDeclaredMethod(methodName, parameterTypes);\n+                method.setAccessible(true);\n+                return method;\n+            } catch (NoSuchMethodException e) {\n+                return null;\n+            }\n+        };\n+\n+        Class<?> cls = object.getClass();\n+        while (cls != null) {\n+            Method method = getMethod.apply(cls);\n+            if (method != null) {\n+                try {\n+                    return method.invoke(object, args);\n+                } catch (IllegalAccessException | InvocationTargetException e) {\n+                    throw new AssertionError(e);\n+                }\n+            }\n+\n+            cls = cls.getSuperclass();\n+        }\n+\n+        throw new AssertionError(\"Method not found: \" + methodName);\n+    }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/util\/ReflectionUtils.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import com.sun.glass.ui.WindowControlsOverlay;\n+import javafx.stage.StageStyle;\n@@ -52,0 +54,29 @@\n+\n+    \/**\n+     * Non-client events are only natively produced on the Windows platform as a result of\n+     * handling the {@code WM_NCHITTEST} message for an {@link StageStyle#EXTENDED} window.\n+     * <p>\n+     * They are never sent to applications, but are processed by {@link WindowControlsOverlay}.\n+     *\/\n+    @Native final static public int NC_DOWN         = 230;\n+    @Native final static public int NC_UP           = 231;\n+    @Native final static public int NC_DRAG         = 232;\n+    @Native final static public int NC_MOVE         = 233;\n+    @Native final static public int NC_ENTER        = 234;\n+    @Native final static public int NC_EXIT         = 235;\n+\n+    public static boolean isNonClientEvent(int event) {\n+        return event >= NC_DOWN && event <= NC_EXIT;\n+    }\n+\n+    public static int toNonClientEvent(int event) {\n+        return switch (event) {\n+            case DOWN -> NC_DOWN;\n+            case UP -> NC_UP;\n+            case DRAG -> NC_DRAG;\n+            case MOVE -> NC_MOVE;\n+            case ENTER -> NC_ENTER;\n+            case EXIT -> NC_EXIT;\n+            default -> event;\n+        };\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/events\/MouseEvent.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -718,0 +718,6 @@\n+    protected abstract boolean _supportsExtendedWindows();\n+    public final boolean supportsExtendedWindows() {\n+        checkEventThread();\n+        return _supportsExtendedWindows();\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/Application.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui;\n+\n+import javafx.stage.StageStyle;\n+\n+\/**\n+ * A non-client handler is used in some implementations of windows with the {@link StageStyle#EXTENDED} style.\n+ * It can inspect a mouse event before it is sent to FX, and decide to consume it if it affects\n+ * a non-client part of the window (for example, minimize\/maximize\/close buttons).\n+ *\/\n+public interface NonClientHandler {\n+\n+    \/**\n+     * Handles the event.\n+     *\n+     * @return {@code true} if the event was handled, {@code false} otherwise\n+     *\/\n+    boolean handleMouseEvent(int type, int button, int x, int y, int xAbs, int yAbs, int clickCount);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/NonClientHandler.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n-\n+import javafx.scene.Node;\n@@ -72,1 +72,1 @@\n-        public void handleMenuEvent(View view, int x, int y, int xAbs,\n+        public boolean handleMenuEvent(View view, int x, int y, int xAbs,\n@@ -74,0 +74,1 @@\n+            return false;\n@@ -368,0 +369,12 @@\n+        \/**\n+         * Returns the draggable area node at the specified coordinates, or {@code null}\n+         * if the specified coordinates do not intersect with a draggable area.\n+         *\n+         * @param x the X coordinate\n+         * @param y the Y coordinate\n+         * @return the draggable area node, or {@code null}\n+         *\/\n+        public Node pickDragAreaNode(double x, double y) {\n+            return null;\n+        }\n+\n@@ -398,0 +411,1 @@\n+    private NonClientHandler nonClientHandler;\n@@ -497,0 +511,6 @@\n+\n+        if (this.isValid && window.isExtendedWindow()) {\n+            this.nonClientHandler = window.getNonClientHandler();\n+        } else {\n+            this.nonClientHandler = null;\n+        }\n@@ -568,1 +588,1 @@\n-    private void handleMenuEvent(int x, int y, int xAbs, int yAbs, boolean isKeyboardTrigger) {\n+    protected boolean handleMenuEvent(int x, int y, int xAbs, int yAbs, boolean isKeyboardTrigger) {\n@@ -570,1 +590,1 @@\n-            this.eventHandler.handleMenuEvent(this, x, y, xAbs, yAbs, isKeyboardTrigger);\n+            return this.eventHandler.handleMenuEvent(this, x, y, xAbs, yAbs, isKeyboardTrigger);\n@@ -572,0 +592,1 @@\n+        return false;\n@@ -916,9 +937,0 @@\n-        \/\/ gznote: optimize - only call for undecorated Windows!\n-        if (this.window != null) {\n-            \/\/ handled by window (programmatical move\/resize)\n-            if (this.window.handleMouseEvent(type, button, x, y, xAbs, yAbs)) {\n-                \/\/ The evnet has been processed by Glass\n-                return;\n-            }\n-        }\n-\n@@ -948,0 +960,11 @@\n+        \/\/ If we have a non-client handler, we give it the first chance to handle the event.\n+        \/\/ Note that a full-screen window has no non-client area, and thus the non-client handler\n+        \/\/ is not notified.\n+        boolean handled = !inFullscreen && nonClientHandler != null\n+            && nonClientHandler.handleMouseEvent(type, button, x, y, xAbs, yAbs, clickCount);\n+\n+        \/\/ We never send non-client events to the application.\n+        if (handled || MouseEvent.isNonClientEvent(type)) {\n+            return;\n+        }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/View.java","additions":36,"deletions":13,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.glass.events.MouseEvent;\n@@ -30,0 +29,2 @@\n+import javafx.beans.value.ObservableValue;\n+import javafx.scene.Parent;\n@@ -119,0 +120,1 @@\n+    public static final int EXTENDED        = 1 << 2;\n@@ -133,1 +135,1 @@\n-    @Native public static final int UTILITY         = 1 << 2;\n+    @Native public static final int UTILITY         = 1 << 3;\n@@ -141,1 +143,1 @@\n-    @Native public static final int POPUP           = 1 << 3;\n+    @Native public static final int POPUP           = 1 << 4;\n@@ -145,3 +147,3 @@\n-    @Native public static final int CLOSABLE        = 1 << 4;\n-    @Native public static final int MINIMIZABLE     = 1 << 5;\n-    @Native public static final int MAXIMIZABLE     = 1 << 6;\n+    @Native public static final int CLOSABLE        = 1 << 5;\n+    @Native public static final int MINIMIZABLE     = 1 << 6;\n+    @Native public static final int MAXIMIZABLE     = 1 << 7;\n@@ -152,1 +154,1 @@\n-    @Native public static final int RIGHT_TO_LEFT     = 1 << 7;\n+    @Native public static final int RIGHT_TO_LEFT     = 1 << 8;\n@@ -160,1 +162,1 @@\n-    @Native public static final int UNIFIED = 1 << 8;\n+    @Native public static final int UNIFIED = 1 << 9;\n@@ -165,1 +167,1 @@\n-    @Native public static final int MODAL = 1 << 9;\n+    @Native public static final int MODAL = 1 << 10;\n@@ -200,1 +202,0 @@\n-    private boolean shouldStartUndecoratedMove = false;\n@@ -206,1 +207,0 @@\n-    private UndecoratedMoveResizeHelper helper = null;\n@@ -240,1 +240,1 @@\n-        switch (styleMask & (TITLED | TRANSPARENT)) {\n+        switch (styleMask & (TITLED | TRANSPARENT | EXTENDED)) {\n@@ -244,0 +244,1 @@\n+            case EXTENDED:\n@@ -246,1 +247,1 @@\n-                throw new RuntimeException(\"The visual kind should be UNTITLED, TITLED, or TRANSPARENT, but not a combination of these\");\n+                throw new RuntimeException(\"The visual kind should be UNTITLED, TITLED, TRANSPARENT, or EXTENDED, but not a combination of these\");\n@@ -257,0 +258,4 @@\n+        if ((styleMask & UNIFIED) != 0 && (styleMask & EXTENDED) != 0) {\n+            throw new RuntimeException(\"UNIFIED and EXTENDED cannot be combined\");\n+        }\n+\n@@ -267,1 +272,0 @@\n-\n@@ -378,3 +382,0 @@\n-            if (this.isDecorated == false) {\n-                this.helper = new UndecoratedMoveResizeHelper();\n-            }\n@@ -425,0 +426,27 @@\n+    \/**\n+     * Returns metrics of the window-provided overlay controls.\n+     *\n+     * @return the overlay metrics, or {@code null} if the window type does not support metrics\n+     *\/\n+    public ObservableValue<WindowOverlayMetrics> windowOverlayMetrics() {\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the window-provided overlay controls, which are rendered above all application content.\n+     *\n+     * @return the overlay, or {@code null} if the window type does not provide overlay controls\n+     *\/\n+    public Parent getWindowOverlay() {\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the window-provided non-client event handler.\n+     *\n+     * @return the non-client event handler, or {@code null}\n+     *\/\n+    public NonClientHandler getNonClientHandler() {\n+        return null;\n+    }\n+\n@@ -677,0 +705,4 @@\n+    public boolean isExtendedWindow() {\n+        return (this.styleMask & Window.EXTENDED) != 0;\n+    }\n+\n@@ -1151,9 +1183,0 @@\n-    \/**\n-     * Enables unconditional start of window move operation when\n-     * mouse is dragged in the client area.\n-     *\/\n-    public void setShouldStartUndecoratedMove(boolean v) {\n-        Application.checkEventThread();\n-        this.shouldStartUndecoratedMove = v;\n-    }\n-\n@@ -1217,5 +1240,0 @@\n-\n-            \/\/ update moveRect\/resizeRect\n-            if (this.helper != null){\n-                this.helper.updateRectangles();\n-            }\n@@ -1272,96 +1290,0 @@\n-    \/\/ *****************************************************\n-    \/\/ programmatical move\/resize\n-    \/\/ *****************************************************\n-    \/** Sets \"programmatical move\" rectangle.\n-     * The rectangle is measured from top of the View:\n-     * width is View.width, height is size.\n-     *\n-     * throws RuntimeException for decorated window.\n-     *\/\n-    public void setUndecoratedMoveRectangle(int size) {\n-        Application.checkEventThread();\n-        if (this.isDecorated == true) {\n-            \/\/throw new RuntimeException(\"setUndecoratedMoveRectangle is only valid for Undecorated Window\");\n-            System.err.println(\"Glass Window.setUndecoratedMoveRectangle is only valid for Undecorated Window. In the future this will be hard error.\");\n-            Thread.dumpStack();\n-            return;\n-        }\n-\n-        if (this.helper != null) {\n-            this.helper.setMoveRectangle(size);\n-        }\n-    }\n-    \/** The method called only for undecorated windows\n-     * x, y: mouse coordinates (in View space).\n-     *\n-     * throws RuntimeException for decorated window.\n-     *\/\n-    public boolean shouldStartUndecoratedMove(final int x, final int y) {\n-        Application.checkEventThread();\n-        if (this.shouldStartUndecoratedMove == true) {\n-            return true;\n-        }\n-        if (this.isDecorated == true) {\n-            return false;\n-        }\n-\n-        if (this.helper != null) {\n-            return this.helper.shouldStartMove(x, y);\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    \/** Sets \"programmatical resize\" rectangle.\n-     * The rectangle is measured from top of the View:\n-     * width is View.width, height is size.\n-     *\n-     * throws RuntimeException for decorated window.\n-     *\/\n-    public void setUndecoratedResizeRectangle(int size) {\n-        Application.checkEventThread();\n-        if ((this.isDecorated == true) || (this.isResizable == false)) {\n-            \/\/throw new RuntimeException(\"setUndecoratedMoveRectangle is only valid for Undecorated Resizable Window\");\n-            System.err.println(\"Glass Window.setUndecoratedResizeRectangle is only valid for Undecorated Resizable Window. In the future this will be hard error.\");\n-            Thread.dumpStack();\n-            return;\n-        }\n-\n-        if (this.helper != null) {\n-            this.helper.setResizeRectangle(size);\n-        }\n-    }\n-\n-    \/** The method called only for undecorated windows\n-     * x, y: mouse coordinates (in View space).\n-     *\n-     * throws RuntimeException for decorated window.\n-     *\/\n-    public boolean shouldStartUndecoratedResize(final int x, final int y) {\n-        Application.checkEventThread();\n-        if ((this.isDecorated == true) || (this.isResizable == false)) {\n-            return false;\n-        }\n-\n-        if (this.helper != null) {\n-            return this.helper.shouldStartResize(x, y);\n-        }  else {\n-            return false;\n-        }\n-    }\n-\n-    \/** Mouse event handler for processing programmatical resize\/move\n-     * (for undecorated windows only).\n-     * Must be called by View.\n-     * x & y are View coordinates.\n-     * NOTE: it's package private!\n-     * @return true if the event is processed by the window,\n-     *         false if it has to be delivered to the app\n-     *\/\n-    boolean handleMouseEvent(int type, int button, int x, int y, int xAbs, int yAbs) {\n-        if (this.isDecorated == false) {\n-            return this.helper.handleMouseEvent(type, button, x, y, xAbs, yAbs);\n-        }\n-        return false;\n-    }\n-\n@@ -1403,137 +1325,0 @@\n-    private class UndecoratedMoveResizeHelper {\n-        TrackingRectangle moveRect = null;\n-        TrackingRectangle resizeRect = null;\n-\n-        boolean inMove = false;         \/\/ we are in \"move\" mode\n-        boolean inResize = false;       \/\/ we are in \"resize\" mode\n-\n-        int startMouseX, startMouseY;   \/\/ start mouse coords\n-        int startX, startY;             \/\/ start window location (for move)\n-        int startWidth, startHeight;    \/\/ start window size (for resize)\n-\n-        UndecoratedMoveResizeHelper() {\n-            this.moveRect = new TrackingRectangle();\n-            this.resizeRect = new TrackingRectangle();\n-        }\n-\n-        void setMoveRectangle(final int size) {\n-            this.moveRect.size = size;\n-\n-            this.moveRect.x = 0;\n-            this.moveRect.y = 0;\n-            this.moveRect.width = getWidth();\n-            this.moveRect.height = this.moveRect.size;\n-        }\n-\n-        boolean shouldStartMove(final int x, final int y) {\n-            return this.moveRect.contains(x, y);\n-        }\n-\n-        boolean inMove() {\n-            return this.inMove;\n-        }\n-\n-        void startMove(final int x, final int y) {\n-            this.inMove = true;\n-\n-            this.startMouseX = x;\n-            this.startMouseY = y;\n-\n-            this.startX = getX();\n-            this.startY = getY();\n-        }\n-\n-        void deltaMove(final int x, final int y) {\n-            int deltaX = x - this.startMouseX;\n-            int deltaY = y - this.startMouseY;\n-\n-            setPosition(this.startX + deltaX, this.startY + deltaY);\n-        }\n-\n-        void stopMove() {\n-            this.inMove = false;\n-        }\n-\n-        void setResizeRectangle(final int size) {\n-            this.resizeRect.size = size;\n-\n-            \/\/ set the rect (bottom right corner of the Window)\n-            this.resizeRect.x = getWidth() - this.resizeRect.size;\n-            this.resizeRect.y = getHeight() - this.resizeRect.size;\n-            this.resizeRect.width = this.resizeRect.size;\n-            this.resizeRect.height = this.resizeRect.size;\n-        }\n-\n-        boolean shouldStartResize(final int x, final int y) {\n-            return this.resizeRect.contains(x, y);\n-        }\n-\n-        boolean inResize() {\n-            return this.inResize;\n-        }\n-\n-        void startResize(final int x, final int y) {\n-            this.inResize = true;\n-\n-            this.startMouseX = x;\n-            this.startMouseY = y;\n-\n-            this.startWidth = getWidth();\n-            this.startHeight = getHeight();\n-        }\n-\n-        void deltaResize(final int x, final int y) {\n-            int deltaX = x - this.startMouseX;\n-            int deltaY = y - this.startMouseY;\n-\n-            setSize(this.startWidth + deltaX, this.startHeight + deltaY);\n-        }\n-\n-        protected void stopResize() {\n-            this.inResize = false;\n-        }\n-\n-        void updateRectangles() {\n-            if (this.moveRect.size > 0) {\n-                setMoveRectangle(this.moveRect.size);\n-            }\n-            if (this.resizeRect.size > 0) {\n-                setResizeRectangle(this.resizeRect.size);\n-            }\n-        }\n-\n-        boolean handleMouseEvent(final int type, final int button, final int x, final int y, final int xAbs, final int yAbs) {\n-            switch (type) {\n-                case MouseEvent.DOWN:\n-                    if (button == MouseEvent.BUTTON_LEFT) {\n-                        if (shouldStartUndecoratedMove(x, y) == true) {\n-                            startMove(xAbs, yAbs);\n-                            return true;\n-                        } else if (shouldStartUndecoratedResize(x, y) == true) {\n-                            startResize(xAbs, yAbs);\n-                            return true;\n-                        }\n-                    }\n-                    break;\n-\n-                case MouseEvent.MOVE:\n-                case MouseEvent.DRAG:\n-                    if (inMove() == true) {\n-                        deltaMove(xAbs, yAbs);\n-                        return true;\n-                    } else if (inResize() == true) {\n-                        deltaResize(xAbs, yAbs);\n-                        return true;\n-                    }\n-                    break;\n-\n-                case MouseEvent.UP:\n-                    boolean wasProcessed = inMove() || inResize();\n-                    stopResize();\n-                    stopMove();\n-                    return wasProcessed;\n-            }\n-            return false;\n-        }\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/Window.java","additions":49,"deletions":264,"binary":false,"changes":313,"status":"modified"},{"patch":"@@ -0,0 +1,540 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui;\n+\n+import com.sun.glass.events.MouseEvent;\n+import com.sun.javafx.util.Utils;\n+import javafx.application.Platform;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.ReadOnlyObjectProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.beans.value.ObservableValue;\n+import javafx.css.CssMetaData;\n+import javafx.css.PseudoClass;\n+import javafx.css.SimpleStyleableBooleanProperty;\n+import javafx.css.SimpleStyleableIntegerProperty;\n+import javafx.css.SimpleStyleableObjectProperty;\n+import javafx.css.StyleConverter;\n+import javafx.css.Styleable;\n+import javafx.css.StyleableBooleanProperty;\n+import javafx.css.StyleableIntegerProperty;\n+import javafx.css.StyleableObjectProperty;\n+import javafx.css.StyleableProperty;\n+import javafx.geometry.Dimension2D;\n+import javafx.geometry.HPos;\n+import javafx.geometry.HorizontalDirection;\n+import javafx.geometry.NodeOrientation;\n+import javafx.geometry.VPos;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.Region;\n+import javafx.scene.paint.Paint;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.util.Subscription;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Contains the visuals and behaviors for the minimize\/maximize\/close buttons on an {@link StageStyle#EXTENDED}\n+ * window for platforms that use client-side decorations (Windows and Linux\/GTK). This control supports\n+ * left-to-right and right-to-left orientations, as well as a customizable layout order of buttons.\n+ *\n+ * <h2>Substructure<\/h2>\n+ * <ul>\n+ *     <li>{@link Region} — {@code window-button-container}\n+ *     <ul>\n+ *         <li>{@link Region} — {@code window-button}, {@code minimize-button}\n+ *         <li>{@link Region} — {@code window-button}, {@code maximize-button}\n+ *         <li>{@link Region} — {@code window-button}, {@code close-button}\n+ *     <\/ul>\n+ * <\/ul>\n+ *\n+ * <table style=\"white-space: nowrap\">\n+ *     <caption>CSS properties of {@code window-button-container}<\/caption>\n+ *     <thead>\n+ *         <tr><th>CSS property<\/th><th>Values<\/th><th>Default<\/th><th>Comment<\/th><\/tr>\n+ *     <\/thead>\n+ *     <tbody>\n+ *         <tr>\n+ *             <th>-fx-button-placement<\/th><td>[ left | right ]<\/td><td>right<\/td>\n+ *             <td style=\"white-space: break-line\">\n+ *                 Specifies the placement of the window buttons on the left or the right side of the window.\n+ *             <\/td>\n+ *         <\/tr>\n+ *         <tr>\n+ *             <th>-fx-allow-rtl<\/th><td>&lt;boolean&gt;<\/td><td>true<\/td>\n+ *             <td style=\"white-space: break-line\">\n+ *                 Specifies whether the minimize\/maximize\/close buttons support right-to-left orientations.\n+ *             <\/td>\n+ *         <\/tr>\n+ *     <\/tbody>\n+ * <\/table>\n+ *\n+ * <table style=\"white-space: nowrap\">\n+ *     <caption>CSS properties of {@code minimize-button}, {@code maximize-button}, {@code close-button}<\/caption>\n+ *     <thead>\n+ *         <tr><th>CSS property<\/th><th>Values<\/th><th>Default<\/th><th>Comment<\/th><\/tr>\n+ *     <\/thead>\n+ *     <tbody><tr>\n+ *         <th>-fx-button-order<\/th><td>&lt;integer&gt;<\/td><td>0\/1\/2<\/td>\n+ *         <td style=\"white-space: break-line\">\n+ *             Specifies the layout order of a button relative to the other buttons.\n+ *             Lower values are laid out before higher values.<\/td>\n+ *     <\/tr><\/tbody>\n+ * <\/table>\n+ *\n+ * <table style=\"white-space: nowrap\">\n+ *     <caption>Conditional style classes of window buttons<\/caption>\n+ *     <thead>\n+ *         <tr style=\"min-width: 200\"><th>Style class<\/th><th>Applies to<\/th><th>Comment<\/th><\/tr>\n+ *     <\/thead>\n+ *     <tbody>\n+ *         <tr><th>.dark<\/th>\n+ *             <td>all buttons<\/td>\n+ *             <td style=\"white-space: break-line\">\n+ *                 This style class will be present if the brightness of {@link Scene#fillProperty()}\n+ *                 as determined by {@link Utils#calculateAverageBrightness(Paint)} is less than 0.5\n+ *             <\/td>\n+ *         <\/tr>\n+ *         <tr><th>.restore<\/th><th>{@code maximize-button}<\/th><td style=\"white-space: break-line\">\n+ *             This style class will be present if {@link Stage#isMaximized()} is {@code true}<\/td>\n+ *         <\/tr>\n+ *     <\/tbody>\n+ * <\/table>\n+ *\/\n+public final class WindowControlsOverlay extends Region {\n+\n+    private static final CssMetaData<WindowControlsOverlay, HorizontalDirection> BUTTON_PLACEMENT_METADATA =\n+        new CssMetaData<>(\"-fx-button-placement\",\n+                StyleConverter.getEnumConverter(HorizontalDirection.class),\n+                HorizontalDirection.RIGHT) {\n+            @Override\n+            public boolean isSettable(WindowControlsOverlay overlay) {\n+                return true;\n+            }\n+\n+            @Override\n+            public StyleableProperty<HorizontalDirection> getStyleableProperty(WindowControlsOverlay overlay) {\n+                return overlay.buttonPlacement;\n+            }\n+        };\n+\n+    private static final CssMetaData<WindowControlsOverlay, Boolean> ALLOW_RTL_METADATA =\n+        new CssMetaData<>(\"-fx-allow-rtl\", StyleConverter.getBooleanConverter(), true) {\n+            @Override\n+            public boolean isSettable(WindowControlsOverlay overlay) {\n+                return true;\n+            }\n+\n+            @Override\n+            public StyleableProperty<Boolean> getStyleableProperty(WindowControlsOverlay overlay) {\n+                return overlay.allowRtl;\n+            }\n+        };\n+\n+    private static final List<CssMetaData<?, ?>> METADATA =\n+        Stream.concat(getClassCssMetaData().stream(),\n+        Stream.of(BUTTON_PLACEMENT_METADATA, ALLOW_RTL_METADATA)).toList();\n+\n+    private static final PseudoClass HOVER_PSEUDOCLASS = PseudoClass.getPseudoClass(\"hover\");\n+    private static final PseudoClass PRESSED_PSEUDOCLASS = PseudoClass.getPseudoClass(\"pressed\");\n+    private static final PseudoClass ACTIVE_PSEUDOCLASS = PseudoClass.getPseudoClass(\"active\");\n+    private static final String DARK_STYLE_CLASS = \"dark\";\n+    private static final String RESTORE_STYLE_CLASS = \"restore\";\n+\n+    \/**\n+     * The metrics (placement and size) of the window buttons.\n+     *\/\n+    private final ObjectProperty<WindowOverlayMetrics> metrics = new SimpleObjectProperty<>(\n+        this, \"metrics\", new WindowOverlayMetrics(HorizontalDirection.RIGHT, new Dimension2D(0, 0)));\n+\n+    \/**\n+     * Specifies the placement of the window buttons on the left or the right side of the window.\n+     * <p>\n+     * This property corresponds to the {@code -fx-button-placement} CSS property.\n+     *\/\n+    private final StyleableObjectProperty<HorizontalDirection> buttonPlacement =\n+        new SimpleStyleableObjectProperty<>(\n+                BUTTON_PLACEMENT_METADATA, this, \"buttonPlacement\", HorizontalDirection.RIGHT) {\n+            @Override\n+            protected void invalidated() {\n+                requestLayout();\n+            }\n+        };\n+\n+    \/**\n+     * Specifies whether the minimize\/maximize\/close buttons support right-to-left orientations.\n+     * <p>\n+     * If this property is {@code true} and the effective node orientation is right-to-left, the\n+     * window buttons are mirrored to the other side of the window.\n+     * <p>\n+     * This property corresponds to the {@code -fx-allow-rtl} CSS property.\n+     *\/\n+    private final StyleableBooleanProperty allowRtl =\n+        new SimpleStyleableBooleanProperty(ALLOW_RTL_METADATA, this, \"allowRtl\", true) {\n+            @Override\n+            protected void invalidated() {\n+                requestLayout();\n+            }\n+        };\n+\n+    \/**\n+     * Contains the buttons in the order as they will appear on the window.\n+     * This list is automatically updated by the implementation of {@link ButtonRegion#buttonOrder}.\n+     *\/\n+    private final List<ButtonRegion> orderedButtons = new ArrayList<>(3);\n+    private final ButtonRegion minimizeButton = new ButtonRegion(ButtonType.MINIMIZE, \"minimize-button\", 0);\n+    private final ButtonRegion maximizeButton = new ButtonRegion(ButtonType.MAXIMIZE, \"maximize-button\", 1);\n+    private final ButtonRegion closeButton = new ButtonRegion(ButtonType.CLOSE, \"close-button\", 2);\n+    private final Subscription subscriptions;\n+\n+    private Node buttonAtMouseDown;\n+\n+    public WindowControlsOverlay(ObservableValue<String> stylesheet) {\n+        var stage = sceneProperty()\n+            .flatMap(Scene::windowProperty)\n+            .map(w -> w instanceof Stage ? (Stage)w : null);\n+\n+        var focusedSubscription = stage\n+            .flatMap(Stage::focusedProperty)\n+            .orElse(true)\n+            .subscribe(this::onFocusedChanged);\n+\n+        var resizableSubscription = stage\n+            .flatMap(Stage::resizableProperty)\n+            .orElse(true)\n+            .subscribe(this::onResizableChanged);\n+\n+        var maximizedSubscription = stage\n+            .flatMap(Stage::maximizedProperty)\n+            .orElse(false)\n+            .subscribe(this::onMaximizedChanged);\n+\n+        var updateStylesheetSubscription = sceneProperty()\n+            .flatMap(Scene::fillProperty)\n+            .map(this::isDarkBackground)\n+            .orElse(false)\n+            .subscribe(x -> updateStyleClass()); \/\/ use a value subscriber, not an invalidation subscriber\n+\n+        subscriptions = Subscription.combine(\n+            focusedSubscription,\n+            resizableSubscription,\n+            maximizedSubscription,\n+            updateStylesheetSubscription,\n+            stylesheet.subscribe(this::updateStylesheet));\n+\n+        getStyleClass().setAll(\"window-button-container\");\n+        getChildren().addAll(minimizeButton, maximizeButton, closeButton);\n+    }\n+\n+    public void dispose() {\n+        subscriptions.unsubscribe();\n+    }\n+\n+    public ReadOnlyObjectProperty<WindowOverlayMetrics> metricsProperty() {\n+        return metrics;\n+    }\n+\n+    \/**\n+     * Classifies and returns the button type at the specified coordinate, or returns\n+     * {@code null} if the specified coordinate does not intersect a button.\n+     *\n+     * @param x the X coordinate, in pixels relative to the window\n+     * @param y the Y coordinate, in pixels relative to the window\n+     * @return the {@code ButtonType} or {@code null}\n+     *\/\n+    public ButtonType buttonAt(double x, double y) {\n+        for (var button : orderedButtons) {\n+            if (button.isVisible() && button.getBoundsInParent().contains(x, y)) {\n+                return button.getButtonType();\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * Handles the specified mouse event.\n+     *\n+     * @param type the event type\n+     * @param button the button type\n+     * @param x the X coordinate, in pixels relative to the window\n+     * @param y the Y coordinate, in pixels relative to the window\n+     * @return {@code true} if the event was handled, {@code false} otherwise\n+     *\/\n+    public boolean handleMouseEvent(int type, int button, double x, double y) {\n+        ButtonType buttonType = buttonAt(x, y);\n+        Node node = buttonType != null ? switch (buttonType) {\n+            case MINIMIZE -> minimizeButton;\n+            case MAXIMIZE -> maximizeButton;\n+            case CLOSE -> closeButton;\n+        } : null;\n+\n+        if (type == MouseEvent.NC_ENTER || type == MouseEvent.NC_MOVE || type == MouseEvent.NC_DRAG) {\n+            handleMouseOver(node);\n+        } else if (type == MouseEvent.NC_EXIT) {\n+            handleMouseExit();\n+        } else if (type == MouseEvent.NC_UP && button == MouseEvent.BUTTON_LEFT) {\n+            handleMouseUp(node, buttonType);\n+        } else if (node != null && type == MouseEvent.NC_DOWN && button == MouseEvent.BUTTON_LEFT) {\n+            handleMouseDown(node);\n+        }\n+\n+        return node != null || buttonAtMouseDown != null;\n+    }\n+\n+    private void handleMouseOver(Node button) {\n+        minimizeButton.pseudoClassStateChanged(HOVER_PSEUDOCLASS, button == minimizeButton);\n+        maximizeButton.pseudoClassStateChanged(HOVER_PSEUDOCLASS, button == maximizeButton);\n+        closeButton.pseudoClassStateChanged(HOVER_PSEUDOCLASS, button == closeButton);\n+\n+        if (buttonAtMouseDown != null && buttonAtMouseDown != button) {\n+            buttonAtMouseDown.pseudoClassStateChanged(PRESSED_PSEUDOCLASS, false);\n+        }\n+    }\n+\n+    private void handleMouseExit() {\n+        buttonAtMouseDown = null;\n+\n+        for (var node : new Node[] {minimizeButton, maximizeButton, closeButton}) {\n+            node.pseudoClassStateChanged(HOVER_PSEUDOCLASS, false);\n+            node.pseudoClassStateChanged(PRESSED_PSEUDOCLASS, false);\n+        }\n+    }\n+\n+    private void handleMouseDown(Node node) {\n+        buttonAtMouseDown = node;\n+\n+        if (!node.isDisabled()) {\n+            node.pseudoClassStateChanged(PRESSED_PSEUDOCLASS, true);\n+        }\n+    }\n+\n+    private void handleMouseUp(Node node, ButtonType buttonType) {\n+        boolean releasedOnButton = buttonAtMouseDown == node;\n+        buttonAtMouseDown = null;\n+        Scene scene = getScene();\n+\n+        if (node == null || node.isDisabled()\n+                || scene == null || !(scene.getWindow() instanceof Stage stage)) {\n+            return;\n+        }\n+\n+        node.pseudoClassStateChanged(PRESSED_PSEUDOCLASS, false);\n+\n+        if (releasedOnButton) {\n+            switch (buttonType) {\n+                case MINIMIZE -> stage.setIconified(true);\n+                case MAXIMIZE -> stage.setMaximized(!stage.isMaximized());\n+                case CLOSE -> stage.close();\n+            }\n+        }\n+    }\n+\n+    private void onFocusedChanged(boolean focused) {\n+        for (var node : new Node[] {minimizeButton, maximizeButton, closeButton}) {\n+            node.pseudoClassStateChanged(ACTIVE_PSEUDOCLASS, focused);\n+        }\n+    }\n+\n+    private void onResizableChanged(boolean resizable) {\n+        maximizeButton.setDisable(!resizable);\n+    }\n+\n+    private void onMaximizedChanged(boolean maximized) {\n+        toggleStyleClass(maximizeButton, RESTORE_STYLE_CLASS, maximized);\n+    }\n+\n+    private void updateStyleClass() {\n+        boolean darkScene = isDarkBackground(getScene() != null ? getScene().getFill() : null);\n+        toggleStyleClass(minimizeButton, DARK_STYLE_CLASS, darkScene);\n+        toggleStyleClass(maximizeButton, DARK_STYLE_CLASS, darkScene);\n+        toggleStyleClass(closeButton, DARK_STYLE_CLASS, darkScene);\n+    }\n+\n+    private void updateStylesheet(String stylesheet) {\n+        getStylesheets().setAll(stylesheet);\n+    }\n+\n+    private void toggleStyleClass(Node node, String styleClass, boolean enabled) {\n+        if (enabled && !node.getStyleClass().contains(styleClass)) {\n+            node.getStyleClass().add(styleClass);\n+        } else if (!enabled) {\n+            node.getStyleClass().remove(styleClass);\n+        }\n+    }\n+\n+    private boolean isDarkBackground(Paint paint) {\n+        return paint != null && Utils.calculateAverageBrightness(paint) < 0.5;\n+    }\n+\n+    @Override\n+    protected void layoutChildren() {\n+        boolean left;\n+        Node button1, button2, button3;\n+\n+        if (allowRtl.get() && getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {\n+            button1 = orderedButtons.get(2);\n+            button2 = orderedButtons.get(1);\n+            button3 = orderedButtons.get(0);\n+            left = buttonPlacement.get() != HorizontalDirection.LEFT;\n+        } else {\n+            button1 = orderedButtons.get(0);\n+            button2 = orderedButtons.get(1);\n+            button3 = orderedButtons.get(2);\n+            left = buttonPlacement.get() == HorizontalDirection.LEFT;\n+        }\n+\n+        double width = getWidth();\n+        double button1Width = boundedWidth(button1);\n+        double button2Width = boundedWidth(button2);\n+        double button3Width = boundedWidth(button3);\n+        double button1Height = boundedHeight(button1);\n+        double button2Height = boundedHeight(button2);\n+        double button3Height = boundedHeight(button3);\n+        double button1X = left ? 0 : width - button1Width - button2Width - button3Width;\n+        double button2X = left ? button1Width : width - button3Width - button2Width;\n+        double button3X = left ? button1Width + button2Width : width - button3Width;\n+        double totalWidth = button1Width + button2Width + button3Width;\n+        double totalHeight = Math.max(button1Height, Math.max(button2Height, button3Height));\n+        Dimension2D currentSize = metrics.get().size();\n+\n+        if (currentSize.getWidth() != totalWidth || currentSize.getHeight() != totalHeight) {\n+            var newMetrics = new WindowOverlayMetrics(\n+                left ? HorizontalDirection.LEFT : HorizontalDirection.RIGHT,\n+                new Dimension2D(totalWidth, totalHeight));\n+\n+            \/\/ Don't change the metrics during layout, since we don't know who might be listening.\n+            Platform.runLater(() -> metrics.set(newMetrics));\n+        }\n+\n+        layoutInArea(button1, button1X, 0, button1Width, button1Height,\n+                     BASELINE_OFFSET_SAME_AS_HEIGHT, HPos.LEFT, VPos.TOP);\n+\n+        layoutInArea(button2, button2X, 0, button2Width, button2Height,\n+                     BASELINE_OFFSET_SAME_AS_HEIGHT, HPos.LEFT, VPos.TOP);\n+\n+        layoutInArea(button3, button3X, 0, button3Width, button3Height,\n+                     BASELINE_OFFSET_SAME_AS_HEIGHT, HPos.LEFT, VPos.TOP);\n+    }\n+\n+    @Override\n+    public boolean usesMirroring() {\n+        return false;\n+    }\n+\n+    @Override\n+    public List<CssMetaData<? extends Styleable, ?>> getCssMetaData() {\n+        return METADATA;\n+    }\n+\n+    private static double boundedWidth(Node node) {\n+        return node.isManaged() ? boundedSize(node.minWidth(-1), node.prefWidth(-1), node.maxWidth(-1)) : 0;\n+    }\n+\n+    private static double boundedHeight(Node node) {\n+        return node.isManaged() ? boundedSize(node.minHeight(-1), node.prefHeight(-1), node.maxHeight(-1)) : 0;\n+    }\n+\n+    private static double boundedSize(double min, double pref, double max) {\n+        return Math.min(Math.max(pref, min), Math.max(min, max));\n+    }\n+\n+    public enum ButtonType {\n+        MINIMIZE,\n+        MAXIMIZE,\n+        CLOSE\n+    }\n+\n+    private class ButtonRegion extends Region {\n+\n+        private static final CssMetaData<ButtonRegion, Number> BUTTON_ORDER_METADATA =\n+            new CssMetaData<>(\"-fx-button-order\", StyleConverter.getSizeConverter()) {\n+                @Override\n+                public boolean isSettable(ButtonRegion node) {\n+                    return true;\n+                }\n+\n+                @Override\n+                public StyleableProperty<Number> getStyleableProperty(ButtonRegion region) {\n+                    return region.buttonOrder;\n+                }\n+            };\n+\n+        private static final List<CssMetaData<?, ?>> METADATA =\n+            Stream.concat(getClassCssMetaData().stream(), Stream.of(BUTTON_ORDER_METADATA)).toList();\n+\n+        \/**\n+         * Specifies the layout order of this button relative to the other buttons.\n+         * Buttons with a lower value are laid out before buttons with a higher value.\n+         * <p>\n+         * This property corresponds to the {@code -fx-button-order} CSS property.\n+         *\/\n+        private final StyleableIntegerProperty buttonOrder =\n+            new SimpleStyleableIntegerProperty(BUTTON_ORDER_METADATA, this, \"buttonOrder\") {\n+                @Override\n+                protected void invalidated() {\n+                    requestParentLayout();\n+\n+                    WindowControlsOverlay.this.orderedButtons.sort(\n+                        Comparator.comparing(ButtonRegion::getButtonOrder));\n+                }\n+            };\n+\n+        private final Region glyph = new Region();\n+        private final ButtonType type;\n+\n+        ButtonRegion(ButtonType type, String styleClass, int order) {\n+            this.type = type;\n+            orderedButtons.add(this);\n+            buttonOrder.set(order);\n+            glyph.getStyleClass().setAll(\"glyph\");\n+            getChildren().add(glyph);\n+            getStyleClass().setAll(\"window-button\", styleClass);\n+        }\n+\n+        public ButtonType getButtonType() {\n+            return type;\n+        }\n+\n+        public int getButtonOrder() {\n+            return buttonOrder.get();\n+        }\n+\n+        @Override\n+        protected void layoutChildren() {\n+            layoutInArea(glyph, 0, 0, getWidth(), getHeight(), 0, HPos.LEFT, VPos.TOP);\n+        }\n+\n+        @Override\n+        public List<CssMetaData<? extends Styleable, ?>> getCssMetaData() {\n+            return METADATA;\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/WindowControlsOverlay.java","additions":540,"deletions":0,"binary":false,"changes":540,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui;\n+\n+import javafx.geometry.Dimension2D;\n+import javafx.geometry.HorizontalDirection;\n+import javafx.stage.StageStyle;\n+import java.util.Objects;\n+\n+\/**\n+ * Provides metrics about the window buttons of {@link StageStyle#EXTENDED} windows.\n+ *\n+ * @param placement the placement of the window buttons\n+ * @param size the size of the window buttons\n+ *\/\n+public record WindowOverlayMetrics(HorizontalDirection placement, Dimension2D size) {\n+\n+    public WindowOverlayMetrics {\n+        Objects.requireNonNull(placement, \"placement cannot be null\");\n+        Objects.requireNonNull(size, \"size cannot be null\");\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/WindowOverlayMetrics.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -466,0 +466,5 @@\n+    @Override\n+    protected boolean _supportsExtendedWindows() {\n+        return true;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkApplication.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.glass.events.MouseEvent;\n@@ -29,0 +30,1 @@\n+import com.sun.glass.ui.NonClientHandler;\n@@ -33,0 +35,3 @@\n+import com.sun.glass.ui.WindowControlsOverlay;\n+import com.sun.glass.ui.WindowOverlayMetrics;\n+import javafx.beans.value.ObservableValue;\n@@ -201,0 +206,63 @@\n+\n+    private WindowControlsOverlay windowControlsOverlay;\n+\n+    @Override\n+    public ObservableValue<WindowOverlayMetrics> windowOverlayMetrics() {\n+        var overlay = getWindowOverlay();\n+        return overlay != null ? overlay.metricsProperty() : null;\n+    }\n+\n+    @Override\n+    public WindowControlsOverlay getWindowOverlay() {\n+        if (windowControlsOverlay == null && isExtendedWindow()) {\n+            windowControlsOverlay = new WindowControlsOverlay(\n+                PlatformThemeObserver.getInstance().stylesheetProperty());\n+        }\n+\n+        return windowControlsOverlay;\n+    }\n+\n+    @Override\n+    public NonClientHandler getNonClientHandler() {\n+        var overlay = getWindowOverlay();\n+        if (overlay == null) {\n+            return null;\n+        }\n+\n+        return (type, button, x, y, xAbs, yAbs, clickCount) -> {\n+            \/\/ In contrast to Windows, GTK doesn't produce non-client events. We convert regular\n+            \/\/ mouse events to non-client events since that's what WindowControlsOverlay expects.\n+            return overlay.handleMouseEvent(\n+                MouseEvent.toNonClientEvent(type), button, x \/ platformScaleX, y \/ platformScaleY);\n+        };\n+    }\n+\n+    \/**\n+     * Returns whether the window is draggable at the specified coordinate.\n+     * <p>\n+     * This method is called from native code.\n+     *\n+     * @param x the X coordinate in physical pixels\n+     * @param y the Y coordinate in physical pixels\n+     *\/\n+    @SuppressWarnings(\"unused\")\n+    private boolean dragAreaHitTest(int x, int y) {\n+        \/\/ A full-screen window has no draggable area.\n+        if (view == null || view.isInFullscreen() || !isExtendedWindow()) {\n+            return false;\n+        }\n+\n+        double wx = x \/ platformScaleX;\n+        double wy = y \/ platformScaleY;\n+\n+        if (windowControlsOverlay != null && windowControlsOverlay.buttonAt(wx, wy) != null) {\n+            return false;\n+        }\n+\n+        View.EventHandler eventHandler = view.getEventHandler();\n+        if (eventHandler == null) {\n+            return false;\n+        }\n+\n+        return eventHandler.pickDragAreaNode(wx, wy) != null;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkWindow.java","additions":69,"deletions":1,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui.gtk;\n+\n+import com.sun.javafx.application.PlatformImpl;\n+import javafx.beans.property.ReadOnlyStringProperty;\n+import javafx.beans.property.ReadOnlyStringWrapper;\n+import javafx.collections.MapChangeListener;\n+\n+final class PlatformThemeObserver {\n+\n+    private static final String THEME_NAME_KEY = \"GTK.theme_name\";\n+\n+    private final ReadOnlyStringWrapper stylesheet = new ReadOnlyStringWrapper(this, \"stylesheet\");\n+\n+    private PlatformThemeObserver() {\n+        PlatformImpl.getPlatformPreferences().addListener((MapChangeListener<String, Object>) change -> {\n+            if (THEME_NAME_KEY.equals(change.getKey())) {\n+                updateThemeStylesheets();\n+            }\n+        });\n+\n+        updateThemeStylesheets();\n+    }\n+\n+    public static PlatformThemeObserver getInstance() {\n+        class Holder {\n+            static final PlatformThemeObserver instance = new PlatformThemeObserver();\n+        }\n+\n+        return Holder.instance;\n+    }\n+\n+    public ReadOnlyStringProperty stylesheetProperty() {\n+        return stylesheet.getReadOnlyProperty();\n+    }\n+\n+    private void updateThemeStylesheets() {\n+        stylesheet.set(WindowDecorationTheme.findBestTheme().getStylesheet());\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/PlatformThemeObserver.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui.gtk;\n+\n+import com.sun.javafx.application.PlatformImpl;\n+import javafx.stage.StageStyle;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+\/**\n+ * The client-side window decoration theme used for {@link StageStyle#EXTENDED} windows.\n+ *\/\n+enum WindowDecorationTheme {\n+\n+    GNOME(\"WindowDecorationGnome.css\"),\n+    KDE(\"WindowDecorationKDE.css\");\n+\n+    WindowDecorationTheme(String stylesheet) {\n+        this.stylesheet = stylesheet;\n+    }\n+\n+    private static final String THEME_NAME_KEY = \"GTK.theme_name\";\n+\n+    \/**\n+     * A mapping of platform theme names to the most similar window decoration theme.\n+     *\/\n+    private static final Map<String, WindowDecorationTheme> SIMILAR_THEMES = Map.of(\n+        \"adwaita\", WindowDecorationTheme.GNOME,\n+        \"yaru\", WindowDecorationTheme.GNOME,\n+        \"breeze\", WindowDecorationTheme.KDE\n+    );\n+\n+    private final String stylesheet;\n+\n+    \/**\n+     * Determines the best window decoration theme for the current window manager theme.\n+     * <p>\n+     * Since we can't ship decorations for all possible window manager themes, we need to choose the\n+     * theme most similar to the native window manager theme. If we can't choose a theme by name, we\n+     * fall back to choosing a theme by determining the current window manager.\n+     *\/\n+    public static WindowDecorationTheme findBestTheme() {\n+        return PlatformImpl.getPlatformPreferences()\n+            .getString(THEME_NAME_KEY)\n+            .map(name -> {\n+                for (Map.Entry<String, WindowDecorationTheme> entry : SIMILAR_THEMES.entrySet()) {\n+                    if (name.toLowerCase(Locale.ROOT).startsWith(entry.getKey())) {\n+                        return entry.getValue();\n+                    }\n+                }\n+\n+                return null;\n+            })\n+            .orElse(switch (WindowManager.current()) {\n+                case GNOME -> WindowDecorationTheme.GNOME;\n+                case KDE -> WindowDecorationTheme.KDE;\n+                default -> WindowDecorationTheme.GNOME;\n+            });\n+    }\n+\n+    public String getStylesheet() {\n+        var url = getClass().getResource(stylesheet);\n+        if (url == null) {\n+            throw new RuntimeException(\"Resource not found: \" + stylesheet);\n+        }\n+\n+        return url.toExternalForm();\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/WindowDecorationTheme.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui.gtk;\n+\n+import java.util.Locale;\n+\n+\/**\n+ * The window manager of the current desktop environment.\n+ *\/\n+enum WindowManager {\n+    UNKNOWN,\n+    GNOME,\n+    KDE;\n+\n+    \/**\n+     * Returns the window manager of the current desktop environment.\n+     *\/\n+    public static WindowManager current() {\n+        var result = parse(System.getenv(\"XDG_CURRENT_DESKTOP\"));\n+        if (result != UNKNOWN) {\n+            return result;\n+        }\n+\n+        result = parse(System.getenv(\"GDMSESSION\"));\n+        if (result != UNKNOWN) {\n+            return result;\n+        }\n+\n+        if (System.getenv(\"KDE_FULL_SESSION\") != null) {\n+            return KDE;\n+        }\n+\n+        return UNKNOWN;\n+    }\n+\n+    private static WindowManager parse(String value) {\n+        if (value == null) {\n+            return UNKNOWN;\n+        }\n+\n+        String v = value.toLowerCase(Locale.ROOT);\n+\n+        if (v.contains(\"gnome\")) {\n+            return GNOME;\n+        }\n+\n+        if (v.contains(\"kde\")) {\n+            return KDE;\n+        }\n+\n+        return UNKNOWN;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/WindowManager.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -231,0 +231,5 @@\n+    @Override\n+    protected boolean _supportsExtendedWindows() {\n+        return false;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/ios\/IosApplication.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -411,0 +411,5 @@\n+    @Override\n+    protected boolean _supportsExtendedWindows() {\n+        return true;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/mac\/MacApplication.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.glass.events.MouseEvent;\n@@ -29,0 +30,1 @@\n+import com.sun.glass.ui.NonClientHandler;\n@@ -33,0 +35,5 @@\n+import com.sun.glass.ui.WindowOverlayMetrics;\n+import com.sun.javafx.binding.ObjectConstant;\n+import javafx.beans.value.ObservableValue;\n+import javafx.geometry.Dimension2D;\n+import javafx.geometry.HorizontalDirection;\n@@ -153,0 +160,41 @@\n+\n+    private native void _performWindowDrag(long ptr);\n+\n+    @Override\n+    public NonClientHandler getNonClientHandler() {\n+        return (type, button, x, y, xAbs, yAbs, clickCount) -> {\n+            if (type == MouseEvent.DOWN) {\n+                double wx = x \/ platformScaleX;\n+                double wy = y \/ platformScaleY;\n+\n+                View.EventHandler eventHandler = view != null ? view.getEventHandler() : null;\n+                if (eventHandler != null && eventHandler.pickDragAreaNode(wx, wy) != null) {\n+                    if (clickCount == 2) {\n+                        maximize(!isMaximized());\n+                    } else if (clickCount == 1) {\n+                        _performWindowDrag(getRawHandle());\n+                    }\n+                }\n+            }\n+\n+            return false;\n+        };\n+    }\n+\n+    private native boolean _isRightToLeftLayoutDirection();\n+\n+    private ObservableValue<WindowOverlayMetrics> windowOverlayMetrics;\n+\n+    @Override\n+    public ObservableValue<WindowOverlayMetrics> windowOverlayMetrics() {\n+        if (windowOverlayMetrics == null) {\n+            HorizontalDirection direction = _isRightToLeftLayoutDirection()\n+                ? HorizontalDirection.RIGHT\n+                : HorizontalDirection.LEFT;\n+\n+            windowOverlayMetrics = ObjectConstant.valueOf(\n+                new WindowOverlayMetrics(direction, new Dimension2D(78, 38)));\n+        }\n+\n+        return windowOverlayMetrics;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/mac\/MacWindow.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -309,0 +309,5 @@\n+    @Override\n+    protected boolean _supportsExtendedWindows() {\n+        return false;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/monocle\/MonocleApplication.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -356,0 +356,5 @@\n+    @Override\n+    protected boolean _supportsExtendedWindows() {\n+        return true;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinApplication.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,0 +98,22 @@\n+\n+    @Override\n+    protected void notifyMenu(int x, int y, int xAbs, int yAbs, boolean isKeyboardTrigger) {\n+        \/\/ If all of the following conditions are satisfied, we open a system menu at the specified coordinates:\n+        \/\/ 1. The application didn't consume the menu event.\n+        \/\/ 2. The window is an EXTENDED window.\n+        \/\/ 3. The menu event occurred on a draggable area.\n+        if (!handleMenuEvent(x, y, xAbs, yAbs, isKeyboardTrigger)) {\n+            var window = (WinWindow)getWindow();\n+            if (!window.isExtendedWindow()) {\n+                return;\n+            }\n+\n+            double wx = x \/ window.getPlatformScaleX();\n+            double wy = y \/ window.getPlatformScaleY();\n+\n+            EventHandler eventHandler = getEventHandler();\n+            if (eventHandler != null && eventHandler.pickDragAreaNode(wx, wy) != null) {\n+                window.showSystemMenu(x, y);\n+            }\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinView.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.glass.ui.WindowControlsOverlay;\n+import com.sun.glass.ui.NonClientHandler;\n@@ -32,0 +34,3 @@\n+import com.sun.glass.ui.WindowOverlayMetrics;\n+import com.sun.javafx.binding.StringConstant;\n+import javafx.beans.value.ObservableValue;\n@@ -43,4 +48,6 @@\n-    float fxReqWidth;\n-    float fxReqHeight;\n-    int pfReqWidth;\n-    int pfReqHeight;\n+    private static final String WINDOW_DECORATION_STYLESHEET = \"WindowDecoration.css\";\n+\n+    private float fxReqWidth;\n+    private float fxReqHeight;\n+    private int pfReqWidth;\n+    private int pfReqHeight;\n@@ -118,0 +125,4 @@\n+            int maxW = getMaximumWidth(), maxH = getMaximumHeight();\n+            pw = Math.max(Math.min(pw, maxW > 0 ? maxW : Integer.MAX_VALUE), getMinimumWidth());\n+            ph = Math.max(Math.min(ph, maxH > 0 ? maxH : Integer.MAX_VALUE), getMinimumHeight());\n+\n@@ -260,0 +271,1 @@\n+    native private void _showSystemMenu(long ptr, int x, int y);\n@@ -318,0 +330,4 @@\n+            if (windowControlsOverlay != null) {\n+                windowControlsOverlay.dispose();\n+            }\n+\n@@ -324,0 +340,91 @@\n+\n+    private WindowControlsOverlay windowControlsOverlay;\n+\n+    @Override\n+    public ObservableValue<WindowOverlayMetrics> windowOverlayMetrics() {\n+        var overlay = getWindowOverlay();\n+        return overlay != null ? overlay.metricsProperty() : null;\n+    }\n+\n+    @Override\n+    public WindowControlsOverlay getWindowOverlay() {\n+        if (windowControlsOverlay == null && isExtendedWindow()) {\n+            var url = getClass().getResource(WINDOW_DECORATION_STYLESHEET);\n+            if (url == null) {\n+                throw new RuntimeException(\"Resource not found: \" + WINDOW_DECORATION_STYLESHEET);\n+            }\n+\n+            windowControlsOverlay = new WindowControlsOverlay(StringConstant.valueOf(url.toExternalForm()));\n+        }\n+\n+        return windowControlsOverlay;\n+    }\n+\n+    @Override\n+    public NonClientHandler getNonClientHandler() {\n+        var overlay = getWindowOverlay();\n+        if (overlay == null) {\n+            return null;\n+        }\n+\n+        return (type, button, x, y, xAbs, yAbs, clickCount) -> {\n+            double wx = x \/ platformScaleX;\n+            double wy = y \/ platformScaleY;\n+\n+            \/\/ Give the window button overlay the first chance to handle the event.\n+            return overlay.handleMouseEvent(type, button, wx, wy);\n+        };\n+    }\n+\n+    \/**\n+     * Opens a system menu at the specified coordinates.\n+     *\n+     * @param x the X coordinate in physical pixels\n+     * @param y the Y coordinate in physical pixels\n+     *\/\n+    public void showSystemMenu(int x, int y) {\n+        _showSystemMenu(getRawHandle(), x, y);\n+    }\n+\n+    \/**\n+     * Classifies the window region at the specified physical coordinate.\n+     * <p>\n+     * This method is called from native code.\n+     *\n+     * @param x the X coordinate in physical pixels\n+     * @param y the Y coordinate in physical pixels\n+     *\/\n+    @SuppressWarnings(\"unused\")\n+    private int nonClientHitTest(int x, int y) {\n+        \/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/inputdev\/wm-nchittest\n+        enum HT {\n+            CLIENT(1), CAPTION(2), MINBUTTON(8), MAXBUTTON(9), CLOSE(20);\n+            HT(int value) { this.value = value; }\n+            final int value;\n+        }\n+\n+        \/\/ A full-screen window has no non-client area.\n+        if (view == null || view.isInFullscreen() || !isExtendedWindow()) {\n+            return HT.CLIENT.value;\n+        }\n+\n+        double wx = x \/ platformScaleX;\n+        double wy = y \/ platformScaleY;\n+\n+        \/\/ If the cursor is over one of the window buttons (minimize, maximize, close), we need to\n+        \/\/ report the value of HTMINBUTTON, HTMAXBUTTON, or HTCLOSE back to the native layer.\n+        switch (windowControlsOverlay != null ? windowControlsOverlay.buttonAt(wx, wy) : null) {\n+            case MINIMIZE: return HT.MINBUTTON.value;\n+            case MAXIMIZE: return HT.MAXBUTTON.value;\n+            case CLOSE: return HT.CLOSE.value;\n+            case null: break;\n+        }\n+\n+        \/\/ Otherwise, test if the cursor is over a draggable area and return HTCAPTION.\n+        View.EventHandler eventHandler = view.getEventHandler();\n+        if (eventHandler != null && eventHandler.pickDragAreaNode(wx, wy) != null) {\n+            return HT.CAPTION.value;\n+        }\n+\n+        return HT.CLIENT.value;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinWindow.java","additions":112,"deletions":5,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import javafx.scene.Scene;\n@@ -211,0 +212,8 @@\n+    public static void setScenes(Node node, Scene newScene, SubScene newSubScene) {\n+        nodeAccessor.setScenes(node, newScene, newSubScene);\n+    }\n+\n+    public static void updateBounds(Node node) {\n+        nodeAccessor.updateBounds(node);\n+    }\n+\n@@ -375,0 +384,2 @@\n+        void setScenes(Node node, Scene newScene, SubScene newSubScene);\n+        void updateBounds(Node node);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/NodeHelper.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,0 +92,6 @@\n+\n+    default void processOverlayCSS() {}\n+\n+    default void layoutOverlay() {}\n+\n+    default void synchronizeOverlay() {}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/TKScene.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import javafx.scene.Node;\n@@ -87,1 +88,1 @@\n-    public void menuEvent(double x, double y, double xAbs, double yAbs,\n+    public boolean menuEvent(double x, double y, double xAbs, double yAbs,\n@@ -123,0 +124,10 @@\n+\n+    \/**\n+     * Returns the draggable area node at the specified coordinates, or {@code null}\n+     * if the specified coordinates do not intersect with a draggable area.\n+     *\n+     * @param x the X coordinate relative to the scene\n+     * @param y the Y coordinate relative to the scene\n+     * @return the draggable area node, or {@code null}\n+     *\/\n+    public Node pickDragAreaNode(double x, double y);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/TKSceneListener.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import javafx.scene.Node;\n@@ -458,3 +459,3 @@\n-    @Override public void handleMenuEvent(final View view,\n-                                          final int x, final int y, final int xAbs, final int yAbs,\n-                                          final boolean isKeyboardTrigger)\n+    @Override public boolean handleMenuEvent(final View view,\n+                                             final int x, final int y, final int xAbs, final int yAbs,\n+                                             final boolean isKeyboardTrigger)\n@@ -470,17 +471,17 @@\n-            QuantumToolkit.runWithoutRenderLock(() -> {\n-                return AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-                    if (scene.sceneListener != null) {\n-                        double pScaleX, pScaleY, spx, spy, sx, sy;\n-                        final Window w = view.getWindow();\n-                        if (w != null) {\n-                            pScaleX = w.getPlatformScaleX();\n-                            pScaleY = w.getPlatformScaleY();\n-                            Screen scr = w.getScreen();\n-                            if (scr != null) {\n-                                spx = scr.getPlatformX();\n-                                spy = scr.getPlatformY();\n-                                sx = scr.getX();\n-                                sy = scr.getY();\n-                            } else {\n-                                spx = spy = sx = sy = 0.0;\n-                            }\n+            return QuantumToolkit.runWithoutRenderLock(() -> {\n+                return AccessController.doPrivileged((PrivilegedAction<Boolean>) () -> {\n+                    if (scene.sceneListener == null) {\n+                        return false;\n+                    }\n+\n+                    double pScaleX, pScaleY, spx, spy, sx, sy;\n+                    final Window w = view.getWindow();\n+                    if (w != null) {\n+                        pScaleX = w.getPlatformScaleX();\n+                        pScaleY = w.getPlatformScaleY();\n+                        Screen scr = w.getScreen();\n+                        if (scr != null) {\n+                            spx = scr.getPlatformX();\n+                            spy = scr.getPlatformY();\n+                            sx = scr.getX();\n+                            sy = scr.getY();\n@@ -488,1 +489,0 @@\n-                            pScaleX = pScaleY = 1.0;\n@@ -491,4 +491,3 @@\n-                        scene.sceneListener.menuEvent(x \/ pScaleX, y \/ pScaleY,\n-                                                      sx + (xAbs - spx) \/ pScaleX,\n-                                                      sy + (yAbs - spy) \/ pScaleY,\n-                                                      isKeyboardTrigger);\n+                    } else {\n+                        pScaleX = pScaleY = 1.0;\n+                        spx = spy = sx = sy = 0.0;\n@@ -496,1 +495,5 @@\n-                    return null;\n+\n+                    return scene.sceneListener.menuEvent(x \/ pScaleX, y \/ pScaleY,\n+                                                         sx + (xAbs - spx) \/ pScaleX,\n+                                                         sy + (yAbs - spy) \/ pScaleY,\n+                                                         isKeyboardTrigger);\n@@ -895,2 +898,1 @@\n-                    scene.sceneListener.changedSize(view.getWidth()  \/ pScaleX,\n-                                                    view.getHeight() \/ pScaleY);\n+                    scene.setViewSize(view.getWidth() \/ pScaleX, view.getHeight() \/ pScaleY);\n@@ -1410,0 +1412,11 @@\n+\n+    @Override\n+    public Node pickDragAreaNode(double x, double y) {\n+        return QuantumToolkit.runWithoutRenderLock(() -> {\n+            if (scene.sceneListener != null) {\n+                return scene.sceneListener.pickDragAreaNode(x, y);\n+            }\n+\n+            return null;\n+        });\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/GlassViewEventHandler.java","additions":41,"deletions":28,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import com.sun.javafx.scene.DirtyBits;\n-import com.sun.javafx.scene.NodeHelper;\n@@ -36,1 +34,0 @@\n-import javafx.scene.Node;\n@@ -45,16 +42,0 @@\n-    static {\n-        \/\/ This is used by classes in different packages to get access to\n-        \/\/ private and package private methods.\n-        OverlayWarningHelper.setOverlayWarningAccessor(\n-                new OverlayWarningHelper.OverlayWarningAccessor() {\n-            @Override\n-            public void doUpdatePeer(Node node) {\n-                ((OverlayWarning) node).doUpdatePeer();\n-            }\n-\n-            @Override\n-            public void doMarkDirty(Node node, DirtyBits dirtyBit) {\n-                ((OverlayWarning) node).doMarkDirty(dirtyBit);\n-            }\n-        });\n-    }\n@@ -72,5 +53,0 @@\n-    {\n-        \/\/ To initialize the class helper at the begining each constructor of this class\n-        OverlayWarningHelper.initHelper(this);\n-    }\n-\n@@ -173,20 +149,0 @@\n-\n-    \/*\n-     * Note: This method MUST only be called via its accessor method.\n-     *\/\n-    private void doUpdatePeer() {\n-        NodeHelper.updatePeer(text);\n-        NodeHelper.updatePeer(background);\n-    }\n-\n-    @Override\n-    protected void updateBounds() {\n-        super.updateBounds();\n-    }\n-\n-    \/*\n-     * Note: This method MUST only be called via its accessor method.\n-     *\/\n-    private void doMarkDirty(DirtyBits dirtyBit) {\n-        view.synchroniseOverlayWarning();\n-    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/OverlayWarning.java","additions":1,"deletions":45,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.tk.quantum;\n-\n-import com.sun.javafx.scene.DirtyBits;\n-import com.sun.javafx.scene.GroupHelper;\n-import com.sun.javafx.util.Utils;\n-import javafx.scene.Node;\n-\n-\/**\n- * Used to access internal methods of OverlayWarning.\n- *\/\n-public class OverlayWarningHelper extends GroupHelper {\n-\n-    private static final OverlayWarningHelper theInstance;\n-    private static OverlayWarningAccessor overlayWarningAccessor;\n-\n-    static {\n-        theInstance = new OverlayWarningHelper();\n-        Utils.forceInit(OverlayWarning.class);\n-    }\n-\n-    private static OverlayWarningHelper getInstance() {\n-        return theInstance;\n-    }\n-\n-    public static void initHelper(OverlayWarning overlayWarning) {\n-        setHelper(overlayWarning, getInstance());\n-    }\n-\n-    @Override\n-    protected void updatePeerImpl(Node node) {\n-        overlayWarningAccessor.doUpdatePeer(node);\n-        super.updatePeerImpl(node);\n-    }\n-\n-    @Override\n-    protected void markDirtyImpl(Node node, DirtyBits dirtyBit) {\n-        super.markDirtyImpl(node, dirtyBit);\n-        overlayWarningAccessor.doMarkDirty(node, dirtyBit);\n-    }\n-\n-    public static void setOverlayWarningAccessor(final OverlayWarningAccessor newAccessor) {\n-        if (overlayWarningAccessor != null) {\n-            throw new IllegalStateException();\n-        }\n-\n-        overlayWarningAccessor = newAccessor;\n-    }\n-\n-    public interface OverlayWarningAccessor {\n-        void doMarkDirty(Node node, DirtyBits dirtyBit);\n-        void doUpdatePeer(Node node);\n-    }\n-\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/OverlayWarningHelper.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -1259,0 +1259,2 @@\n+            case EXTENDED_WINDOW:\n+                return Application.GetApplication().supportsExtendedWindows();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/QuantumToolkit.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import com.sun.javafx.scene.NodeHelper;\n@@ -39,0 +38,1 @@\n+import javafx.scene.Parent;\n@@ -45,0 +45,1 @@\n+    private final javafx.scene.Scene fxScene;\n@@ -47,1 +48,0 @@\n-\n@@ -49,0 +49,2 @@\n+    private ViewSceneOverlay viewSceneOverlay;\n+    private Parent overlayRoot;\n@@ -50,1 +52,1 @@\n-    public ViewScene(boolean depthBuffer, boolean msaa) {\n+    public ViewScene(javafx.scene.Scene fxScene, boolean depthBuffer, boolean msaa) {\n@@ -53,0 +55,1 @@\n+        this.fxScene = fxScene;\n@@ -84,0 +87,8 @@\n+\n+            if (fxScene != null) {\n+                viewSceneOverlay = new ViewSceneOverlay(fxScene, painter);\n+                viewSceneOverlay.setRoot(overlayRoot);\n+            } else {\n+                viewSceneOverlay = null;\n+            }\n+\n@@ -104,0 +115,1 @@\n+                viewSceneOverlay = null;\n@@ -155,3 +167,5 @@\n-    @Override public String toString() {\n-        View view = getPlatformView();\n-        return (\" scene: \" + hashCode() + \" @ (\" + view.getWidth() + \",\" + view.getHeight() + \")\");\n+    @Override\n+    public void processOverlayCSS() {\n+        if (viewSceneOverlay != null) {\n+            viewSceneOverlay.processCSS();\n+        }\n@@ -160,14 +174,19 @@\n-    void synchroniseOverlayWarning() {\n-        try {\n-            waitForSynchronization();\n-            OverlayWarning warning = getWindowStage().getWarning();\n-            if (warning == null) {\n-                painter.setOverlayRoot(null);\n-            } else {\n-                painter.setOverlayRoot(NodeHelper.getPeer(warning));\n-                warning.updateBounds();\n-                NodeHelper.updatePeer(warning);\n-            }\n-        } finally {\n-            releaseSynchronization(true);\n-            entireSceneNeedsRepaint();\n+    @Override\n+    public void layoutOverlay() {\n+        if (viewSceneOverlay != null) {\n+            viewSceneOverlay.layout();\n+        }\n+    }\n+\n+    @Override\n+    public void synchronizeOverlay() {\n+        if (viewSceneOverlay != null) {\n+            viewSceneOverlay.synchronize();\n+        }\n+    }\n+\n+    public void setViewSize(float width, float height) {\n+        sceneListener.changedSize(width, height);\n+\n+        if (viewSceneOverlay != null) {\n+            viewSceneOverlay.resize(width, height);\n@@ -176,0 +195,13 @@\n+\n+    public void setOverlay(Parent root) {\n+        overlayRoot = root;\n+\n+        if (viewSceneOverlay != null) {\n+            viewSceneOverlay.setRoot(root);\n+        }\n+    }\n+\n+    @Override public String toString() {\n+        View view = getPlatformView();\n+        return (\" scene: \" + hashCode() + \" @ (\" + view.getWidth() + \",\" + view.getHeight() + \")\");\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/ViewScene.java","additions":53,"deletions":21,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.tk.quantum;\n+\n+import com.sun.javafx.scene.NodeHelper;\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+import javafx.scene.SubScene;\n+\n+\/**\n+ * Shows an overlay over a {@link javafx.scene.Scene}.\n+ * The overlay is not part of the scene graph, and not accessible by applications.\n+ *\/\n+final class ViewSceneOverlay {\n+\n+    private final javafx.scene.Scene fxScene;\n+    private final ViewPainter painter;\n+    private Parent root;\n+    private double width, height;\n+\n+    ViewSceneOverlay(javafx.scene.Scene fxScene, ViewPainter painter) {\n+        this.fxScene = fxScene;\n+        this.painter = painter;\n+    }\n+\n+    public void processCSS() {\n+        if (root != null) {\n+            NodeHelper.processCSS(root);\n+        }\n+    }\n+\n+    public void resize(double width, double height) {\n+        this.width = width;\n+        this.height = height;\n+    }\n+\n+    public void layout() {\n+        if (fxScene == null) {\n+            return;\n+        }\n+\n+        var window = fxScene.getWindow();\n+\n+        if (root != null && window != null) {\n+            root.resize(width, height);\n+            root.layout();\n+            NodeHelper.updateBounds(root);\n+        }\n+    }\n+\n+    public void setRoot(Parent root) {\n+        if (this.root == root) {\n+            return;\n+        }\n+\n+        this.root = root;\n+\n+        if (root != null) {\n+            NodeHelper.setScenes(root, fxScene, null);\n+            painter.setOverlayRoot(NodeHelper.getPeer(root));\n+        } else {\n+            painter.setOverlayRoot(null);\n+        }\n+    }\n+\n+    public void synchronize() {\n+        if (root != null && !NodeHelper.isDirtyEmpty(root)) {\n+            syncPeer(root);\n+        }\n+    }\n+\n+    private void syncPeer(Node node) {\n+        NodeHelper.syncPeer(node);\n+\n+        if (node instanceof Parent parent) {\n+            for (Node child : parent.getChildrenUnmodifiable()) {\n+                syncPeer(child);\n+            }\n+        } else if (node instanceof SubScene subScene) {\n+            syncPeer(subScene.getRoot());\n+        }\n+\n+        if (node.getClip() != null) {\n+            syncPeer(node.getClip());\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/ViewSceneOverlay.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,7 @@\n+                \/\/ Downgrade conditional stage styles if not supported\n+                if (style == StageStyle.UNIFIED && !app.supportsUnifiedWindows()) {\n+                    style = StageStyle.DECORATED;\n+                } else if (style == StageStyle.EXTENDED && !app.supportsExtendedWindows()) {\n+                    style = StageStyle.DECORATED;\n+                }\n+\n@@ -159,3 +166,1 @@\n-                        if (app.supportsUnifiedWindows()) {\n-                            windowMask |= Window.UNIFIED;\n-                        }\n+                        windowMask |= Window.UNIFIED;\n@@ -167,4 +172,4 @@\n-                        if (ownerWindow != null || modality != Modality.NONE) {\n-                            windowMask &=\n-                                ~(Window.MINIMIZABLE | Window.MAXIMIZABLE);\n-                        }\n+                        resizable = true;\n+                        break;\n+                    case EXTENDED:\n+                        windowMask |= Window.EXTENDED | Window.CLOSABLE | Window.MINIMIZABLE | Window.MAXIMIZABLE;\n@@ -181,0 +186,4 @@\n+\n+                if (ownerWindow != null || modality != Modality.NONE) {\n+                    windowMask &= ~(Window.MINIMIZABLE | Window.MAXIMIZABLE);\n+                }\n@@ -247,1 +256,1 @@\n-        ViewScene scene = new ViewScene(depthBuffer, msaa);\n+        ViewScene scene = new ViewScene(fxStage != null ? fxStage.getScene() : null, depthBuffer, msaa);\n@@ -249,0 +258,6 @@\n+\n+        \/\/ The window-provided overlay is not visible in full-screen mode.\n+        if (!isInFullScreen) {\n+            scene.setOverlay(platformWindow.getWindowOverlay());\n+        }\n+\n@@ -699,1 +714,0 @@\n-                    setWarning(null);\n@@ -701,0 +715,2 @@\n+\n+                setWarning(null);\n@@ -714,5 +730,5 @@\n-        getViewScene().synchroniseOverlayWarning();\n-    }\n-\n-    OverlayWarning getWarning() {\n-        return warning;\n+        if (newWarning != null) {\n+            getViewScene().setOverlay(newWarning);\n+        } else if (!isInFullScreen) {\n+            getViewScene().setOverlay(platformWindow.getWindowOverlay());\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/WindowStage.java","additions":31,"deletions":15,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.Paint;\n+import javafx.scene.paint.RadialGradient;\n@@ -222,1 +225,1 @@\n-     * Calculates a perceptual brightness for a color between 0.0 black and 1.0 while\n+     * Calculates a perceptual brightness for a color between 0.0 (black) and 1.0 (white).\n@@ -228,0 +231,25 @@\n+    \/**\n+     * Calculates an average perceptual brightness for a paint between 0.0 (black) and 1.0 (white).\n+     * <p>\n+     * The average brightness of gradient paints only takes into account the colors of gradient stops,\n+     * but not the distribution of the gradient stops across the paint area.\n+     * <p>\n+     * The brightness of {@code ImagePattern} paints is 1.0 by convention.\n+     *\/\n+    public static double calculateAverageBrightness(Paint paint) {\n+        return switch (paint) {\n+            case Color color -> calculateBrightness(color);\n+            case LinearGradient gradient -> calculateAverageGradientBrightness(gradient.getStops());\n+            case RadialGradient gradient -> calculateAverageGradientBrightness(gradient.getStops());\n+            default -> 1.0;\n+        };\n+    }\n+\n+    private static double calculateAverageGradientBrightness(List<Stop> stops) {\n+        return stops.stream()\n+            .map(Stop::getColor)\n+            .mapToDouble(Utils::calculateBrightness)\n+            .average()\n+            .orElse(1.0);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/util\/Utils.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,0 +162,9 @@\n+    \/**\n+     * Indicates that a system supports {@link javafx.stage.StageStyle#EXTENDED}.\n+     * <p>\n+     * This feature is currently supported on Windows, Linux, and macOS.\n+     *\n+     * @since 24\n+     *\/\n+    EXTENDED_WINDOW,\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/application\/ConditionalFeature.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -501,0 +501,10 @@\n+            @Override\n+            public void setScenes(Node node, Scene newScene, SubScene newSubScene) {\n+                node.setScenes(newScene, newSubScene);\n+            }\n+\n+            @Override\n+            public void updateBounds(Node node) {\n+                node.updateBounds();\n+            }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+import javafx.scene.layout.HeaderBarBase;\n@@ -569,0 +570,4 @@\n+        if (peer != null) {\n+            peer.processOverlayCSS();\n+        }\n+\n@@ -595,0 +600,4 @@\n+        if (peer != null) {\n+            peer.layoutOverlay();\n+        }\n+\n@@ -1897,1 +1906,1 @@\n-    private void processMenuEvent(double x2, double y2, double xAbs, double yAbs, boolean isKeyboardTrigger) {\n+    private boolean processMenuEvent(double x2, double y2, double xAbs, double yAbs, boolean isKeyboardTrigger) {\n@@ -1931,0 +1940,2 @@\n+        boolean handled = false;\n+\n@@ -1934,1 +1945,1 @@\n-            Event.fireEvent(eventTarget, context);\n+            handled = EventUtil.fireEvent(eventTarget, context) == null;\n@@ -1937,0 +1948,2 @@\n+\n+        return handled;\n@@ -2633,0 +2646,1 @@\n+                        peer.synchronizeOverlay();\n@@ -2735,1 +2749,1 @@\n-        public void menuEvent(double x, double y, double xAbs, double yAbs,\n+        public boolean menuEvent(double x, double y, double xAbs, double yAbs,\n@@ -2737,1 +2751,1 @@\n-            Scene.this.processMenuEvent(x, y, xAbs,yAbs, isKeyboardTrigger);\n+            return Scene.this.processMenuEvent(x, y, xAbs,yAbs, isKeyboardTrigger);\n@@ -2992,0 +3006,30 @@\n+        private final PickRay pickRay = new PickRay();\n+\n+        @Override\n+        public Node pickDragAreaNode(double x, double y) {\n+            Node root = Scene.this.getRoot();\n+            if (root == null) {\n+                return null;\n+            }\n+\n+            pickRay.set(x, y, 1, 0, Double.POSITIVE_INFINITY);\n+            var pickResultChooser = new PickResultChooser();\n+            root.pickNode(pickRay, pickResultChooser);\n+            Node intersectedNode = pickResultChooser.getIntersectedNode();\n+            Boolean draggable = intersectedNode instanceof HeaderBarBase ? true : null;\n+\n+            while (intersectedNode != null) {\n+                if (intersectedNode instanceof HeaderBarBase) {\n+                    return draggable == Boolean.TRUE ? intersectedNode : null;\n+                }\n+\n+                if (draggable == null && HeaderBarBase.isDraggable(intersectedNode) instanceof Boolean value) {\n+                    draggable = value;\n+                }\n+\n+                intersectedNode = intersectedNode.getParent();\n+            }\n+\n+            return null;\n+        }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":48,"deletions":4,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,505 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.layout;\n+\n+import com.sun.javafx.geom.Vec2d;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.ObjectPropertyBase;\n+import javafx.geometry.HPos;\n+import javafx.geometry.Insets;\n+import javafx.geometry.NodeOrientation;\n+import javafx.geometry.Orientation;\n+import javafx.geometry.Pos;\n+import javafx.geometry.VPos;\n+import javafx.scene.Node;\n+import javafx.stage.StageStyle;\n+\n+\/**\n+ * A client-area header bar that is used as a replacement for the system-provided header bar in stages\n+ * with the {@link StageStyle#EXTENDED} style. This class enables the <em>click-and-drag<\/em> and\n+ * <em>double-click to maximize<\/em> behaviors that are usually afforded by system-provided header bars.\n+ * The entire {@code HeaderBar} background is draggable by default, but its content is not. Applications\n+ * can specify draggable content nodes of the {@code HeaderBar} with the {@link #setDraggable} method.\n+ * <p>\n+ * {@code HeaderBar} is a layout container that allows applications to place scene graph nodes\n+ * in three areas: {@link #leadingProperty() leading}, {@link #centerProperty() center}, and\n+ * {@link #trailingProperty() trailing}. {@code HeaderBar} ensures that the leading and trailing areas\n+ * account for the default window buttons (minimize, maximize, close). If a child is configured to be\n+ * centered in the {@code center} area, it is laid out with respect to the stage, and not with respect\n+ * to the {@code center} area. This ensures that the child will appear centered in the stage regardless\n+ * of leading or trailing children or the platform-specific placement of default window buttons.\n+ * <p>\n+ * All children will be resized to their preferred widths and extend the height of the {@code HeaderBar}.\n+ * {@code HeaderBar} honors the minimum, preferred, and maximum sizes of its children. If the child's\n+ * resizable range prevents it from be resized to fit within its position, it will be vertically centered\n+ * relative to the available space; this alignment can be customized with a layout constraint.\n+ *\n+ * <h2>Layout constraints<\/h2>\n+ * An application may set constraints on individual children to customize their layout.\n+ * For each constraint, {@code HeaderBar} provides static getter and setter methods.\n+ * <table style=\"white-space: nowrap\">\n+ *     <caption>Layout constraints of {@code HeaderBar}<\/caption>\n+ *     <thead>\n+ *         <tr><th>Constraint<\/th><th>Type<\/th><th>Description<\/th><\/tr>\n+ *     <\/thead>\n+ *     <tbody>\n+ *         <tr><th>alignment<\/th><td>{@link Pos}<\/td>\n+ *             <td>The alignment of the child within its area of the {@code HeaderBar}.<\/td>\n+ *         <\/tr>\n+ *         <tr><th>margin<\/th>\n+ *             <td>{@link Insets}<\/td><td>Margin space around the outside of the child.<\/td>\n+ *         <\/tr>\n+ *     <\/tbody>\n+ * <\/table>\n+ *\n+ * <h2>Example<\/h2>\n+ * Usually, {@code HeaderBar} is placed in a root container like {@code BorderPane} to align it\n+ * with the top of the scene:\n+ * <pre>{@code\n+ * public class MyApp extends Application {\n+ *     @Override\n+ *     public void start(Stage stage) {\n+ *         var button = new Button(\"My button\");\n+ *         HeaderBar.setAlignment(button, Pos.CENTER_LEFT);\n+ *         HeaderBar.setMargin(button, new Insets(5));\n+ *\n+ *         var headerBar = new HeaderBar();\n+ *         headerBar.setCenter(button);\n+ *\n+ *         var root = new BorderPane();\n+ *         root.setTop(headerBar);\n+ *\n+ *         stage.setScene(new Scene(root));\n+ *         stage.initStyle(StageStyle.EXTENDED);\n+ *         stage.show();\n+ *     }\n+ * }\n+ * }<\/pre>\n+ *\n+ * @apiNote An application should only add a single {@code HeaderBar} to the scene graph, and it should\n+ *          be located at the top of the scene. While it is technically possible to add multiple header\n+ *          bars to the scene graph, or place a header bar in another area of the scene, the resulting\n+ *          user experience is not what users typically expect from JavaFX applications and should\n+ *          therefore be avoided.\n+ *\n+ * @see HeaderBarBase\n+ * @since 24\n+ *\/\n+public class HeaderBar extends HeaderBarBase {\n+\n+    private static final String ALIGNMENT = \"headerbar-alignment\";\n+    private static final String MARGIN = \"headerbar-margin\";\n+\n+    \/**\n+     * Sets the alignment for the child when contained in a {@code HeaderBar}.\n+     * If set, will override the header bar's default alignment for the child's position.\n+     * Setting the value to {@code null} will remove the constraint.\n+     *\n+     * @param child the child node\n+     * @param value the alignment position\n+     *\/\n+    public static void setAlignment(Node child, Pos value) {\n+        Pane.setConstraint(child, ALIGNMENT, value);\n+    }\n+\n+    \/**\n+     * Returns the child's alignment in the {@code HeaderBar}.\n+     *\n+     * @param child the child node\n+     * @return the alignment position for the child, or {@code null} if no alignment was set\n+     *\/\n+    public static Pos getAlignment(Node child) {\n+        return (Pos)Pane.getConstraint(child, ALIGNMENT);\n+    }\n+\n+    \/**\n+     * Sets the margin for the child when contained in a {@code HeaderBar}.\n+     * If set, the header bar will lay it out with the margin space around it.\n+     * Setting the value to {@code null} will remove the constraint.\n+     *\n+     * @param child the child node\n+     * @param value the margin of space around the child\n+     *\/\n+    public static void setMargin(Node child, Insets value) {\n+        Pane.setConstraint(child, MARGIN, value);\n+    }\n+\n+    \/**\n+     * Returns the child's margin.\n+     *\n+     * @param child the child node\n+     * @return the margin for the child, or {@code null} if no margin was set\n+     *\/\n+    public static Insets getMargin(Node child) {\n+        return (Insets)Pane.getConstraint(child, MARGIN);\n+    }\n+\n+    private static Insets getNodeMargin(Node child) {\n+        Insets margin = getMargin(child);\n+        return margin != null ? margin : Insets.EMPTY;\n+    }\n+\n+    \/**\n+     * Creates a new {@code HeaderBar}.\n+     *\/\n+    public HeaderBar() {\n+    }\n+\n+    \/**\n+     * Creates a new {@code HeaderBar} with the specified children.\n+     *\n+     * @param leading the leading node\n+     * @param center the center node\n+     * @param trailing the trailing node\n+     *\/\n+    public HeaderBar(Node leading, Node center, Node trailing) {\n+        setLeading(leading);\n+        setCenter(center);\n+        setTrailing(trailing);\n+    }\n+\n+    \/**\n+     * The leading area of the {@code HeaderBar}.\n+     * <p>\n+     * Usually, this corresponds to the left side of the header bar; with right-to-left orientation,\n+     * this corresponds to the right side of the header bar.\n+     *\/\n+    private final ObjectProperty<Node> leading = new NodeProperty() {\n+        @Override\n+        public String getName() {\n+            return \"leading\";\n+        }\n+    };\n+\n+    public final ObjectProperty<Node> leadingProperty() {\n+        return leading;\n+    }\n+\n+    public final Node getLeading() {\n+        return leading.get();\n+    }\n+\n+    public final void setLeading(Node value) {\n+        leading.set(value);\n+    }\n+\n+    \/**\n+     * The center area of the {@code HeaderBar}.\n+     *\/\n+    private final ObjectProperty<Node> center = new NodeProperty() {\n+        @Override\n+        public String getName() {\n+            return \"center\";\n+        }\n+    };\n+\n+    public final ObjectProperty<Node> centerProperty() {\n+        return center;\n+    }\n+\n+    public final Node getCenter() {\n+        return center.get();\n+    }\n+\n+    public final void setCenter(Node value) {\n+        center.set(value);\n+    }\n+\n+    \/**\n+     * The trailing area of the {@code HeaderBar}.\n+     * <p>\n+     * Usually, this corresponds to the right side of the header bar; with right-to-left orientation,\n+     * this corresponds to the left side of the header bar.\n+     *\/\n+    private final ObjectProperty<Node> trailing = new NodeProperty() {\n+        @Override\n+        public String getName() {\n+            return \"trailing\";\n+        }\n+    };\n+\n+    public final ObjectProperty<Node> trailingProperty() {\n+        return trailing;\n+    }\n+\n+    public final Node getTrailing() {\n+        return trailing.get();\n+    }\n+\n+    public final void setTrailing(Node value) {\n+        trailing.set(value);\n+    }\n+\n+    @Override\n+    protected double computeMinWidth(double height) {\n+        Node leading = getLeading(), center = getCenter(), trailing = getTrailing();\n+        Insets insets = getInsets();\n+        double leftPrefWidth;\n+        double rightPrefWidth;\n+        double centerMinWidth;\n+\n+        if (height != -1\n+                && (childHasContentBias(leading, Orientation.VERTICAL) ||\n+                    childHasContentBias(trailing, Orientation.VERTICAL) ||\n+                    childHasContentBias(center, Orientation.VERTICAL))) {\n+            double areaHeight = Math.max(0, height);\n+            leftPrefWidth = getAreaWidth(leading, areaHeight, false);\n+            rightPrefWidth = getAreaWidth(trailing, areaHeight, false);\n+            centerMinWidth = getAreaWidth(center, areaHeight, true);\n+        } else {\n+            leftPrefWidth = getAreaWidth(leading, -1, false);\n+            rightPrefWidth = getAreaWidth(trailing, -1, false);\n+            centerMinWidth = getAreaWidth(center, -1, true);\n+        }\n+\n+        return insets.getLeft()\n+             + leftPrefWidth\n+             + centerMinWidth\n+             + rightPrefWidth\n+             + insets.getRight()\n+             + getLeftSystemInset().getWidth()\n+             + getRightSystemInset().getWidth();\n+    }\n+\n+    @Override\n+    protected double computeMinHeight(double width) {\n+        Node leading = getLeading(), center = getCenter(), trailing = getTrailing();\n+        Insets insets = getInsets();\n+        double leadingMinHeight = getAreaHeight(leading, -1, true);\n+        double trailingMinHeight = getAreaHeight(trailing, -1, true);\n+        double centerMinHeight;\n+\n+        if (width != -1 && childHasContentBias(center, Orientation.HORIZONTAL)) {\n+            double leadingPrefWidth = getAreaWidth(leading, -1, false);\n+            double trailingPrefWidth = getAreaWidth(trailing, -1, false);\n+            centerMinHeight = getAreaHeight(center, Math.max(0, width - leadingPrefWidth - trailingPrefWidth), true);\n+        } else {\n+            centerMinHeight = getAreaHeight(center, -1, true);\n+        }\n+\n+        return insets.getTop()\n+             + insets.getBottom()\n+             + Math.max(centerMinHeight, Math.max(trailingMinHeight, leadingMinHeight));\n+    }\n+\n+    @Override\n+    protected double computePrefHeight(double width) {\n+        Node leading = getLeading(), center = getCenter(), trailing = getTrailing();\n+        Insets insets = getInsets();\n+        double leadingPrefHeight = getAreaHeight(leading, -1, false);\n+        double trailingPrefHeight = getAreaHeight(trailing, -1, false);\n+        double centerPrefHeight;\n+\n+        if (width != -1 && childHasContentBias(center, Orientation.HORIZONTAL)) {\n+            double leadingPrefWidth = getAreaWidth(leading, -1, false);\n+            double trailingPrefWidth = getAreaWidth(trailing, -1, false);\n+            centerPrefHeight = getAreaHeight(center, Math.max(0, width - leadingPrefWidth - trailingPrefWidth), false);\n+        } else {\n+            centerPrefHeight = getAreaHeight(center, -1, false);\n+        }\n+\n+        return insets.getTop()\n+             + insets.getBottom()\n+             + Math.max(centerPrefHeight, Math.max(trailingPrefHeight, leadingPrefHeight));\n+    }\n+\n+    @Override\n+    public boolean usesMirroring() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected void layoutChildren() {\n+        Node center = getCenter();\n+        Node left, right;\n+        Insets insets = getInsets();\n+        boolean rtl = getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;\n+        double width = Math.max(getWidth(), minWidth(-1));\n+        double height = Math.max(getHeight(), minHeight(-1));\n+        double leftSystemInset = getLeftSystemInset().getWidth();\n+        double rightSystemInset = getRightSystemInset().getWidth();\n+        double leftWidth = 0;\n+        double rightWidth = 0;\n+        double insideY = insets.getTop();\n+        double insideHeight = height - insideY - insets.getBottom();\n+        double insideX, insideWidth;\n+\n+        if (rtl) {\n+            left = getTrailing();\n+            right = getLeading();\n+            insideX = insets.getRight() + leftSystemInset;\n+            insideWidth = width - insideX - insets.getLeft() - rightSystemInset;\n+        } else {\n+            left = getLeading();\n+            right = getTrailing();\n+            insideX = insets.getLeft() + leftSystemInset;\n+            insideWidth = width - insideX - insets.getRight() - rightSystemInset;\n+        }\n+\n+        if (left != null && left.isManaged()) {\n+            Insets leftMargin = adjustMarginForRTL(getNodeMargin(left), rtl);\n+            double adjustedWidth = adjustWidthByMargin(insideWidth, leftMargin);\n+            Vec2d childSize = resizeChild(left, adjustedWidth, insideHeight, leftMargin);\n+            leftWidth = snapSpaceX(leftMargin.getLeft()) + childSize.x + snapSpaceX(leftMargin.getRight());\n+            Pos alignment = getAlignment(left);\n+\n+            positionInArea(\n+                left, insideX, insideY,\n+                leftWidth, insideHeight, 0,\n+                leftMargin,\n+                alignment != null ? alignment.getHpos() : HPos.CENTER,\n+                alignment != null ? alignment.getVpos() : VPos.CENTER,\n+                isSnapToPixel());\n+        }\n+\n+        if (right != null && right.isManaged()) {\n+            Insets rightMargin = adjustMarginForRTL(getNodeMargin(right), rtl);\n+            double adjustedWidth = adjustWidthByMargin(insideWidth - leftWidth, rightMargin);\n+            Vec2d childSize = resizeChild(right, adjustedWidth, insideHeight, rightMargin);\n+            rightWidth = snapSpaceX(rightMargin.getLeft()) + childSize.x + snapSpaceX(rightMargin.getRight());\n+            Pos alignment = getAlignment(right);\n+\n+            positionInArea(\n+                right, insideX + insideWidth - rightWidth, insideY,\n+                rightWidth, insideHeight, 0,\n+                rightMargin,\n+                alignment != null ? alignment.getHpos() : HPos.CENTER,\n+                alignment != null ? alignment.getVpos() : VPos.CENTER,\n+                isSnapToPixel());\n+        }\n+\n+        if (center != null && center.isManaged()) {\n+            Insets centerMargin = adjustMarginForRTL(getNodeMargin(center), rtl);\n+            double adjustedWidth = adjustWidthByMargin(insideWidth - leftWidth - rightWidth, centerMargin);\n+            Vec2d childSize = resizeChild(center, adjustedWidth, insideHeight, centerMargin);\n+            double centerWidth = childSize.x;\n+            Pos alignment = getAlignment(center);\n+\n+            if (alignment == null || alignment.getHpos() == HPos.CENTER) {\n+                double idealX = width \/ 2 - centerWidth \/ 2;\n+                double minX = insideX + leftWidth + centerMargin.getLeft();\n+                double maxX = insideX + insideWidth - rightWidth - centerMargin.getRight();\n+                double adjustedX;\n+\n+                if (idealX < minX) {\n+                    adjustedX = minX;\n+                } else if (idealX + centerWidth > maxX) {\n+                    adjustedX = maxX - centerWidth;\n+                } else {\n+                    adjustedX = idealX;\n+                }\n+\n+                positionInArea(\n+                    center,\n+                    adjustedX, insideY,\n+                    centerWidth, insideHeight, 0,\n+                    new Insets(centerMargin.getTop(), 0, centerMargin.getBottom(), 0),\n+                    HPos.LEFT, alignment != null ? alignment.getVpos() : VPos.CENTER,\n+                    isSnapToPixel());\n+            } else {\n+                positionInArea(\n+                    center,\n+                    insideX + leftWidth, insideY,\n+                    insideWidth - leftWidth - rightWidth, insideHeight, 0,\n+                    centerMargin,\n+                    alignment.getHpos(), alignment.getVpos(),\n+                    isSnapToPixel());\n+            }\n+        }\n+    }\n+\n+    private Insets adjustMarginForRTL(Insets margin, boolean rtl) {\n+        if (margin == null) {\n+            return null;\n+        }\n+\n+        return rtl\n+            ? new Insets(margin.getTop(), margin.getLeft(), margin.getBottom(), margin.getRight())\n+            : margin;\n+    }\n+\n+    private boolean childHasContentBias(Node child, Orientation orientation) {\n+        if (child != null && child.isManaged()) {\n+            return child.getContentBias() == orientation;\n+        }\n+\n+        return false;\n+    }\n+\n+    private Vec2d resizeChild(Node child, double adjustedWidth, double insideHeight, Insets margin) {\n+        double adjustedHeight = adjustHeightByMargin(insideHeight, margin);\n+        double childWidth = Math.min(snapSizeX(child.prefWidth(adjustedHeight)), adjustedWidth);\n+        Vec2d size = boundedNodeSizeWithBias(child, childWidth, adjustedHeight, false, true, TEMP_VEC2D);\n+        size.x = snapSizeX(size.x);\n+        size.y = snapSizeX(size.y);\n+        child.resize(size.x, size.y);\n+        return size;\n+    }\n+\n+    private double getAreaWidth(Node child, double height, boolean minimum) {\n+        if (child != null && child.isManaged()) {\n+            Insets margin = getNodeMargin(child);\n+            return minimum\n+                ? computeChildMinAreaWidth(child, -1, margin, height, false)\n+                : computeChildPrefAreaWidth(child, -1, margin, height, false);\n+        }\n+\n+        return 0;\n+    }\n+\n+    private double getAreaHeight(Node child, double width, boolean minimum) {\n+        if (child != null && child.isManaged()) {\n+            Insets margin = getNodeMargin(child);\n+            return minimum\n+                ? computeChildMinAreaHeight(child, -1, margin, width)\n+                : computeChildPrefAreaHeight(child, -1, margin, width);\n+        }\n+\n+        return 0;\n+    }\n+\n+    private abstract class NodeProperty extends ObjectPropertyBase<Node> {\n+        private Node value;\n+\n+        @Override\n+        public Object getBean() {\n+            return HeaderBar.this;\n+        }\n+\n+        @Override\n+        protected void invalidated() {\n+            if (value != null) {\n+                getChildren().remove(value);\n+            }\n+\n+            value = get();\n+\n+            if (value != null) {\n+                getChildren().add(value);\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HeaderBar.java","additions":505,"deletions":0,"binary":false,"changes":505,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.layout;\n+\n+import com.sun.glass.ui.WindowOverlayMetrics;\n+import com.sun.javafx.stage.StageHelper;\n+import com.sun.javafx.tk.quantum.WindowStage;\n+import javafx.beans.property.ReadOnlyObjectWrapper;\n+import javafx.beans.value.ObservableValue;\n+import javafx.geometry.Dimension2D;\n+import javafx.geometry.HorizontalDirection;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.stage.Window;\n+import javafx.util.Subscription;\n+\n+\/**\n+ * Base class for a client-area header bar that is used as a replacement for the system-provided header bar\n+ * in stages with the {@link StageStyle#EXTENDED} style. This class is intended for application developers\n+ * to use as a starting point for custom header bar implementations, and it enables the <em>click-and-drag<\/em>\n+ * and <em>double-click to maximize<\/em> behaviors that are usually afforded by system-provided header bars.\n+ * The entire {@code HeaderBarBase} background is draggable by default, but its content is not. Applications\n+ * can specify draggable content nodes of the {@code HeaderBarBase} with the {@link #setDraggable} method.\n+ *\n+ * @apiNote Most application developers should use the {@link HeaderBar} implementation instead of\n+ *          creating a custom header bar.\n+ * @see HeaderBar\n+ * @since 24\n+ *\/\n+public abstract class HeaderBarBase extends Region {\n+\n+    private static final String DRAGGABLE = \"headerbar-draggable\";\n+\n+    \/**\n+     * Specifies whether the child and its subtree is a draggable part of the {@code HeaderBar}.\n+     * <p>\n+     * If set to a non-null value, the value will apply for the entire subtree of the child unless\n+     * another node in the subtree specifies a different value. Setting the value to {@code null}\n+     * will remove the flag.\n+     *\n+     * @param child the child node\n+     * @param value a {@code Boolean} value indicating whether the child and its subtree is draggable,\n+     *              or {@code null} to remove the flag\n+     *\/\n+    public static void setDraggable(Node child, Boolean value) {\n+        Pane.setConstraint(child, DRAGGABLE, value);\n+    }\n+\n+    \/**\n+     * Returns whether the child and its subtree is a draggable part of the {@code HeaderBar}.\n+     *\n+     * @param child the child node\n+     * @return a {@code Boolean} value indicating whether the child and its subtree is draggable,\n+     *         or {@code null} if not set\n+     *\/\n+    public static Boolean isDraggable(Node child) {\n+        return (Boolean)Pane.getConstraint(child, DRAGGABLE);\n+    }\n+\n+    private Subscription metricsSubscription;\n+    private WindowOverlayMetrics currentMetrics;\n+    private boolean currentFullScreen;\n+\n+    \/**\n+     * Constructor called by subclasses.\n+     *\/\n+    protected HeaderBarBase() {\n+        var stage = sceneProperty()\n+            .flatMap(Scene::windowProperty)\n+            .map(w -> w instanceof Stage s ? s : null);\n+\n+        stage.flatMap(Window::showingProperty)\n+            .orElse(false)\n+            .subscribe(this::onShowingChanged);\n+\n+        stage.flatMap(Stage::fullScreenProperty)\n+            .orElse(false)\n+            .subscribe(this::onFullScreenChanged);\n+    }\n+\n+    private void onShowingChanged(boolean showing) {\n+        if (!showing) {\n+            if (metricsSubscription != null) {\n+                metricsSubscription.unsubscribe();\n+                metricsSubscription = null;\n+            }\n+        } else if (getScene().getWindow() instanceof Stage stage\n+                   && StageHelper.getPeer(stage) instanceof WindowStage windowStage) {\n+            ObservableValue<WindowOverlayMetrics> metrics =\n+                windowStage.getPlatformWindow().windowOverlayMetrics();\n+\n+            if (metrics != null) {\n+                metricsSubscription = metrics.subscribe(this::onMetricsChanged);\n+            }\n+        }\n+    }\n+\n+    private void onMetricsChanged(WindowOverlayMetrics metrics) {\n+        currentMetrics = metrics;\n+        updateInsets();\n+    }\n+\n+    private void onFullScreenChanged(boolean fullScreen) {\n+        currentFullScreen = fullScreen;\n+        updateInsets();\n+    }\n+\n+    private void updateInsets() {\n+        if (currentFullScreen || currentMetrics == null) {\n+            leftSystemInset.set(new Dimension2D(0, 0));\n+            rightSystemInset.set(new Dimension2D(0, 0));\n+        } else if (currentMetrics.placement() == HorizontalDirection.LEFT) {\n+            leftSystemInset.set(currentMetrics.size());\n+            rightSystemInset.set(new Dimension2D(0, 0));\n+        } else if (currentMetrics.placement() == HorizontalDirection.RIGHT) {\n+            leftSystemInset.set(new Dimension2D(0, 0));\n+            rightSystemInset.set(currentMetrics.size());\n+        } else {\n+            leftSystemInset.set(new Dimension2D(0, 0));\n+            rightSystemInset.set(new Dimension2D(0, 0));\n+        }\n+    }\n+\n+    \/**\n+     * Describes the size of the left system inset, which is an area reserved for the\n+     * minimize, maximize, and close window buttons. If there are no window buttons on\n+     * the left side of the window, the returned area is an empty {@code Dimension2D}.\n+     * <p>\n+     * Note that the left system inset refers to the physical left side of the window,\n+     * independent of layout orientation.\n+     *\/\n+    private final ReadOnlyObjectWrapper<Dimension2D> leftSystemInset =\n+        new ReadOnlyObjectWrapper<>(this, \"leftInset\", new Dimension2D(0, 0)) {\n+            @Override\n+            protected void invalidated() {\n+                requestLayout();\n+            }\n+        };\n+\n+    public final ReadOnlyObjectWrapper<Dimension2D> leftSystemInsetProperty() {\n+        return leftSystemInset;\n+    }\n+\n+    public final Dimension2D getLeftSystemInset() {\n+        return leftSystemInset.get();\n+    }\n+\n+    \/**\n+     * Describes the size of the right system inset, which is an area reserved for the\n+     * minimize, maximize, and close window buttons. If there are no window buttons on\n+     * the right side of the window, the returned area is an empty {@code Dimension2D}.\n+     * <p>\n+     * Note that the right system inset refers to the physical right side of the window,\n+     * independent of layout orientation.\n+     *\/\n+    private final ReadOnlyObjectWrapper<Dimension2D> rightSystemInset =\n+        new ReadOnlyObjectWrapper<>(this, \"rightInset\", new Dimension2D(0, 0)) {\n+            @Override\n+            protected void invalidated() {\n+                requestLayout();\n+            }\n+        };\n+\n+    public final ReadOnlyObjectWrapper<Dimension2D> rightSystemInsetProperty() {\n+        return rightSystemInset;\n+    }\n+\n+    public final Dimension2D getRightSystemInset() {\n+        return rightSystemInset.get();\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HeaderBarBase.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,6 @@\n+import javafx.application.ConditionalFeature;\n+import javafx.application.Platform;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.HeaderBar;\n+\n@@ -69,1 +75,36 @@\n-    UNIFIED\n+    UNIFIED,\n+\n+    \/**\n+     * Defines a {@code Stage} style in which the client area is extended into the header bar area, removing\n+     * the separation between the two areas and allowing applications to place scene graph nodes in the header\n+     * bar area of the stage.\n+     * <p>\n+     * An extended window has the default window buttons (minimize, maximize, close), but no system-provided\n+     * draggable header bar. Applications need to provide their own header bar by placing the {@link HeaderBar}\n+     * control in the scene graph. Usually, this is combined with a {@link BorderPane} root container:\n+     * <pre>{@code\n+     * public class MyApp extends Application {\n+     *     @Override\n+     *     public void start(Stage stage) {\n+     *         var headerBar = new HeaderBar();\n+     *         var root = new BorderPane();\n+     *         root.setTop(headerBar);\n+     *\n+     *         stage.setScene(new Scene(root));\n+     *         stage.initStyle(StageStyle.EXTENDED);\n+     *         stage.show();\n+     *     }\n+     * }\n+     * }<\/pre>\n+     * <p>\n+     * The color scheme of the default window buttons is adjusted to the {@link Scene#fillProperty() fill}\n+     * of the {@code Scene} to remain easily recognizable. Applications should set the scene fill to a color\n+     * that matches the brightness of the user interface, even if the scene fill is not visible because it\n+     * is obscured by other controls.\n+     * <p>\n+     * This is a conditional feature, to check if it is supported see {@link Platform#isSupported(ConditionalFeature)}.\n+     * If the feature is not supported by the platform, this style downgrades to {@link StageStyle#DECORATED}.\n+     *\n+     * @since 24\n+     *\/\n+    EXTENDED\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/StageStyle.java","additions":43,"deletions":2,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -525,0 +525,1 @@\n+                case GDK_2BUTTON_PRESS:\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassApplication.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,3 @@\n+    if (mask & com_sun_glass_ui_gtk_GtkWindow_EXTENDED) {\n+        return EXTENDED;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassWindow.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+jmethodID jGtkWindowDragAreaHitTest;\n@@ -277,2 +278,3 @@\n-    jGtkWindowNotifyStateChanged =\n-            env->GetMethodID(clazz, \"notifyStateChanged\", \"(I)V\");\n+    jGtkWindowNotifyStateChanged = env->GetMethodID(clazz, \"notifyStateChanged\", \"(I)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jGtkWindowDragAreaHitTest = env->GetMethodID(clazz, \"dragAreaHitTest\", \"(II)Z\");\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,2 @@\n-    extern jmethodID jGtkWindowNotifyStateChanged; \/\/ com.sun.glass.ui.GtkWindow#notifyStateChanged (I)V\n+    extern jmethodID jGtkWindowNotifyStateChanged; \/\/ com.sun.glass.ui.gtk.GtkWindow#notifyStateChanged (I)V\n+    extern jmethodID jGtkWindowDragAreaHitTest; \/\/com.sun.glass.ui.gtk.GtkWindow#dragAreaHitTest (II)Z\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,0 +54,3 @@\n+\/\/ Resize border width of EXTENDED windows\n+#define RESIZE_BORDER_WIDTH 5\n+\n@@ -263,0 +266,5 @@\n+    \/\/ We only handle single press\/release events here.\n+    if (event->type != GDK_BUTTON_PRESS && event->type != GDK_BUTTON_RELEASE) {\n+        return;\n+    }\n+\n@@ -651,1 +659,20 @@\n-    gdk_window_set_cursor(gdk_window, cursor);\n+\n+    gdk_cursor = cursor;\n+\n+    if (gdk_cursor_override == NULL) {\n+        gdk_window_set_cursor(gdk_window, cursor);\n+    }\n+}\n+\n+void WindowContextBase::set_cursor_override(GdkCursor* cursor) {\n+    if (gdk_cursor_override == cursor) {\n+        return;\n+    }\n+\n+    gdk_cursor_override = cursor;\n+\n+    if (cursor != NULL) {\n+        gdk_window_set_cursor(gdk_window, cursor);\n+    } else {\n+        gdk_window_set_cursor(gdk_window, gdk_cursor);\n+    }\n@@ -659,0 +686,4 @@\n+bool WindowContextBase::get_window_edge(int x, int y, GdkWindowEdge* window_edge) {\n+    return false;\n+}\n+\n@@ -1369,0 +1400,150 @@\n+\/*\n+ * Handles mouse button events of EXTENDED windows and adds the window behaviors for non-client\n+ * regions that are usually provided by the window manager. Note that a full-screen window has\n+ * no non-client regions.\n+ *\/\n+void WindowContextTop::process_mouse_button(GdkEventButton* event) {\n+    \/\/ Non-EXTENDED or full-screen windows don't have additional behaviors, so we delegate\n+    \/\/ directly to the base implementation.\n+    if (is_fullscreen || frame_type != EXTENDED || jwindow == NULL) {\n+        WindowContextBase::process_mouse_button(event);\n+        return;\n+    }\n+\n+    \/\/ Double-clicking on the drag area maximizes the window (or restores its size).\n+    if (event->type == GDK_2BUTTON_PRESS) {\n+        jboolean dragArea = mainEnv->CallBooleanMethod(\n+            jwindow, jGtkWindowDragAreaHitTest, (jint)event->x, (jint)event->y);\n+        CHECK_JNI_EXCEPTION(mainEnv);\n+\n+        if (dragArea) {\n+            set_maximized(!is_maximized);\n+        }\n+\n+        \/\/ We don't process the GDK_2BUTTON_PRESS event in the base implementation.\n+        return;\n+    }\n+\n+    if (event->button == 1 && event->type == GDK_BUTTON_PRESS) {\n+        GdkWindowEdge edge;\n+        bool shouldStartResizeDrag = !is_maximized && get_window_edge(event->x, event->y, &edge);\n+\n+        \/\/ Clicking on a window edge starts a move-resize operation.\n+        if (shouldStartResizeDrag) {\n+            \/\/ Send a synthetic PRESS + RELEASE to FX. This allows FX to do things that need to be done\n+            \/\/ prior to resizing the window, like closing a popup menu. We do this because we won't be\n+            \/\/ sending events to FX once the resize operation has started.\n+            WindowContextBase::process_mouse_button(event);\n+            event->type = GDK_BUTTON_RELEASE;\n+            WindowContextBase::process_mouse_button(event);\n+\n+            gint rx = 0, ry = 0;\n+            gdk_window_get_root_coords(get_gdk_window(), event->x, event->y, &rx, &ry);\n+            gtk_window_begin_resize_drag(get_gtk_window(), edge, 1, rx, ry, event->time);\n+            return;\n+        }\n+\n+        bool shouldStartMoveDrag = mainEnv->CallBooleanMethod(\n+            jwindow, jGtkWindowDragAreaHitTest, (jint)event->x, (jint)event->y);\n+        CHECK_JNI_EXCEPTION(mainEnv);\n+\n+        \/\/ Clicking on a draggable area starts a move-drag operation.\n+        if (shouldStartMoveDrag) {\n+            \/\/ Send a synthetic PRESS + RELEASE to FX.\n+            WindowContextBase::process_mouse_button(event);\n+            event->type = GDK_BUTTON_RELEASE;\n+            WindowContextBase::process_mouse_button(event);\n+\n+            gint rx = 0, ry = 0;\n+            gdk_window_get_root_coords(get_gdk_window(), event->x, event->y, &rx, &ry);\n+            gtk_window_begin_move_drag(get_gtk_window(), 1, rx, ry, event->time);\n+            return;\n+        }\n+    }\n+\n+    \/\/ Call the base implementation for client area events.\n+    WindowContextBase::process_mouse_button(event);\n+}\n+\n+\/*\n+ * Handles mouse motion events of EXTENDED windows and changes the cursor when it is on top\n+ * of the internal resize border. Note that a full-screen window or maximized window has no\n+ * resize border.\n+ *\/\n+void WindowContextTop::process_mouse_motion(GdkEventMotion* event) {\n+    GdkWindowEdge edge;\n+\n+    \/\/ Call the base implementation for client area events.\n+    if (is_fullscreen\n+            || is_maximized\n+            || frame_type != EXTENDED\n+            || !get_window_edge(event->x, event->y, &edge)) {\n+        set_cursor_override(NULL);\n+        WindowContextBase::process_mouse_motion(event);\n+        return;\n+    }\n+\n+    static const struct Cursors {\n+        GdkCursor* NORTH = gdk_cursor_new(GDK_TOP_SIDE);\n+        GdkCursor* NORTH_EAST = gdk_cursor_new(GDK_TOP_RIGHT_CORNER);\n+        GdkCursor* EAST = gdk_cursor_new(GDK_RIGHT_SIDE);\n+        GdkCursor* SOUTH_EAST = gdk_cursor_new(GDK_BOTTOM_RIGHT_CORNER);\n+        GdkCursor* SOUTH = gdk_cursor_new(GDK_BOTTOM_SIDE);\n+        GdkCursor* SOUTH_WEST = gdk_cursor_new(GDK_BOTTOM_LEFT_CORNER);\n+        GdkCursor* WEST = gdk_cursor_new(GDK_LEFT_SIDE);\n+        GdkCursor* NORTH_WEST = gdk_cursor_new(GDK_TOP_LEFT_CORNER);\n+    } cursors;\n+\n+    GdkCursor* cursor = NULL;\n+\n+    switch (edge) {\n+        case GDK_WINDOW_EDGE_NORTH: cursor = cursors.NORTH; break;\n+        case GDK_WINDOW_EDGE_NORTH_EAST: cursor = cursors.NORTH_EAST; break;\n+        case GDK_WINDOW_EDGE_EAST: cursor = cursors.EAST; break;\n+        case GDK_WINDOW_EDGE_SOUTH_EAST: cursor = cursors.SOUTH_EAST; break;\n+        case GDK_WINDOW_EDGE_SOUTH: cursor = cursors.SOUTH; break;\n+        case GDK_WINDOW_EDGE_SOUTH_WEST: cursor = cursors.SOUTH_WEST; break;\n+        case GDK_WINDOW_EDGE_WEST: cursor = cursors.WEST; break;\n+        case GDK_WINDOW_EDGE_NORTH_WEST: cursor = cursors.NORTH_WEST; break;\n+    }\n+\n+    set_cursor_override(cursor);\n+\n+    \/\/ If the cursor is not on a resize border, call the base handler.\n+    if (cursor == NULL) {\n+        WindowContextBase::process_mouse_motion(event);\n+    }\n+}\n+\n+\/*\n+ * Determines the GdkWindowEdge at the specified coordinate; returns true if the coordinate\n+ * identifies a window edge, false otherwise.\n+ *\/\n+bool WindowContextTop::get_window_edge(int x, int y, GdkWindowEdge* window_edge) {\n+    GdkWindowEdge edge;\n+    gint width, height;\n+    gtk_window_get_size(get_gtk_window(), &width, &height);\n+\n+    if (x <= RESIZE_BORDER_WIDTH) {\n+        if (y <= 2 * RESIZE_BORDER_WIDTH) edge = GDK_WINDOW_EDGE_NORTH_WEST;\n+        else if (y >= height - 2 * RESIZE_BORDER_WIDTH) edge = GDK_WINDOW_EDGE_SOUTH_WEST;\n+        else edge = GDK_WINDOW_EDGE_WEST;\n+    } else if (x >= width - RESIZE_BORDER_WIDTH) {\n+        if (y <= 2 * RESIZE_BORDER_WIDTH) edge = GDK_WINDOW_EDGE_NORTH_EAST;\n+        else if (y >= height - 2 * RESIZE_BORDER_WIDTH) edge = GDK_WINDOW_EDGE_SOUTH_EAST;\n+        else edge = GDK_WINDOW_EDGE_EAST;\n+    } else if (y <= RESIZE_BORDER_WIDTH) {\n+        edge = GDK_WINDOW_EDGE_NORTH;\n+    } else if (y >= height - RESIZE_BORDER_WIDTH) {\n+        edge = GDK_WINDOW_EDGE_SOUTH;\n+    } else {\n+        return false;\n+    }\n+\n+    if (window_edge != NULL) {\n+        *window_edge = edge;\n+    }\n+\n+    return true;\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.cpp","additions":182,"deletions":1,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,2 @@\n-    TRANSPARENT\n+    TRANSPARENT,\n+    EXTENDED\n@@ -165,0 +166,1 @@\n+    virtual bool get_window_edge(int x, int y, GdkWindowEdge*) = 0;\n@@ -185,0 +187,2 @@\n+    GdkCursor* gdk_cursor = NULL;\n+    GdkCursor* gdk_cursor_override = NULL;\n@@ -231,0 +235,1 @@\n+    void set_cursor_override(GdkCursor*);\n@@ -250,0 +255,1 @@\n+    bool get_window_edge(int x, int y, GdkWindowEdge*);\n@@ -287,0 +293,2 @@\n+    void process_mouse_motion(GdkEventMotion*);\n+    void process_mouse_button(GdkEventButton*);\n@@ -334,0 +342,1 @@\n+    bool get_window_edge(int x, int y, GdkWindowEdge*);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,0 +118,2 @@\n+- (NSEvent*)lastEvent;\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassViewDelegate.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1336,0 +1336,5 @@\n+- (NSEvent*)lastEvent\n+{\n+    return lastEvent;\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassViewDelegate.m","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -432,0 +432,4 @@\n+            if ((jStyleMask&com_sun_glass_ui_Window_EXTENDED) != 0) {\n+                styleMask = styleMask | NSWindowStyleMaskTitled | NSWindowStyleMaskFullSizeContentView;\n+            }\n+\n@@ -457,0 +461,6 @@\n+        if ((jStyleMask & com_sun_glass_ui_Window_EXTENDED) != 0) {\n+            [window->nsWindow setTitlebarAppearsTransparent:YES];\n+            [window->nsWindow setToolbar:[NSToolbar new]];\n+            [window->nsWindow setToolbarStyle:NSWindowToolbarStyleUnifiedCompact];\n+        }\n+\n@@ -475,1 +485,2 @@\n-        window->isDecorated = (jStyleMask&com_sun_glass_ui_Window_TITLED) != 0;\n+        window->isDecorated = (jStyleMask&com_sun_glass_ui_Window_TITLED) != 0 ||\n+                              (jStyleMask&com_sun_glass_ui_Window_EXTENDED) != 0;\n@@ -1471,0 +1482,47 @@\n+\n+\/*\n+ * Class:     com_sun_glass_ui_mac_MacWindow\n+ * Method:    _performWindowDrag\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1performWindowDrag\n+(JNIEnv *env, jobject jWindow, jlong jPtr)\n+{\n+    LOG(\"Java_com_sun_glass_ui_mac_MacWindow__1performWindowDrag\");\n+    if (!jPtr) return;\n+\n+    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n+    GLASS_POOL_ENTER;\n+    {\n+        GlassWindow *window = getGlassWindow(env, jPtr);\n+        GlassViewDelegate* delegate = [window->view delegate];\n+        [window->nsWindow performWindowDragWithEvent:[delegate lastEvent]];\n+    }\n+    GLASS_POOL_EXIT;\n+    GLASS_CHECK_EXCEPTION(env);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_mac_MacWindow\n+ * Method:    _isRightToLeftLayoutDirection\n+ * Signature: ()Z;\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1isRightToLeftLayoutDirection\n+(JNIEnv *env, jobject self)\n+{\n+    LOG(\"Java_com_sun_glass_ui_mac_MacWindow__1isRightToLeftLayoutDirection\");\n+    jboolean result = false;\n+\n+    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n+    GLASS_POOL_ENTER;\n+    {\n+        NSString* preferredLanguage = [[NSLocale preferredLanguages] objectAtIndex:0];\n+        NSLocale* locale = [NSLocale localeWithLocaleIdentifier:preferredLanguage];\n+        NSString* languageCode = [locale objectForKey:NSLocaleLanguageCode];\n+        result = [NSLocale characterDirectionForLanguage:languageCode] == NSLocaleLanguageDirectionRightToLeft;\n+    }\n+    GLASS_POOL_EXIT;\n+    GLASS_CHECK_EXCEPTION(env);\n+\n+    return result;\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow.m","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+#define ABM_GETAUTOHIDEBAREX 0x0000000b \/\/ multimon aware autohide bars\n@@ -65,1 +66,2 @@\n-GlassWindow::GlassWindow(jobject jrefThis, bool isTransparent, bool isDecorated, bool isUnified, HWND parentOrOwner)\n+GlassWindow::GlassWindow(jobject jrefThis, bool isTransparent, bool isDecorated, bool isUnified,\n+                         bool isExtended, HWND parentOrOwner)\n@@ -77,0 +79,1 @@\n+    m_isExtended(isExtended),\n@@ -455,0 +458,10 @@\n+\n+            if (BOOL(wParam) && m_isExtended) {\n+                return HandleNCCalcSizeEvent(msg, wParam, lParam);\n+            }\n+            break;\n+        case WM_NCHITTEST: {\n+            LRESULT res;\n+            if (m_isExtended && HandleNCHitTestEvent(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), res)) {\n+                return res;\n+            }\n@@ -456,0 +469,1 @@\n+        }\n@@ -480,17 +494,1 @@\n-            if (IsEnabled()) {\n-                if (msg == WM_MOUSELEAVE && GetDelegateWindow()) {\n-                    \/\/ Skip generating MouseEvent.EXIT when entering FullScreen\n-                    return 0;\n-                }\n-                BOOL handled = HandleViewMouseEvent(GetHWND(), msg, wParam, lParam);\n-                if (handled && msg == WM_RBUTTONUP) {\n-                    \/\/ By default, DefWindowProc() sends WM_CONTEXTMENU from WM_LBUTTONUP\n-                    \/\/ Since DefWindowProc() is not called, call the mouse menu handler directly\n-                    HandleViewMenuEvent(GetHWND(), WM_CONTEXTMENU, (WPARAM) GetHWND(), ::GetMessagePos ());\n-                    \/\/::DefWindowProc(GetHWND(), msg, wParam, lParam);\n-                }\n-                if (handled) {\n-                    \/\/ Do not call the DefWindowProc() for mouse events that were handled\n-                    return 0;\n-                }\n-            } else {\n+            if (!IsEnabled()) {\n@@ -499,0 +497,2 @@\n+            } else if (HandleMouseEvents(msg, wParam, lParam)) {\n+                return 0;\n@@ -549,0 +549,11 @@\n+\n+            if (m_isExtended) {\n+                HandleNonClientMouseEvents(msg, wParam, lParam);\n+\n+                \/\/ We need to handle clicks on the min\/max\/close regions, as otherwise Windows will\n+                \/\/ draw very ugly buttons on top of our window.\n+                if (wParam == HTMINBUTTON || wParam == HTMAXBUTTON || wParam == HTCLOSE) {\n+                    return 0;\n+                }\n+            }\n+\n@@ -551,0 +562,18 @@\n+        case WM_NCLBUTTONUP:\n+        case WM_NCLBUTTONDBLCLK:\n+        case WM_NCRBUTTONUP:\n+        case WM_NCRBUTTONDBLCLK:\n+        case WM_NCMBUTTONUP:\n+        case WM_NCMBUTTONDBLCLK:\n+        case WM_NCXBUTTONUP:\n+        case WM_NCXBUTTONDBLCLK:\n+        case WM_NCMOUSELEAVE:\n+        case WM_NCMOUSEMOVE:\n+            if (m_isExtended) {\n+                HandleNonClientMouseEvents(msg, wParam, lParam);\n+\n+                if (wParam == HTMINBUTTON || wParam == HTMAXBUTTON || wParam == HTCLOSE) {\n+                    return 0;\n+                }\n+            }\n+            break;\n@@ -576,0 +605,37 @@\n+bool GlassWindow::HandleMouseEvents(UINT msg, WPARAM wParam, LPARAM lParam)\n+{\n+    if (msg == WM_MOUSELEAVE && GetDelegateWindow()) {\n+        \/\/ Skip generating MouseEvent.EXIT when entering FullScreen\n+        return true;\n+    }\n+\n+    BOOL handled = HandleViewMouseEvent(GetHWND(), msg, wParam, lParam);\n+    if (handled && msg == WM_RBUTTONUP) {\n+        \/\/ By default, DefWindowProc() sends WM_CONTEXTMENU from WM_LBUTTONUP\n+        \/\/ Since DefWindowProc() is not called, call the mouse menu handler directly\n+        HandleViewMenuEvent(GetHWND(), WM_CONTEXTMENU, (WPARAM) GetHWND(), ::GetMessagePos ());\n+        \/\/::DefWindowProc(GetHWND(), msg, wParam, lParam);\n+    }\n+\n+    if (handled) {\n+        \/\/ Do not call the DefWindowProc() for mouse events that were handled\n+        return true;\n+    }\n+\n+    return false;\n+}\n+\n+void GlassWindow::HandleNonClientMouseEvents(UINT msg, WPARAM wParam, LPARAM lParam)\n+{\n+    HandleViewNonClientMouseEvent(GetHWND(), msg, wParam, lParam);\n+    LRESULT result;\n+\n+    \/\/ If the right mouse button was released on a HTCAPTION area, we synthesize a WM_CONTEXTMENU event.\n+    \/\/ This allows JavaFX applications to respond to context menu events in the non-client header bar area.\n+    if (msg == WM_NCRBUTTONUP\n+            && HandleNCHitTestEvent(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), result)\n+            && result == HTCAPTION) {\n+        HandleViewMenuEvent(GetHWND(), WM_CONTEXTMENU, (WPARAM)GetHWND(), ::GetMessagePos());\n+    }\n+}\n+\n@@ -766,0 +832,79 @@\n+LRESULT GlassWindow::HandleNCCalcSizeEvent(UINT msg, WPARAM wParam, LPARAM lParam)\n+{\n+    \/\/ Capture the top and size before DefWindowProc applies the default frame.\n+    NCCALCSIZE_PARAMS *p = (NCCALCSIZE_PARAMS*)lParam;\n+    LONG originalTop = p->rgrc[0].top;\n+    RECT originalSize = p->rgrc[0];\n+\n+    \/\/ Apply the default window frame.\n+    LRESULT res = DefWindowProc(GetHWND(), msg, wParam, lParam);\n+    if (res != 0) {\n+        return res;\n+    }\n+\n+    \/\/ Restore the original top, which might have been overwritten by DefWindowProc.\n+    RECT newSize = p->rgrc[0];\n+    newSize.top = originalTop;\n+\n+    \/\/ A maximized window extends slightly beyond the screen, so we need to account for that\n+    \/\/ by adding the border width to the top.\n+    bool maximized = (::GetWindowLong(GetHWND(), GWL_STYLE) & WS_MAXIMIZE) != 0;\n+    if (maximized && !m_isInFullScreen) {\n+        newSize.top += ::GetSystemMetrics(SM_CXPADDEDBORDER) + ::GetSystemMetrics(SM_CYSIZEFRAME);\n+    }\n+\n+    \/\/ If we have an auto-hide taskbar, we need to reduce the size of a maximized or fullscreen\n+    \/\/ window a little bit where the taskbar is located, as otherwise the taskbar cannot be\n+    \/\/ summoned.\n+    HMONITOR monitor = ::MonitorFromWindow(GetHWND(), MONITOR_DEFAULTTONEAREST);\n+    if (monitor && (maximized || m_isInFullScreen)) {\n+        MONITORINFO monitorInfo = { 0 };\n+        monitorInfo.cbSize = sizeof(MONITORINFO);\n+        ::GetMonitorInfo(monitor, &monitorInfo);\n+\n+        APPBARDATA data = { 0 };\n+        data.cbSize = sizeof(data);\n+\n+        if ((::SHAppBarMessage(ABM_GETSTATE, &data) & ABS_AUTOHIDE) == ABS_AUTOHIDE) {\n+            data.rc = monitorInfo.rcMonitor;\n+            DWORD appBarMsg = ::IsWindows8OrGreater() ? ABM_GETAUTOHIDEBAREX : ABM_GETAUTOHIDEBAR;\n+\n+            \/\/ Reduce the window size by one pixel on the taskbar side.\n+            if ((data.uEdge = ABE_TOP), ::SHAppBarMessage(appBarMsg, &data) != NULL) {\n+                newSize.top += 1;\n+            } else if ((data.uEdge = ABE_BOTTOM), ::SHAppBarMessage(appBarMsg, &data) != NULL) {\n+                newSize.bottom -= 1;\n+            } else if ((data.uEdge = ABE_LEFT), ::SHAppBarMessage(appBarMsg, &data) != NULL) {\n+                newSize.left += 1;\n+            } else if ((data.uEdge = ABE_RIGHT), ::SHAppBarMessage(appBarMsg, &data) != NULL) {\n+                newSize.right -= 1;\n+            }\n+        }\n+    }\n+\n+    p->rgrc[0] = newSize;\n+    return 0;\n+}\n+\n+\/\/ Handling this message tells Windows which parts of the window are non-client regions.\n+\/\/ This enables window behaviors like dragging or snap layouts.\n+BOOL GlassWindow::HandleNCHitTestEvent(SHORT x, SHORT y, LRESULT& result)\n+{\n+    if (::DefWindowProc(GetHWND(), WM_NCHITTEST, 0, MAKELONG(x, y)) != HTCLIENT) {\n+        return FALSE;\n+    }\n+\n+    POINT pt = { x, y };\n+\n+    if (!::ScreenToClient(GetHWND(), &pt)) {\n+        return FALSE;\n+    }\n+\n+    JNIEnv* env = GetEnv();\n+    jint res = env->CallIntMethod(m_grefThis, javaIDs.WinWindow.nonClientHitTest, pt.x, pt.y);\n+    CheckAndClearException(env);\n+    result = LRESULT(res);\n+\n+    return TRUE;\n+}\n+\n@@ -1090,0 +1235,42 @@\n+void GlassWindow::ShowSystemMenu(int x, int y)\n+{\n+    WINDOWPLACEMENT placement;\n+    if (!::GetWindowPlacement(GetHWND(), &placement)) {\n+        return;\n+    }\n+\n+    HMENU systemMenu = GetSystemMenu(GetHWND(), FALSE);\n+    bool maximized = placement.showCmd == SW_SHOWMAXIMIZED;\n+\n+    MENUITEMINFO menuItemInfo { sizeof(MENUITEMINFO) };\n+    menuItemInfo.fMask = MIIM_STATE;\n+    menuItemInfo.fType = MFT_STRING;\n+\n+    menuItemInfo.fState = maximized ? MF_ENABLED : MF_DISABLED;\n+    SetMenuItemInfo(systemMenu, SC_RESTORE, FALSE, &menuItemInfo);\n+\n+    menuItemInfo.fState = maximized ? MF_DISABLED : MF_ENABLED;\n+    SetMenuItemInfo(systemMenu, SC_MOVE, FALSE, &menuItemInfo);\n+\n+    menuItemInfo.fState = maximized ? MF_DISABLED : MF_ENABLED;\n+    SetMenuItemInfo(systemMenu, SC_SIZE, FALSE, &menuItemInfo);\n+\n+    menuItemInfo.fState = MF_ENABLED;\n+    SetMenuItemInfo(systemMenu, SC_MINIMIZE, FALSE, &menuItemInfo);\n+\n+    menuItemInfo.fState = maximized ? MF_DISABLED : MF_ENABLED;\n+    SetMenuItemInfo(systemMenu, SC_MAXIMIZE, FALSE, &menuItemInfo);\n+\n+    menuItemInfo.fState = MF_ENABLED;\n+    SetMenuItemInfo(systemMenu, SC_CLOSE, FALSE, &menuItemInfo);\n+    SetMenuDefaultItem(systemMenu, UINT_MAX, FALSE);\n+\n+    POINT ptAbs = { x, y };\n+    ::ClientToScreen(GetHWND(), &ptAbs);\n+\n+    BOOL menuItem = TrackPopupMenu(systemMenu, TPM_RETURNCMD, ptAbs.x, ptAbs.y, 0, GetHWND(), NULL);\n+    if (menuItem != 0) {\n+        PostMessage(GetHWND(), WM_SYSCOMMAND, menuItem, 0);\n+    }\n+}\n+\n@@ -1148,0 +1335,4 @@\n+\n+     javaIDs.WinWindow.nonClientHitTest = env->GetMethodID(cls, \"nonClientHitTest\", \"(II)I\");\n+     ASSERT(javaIDs.WinWindow.nonClientHitTest);\n+     if (env->ExceptionCheck()) return;\n@@ -1167,0 +1358,4 @@\n+        if (mask & com_sun_glass_ui_Window_EXTENDED) {\n+            mask |= com_sun_glass_ui_Window_TITLED;\n+        }\n+\n@@ -1209,0 +1404,1 @@\n+                (mask & com_sun_glass_ui_Window_EXTENDED) != 0,\n@@ -1911,0 +2107,23 @@\n+\/*\n+ * Class:     com_sun_glass_ui_win_WinWindow\n+ * Method:    _showSystemMenu\n+ * Signature: (JII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinWindow__1showSystemMenu\n+    (JNIEnv *env, jobject jThis, jlong ptr, jint x, jint y)\n+{\n+    ENTER_MAIN_THREAD()\n+    {\n+        GlassWindow *pWindow = GlassWindow::FromHandle(hWnd);\n+        if (pWindow) {\n+            pWindow->ShowSystemMenu(x, y);\n+        }\n+    }\n+    jint x, y;\n+    LEAVE_MAIN_THREAD_WITH_hWnd;\n+\n+    ARG(x) = x;\n+    ARG(y) = y;\n+    PERFORM();\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassWindow.cpp","additions":238,"deletions":19,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,2 @@\n-    GlassWindow(jobject jrefThis, bool isTransparent, bool isDecorated, bool isUnified, HWND parentOrOwner);\n+    GlassWindow(jobject jrefThis, bool isTransparent, bool isDecorated, bool isUnified,\n+                bool isExtended, HWND parentOrOwner);\n@@ -105,0 +106,1 @@\n+    void ShowSystemMenu(int x, int y);\n@@ -147,0 +149,1 @@\n+    const bool m_isExtended;\n@@ -187,0 +190,4 @@\n+    bool HandleMouseEvents(UINT msg, WPARAM wParam, LPARAM lParam);\n+    void HandleNonClientMouseEvents(UINT msg, WPARAM wParam, LPARAM lParam);\n+    LRESULT HandleNCCalcSizeEvent(UINT msg, WPARAM wParam, LPARAM lParam);\n+    BOOL HandleNCHitTestEvent(SHORT, SHORT, LRESULT&);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassWindow.h","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -493,0 +493,3 @@\n+    struct {\n+        jmethodID nonClientHitTest;\n+    } WinWindow;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/Utils.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -937,0 +937,122 @@\n+void ViewContainer::HandleViewNonClientMouseEvent(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\n+{\n+    if (!GetGlassView()) {\n+        return;\n+    }\n+\n+    int type = 0;\n+    int button = com_sun_glass_events_MouseEvent_BUTTON_NONE;\n+    POINT pt;   \/\/ client coords\n+\n+    if (msg == WM_NCMOUSELEAVE) {\n+        type = com_sun_glass_events_MouseEvent_NC_EXIT;\n+        pt.x = GET_X_LPARAM(lParam);\n+        pt.y = GET_Y_LPARAM(lParam);\n+        ::MapWindowPoints(NULL, hwnd, &pt, 1);\n+        m_bTrackingMouse = FALSE;\n+        m_lastMouseMovePosition = -1;\n+    } else if (msg >= WM_NCMOUSEMOVE && msg <= WM_NCXBUTTONDBLCLK) {\n+        pt.x = GET_X_LPARAM(lParam);\n+        pt.y = GET_Y_LPARAM(lParam);\n+        ::MapWindowPoints(NULL, hwnd, &pt, 1);\n+\n+        switch (msg) {\n+            case WM_NCMOUSEMOVE:\n+                if (lParam == m_lastMouseMovePosition) {\n+                    \/\/ Avoid sending synthetic NC_MOVE events if\n+                    \/\/ the pointer hasn't moved actually.\n+                    \/\/ Just consume the messages.\n+                    return;\n+                }\n+\n+                m_lastMouseMovePosition = lParam;\n+                type = com_sun_glass_events_MouseEvent_NC_MOVE;\n+                break;\n+            case WM_NCLBUTTONDOWN:\n+                type = com_sun_glass_events_MouseEvent_NC_DOWN;\n+                button = com_sun_glass_events_MouseEvent_BUTTON_LEFT;\n+                break;\n+            case WM_NCLBUTTONUP:\n+                type = com_sun_glass_events_MouseEvent_NC_UP;\n+                button = com_sun_glass_events_MouseEvent_BUTTON_LEFT;\n+                break;\n+            case WM_NCRBUTTONDOWN:\n+                type = com_sun_glass_events_MouseEvent_NC_DOWN;\n+                button = com_sun_glass_events_MouseEvent_BUTTON_RIGHT;\n+                break;\n+            case WM_NCRBUTTONUP:\n+                type = com_sun_glass_events_MouseEvent_NC_UP;\n+                button = com_sun_glass_events_MouseEvent_BUTTON_RIGHT;\n+                break;\n+            case WM_NCMBUTTONDOWN:\n+                type = com_sun_glass_events_MouseEvent_NC_DOWN;\n+                button = com_sun_glass_events_MouseEvent_BUTTON_OTHER;\n+                break;\n+            case WM_NCMBUTTONUP:\n+                type = com_sun_glass_events_MouseEvent_NC_UP;\n+                button = com_sun_glass_events_MouseEvent_BUTTON_OTHER;\n+                break;\n+            case WM_NCXBUTTONDOWN:\n+                type = com_sun_glass_events_MouseEvent_NC_DOWN;\n+                button = GET_XBUTTON_WPARAM(wParam) == XBUTTON1\n+                    ? com_sun_glass_events_MouseEvent_BUTTON_BACK\n+                    : com_sun_glass_events_MouseEvent_BUTTON_FORWARD;\n+                break;\n+            case WM_NCXBUTTONUP:\n+                type = com_sun_glass_events_MouseEvent_NC_UP;\n+                button = GET_XBUTTON_WPARAM(wParam) == XBUTTON1\n+                    ? com_sun_glass_events_MouseEvent_BUTTON_BACK\n+                    : com_sun_glass_events_MouseEvent_BUTTON_FORWARD;\n+                break;\n+        }\n+    }\n+\n+    \/\/ Event was not handled\n+    if (type == 0) {\n+        return;\n+    }\n+\n+    \/\/ get screen coords\n+    POINT ptAbs = pt;\n+    ::ClientToScreen(hwnd, &ptAbs);\n+\n+    \/\/ unmirror the x coordinate\n+    LONG style = ::GetWindowLong(hwnd, GWL_EXSTYLE);\n+    if (style & WS_EX_LAYOUTRTL) {\n+        RECT rect = {0};\n+        ::GetClientRect(hwnd, &rect);\n+        pt.x = max(0, rect.right - rect.left) - pt.x;\n+    }\n+\n+    jint jModifiers = GetModifiers();\n+    jboolean isSynthesized = jboolean(IsTouchEvent());\n+    JNIEnv* env = GetEnv();\n+\n+    if (!m_bTrackingMouse && type != com_sun_glass_events_MouseEvent_NC_EXIT) {\n+        TRACKMOUSEEVENT trackData;\n+        trackData.cbSize = sizeof(trackData);\n+        trackData.dwFlags = TME_LEAVE | TME_NONCLIENT;\n+        trackData.hwndTrack = hwnd;\n+        trackData.dwHoverTime = HOVER_DEFAULT;\n+\n+        if (::TrackMouseEvent(&trackData)) {\n+            \/\/ Mouse tracking will be canceled automatically upon receiving WM_NCMOUSELEAVE\n+            m_bTrackingMouse = TRUE;\n+        }\n+\n+        env->CallVoidMethod(GetView(), javaIDs.View.notifyMouse,\n+            com_sun_glass_events_MouseEvent_NC_ENTER,\n+            com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+            pt.x, pt.y, ptAbs.x, ptAbs.y,\n+            jModifiers, JNI_FALSE, isSynthesized);\n+        CheckAndClearException(env);\n+    }\n+\n+    env->CallVoidMethod(GetView(), javaIDs.View.notifyMouse,\n+        type, button, pt.x, pt.y, ptAbs.x, ptAbs.y,\n+        jModifiers,\n+        type == com_sun_glass_events_MouseEvent_NC_UP && button == com_sun_glass_events_MouseEvent_BUTTON_RIGHT,\n+        isSynthesized);\n+    CheckAndClearException(env);\n+}\n+\n@@ -951,1 +1073,1 @@\n-    trackData.dwFlags = TME_LEAVE | TME_CANCEL;\n+    trackData.dwFlags = TME_LEAVE | TME_NONCLIENT | TME_CANCEL;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/ViewContainer.cpp","additions":123,"deletions":1,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+        void HandleViewNonClientMouseEvent(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/ViewContainer.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,2 @@\n+#include <shellapi.h>\n+#include <versionhelpers.h>\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/common.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+.window-button-container {\n+    -fx-button-placement: right;\n+    -fx-allow-rtl: true;\n+}\n+\n+.minimize-button,\n+.maximize-button,\n+.close-button {\n+    -fx-background-color: #00000009;\n+    -fx-background-radius: 15;\n+    -fx-background-insets: 6;\n+    -fx-pref-width: 36;\n+    -fx-pref-height: 36;\n+}\n+\n+.minimize-button.dark,\n+.maximize-button.dark,\n+.close-button.dark {\n+    -fx-background-color: #ffffff09;\n+}\n+\n+.minimize-button:active,\n+.maximize-button:active,\n+.close-button:active {\n+    -fx-background-color: #00000015;\n+}\n+\n+.minimize-button.dark:active,\n+.maximize-button.dark:active,\n+.close-button.dark:active {\n+    -fx-background-color: #ffffff15\n+}\n+\n+.minimize-button:active:hover,\n+.maximize-button:active:hover,\n+.close-button:active:hover {\n+    -fx-background-color: #00000025;\n+}\n+\n+.minimize-button.dark:active:hover,\n+.maximize-button.dark:active:hover,\n+.close-button.dark:active:hover {\n+    -fx-background-color: #ffffff25;\n+}\n+\n+.minimize-button:pressed,\n+.maximize-button:pressed,\n+.close-button:pressed {\n+    -fx-background-color: #00000035 !important;\n+}\n+\n+.minimize-button.dark:pressed,\n+.maximize-button.dark:pressed,\n+.close-button.dark:pressed {\n+    -fx-background-color: #ffffff35 !important;\n+}\n+\n+.minimize-button > .glyph,\n+.maximize-button > .glyph,\n+.close-button > .glyph {\n+    -fx-background-color: #777;\n+    -fx-background-insets: 6 -6 -6 6;\n+    -fx-scale-shape: false;\n+    -fx-position-shape: false;\n+}\n+\n+.minimize-button:active > .glyph,\n+.maximize-button:active > .glyph,\n+.close-button:active > .glyph {\n+    -fx-background-color: #333;\n+}\n+\n+.minimize-button.dark:active > .glyph,\n+.maximize-button.dark:active > .glyph,\n+.close-button.dark:active > .glyph {\n+    -fx-background-color: white;\n+}\n+\n+.maximize-button:disabled {\n+    -fx-background-color: transparent;\n+}\n+\n+.maximize-button:disabled > .glyph {\n+    -fx-background-color: #777;\n+}\n+\n+.minimize-button > .glyph {\n+    -fx-shape: \"m 8,13 v 1 h 8 v -1 z\";\n+}\n+\n+.maximize-button > .glyph {\n+    -fx-shape: \"M 15,8.934 V 15 H 9 V 8.934 Z M 8,8 v 8 h 8 V 8 Z\";\n+}\n+\n+.maximize-button.restore > .glyph {\n+    -fx-shape: \"M 10 7 L 10 8 L 16 8 L 16 14 L 17 14 L 17 7 L 10 7 z M 8 9 L 8 16 L 15 16 L 15 9 L 8 9 z M 9 9.9238281 L 14 9.9238281 L 14 15 L 9 15 L 9 9.9238281 z\";\n+}\n+\n+.close-button > .glyph {\n+    -fx-shape: \"m 8.1464844,8.1464844 a 0.5,0.5 0 0 0 0,0.7070312 L 11.292969,12 8.1464844,15.146484 a 0.5,0.5 0 0 0 0,0.707032 0.5,0.5 0 0 0 0.7070312,0 L 12,12.707031 l 3.146484,3.146485 a 0.5,0.5 0 0 0 0.707032,0 0.5,0.5 0 0 0 0,-0.707032 L 12.707031,12 15.853516,8.8535156 a 0.5,0.5 0 0 0 0,-0.7070312 0.5,0.5 0 0 0 -0.707032,0 L 12,11.292969 8.8535156,8.1464844 a 0.5,0.5 0 0 0 -0.7070312,0 z\";\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/glass\/ui\/gtk\/WindowDecorationGnome.css","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+.window-button-container {\n+    -fx-button-placement: right;\n+    -fx-allow-rtl: true;\n+}\n+\n+.minimize-button,\n+.maximize-button,\n+.close-button {\n+    -fx-background-color: transparent;\n+    -fx-background-radius: 13;\n+    -fx-background-insets: 8;\n+    -fx-pref-width: 36;\n+    -fx-pref-height: 36;\n+}\n+\n+.minimize-button > .glyph,\n+.maximize-button > .glyph,\n+.close-button > .glyph {\n+    -fx-background-color: #1d1d1e;\n+    -fx-background-insets: 8 -8 -8 8;\n+    -fx-scale-shape: false;\n+    -fx-position-shape: false;\n+}\n+\n+.minimize-button.dark > .glyph,\n+.maximize-button.dark > .glyph,\n+.close-button.dark > .glyph {\n+    -fx-background-color: #ced0d6;\n+}\n+\n+.minimize-button:hover,\n+.maximize-button:hover,\n+.close-button:hover {\n+    -fx-background-color: #27292d;\n+}\n+\n+.minimize-button.dark:hover,\n+.maximize-button.dark:hover,\n+.close-button.dark:hover {\n+    -fx-background-color: #dfe1e6;\n+}\n+\n+.minimize-button:hover > .glyph,\n+.maximize-button:hover > .glyph,\n+.close-button:hover > .glyph {\n+    -fx-background-color: #ced0d6;\n+}\n+\n+.minimize-button.dark:hover > .glyph,\n+.maximize-button.dark:hover > .glyph,\n+.close-button.dark:hover > .glyph {\n+    -fx-background-color: #393b40;\n+}\n+\n+.minimize-button:pressed,\n+.maximize-button:pressed,\n+.close-button:pressed {\n+    -fx-background-color: #474b52 !important;\n+}\n+\n+.minimize-button.dark:pressed,\n+.maximize-button.dark:pressed,\n+.close-button.dark:pressed {\n+    -fx-background-color: #6c7076 !important;\n+}\n+\n+.maximize-button:disabled {\n+    -fx-managed: false;\n+    visibility: hidden;\n+}\n+\n+.minimize-button > .glyph {\n+    -fx-shape: \"m 5,7.5 a 0.5,0.5 0 0 0 -0.3535156,0.1464844 0.5,0.5 0 0 0 0,0.7070312 l 5,5.0000004 a 0.50005,0.50005 0 0 0 0.7070316,0 l 5,-5.0000004 a 0.5,0.5 0 0 0 0,-0.7070312 0.5,0.5 0 0 0 -0.707032,0 L 10,12.292969 5.3535156,7.6464844 A 0.5,0.5 0 0 0 5,7.5 Z\";\n+}\n+\n+.maximize-button > .glyph {\n+    -fx-shape: \"m 9.6464844,6.6464844 -5,4.9999996 a 0.5,0.5 0 0 0 0,0.707032 0.5,0.5 0 0 0 0.7070312,0 L 10,7.7070312 14.646484,12.353516 a 0.5,0.5 0 0 0 0.707032,0 0.5,0.5 0 0 0 0,-0.707032 l -5,-4.9999996 a 0.50005,0.50005 0 0 0 -0.7070316,0 z\";\n+}\n+\n+.maximize-button.restore > .glyph {\n+    -fx-shape: \"m 9.6464844,5.1464844 -4.5,4.5 a 0.50005,0.50005 0 0 0 0,0.7070316 l 4.5,4.5 a 0.50005,0.50005 0 0 0 0.7070316,0 l 4.5,-4.5 a 0.50005,0.50005 0 0 0 0,-0.7070316 l -4.5,-4.5 a 0.50005,0.50005 0 0 0 -0.7070316,0 z M 10,6.2070312 13.792969,10 10,13.792969 6.2070312,10 Z\";\n+}\n+\n+.close-button > .glyph {\n+    -fx-shape: \"m 6,5.5 a 0.5,0.5 0 0 0 -0.3535156,0.1464844 0.5,0.5 0 0 0 0,0.7070312 L 9.2929688,10 5.6464844,13.646484 a 0.5,0.5 0 0 0 0,0.707032 0.5,0.5 0 0 0 0.7070312,0 L 10,10.707031 l 3.646484,3.646485 a 0.5,0.5 0 0 0 0.707032,0 0.5,0.5 0 0 0 0,-0.707032 L 10.707031,10 14.353516,6.3535156 a 0.5,0.5 0 0 0 0,-0.7070312 0.5,0.5 0 0 0 -0.707032,0 L 10,9.2929688 6.3535156,5.6464844 A 0.5,0.5 0 0 0 6,5.5 Z\";\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/glass\/ui\/gtk\/WindowDecorationKDE.css","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+.window-button-container {\n+    -fx-button-placement: right;\n+    -fx-allow-rtl: true;\n+}\n+\n+.minimize-button,\n+.maximize-button,\n+.close-button {\n+    -fx-background-color: transparent;\n+    -fx-pref-width: 46;\n+    -fx-pref-height: 29;\n+}\n+\n+.minimize-button:hover,\n+.maximize-button:hover {\n+    -fx-background-color: #00000015;\n+}\n+\n+.minimize-button.dark:hover,\n+.maximize-button.dark:hover {\n+    -fx-background-color: #ffffff15;\n+}\n+\n+.close-button:hover {\n+    -fx-background-color: #c42b1c;\n+}\n+\n+.minimize-button:pressed,\n+.maximize-button:pressed,\n+.close-button:pressed {\n+    -fx-opacity: 0.8;\n+}\n+\n+.minimize-button > .glyph,\n+.maximize-button > .glyph,\n+.close-button > .glyph {\n+    -fx-background-color: #777;\n+    -fx-scale-shape: false;\n+}\n+\n+.minimize-button:active > .glyph,\n+.maximize-button:active > .glyph,\n+.close-button:active > .glyph {\n+    -fx-background-color: black;\n+}\n+\n+.minimize-button.dark:active > .glyph,\n+.maximize-button.dark:active > .glyph,\n+.close-button.dark:active > .glyph {\n+    -fx-background-color: white;\n+}\n+\n+.close-button:hover > .glyph {\n+    -fx-background-color: white;\n+}\n+\n+.minimize-button.dark:pressed > .glyph {\n+    -fx-background-color: white;\n+}\n+\n+.maximize-button:disabled {\n+    -fx-background-color: transparent !important;\n+}\n+\n+.maximize-button:disabled > .glyph {\n+    -fx-background-color: #00000020 !important;\n+}\n+\n+.maximize-button.dark:disabled > .glyph {\n+    -fx-background-color: #ffffff20 !important;\n+}\n+\n+.minimize-button > .glyph {\n+    -fx-shape: \"m 0.42342443,4.6755 q -0.0871756,0 -0.16397319,-0.0332 Q 0.18265374,4.6091 0.1245366,4.551 0.06641952,4.4929 0.03320975,4.41608 0,4.33925 0,4.25208 0,4.16488 0.03320975,4.0881 0.06641952,4.0113 0.1245366,3.95112 0.1826537,3.89092 0.25945124,3.85772 0.33624881,3.8245 0.42342443,3.8245 H 8.078274 q 0.087175,0 0.1639731,0.0332 0.076797,0.0332 0.1349147,0.0934 0.058117,0.0602 0.091327,0.13698 0.033209,0.0768 0.033209,0.16397 0,0.0872 -0.03321,0.16397 -0.03321,0.0768 -0.091327,0.13492 -0.058117,0.0581 -0.1349147,0.0913 -0.076797,0.0332 -0.1639731,0.0332 z\";\n+}\n+\n+.maximize-button > .glyph {\n+    -fx-shape: \"M 1.253418,8.5 Q 1.0043945,8.5 0.77612305,8.3983154 0.54785156,8.2966309 0.37561035,8.1243896 0.20336914,7.9521484 0.10168457,7.723877 0,7.4956055 0,7.246582 V 1.253418 Q 0,1.0043945 0.10168457,0.77612305 0.20336914,0.54785156 0.37561035,0.37561035 0.54785156,0.20336914 0.77612305,0.10168457 1.0043945,0 1.253418,0 H 7.246582 Q 7.4956055,0 7.723877,0.10168457 7.9521484,0.20336914 8.1243896,0.37561035 8.2966309,0.54785156 8.3983154,0.77612305 8.5,1.0043945 8.5,1.253418 V 7.246582 Q 8.5,7.4956055 8.3983154,7.723877 8.2966309,7.9521484 8.1243896,8.1243896 7.9521484,8.2966309 7.723877,8.3983154 7.4956055,8.5 7.246582,8.5 Z M 7.2258301,7.6491699 q 0.087158,0 0.1639404,-0.033203 0.076782,-0.033203 0.1348877,-0.091309 0.058105,-0.058105 0.091309,-0.1348877 0.033203,-0.076782 0.033203,-0.1639404 V 1.2741699 q 0,-0.087158 -0.033203,-0.1639404 Q 7.5827637,1.0334473 7.5246582,0.9753418 7.4665527,0.91723633 7.3897705,0.8840332 7.3129883,0.85083008 7.2258301,0.85083008 H 1.2741699 q -0.087158,0 -0.1639404,0.0332031 -0.076782,0.0332031 -0.1348877,0.0913086 Q 0.9172363,1.0334473 0.8840332,1.1102295 0.8508301,1.1870115 0.8508301,1.2741699 v 5.9516602 q 0,0.087158 0.0332031,0.1639404 0.0332031,0.076782 0.0913086,0.1348877 0.0581055,0.058105 0.1348877,0.091309 0.076782,0.033203 0.1639404,0.033203 z\";\n+}\n+\n+.maximize-button.restore > .glyph {\n+    -fx-shape: \"m 7.6491699,2.5192871 q 0,-0.3444824 -0.1369629,-0.6495361 Q 7.3752441,1.5646973 7.1407471,1.338501 6.90625,1.1123047 6.5970459,0.98156738 6.2878418,0.85083008 5.9475098,0.85083008 H 1.7722168 Q 1.838623,0.65991211 1.9589844,0.50219727 2.0793457,0.34448242 2.2370605,0.23242188 2.3947754,0.12036133 2.5836182,0.06018066 2.7724609,0 2.9758301,0 H 5.9475098 Q 6.4746094,0 6.9394531,0.20129395 7.4042969,0.40258789 7.7508545,0.74707031 8.0974121,1.0915527 8.2987061,1.5563965 8.5,2.0212402 8.5,2.5483398 V 5.5241699 Q 8.5,5.7275391 8.4398193,5.9163818 8.3796387,6.1052246 8.2675781,6.2629395 8.1555176,6.4206543 7.9978027,6.5410156 7.8400879,6.661377 7.6491699,6.7277832 Z M 1.253418,8.5 Q 1.0043945,8.5 0.77612305,8.3983154 0.54785156,8.2966309 0.37561035,8.1243896 0.20336914,7.9521484 0.10168457,7.723877 0,7.4956055 0,7.246582 V 2.9550781 Q 0,2.7019043 0.10168457,2.475708 0.20336914,2.2495117 0.37561035,2.0772705 0.54785156,1.9050293 0.77404785,1.8033447 1.0002441,1.7016602 1.253418,1.7016602 h 4.2915039 q 0.2531738,0 0.4814453,0.1016845 0.2282715,0.1016846 0.3984375,0.2718506 0.170166,0.170166 0.2718506,0.3984375 0.1016845,0.2282715 0.1016845,0.4814453 V 7.246582 q 0,0.2531739 -0.1016845,0.4793701 Q 6.5949707,7.9521484 6.4227295,8.1243896 6.2504883,8.2966309 6.024292,8.3983154 5.7980957,8.5 5.5449219,8.5 Z M 5.5241699,7.6491699 q 0.087158,0 0.1639405,-0.033203 0.076782,-0.033203 0.1369628,-0.091309 0.060181,-0.058105 0.093384,-0.1348877 0.033203,-0.076782 0.033203,-0.1639404 v -4.25 q 0,-0.087158 -0.033203,-0.1660156 Q 5.8852539,2.730957 5.8271484,2.6728516 5.769043,2.6147461 5.6901855,2.581543 5.6113281,2.5483398 5.5241699,2.5483398 h -4.25 q -0.087158,0 -0.1639404,0.033203 -0.076782,0.033203 -0.1348877,0.093384 -0.0581055,0.060181 -0.0913086,0.1369628 -0.0332031,0.076782 -0.0332031,0.1639405 v 4.25 q 0,0.087158 0.0332031,0.1639404 0.0332031,0.076782 0.0913086,0.1348877 0.0581055,0.058105 0.1348877,0.091309 0.076782,0.033203 0.1639404,0.033203 z\";\n+}\n+\n+.close-button > .glyph {\n+    -fx-shape: \"M 4.25,4.8518066 0.7263184,8.3754883 Q 0.6018066,8.5 0.4274902,8.5 0.2448731,8.5 0.1224365,8.3775635 0,8.255127 0,8.0725098 0,7.8981934 0.1245117,7.7736816 L 3.6481934,4.25 0.1245117,0.72631836 Q 0,0.60180664 0,0.42333984 0,0.33618164 0.033203,0.25732422 0.066406,0.17846682 0.124512,0.12243652 0.182617,0.06640625 0.2614749,0.03320312 0.340332,0 0.4274902,0 0.6018066,0 0.7263184,0.12451172 L 4.25,3.6481934 7.7736816,0.12451172 Q 7.8981934,0 8.0766602,0 q 0.087158,0 0.1639404,0.03320312 0.076782,0.03320313 0.1348877,0.0913086 0.058105,0.0581055 0.091309,0.13488769 Q 8.5,0.33618164 8.5,0.42333984 8.5,0.60180664 8.3754883,0.72631836 L 4.8518066,4.25 8.3754883,7.7736816 Q 8.5,7.8981934 8.5,8.0725098 8.5,8.1596678 8.466797,8.2385254 8.433594,8.3173824 8.377564,8.3754883 8.321534,8.4335933 8.2426763,8.4667973 8.1638193,8.5 8.0766607,8.5 7.8981939,8.5 7.7736821,8.3754883 Z\";\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/glass\/ui\/win\/WindowDecoration.css","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -4,0 +4,1 @@\n+--add-exports javafx.base\/com.sun.javafx.binding=ALL-UNNAMED\n@@ -56,0 +57,1 @@\n+--add-opens javafx.graphics\/javafx.stage=ALL-UNNAMED\n","filename":"modules\/javafx.graphics\/src\/test\/addExports","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,349 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.glass.ui;\n+\n+import com.sun.glass.ui.WindowControlsOverlay;\n+import com.sun.javafx.binding.ObjectConstant;\n+import javafx.beans.value.ObservableValue;\n+import javafx.geometry.Dimension2D;\n+import javafx.geometry.HorizontalDirection;\n+import javafx.geometry.NodeOrientation;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Stage;\n+import org.junit.jupiter.api.Test;\n+import test.util.ReflectionUtils;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class WindowControlsOverlayTest {\n+\n+    \/**\n+     * Asserts that the buttons are laid out on the right side of the control (left-to-right orientation).\n+     *\/\n+    @Test\n+    void rightPlacement() {\n+        var overlay = new WindowControlsOverlay(getStylesheet(\"\"\"\n+                .window-button-container { -fx-button-placement: right; }\n+                .window-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"));\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertSize(overlay, 200, 100);\n+        assertLayoutBounds(children.get(0), 140, 0, 20, 10);\n+        assertLayoutBounds(children.get(1), 160, 0, 20, 10);\n+        assertLayoutBounds(children.get(2), 180, 0, 20, 10);\n+        assertEquals(HorizontalDirection.RIGHT, overlay.metricsProperty().get().placement());\n+        assertEquals(new Dimension2D(60, 10), overlay.metricsProperty().get().size());\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out on the left side of the control (right-to-left orientation).\n+     *\/\n+    @Test\n+    void rightPlacement_rightToLeft() {\n+        var overlay = new WindowControlsOverlay(getStylesheet(\"\"\"\n+                .window-button-container { -fx-button-placement: right; }\n+                .window-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"));\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertSize(overlay, 200, 100);\n+        assertLayoutBounds(children.get(0), 40, 0, 20, 10);\n+        assertLayoutBounds(children.get(1), 20, 0, 20, 10);\n+        assertLayoutBounds(children.get(2), 0, 0, 20, 10);\n+        assertEquals(HorizontalDirection.LEFT, overlay.metricsProperty().get().placement());\n+        assertEquals(new Dimension2D(60, 10), overlay.metricsProperty().get().size());\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out on the left side of the control (left-to-right orientation).\n+     *\/\n+    @Test\n+    void leftPlacement() {\n+        var overlay = new WindowControlsOverlay(getStylesheet(\"\"\"\n+                .window-button-container { -fx-button-placement: left; }\n+                .window-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"));\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertSize(overlay, 200, 100);\n+        assertLayoutBounds(children.get(0), 0, 0, 20, 10);\n+        assertLayoutBounds(children.get(1), 20, 0, 20, 10);\n+        assertLayoutBounds(children.get(2), 40, 0, 20, 10);\n+        assertEquals(HorizontalDirection.LEFT, overlay.metricsProperty().get().placement());\n+        assertEquals(new Dimension2D(60, 10), overlay.metricsProperty().get().size());\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out on the right side of the control (right-to-left orientation).\n+     *\/\n+    @Test\n+    void leftPlacement_rightToLeft() {\n+        var overlay = new WindowControlsOverlay(getStylesheet(\"\"\"\n+                .window-button-container { -fx-button-placement: left; }\n+                .window-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"));\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertSize(overlay, 200, 100);\n+        assertLayoutBounds(children.get(0), 180, 0, 20, 10);\n+        assertLayoutBounds(children.get(1), 160, 0, 20, 10);\n+        assertLayoutBounds(children.get(2), 140, 0, 20, 10);\n+        assertEquals(HorizontalDirection.RIGHT, overlay.metricsProperty().get().placement());\n+        assertEquals(new Dimension2D(60, 10), overlay.metricsProperty().get().size());\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out in a custom order (left-to-right orientation).\n+     *\/\n+    @Test\n+    void customButtonOrder() {\n+        var overlay = new WindowControlsOverlay(getStylesheet(\"\"\"\n+                .window-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+                .minimize-button { -fx-button-order: 5; }\n+                .maximize-button { -fx-button-order: 1; }\n+                .close-button { -fx-button-order: 3; }\n+            \"\"\"));\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertTrue(children.get(0).getStyleClass().contains(\"minimize-button\"));\n+        assertLayoutBounds(children.get(0), 180, 0, 20, 10);\n+        assertTrue(children.get(1).getStyleClass().contains(\"maximize-button\"));\n+        assertLayoutBounds(children.get(1), 140, 0, 20, 10);\n+        assertTrue(children.get(2).getStyleClass().contains(\"close-button\"));\n+        assertLayoutBounds(children.get(2), 160, 0, 20, 10);\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out in a custom order (right-to-left orientation).\n+     *\/\n+    @Test\n+    void customButtonOrder_rightToLeft() {\n+        var overlay = new WindowControlsOverlay(getStylesheet(\"\"\"\n+                .window-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+                .minimize-button { -fx-button-order: 5; }\n+                .maximize-button { -fx-button-order: 1; }\n+                .close-button { -fx-button-order: 3; }\n+            \"\"\"));\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertTrue(children.get(0).getStyleClass().contains(\"minimize-button\"));\n+        assertLayoutBounds(children.get(0), 0, 0, 20, 10);\n+        assertTrue(children.get(1).getStyleClass().contains(\"maximize-button\"));\n+        assertLayoutBounds(children.get(1), 40, 0, 20, 10);\n+        assertTrue(children.get(2).getStyleClass().contains(\"close-button\"));\n+        assertLayoutBounds(children.get(2), 20, 0, 20, 10);\n+    }\n+\n+    \/**\n+     * Asserts that the buttons are laid out on the right, even though the node orientation is right-to-left.\n+     *\/\n+    @Test\n+    void disallowRightToLeft() {\n+        var overlay = new WindowControlsOverlay(getStylesheet(\"\"\"\n+                .window-button-container { -fx-button-placement: right; -fx-allow-rtl: false; }\n+                .window-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"));\n+\n+        var unused = new Scene(overlay);\n+        var children = overlay.getChildrenUnmodifiable();\n+        overlay.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertLayoutBounds(children.get(0), 140, 0, 20, 10);\n+        assertLayoutBounds(children.get(1), 160, 0, 20, 10);\n+        assertLayoutBounds(children.get(2), 180, 0, 20, 10);\n+        assertEquals(HorizontalDirection.RIGHT, overlay.metricsProperty().get().placement());\n+        assertEquals(new Dimension2D(60, 10), overlay.metricsProperty().get().size());\n+    }\n+\n+    @Test\n+    void activePseudoClassCorrespondsToStageFocusedProperty() {\n+        var overlay = new WindowControlsOverlay(getStylesheet(\"\"\"\n+                .window-button-container { -fx-button-placement: right; }\n+                .window-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"));\n+\n+        var scene = new Scene(overlay);\n+        var stage = new Stage();\n+        stage.setScene(scene);\n+        stage.show();\n+\n+        assertTrue(stage.isFocused());\n+        assertTrue(overlay.getChildrenUnmodifiable().get(0).getPseudoClassStates().stream().anyMatch(\n+                pc -> pc.getPseudoClassName().equals(\"active\")));\n+\n+        ReflectionUtils.invokeMethod(stage, \"setFocused\", new Class[] { boolean.class }, false);\n+\n+        assertFalse(stage.isFocused());\n+        assertTrue(overlay.getChildrenUnmodifiable().get(0).getPseudoClassStates().stream().noneMatch(\n+                pc -> pc.getPseudoClassName().equals(\"active\")));\n+    }\n+\n+    \/**\n+     * Asserts that the maximize button is disabled when the stage is not resizable.\n+     *\/\n+    @Test\n+    void maximizeButtonIsDisabledWhenStageIsNotResizable() {\n+        var overlay = new WindowControlsOverlay(getStylesheet(\"\"\"\n+                .window-button-container { -fx-button-placement: right; }\n+                .window-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"));\n+\n+        var scene = new Scene(overlay);\n+        var stage = new Stage();\n+        stage.setScene(scene);\n+        stage.show();\n+\n+        var maxButton = overlay.getChildrenUnmodifiable().get(1);\n+        assertTrue(maxButton.getStyleClass().contains(\"maximize-button\"));\n+        assertTrue(stage.isResizable());\n+        assertFalse(maxButton.isDisabled());\n+\n+        stage.setResizable(false);\n+        assertTrue(maxButton.isDisabled());\n+    }\n+\n+    \/**\n+     * Asserts that the .restore style class is added to the maximize button when the stage is maximized.\n+     *\/\n+    @Test\n+    void restoreStyleClassIsPresentWhenStageIsMaximized() {\n+        var overlay = new WindowControlsOverlay(getStylesheet(\"\"\"\n+                .window-button-container { -fx-button-placement: right; }\n+                .window-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"));\n+\n+        var scene = new Scene(overlay);\n+        var stage = new Stage();\n+        stage.setScene(scene);\n+        stage.show();\n+\n+        var maxButton = overlay.getChildrenUnmodifiable().get(1);\n+        assertTrue(maxButton.getStyleClass().contains(\"maximize-button\"));\n+        assertFalse(maxButton.getStyleClass().contains(\"restore\"));\n+\n+        stage.setMaximized(true);\n+        assertTrue(maxButton.getStyleClass().contains(\"restore\"));\n+    }\n+\n+    \/**\n+     * Asserts that the .dark style class is added to all buttons when {@link Scene#getFill()} is dark.\n+     *\/\n+    @Test\n+    void darkStyleClassIsPresentWhenSceneFillIsDark() {\n+        var overlay = new WindowControlsOverlay(getStylesheet(\"\"\"\n+                .window-button-container { -fx-button-placement: right; }\n+                .window-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"));\n+\n+        var scene = new Scene(overlay);\n+\n+        scene.setFill(Color.WHITE);\n+        assertTrue(overlay.getChildrenUnmodifiable().stream().noneMatch(b -> b.getStyleClass().contains(\"dark\")));\n+\n+        scene.setFill(Color.BLACK);\n+        assertTrue(overlay.getChildrenUnmodifiable().stream().allMatch(b -> b.getStyleClass().contains(\"dark\")));\n+    }\n+\n+    \/**\n+     * Tests button picking using {@link WindowControlsOverlay#buttonAt(double, double)}.\n+     *\/\n+    @Test\n+    void pickButtonAtCoordinates() {\n+        var overlay = new WindowControlsOverlay(getStylesheet(\"\"\"\n+                .window-button-container { -fx-button-placement: right; }\n+                .window-button { -fx-pref-width: 20; -fx-pref-height: 10; }\n+            \"\"\"));\n+\n+        var unused = new Scene(overlay);\n+        overlay.resize(200, 100);\n+        overlay.applyCss();\n+        overlay.layout();\n+\n+        assertNull(overlay.buttonAt(139, 5));\n+        assertEquals(WindowControlsOverlay.ButtonType.MINIMIZE, overlay.buttonAt(140, 0));\n+        assertEquals(WindowControlsOverlay.ButtonType.MAXIMIZE, overlay.buttonAt(165, 5));\n+        assertEquals(WindowControlsOverlay.ButtonType.CLOSE, overlay.buttonAt(181, 10));\n+    }\n+\n+    private static ObservableValue<String> getStylesheet(String text) {\n+        String stylesheet = \"data:text\/css;base64,\"\n+            + Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));\n+\n+        return ObjectConstant.valueOf(stylesheet);\n+    }\n+\n+    private static void assertLayoutBounds(Node node, double x, double y, double width, double height) {\n+        assertEquals(x, node.getLayoutX());\n+        assertEquals(y, node.getLayoutY());\n+        assertSize(node, width, height);\n+    }\n+\n+    private static void assertSize(Node node, double width, double height) {\n+        assertEquals(width, node.getLayoutBounds().getWidth());\n+        assertEquals(height, node.getLayoutBounds().getHeight());\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/glass\/ui\/WindowControlsOverlayTest.java","additions":349,"deletions":0,"binary":false,"changes":349,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import javafx.scene.image.Image;\n@@ -39,0 +40,6 @@\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.CycleMethod;\n+import javafx.scene.paint.ImagePattern;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.RadialGradient;\n+import javafx.scene.paint.Stop;\n@@ -184,0 +191,41 @@\n+\n+    @Test\n+    void testAveragePerceptualBrightness_LinearGradient() {\n+        var gradient = new LinearGradient(\n+            0, 0, 1, 1, true, CycleMethod.NO_CYCLE,\n+            new Stop(0, Color.RED), new Stop(0.5, Color.GREEN), new Stop(1, Color.BLUE));\n+\n+        double actual = Utils.calculateAverageBrightness(gradient);\n+        double expect = (Utils.calculateBrightness(Color.RED)\n+            + Utils.calculateBrightness(Color.GREEN)\n+            + Utils.calculateBrightness(Color.BLUE)) \/ 3;\n+\n+        assertEquals(expect, actual);\n+    }\n+\n+    @Test\n+    void testAveragePerceptualBrightness_RadialGradient() {\n+        var gradient = new RadialGradient(\n+            0, 0, 0, 0, 1, true, CycleMethod.NO_CYCLE,\n+            new Stop(0, Color.RED), new Stop(0.5, Color.GREEN), new Stop(1, Color.BLUE));\n+\n+        double actual = Utils.calculateAverageBrightness(gradient);\n+        double expect = (Utils.calculateBrightness(Color.RED)\n+            + Utils.calculateBrightness(Color.GREEN)\n+            + Utils.calculateBrightness(Color.BLUE)) \/ 3;\n+\n+        assertEquals(expect, actual);\n+    }\n+\n+    @Test\n+    void testAveragePerceptualBrightness_ImagePattern() {\n+        var pattern = new ImagePattern(new Image(\"test\"));\n+        assertEquals(1, Utils.calculateAverageBrightness(pattern));\n+    }\n+\n+    @Test\n+    void testAveragePerceptualBrightness_Color() {\n+        var actual = Utils.calculateAverageBrightness(Color.RED);\n+        var expect = Utils.calculateBrightness(Color.RED);\n+        assertEquals(expect, actual);\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/util\/UtilsTest.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,438 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.layout;\n+\n+import javafx.beans.property.ObjectProperty;\n+import javafx.geometry.Dimension2D;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Pos;\n+import javafx.scene.Node;\n+import javafx.scene.layout.HeaderBar;\n+import javafx.scene.shape.Rectangle;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import test.util.ReflectionUtils;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class HeaderBarTest {\n+\n+    HeaderBar headerBar;\n+\n+    @BeforeEach\n+    void setup() {\n+        headerBar = new HeaderBar();\n+    }\n+\n+    @Test\n+    void emptyHeaderBar() {\n+        assertNull(headerBar.getLeading());\n+        assertNull(headerBar.getCenter());\n+        assertNull(headerBar.getTrailing());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+        \"TOP_LEFT, 10, 10, 100, 80\",\n+        \"TOP_CENTER, 10, 10, 100, 80\",\n+        \"TOP_RIGHT, 10, 10, 100, 80\",\n+        \"CENTER_LEFT, 10, 10, 100, 80\",\n+        \"CENTER, 10, 10, 100, 80\",\n+        \"CENTER_RIGHT, 10, 10, 100, 80\",\n+        \"BOTTOM_LEFT, 10, 10, 100, 80\",\n+        \"BOTTOM_CENTER, 10, 10, 100, 80\",\n+        \"BOTTOM_RIGHT, 10, 10, 100, 80\"\n+    })\n+    void alignmentOfLeadingChildOnly_resizable(String arg) {\n+        String[] args = arg.split(\",\");\n+        var content = new MockResizable(100, 50);\n+        HeaderBar.setAlignment(content, Pos.valueOf(args[0]));\n+        HeaderBar.setMargin(content, new Insets(10));\n+        headerBar.setLeading(content);\n+        headerBar.resize(1000, 100);\n+        headerBar.layout();\n+\n+        assertBounds(\n+            Double.parseDouble(args[1]),\n+            Double.parseDouble(args[2]),\n+            Double.parseDouble(args[3]),\n+            Double.parseDouble(args[4]),\n+            content);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+        \"TOP_LEFT, 10, 10, 100, 50\",\n+        \"TOP_CENTER, 10, 10, 100, 50\",\n+        \"TOP_RIGHT, 10, 10, 100, 50\",\n+        \"CENTER_LEFT, 10, 25, 100, 50\",\n+        \"CENTER, 10, 25, 100, 50\",\n+        \"CENTER_RIGHT, 10, 25, 100, 50\",\n+        \"BOTTOM_LEFT, 10, 40, 100, 50\",\n+        \"BOTTOM_CENTER, 10, 40, 100, 50\",\n+        \"BOTTOM_RIGHT, 10, 40, 100, 50\"\n+    })\n+    void alignmentOfLeadingChildOnly_notResizable(String arg) {\n+        String[] args = arg.split(\",\");\n+        var content = new Rectangle(100, 50);\n+        HeaderBar.setAlignment(content, Pos.valueOf(args[0]));\n+        HeaderBar.setMargin(content, new Insets(10));\n+        headerBar.setLeading(content);\n+        headerBar.resize(1000, 100);\n+        headerBar.layout();\n+\n+        assertBounds(\n+            Double.parseDouble(args[1]),\n+            Double.parseDouble(args[2]),\n+            Double.parseDouble(args[3]),\n+            Double.parseDouble(args[4]),\n+            content);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+        \"TOP_LEFT, 890, 10, 100, 80\",\n+        \"TOP_CENTER, 890, 10, 100, 80\",\n+        \"TOP_RIGHT, 890, 10, 100, 80\",\n+        \"CENTER_LEFT, 890, 10, 100, 80\",\n+        \"CENTER, 890, 10, 100, 80\",\n+        \"CENTER_RIGHT, 890, 10, 100, 80\",\n+        \"BOTTOM_LEFT, 890, 10, 100, 80\",\n+        \"BOTTOM_CENTER, 890, 10, 100, 80\",\n+        \"BOTTOM_RIGHT, 890, 10, 100, 80\"\n+    })\n+    void alignmentOfTrailingChildOnly_resizable(String arg) {\n+        String[] args = arg.split(\",\");\n+        var content = new MockResizable(100, 50);\n+        HeaderBar.setAlignment(content, Pos.valueOf(args[0]));\n+        HeaderBar.setMargin(content, new Insets(10));\n+        headerBar.setTrailing(content);\n+        headerBar.resize(1000, 100);\n+        headerBar.layout();\n+\n+        assertBounds(\n+            Double.parseDouble(args[1]),\n+            Double.parseDouble(args[2]),\n+            Double.parseDouble(args[3]),\n+            Double.parseDouble(args[4]),\n+            content);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+        \"TOP_LEFT, 890, 10, 100, 50\",\n+        \"TOP_CENTER, 890, 10, 100, 50\",\n+        \"TOP_RIGHT, 890, 10, 100, 50\",\n+        \"CENTER_LEFT, 890, 25, 100, 50\",\n+        \"CENTER, 890, 25, 100, 50\",\n+        \"CENTER_RIGHT, 890, 25, 100, 50\",\n+        \"BOTTOM_LEFT, 890, 40, 100, 50\",\n+        \"BOTTOM_CENTER, 890, 40, 100, 50\",\n+        \"BOTTOM_RIGHT, 890, 40, 100, 50\"\n+    })\n+    void alignmentOfTrailingChildOnly_notResizable(String arg) {\n+        String[] args = arg.split(\",\");\n+        var content = new Rectangle(100, 50);\n+        HeaderBar.setAlignment(content, Pos.valueOf(args[0]));\n+        HeaderBar.setMargin(content, new Insets(10));\n+        headerBar.setTrailing(content);\n+        headerBar.resize(1000, 100);\n+        headerBar.layout();\n+\n+        assertBounds(\n+            Double.parseDouble(args[1]),\n+            Double.parseDouble(args[2]),\n+            Double.parseDouble(args[3]),\n+            Double.parseDouble(args[4]),\n+            content);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+        \"TOP_LEFT, 10, 10, 100, 80\",\n+        \"TOP_CENTER, 450, 10, 100, 80\",\n+        \"TOP_RIGHT, 890, 10, 100, 80\",\n+        \"CENTER_LEFT, 10, 10, 100, 80\",\n+        \"CENTER, 450, 10, 100, 80\",\n+        \"CENTER_RIGHT, 890, 10, 100, 80\",\n+        \"BOTTOM_LEFT, 10, 10, 100, 80\",\n+        \"BOTTOM_CENTER, 450, 10, 100, 80\",\n+        \"BOTTOM_RIGHT, 890, 10, 100, 80\"\n+    })\n+    void alignmentOfCenterChildOnly_resizable(String arg) {\n+        String[] args = arg.split(\",\");\n+        var content = new MockResizable(100, 50);\n+        HeaderBar.setAlignment(content, Pos.valueOf(args[0]));\n+        HeaderBar.setMargin(content, new Insets(10));\n+        headerBar.setCenter(content);\n+        headerBar.resize(1000, 100);\n+        headerBar.layout();\n+\n+        assertBounds(\n+            Double.parseDouble(args[1]),\n+            Double.parseDouble(args[2]),\n+            Double.parseDouble(args[3]),\n+            Double.parseDouble(args[4]),\n+            content);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+        \"TOP_LEFT, 10, 10, 100, 50\",\n+        \"TOP_CENTER, 450, 10, 100, 50\",\n+        \"TOP_RIGHT, 890, 10, 100, 50\",\n+        \"CENTER_LEFT, 10, 25, 100, 50\",\n+        \"CENTER, 450, 25, 100, 50\",\n+        \"CENTER_RIGHT, 890, 25, 100, 50\",\n+        \"BOTTOM_LEFT, 10, 40, 100, 50\",\n+        \"BOTTOM_CENTER, 450, 40, 100, 50\",\n+        \"BOTTOM_RIGHT, 890, 40, 100, 50\"\n+    })\n+    void alignmentOfCenterChildOnly_notResizable(String arg) {\n+        String[] args = arg.split(\",\");\n+        var content = new Rectangle(100, 50);\n+        HeaderBar.setAlignment(content, Pos.valueOf(args[0]));\n+        HeaderBar.setMargin(content, new Insets(10));\n+        headerBar.setCenter(content);\n+        headerBar.resize(1000, 100);\n+        headerBar.layout();\n+\n+        assertBounds(\n+            Double.parseDouble(args[1]),\n+            Double.parseDouble(args[2]),\n+            Double.parseDouble(args[3]),\n+            Double.parseDouble(args[4]),\n+            content);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+        \"TOP_LEFT, 60, 10, 100, 80\",\n+        \"TOP_CENTER, 450, 10, 100, 80\",\n+        \"TOP_RIGHT, 740, 10, 100, 80\",\n+        \"CENTER_LEFT, 60, 10, 100, 80\",\n+        \"CENTER, 450, 10, 100, 80\",\n+        \"CENTER_RIGHT, 740, 10, 100, 80\",\n+        \"BOTTOM_LEFT, 60, 10, 100, 80\",\n+        \"BOTTOM_CENTER, 450, 10, 100, 80\",\n+        \"BOTTOM_RIGHT, 740, 10, 100, 80\"\n+    })\n+    void alignmentOfCenterChild_resizable_withNonEmptyLeadingAndTrailingChild(String arg) {\n+        String[] args = arg.split(\",\");\n+        var leading = new MockResizable(50, 50);\n+        var center = new MockResizable(100, 50);\n+        var trailing = new MockResizable(150, 50);\n+        HeaderBar.setAlignment(center, Pos.valueOf(args[0]));\n+        HeaderBar.setMargin(center, new Insets(10));\n+        headerBar.setLeading(leading);\n+        headerBar.setCenter(center);\n+        headerBar.setTrailing(trailing);\n+        headerBar.resize(1000, 100);\n+        headerBar.layout();\n+\n+        assertBounds(\n+            Double.parseDouble(args[1]),\n+            Double.parseDouble(args[2]),\n+            Double.parseDouble(args[3]),\n+            Double.parseDouble(args[4]),\n+            center);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+        \"TOP_LEFT, 60, 10, 100, 50\",\n+        \"TOP_CENTER, 450, 10, 100, 50\",\n+        \"TOP_RIGHT, 740, 10, 100, 50\",\n+        \"CENTER_LEFT, 60, 25, 100, 50\",\n+        \"CENTER, 450, 25, 100, 50\",\n+        \"CENTER_RIGHT, 740, 25, 100, 50\",\n+        \"BOTTOM_LEFT, 60, 40, 100, 50\",\n+        \"BOTTOM_CENTER, 450, 40, 100, 50\",\n+        \"BOTTOM_RIGHT, 740, 40, 100, 50\"\n+    })\n+    void alignmentOfCenterChild_notResizable_withNonEmptyLeadingAndTrailingChild(String arg) {\n+        String[] args = arg.split(\",\");\n+        var leading = new Rectangle(50, 50);\n+        var center = new Rectangle(100, 50);\n+        var trailing = new Rectangle(150, 50);\n+        HeaderBar.setAlignment(center, Pos.valueOf(args[0]));\n+        HeaderBar.setMargin(center, new Insets(10));\n+        headerBar.setLeading(leading);\n+        headerBar.setCenter(center);\n+        headerBar.setTrailing(trailing);\n+        headerBar.resize(1000, 100);\n+        headerBar.layout();\n+\n+        assertBounds(\n+            Double.parseDouble(args[1]),\n+            Double.parseDouble(args[2]),\n+            Double.parseDouble(args[3]),\n+            Double.parseDouble(args[4]),\n+            center);\n+    }\n+\n+    @ParameterizedTest\n+    @SuppressWarnings(\"unchecked\")\n+    @ValueSource(strings = {\n+        \"TOP_LEFT, 160, 10, 100, 80\",\n+        \"TOP_CENTER, 450, 10, 100, 80\",\n+        \"TOP_RIGHT, 740, 10, 100, 80\",\n+        \"CENTER_LEFT, 160, 10, 100, 80\",\n+        \"CENTER, 450, 10, 100, 80\",\n+        \"CENTER_RIGHT, 740, 10, 100, 80\",\n+        \"BOTTOM_LEFT, 160, 10, 100, 80\",\n+        \"BOTTOM_CENTER, 450, 10, 100, 80\",\n+        \"BOTTOM_RIGHT, 740, 10, 100, 80\"\n+    })\n+    void alignmentOfCenterChild_withLeftSystemInset(String arg) {\n+        String[] args = arg.split(\",\");\n+        var leftSystemInset = (ObjectProperty<Dimension2D>)ReflectionUtils.getFieldValue(headerBar, \"leftSystemInset\");\n+        leftSystemInset.set(new Dimension2D(100, 100));\n+        var leading = new MockResizable(50, 50);\n+        var center = new MockResizable(100, 50);\n+        var trailing = new MockResizable(150, 50);\n+        HeaderBar.setAlignment(center, Pos.valueOf(args[0]));\n+        HeaderBar.setMargin(center, new Insets(10));\n+        headerBar.setLeading(leading);\n+        headerBar.setCenter(center);\n+        headerBar.setTrailing(trailing);\n+        headerBar.resize(1000, 100);\n+        headerBar.layout();\n+\n+        assertBounds(\n+            Double.parseDouble(args[1]),\n+            Double.parseDouble(args[2]),\n+            Double.parseDouble(args[3]),\n+            Double.parseDouble(args[4]),\n+            center);\n+    }\n+\n+    @ParameterizedTest\n+    @SuppressWarnings(\"unchecked\")\n+    @ValueSource(strings = {\n+        \"TOP_LEFT, 60, 10, 100, 80\",\n+        \"TOP_CENTER, 450, 10, 100, 80\",\n+        \"TOP_RIGHT, 640, 10, 100, 80\",\n+        \"CENTER_LEFT, 60, 10, 100, 80\",\n+        \"CENTER, 450, 10, 100, 80\",\n+        \"CENTER_RIGHT, 640, 10, 100, 80\",\n+        \"BOTTOM_LEFT, 60, 10, 100, 80\",\n+        \"BOTTOM_CENTER, 450, 10, 100, 80\",\n+        \"BOTTOM_RIGHT, 640, 10, 100, 80\"\n+    })\n+    void alignmentOfCenterChild_withRightSystemInset(String arg) {\n+        String[] args = arg.split(\",\");\n+        var rightSystemInset = (ObjectProperty<Dimension2D>)ReflectionUtils.getFieldValue(headerBar, \"rightSystemInset\");\n+        rightSystemInset.set(new Dimension2D(100, 100));\n+        var leading = new MockResizable(50, 50);\n+        var center = new MockResizable(100, 50);\n+        var trailing = new MockResizable(150, 50);\n+        HeaderBar.setAlignment(center, Pos.valueOf(args[0]));\n+        HeaderBar.setMargin(center, new Insets(10));\n+        headerBar.setLeading(leading);\n+        headerBar.setCenter(center);\n+        headerBar.setTrailing(trailing);\n+        headerBar.resize(1000, 100);\n+        headerBar.layout();\n+\n+        assertBounds(\n+            Double.parseDouble(args[1]),\n+            Double.parseDouble(args[2]),\n+            Double.parseDouble(args[3]),\n+            Double.parseDouble(args[4]),\n+            center);\n+    }\n+\n+    @ParameterizedTest\n+    @SuppressWarnings(\"unchecked\")\n+    @ValueSource(strings = {\n+        \"TOP_CENTER, 260, 10, 80, 80\",\n+        \"CENTER, 260, 10, 80, 80\",\n+        \"BOTTOM_CENTER, 260, 10, 80, 80\"\n+    })\n+    void alignmentOfCenterChild_withLeftSystemInset_andOffsetCausedByInsufficientHorizontalSpace(String arg) {\n+        String[] args = arg.split(\",\");\n+        var leftSystemInset = (ObjectProperty<Dimension2D>)ReflectionUtils.getFieldValue(headerBar, \"leftSystemInset\");\n+        leftSystemInset.set(new Dimension2D(200, 100));\n+        var leading = new MockResizable(50, 50);\n+        var center = new MockResizable(100, 50);\n+        var trailing = new MockResizable(150, 50);\n+        HeaderBar.setAlignment(center, Pos.valueOf(args[0]));\n+        HeaderBar.setMargin(center, new Insets(10));\n+        headerBar.setLeading(leading);\n+        headerBar.setCenter(center);\n+        headerBar.setTrailing(trailing);\n+        headerBar.resize(500, 100);\n+        headerBar.layout();\n+\n+        assertBounds(\n+            Double.parseDouble(args[1]),\n+            Double.parseDouble(args[2]),\n+            Double.parseDouble(args[3]),\n+            Double.parseDouble(args[4]),\n+            center);\n+    }\n+\n+    @ParameterizedTest\n+    @SuppressWarnings(\"unchecked\")\n+    @ValueSource(strings = {\n+        \"TOP_CENTER, 60, 10, 80, 80\",\n+        \"CENTER, 60, 10, 80, 80\",\n+        \"BOTTOM_CENTER, 60, 10, 80, 80\"\n+    })\n+    void alignmentOfCenterChild_withRightSystemInset_andOffsetCausedByInsufficientHorizontalSpace(String arg) {\n+        String[] args = arg.split(\",\");\n+        var rightSystemInset = (ObjectProperty<Dimension2D>)ReflectionUtils.getFieldValue(headerBar, \"rightSystemInset\");\n+        rightSystemInset.set(new Dimension2D(200, 100));\n+        var leading = new MockResizable(50, 50);\n+        var center = new MockResizable(100, 50);\n+        var trailing = new MockResizable(150, 50);\n+        HeaderBar.setAlignment(center, Pos.valueOf(args[0]));\n+        HeaderBar.setMargin(center, new Insets(10));\n+        headerBar.setLeading(leading);\n+        headerBar.setCenter(center);\n+        headerBar.setTrailing(trailing);\n+        headerBar.resize(500, 100);\n+        headerBar.layout();\n+\n+        assertBounds(\n+            Double.parseDouble(args[1]),\n+            Double.parseDouble(args[2]),\n+            Double.parseDouble(args[3]),\n+            Double.parseDouble(args[4]),\n+            center);\n+    }\n+\n+    private void assertBounds(double x, double y, double width, double height, Node node) {\n+        var bounds = node.getLayoutBounds();\n+        assertEquals(x, node.getLayoutX());\n+        assertEquals(y, node.getLayoutY());\n+        assertEquals(width, bounds.getWidth());\n+        assertEquals(height, bounds.getHeight());\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/HeaderBarTest.java","additions":438,"deletions":0,"binary":false,"changes":438,"status":"added"}]}