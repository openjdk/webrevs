{"files":[{"patch":"@@ -1,531 +1,531 @@\n-\/*\r\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.  Oracle designates this\r\n- * particular file as subject to the \"Classpath\" exception as provided\r\n- * by Oracle in the LICENSE file that accompanied this code.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-#include \"common.h\"\r\n-\r\n-#include \"GlassApplication.h\"\r\n-#include \"FullScreenWindow.h\"\r\n-#include \"GlassView.h\"\r\n-#include \"GlassDnD.h\"\r\n-#include \"GlassWindow.h\"\r\n-\r\n-#include \"com_sun_glass_events_WindowEvent.h\"\r\n-\r\n-\/\/TODO: is that possible to move all the code to the shared level?\r\n-\r\n-static LPCTSTR szFullScreenWindowClassName = TEXT(\"FullScreenWindowClass\");\r\n-static LPCTSTR szBackgroundWindowClassName = TEXT(\"BackgroundWindowClass\");\r\n-\r\n-static const UINT ANIMATION_MAX_ITERATION = 30;\r\n-static const UINT ANIMATION_TIMER_ELAPSE = USER_TIMER_MINIMUM; \/\/ 0xA ms\r\n-\r\n-FullScreenWindow::FullScreenWindow() :\r\n-    BaseWnd(),\r\n-    ViewContainer()\r\n-{\r\n-    m_animationStage = 0;\r\n-    m_bgWindow = NULL;\r\n-}\r\n-\r\n-FullScreenWindow::~FullScreenWindow()\r\n-{\r\n-}\r\n-\r\n-HWND FullScreenWindow::Create()\r\n-{\r\n-    m_bgWindow = new BackgroundWindow();\r\n-    m_bgWindow->Create();\r\n-\r\n-    DWORD dwStyle = WS_POPUP | WS_CLIPCHILDREN;\r\n-    DWORD dwExStyle = 0;\r\n-\r\n-    HWND hwnd = BaseWnd::Create(NULL, 0, 0, 0, 0,\r\n-                             TEXT(\"\"), dwExStyle, dwStyle, NULL);\r\n-\r\n-    ViewContainer::InitDropTarget(hwnd);\r\n-     ViewContainer::InitManipProcessor(hwnd);\r\n-\r\n-    return hwnd;\r\n-}\r\n-\r\n-void FullScreenWindow::Close()\r\n-{\r\n-    if (m_bgWindow) {\r\n-        m_bgWindow->Close();\r\n-        m_bgWindow = NULL;\r\n-    }\r\n-\r\n-    ViewContainer::ReleaseDropTarget();\r\n-    ViewContainer::ReleaseManipProcessor();\r\n-\r\n-    ::DestroyWindow(GetHWND());\r\n-}\r\n-\r\n-\/* static *\/\r\n-void FullScreenWindow::ClientRectInScreen(HWND hwnd, RECT * rect)\r\n-{\r\n-    ::GetClientRect(hwnd, rect);\r\n-    ::MapWindowPoints(hwnd, (HWND)NULL, (LPPOINT)rect, (sizeof(RECT)\/sizeof(POINT)));\r\n-}\r\n-\r\n-void FullScreenWindow::AttachView(GlassView * view, BOOL keepRatio)\r\n-{\r\n-    SetGlassView(view);\r\n-\r\n-    m_oldViewParent = GetGlassView()->GetHostHwnd();\r\n-\r\n-    FullScreenWindow::ClientRectInScreen(m_oldViewParent, &m_viewRect);\r\n-\r\n-    InitWindowRect(keepRatio);\r\n-\r\n-    GlassWindow * window = GlassWindow::FromHandle(m_oldViewParent);\r\n-    if (window) {\r\n-        window->SetDelegateWindow(GetHWND());\r\n-    }\r\n-\r\n-    ::ShowWindow(m_oldViewParent, SW_HIDE);\r\n-    GetGlassView()->SetHostHwnd(GetHWND());\r\n-}\r\n-\r\n-void FullScreenWindow::DetachView()\r\n-{\r\n-    RECT r;\r\n-    HWND oldWnd = m_oldViewParent;\r\n-    GlassView* view = GetGlassView();\r\n-\r\n-    m_oldViewParent = NULL;\r\n-\r\n-    view->SetHostHwnd(oldWnd);\r\n-\r\n-    ::ShowWindow(oldWnd, SW_SHOW);\r\n-    ::SetForegroundWindow(oldWnd);\r\n-    ::SetFocus(oldWnd);\r\n-\r\n-    GlassWindow * window = GlassWindow::FromHandle(oldWnd);\r\n-    if (window) {\r\n-        window->SetDelegateWindow(NULL);\r\n-    }\r\n-\r\n-    ::GetClientRect(oldWnd, &r);\r\n-    JNIEnv* env = GetEnv();\r\n-    env->CallVoidMethod(GetView(), javaIDs.View.notifyResize,\r\n-            r.right-r.left, r.bottom - r.top);\r\n-    CheckAndClearException(env);\r\n-\r\n-    SetGlassView(NULL);\r\n-}\r\n-\r\n-\/* static *\/\r\n-void FullScreenWindow::CalculateBounds(HWND hwnd, RECT * screenRect,\r\n-        RECT * contentRect, BOOL keepRatio, const RECT & viewRect)\r\n-{\r\n-    MONITORINFOEX mix;\r\n-    HMONITOR hMonitor = ::MonitorFromWindow(hwnd, MONITOR_DEFAULTTOPRIMARY);\r\n-\r\n-    memset(&mix, 0, sizeof(MONITORINFOEX));\r\n-    mix.cbSize = sizeof(MONITORINFOEX);\r\n-    ::GetMonitorInfo(hMonitor, &mix);\r\n-\r\n-    ::CopyRect(screenRect, &mix.rcMonitor);\r\n-    ::CopyRect(contentRect, &mix.rcMonitor);\r\n-\r\n-    if (keepRatio) {\r\n-        int viewWidth = viewRect.right - viewRect.left;\r\n-        int viewHeight = viewRect.bottom - viewRect.top;\r\n-        int screenWidth = screenRect->right - screenRect->left;\r\n-        int screenHeight = screenRect->bottom - screenRect->top;\r\n-\r\n-        float ratioWidth = (float)viewWidth \/ (float)screenWidth;\r\n-        float ratioHeight = (float)viewHeight \/ (float)screenHeight;\r\n-\r\n-        if (ratioWidth > ratioHeight) {\r\n-            float ratio = (float)viewWidth \/ (float)viewHeight;\r\n-            int height = (int)(screenWidth \/ ratio);\r\n-            contentRect->top += (screenHeight - height) \/ 2;\r\n-            contentRect->bottom = contentRect->top + height;\r\n-        } else {\r\n-            float ratio = (float)viewHeight \/ (float)viewWidth;\r\n-            int width = (int)(screenHeight \/ ratio);\r\n-            contentRect->left += (screenWidth - width) \/ 2;\r\n-            contentRect->right = contentRect->left + width;\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-void FullScreenWindow::InitWindowRect(BOOL keepRatio)\r\n-{\r\n-    RECT screenRect;\r\n-\r\n-    FullScreenWindow::CalculateBounds(m_oldViewParent, &screenRect,\r\n-            &m_windowRect, keepRatio, m_viewRect);\r\n-\r\n-    m_bgWindow->SetWindowRect(&screenRect);\r\n-}\r\n-\r\n-void FullScreenWindow::ShowWindow(BOOL animate)\r\n-{\r\n-    m_bgWindow->ShowWindow(animate);\r\n-\r\n-    RECT rect;\r\n-    if (animate) {\r\n-        CopyRect(&rect, &m_viewRect);\r\n-    } else {\r\n-        CopyRect(&rect, &m_windowRect);\r\n-    }\r\n-\r\n-    ::SetWindowPos(GetHWND(), HWND_TOPMOST, rect.left, rect.top,\r\n-                    rect.right - rect.left, rect.bottom - rect.top,\r\n-                    SWP_SHOWWINDOW);\r\n-    ::SetForegroundWindow(GetHWND());\r\n-}\r\n-\r\n-void FullScreenWindow::HideWindow()\r\n-{\r\n-    m_bgWindow->HideWindow();\r\n-    ::ShowWindow(GetHWND(), SW_HIDE);\r\n-}\r\n-\r\n-void FullScreenWindow::HandleSizeEvent()\r\n-{\r\n-}\r\n-\r\n-void FullScreenWindow::HandleViewTimerEvent(HWND hwnd, UINT_PTR timerID)\r\n-{\r\n-    switch (timerID) {\r\n-    case IDT_GLASS_ANIMATION_ENTER:\r\n-    case IDT_GLASS_ANIMATION_EXIT:\r\n-        break;\r\n-    default:\r\n-        ViewContainer::HandleViewTimerEvent(hwnd, timerID);\r\n-        return;\r\n-    }\r\n-\r\n-    if (timerID == IDT_GLASS_ANIMATION_ENTER) {\r\n-        if (m_animationStage > ANIMATION_MAX_ITERATION) {\r\n-            StopAnimation(TRUE);\r\n-            return;\r\n-        }\r\n-    } else if (timerID == IDT_GLASS_ANIMATION_EXIT) {\r\n-        if (m_animationStage < 1) {\r\n-            StopAnimation(FALSE);\r\n-            return;\r\n-        }\r\n-    }\r\n-\r\n-    m_bgWindow->UpdateAnimationOpacity(m_animationStage);\r\n-    UpdateAnimationRect();\r\n-\r\n-    if (timerID == IDT_GLASS_ANIMATION_ENTER) {\r\n-        m_animationStage++;\r\n-    } else if (timerID == IDT_GLASS_ANIMATION_EXIT) {\r\n-        m_animationStage--;\r\n-    }\r\n-}\r\n-\r\n-LRESULT FullScreenWindow::WindowProc(UINT msg, WPARAM wParam, LPARAM lParam)\r\n-{\r\n-    MessageResult commonResult = BaseWnd::CommonWindowProc(msg, wParam, lParam);\r\n-    if (commonResult.processed) {\r\n-        return commonResult.result;\r\n-    }\r\n-\r\n-    switch (msg) {\r\n-        case WM_TIMER:\r\n-            HandleViewTimerEvent(GetHWND(), wParam);\r\n-            break;\r\n-        case WM_SIZE:\r\n-            if (wParam == SIZE_RESTORED || wParam == SIZE_MAXIMIZED) {\r\n-                HandleSizeEvent();\r\n-            }\r\n-            HandleViewSizeEvent(GetHWND(), msg, wParam, lParam);\r\n-            break;\r\n-        case WM_ACTIVATE:\r\n-            {\r\n-                \/\/ The fActive shouldn't be WA_INACTIVE && the window shouldn't be minimized:\r\n-                const bool isFocusGained = LOWORD(wParam) != WA_INACTIVE && HIWORD(wParam) == 0;\r\n-\r\n-                if (!isFocusGained && IsCommonDialogOwner()) {\r\n-                    \/\/ Remain in full screen while a file dialog is showing\r\n-                    break;\r\n-                }\r\n-\r\n-                HWND hWndInsertAfter = isFocusGained ? HWND_TOPMOST : HWND_BOTTOM;\r\n-\r\n-                if (m_bgWindow) {\r\n-                    ::SetWindowPos(m_bgWindow->GetHWND(), hWndInsertAfter, 0, 0, 0, 0,\r\n-                            SWP_ASYNCWINDOWPOS | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOSIZE);\r\n-                }\r\n-                ::SetWindowPos(GetHWND(), hWndInsertAfter, 0, 0, 0, 0,\r\n-                        SWP_ASYNCWINDOWPOS | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOSIZE);\r\n-\r\n-                GlassWindow * window = GlassWindow::FromHandle(m_oldViewParent);\r\n-                if (window) {\r\n-                    window->HandleActivateEvent(isFocusGained ?\r\n-                        com_sun_glass_events_WindowEvent_FOCUS_GAINED :\r\n-                        com_sun_glass_events_WindowEvent_FOCUS_LOST);\r\n-\r\n-                    \/\/ Child windows don't have a taskbar button, therefore\r\n-                    \/\/ we force exiting from the FS mode if the window looses\r\n-                    \/\/ focus.\r\n-                    if (!isFocusGained) {\r\n-                        ExitFullScreenMode(FALSE);\r\n-                    }\r\n-                }\r\n-            }\r\n-            break;\r\n-        case WM_CLOSE:\r\n-            {\r\n-                GlassWindow * window = GlassWindow::FromHandle(m_oldViewParent);\r\n-                ExitFullScreenMode(FALSE);\r\n-                if (window) {\r\n-                    window->HandleCloseEvent();\r\n-                }\r\n-            }\r\n-            return 0;\r\n-        case WM_INPUTLANGCHANGE:\r\n-            HandleViewInputLangChange(GetHWND(), msg, wParam, lParam);\r\n-            return 0;\r\n-        case WM_PAINT:\r\n-            HandleViewPaintEvent(GetHWND(), msg, wParam, lParam);\r\n-            break;\r\n-        case WM_CONTEXTMENU:\r\n-            HandleViewMenuEvent(GetHWND(), msg, wParam, lParam);\r\n-            break;\r\n-        case WM_MOUSEMOVE:\r\n-        case WM_LBUTTONDOWN:\r\n-        case WM_LBUTTONUP:\r\n-        case WM_LBUTTONDBLCLK:\r\n-        case WM_RBUTTONDOWN:\r\n-        case WM_RBUTTONUP:\r\n-        case WM_RBUTTONDBLCLK:\r\n-        case WM_MBUTTONDOWN:\r\n-        case WM_MBUTTONUP:\r\n-        case WM_MBUTTONDBLCLK:\r\n-        case WM_XBUTTONDOWN:\r\n-        case WM_XBUTTONUP:\r\n-        case WM_XBUTTONDBLCLK:\r\n-        case WM_MOUSEWHEEL:\r\n-        case WM_MOUSEHWHEEL:\r\n-        case WM_MOUSELEAVE: {\r\n-            BOOL handled = HandleViewMouseEvent(GetHWND(), msg, wParam, lParam, FALSE);\r\n-            if (handled && msg == WM_RBUTTONUP) {\r\n-                \/\/ By default, DefWindowProc() sends WM_CONTEXTMENU from WM_LBUTTONUP\r\n-                \/\/ Since DefWindowProc() is not called, call the mouse menu handler directly\r\n-                HandleViewMenuEvent(GetHWND(), WM_CONTEXTMENU, (WPARAM) GetHWND(), ::GetMessagePos ());\r\n-                \/\/::DefWindowProc(GetHWND(), msg, wParam, lParam);\r\n-            }\r\n-            if (handled) {\r\n-                \/\/ Do not call the DefWindowProc() for mouse events that were handled\r\n-                return 0;\r\n-            }\r\n-            break;\r\n-        }\r\n-        case WM_CAPTURECHANGED:\r\n-            ViewContainer::NotifyCaptureChanged(GetHWND(), (HWND)lParam);\r\n-            break;\r\n-        case WM_SYSKEYDOWN:\r\n-        case WM_SYSKEYUP:\r\n-        case WM_KEYDOWN:\r\n-        case WM_KEYUP:\r\n-            HandleViewKeyEvent(GetHWND(), msg, wParam, lParam);\r\n-            \/\/ Always pass the message down to the DefWindowProc() to handle\r\n-            \/\/ system keys (Alt+F4, etc.)\r\n-            break;\r\n-        case WM_DEADCHAR:\r\n-            HandleViewDeadKeyEvent(GetHWND(), msg, wParam, lParam);\r\n-            break;\r\n-        case WM_CHAR:\r\n-        case WM_IME_CHAR:\r\n-            HandleViewTypedEvent(GetHWND(), msg, wParam, lParam);\r\n-            return 0;\r\n-        case WM_IME_COMPOSITION:\r\n-        case WM_IME_ENDCOMPOSITION:\r\n-        case WM_IME_NOTIFY:\r\n-        case WM_IME_STARTCOMPOSITION:\r\n-            if (HandleViewInputMethodEvent(GetHWND(), msg, wParam, lParam)) {\r\n-                return 0;\r\n-            }\r\n-            break;\r\n-        case WM_TOUCH:\r\n-            HandleViewTouchEvent(GetHWND(), msg, wParam, lParam);\r\n-            return 0;\r\n-        case WM_GETOBJECT: {\r\n-            LRESULT lr = HandleViewGetAccessible(GetHWND(), wParam, lParam);\r\n-            if (lr) return lr;\r\n-            break;\r\n-        }\r\n-    }\r\n-\r\n-    return ::DefWindowProc(GetHWND(), msg, wParam, lParam);\r\n-}\r\n-\r\n-LPCTSTR FullScreenWindow::GetWindowClassNameSuffix()\r\n-{\r\n-    return szFullScreenWindowClassName;\r\n-}\r\n-\r\n-BOOL FullScreenWindow::EnterFullScreenMode(GlassView * view, BOOL animate, BOOL keepRatio)\r\n-{\r\n-    if (IsAnimationInProcess()) {\r\n-        return TRUE;\r\n-    }\r\n-\r\n-    AttachView(view, keepRatio);\r\n-    ShowWindow(animate);\r\n-\r\n-    if (animate) {\r\n-        StartAnimation(TRUE);\r\n-    }\r\n-\r\n-    return TRUE;\r\n-}\r\n-\r\n-void FullScreenWindow::StartAnimation(BOOL enter)\r\n-{\r\n-    m_animationStage = (enter ? 1 : ANIMATION_MAX_ITERATION);\r\n-    UINT_PTR eventID = (enter ? IDT_GLASS_ANIMATION_ENTER : IDT_GLASS_ANIMATION_EXIT);\r\n-    ::SetTimer(GetHWND(), eventID, ANIMATION_TIMER_ELAPSE, NULL);\r\n-}\r\n-\r\n-void FullScreenWindow::ExitFullScreenMode(BOOL animate)\r\n-{\r\n-    if (IsAnimationInProcess()) {\r\n-        \/\/TODO: the animation should be terminated\r\n-        return;\r\n-    }\r\n-\r\n-\r\n-    if (animate) {\r\n-        StartAnimation(FALSE);\r\n-    } else {\r\n-        GlassView * view = GetGlassView();\r\n-        DetachView();\r\n-        HideWindow();\r\n-        Close();\r\n-    }\r\n-}\r\n-\r\n-void FullScreenWindow::StopAnimation(BOOL enter)\r\n-{\r\n-    UINT_PTR eventID = (enter ? IDT_GLASS_ANIMATION_ENTER : IDT_GLASS_ANIMATION_EXIT);\r\n-    ::KillTimer(GetHWND(), eventID);\r\n-\r\n-    if (!enter) {\r\n-        GlassView * view = GetGlassView();\r\n-        DetachView();\r\n-        HideWindow();\r\n-        Close();\r\n-    }\r\n-}\r\n-\r\n-BOOL FullScreenWindow::IsAnimationInProcess()\r\n-{\r\n-    if (m_animationStage >= 1 && m_animationStage <= ANIMATION_MAX_ITERATION) {\r\n-        return true;\r\n-    }\r\n-    return false;\r\n-}\r\n-\r\n-void FullScreenWindow::UpdateAnimationRect()\r\n-{\r\n-    RECT rect;\r\n-    float stage = (float)m_animationStage \/ (float)ANIMATION_MAX_ITERATION;\r\n-    rect.left = m_viewRect.left +  (long)((m_windowRect.left - m_viewRect.left) * stage);                                                                ;\r\n-    rect.top = m_viewRect.top +  (long)((m_windowRect.top - m_viewRect.top) * stage);\r\n-    rect.right = m_viewRect.right +  (long)((m_windowRect.right - m_viewRect.right) * stage);\r\n-    rect.bottom = m_viewRect.bottom +  (long)((m_windowRect.bottom - m_viewRect.bottom) * stage);\r\n-\r\n-    ::SetWindowPos(GetHWND(), NULL, rect.left, rect.top,\r\n-                    rect.right - rect.left, rect.bottom - rect.top,\r\n-                    SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSENDCHANGING | SWP_DEFERERASE);\r\n-}\r\n-\r\n-\/\/ Transparent background window\r\n-\r\n-BackgroundWindow::BackgroundWindow() : BaseWnd()\r\n-{\r\n-    m_rect.left = 0;\r\n-    m_rect.top = 0;\r\n-    m_rect.right = 0;\r\n-    m_rect.bottom = 0;\r\n-}\r\n-\r\n-BackgroundWindow::~BackgroundWindow()\r\n-{\r\n-}\r\n-\r\n-HWND BackgroundWindow::Create()\r\n-{\r\n-    DWORD dwStyle = WS_POPUP | WS_CLIPCHILDREN;\r\n-    DWORD dwExStyle = WS_EX_LAYERED | WS_EX_TOOLWINDOW;\r\n-\r\n-    return BaseWnd::Create(NULL, 0, 0, 0, 0,\r\n-                           TEXT(\"\"), dwExStyle, dwStyle, (HBRUSH)::GetStockObject(BLACK_BRUSH));\r\n-}\r\n-\r\n-void BackgroundWindow::Close()\r\n-{\r\n-    ::DestroyWindow(GetHWND());\r\n-}\r\n-\r\n-LRESULT BackgroundWindow::WindowProc(UINT msg, WPARAM wParam, LPARAM lParam)\r\n-{\r\n-    switch (msg) {\r\n-        case WM_MOUSEACTIVATE: {\r\n-            return MA_NOACTIVATE;\r\n-        }\r\n-    }\r\n-\r\n-    return ::DefWindowProc(GetHWND(), msg, wParam, lParam);\r\n-}\r\n-\r\n-LPCTSTR BackgroundWindow::GetWindowClassNameSuffix()\r\n-{\r\n-    return szBackgroundWindowClassName;\r\n-}\r\n-\r\n-void BackgroundWindow::SetWindowRect(RECT * rect)\r\n-{\r\n-    ::CopyRect(&m_rect, rect);\r\n-}\r\n-\r\n-void BackgroundWindow::ShowWindow(BOOL animate) {\r\n-    BYTE opacity = (animate ? 0x0 : 0xFF);\r\n-    ::SetLayeredWindowAttributes(GetHWND(), RGB(0, 0, 0), opacity, LWA_ALPHA);\r\n-    ::SetWindowPos(GetHWND(), HWND_TOPMOST, m_rect.left, m_rect.top,\r\n-                    m_rect.right - m_rect.left, m_rect.bottom - m_rect.top,\r\n-                    SWP_SHOWWINDOW | SWP_NOACTIVATE);\r\n-}\r\n-\r\n-void BackgroundWindow::HideWindow()\r\n-{\r\n-    ::ShowWindow(GetHWND(), SW_HIDE);\r\n-}\r\n-\r\n-void BackgroundWindow::UpdateAnimationOpacity(int animationStage)\r\n-{\r\n-    BYTE opacity = ((int)0xFF * animationStage) \/ ANIMATION_MAX_ITERATION;\r\n-    ::SetLayeredWindowAttributes(GetHWND(), RGB(0, 0, 0), opacity, LWA_ALPHA);\r\n-}\r\n+\/*\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"common.h\"\n+\n+#include \"GlassApplication.h\"\n+#include \"FullScreenWindow.h\"\n+#include \"GlassView.h\"\n+#include \"GlassDnD.h\"\n+#include \"GlassWindow.h\"\n+\n+#include \"com_sun_glass_events_WindowEvent.h\"\n+\n+\/\/TODO: is that possible to move all the code to the shared level?\n+\n+static LPCTSTR szFullScreenWindowClassName = TEXT(\"FullScreenWindowClass\");\n+static LPCTSTR szBackgroundWindowClassName = TEXT(\"BackgroundWindowClass\");\n+\n+static const UINT ANIMATION_MAX_ITERATION = 30;\n+static const UINT ANIMATION_TIMER_ELAPSE = USER_TIMER_MINIMUM; \/\/ 0xA ms\n+\n+FullScreenWindow::FullScreenWindow() :\n+    BaseWnd(),\n+    ViewContainer()\n+{\n+    m_animationStage = 0;\n+    m_bgWindow = NULL;\n+}\n+\n+FullScreenWindow::~FullScreenWindow()\n+{\n+}\n+\n+HWND FullScreenWindow::Create()\n+{\n+    m_bgWindow = new BackgroundWindow();\n+    m_bgWindow->Create();\n+\n+    DWORD dwStyle = WS_POPUP | WS_CLIPCHILDREN;\n+    DWORD dwExStyle = 0;\n+\n+    HWND hwnd = BaseWnd::Create(NULL, 0, 0, 0, 0,\n+                             TEXT(\"\"), dwExStyle, dwStyle, NULL);\n+\n+    ViewContainer::InitDropTarget(hwnd);\n+     ViewContainer::InitManipProcessor(hwnd);\n+\n+    return hwnd;\n+}\n+\n+void FullScreenWindow::Close()\n+{\n+    if (m_bgWindow) {\n+        m_bgWindow->Close();\n+        m_bgWindow = NULL;\n+    }\n+\n+    ViewContainer::ReleaseDropTarget();\n+    ViewContainer::ReleaseManipProcessor();\n+\n+    ::DestroyWindow(GetHWND());\n+}\n+\n+\/* static *\/\n+void FullScreenWindow::ClientRectInScreen(HWND hwnd, RECT * rect)\n+{\n+    ::GetClientRect(hwnd, rect);\n+    ::MapWindowPoints(hwnd, (HWND)NULL, (LPPOINT)rect, (sizeof(RECT)\/sizeof(POINT)));\n+}\n+\n+void FullScreenWindow::AttachView(GlassView * view, BOOL keepRatio)\n+{\n+    SetGlassView(view);\n+\n+    m_oldViewParent = GetGlassView()->GetHostHwnd();\n+\n+    FullScreenWindow::ClientRectInScreen(m_oldViewParent, &m_viewRect);\n+\n+    InitWindowRect(keepRatio);\n+\n+    GlassWindow * window = GlassWindow::FromHandle(m_oldViewParent);\n+    if (window) {\n+        window->SetDelegateWindow(GetHWND());\n+    }\n+\n+    ::ShowWindow(m_oldViewParent, SW_HIDE);\n+    GetGlassView()->SetHostHwnd(GetHWND());\n+}\n+\n+void FullScreenWindow::DetachView()\n+{\n+    RECT r;\n+    HWND oldWnd = m_oldViewParent;\n+    GlassView* view = GetGlassView();\n+\n+    m_oldViewParent = NULL;\n+\n+    view->SetHostHwnd(oldWnd);\n+\n+    ::ShowWindow(oldWnd, SW_SHOW);\n+    ::SetForegroundWindow(oldWnd);\n+    ::SetFocus(oldWnd);\n+\n+    GlassWindow * window = GlassWindow::FromHandle(oldWnd);\n+    if (window) {\n+        window->SetDelegateWindow(NULL);\n+    }\n+\n+    ::GetClientRect(oldWnd, &r);\n+    JNIEnv* env = GetEnv();\n+    env->CallVoidMethod(GetView(), javaIDs.View.notifyResize,\n+            r.right-r.left, r.bottom - r.top);\n+    CheckAndClearException(env);\n+\n+    SetGlassView(NULL);\n+}\n+\n+\/* static *\/\n+void FullScreenWindow::CalculateBounds(HWND hwnd, RECT * screenRect,\n+        RECT * contentRect, BOOL keepRatio, const RECT & viewRect)\n+{\n+    MONITORINFOEX mix;\n+    HMONITOR hMonitor = ::MonitorFromWindow(hwnd, MONITOR_DEFAULTTOPRIMARY);\n+\n+    memset(&mix, 0, sizeof(MONITORINFOEX));\n+    mix.cbSize = sizeof(MONITORINFOEX);\n+    ::GetMonitorInfo(hMonitor, &mix);\n+\n+    ::CopyRect(screenRect, &mix.rcMonitor);\n+    ::CopyRect(contentRect, &mix.rcMonitor);\n+\n+    if (keepRatio) {\n+        int viewWidth = viewRect.right - viewRect.left;\n+        int viewHeight = viewRect.bottom - viewRect.top;\n+        int screenWidth = screenRect->right - screenRect->left;\n+        int screenHeight = screenRect->bottom - screenRect->top;\n+\n+        float ratioWidth = (float)viewWidth \/ (float)screenWidth;\n+        float ratioHeight = (float)viewHeight \/ (float)screenHeight;\n+\n+        if (ratioWidth > ratioHeight) {\n+            float ratio = (float)viewWidth \/ (float)viewHeight;\n+            int height = (int)(screenWidth \/ ratio);\n+            contentRect->top += (screenHeight - height) \/ 2;\n+            contentRect->bottom = contentRect->top + height;\n+        } else {\n+            float ratio = (float)viewHeight \/ (float)viewWidth;\n+            int width = (int)(screenHeight \/ ratio);\n+            contentRect->left += (screenWidth - width) \/ 2;\n+            contentRect->right = contentRect->left + width;\n+        }\n+    }\n+}\n+\n+void FullScreenWindow::InitWindowRect(BOOL keepRatio)\n+{\n+    RECT screenRect;\n+\n+    FullScreenWindow::CalculateBounds(m_oldViewParent, &screenRect,\n+            &m_windowRect, keepRatio, m_viewRect);\n+\n+    m_bgWindow->SetWindowRect(&screenRect);\n+}\n+\n+void FullScreenWindow::ShowWindow(BOOL animate)\n+{\n+    m_bgWindow->ShowWindow(animate);\n+\n+    RECT rect;\n+    if (animate) {\n+        CopyRect(&rect, &m_viewRect);\n+    } else {\n+        CopyRect(&rect, &m_windowRect);\n+    }\n+\n+    ::SetWindowPos(GetHWND(), HWND_TOPMOST, rect.left, rect.top,\n+                    rect.right - rect.left, rect.bottom - rect.top,\n+                    SWP_SHOWWINDOW);\n+    ::SetForegroundWindow(GetHWND());\n+}\n+\n+void FullScreenWindow::HideWindow()\n+{\n+    m_bgWindow->HideWindow();\n+    ::ShowWindow(GetHWND(), SW_HIDE);\n+}\n+\n+void FullScreenWindow::HandleSizeEvent()\n+{\n+}\n+\n+void FullScreenWindow::HandleViewTimerEvent(HWND hwnd, UINT_PTR timerID)\n+{\n+    switch (timerID) {\n+    case IDT_GLASS_ANIMATION_ENTER:\n+    case IDT_GLASS_ANIMATION_EXIT:\n+        break;\n+    default:\n+        ViewContainer::HandleViewTimerEvent(hwnd, timerID);\n+        return;\n+    }\n+\n+    if (timerID == IDT_GLASS_ANIMATION_ENTER) {\n+        if (m_animationStage > ANIMATION_MAX_ITERATION) {\n+            StopAnimation(TRUE);\n+            return;\n+        }\n+    } else if (timerID == IDT_GLASS_ANIMATION_EXIT) {\n+        if (m_animationStage < 1) {\n+            StopAnimation(FALSE);\n+            return;\n+        }\n+    }\n+\n+    m_bgWindow->UpdateAnimationOpacity(m_animationStage);\n+    UpdateAnimationRect();\n+\n+    if (timerID == IDT_GLASS_ANIMATION_ENTER) {\n+        m_animationStage++;\n+    } else if (timerID == IDT_GLASS_ANIMATION_EXIT) {\n+        m_animationStage--;\n+    }\n+}\n+\n+LRESULT FullScreenWindow::WindowProc(UINT msg, WPARAM wParam, LPARAM lParam)\n+{\n+    MessageResult commonResult = BaseWnd::CommonWindowProc(msg, wParam, lParam);\n+    if (commonResult.processed) {\n+        return commonResult.result;\n+    }\n+\n+    switch (msg) {\n+        case WM_TIMER:\n+            HandleViewTimerEvent(GetHWND(), wParam);\n+            break;\n+        case WM_SIZE:\n+            if (wParam == SIZE_RESTORED || wParam == SIZE_MAXIMIZED) {\n+                HandleSizeEvent();\n+            }\n+            HandleViewSizeEvent(GetHWND(), msg, wParam, lParam);\n+            break;\n+        case WM_ACTIVATE:\n+            {\n+                \/\/ The fActive shouldn't be WA_INACTIVE && the window shouldn't be minimized:\n+                const bool isFocusGained = LOWORD(wParam) != WA_INACTIVE && HIWORD(wParam) == 0;\n+\n+                if (!isFocusGained && IsCommonDialogOwner()) {\n+                    \/\/ Remain in full screen while a file dialog is showing\n+                    break;\n+                }\n+\n+                HWND hWndInsertAfter = isFocusGained ? HWND_TOPMOST : HWND_BOTTOM;\n+\n+                if (m_bgWindow) {\n+                    ::SetWindowPos(m_bgWindow->GetHWND(), hWndInsertAfter, 0, 0, 0, 0,\n+                            SWP_ASYNCWINDOWPOS | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOSIZE);\n+                }\n+                ::SetWindowPos(GetHWND(), hWndInsertAfter, 0, 0, 0, 0,\n+                        SWP_ASYNCWINDOWPOS | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOSIZE);\n+\n+                GlassWindow * window = GlassWindow::FromHandle(m_oldViewParent);\n+                if (window) {\n+                    window->HandleActivateEvent(isFocusGained ?\n+                        com_sun_glass_events_WindowEvent_FOCUS_GAINED :\n+                        com_sun_glass_events_WindowEvent_FOCUS_LOST);\n+\n+                    \/\/ Child windows don't have a taskbar button, therefore\n+                    \/\/ we force exiting from the FS mode if the window looses\n+                    \/\/ focus.\n+                    if (!isFocusGained) {\n+                        ExitFullScreenMode(FALSE);\n+                    }\n+                }\n+            }\n+            break;\n+        case WM_CLOSE:\n+            {\n+                GlassWindow * window = GlassWindow::FromHandle(m_oldViewParent);\n+                ExitFullScreenMode(FALSE);\n+                if (window) {\n+                    window->HandleCloseEvent();\n+                }\n+            }\n+            return 0;\n+        case WM_INPUTLANGCHANGE:\n+            HandleViewInputLangChange(GetHWND(), msg, wParam, lParam);\n+            return 0;\n+        case WM_PAINT:\n+            HandleViewPaintEvent(GetHWND(), msg, wParam, lParam);\n+            break;\n+        case WM_CONTEXTMENU:\n+            HandleViewMenuEvent(GetHWND(), msg, wParam, lParam);\n+            break;\n+        case WM_MOUSEMOVE:\n+        case WM_LBUTTONDOWN:\n+        case WM_LBUTTONUP:\n+        case WM_LBUTTONDBLCLK:\n+        case WM_RBUTTONDOWN:\n+        case WM_RBUTTONUP:\n+        case WM_RBUTTONDBLCLK:\n+        case WM_MBUTTONDOWN:\n+        case WM_MBUTTONUP:\n+        case WM_MBUTTONDBLCLK:\n+        case WM_XBUTTONDOWN:\n+        case WM_XBUTTONUP:\n+        case WM_XBUTTONDBLCLK:\n+        case WM_MOUSEWHEEL:\n+        case WM_MOUSEHWHEEL:\n+        case WM_MOUSELEAVE: {\n+            BOOL handled = HandleViewMouseEvent(GetHWND(), msg, wParam, lParam, FALSE);\n+            if (handled && msg == WM_RBUTTONUP) {\n+                \/\/ By default, DefWindowProc() sends WM_CONTEXTMENU from WM_LBUTTONUP\n+                \/\/ Since DefWindowProc() is not called, call the mouse menu handler directly\n+                HandleViewMenuEvent(GetHWND(), WM_CONTEXTMENU, (WPARAM) GetHWND(), ::GetMessagePos ());\n+                \/\/::DefWindowProc(GetHWND(), msg, wParam, lParam);\n+            }\n+            if (handled) {\n+                \/\/ Do not call the DefWindowProc() for mouse events that were handled\n+                return 0;\n+            }\n+            break;\n+        }\n+        case WM_CAPTURECHANGED:\n+            ViewContainer::NotifyCaptureChanged(GetHWND(), (HWND)lParam);\n+            break;\n+        case WM_SYSKEYDOWN:\n+        case WM_SYSKEYUP:\n+        case WM_KEYDOWN:\n+        case WM_KEYUP:\n+            HandleViewKeyEvent(GetHWND(), msg, wParam, lParam);\n+            \/\/ Always pass the message down to the DefWindowProc() to handle\n+            \/\/ system keys (Alt+F4, etc.)\n+            break;\n+        case WM_DEADCHAR:\n+            HandleViewDeadKeyEvent(GetHWND(), msg, wParam, lParam);\n+            break;\n+        case WM_CHAR:\n+        case WM_IME_CHAR:\n+            HandleViewTypedEvent(GetHWND(), msg, wParam, lParam);\n+            return 0;\n+        case WM_IME_COMPOSITION:\n+        case WM_IME_ENDCOMPOSITION:\n+        case WM_IME_NOTIFY:\n+        case WM_IME_STARTCOMPOSITION:\n+            if (HandleViewInputMethodEvent(GetHWND(), msg, wParam, lParam)) {\n+                return 0;\n+            }\n+            break;\n+        case WM_TOUCH:\n+            HandleViewTouchEvent(GetHWND(), msg, wParam, lParam);\n+            return 0;\n+        case WM_GETOBJECT: {\n+            LRESULT lr = HandleViewGetAccessible(GetHWND(), wParam, lParam);\n+            if (lr) return lr;\n+            break;\n+        }\n+    }\n+\n+    return ::DefWindowProc(GetHWND(), msg, wParam, lParam);\n+}\n+\n+LPCTSTR FullScreenWindow::GetWindowClassNameSuffix()\n+{\n+    return szFullScreenWindowClassName;\n+}\n+\n+BOOL FullScreenWindow::EnterFullScreenMode(GlassView * view, BOOL animate, BOOL keepRatio)\n+{\n+    if (IsAnimationInProcess()) {\n+        return TRUE;\n+    }\n+\n+    AttachView(view, keepRatio);\n+    ShowWindow(animate);\n+\n+    if (animate) {\n+        StartAnimation(TRUE);\n+    }\n+\n+    return TRUE;\n+}\n+\n+void FullScreenWindow::StartAnimation(BOOL enter)\n+{\n+    m_animationStage = (enter ? 1 : ANIMATION_MAX_ITERATION);\n+    UINT_PTR eventID = (enter ? IDT_GLASS_ANIMATION_ENTER : IDT_GLASS_ANIMATION_EXIT);\n+    ::SetTimer(GetHWND(), eventID, ANIMATION_TIMER_ELAPSE, NULL);\n+}\n+\n+void FullScreenWindow::ExitFullScreenMode(BOOL animate)\n+{\n+    if (IsAnimationInProcess()) {\n+        \/\/TODO: the animation should be terminated\n+        return;\n+    }\n+\n+\n+    if (animate) {\n+        StartAnimation(FALSE);\n+    } else {\n+        GlassView * view = GetGlassView();\n+        DetachView();\n+        HideWindow();\n+        Close();\n+    }\n+}\n+\n+void FullScreenWindow::StopAnimation(BOOL enter)\n+{\n+    UINT_PTR eventID = (enter ? IDT_GLASS_ANIMATION_ENTER : IDT_GLASS_ANIMATION_EXIT);\n+    ::KillTimer(GetHWND(), eventID);\n+\n+    if (!enter) {\n+        GlassView * view = GetGlassView();\n+        DetachView();\n+        HideWindow();\n+        Close();\n+    }\n+}\n+\n+BOOL FullScreenWindow::IsAnimationInProcess()\n+{\n+    if (m_animationStage >= 1 && m_animationStage <= ANIMATION_MAX_ITERATION) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void FullScreenWindow::UpdateAnimationRect()\n+{\n+    RECT rect;\n+    float stage = (float)m_animationStage \/ (float)ANIMATION_MAX_ITERATION;\n+    rect.left = m_viewRect.left +  (long)((m_windowRect.left - m_viewRect.left) * stage);                                                                ;\n+    rect.top = m_viewRect.top +  (long)((m_windowRect.top - m_viewRect.top) * stage);\n+    rect.right = m_viewRect.right +  (long)((m_windowRect.right - m_viewRect.right) * stage);\n+    rect.bottom = m_viewRect.bottom +  (long)((m_windowRect.bottom - m_viewRect.bottom) * stage);\n+\n+    ::SetWindowPos(GetHWND(), NULL, rect.left, rect.top,\n+                    rect.right - rect.left, rect.bottom - rect.top,\n+                    SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSENDCHANGING | SWP_DEFERERASE);\n+}\n+\n+\/\/ Transparent background window\n+\n+BackgroundWindow::BackgroundWindow() : BaseWnd()\n+{\n+    m_rect.left = 0;\n+    m_rect.top = 0;\n+    m_rect.right = 0;\n+    m_rect.bottom = 0;\n+}\n+\n+BackgroundWindow::~BackgroundWindow()\n+{\n+}\n+\n+HWND BackgroundWindow::Create()\n+{\n+    DWORD dwStyle = WS_POPUP | WS_CLIPCHILDREN;\n+    DWORD dwExStyle = WS_EX_LAYERED | WS_EX_TOOLWINDOW;\n+\n+    return BaseWnd::Create(NULL, 0, 0, 0, 0,\n+                           TEXT(\"\"), dwExStyle, dwStyle, (HBRUSH)::GetStockObject(BLACK_BRUSH));\n+}\n+\n+void BackgroundWindow::Close()\n+{\n+    ::DestroyWindow(GetHWND());\n+}\n+\n+LRESULT BackgroundWindow::WindowProc(UINT msg, WPARAM wParam, LPARAM lParam)\n+{\n+    switch (msg) {\n+        case WM_MOUSEACTIVATE: {\n+            return MA_NOACTIVATE;\n+        }\n+    }\n+\n+    return ::DefWindowProc(GetHWND(), msg, wParam, lParam);\n+}\n+\n+LPCTSTR BackgroundWindow::GetWindowClassNameSuffix()\n+{\n+    return szBackgroundWindowClassName;\n+}\n+\n+void BackgroundWindow::SetWindowRect(RECT * rect)\n+{\n+    ::CopyRect(&m_rect, rect);\n+}\n+\n+void BackgroundWindow::ShowWindow(BOOL animate) {\n+    BYTE opacity = (animate ? 0x0 : 0xFF);\n+    ::SetLayeredWindowAttributes(GetHWND(), RGB(0, 0, 0), opacity, LWA_ALPHA);\n+    ::SetWindowPos(GetHWND(), HWND_TOPMOST, m_rect.left, m_rect.top,\n+                    m_rect.right - m_rect.left, m_rect.bottom - m_rect.top,\n+                    SWP_SHOWWINDOW | SWP_NOACTIVATE);\n+}\n+\n+void BackgroundWindow::HideWindow()\n+{\n+    ::ShowWindow(GetHWND(), SW_HIDE);\n+}\n+\n+void BackgroundWindow::UpdateAnimationOpacity(int animationStage)\n+{\n+    BYTE opacity = ((int)0xFF * animationStage) \/ ANIMATION_MAX_ITERATION;\n+    ::SetLayeredWindowAttributes(GetHWND(), RGB(0, 0, 0), opacity, LWA_ALPHA);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/FullScreenWindow.cpp","additions":531,"deletions":531,"binary":false,"changes":1062,"status":"modified"}]}