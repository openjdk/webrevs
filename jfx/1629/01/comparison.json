{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import javafx.scene.input.KeyCode;\n@@ -39,3 +40,0 @@\n-import static javafx.scene.input.KeyCode.*;\n-import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;\n-\n@@ -72,0 +70,4 @@\n+    private final EventHandler<KeyEvent> spinnerKeyHandler = e -> {\n+        boolean arrowsAreVertical = arrowsAreVertical();\n+        KeyCode increment = arrowsAreVertical ? KeyCode.UP : KeyCode.RIGHT;\n+        KeyCode decrement = arrowsAreVertical ? KeyCode.DOWN : KeyCode.LEFT;\n@@ -73,0 +75,9 @@\n+        if (e.getCode() == increment) {\n+            increment(1);\n+            e.consume();\n+        }\n+        else if (e.getCode() == decrement) {\n+            decrement(1);\n+            e.consume();\n+        }\n+    };\n@@ -87,15 +98,1 @@\n-        \/\/ then spinner-specific mappings for key and mouse input\n-        addDefaultMapping(spinnerInputMap,\n-            new KeyMapping(UP, KeyEvent.KEY_PRESSED, e -> {\n-                if (arrowsAreVertical()) increment(1); else FocusTraversalInputMap.traverseUp(e);\n-            }),\n-            new KeyMapping(RIGHT, KeyEvent.KEY_PRESSED, e -> {\n-                if (! arrowsAreVertical()) increment(1); else FocusTraversalInputMap.traverseRight(e);\n-            }),\n-            new KeyMapping(LEFT, KeyEvent.KEY_PRESSED, e -> {\n-                if (! arrowsAreVertical()) decrement(1); else FocusTraversalInputMap.traverseLeft(e);\n-            }),\n-            new KeyMapping(DOWN, KeyEvent.KEY_PRESSED, e -> {\n-                if (arrowsAreVertical()) decrement(1); else FocusTraversalInputMap.traverseDown(e);\n-            })\n-        );\n+        spinner.addEventFilter(KeyEvent.KEY_PRESSED, spinnerKeyHandler);\n@@ -105,0 +102,6 @@\n+    @Override\n+    public void dispose() {\n+        getNode().removeEventFilter(KeyEvent.KEY_PRESSED, spinnerKeyHandler);\n+\n+        super.dispose();\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/SpinnerBehavior.java","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import javafx.event.Event;\n@@ -44,0 +45,1 @@\n+import com.sun.javafx.event.EventDispatchChainImpl;\n@@ -180,34 +182,16 @@\n-        lh.addEventFilter(control, KeyEvent.ANY, (ke) -> {\n-            if (control.isEditable()) {\n-                \/\/ This prevents a stack overflow from our rebroadcasting of the\n-                \/\/ event to the textfield that occurs in the final else statement\n-                \/\/ of the conditions below.\n-                if (ke.getTarget().equals(textField)) return;\n-\n-                \/\/ Fix for RT-38527 which led to a stack overflow\n-                if (ke.getCode() == KeyCode.ESCAPE) return;\n-\n-                \/\/ This and the additional check of isIncDecKeyEvent in\n-                \/\/ textField's event filter fix JDK-8185937.\n-                if (isIncDecKeyEvent(ke)) return;\n-\n-                \/\/ Fix for the regression noted in a comment in RT-29885.\n-                \/\/ This forwards the event down into the TextField when\n-                \/\/ the key event is actually received by the Spinner.\n-                textField.fireEvent(ke.copyFor(textField, textField));\n-\n-                if (ke.getCode() == KeyCode.ENTER) return;\n-\n-                ke.consume();\n-            }\n-        });\n-\n-        \/\/ This event filter is to enable keyboard events being delivered to the\n-        \/\/ spinner when the user has mouse clicked into the TextField area of the\n-        \/\/ Spinner control. Without this the up\/down\/left\/right arrow keys don't\n-        \/\/ work when you click inside the TextField area (but they do in the case\n-        \/\/ of tabbing in).\n-        lh.addEventFilter(textField, KeyEvent.ANY, (ke) -> {\n-            if (! control.isEditable() || isIncDecKeyEvent(ke)) {\n-                control.fireEvent(ke.copyFor(control, control));\n-                ke.consume();\n+        \/\/ Forwards all key events arriving at the control level to the internal\n+        \/\/ text field, if the control is editable. This forwarding is limited to the\n+        \/\/ text field only, and so the forwarded event will NOT traverse the entire\n+        \/\/ scene graph. The originating event is only consumed if the forwarded\n+        \/\/ event was consumed.\n+        lh.addEventFilter(control, KeyEvent.ANY, e -> {\n+            \/\/ Note: due to a bug, we check if the event is consumed here. The behavior\n+            \/\/ will consume the appropriate arrow keys, but the event is STILL delivered to this\n+            \/\/ filter at the same level. Without the consume check, the TextField will act\n+            \/\/ on arrow keys, moving the cursor unexpectedly.\n+            if (!e.isConsumed() && control.isEditable()) {\n+                Event event = textField.getEventDispatcher().dispatchEvent(e.copyFor(textField, textField), new EventDispatchChainImpl());\n+\n+                if (event == null || event.isConsumed()) {\n+                    e.consume();  \/\/ consume original trigger event\n+                }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/SpinnerSkin.java","additions":18,"deletions":34,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1606,2 +1606,0 @@\n-        intSpinner.setEditable(true);\n-\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/SpinnerTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}