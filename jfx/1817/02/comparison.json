{"files":[{"patch":"@@ -58,0 +58,1 @@\n+     * @param lineSpacing the line spacing (applies only to TYPE_TEXT)\n@@ -60,1 +61,1 @@\n-    public static PathElement[] getRange(TextLayout layout, int start, int end, int type, double dx, double dy) {\n+    public static PathElement[] getRange(TextLayout layout, int start, int end, int type, double dx, double dy, double lineSpacing) {\n@@ -66,1 +67,1 @@\n-            double bottomEdge = bottom + dy;\n+            double bottomEdge = bottom + dy + lineSpacing;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/TextUtils.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1059,1 +1059,1 @@\n-    private PathElement[] getRange(int start, int end, int type) {\n+    private PathElement[] getRange(int start, int end, int type, double lineSpacing) {\n@@ -1065,1 +1065,1 @@\n-            return TextUtils.getRange(layout, start, end, type, dx, dy);\n+            return TextUtils.getRange(layout, start, end, type, dx, dy, lineSpacing);\n@@ -1091,0 +1091,1 @@\n+     * The returned value does not include line spacing.\n@@ -1096,0 +1097,1 @@\n+     * @see #getRangeShape(int, int, boolean)\n@@ -1098,1 +1100,16 @@\n-        return getRange(start, end, TextLayout.TYPE_TEXT);\n+        return getRange(start, end, TextLayout.TYPE_TEXT, 0.0);\n+    }\n+\n+    \/**\n+     * Returns the shape for the range of the text in local coordinates,\n+     * with or without line spacing.\n+     *\n+     * @param start the beginning character index for the range\n+     * @param end the end character index (non-inclusive) for the range\n+     * @param includeLineSpacing whether the shapes include line spacing\n+     * @return an array of {@code PathElement} which can be used to create a {@code Shape}\n+     * @since 25\n+     *\/\n+    public final PathElement[] getRangeShape(int start, int end, boolean includeLineSpacing) {\n+        double lineSpacing = includeLineSpacing ? getLineSpacing() : 0.0;\n+        return getRange(start, end, TextLayout.TYPE_TEXT, lineSpacing);\n@@ -1110,1 +1127,13 @@\n-        return getRange(start, end, TextLayout.TYPE_UNDERLINE);\n+        return getRange(start, end, TextLayout.TYPE_UNDERLINE, 0.0);\n+    }\n+\n+    \/**\n+     * Returns the shape for the strike-through in local coordinates.\n+     *\n+     * @param start the beginning character index for the range\n+     * @param end the end character index (non-inclusive) for the range\n+     * @return an array of {@code PathElement} which can be used to create a {@code Shape}\n+     * @since 25\n+     *\/\n+    public final PathElement[] getStrikeThroughShape(int start, int end) {\n+        return getRange(start, end, TextLayout.TYPE_STRIKETHROUGH, 0.0);\n@@ -1772,1 +1801,1 @@\n-                        return getRange(start, end, TextLayout.TYPE_TEXT);\n+                        return getRange(start, end, TextLayout.TYPE_TEXT, 0.0);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/Text.java","additions":34,"deletions":5,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -196,0 +196,2 @@\n+     * <p>\n+     * NOTE: this method does not take border or padding into account.\n@@ -200,0 +202,1 @@\n+     * @deprecated replaced by {@code getHitInfo()}\n@@ -201,0 +204,1 @@\n+    @Deprecated(since=\"25\")\n@@ -213,0 +217,19 @@\n+    \/**\n+     * Maps local point to {@link HitInfo} in the content.\n+     *\n+     * @param point the specified point to be tested\n+     * @return a {@code HitInfo} representing the character index found\n+     * @since 25\n+     *\/\n+    public final HitInfo getHitInfo(javafx.geometry.Point2D point) {\n+        if (point != null) {\n+            TextLayout layout = getTextLayout();\n+            double x = point.getX() - snappedLeftInset();\n+            double y = point.getY() - snappedTopInset();\n+            TextLayout.Hit h = layout.getHitInfo((float)x, (float)y);\n+            return new HitInfo(h.getCharIndex(), h.getInsertionIndex(), h.isLeading());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n@@ -215,0 +238,2 @@\n+     * <p>\n+     * NOTE: this method does not take border or padding into account.\n@@ -220,0 +245,1 @@\n+     * @deprecated replaced by {@code getCaretShape()}\n@@ -221,0 +247,1 @@\n+    @Deprecated(since=\"25\")\n@@ -223,1 +250,0 @@\n-        \/\/ TODO padding JDK-8341438?\n@@ -227,0 +253,15 @@\n+    \/**\n+     * Returns shape of caret in local coordinates.\n+     *\n+     * @param charIndex the character index for the caret\n+     * @param leading whether the caret is biased on the leading edge of the character\n+     * @return an array of {@code PathElement} which can be used to create a {@code Shape}\n+     * @since 25\n+     *\/\n+    public PathElement[] getCaretShape(int charIndex, boolean leading) {\n+        TextLayout.CaretGeometry g = getTextLayout().getCaretGeometry(charIndex, leading);\n+        double dx = snappedLeftInset();\n+        double dy = snappedTopInset();\n+        return TextUtils.getCaretPathElements(g, dx, dy);\n+    }\n+\n@@ -229,0 +270,6 @@\n+     * <p>\n+     * NOTES:\n+     * <ul>\n+     * <li>this method does not take border or padding into account\n+     * <li>the shapes returned do not include line spacing\n+     * <\/ul>\n@@ -234,0 +281,1 @@\n+     * @deprecated replaced by {@code getRangeShape()}\n@@ -235,0 +283,1 @@\n+    @Deprecated(since=\"25\")\n@@ -236,1 +285,16 @@\n-        return getRange(start, end, TextLayout.TYPE_TEXT);\n+        return getRange(start, end, TextLayout.TYPE_TEXT, false, 0.0);\n+    }\n+\n+    \/**\n+     * Returns shape for the range of the text in local coordinates.\n+     *\n+     * @param start the beginning character index for the range\n+     * @param end the end character index (non-inclusive) for the range\n+     * @param includeLineSpacing determines whether the result includes the line spacing\n+     * @return an array of {@code PathElement} which can be used to create a {@code Shape}\n+     * @since 25\n+     * @see LayoutInfo#getSelectionGeometry(int, int, boolean)\n+     *\/\n+    public final PathElement[] getRangeShape(int start, int end, boolean includeLineSpacing) {\n+        double lineSpacing = includeLineSpacing ? getLineSpacing() : 0.0;\n+        return getRange(start, end, TextLayout.TYPE_TEXT, true, lineSpacing);\n@@ -241,0 +305,2 @@\n+     * <p>\n+     * NOTE: this method does not take border or padding into account.\n@@ -246,0 +312,1 @@\n+     * @deprecated replaced by {@code getUnderlineShape()}\n@@ -247,0 +314,1 @@\n+    @Deprecated(since=\"25\")\n@@ -248,1 +316,27 @@\n-        return getRange(start, end, TextLayout.TYPE_UNDERLINE);\n+        return getRange(start, end, TextLayout.TYPE_UNDERLINE, false, 0.0);\n+    }\n+\n+    \/**\n+     * Returns the shape for the underline in local coordinates.\n+     *\n+     * @param start the beginning character index for the range\n+     * @param end the end character index (non-inclusive) for the range\n+     * @return an array of {@code PathElement} which can be used to create a {@code Shape}\n+     * @since 25\n+     * @see LayoutInfo#getUnderlineGeometry(int, int)\n+     *\/\n+    public final PathElement[] getUnderlineShape(int start, int end) {\n+        return getRange(start, end, TextLayout.TYPE_UNDERLINE, true, 0.0);\n+    }\n+\n+    \/**\n+     * Returns the shape for the strike-through in local coordinates.\n+     *\n+     * @param start the beginning character index for the range\n+     * @param end the end character index (non-inclusive) for the range\n+     * @return an array of {@code PathElement} which can be used to create a {@code Shape}\n+     * @since 25\n+     * @see LayoutInfo#getStrikeThroughGeometry(int, int)\n+     *\/\n+    public final PathElement[] getStrikeThroughShape(int start, int end) {\n+        return getRange(start, end, TextLayout.TYPE_STRIKETHROUGH, true, 0.0);\n@@ -371,1 +465,10 @@\n-    private PathElement[] getRange(int start, int end, int type) {\n+    private PathElement[] getRange(int start, int end, int type, boolean accountForInsets, double lineSpacing) {\n+        double dx;\n+        double dy;\n+        if(accountForInsets) {\n+            dx = snappedLeftInset();\n+            dy = snappedTopInset();\n+        } else {\n+            dx = 0.0;\n+            dy = 0.0;\n+        }\n@@ -373,1 +476,1 @@\n-        return TextUtils.getRange(layout, start, end, type, 0, 0);\n+        return TextUtils.getRange(layout, start, end, type, dx, dy, lineSpacing);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/TextFlow.java","additions":108,"deletions":5,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -28,0 +28,11 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import javafx.geometry.Bounds;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Point2D;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.shape.Path;\n+import javafx.scene.shape.PathElement;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.HitInfo;\n@@ -30,2 +41,0 @@\n-import javafx.scene.layout.VBox;\n-import javafx.scene.Scene;\n@@ -33,4 +42,0 @@\n-import test.com.sun.javafx.pgstub.StubToolkit;\n-\n-import com.sun.javafx.tk.Toolkit;\n-\n@@ -38,2 +43,2 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import com.sun.javafx.tk.Toolkit;\n+import test.com.sun.javafx.pgstub.StubToolkit;\n@@ -43,0 +48,2 @@\n+    private static final double EPSILON = 0.00001;\n+\n@@ -114,0 +121,7 @@\n+    }\n+\n+    private static Text text(String text) {\n+        Text t = new Text(text);\n+        t.setFont(new Font(\"System\", 12.0));\n+        return t;\n+    }\n@@ -115,0 +129,117 @@\n+    \/\/ new StubTextLayout generates prodictable text shapes\n+    private static void checkNear(PathElement[] em, double ex, double ey, double ew, double eh) {\n+        Bounds b = new Path(em).getBoundsInLocal();\n+        double x = b.getMinX();\n+        double y = b.getMinY();\n+        double w = b.getWidth();\n+        double h = b.getHeight();\n+        assertEquals(ex, x, EPSILON);\n+        assertEquals(ey, y, EPSILON);\n+        assertEquals(ew, w, EPSILON);\n+        assertEquals(eh, h, EPSILON);\n+    }\n+\n+    private void checkNear(HitInfo h, int expectedCharIndex, boolean expectedLeading, int expectedInsert) {\n+        assertEquals(expectedCharIndex, h.getCharIndex());\n+        assertEquals(expectedLeading, h.isLeading());\n+        assertEquals(expectedInsert, h.getInsertionIndex());\n+    }\n+\n+    @Test\n+    public void caretShape() {\n+        int first = 0;\n+        int second = 6;\n+\n+        TextFlow f = new TextFlow(text(\"01234\\n56789\"));\n+        checkNear(f.caretShape(first, true), -1, -1, 2, 14);\n+        checkNear(f.caretShape(second, true), -1, 11, 2, 14);\n+        checkNear(f.getCaretShape(first, true), -1, -1, 2, 14);\n+        checkNear(f.getCaretShape(second, true), -1, 11, 2, 14);\n+\n+        f.setPadding(new Insets(100));\n+        \/\/ legacy implementation accounts for no insets\n+        checkNear(f.caretShape(first, true), -1, -1, 2, 14);\n+        checkNear(f.caretShape(second, true), -1, 11, 2, 14);\n+        \/\/ new implementation accounts for insets\n+        checkNear(f.getCaretShape(first, true), 99, 99, 2, 14);\n+        checkNear(f.getCaretShape(second, true), 99, 111, 2, 14);\n+\n+        f.setLineSpacing(50);\n+        \/\/ legacy implementation accounts neither for insets nor line spacing\n+        checkNear(f.caretShape(first, true), -1, -1, 2, 14);\n+        checkNear(f.caretShape(second, true), -1, 61, 2, 14);\n+        \/\/ new implementation accounts for insets and line spacing\n+        checkNear(f.getCaretShape(first, true), 99, 99, 2, 14);\n+        checkNear(f.getCaretShape(second, true), 99, 161, 2, 14);\n+    }\n+\n+    @Test\n+    public void hitInfo() {\n+        double first = 0;\n+        double second = 12;\n+        double padding = 100;\n+        double lineSpacing = 50;\n+\n+        TextFlow f = new TextFlow(text(\"01234\\n56789\"));\n+        checkNear(f.hitTest(new Point2D(0, first)), 0, true, 0);\n+        checkNear(f.hitTest(new Point2D(0, second)), 6, true, 6);\n+        checkNear(f.getHitInfo(new Point2D(0, first)), 0, true, 0);\n+        checkNear(f.getHitInfo(new Point2D(0, second)), 6, true, 6);\n+\n+        f.setPadding(new Insets(padding));\n+        \/\/ legacy implementation accounts for no insets\n+        checkNear(f.hitTest(new Point2D(padding, padding + first)), 11, false, 12);\n+        checkNear(f.hitTest(new Point2D(padding, padding + second)), 11, false, 12);\n+        \/\/ new implementation accounts for insets\n+        checkNear(f.getHitInfo(new Point2D(padding, padding + first)), 0, true, 0);\n+        checkNear(f.getHitInfo(new Point2D(padding, padding + second)), 6, true, 6);\n+\n+        f.setLineSpacing(lineSpacing);\n+        \/\/ legacy implementation accounts neither for insets nor line spacing\n+        checkNear(f.hitTest(new Point2D(padding, padding + first)), 10, false, 11);\n+        checkNear(f.hitTest(new Point2D(padding, padding + second)), 10, false, 11);\n+        \/\/ new implementation accounts for insets and line spacing\n+        checkNear(f.getHitInfo(new Point2D(padding, padding + first)), 0, true, 0);\n+        checkNear(f.getHitInfo(new Point2D(padding, padding + lineSpacing + second)), 6, true, 6);\n+    }\n+\n+    @Test\n+    public void rangeShape() {\n+        TextFlow f = new TextFlow(text(\"01234\\n56789\"));\n+        checkNear(f.rangeShape(0, 10), -1, -1, 62, 26);\n+        checkNear(f.getRangeShape(0, 10, false), -1, -1, 62, 26);\n+        checkNear(f.getRangeShape(0, 10, true), -1, -1, 62, 26);\n+\n+        f.setPadding(new Insets(100));\n+        \/\/ legacy implementation accounts for no insets\n+        checkNear(f.rangeShape(0, 10), -1, -1, 62, 26);\n+        \/\/ new implementation accounts for insets\n+        checkNear(f.getRangeShape(0, 10, false), 99, 99, 62, 26);\n+        checkNear(f.getRangeShape(0, 10, true), 99, 99, 62, 26);\n+\n+        f.setLineSpacing(50);\n+        \/\/ legacy implementation accounts neither for insets nor line spacing\n+        checkNear(f.rangeShape(0, 10), -1, -1, 62, 76);\n+        \/\/ new implementation accounts for insets and line spacing\n+        checkNear(f.getRangeShape(0, 10, false), 99, 99, 62, 76);\n+        checkNear(f.getRangeShape(0, 10, true), 99, 99, 62, 126);\n+    }\n+\n+    @Test\n+    public void strikeThroughShape() {\n+        TextFlow f = new TextFlow(text(\"01234567890\"));\n+        checkNear(f.getStrikeThroughShape(0, 10), -1, 8.6, 122, 3);\n+\n+        f.setPadding(new Insets(100));\n+        checkNear(f.getStrikeThroughShape(0, 10), 99, 108.6, 122, 3);\n+    }\n+\n+    @Test\n+    public void underlineShape() {\n+        TextFlow f = new TextFlow(text(\"01234567890\"));\n+        checkNear(f.underlineShape(0, 10), -1, 9.6, 122, 3);\n+        checkNear(f.getUnderlineShape(0, 10), -1, 9.6, 122, 3);\n+\n+        f.setPadding(new Insets(100));\n+        checkNear(f.underlineShape(0, 10), -1, 9.6, 122, 3);\n+        checkNear(f.getUnderlineShape(0, 10), 99, 109.6, 122, 3);\n@@ -116,1 +247,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/text\/TextFlowTest.java","additions":140,"deletions":9,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,10 +28,0 @@\n-import javafx.scene.text.Font;\n-import javafx.scene.text.Text;\n-import javafx.scene.layout.HBox;\n-import javafx.scene.Scene;\n-import javafx.stage.Stage;\n-import test.com.sun.javafx.pgstub.StubToolkit;\n-\n-import com.sun.javafx.tk.Toolkit;\n-\n-import org.junit.jupiter.api.Test;\n@@ -40,1 +30,0 @@\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -42,0 +31,1 @@\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -43,0 +33,14 @@\n+import javafx.geometry.Bounds;\n+import javafx.geometry.Point2D;\n+import javafx.geometry.VPos;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.shape.Path;\n+import javafx.scene.shape.PathElement;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.HitInfo;\n+import javafx.scene.text.Text;\n+import javafx.stage.Stage;\n+import org.junit.jupiter.api.Test;\n+import com.sun.javafx.tk.Toolkit;\n+import test.com.sun.javafx.pgstub.StubToolkit;\n@@ -46,0 +50,2 @@\n+    private static final double EPSILON = 0.00001;\n+\n@@ -321,1 +327,235 @@\n-  }\n+    }\n+\n+    private static Text text(String text) {\n+        Text t = new Text(text);\n+        t.setFont(new Font(\"System\", 12.0));\n+        return t;\n+    }\n+\n+    \/\/ new StubTextLayout generates prodictable text shapes\n+    private static void checkNear(PathElement[] em, double ex, double ey, double ew, double eh) {\n+        Bounds b = new Path(em).getBoundsInLocal();\n+        double x = b.getMinX();\n+        double y = b.getMinY();\n+        double w = b.getWidth();\n+        double h = b.getHeight();\n+        assertEquals(ex, x, EPSILON);\n+        assertEquals(ey, y, EPSILON);\n+        assertEquals(ew, w, EPSILON);\n+        assertEquals(eh, h, EPSILON);\n+    }\n+\n+    private void checkNear(HitInfo h, int expectedCharIndex, boolean expectedLeading, int expectedInsert) {\n+        assertEquals(expectedCharIndex, h.getCharIndex());\n+        assertEquals(expectedLeading, h.isLeading());\n+        assertEquals(expectedInsert, h.getInsertionIndex());\n+    }\n+\n+    @Test\n+    public void caretShape() {\n+        int first = 0;\n+        int second = 6;\n+\n+        Text t = text(\"01234\\n56789\");\n+\n+        \/\/ top\n+        t.setTextOrigin(VPos.TOP);\n+        t.setLineSpacing(0);\n+        checkNear(t.caretShape(first, true), -1, -1, 2, 14);\n+        checkNear(t.caretShape(second, true), -1, 11, 2, 14);\n+        t.setLineSpacing(50);\n+        checkNear(t.caretShape(first, true), -1, -1, 2, 14);\n+        checkNear(t.caretShape(second, true), -1, 61, 2, 14);\n+\n+        \/\/ baseline\n+        t.setTextOrigin(VPos.BASELINE);\n+        t.setLineSpacing(0);\n+        checkNear(t.caretShape(first, true), -1, -10.6, 2, 14);\n+        checkNear(t.caretShape(second, true), -1, 1.4, 2, 14);\n+        t.setLineSpacing(50);\n+        checkNear(t.caretShape(first, true), -1, -10.6, 2, 14);\n+        checkNear(t.caretShape(second, true), -1, 51.4, 2, 14);\n+\n+        \/\/ center\n+        t.setTextOrigin(VPos.CENTER);\n+        t.setLineSpacing(0);\n+        checkNear(t.caretShape(first, true), -1, -13, 2, 14);\n+        checkNear(t.caretShape(second, true), -1, -1, 2, 14);\n+        t.setLineSpacing(50);\n+        checkNear(t.caretShape(first, true), -1, -38, 2, 14);\n+        checkNear(t.caretShape(second, true), -1, 24, 2, 14);\n+\n+        \/\/ bottom\n+        t.setTextOrigin(VPos.BOTTOM);\n+        t.setLineSpacing(0);\n+        checkNear(t.caretShape(first, true), -1, -25, 2, 14);\n+        checkNear(t.caretShape(second, true), -1, -13, 2, 14);\n+        t.setLineSpacing(50);\n+        checkNear(t.caretShape(first, true), -1, -75, 2, 14);\n+        checkNear(t.caretShape(second, true), -1, -13, 2, 14);\n+    }\n+\n+    @Test\n+    public void hitInfo() {\n+        double first = 0;\n+        double second = 12;\n+        double baseline = -9;\n+        double height = -24;\n+        double lineSpacing = 50;\n+\n+        Text t = text(\"01234\\n56789\");\n+\n+        \/\/ top\n+        t.setTextOrigin(VPos.TOP);\n+        t.setLineSpacing(0);\n+        checkNear(t.hitTest(new Point2D(0, first)), 0, true, 0);\n+        checkNear(t.hitTest(new Point2D(0, second)), 6, true, 6);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.hitTest(new Point2D(0, first)), 0, true, 0);\n+        checkNear(t.hitTest(new Point2D(0, lineSpacing + second)), 6, true, 6);\n+\n+        \/\/ baseline\n+        t.setTextOrigin(VPos.BASELINE);\n+        t.setLineSpacing(0);\n+        checkNear(t.hitTest(new Point2D(0, baseline + first)), 0, true, 0);\n+        checkNear(t.hitTest(new Point2D(0, baseline + second)), 6, true, 6);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.hitTest(new Point2D(0, baseline + first)), 0, true, 0);\n+        checkNear(t.hitTest(new Point2D(0, baseline + lineSpacing + second)), 6, true, 6);\n+\n+        \/\/ center\n+        t.setTextOrigin(VPos.CENTER);\n+        t.setLineSpacing(0);\n+        checkNear(t.hitTest(new Point2D(0, height \/ 2 + first)), 0, true, 0);\n+        checkNear(t.hitTest(new Point2D(0, height \/ 2 + second)), 6, true, 6);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.hitTest(new Point2D(0, height \/ 2 + first)), 0, true, 0);\n+        checkNear(t.hitTest(new Point2D(0, height \/ 2 + lineSpacing + second)), 6, true, 6);\n+\n+        \/\/ bottom\n+        t.setTextOrigin(VPos.BOTTOM);\n+        t.setLineSpacing(0);\n+        checkNear(t.hitTest(new Point2D(0, height + first)), 0, true, 0);\n+        checkNear(t.hitTest(new Point2D(0, height + second)), 6, true, 6);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.hitTest(new Point2D(0, height + first)), 0, true, 0);\n+        checkNear(t.hitTest(new Point2D(0, height + lineSpacing + second)), 6, true, 6);\n+    }\n+\n+    @Test\n+    public void rangeShape() {\n+        Text t = text(\"01234\\n56789\");\n+        double lineSpacing = 50;\n+\n+        \/\/ top\n+        t.setTextOrigin(VPos.TOP);\n+        t.setLineSpacing(0);\n+        checkNear(t.rangeShape(0, 10), -1, -1, 62, 26);\n+        checkNear(t.getRangeShape(0, 10, false), -1, -1, 62, 26);\n+        checkNear(t.getRangeShape(0, 10, true), -1, -1, 62, 26);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.rangeShape(0, 10), -1, -1, 62, 76);\n+        checkNear(t.getRangeShape(0, 10, false), -1, -1, 62, 76);\n+        checkNear(t.getRangeShape(0, 10, true), -1, -1, 62, 126);\n+\n+        \/\/ baseline\n+        t.setTextOrigin(VPos.BASELINE);\n+        t.setLineSpacing(0);\n+        checkNear(t.rangeShape(0, 10), -1, -10.6, 62, 26);\n+        checkNear(t.getRangeShape(0, 10, false), -1, -10.6, 62, 26);\n+        checkNear(t.getRangeShape(0, 10, true), -1, -10.6, 62, 26);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.rangeShape(0, 10), -1, -10.6, 62, 76);\n+        checkNear(t.getRangeShape(0, 10, false), -1, -10.6, 62, 76);\n+        checkNear(t.getRangeShape(0, 10, true), -1, -10.6, 62, 126);\n+\n+        \/\/ center\n+        t.setTextOrigin(VPos.CENTER);\n+        t.setLineSpacing(0);\n+        checkNear(t.rangeShape(0, 10), -1, -13, 62, 26);\n+        checkNear(t.getRangeShape(0, 10, false), -1, -13, 62, 26);\n+        checkNear(t.getRangeShape(0, 10, true), -1, -13, 62, 26);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.rangeShape(0, 10), -1, -38, 62, 76);\n+        checkNear(t.getRangeShape(0, 10, false), -1, -38, 62, 76);\n+        checkNear(t.getRangeShape(0, 10, true), -1, -38, 62, 126);\n+\n+        \/\/ bottom\n+        t.setTextOrigin(VPos.BOTTOM);\n+        t.setLineSpacing(0);\n+        checkNear(t.rangeShape(0, 10), -1, -25, 62, 26);\n+        checkNear(t.getRangeShape(0, 10, false), -1, -25, 62, 26);\n+        checkNear(t.getRangeShape(0, 10, true), -1, -25, 62, 26);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.rangeShape(0, 10), -1, -75, 62, 76);\n+        checkNear(t.getRangeShape(0, 10, false), -1, -75, 62, 76);\n+        checkNear(t.getRangeShape(0, 10, true), -1, -75, 62, 126);\n+    }\n+\n+    @Test\n+    public void strikeThroughShape() {\n+        Text t = text(\"01234\\n56789\");\n+        double lineSpacing = 50;\n+\n+        \/\/ top\n+        t.setTextOrigin(VPos.TOP);\n+        t.setLineSpacing(0);\n+        checkNear(t.getStrikeThroughShape(0, 10), -1, 8.6, 62, 15);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.getStrikeThroughShape(0, 10), -1, 8.6, 62, 65);\n+\n+        \/\/ baseline\n+        t.setTextOrigin(VPos.BASELINE);\n+        t.setLineSpacing(0);\n+        checkNear(t.getStrikeThroughShape(0, 10), -1, -1, 62, 15);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.getStrikeThroughShape(0, 10), -1, -1, 62, 65);\n+\n+        \/\/ center\n+        t.setTextOrigin(VPos.CENTER);\n+        t.setLineSpacing(0);\n+        checkNear(t.getStrikeThroughShape(0, 10), -1, -3.4, 62, 15);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.getStrikeThroughShape(0, 10), -1, -28.4, 62, 65);\n+\n+        \/\/ bottom\n+        t.setTextOrigin(VPos.BOTTOM);\n+        t.setLineSpacing(0);\n+        checkNear(t.getStrikeThroughShape(0, 10), -1, -15.4, 62, 15);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.getStrikeThroughShape(0, 10), -1, -65.4, 62, 65);\n+    }\n+\n+    @Test\n+    public void underlineShape() {\n+        Text t = text(\"01234\\n56789\");\n+        double lineSpacing = 50;\n+\n+        \/\/ top\n+        t.setTextOrigin(VPos.TOP);\n+        t.setLineSpacing(0);\n+        checkNear(t.underlineShape(0, 10), -1, 9.6, 62, 15);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.underlineShape(0, 10), -1, 9.6, 62, 65);\n+\n+        \/\/ baseline\n+        t.setTextOrigin(VPos.BASELINE);\n+        t.setLineSpacing(0);\n+        checkNear(t.underlineShape(0, 10), -1, 0, 62, 15);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.underlineShape(0, 10), -1, 0, 62, 65);\n+\n+        \/\/ center\n+        t.setTextOrigin(VPos.CENTER);\n+        t.setLineSpacing(0);\n+        checkNear(t.underlineShape(0, 10), -1, -2.4, 62, 15);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.underlineShape(0, 10), -1, -27.4, 62, 65);\n+\n+        \/\/ bottom\n+        t.setTextOrigin(VPos.BOTTOM);\n+        t.setLineSpacing(0);\n+        checkNear(t.underlineShape(0, 10), -1, -14.4, 62, 15);\n+        t.setLineSpacing(lineSpacing);\n+        checkNear(t.underlineShape(0, 10), -1, -64.4, 62, 65);\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/text\/TextTest.java","additions":253,"deletions":13,"binary":false,"changes":266,"status":"modified"}]}