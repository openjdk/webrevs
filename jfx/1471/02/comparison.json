{"files":[{"patch":"@@ -4366,0 +4366,1 @@\n+    options.tags(\"interpolationType:a:Interpolation type:\")\n","filename":"build.gradle","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.util.List;\n+import java.util.Objects;\n@@ -63,0 +65,64 @@\n+\n+    \/**\n+     * Converts the specified list into an unmodifiable list that does not contain {@code null} values.\n+     * The returned list is a copy of, and not a wrapper around the specified list.\n+     *\n+     * @param <T> the type of elements in the list\n+     * @param list the list, not {@code null}\n+     * @return an unmodifiable list that does not contain null values\n+     *\/\n+    public static <T> UnmodifiableArrayList<T> copyOfNullFiltered(List<T> list) {\n+        Objects.requireNonNull(list, \"list cannot be null\");\n+\n+        int index = 0;\n+        int numNonNullValues = 0;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newValues = (T[])new Object[list.size()];\n+\n+        if (list instanceof RandomAccess) {\n+            \/\/ Prevents the iterator allocation for random-access lists.\n+            for (int i = 0, max = list.size(); i < max; ++i) {\n+                T value = list.get(i);\n+                if (value != null) {\n+                    newValues[index++] = value;\n+                    ++numNonNullValues;\n+                }\n+            }\n+        } else {\n+            for (T value : list) {\n+                if (value != null) {\n+                    newValues[index++] = value;\n+                    ++numNonNullValues;\n+                }\n+            }\n+        }\n+\n+        return new UnmodifiableArrayList<>(newValues, numNonNullValues);\n+    }\n+\n+    \/**\n+     * Converts the specified array into an unmodifiable list that does not contain {@code null} values.\n+     * The returned list is a copy of, and not a wrapper around the specified array.\n+     *\n+     * @param <T> the type of elements in the array\n+     * @param elements the array, not {@code null}\n+     * @return an unmodifiable list that does not contain null values\n+     *\/\n+    public static <T> UnmodifiableArrayList<T> copyOfNullFiltered(T[] elements) {\n+        Objects.requireNonNull(elements, \"elements cannot be null\");\n+\n+        int numNonNullValues = 0;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newValues = (T[])new Object[elements.length];\n+\n+        for (int i = 0, j = 0; i < elements.length; ++i) {\n+            if (elements[i] != null) {\n+                newValues[j++] = elements[i];\n+                ++numNonNullValues;\n+            }\n+        }\n+\n+        return new UnmodifiableArrayList<>(newValues, numNonNullValues);\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/UnmodifiableArrayList.java","additions":67,"deletions":1,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+--add-exports javafx.base\/com.sun.javafx=ALL-UNNAMED\n","filename":"modules\/javafx.base\/src\/test\/addExports","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx;\n+\n+import com.sun.javafx.UnmodifiableArrayList;\n+import org.junit.jupiter.api.Test;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class UnmodifiableArrayListTest {\n+\n+    @Test\n+    void testCopyOfNullFilteredList_nullList() {\n+        assertThrows(NullPointerException.class, () -> UnmodifiableArrayList.copyOfNullFiltered((List<?>)null));\n+    }\n+\n+    @Test\n+    void testCopyOfNullFilteredList_nullArray() {\n+        assertThrows(NullPointerException.class, () -> UnmodifiableArrayList.copyOfNullFiltered((Object[])null));\n+    }\n+\n+    @Test\n+    void testCopyOfNullFilteredList_randomAccess() {\n+        var list = new ArrayList<String>();\n+        list.add(\"a\");\n+        list.add(null);\n+        list.add(\"b\");\n+        list.add(null);\n+\n+        assertEquals(List.of(\"a\", \"b\"), UnmodifiableArrayList.copyOfNullFiltered(list));\n+    }\n+\n+    @Test\n+    void testCopyOfNullFilteredList_nonRandomAccess() {\n+        var list = new LinkedList<String>();\n+        list.add(\"a\");\n+        list.add(null);\n+        list.add(\"b\");\n+        list.add(null);\n+\n+        assertEquals(List.of(\"a\", \"b\"), UnmodifiableArrayList.copyOfNullFiltered(list));\n+    }\n+\n+    @Test\n+    void testCopyOfNullFilteredArray() {\n+        var list = new String[4];\n+        list[0] = \"a\";\n+        list[1] = null;\n+        list[2] = \"b\";\n+        list[3] = null;\n+\n+        assertEquals(List.of(\"a\", \"b\"), UnmodifiableArrayList.copyOfNullFiltered(list));\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/UnmodifiableArrayListTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene.paint;\n+\n+import javafx.animation.Interpolatable;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.Paint;\n+import javafx.scene.paint.RadialGradient;\n+import javafx.scene.paint.Stop;\n+import java.util.List;\n+\n+public final class PaintUtils {\n+\n+    private PaintUtils() {}\n+\n+    \/**\n+     * Interpolates between potentially different types of paint.\n+     * <p>\n+     * In addition to homogeneous interpolations between paints of the same type, the following\n+     * heterogeneous interpolations are supported:\n+     * <ul>\n+     *     <li>Color ↔ LinearGradient\n+     *     <li>Color ↔ RadialGradient\n+     * <\/ul>\n+     * If a paint is not interpolatable, {@code startValue} is returned for {@code t < 0.5},\n+     * and {@code endValue} is returned otherwise.\n+     *\/\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public static Paint interpolate(Paint startValue, Paint endValue, double t) {\n+        if (startValue instanceof Color start) {\n+            if (endValue instanceof Color end) {\n+                return start.interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof LinearGradient end) {\n+                return newSolidGradient(end, start).interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof RadialGradient end) {\n+                return newSolidGradient(end, start).interpolate(end, t);\n+            }\n+        }\n+\n+        if (startValue instanceof LinearGradient start) {\n+            if (endValue instanceof LinearGradient end) {\n+                return start.interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof Color end) {\n+                return start.interpolate(newSolidGradient(start, end), t);\n+            }\n+        }\n+\n+        if (startValue instanceof RadialGradient start) {\n+            if (endValue instanceof RadialGradient end) {\n+                return start.interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof Color end) {\n+                return start.interpolate(newSolidGradient(start, end), t);\n+            }\n+        }\n+\n+        if (startValue instanceof Interpolatable start\n+                && endValue instanceof Interpolatable end\n+                && startValue.getClass().isInstance(endValue)) {\n+            return (Paint)start.interpolate(end, t);\n+        }\n+\n+        return t < 0.5 ? startValue : endValue;\n+    }\n+\n+    \/**\n+     * Creates a new linear gradient that consists of two stops with the same color.\n+     *\/\n+    public static LinearGradient newSolidGradient(LinearGradient source, Color color) {\n+        return new LinearGradient(\n+                source.getStartX(), source.getStartY(),\n+                source.getEndX(), source.getEndY(),\n+                source.isProportional(),\n+                source.getCycleMethod(),\n+                List.of(new Stop(0, color), new Stop(1, color)));\n+    }\n+\n+    \/**\n+     * Creates a new radial gradient that consists of two stops with the same color.\n+     *\/\n+    public static RadialGradient newSolidGradient(RadialGradient source, Color color) {\n+        return new RadialGradient(\n+                source.getFocusAngle(), source.getFocusDistance(),\n+                source.getCenterX(), source.getCenterY(),\n+                source.getRadius(),\n+                source.isProportional(),\n+                source.getCycleMethod(),\n+                List.of(new Stop(0, color), new Stop(1, color)));\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/paint\/PaintUtils.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import javafx.animation.Interpolatable;\n@@ -50,0 +51,2 @@\n+import java.util.Objects;\n+import com.sun.javafx.UnmodifiableArrayList;\n@@ -146,0 +149,166 @@\n+    \/**\n+     * Utility function that interpolates between two double values.\n+     *\/\n+    public static double interpolate(double from, double to, double t) {\n+        return from + t * (to - from);\n+    }\n+\n+    \/**\n+     * Utility function that interpolates between two discrete values, returning {@code from}\n+     * when {@code t < 0.5}, and {@code to} otherwise.\n+     *\/\n+    public static <T> T interpolateDiscrete(T from, T to, double t) {\n+        return t < 0.5 ? from : to;\n+    }\n+\n+    \/**\n+     * Utility function that interpolates between two discrete values, returning {@code from}\n+     * when {@code t < 0.5}, and {@code to} otherwise.\n+     *\/\n+    public static double interpolateDiscrete(double from, double to, double t) {\n+        return t < 0.5 ? from : to;\n+    }\n+\n+    \/**\n+     * Computes an intermediate list that consists of the pairwise interpolation between two lists,\n+     * using the following rules:\n+     * <ol>\n+     *     <li>The size of the returned list corresponds to the size of the second list.\n+     *     <li>If the first list has fewer elements than the second list, the missing elements are copied\n+     *         from the second list.\n+     *     <li>If the first list has more elements than the second list, the excess elements are discarded.\n+     *     <li>If the intermediate list is shallow-equal to the first list passed into the method (i.e. its\n+     *         elements are references to the same objects), the existing list is returned.\n+     *     <li>If a new list is returned, it is unmodifiable.\n+     * <\/ol>\n+     *\n+     * @param firstList the first list, not {@code null}\n+     * @param secondList the second list, not {@code null}\n+     * @return the intermediate list\n+     *\/\n+    public static <T extends Interpolatable<T>> List<T> interpolateListsPairwise(\n+            List<T> firstList, List<T> secondList, double t) {\n+        Objects.requireNonNull(firstList, \"firstList\");\n+        Objects.requireNonNull(secondList, \"secondList\");\n+\n+        if (secondList.isEmpty()) {\n+            return firstList.isEmpty() ? firstList : secondList;\n+        }\n+\n+        int listSize = firstList.size();\n+\n+        \/\/ For small equisized lists (up to 8 elements), we use an optimization to prevent the allocation\n+        \/\/ of a new array in case the intermediate list would be equal to the existing list.\n+        if (listSize <= 8 && listSize == secondList.size()) {\n+            return interpolateEquisizedListsPairwise(firstList, secondList, t);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newArray = (T[])new Interpolatable[secondList.size()];\n+        boolean equal = firstList.size() == secondList.size();\n+\n+        for (int i = 0, firstListSize = firstList.size(); i < newArray.length; ++i) {\n+            if (firstListSize > i) {\n+                newArray[i] = firstList.get(i).interpolate(secondList.get(i), t);\n+                equal &= newArray[i] == firstList.get(i);\n+            } else {\n+                newArray[i] = secondList.get(i);\n+            }\n+        }\n+\n+        return equal ? firstList : new UnmodifiableArrayList<>(newArray, newArray.length);\n+    }\n+\n+    \/**\n+     * Computes an intermediate list that consists of the pairwise interpolation between two lists\n+     * of equal size, each containing up to 8 elements.\n+     * <p>\n+     * This method is an optimization: it does not allocate memory when the intermediate list is\n+     * shallow-equal to the list that is passed into this method, i.e. its elements are references\n+     * to the same objects. The existing list is returned in this case.\n+     *\/\n+    private static <T extends Interpolatable<T>> List<T> interpolateEquisizedListsPairwise(\n+            List<T> firstList, List<T> secondList, double t) {\n+        int listSize = firstList.size();\n+        if (listSize > 8 || listSize != secondList.size()) {\n+            throw new AssertionError();\n+        }\n+\n+        T item1 = null, item2 = null, item3 = null, item4 = null, item5 = null, item6 = null, item7 = null;\n+        T item0 = firstList.get(0).interpolate(secondList.get(0), t);\n+        boolean same = item0 == firstList.get(0);\n+\n+        if (listSize > 1) {\n+            item1 = firstList.get(1).interpolate(secondList.get(1), t);\n+            same &= item1 == firstList.get(1);\n+\n+            if (listSize > 2) {\n+                item2 = firstList.get(2).interpolate(secondList.get(2), t);\n+                same &= item2 == firstList.get(2);\n+\n+                if (listSize > 3) {\n+                    item3 = firstList.get(3).interpolate(secondList.get(3), t);\n+                    same &= item3 == firstList.get(3);\n+\n+                    if (listSize > 4) {\n+                        item4 = firstList.get(4).interpolate(secondList.get(4), t);\n+                        same &= item4 == firstList.get(4);\n+\n+                        if (listSize > 5) {\n+                            item5 = firstList.get(5).interpolate(secondList.get(5), t);\n+                            same &= item5 == firstList.get(5);\n+\n+                            if (listSize > 6) {\n+                                item6 = firstList.get(6).interpolate(secondList.get(6), t);\n+                                same &= item6 == firstList.get(6);\n+\n+                                if (listSize > 7) {\n+                                    item7 = firstList.get(7).interpolate(secondList.get(7), t);\n+                                    same &= item7 == firstList.get(7);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (same) {\n+            return firstList;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newArray = (T[])new Interpolatable[listSize];\n+        newArray[0] = item0;\n+\n+        if (listSize > 1) {\n+            newArray[1] = item1;\n+\n+            if (listSize > 2) {\n+                newArray[2] = item2;\n+\n+                if (listSize > 3) {\n+                    newArray[3] = item3;\n+\n+                    if (listSize > 4) {\n+                        newArray[4] = item4;\n+\n+                        if (listSize > 5) {\n+                            newArray[5] = item5;\n+\n+                            if (listSize > 6) {\n+                                newArray[6] = item6;\n+\n+                                if (listSize > 7) {\n+                                    newArray[7] = item7;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return new UnmodifiableArrayList<>(newArray, listSize);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/util\/Utils.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -29,3 +29,34 @@\n- * A value that can be interpolated. It defines single\n- * {@link #interpolate(Object, double)} method, which returns interpolated value\n- * of given fraction.\n+ * A value that can be interpolated. It defines a single {@link #interpolate(Object, double)}\n+ * method, which returns an intermediate value between the value of this {@code Interpolatable}\n+ * and the specified target value.\n+ * <p>\n+ * Component values can be interpolated in different ways, depending on the semantics of the component type:\n+ * <table class=\"striped\">\n+ *     <caption><b>Interpolation types<\/b><\/caption>\n+ *     <tbody>\n+ *         <tr><td><a id=\"default\" style=\"white-space: nowrap\">default<\/a><\/td>\n+ *             <td>Component types that implement {@code Interpolatable} are interpolated by calling the\n+ *                 {@link #interpolate(Object, double)} method.<\/td>\n+ *         <\/tr>\n+ *         <tr><td><a id=\"linear\" style=\"white-space: nowrap\">linear<\/a><\/td>\n+ *             <td>Two components are combined by linear interpolation such that {@code t = 0} produces\n+ *                 the start value, and {@code t = 1} produces the end value. This interpolation type\n+ *                 is usually applicable for numeric components.<\/td>\n+ *         <\/tr>\n+ *         <tr><td><a id=\"discrete\" style=\"white-space: nowrap\">discrete<\/a><\/td>\n+ *             <td>If two components cannot be meaningfully combined, the intermediate component value\n+ *                 is equal to the start value for {@code t < 0.5} and equal to the end value for\n+ *                 {@code t >= 0.5}.<\/td>\n+ *         <\/tr>\n+ *         <tr><td><a id=\"pairwise\" style=\"white-space: nowrap\">pairwise<\/a><\/td>\n+ *             <td>Two lists are combined by pairwise interpolation. If the start list has fewer elements than\n+ *                 the target list, the missing elements are copied from the target list. If the start list has\n+ *                 more elements than the target list, the excess elements are discarded.\n+ *             <\/td>\n+ *         <\/tr>\n+ *         <tr><td style=\"white-space: nowrap\">(see prose)<\/td>\n+ *             <td>Some component types are interpolated in specific ways not covered here.\n+ *                 Refer to their respective documentation for more information.<\/td>\n+ *         <\/tr>\n+ *     <\/tbody>\n+ * <\/table>\n@@ -40,3 +71,8 @@\n-     * The function calculates an interpolated value along the fraction\n-     * {@code t} between {@code 0.0} and {@code 1.0}. When {@code t} = 1.0,\n-     * {@code endVal} is returned.\n+     * Returns an intermediate value between the value of this {@code Interpolatable} and the specified\n+     * {@code endValue} using the linear interpolation factor {@code t}, ranging from 0 (inclusive)\n+     * to 1 (inclusive).\n+     * <p>\n+     * The returned value may not be a new instance; the implementation might also return one of the\n+     * two existing instances if the intermediate value would be equal to one of the existing values.\n+     * However, this is an optimization and applications should not assume any particular identity\n+     * of the returned value.\n@@ -44,5 +80,9 @@\n-     * @param endValue\n-     *            target value\n-     * @param t\n-     *            fraction between {@code 0.0} and {@code 1.0}\n-     * @return interpolated value\n+     * @implSpec An implementation is not required to reject interpolation factors less than 0 or larger\n+     *           than 1, but this specification gives no meaning to values returned outside of this range.\n+     *           For example, an implementation might clamp the interpolation factor to [0..1], or it might\n+     *           continue the linear interpolation outside of this range.\n+     *\n+     * @param endValue the target value\n+     * @param t the interpolation factor\n+     * @throws NullPointerException if {@code endValue} is {@code null}\n+     * @return the intermediate value\n@@ -50,1 +90,1 @@\n-    public T interpolate(T endValue, double t);\n+    T interpolate(T endValue, double t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/animation\/Interpolatable.java","additions":52,"deletions":12,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ import com.sun.javafx.util.Utils;\n+ import javafx.animation.Interpolatable;\n@@ -29,0 +31,1 @@\n+ import java.util.Objects;\n@@ -34,1 +37,1 @@\n-public class Insets {\n+public class Insets implements Interpolatable<Insets> {\n@@ -41,1 +44,2 @@\n-     * The inset on the top side\n+     * The inset on the top side.\n+     *\n@@ -43,0 +47,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -48,1 +53,2 @@\n-     * The inset on the right side\n+     * The inset on the right side.\n+     *\n@@ -50,0 +56,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -55,1 +62,2 @@\n-     * The inset on the bottom side\n+     * The inset on the bottom side.\n+     *\n@@ -57,0 +65,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -62,1 +71,2 @@\n-     * The inset on the left side\n+     * The inset on the left side.\n+     *\n@@ -64,0 +74,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -102,0 +113,25 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public Insets interpolate(Insets endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0 || equals(endValue)) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        return new Insets(\n+            Utils.interpolate(top, endValue.top, t),\n+            Utils.interpolate(right, endValue.right, t),\n+            Utils.interpolate(bottom, endValue.bottom, t),\n+            Utils.interpolate(left, endValue.left, t));\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/geometry\/Insets.java","additions":42,"deletions":6,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Objects;\n@@ -54,0 +55,1 @@\n+     *\n@@ -55,0 +57,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -69,0 +72,1 @@\n+     *\n@@ -70,0 +74,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -361,0 +366,1 @@\n+     * @throws NullPointerException {@inheritDoc}\n@@ -365,0 +371,2 @@\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/geometry\/Point2D.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Objects;\n@@ -55,0 +56,1 @@\n+     *\n@@ -56,0 +58,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -70,0 +73,1 @@\n+     *\n@@ -71,0 +75,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -85,0 +90,1 @@\n+     *\n@@ -86,0 +92,1 @@\n+     * @interpolationType <a href=\"..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -399,0 +406,1 @@\n+     * @throws NullPointerException {@inheritDoc}\n@@ -403,0 +411,2 @@\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/geometry\/Point3D.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import javafx.animation.Interpolatable;\n@@ -39,0 +40,1 @@\n+import java.util.Objects;\n@@ -41,0 +43,1 @@\n+import com.sun.javafx.util.Utils;\n@@ -73,1 +76,1 @@\n-public final class Background {\n+public final class Background implements Interpolatable<Background> {\n@@ -139,0 +142,1 @@\n+     *\n@@ -140,0 +144,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#pairwise\">pairwise<\/a>\n@@ -148,0 +153,1 @@\n+     *\n@@ -149,0 +155,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#pairwise\">pairwise<\/a>\n@@ -160,0 +167,1 @@\n+     *\n@@ -161,0 +169,1 @@\n+     * @interpolationType the intermediate value is derived from {@link #getFills() fills}\n@@ -247,3 +256,3 @@\n-        \/\/ array based constructor (for speed).\n-        this(fills == null ? null : fills.toArray(new BackgroundFill[fills.size()]),\n-             images == null ? null : images.toArray(new BackgroundImage[images.size()]));\n+        \/\/ array based constructor.\n+        this(fills != null ? UnmodifiableArrayList.copyOfNullFiltered(fills) : List.of(),\n+             images != null ? UnmodifiableArrayList.copyOfNullFiltered(images) : List.of(), 0);\n@@ -267,0 +276,18 @@\n+        this(fills != null ? UnmodifiableArrayList.copyOfNullFiltered(fills) : List.of(),\n+             images != null ? UnmodifiableArrayList.copyOfNullFiltered(images) : List.of(), 0);\n+    }\n+\n+    \/**\n+     * Creates a new Background with the specified fills and images.\n+     * This constructor requires that both lists do not contain null values, and that the lists\n+     * are immutable. The purpose of this constructor is to prevent an unnecessary array creation\n+     * when the caller already knows that the specified lists satisfy the non-null precondition\n+     * and preserve the immutability invariant.\n+     *\n+     * @param fills the fills, not {@code null}\n+     * @param images the images, not {@code null}\n+     *\/\n+    private Background(List<BackgroundFill> fills, List<BackgroundImage> images, int ignored) {\n+        Objects.requireNonNull(fills, \"fills cannot be null\");\n+        Objects.requireNonNull(images, \"images cannot be null\");\n+\n@@ -273,33 +300,21 @@\n-        \/\/ If the fills is empty or null then we know we can just use the shared\n-        \/\/ immutable empty list from Collections.\n-        if (fills == null || fills.length == 0) {\n-            this.fills = Collections.emptyList();\n-        } else {\n-            \/\/ We need to iterate over all of the supplied elements in the fills array.\n-            \/\/ Each null element is ignored. Each non-null element is inspected to\n-            \/\/ see if it contributes to the outsets.\n-            final BackgroundFill[] noNulls = new BackgroundFill[fills.length];\n-            int size = 0;\n-            for (int i=0; i<fills.length; i++) {\n-                final BackgroundFill fill = fills[i];\n-                if (fill != null) {\n-                    noNulls[size++] = fill;\n-                    final Insets fillInsets = fill.getInsets();\n-                    final double fillTop = fillInsets.getTop();\n-                    final double fillRight = fillInsets.getRight();\n-                    final double fillBottom = fillInsets.getBottom();\n-                    final double fillLeft = fillInsets.getLeft();\n-                    outerTop = outerTop <= fillTop ? outerTop : fillTop; \/\/ min\n-                    outerRight = outerRight <= fillRight ? outerRight : fillRight; \/\/ min\n-                    outerBottom = outerBottom <= fillBottom ? outerBottom : fillBottom; \/\/ min\n-                    outerLeft = outerLeft <= fillLeft ? outerLeft : fillLeft; \/\/ min\n-\n-                    \/\/ The common case is to NOT have percent based radii\n-                    final boolean b = fill.getRadii().hasPercentBasedRadii;\n-                    hasPercentFillRadii |= b;\n-                    if (fill.fill.isOpaque()) {\n-                        opaqueFill = true;\n-                        if (b) {\n-                            hasPercentOpaqueInsets = true;\n-                        }\n-                    }\n+        \/\/ We need to iterate over all of the supplied elements in the fills list.\n+        \/\/ Each element is inspected to see if it contributes to the outsets.\n+        for (int i = 0, max = fills.size(); i < max; i++) {\n+            final BackgroundFill fill = fills.get(i);\n+            final Insets fillInsets = fill.getInsets();\n+            final double fillTop = fillInsets.getTop();\n+            final double fillRight = fillInsets.getRight();\n+            final double fillBottom = fillInsets.getBottom();\n+            final double fillLeft = fillInsets.getLeft();\n+            outerTop = outerTop <= fillTop ? outerTop : fillTop; \/\/ min\n+            outerRight = outerRight <= fillRight ? outerRight : fillRight; \/\/ min\n+            outerBottom = outerBottom <= fillBottom ? outerBottom : fillBottom; \/\/ min\n+            outerLeft = outerLeft <= fillLeft ? outerLeft : fillLeft; \/\/ min\n+\n+            \/\/ The common case is to NOT have percent based radii\n+            final boolean b = fill.getRadii().hasPercentBasedRadii;\n+            hasPercentFillRadii |= b;\n+            if (fill.fill.isOpaque()) {\n+                opaqueFill = true;\n+                if (b) {\n+                    hasPercentOpaqueInsets = true;\n@@ -308,1 +323,0 @@\n-            this.fills = new UnmodifiableArrayList<>(noNulls, size);\n@@ -310,0 +324,2 @@\n+\n+        this.fills = fills;\n@@ -320,13 +336,1 @@\n-        \/\/ An null or empty images array results in an empty list\n-        if (images == null || images.length == 0) {\n-            this.images = Collections.emptyList();\n-        } else {\n-            \/\/ Filter out any  null values and create an immutable array list\n-            final BackgroundImage[] noNulls = new BackgroundImage[images.length];\n-            int size = 0;\n-            for (int i=0; i<images.length; i++) {\n-                final BackgroundImage image = images[i];\n-                if (image != null) noNulls[size++] = image;\n-            }\n-            this.images = new UnmodifiableArrayList<>(noNulls, size);\n-        }\n+        this.images = images;\n@@ -638,0 +642,35 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public Background interpolate(Background endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        List<BackgroundFill> newFills = fills == endValue.fills ?\n+            fills : Utils.interpolateListsPairwise(fills, endValue.fills, t);\n+\n+        List<BackgroundImage> newImages = images == endValue.images ?\n+            images : Utils.interpolateListsPairwise(images, endValue.images, t);\n+\n+        if (newFills == fills && newImages == images) {\n+            return this;\n+        }\n+\n+        if (newFills == endValue.fills && newImages == endValue.images) {\n+            return endValue;\n+        }\n+\n+        return new Background(newFills, newImages, 0);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Background.java","additions":91,"deletions":52,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.scene.paint.PaintUtils;\n+import javafx.animation.Interpolatable;\n@@ -31,0 +33,1 @@\n+import javafx.scene.paint.LinearGradient;\n@@ -32,0 +35,3 @@\n+import javafx.scene.paint.RadialGradient;\n+\n+import java.util.Objects;\n@@ -42,0 +48,10 @@\n+ * <p>\n+ * {@code BackgroundFill} supports interpolation between the following heterogeneous paint combinations:\n+ * <ul>\n+ *     <li>{@link Color} ↔ {@link LinearGradient}\n+ *     <li>{@link Color} ↔ {@link RadialGradient}\n+ * <\/ul>\n+ * Heterogeneous paint interpolation converts the {@code Color} to a visually identical gradient paint,\n+ * and then performs a gradient paint interpolation. If heterogeneous paints cannot be interpolated as\n+ * described, the paints are interpolated <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discretely<\/a>.\n+ *\n@@ -44,1 +60,1 @@\n-public final class BackgroundFill {\n+public final class BackgroundFill implements Interpolatable<BackgroundFill> {\n@@ -48,0 +64,1 @@\n+     *\n@@ -49,0 +66,1 @@\n+     * @interpolationType see {@link BackgroundFill}\n@@ -58,0 +76,1 @@\n+     *\n@@ -59,0 +78,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -69,0 +89,1 @@\n+     *\n@@ -70,0 +91,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -106,0 +128,45 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public BackgroundFill interpolate(BackgroundFill endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        \/\/ CornerRadii, Insets and Paint are implemented such that interpolate() always returns the\n+        \/\/ existing instance if the intermediate value is equal to the start value or the end value,\n+        \/\/ which allows us to use an identity comparison in place of a value comparison to determine\n+        \/\/ equality.\n+        CornerRadii newRadii = radii.interpolate(endValue.radii, t);\n+        Insets newInsets = insets.interpolate(endValue.insets, t);\n+        Paint newFill = PaintUtils.interpolate(fill, endValue.fill, t);\n+\n+        if (isSame(newFill, newRadii, newInsets)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newFill, newRadii, newInsets)) {\n+            return endValue;\n+        }\n+\n+        return new BackgroundFill(newFill, newRadii, newInsets);\n+    }\n+\n+    private boolean isSame(Paint fill, CornerRadii radii, Insets insets) {\n+        return this.fill == fill\n+            && this.radii == radii\n+            && this.insets == insets;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundFill.java","additions":69,"deletions":2,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import javafx.animation.Interpolatable;\n@@ -30,0 +31,1 @@\n+import java.util.Objects;\n@@ -46,1 +48,1 @@\n-public final class BackgroundImage {\n+public final class BackgroundImage implements Interpolatable<BackgroundImage> {\n@@ -55,0 +57,1 @@\n+     *\n@@ -56,0 +59,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -64,0 +68,1 @@\n+     *\n@@ -65,1 +70,2 @@\n-     * is to be repeated along the x-axis of the region\n+     *         is to be repeated along the x-axis of the region\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -74,0 +80,1 @@\n+     *\n@@ -75,1 +82,2 @@\n-     * is to be repeated along the y-axis of the region\n+     *         is to be repeated along the y-axis of the region\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -83,0 +91,1 @@\n+     *\n@@ -84,0 +93,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -90,0 +100,1 @@\n+     *\n@@ -91,0 +102,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -141,0 +153,62 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public BackgroundImage interpolate(BackgroundImage endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        \/\/ BackgroundPosition and BackgroundSize are implemented such that interpolate() always returns\n+        \/\/ the existing instance if the intermediate value is equal to the start value or the end value,\n+        \/\/ which allows us to use an identity comparison in place of a value comparison to determine\n+        \/\/ equality.\n+        BackgroundPosition newPosition = this.position.interpolate(endValue.position, t);\n+        BackgroundSize newSize = this.size.interpolate(endValue.size, t);\n+        BackgroundRepeat newRepeatX, newRepeatY;\n+        Image newImage;\n+\n+        if (t < 0.5) {\n+            newRepeatX = this.repeatX;\n+            newRepeatY = this.repeatY;\n+            newImage = this.image;\n+        } else {\n+            newRepeatX = endValue.repeatX;\n+            newRepeatY = endValue.repeatY;\n+            newImage = endValue.image;\n+        }\n+\n+        if (isSame(newImage, newRepeatX, newRepeatY, newPosition, newSize)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newImage, newRepeatX, newRepeatY, newPosition, newSize)) {\n+            return endValue;\n+        }\n+\n+        return new BackgroundImage(newImage, newRepeatX, newRepeatY, newPosition, newSize);\n+    }\n+\n+    private boolean isSame(Image image,\n+                           BackgroundRepeat repeatX,\n+                           BackgroundRepeat repeatY,\n+                           BackgroundPosition position,\n+                           BackgroundSize size) {\n+        return this.image == image\n+            && this.repeatX == repeatX\n+            && this.repeatY == repeatY\n+            && this.position == position\n+            && this.size == size;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundImage.java","additions":78,"deletions":4,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -30,0 +32,1 @@\n+import java.util.Objects;\n@@ -52,1 +55,1 @@\n-public class BackgroundPosition {\n+public class BackgroundPosition implements Interpolatable<BackgroundPosition> {\n@@ -71,2 +74,3 @@\n-     * @return the Side along the horizontal axis to which the BackgroundImage is\n-     * anchored\n+     *\n+     * @return the Side along the horizontal axis to which the BackgroundImage is anchored\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -80,2 +84,2 @@\n-     * @return the Side along the vertical axis to which the BackgroundImage is\n-     * anchored\n+     * @return the Side along the vertical axis to which the BackgroundImage is anchored\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -93,0 +97,1 @@\n+     *\n@@ -94,0 +99,4 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> if one\n+     *                    value is absolute and the other is a {@link #isHorizontalAsPercentage() percentage},\n+     *                    or if the background is anchored at different {@link #getHorizontalSide() sides};\n+     *                    otherwise <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -104,0 +113,1 @@\n+     *\n@@ -105,0 +115,4 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> if one\n+     *                    value is absolute and the other is a {@link #isVerticalAsPercentage() percentage},\n+     *                    or if the background is anchored at different {@link #getVerticalSide() sides};\n+     *                    otherwise <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -112,0 +126,1 @@\n+     *\n@@ -113,0 +128,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -120,0 +136,1 @@\n+     *\n@@ -121,0 +138,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -178,0 +196,77 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public BackgroundPosition interpolate(BackgroundPosition endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        double newHorizontalPosition, newVerticalPosition;\n+        boolean newHorizontalAsPercentage, newVerticalAsPercentage;\n+        Side newHorizontalSide, newVerticalSide;\n+\n+        if (this.horizontalSide == endValue.horizontalSide\n+                && this.horizontalAsPercentage == endValue.horizontalAsPercentage) {\n+            newHorizontalPosition = Utils.interpolate(this.horizontalPosition, endValue.horizontalPosition, t);\n+            newHorizontalAsPercentage = this.horizontalAsPercentage;\n+            newHorizontalSide = this.horizontalSide;\n+        } else if (t < 0.5) {\n+            newHorizontalPosition = this.horizontalPosition;\n+            newHorizontalAsPercentage = this.horizontalAsPercentage;\n+            newHorizontalSide = this.horizontalSide;\n+        } else {\n+            newHorizontalPosition = endValue.horizontalPosition;\n+            newHorizontalAsPercentage = endValue.horizontalAsPercentage;\n+            newHorizontalSide = endValue.horizontalSide;\n+        }\n+\n+        if (this.verticalSide == endValue.verticalSide\n+                && this.verticalAsPercentage == endValue.verticalAsPercentage) {\n+            newVerticalPosition = Utils.interpolate(this.verticalPosition, endValue.verticalPosition, t);\n+            newVerticalAsPercentage = this.verticalAsPercentage;\n+            newVerticalSide = this.verticalSide;\n+        } else if (t < 0.5) {\n+            newVerticalPosition = this.verticalPosition;\n+            newVerticalAsPercentage = this.verticalAsPercentage;\n+            newVerticalSide = this.verticalSide;\n+        } else {\n+            newVerticalPosition = endValue.verticalPosition;\n+            newVerticalAsPercentage = endValue.verticalAsPercentage;\n+            newVerticalSide = endValue.verticalSide;\n+        }\n+\n+        if (isSame(newHorizontalSide, newHorizontalPosition, newHorizontalAsPercentage,\n+                   newVerticalSide, newVerticalPosition, newVerticalAsPercentage)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newHorizontalSide, newHorizontalPosition, newHorizontalAsPercentage,\n+                            newVerticalSide, newVerticalPosition, newVerticalAsPercentage)) {\n+            return endValue;\n+        }\n+\n+        return new BackgroundPosition(\n+            newHorizontalSide, newHorizontalPosition, newHorizontalAsPercentage,\n+            newVerticalSide, newVerticalPosition, newVerticalAsPercentage);\n+    }\n+\n+    private boolean isSame(Side horizontalSide, double horizontalPosition, boolean horizontalAsPercentage,\n+                           Side verticalSide, double verticalPosition, boolean verticalAsPercentage) {\n+        return this.horizontalSide == horizontalSide\n+            && this.horizontalPosition == horizontalPosition\n+            && this.horizontalAsPercentage == horizontalAsPercentage\n+            && this.verticalSide == verticalSide\n+            && this.verticalPosition == verticalPosition\n+            && this.verticalAsPercentage == verticalAsPercentage;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundPosition.java","additions":101,"deletions":6,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -29,0 +31,1 @@\n+import java.util.Objects;\n@@ -57,1 +60,1 @@\n-public final class BackgroundSize {\n+public final class BackgroundSize implements Interpolatable<BackgroundSize> {\n@@ -85,0 +88,1 @@\n+     *\n@@ -86,1 +90,6 @@\n-     * BackgroundImage should render\n+     *         BackgroundImage should render\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n+     *                    if {@link #isCover() cover} or {@link #isContain() contain} is set, if one value\n+     *                    is absolute and the other value is a {@link #isWidthAsPercentage() percentage},\n+     *                    or if the width is {@link #AUTO}; otherwise\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -96,0 +105,1 @@\n+     *\n@@ -97,1 +107,6 @@\n-     * BackgroundImage should render\n+     *         BackgroundImage should render\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n+     *                    if {@link #isCover() cover} or {@link #isContain() contain} is set, if one value\n+     *                    is absolute and the other value is a {@link #isHeightAsPercentage() percentage},\n+     *                    or if the height is {@link #AUTO}; otherwise\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -105,0 +120,1 @@\n+     *\n@@ -106,0 +122,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -113,0 +130,1 @@\n+     *\n@@ -114,0 +132,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -122,0 +141,1 @@\n+     *\n@@ -123,0 +143,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -131,0 +152,1 @@\n+     *\n@@ -132,0 +154,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -183,0 +206,64 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public BackgroundSize interpolate(BackgroundSize endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        if (cover || contain || endValue.cover || endValue.contain) {\n+            return t < 0.5 ? this : endValue;\n+        }\n+\n+        double newWidth = interpolate(\n+            this.width, endValue.width, this.widthAsPercentage, endValue.widthAsPercentage, t);\n+\n+        double newHeight = interpolate(\n+            this.height, endValue.height, this.heightAsPercentage, endValue.heightAsPercentage, t);\n+\n+        boolean newWidthAsPercentage, newHeightAsPercentage;\n+\n+        if (t < 0.5) {\n+            newWidthAsPercentage = this.widthAsPercentage;\n+            newHeightAsPercentage = this.heightAsPercentage;\n+        } else {\n+            newWidthAsPercentage = endValue.widthAsPercentage;\n+            newHeightAsPercentage = endValue.heightAsPercentage;\n+        }\n+\n+        if (isSame(newWidth, newHeight, newWidthAsPercentage, newHeightAsPercentage)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newWidth, newHeight, newWidthAsPercentage, newHeightAsPercentage)) {\n+            return endValue;\n+        }\n+\n+        return new BackgroundSize(newWidth, newHeight, newWidthAsPercentage, newHeightAsPercentage, false, false);\n+    }\n+\n+    private boolean isSame(double width, double height, boolean widthAsPercentage, boolean heightAsPercentage) {\n+        return this.width == width\n+            && this.height == height\n+            && this.widthAsPercentage == widthAsPercentage\n+            && this.heightAsPercentage == heightAsPercentage;\n+    }\n+\n+    private static double interpolate(double start, double end,\n+                                      boolean startIsPercentage, boolean endIsPercentage,\n+                                      double t) {\n+        return startIsPercentage == endIsPercentage && start != AUTO && end != AUTO ?\n+            Utils.interpolate(start, end, t) :\n+            Utils.interpolateDiscrete(start, end, t);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundSize.java","additions":91,"deletions":4,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,2 @@\n-\n+import java.util.Objects;\n+import javafx.animation.Interpolatable;\n@@ -37,1 +38,0 @@\n-import javafx.css.CssMetaData;\n@@ -39,0 +39,3 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.css.CssMetaData;\n+import javafx.css.Styleable;\n@@ -50,1 +53,0 @@\n-import javafx.css.Styleable;\n@@ -90,1 +92,1 @@\n-public final class Border {\n+public final class Border implements Interpolatable<Border> {\n@@ -168,2 +170,3 @@\n-     * @return the list of BorderStrokes which together define the stroked\n-     * portion of this Border\n+     *\n+     * @return the list of BorderStrokes which together define the stroked portion of this Border\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#pairwise\">pairwise<\/a>\n@@ -183,0 +186,1 @@\n+     *\n@@ -184,1 +188,2 @@\n-     * instead of stroke for this Border\n+     *         instead of stroke for this Border\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#pairwise\">pairwise<\/a>\n@@ -280,2 +285,2 @@\n-        this(strokes == null ? null : strokes.toArray(new BorderStroke[strokes.size()]),\n-             images == null ? null : images.toArray(new BorderImage[images.size()]));\n+        this(strokes != null ? UnmodifiableArrayList.copyOfNullFiltered(strokes) : List.of(),\n+             images != null ? UnmodifiableArrayList.copyOfNullFiltered(images) : List.of(), 0);\n@@ -303,0 +308,18 @@\n+        this(strokes != null ? UnmodifiableArrayList.copyOfNullFiltered(strokes) : List.of(),\n+             images != null ? UnmodifiableArrayList.copyOfNullFiltered(images) : List.of(), 0);\n+    }\n+\n+    \/**\n+     * Creates a new Border with the specified strokes and images.\n+     * This constructor requires that both lists do not contain null values, and that the lists\n+     * are immutable. The purpose of this constructor is to prevent an unnecessary array creation\n+     * when the caller already knows that the specified lists satisfy the non-null precondition\n+     * and preserve the immutability invariant.\n+     *\n+     * @param strokes the strokes, not {@code null}\n+     * @param images the images, not {@code null}\n+     *\/\n+    private Border(List<BorderStroke> strokes, List<BorderImage> images, int ignored) {\n+        Objects.requireNonNull(strokes, \"strokes cannot be null\");\n+        Objects.requireNonNull(images, \"images cannot be null\");\n+\n@@ -306,36 +329,26 @@\n-        if (strokes == null || strokes.length == 0) {\n-            this.strokes = Collections.emptyList();\n-        } else {\n-            final BorderStroke[] noNulls = new BorderStroke[strokes.length];\n-            int size = 0;\n-            for (int i=0; i<strokes.length; i++) {\n-                final BorderStroke stroke = strokes[i];\n-                if (stroke != null) {\n-                    noNulls[size++] = stroke;\n-\n-                    \/\/ Calculate the insets and outsets. \"insets\" are the distance\n-                    \/\/ from the edge of the region to the inmost edge of the inmost border.\n-                    \/\/ Outsets are the distance from the edge of the region out towards the\n-                    \/\/ outer-most edge of the outer-most border.\n-                    final double strokeInnerTop = stroke.innerEdge.getTop();\n-                    final double strokeInnerRight = stroke.innerEdge.getRight();\n-                    final double strokeInnerBottom = stroke.innerEdge.getBottom();\n-                    final double strokeInnerLeft = stroke.innerEdge.getLeft();\n-\n-                    innerTop = innerTop >= strokeInnerTop ? innerTop : strokeInnerTop;\n-                    innerRight = innerRight >= strokeInnerRight? innerRight : strokeInnerRight;\n-                    innerBottom = innerBottom >= strokeInnerBottom ? innerBottom : strokeInnerBottom;\n-                    innerLeft = innerLeft >= strokeInnerLeft ? innerLeft : strokeInnerLeft;\n-\n-                    final double strokeOuterTop = stroke.outerEdge.getTop();\n-                    final double strokeOuterRight = stroke.outerEdge.getRight();\n-                    final double strokeOuterBottom = stroke.outerEdge.getBottom();\n-                    final double strokeOuterLeft = stroke.outerEdge.getLeft();\n-\n-                    outerTop = outerTop >= strokeOuterTop ? outerTop : strokeOuterTop;\n-                    outerRight = outerRight >= strokeOuterRight? outerRight : strokeOuterRight;\n-                    outerBottom = outerBottom >= strokeOuterBottom ? outerBottom : strokeOuterBottom;\n-                    outerLeft = outerLeft >= strokeOuterLeft ? outerLeft : strokeOuterLeft;\n-                }\n-            }\n-            this.strokes = new UnmodifiableArrayList<>(noNulls, size);\n+        for (int i = 0, max = strokes.size(); i < max; i++) {\n+            final BorderStroke stroke = strokes.get(i);\n+\n+            \/\/ Calculate the insets and outsets. \"insets\" are the distance\n+            \/\/ from the edge of the region to the inmost edge of the inmost border.\n+            \/\/ Outsets are the distance from the edge of the region out towards the\n+            \/\/ outer-most edge of the outer-most border.\n+            final double strokeInnerTop = stroke.innerEdge.getTop();\n+            final double strokeInnerRight = stroke.innerEdge.getRight();\n+            final double strokeInnerBottom = stroke.innerEdge.getBottom();\n+            final double strokeInnerLeft = stroke.innerEdge.getLeft();\n+\n+            innerTop = innerTop >= strokeInnerTop ? innerTop : strokeInnerTop;\n+            innerRight = innerRight >= strokeInnerRight? innerRight : strokeInnerRight;\n+            innerBottom = innerBottom >= strokeInnerBottom ? innerBottom : strokeInnerBottom;\n+            innerLeft = innerLeft >= strokeInnerLeft ? innerLeft : strokeInnerLeft;\n+\n+            final double strokeOuterTop = stroke.outerEdge.getTop();\n+            final double strokeOuterRight = stroke.outerEdge.getRight();\n+            final double strokeOuterBottom = stroke.outerEdge.getBottom();\n+            final double strokeOuterLeft = stroke.outerEdge.getLeft();\n+\n+            outerTop = outerTop >= strokeOuterTop ? outerTop : strokeOuterTop;\n+            outerRight = outerRight >= strokeOuterRight? outerRight : strokeOuterRight;\n+            outerBottom = outerBottom >= strokeOuterBottom ? outerBottom : strokeOuterBottom;\n+            outerLeft = outerLeft >= strokeOuterLeft ? outerLeft : strokeOuterLeft;\n@@ -344,34 +357,26 @@\n-        if (images == null || images.length == 0) {\n-            this.images = Collections.emptyList();\n-        } else {\n-            final BorderImage[] noNulls = new BorderImage[images.length];\n-            int size = 0;\n-            for (int i=0; i<images.length; i++) {\n-                final BorderImage image = images[i];\n-                if (image != null){\n-                    noNulls[size++] = image;\n-\n-                    \/\/ The Image width + insets may contribute to the insets \/ outsets of\n-                    \/\/ this border.\n-                    final double imageInnerTop = image.innerEdge.getTop();\n-                    final double imageInnerRight = image.innerEdge.getRight();\n-                    final double imageInnerBottom = image.innerEdge.getBottom();\n-                    final double imageInnerLeft = image.innerEdge.getLeft();\n-\n-                    innerTop = innerTop >= imageInnerTop ? innerTop : imageInnerTop;\n-                    innerRight = innerRight >= imageInnerRight? innerRight : imageInnerRight;\n-                    innerBottom = innerBottom >= imageInnerBottom ? innerBottom : imageInnerBottom;\n-                    innerLeft = innerLeft >= imageInnerLeft ? innerLeft : imageInnerLeft;\n-\n-                    final double imageOuterTop = image.outerEdge.getTop();\n-                    final double imageOuterRight = image.outerEdge.getRight();\n-                    final double imageOuterBottom = image.outerEdge.getBottom();\n-                    final double imageOuterLeft = image.outerEdge.getLeft();\n-\n-                    outerTop = outerTop >= imageOuterTop ? outerTop : imageOuterTop;\n-                    outerRight = outerRight >= imageOuterRight? outerRight : imageOuterRight;\n-                    outerBottom = outerBottom >= imageOuterBottom ? outerBottom : imageOuterBottom;\n-                    outerLeft = outerLeft >= imageOuterLeft ? outerLeft : imageOuterLeft;\n-                }\n-            }\n-            this.images = new UnmodifiableArrayList<>(noNulls, size);\n+        this.strokes = strokes;\n+\n+        for (int i = 0, max = images.size(); i < max; i++) {\n+            final BorderImage image = images.get(i);\n+\n+            \/\/ The Image width + insets may contribute to the insets \/ outsets of\n+            \/\/ this border.\n+            final double imageInnerTop = image.innerEdge.getTop();\n+            final double imageInnerRight = image.innerEdge.getRight();\n+            final double imageInnerBottom = image.innerEdge.getBottom();\n+            final double imageInnerLeft = image.innerEdge.getLeft();\n+\n+            innerTop = innerTop >= imageInnerTop ? innerTop : imageInnerTop;\n+            innerRight = innerRight >= imageInnerRight? innerRight : imageInnerRight;\n+            innerBottom = innerBottom >= imageInnerBottom ? innerBottom : imageInnerBottom;\n+            innerLeft = innerLeft >= imageInnerLeft ? innerLeft : imageInnerLeft;\n+\n+            final double imageOuterTop = image.outerEdge.getTop();\n+            final double imageOuterRight = image.outerEdge.getRight();\n+            final double imageOuterBottom = image.outerEdge.getBottom();\n+            final double imageOuterLeft = image.outerEdge.getLeft();\n+\n+            outerTop = outerTop >= imageOuterTop ? outerTop : imageOuterTop;\n+            outerRight = outerRight >= imageOuterRight? outerRight : imageOuterRight;\n+            outerBottom = outerBottom >= imageOuterBottom ? outerBottom : imageOuterBottom;\n+            outerLeft = outerLeft >= imageOuterLeft ? outerLeft : imageOuterLeft;\n@@ -380,0 +385,2 @@\n+        this.images = images;\n+\n@@ -408,0 +415,35 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public Border interpolate(Border endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        List<BorderImage> newImages = images == endValue.images ?\n+            images : Utils.interpolateListsPairwise(images, endValue.images, t);\n+\n+        List<BorderStroke> newStrokes = strokes == endValue.strokes ?\n+            strokes : Utils.interpolateListsPairwise(strokes, endValue.strokes, t);\n+\n+        if (images == newImages && strokes == newStrokes) {\n+            return this;\n+        }\n+\n+        if (endValue.images == newImages && endValue.strokes == newStrokes) {\n+            return endValue;\n+        }\n+\n+        return new Border(newStrokes, newImages);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Border.java","additions":122,"deletions":80,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javafx.animation.Interpolatable;\n@@ -32,0 +33,1 @@\n+import java.util.Objects;\n@@ -51,1 +53,1 @@\n-public class BorderImage {\n+public class BorderImage implements Interpolatable<BorderImage> {\n@@ -57,0 +59,1 @@\n+     *\n@@ -58,0 +61,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -66,0 +70,1 @@\n+     *\n@@ -67,1 +72,2 @@\n-     * is to be repeated along the x-axis of the region\n+     *         is to be repeated along the x-axis of the region\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -76,0 +82,1 @@\n+     *\n@@ -77,1 +84,2 @@\n-     * is to be repeated along the y-axis of the region\n+     *         is to be repeated along the y-axis of the region\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -87,0 +95,1 @@\n+     *\n@@ -88,0 +97,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -106,0 +116,1 @@\n+     *\n@@ -107,0 +118,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -115,0 +127,1 @@\n+     *\n@@ -116,0 +129,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -123,0 +137,1 @@\n+     *\n@@ -124,0 +139,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -189,0 +205,64 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public BorderImage interpolate(BorderImage endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        \/\/ BorderWidths and Insets are implemented such that interpolate() always returns the existing\n+        \/\/ instance if the intermediate value is equal to the start value or the end value, which allows\n+        \/\/ us to use an identity comparison in place of a value comparison to determine equality.\n+        BorderWidths newWidths = widths.interpolate(endValue.widths, t);\n+        BorderWidths newSlices = slices.interpolate(endValue.slices, t);\n+        Insets newInsets = insets.interpolate(endValue.insets, t);\n+        Image newImage;\n+        BorderRepeat newRepeatX, newRepeatY;\n+        boolean newFilled;\n+\n+        if (t < 0.5) {\n+            newImage = this.image;\n+            newRepeatX = this.repeatX;\n+            newRepeatY = this.repeatY;\n+            newFilled = this.filled;\n+        } else {\n+            newImage = endValue.image;\n+            newRepeatX = endValue.repeatX;\n+            newRepeatY = endValue.repeatY;\n+            newFilled = endValue.filled;\n+        }\n+\n+        if (isSame(newImage, newWidths, newSlices, newFilled, newRepeatX, newRepeatY)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newImage, newWidths, newSlices, newFilled, newRepeatX, newRepeatY)) {\n+            return endValue;\n+        }\n+\n+        return new BorderImage(endValue.image, newWidths, newInsets, newSlices,\n+                               endValue.filled, endValue.repeatX, endValue.repeatY);\n+    }\n+\n+    private boolean isSame(Image image, BorderWidths widths, BorderWidths slices, boolean filled,\n+                           BorderRepeat repeatX, BorderRepeat repeatY) {\n+        return this.image == image\n+            && this.widths == widths\n+            && this.slices == slices\n+            && this.filled == filled\n+            && this.repeatX == repeatX\n+            && this.repeatY == repeatY;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BorderImage.java","additions":84,"deletions":4,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.scene.paint.PaintUtils;\n+import javafx.animation.Interpolatable;\n@@ -31,0 +33,1 @@\n+import javafx.scene.paint.LinearGradient;\n@@ -32,0 +35,1 @@\n+import javafx.scene.paint.RadialGradient;\n@@ -33,0 +37,1 @@\n+import java.util.Objects;\n@@ -45,0 +50,9 @@\n+ * <p>\n+ * {@code BorderStroke} supports interpolation between the following heterogeneous paint combinations:\n+ * <ul>\n+ *     <li>{@link Color} ↔ {@link LinearGradient}\n+ *     <li>{@link Color} ↔ {@link RadialGradient}\n+ * <\/ul>\n+ * Heterogeneous paint interpolation converts the {@code Color} to a visually identical gradient paint,\n+ * and then performs a gradient paint interpolation. If heterogeneous paints cannot be interpolated as\n+ * described, the paints are interpolated <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discretely<\/a>.\n@@ -48,1 +62,1 @@\n-public class BorderStroke {\n+public class BorderStroke implements Interpolatable<BorderStroke> {\n@@ -75,0 +89,1 @@\n+     * @interpolationType see {@link BorderStroke}\n@@ -88,0 +103,1 @@\n+     * @interpolationType see {@link BorderStroke}\n@@ -98,0 +114,1 @@\n+     * @interpolationType see {@link BorderStroke}\n@@ -108,0 +125,1 @@\n+     * @interpolationType see {@link BorderStroke}\n@@ -117,0 +135,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -127,0 +146,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -138,0 +158,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -149,0 +170,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -156,0 +178,1 @@\n+     *\n@@ -157,0 +180,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -164,0 +188,1 @@\n+     *\n@@ -165,0 +190,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -176,0 +202,1 @@\n+     *\n@@ -177,0 +204,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#default\">default<\/a>\n@@ -361,0 +389,78 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public BorderStroke interpolate(BorderStroke endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        \/\/ CornerRadii, BorderWidths, Insets and Paint are implemented such that interpolate() always returns\n+        \/\/ the existing instance if the intermediate value is equal to the start value or the end value,\n+        \/\/ which allows us to use an identity comparison in place of a value comparison to determine equality.\n+        CornerRadii newRadii = this.radii.interpolate(endValue.radii, t);\n+        BorderWidths newWidths = this.widths.interpolate(endValue.widths, t);\n+        Insets newInsets = this.insets.interpolate(endValue.insets, t);\n+        Paint newTopStroke = PaintUtils.interpolate(this.topStroke, endValue.topStroke, t);\n+        Paint newRightStroke = PaintUtils.interpolate(this.rightStroke, endValue.rightStroke, t);\n+        Paint newBottomStroke = PaintUtils.interpolate(this.bottomStroke, endValue.bottomStroke, t);\n+        Paint newLeftStroke = PaintUtils.interpolate(this.leftStroke, endValue.leftStroke, t);\n+        BorderStrokeStyle newTopStyle, newRightStyle, newBottomStyle, newLeftStyle;\n+\n+        if (t < 0.5) {\n+            newTopStyle = this.topStyle;\n+            newRightStyle = this.rightStyle;\n+            newBottomStyle = this.bottomStyle;\n+            newLeftStyle = this.leftStyle;\n+        } else {\n+            newTopStyle = endValue.topStyle;\n+            newRightStyle = endValue.rightStyle;\n+            newBottomStyle = endValue.bottomStyle;\n+            newLeftStyle = endValue.leftStyle;\n+        }\n+\n+        if (isSame(newTopStroke, newRightStroke, newBottomStroke, newLeftStroke,\n+                   newTopStyle, newRightStyle, newBottomStyle, newLeftStyle,\n+                   newRadii, newWidths, newInsets)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newTopStroke, newRightStroke, newBottomStroke, newLeftStroke,\n+                            newTopStyle, newRightStyle, newBottomStyle, newLeftStyle,\n+                            newRadii, newWidths, newInsets)) {\n+            return endValue;\n+        }\n+\n+        return new BorderStroke(newTopStroke, newRightStroke, newBottomStroke, newLeftStroke,\n+                                newTopStyle, newRightStyle, newBottomStyle, newLeftStyle,\n+                                newRadii, newWidths, newInsets);\n+    }\n+\n+    private boolean isSame(Paint topStroke, Paint rightStroke, Paint bottomStroke, Paint leftStroke,\n+                           BorderStrokeStyle topStyle, BorderStrokeStyle rightStyle,\n+                           BorderStrokeStyle bottomStyle, BorderStrokeStyle leftStyle,\n+                           CornerRadii radii, BorderWidths widths, Insets insets) {\n+        return this.topStroke == topStroke\n+            && this.rightStroke == rightStroke\n+            && this.bottomStroke == bottomStroke\n+            && this.leftStroke == leftStroke\n+            && this.topStyle == topStyle\n+            && this.rightStyle == rightStyle\n+            && this.bottomStyle == bottomStyle\n+            && this.leftStyle == leftStyle\n+            && this.radii == radii\n+            && this.widths == widths\n+            && this.insets == insets;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BorderStroke.java","additions":108,"deletions":2,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -29,1 +31,1 @@\n-\n+import java.util.Objects;\n@@ -44,1 +46,1 @@\n-public final class BorderWidths {\n+public final class BorderWidths implements Interpolatable<BorderWidths> {\n@@ -75,0 +77,1 @@\n+     *\n@@ -76,0 +79,4 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isTopAsPercentage() percentages}, and both\n+     *                    values are not the special value {@link #AUTO};\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -85,0 +92,1 @@\n+     *\n@@ -86,0 +94,4 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isRightAsPercentage() percentages}, and both\n+     *                    values are not the special value {@link #AUTO};\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -95,0 +107,1 @@\n+     *\n@@ -96,0 +109,4 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isBottomAsPercentage() percentages}, and both\n+     *                    values are not the special value {@link #AUTO};\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -105,0 +122,1 @@\n+     *\n@@ -106,0 +124,4 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isLeftAsPercentage() percentages}, and both\n+     *                    values are not the special value {@link #AUTO};\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -113,0 +135,1 @@\n+     *\n@@ -114,0 +137,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -121,0 +145,1 @@\n+     *\n@@ -122,0 +147,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -129,0 +155,1 @@\n+     *\n@@ -130,0 +157,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -137,0 +165,1 @@\n+     *\n@@ -138,0 +167,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -226,0 +256,101 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public BorderWidths interpolate(BorderWidths endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0 || equals(endValue)) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        double newTop, newRight, newBottom, newLeft;\n+        boolean newTopAsPercentage, newRightAsPercentage, newBottomAsPercentage, newLeftAsPercentage;\n+\n+        if (this.topAsPercentage == endValue.topAsPercentage) {\n+            newTop = interpolate(this.top, endValue.top, t);\n+            newTopAsPercentage = this.topAsPercentage;\n+        } else if (t < 0.5) {\n+            newTop = this.top;\n+            newTopAsPercentage = this.topAsPercentage;\n+        } else {\n+            newTop = endValue.top;\n+            newTopAsPercentage = endValue.topAsPercentage;\n+        }\n+\n+        if (this.rightAsPercentage == endValue.rightAsPercentage) {\n+            newRight = interpolate(this.right, endValue.right, t);\n+            newRightAsPercentage = this.rightAsPercentage;\n+        } else if (t < 0.5) {\n+            newRight = this.right;\n+            newRightAsPercentage = this.rightAsPercentage;\n+        } else {\n+            newRight = endValue.right;\n+            newRightAsPercentage = endValue.rightAsPercentage;\n+        }\n+\n+        if (this.bottomAsPercentage == endValue.bottomAsPercentage) {\n+            newBottom = interpolate(this.bottom, endValue.bottom, t);\n+            newBottomAsPercentage = this.bottomAsPercentage;\n+        } else if (t < 0.5) {\n+            newBottom = this.bottom;\n+            newBottomAsPercentage = this.bottomAsPercentage;\n+        } else {\n+            newBottom = endValue.bottom;\n+            newBottomAsPercentage = endValue.bottomAsPercentage;\n+        }\n+\n+        if (this.leftAsPercentage == endValue.leftAsPercentage) {\n+            newLeft = interpolate(this.left, endValue.left, t);\n+            newLeftAsPercentage = this.leftAsPercentage;\n+        } else if (t < 0.5) {\n+            newLeft = this.left;\n+            newLeftAsPercentage = this.leftAsPercentage;\n+        } else {\n+            newLeft = endValue.left;\n+            newLeftAsPercentage = endValue.leftAsPercentage;\n+        }\n+\n+        if (isSame(newTop, newRight, newBottom, newLeft,\n+                   newTopAsPercentage, newRightAsPercentage,\n+                   newBottomAsPercentage, newLeftAsPercentage)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newTop, newRight, newBottom, newLeft,\n+                            newTopAsPercentage, newRightAsPercentage,\n+                            newBottomAsPercentage, newLeftAsPercentage)) {\n+            return endValue;\n+        }\n+\n+        return new BorderWidths(\n+            newTop, newRight, newBottom, newLeft,\n+            newTopAsPercentage, newRightAsPercentage, newBottomAsPercentage, newLeftAsPercentage);\n+    }\n+\n+    private static double interpolate(double start, double end, double t) {\n+        return start != AUTO && end != AUTO ?\n+            Utils.interpolate(start, end, t) :\n+            Utils.interpolateDiscrete(start, end, t);\n+    }\n+\n+    private boolean isSame(double top, double right, double bottom, double left,\n+                           boolean topAsPercentage, boolean rightAsPercentage,\n+                           boolean bottomAsPercentage, boolean leftAsPercentage) {\n+        return this.top == top\n+            && this.right == right\n+            && this.bottom == bottom\n+            && this.left == left\n+            && this.topAsPercentage == topAsPercentage\n+            && this.rightAsPercentage == rightAsPercentage\n+            && this.bottomAsPercentage == bottomAsPercentage\n+            && this.leftAsPercentage == leftAsPercentage;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BorderWidths.java","additions":134,"deletions":3,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -29,1 +31,1 @@\n-\n+import java.util.Objects;\n@@ -40,1 +42,1 @@\n-public class CornerRadii {\n+public class CornerRadii implements Interpolatable<CornerRadii> {\n@@ -52,0 +54,1 @@\n+     *\n@@ -53,0 +56,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isTopLeftHorizontalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -59,0 +65,1 @@\n+     *\n@@ -60,0 +67,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isTopLeftVerticalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -66,0 +76,1 @@\n+     *\n@@ -67,0 +78,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isTopRightVerticalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -73,0 +87,1 @@\n+     *\n@@ -74,0 +89,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isTopRightHorizontalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -80,0 +98,1 @@\n+     *\n@@ -81,0 +100,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isBottomRightHorizontalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -87,0 +109,1 @@\n+     *\n@@ -88,0 +111,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isBottomRightVerticalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -94,0 +120,1 @@\n+     *\n@@ -95,0 +122,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isBottomLeftVerticalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -101,0 +131,1 @@\n+     *\n@@ -102,0 +133,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a> if both values are\n+     *                    absolute or both values are {@link #isBottomLeftHorizontalRadiusAsPercentage() percentages},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -107,1 +141,2 @@\n-     * indicates whether {@code topLeftHorizontalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code topLeftHorizontalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -109,0 +144,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -114,1 +150,2 @@\n-     * indicates whether {@code topLeftVerticalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code topLeftVerticalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -116,0 +153,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -121,1 +159,2 @@\n-     * indicates whether {@code topRightVerticalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code topRightVerticalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -123,0 +162,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -128,1 +168,2 @@\n-     * indicates whether {@code topRightHorizontalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code topRightHorizontalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -130,0 +171,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -135,1 +177,2 @@\n-     * indicates whether {@code bottomRightHorizontalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code bottomRightHorizontalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -137,0 +180,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -142,1 +186,2 @@\n-     * indicates whether {@code bottomRightVerticalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code bottomRightVerticalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -144,0 +189,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -149,1 +195,2 @@\n-     * indicates whether {@code bottomLeftVerticalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code bottomLeftVerticalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -151,0 +198,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -156,1 +204,2 @@\n-     * indicates whether {@code bottomLeftHorizontalRadius} is interpreted as a value or a percentage.\n+     * Indicates whether {@code bottomLeftHorizontalRadius} is interpreted as a value or a percentage.\n+     *\n@@ -158,0 +207,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -362,0 +412,168 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public CornerRadii interpolate(CornerRadii endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        if (uniform && endValue.uniform) {\n+            double newRadius = interpolate(\n+                this.topLeftHorizontalRadius, endValue.topLeftHorizontalRadius,\n+                this.topLeftHorizontalRadiusAsPercentage, endValue.topLeftHorizontalRadiusAsPercentage, t);\n+\n+            boolean newRadiusAsPercentage = t < 0.5 ?\n+                this.topLeftHorizontalRadiusAsPercentage :\n+                endValue.topLeftHorizontalRadiusAsPercentage;\n+\n+            if (topLeftHorizontalRadius == newRadius\n+                    && topLeftHorizontalRadiusAsPercentage == newRadiusAsPercentage) {\n+                return this;\n+            }\n+\n+            if (endValue.topLeftHorizontalRadius == newRadius\n+                    && endValue.topLeftHorizontalRadiusAsPercentage == newRadiusAsPercentage) {\n+                return endValue;\n+            }\n+\n+            return new CornerRadii(newRadius, newRadiusAsPercentage);\n+        }\n+\n+        boolean newTopLeftHorizontalRadiusAsPercentage,\n+                newTopLeftVerticalRadiusAsPercentage,\n+                newTopRightVerticalRadiusAsPercentage,\n+                newTopRightHorizontalRadiusAsPercentage,\n+                newBottomRightHorizontalRadiusAsPercentage,\n+                newBottomRightVerticalRadiusAsPercentage,\n+                newBottomLeftVerticalRadiusAsPercentage,\n+                newBottomLeftHorizontalRadiusAsPercentage;\n+\n+        if (t < 0.5) {\n+            newTopLeftHorizontalRadiusAsPercentage = this.topLeftHorizontalRadiusAsPercentage;\n+            newTopLeftVerticalRadiusAsPercentage = this.topLeftVerticalRadiusAsPercentage;\n+            newTopRightVerticalRadiusAsPercentage = this.topRightVerticalRadiusAsPercentage;\n+            newTopRightHorizontalRadiusAsPercentage = this.topRightHorizontalRadiusAsPercentage;\n+            newBottomRightHorizontalRadiusAsPercentage = this.bottomRightHorizontalRadiusAsPercentage;\n+            newBottomRightVerticalRadiusAsPercentage = this.bottomRightVerticalRadiusAsPercentage;\n+            newBottomLeftVerticalRadiusAsPercentage = this.bottomLeftVerticalRadiusAsPercentage;\n+            newBottomLeftHorizontalRadiusAsPercentage = this.bottomLeftHorizontalRadiusAsPercentage;\n+        } else {\n+            newTopLeftHorizontalRadiusAsPercentage = endValue.topLeftHorizontalRadiusAsPercentage;\n+            newTopLeftVerticalRadiusAsPercentage = endValue.topLeftVerticalRadiusAsPercentage;\n+            newTopRightVerticalRadiusAsPercentage = endValue.topRightVerticalRadiusAsPercentage;\n+            newTopRightHorizontalRadiusAsPercentage = endValue.topRightHorizontalRadiusAsPercentage;\n+            newBottomRightHorizontalRadiusAsPercentage = endValue.bottomRightHorizontalRadiusAsPercentage;\n+            newBottomRightVerticalRadiusAsPercentage = endValue.bottomRightVerticalRadiusAsPercentage;\n+            newBottomLeftVerticalRadiusAsPercentage = endValue.bottomLeftVerticalRadiusAsPercentage;\n+            newBottomLeftHorizontalRadiusAsPercentage = endValue.bottomLeftHorizontalRadiusAsPercentage;\n+        }\n+\n+        double newTopLeftHorizontalRadius = interpolate(\n+            this.topLeftHorizontalRadius, endValue.topLeftHorizontalRadius,\n+            this.topLeftHorizontalRadiusAsPercentage, endValue.topLeftHorizontalRadiusAsPercentage, t);\n+\n+        double newTopLeftVerticalRadius = interpolate(\n+            this.topLeftVerticalRadius, endValue.topLeftVerticalRadius,\n+            this.topLeftVerticalRadiusAsPercentage, endValue.topLeftVerticalRadiusAsPercentage, t);\n+\n+        double newTopRightVerticalRadius = interpolate(\n+            this.topRightVerticalRadius, endValue.topRightVerticalRadius,\n+            this.topRightVerticalRadiusAsPercentage, endValue.topRightVerticalRadiusAsPercentage, t);\n+\n+        double newTopRightHorizontalRadius = interpolate(\n+            this.topRightHorizontalRadius, endValue.topRightHorizontalRadius,\n+            this.topRightHorizontalRadiusAsPercentage, endValue.topRightHorizontalRadiusAsPercentage, t);\n+\n+        double newBottomRightHorizontalRadius = interpolate(\n+            this.bottomRightHorizontalRadius, endValue.bottomRightHorizontalRadius,\n+            this.bottomRightHorizontalRadiusAsPercentage, endValue.bottomRightHorizontalRadiusAsPercentage, t);\n+\n+        double newBottomRightVerticalRadius = interpolate(\n+            this.bottomRightVerticalRadius, endValue.bottomRightVerticalRadius,\n+            this.bottomRightVerticalRadiusAsPercentage, endValue.bottomRightVerticalRadiusAsPercentage, t);\n+\n+        double newBottomLeftVerticalRadius = interpolate(\n+            this.bottomLeftVerticalRadius, endValue.bottomLeftVerticalRadius,\n+            this.bottomLeftVerticalRadiusAsPercentage, endValue.bottomLeftVerticalRadiusAsPercentage, t);\n+\n+        double newBottomLeftHorizontalRadius = interpolate(\n+            this.bottomLeftHorizontalRadius, endValue.bottomLeftHorizontalRadius,\n+            this.bottomLeftHorizontalRadiusAsPercentage, endValue.bottomLeftHorizontalRadiusAsPercentage, t);\n+\n+        if (isSame(newTopLeftHorizontalRadius, newTopLeftVerticalRadius,\n+                   newTopRightVerticalRadius, newTopRightHorizontalRadius,\n+                   newBottomRightHorizontalRadius, newBottomRightVerticalRadius,\n+                   newBottomLeftVerticalRadius, newBottomLeftHorizontalRadius,\n+                   newTopLeftHorizontalRadiusAsPercentage, newTopLeftVerticalRadiusAsPercentage,\n+                   newTopRightVerticalRadiusAsPercentage, newTopRightHorizontalRadiusAsPercentage,\n+                   newBottomRightHorizontalRadiusAsPercentage, newBottomRightVerticalRadiusAsPercentage,\n+                   newBottomLeftVerticalRadiusAsPercentage, newBottomLeftHorizontalRadiusAsPercentage)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newTopLeftHorizontalRadius, newTopLeftVerticalRadius,\n+                            newTopRightVerticalRadius, newTopRightHorizontalRadius,\n+                            newBottomRightHorizontalRadius, newBottomRightVerticalRadius,\n+                            newBottomLeftVerticalRadius, newBottomLeftHorizontalRadius,\n+                            newTopLeftHorizontalRadiusAsPercentage, newTopLeftVerticalRadiusAsPercentage,\n+                            newTopRightVerticalRadiusAsPercentage, newTopRightHorizontalRadiusAsPercentage,\n+                            newBottomRightHorizontalRadiusAsPercentage, newBottomRightVerticalRadiusAsPercentage,\n+                            newBottomLeftVerticalRadiusAsPercentage, newBottomLeftHorizontalRadiusAsPercentage)) {\n+            return endValue;\n+        }\n+\n+        return new CornerRadii(\n+            newTopLeftHorizontalRadius, newTopLeftVerticalRadius,\n+            newTopRightVerticalRadius, newTopRightHorizontalRadius,\n+            newBottomRightHorizontalRadius, newBottomRightVerticalRadius,\n+            newBottomLeftVerticalRadius, newBottomLeftHorizontalRadius,\n+            newTopLeftHorizontalRadiusAsPercentage, newTopLeftVerticalRadiusAsPercentage,\n+            newTopRightVerticalRadiusAsPercentage, newTopRightHorizontalRadiusAsPercentage,\n+            newBottomRightHorizontalRadiusAsPercentage, newBottomRightVerticalRadiusAsPercentage,\n+            newBottomLeftVerticalRadiusAsPercentage, newBottomLeftHorizontalRadiusAsPercentage);\n+    }\n+\n+    private static double interpolate(double start, double end,\n+                                      boolean startIsPercentage, boolean endIsPercentage,\n+                                      double t) {\n+        return startIsPercentage == endIsPercentage ?\n+            Utils.interpolate(start, end, t) :\n+            Utils.interpolateDiscrete(start, end, t);\n+    }\n+\n+    private boolean isSame(double topLeftHorizontalRadius, double topLeftVerticalRadius,\n+                           double topRightVerticalRadius, double topRightHorizontalRadius,\n+                           double bottomRightHorizontalRadius, double bottomRightVerticalRadius,\n+                           double bottomLeftVerticalRadius, double bottomLeftHorizontalRadius,\n+                           boolean topLeftHorizontalRadiusAsPercentage, boolean topLeftVerticalRadiusAsPercentage,\n+                           boolean topRightVerticalRadiusAsPercentage, boolean topRightHorizontalRadiusAsPercentage,\n+                           boolean bottomRightHorizontalRadiusAsPercentage, boolean bottomRightVerticalRadiusAsPercentage,\n+                           boolean bottomLeftVerticalRadiusAsPercentage, boolean bottomLeftHorizontalRadiusAsPercentage) {\n+        return this.topLeftHorizontalRadius == topLeftHorizontalRadius\n+            && this.topLeftVerticalRadius == topLeftVerticalRadius\n+            && this.topRightVerticalRadius == topRightVerticalRadius\n+            && this.topRightHorizontalRadius == topRightHorizontalRadius\n+            && this.bottomRightHorizontalRadius == bottomRightHorizontalRadius\n+            && this.bottomRightVerticalRadius == bottomRightVerticalRadius\n+            && this.bottomLeftVerticalRadius == bottomLeftVerticalRadius\n+            && this.bottomLeftHorizontalRadius == bottomLeftHorizontalRadius\n+            && this.topLeftHorizontalRadiusAsPercentage == topLeftHorizontalRadiusAsPercentage\n+            && this.topLeftVerticalRadiusAsPercentage == topLeftVerticalRadiusAsPercentage\n+            && this.topRightVerticalRadiusAsPercentage == topRightVerticalRadiusAsPercentage\n+            && this.topRightHorizontalRadiusAsPercentage == topRightHorizontalRadiusAsPercentage\n+            && this.bottomRightHorizontalRadiusAsPercentage == bottomRightHorizontalRadiusAsPercentage\n+            && this.bottomRightVerticalRadiusAsPercentage == bottomRightVerticalRadiusAsPercentage\n+            && this.bottomLeftVerticalRadiusAsPercentage == bottomLeftVerticalRadiusAsPercentage\n+            && this.bottomLeftHorizontalRadiusAsPercentage == bottomLeftHorizontalRadiusAsPercentage;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/CornerRadii.java","additions":229,"deletions":11,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -1844,0 +1845,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -1853,0 +1855,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -1862,0 +1865,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -1871,0 +1875,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -1939,0 +1944,3 @@\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n@@ -1940,2 +1948,6 @@\n-    @Override public Color interpolate(Color endValue, double t) {\n-        if (t <= 0.0) return this;\n+    @Override\n+    public Color interpolate(Color endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ If both instances are equal, return this instance to prevent the creation of numerous small objects.\n+        if (t <= 0.0 || equals(endValue)) return this;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/Color.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -32,0 +34,1 @@\n+import java.util.Objects;\n@@ -133,1 +136,1 @@\n-public final class ImagePattern extends Paint {\n+public final class ImagePattern extends Paint implements Interpolatable<ImagePattern> {\n@@ -153,0 +156,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -165,0 +171,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -178,0 +187,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -191,0 +203,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -209,0 +224,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -224,0 +240,1 @@\n+    private int hash;\n@@ -273,0 +290,61 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public ImagePattern interpolate(ImagePattern endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        if (t <= 0 || equals(endValue)) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        if (proportional != endValue.proportional) {\n+            return Utils.interpolateDiscrete(this, endValue, t);\n+        }\n+\n+        return new ImagePattern(\n+            Utils.interpolateDiscrete(image, endValue.image, t),\n+            Utils.interpolate(x, endValue.x, t),\n+            Utils.interpolate(y, endValue.y, t),\n+            Utils.interpolate(width, endValue.width, t),\n+            Utils.interpolate(height, endValue.height, t),\n+            proportional);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof ImagePattern other) {\n+            return proportional == other.proportional\n+                && x == other.x\n+                && y == other.y\n+                && width == other.width\n+                && height == other.height\n+                && image.equals(other.image);\n+        }\n+\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        if (hash == 0) {\n+            long bits = 17L;\n+            bits = 37L * bits + Double.doubleToLongBits(x);\n+            bits = 37L * bits + Double.doubleToLongBits(y);\n+            bits = 37L * bits + Double.doubleToLongBits(width);\n+            bits = 37L * bits + Double.doubleToLongBits(height);\n+            bits = 37L * bits + ((proportional) ? 1231L : 1237L);\n+            bits = 37L * bits + image.hashCode();\n+            hash = (int) (bits ^ (bits >> 32));\n+        }\n+\n+        return hash;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/ImagePattern.java","additions":80,"deletions":2,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-\n+import java.util.Objects;\n@@ -32,0 +32,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -75,1 +77,1 @@\n-public final class LinearGradient extends Paint {\n+public final class LinearGradient extends Paint implements Interpolatable<LinearGradient> {\n@@ -81,1 +83,1 @@\n-     * point on a unit square that will be scaled to match the size of the\n+     * point on a unit square that will be scaled to match the size of\n@@ -83,1 +85,1 @@\n-     (\n+     *\n@@ -86,0 +88,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -96,1 +101,1 @@\n-     * point on a unit square that will be scaled to match the size of the\n+     * point on a unit square that will be scaled to match the size of\n@@ -101,0 +106,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -111,1 +119,1 @@\n-     * point on a unit square that will be scaled to match the size of the\n+     * point on a unit square that will be scaled to match the size of\n@@ -116,0 +124,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -126,1 +137,1 @@\n-     * point on a unit square that will be scaled to match the size of the\n+     * point on a unit square that will be scaled to match the size of\n@@ -131,0 +142,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -148,0 +162,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -162,0 +177,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -183,0 +199,3 @@\n+     * @interpolationType Stop list interpolation produces smooth transitions of gradient stops by allowing\n+     *                    the insertion of new stops along the gradient. At most, the intermediate stop list\n+     *                    has the combined number of gradient stops of both the start list and the target list.\n@@ -267,0 +286,18 @@\n+    \/**\n+     * Private constructor accepting a stop list that is already normalized.\n+     * This constructor is only called from the {@link #interpolate} method.\n+     *\/\n+    private LinearGradient(\n+            double startX, double startY, double endX, double endY,\n+            boolean proportional, CycleMethod cycleMethod, List<Stop> stops,\n+            int ignored) {\n+        this.startX = startX;\n+        this.startY = startY;\n+        this.endX = endX;\n+        this.endY = endY;\n+        this.proportional = proportional;\n+        this.cycleMethod = cycleMethod;\n+        this.stops = stops;\n+        this.opaque = determineOpacity();\n+    }\n+\n@@ -293,0 +330,75 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public LinearGradient interpolate(LinearGradient endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0.0) {\n+            return this;\n+        }\n+\n+        if (t >= 1.0) {\n+            return endValue;\n+        }\n+\n+        double newStartX, newStartY, newEndX, newEndY;\n+        boolean newProportional;\n+\n+        if (this.proportional == endValue.proportional) {\n+            newStartX = Utils.interpolate(this.startX, endValue.startX, t);\n+            newStartY = Utils.interpolate(this.startY, endValue.startY, t);\n+            newEndX = Utils.interpolate(this.endX, endValue.endX, t);\n+            newEndY = Utils.interpolate(this.endY, endValue.endY, t);\n+            newProportional = this.proportional;\n+        } else if (t < 0.5) {\n+            newStartX = this.startX;\n+            newStartY = this.startY;\n+            newEndX = this.endX;\n+            newEndY = this.endY;\n+            newProportional = this.proportional;\n+        } else {\n+            newStartX = endValue.startX;\n+            newStartY = endValue.startY;\n+            newEndX = endValue.endX;\n+            newEndY = endValue.endY;\n+            newProportional = endValue.proportional;\n+        }\n+\n+        CycleMethod newCycleMethod = Utils.interpolateDiscrete(this.cycleMethod, endValue.cycleMethod, t);\n+\n+        \/\/ Optimization: if both lists are equal, we don't compute a new intermediate list.\n+        List<Stop> newStops = this.stops.equals(endValue.stops) ?\n+            null : Stop.interpolateLists(this.stops, endValue.stops, t);\n+\n+        if (isSame(newStartX, newStartY, newEndX, newEndY, newProportional,\n+                   newCycleMethod, Objects.requireNonNullElse(newStops, this.stops))) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newStartX, newStartY, newEndX, newEndY, newProportional,\n+                            newCycleMethod, Objects.requireNonNullElse(newStops, endValue.stops))) {\n+            return endValue;\n+        }\n+\n+        return new LinearGradient(newStartX, newStartY, newEndX, newEndY,\n+                                  newProportional, newCycleMethod,\n+                                  Objects.requireNonNullElse(newStops, this.stops), 0);\n+    }\n+\n+    private boolean isSame(double startX, double startY, double endX, double endY,\n+                           boolean proportional, CycleMethod cycleMethod, List<Stop> stops) {\n+        return this.startX == startX\n+            && this.startY == startY\n+            && this.endX == endX\n+            && this.endY == endY\n+            && this.proportional == proportional\n+            && this.cycleMethod == cycleMethod\n+            && this.stops == stops;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/LinearGradient.java","additions":120,"deletions":8,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-\n+import java.util.Objects;\n@@ -32,0 +32,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -68,1 +70,1 @@\n-public final class RadialGradient extends Paint {\n+public final class RadialGradient extends Paint implements Interpolatable<RadialGradient> {\n@@ -74,2 +76,4 @@\n-     * @return the angle in degrees from the center of the gradient\n-     * to the focus point to which the first color is mapped\n+     *\n+     * @return the angle in degrees from the center of the gradient to the focus point\n+     *         to which the first color is mapped\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -88,2 +92,4 @@\n-     * @return the distance from the center of the gradient to the\n-     * focus point to which the first color is mapped\n+     *\n+     * @return the distance from the center of the gradient to the focus point to which\n+     *         the first color is mapped\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -100,1 +106,1 @@\n-     * point on a unit square that will be scaled to match the size of the\n+     * point on a unit square that will be scaled to match the size of\n@@ -104,2 +110,1 @@\n-     * @return the X coordinate of the center point of the circle defining the\n-     * gradient\n+     * @return the X coordinate of the center point of the circle defining the gradient\n@@ -107,0 +112,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -121,2 +129,1 @@\n-     * @return the X coordinate of the center point of the circle defining the\n-     * gradient\n+     * @return the X coordinate of the center point of the circle defining the gradient\n@@ -124,0 +131,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -137,2 +147,1 @@\n-     * @return the radius of the circle defining the extents of the color\n-     * gradient\n+     * @return the radius of the circle defining the extents of the color gradient\n@@ -140,0 +149,3 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     *                    if both values are absolute or both values are {@link #isProportional() proportional},\n+     *                    <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a> otherwise\n@@ -156,2 +168,1 @@\n-     * @return true if the center and radius values are proportional, otherwise\n-     * absolute\n+     * @return true if the center and radius values are proportional, otherwise absolute\n@@ -159,0 +170,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -173,0 +185,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#discrete\">discrete<\/a>\n@@ -194,0 +207,1 @@\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#pairwise\">pairwise<\/a>\n@@ -288,0 +302,18 @@\n+    \/**\n+     * Private constructor accepting a stop list that is already normalized.\n+     * This constructor is only called from the {@link #interpolate} method.\n+     *\/\n+    private RadialGradient(\n+            double focusAngle, double focusDistance, double centerX, double centerY, double radius,\n+            boolean proportional, CycleMethod cycleMethod, List<Stop> stops, int ignored) {\n+        this.focusAngle = focusAngle;\n+        this.focusDistance = focusDistance;\n+        this.centerX = centerX;\n+        this.centerY = centerY;\n+        this.radius = radius;\n+        this.proportional = proportional;\n+        this.cycleMethod = cycleMethod;\n+        this.stops = stops;\n+        this.opaque = determineOpacity();\n+    }\n+\n@@ -314,0 +346,74 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public RadialGradient interpolate(RadialGradient endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0.0) {\n+            return this;\n+        }\n+\n+        if (t >= 1.0) {\n+            return endValue;\n+        }\n+\n+        double newCenterX, newCenterY, newRadius;\n+        boolean newProportional;\n+\n+        if (this.proportional == endValue.proportional) {\n+            newCenterX = Utils.interpolate(this.centerX, endValue.centerX, t);\n+            newCenterY = Utils.interpolate(this.centerY, endValue.centerY, t);\n+            newRadius = Utils.interpolate(this.radius, endValue.radius, t);\n+            newProportional = this.proportional;\n+        } else if (t < 0.5) {\n+            newCenterX = this.centerX;\n+            newCenterY = this.centerY;\n+            newRadius = this.radius;\n+            newProportional = this.proportional;\n+        } else {\n+            newCenterX = endValue.centerX;\n+            newCenterY = endValue.centerY;\n+            newRadius = endValue.radius;\n+            newProportional = endValue.proportional;\n+        }\n+\n+        double newFocusAngle = Utils.interpolate(this.focusAngle, endValue.focusAngle, t);\n+        double newFocusDistance = Utils.interpolate(this.focusDistance, endValue.focusDistance, t);\n+        CycleMethod newCycleMethod = Utils.interpolateDiscrete(this.cycleMethod, endValue.cycleMethod, t);\n+\n+        \/\/ Optimization: if both lists are equal, we don't compute a new intermediate list.\n+        List<Stop> newStops = this.stops.equals(endValue.stops) ?\n+            null : Stop.interpolateLists(this.stops, endValue.stops, t);\n+\n+        if (isSame(newFocusAngle, newFocusDistance, newCenterX, newCenterY, newRadius, newProportional,\n+                   newCycleMethod, Objects.requireNonNullElse(newStops, this.stops))) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newFocusAngle, newFocusDistance, newCenterX, newCenterY, newRadius, newProportional,\n+                            newCycleMethod, Objects.requireNonNullElse(newStops, endValue.stops))) {\n+            return endValue;\n+        }\n+\n+        return new RadialGradient(newFocusAngle, newFocusDistance, newCenterX, newCenterY, newRadius, newProportional,\n+                                  newCycleMethod, Objects.requireNonNullElse(newStops, this.stops), 0);\n+    }\n+\n+    private boolean isSame(double focusAngle, double focusDistance, double centerX, double centerY,\n+                           double radius, boolean proportional, CycleMethod cycleMethod, List<Stop> stops) {\n+        return this.focusAngle == focusAngle\n+            && this.focusDistance == focusDistance\n+            && this.centerX == centerX\n+            && this.centerY == centerY\n+            && this.radius == radius\n+            && this.proportional == proportional\n+            && this.cycleMethod == cycleMethod\n+            && this.stops == stops;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/RadialGradient.java","additions":122,"deletions":16,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,4 @@\n+import java.util.Objects;\n+import com.sun.javafx.UnmodifiableArrayList;\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -49,1 +53,1 @@\n-public final class Stop {\n+public final class Stop implements Interpolatable<Stop> {\n@@ -68,1 +72,1 @@\n-            if (s == null || s.getColor() == null) continue;\n+            if (s == null) continue;\n@@ -134,0 +138,74 @@\n+    \/**\n+     * Interpolates between two lists of stops.\n+     *\n+     * @param firstList the first list, not {@code null}\n+     * @param secondList the second list, not {@code null}\n+     * @return the interpolated list, which may also be {@code firstList} or {@code secondList};\n+     *         if a new list is returned, it is unmodifiable\n+     *\/\n+    static List<Stop> interpolateLists(List<Stop> firstList, List<Stop> secondList, double t) {\n+        Objects.requireNonNull(firstList, \"firstList cannot be null\");\n+        Objects.requireNonNull(secondList, \"secondList cannot be null\");\n+\n+        if (t <= 0) {\n+            return firstList;\n+        }\n+\n+        if (t >= 1) {\n+            return secondList;\n+        }\n+\n+        \/\/ We need a new list that is at most the combined size of firstList and secondList.\n+        \/\/ In many cases we don't need all of that capacity, but allocating once is better than\n+        \/\/ re-allocating when we run out of space. In general, we expect the size of stop lists\n+        \/\/ to be quite small (a single-digit number of stops at most).\n+        Stop[] stops = new Stop[firstList.size() + secondList.size()];\n+        int size = 0;\n+\n+        for (int i = 0, j = 0, imax = firstList.size(), jmax = secondList.size(); i < imax && j < jmax; ++size) {\n+            Stop first = firstList.get(i);\n+            Stop second = secondList.get(j);\n+\n+            if (first.offset == second.offset) {\n+                stops[size] = first.color.equals(second.color) ?\n+                    first : new Stop(first.offset, first.color.interpolate(second.color, t));\n+                ++i;\n+                ++j;\n+            } else if (first.offset < second.offset) {\n+                stops[size] = j == 0 ?\n+                    new Stop(first.offset, second.color) :\n+                    interpolateVirtualStop(first, second, secondList.get(j - 1), 1 - t);\n+                ++i;\n+            } else {\n+                stops[size] = i == 0 ?\n+                    new Stop(second.offset, first.color) :\n+                    interpolateVirtualStop(second, first, firstList.get(i - 1), t);\n+                ++j;\n+            }\n+        }\n+\n+        return new UnmodifiableArrayList<>(stops, size);\n+    }\n+\n+    \/**\n+     * Consider two lists A and B, where A contains three stops, and B contains two stops:\n+     * <pre>{@code\n+     *               A2\n+     *             \/   \\\n+     *           \/      \\\n+     *    B1---\/----[X]--\\--B2\n+     *       \/            \\\n+     *     \/               \\\n+     *   A1                 A3\n+     * }<\/pre>\n+     *\n+     * Given the stops A{1,2,3} and B{1,2} in the diagram above, this method computes a new virtual\n+     * stop X that matches the offset of A2, and then interpolates between X and A2.\n+     *\/\n+    private static Stop interpolateVirtualStop(Stop A2, Stop B2, Stop B1, double t) {\n+        double u = (A2.offset - B1.offset) \/ (B2.offset - B1.offset);\n+        Color colorX = B1.color.interpolate(B2.color, u);\n+        Color colorR = colorX.interpolate(A2.color, t);\n+        return colorR.equals(A2.color) ? A2 : new Stop(A2.offset, colorR);\n+    }\n+\n@@ -152,2 +230,2 @@\n-     * @return position of the Stop within the gradient\n-     *         (ranging from {@code 0} to {@code 1})\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n+     * @return position of the Stop within the gradient (ranging from {@code 0} to {@code 1})\n@@ -168,0 +246,2 @@\n+     *\n+     * @interpolationType <a href=\"..\/..\/animation\/Interpolatable.html#linear\">linear<\/a>\n@@ -187,1 +267,38 @@\n-        this.color = color;\n+        this.color = Objects.requireNonNullElse(color, Color.TRANSPARENT);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 23\n+     *\/\n+    @Override\n+    public Stop interpolate(Stop endValue, double t) {\n+        Objects.requireNonNull(endValue, \"endValue cannot be null\");\n+\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0.0) {\n+            return this;\n+        }\n+\n+        if (t >= 1.0) {\n+            return endValue;\n+        }\n+\n+        \/\/ Color is implemented such that interpolate() always returns the existing instance if the\n+        \/\/ intermediate value is equal to the start value or the end value, which allows us to use an\n+        \/\/ identity comparison in place of a value comparison to determine equality.\n+        Color color = this.color.interpolate(endValue.color, t);\n+        double offset = Utils.interpolate(this.offset, endValue.offset, t);\n+\n+        if (offset == this.offset && color == this.color) {\n+            return this;\n+        }\n+\n+        if (offset == endValue.offset && color == endValue.color) {\n+            return endValue;\n+        }\n+\n+        return new Stop(offset, color);\n@@ -198,4 +315,2 @@\n-        if (obj instanceof Stop) {\n-            Stop other = (Stop) obj;\n-            return offset == other.offset &&\n-              (color == null ? other.color == null : color.equals(other.color));\n+        if (obj instanceof Stop other) {\n+            return offset == other.offset && color.equals(other.color);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/Stop.java","additions":125,"deletions":10,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.paint;\n+\n+import java.util.List;\n+\n+public final class StopShim {\n+\n+    private StopShim() {}\n+\n+    public static List<Stop> interpolateLists(List<Stop> firstList, List<Stop> secondList, double t) {\n+        return Stop.interpolateLists(firstList, secondList, t);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/javafx\/scene\/paint\/StopShim.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+--add-exports javafx.graphics\/com.sun.javafx.scene.paint=ALL-UNNAMED\n","filename":"modules\/javafx.graphics\/src\/test\/addExports","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,2 @@\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -34,1 +32,1 @@\n-import org.junit.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -65,0 +63,26 @@\n+    }\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenTwoDifferentValuesReturnsNewInstance() {\n+            var a = new Insets(2, 4, 6, 8);\n+            var b = new Insets(4, 8, 12, 16);\n+            var expected = new Insets(3, 6, 9, 12);\n+            assertEquals(expected, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsStartInstance() {\n+            var a = new Insets(2, 4, 6, 8);\n+            var b = new Insets(2, 4, 6, 8);\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var a = new Insets(2, 4, 6, 8);\n+            var b = new Insets(4, 8, 12, 16);\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -1));\n+        }\n@@ -66,0 +90,7 @@\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var a = new Insets(2, 4, 6, 8);\n+            var b = new Insets(4, 8, 12, 16);\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/geometry\/InsetsTest.java","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.scene.paint.PaintUtils;\n@@ -29,0 +30,1 @@\n+import javafx.scene.image.Image;\n@@ -32,1 +34,6 @@\n-import org.junit.Test;\n+import javafx.scene.paint.ImagePattern;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.RadialGradient;\n+import java.io.ByteArrayInputStream;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -34,1 +41,1 @@\n-import static org.junit.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -40,1 +47,2 @@\n-    @Test public void nullPaintDefaultsToTransparent() {\n+    @Test\n+    public void nullPaintDefaultsToTransparent() {\n@@ -100,0 +108,117 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void twoColorFills() {\n+            BackgroundFill startValue = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(Color.RED, new CornerRadii(4), new Insets(6));\n+            BackgroundFill actual = startValue.interpolate(endValue, 0.5);\n+            assertEquals(Color.ORANGE.interpolate(Color.RED, 0.5), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+        }\n+\n+        @Test\n+        public void twoLinearGradientFills() {\n+            var gradient1 = LinearGradient.valueOf(\"linear-gradient(to left top, red, blue)\");\n+            var gradient2 = LinearGradient.valueOf(\"linear-gradient(to left top, yellow, white)\");\n+            BackgroundFill startValue = new BackgroundFill(gradient1, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(gradient2, new CornerRadii(4), new Insets(6));\n+            BackgroundFill actual = startValue.interpolate(endValue, 0.5);\n+            assertEquals(gradient1.interpolate(gradient2, 0.5), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+        }\n+\n+        @Test\n+        public void linearGradientAndColorFills() {\n+            var gradient = LinearGradient.valueOf(\"linear-gradient(to left top, red, blue)\");\n+            BackgroundFill startValue = new BackgroundFill(gradient, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(Color.ORANGE, new CornerRadii(4), new Insets(6));\n+\n+            BackgroundFill actual = startValue.interpolate(endValue, 0.5);\n+            assertEquals(gradient.interpolate(PaintUtils.newSolidGradient(gradient, Color.ORANGE), 0.5), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+\n+            actual = endValue.interpolate(startValue, 0.5);\n+            assertEquals(PaintUtils.newSolidGradient(gradient, Color.ORANGE).interpolate(gradient, 0.5), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+        }\n+\n+        @Test\n+        public void twoRadialGradientFills() {\n+            var gradient1 = RadialGradient.valueOf(\"radial-gradient(radius 100%, red, blue)\");\n+            var gradient2 = RadialGradient.valueOf(\"radial-gradient(radius 50%, yellow, white)\");\n+            BackgroundFill startValue = new BackgroundFill(gradient1, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(gradient2, new CornerRadii(4), new Insets(6));\n+            BackgroundFill actual = startValue.interpolate(endValue, 0.5);\n+            assertEquals(gradient1.interpolate(gradient2, 0.5), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+        }\n+\n+        @Test\n+        public void radialGradientAndColorFills() {\n+            var gradient = RadialGradient.valueOf(\"radial-gradient(radius 100%, red, blue)\");\n+            BackgroundFill startValue = new BackgroundFill(gradient, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(Color.ORANGE, new CornerRadii(4), new Insets(6));\n+\n+            BackgroundFill actual = startValue.interpolate(endValue, 0.5);\n+            assertEquals(gradient.interpolate(PaintUtils.newSolidGradient(gradient, Color.ORANGE), 0.5), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+\n+            actual = endValue.interpolate(startValue, 0.5);\n+            assertEquals(PaintUtils.newSolidGradient(gradient, Color.ORANGE).interpolate(gradient, 0.5), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+        }\n+\n+        @Test\n+        public void incompatibleFillsReturnsStartFillOrEndFill() {\n+            var imagePattern = new ImagePattern(new Image(new ByteArrayInputStream(new byte[] {})));\n+            BackgroundFill startValue = new BackgroundFill(imagePattern, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(Color.RED, new CornerRadii(4), new Insets(6));\n+            BackgroundFill actual;\n+\n+            actual = startValue.interpolate(endValue, 0.25);\n+            assertEquals(startValue.getFill(), actual.getFill());\n+            assertEquals(new CornerRadii(2.5), actual.getRadii());\n+            assertEquals(new Insets(3), actual.getInsets());\n+\n+            actual = startValue.interpolate(endValue, 0.5);\n+            assertEquals(endValue.getFill(), actual.getFill());\n+            assertEquals(new CornerRadii(3), actual.getRadii());\n+            assertEquals(new Insets(4), actual.getInsets());\n+\n+            actual = startValue.interpolate(endValue, 0.75);\n+            assertEquals(endValue.getFill(), actual.getFill());\n+            assertEquals(new CornerRadii(3.5), actual.getRadii());\n+            assertEquals(new Insets(5), actual.getInsets());\n+        }\n+\n+        @Test\n+        public void twoEqualFillsReturnsExistingInstance() {\n+            BackgroundFill startValue = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            BackgroundFill startValue = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(Color.RED, new CornerRadii(4), new Insets(6));\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            BackgroundFill startValue = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            BackgroundFill endValue = new BackgroundFill(Color.RED, new CornerRadii(4), new Insets(6));\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundFillTest.java","additions":129,"deletions":4,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n-import org.junit.Test;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -36,1 +37,1 @@\n-import static org.junit.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -68,1 +69,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -70,1 +71,1 @@\n-        new BackgroundImage(null, NO_REPEAT, ROUND, POS_2, SIZE_2);\n+        assertThrows(NullPointerException.class, () -> new BackgroundImage(null, NO_REPEAT, ROUND, POS_2, SIZE_2));\n@@ -221,0 +222,53 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        final BackgroundImage BACKGROUND_IMAGE_A = new BackgroundImage(\n+            IMAGE_1, NO_REPEAT, NO_REPEAT,\n+            new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false),\n+            new BackgroundSize(50, 100, false, false, false, false));\n+\n+        final BackgroundImage BACKGROUND_IMAGE_B = new BackgroundImage(\n+            IMAGE_2, REPEAT, SPACE,\n+            new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false),\n+            new BackgroundSize(100, 200, false, false, false, false));\n+\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var expect = new BackgroundImage(\n+                IMAGE_2, REPEAT, SPACE,\n+                new BackgroundPosition(Side.LEFT, 5, false, Side.TOP, 10, false),\n+                new BackgroundSize(75, 150, false, false, false, false));\n+\n+            var actual = BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, 0.5);\n+\n+            assertEquals(expect, actual);\n+            assertNotSame(expect, actual);\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var startValue = new BackgroundImage(\n+                IMAGE_1, NO_REPEAT, NO_REPEAT,\n+                new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false),\n+                new BackgroundSize(50, 100, false, false, false, false));\n+\n+            var endValue = new BackgroundImage(\n+                IMAGE_1, NO_REPEAT, NO_REPEAT,\n+                new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false),\n+                new BackgroundSize(50, 100, false, false, false, false));\n+\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            assertSame(BACKGROUND_IMAGE_A, BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, 0));\n+            assertSame(BACKGROUND_IMAGE_A, BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            assertSame(BACKGROUND_IMAGE_B, BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, 1));\n+            assertSame(BACKGROUND_IMAGE_B, BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundImageTest.java","additions":59,"deletions":5,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,2 @@\n-import org.junit.Test;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -32,1 +33,1 @@\n-import static org.junit.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -37,1 +38,2 @@\n-    @Test public void valuesAreCorrectAfterConstruction() {\n+    @Test\n+    public void valuesAreCorrectAfterConstruction() {\n@@ -64,1 +66,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -66,1 +68,3 @@\n-        new BackgroundPosition(Side.TOP, 10, true, Side.BOTTOM, 20, true);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundPosition(Side.TOP, 10, true, Side.BOTTOM, 20, true));\n@@ -69,1 +73,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -71,1 +75,3 @@\n-        new BackgroundPosition(Side.BOTTOM, 10, true, Side.BOTTOM, 20, true);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundPosition(Side.BOTTOM, 10, true, Side.BOTTOM, 20, true));\n@@ -84,1 +90,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -86,1 +92,3 @@\n-        new BackgroundPosition(Side.LEFT, 10, true, Side.LEFT, 20, true);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundPosition(Side.LEFT, 10, true, Side.LEFT, 20, true));\n@@ -89,1 +97,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -91,1 +99,3 @@\n-        new BackgroundPosition(Side.LEFT, 10, true, Side.RIGHT, 20, true);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundPosition(Side.LEFT, 10, true, Side.RIGHT, 20, true));\n@@ -170,0 +180,95 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateComponentWithAbsoluteAndPercentageMismatch() {\n+            record TestCase(BackgroundPosition endValue, BackgroundPosition expected) {}\n+\n+            final double v0 = 0, v25 = 10, v50 = 20, v100 = 40;\n+            final var startValue = new BackgroundPosition(Side.LEFT, v0, false, Side.TOP, v0, false);\n+\n+            \/\/ For each component: interpolation with t=0.25 returns start value on absolute\/percentage mismatch.\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new BackgroundPosition(Side.LEFT, v100, false, Side.TOP, v100, false),\n+                    new BackgroundPosition(Side.LEFT, v25, false, Side.TOP, v25, false)),\n+                new TestCase(\n+                    new BackgroundPosition(Side.LEFT, v100, true, Side.TOP, v100, false),\n+                    new BackgroundPosition(Side.LEFT, v0, false, Side.TOP, v25, false)),\n+                new TestCase(\n+                    new BackgroundPosition(Side.LEFT, v100, false, Side.TOP, v100, true),\n+                    new BackgroundPosition(Side.LEFT, v25, false, Side.TOP, v0, false))\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.25));\n+            }\n+\n+            \/\/ For each component: interpolation with t=0.5 returns end value on absolute\/percentage mismatch.\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new BackgroundPosition(Side.LEFT, v100, false, Side.TOP, v100, false),\n+                    new BackgroundPosition(Side.LEFT, v50, false, Side.TOP, v50, false)),\n+                new TestCase(\n+                    new BackgroundPosition(Side.LEFT, v100, true, Side.TOP, v100, false),\n+                    new BackgroundPosition(Side.LEFT, v100, true, Side.TOP, v50, false)),\n+                new TestCase(\n+                    new BackgroundPosition(Side.LEFT, v100, false, Side.TOP, v100, true),\n+                    new BackgroundPosition(Side.LEFT, v50, false, Side.TOP, v100, true))\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.5));\n+            }\n+        }\n+\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var endValue = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            var expected = new BackgroundPosition(Side.LEFT, 5, false, Side.TOP, 10, false);\n+            assertEquals(expected, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var startValue = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            var endValue = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.75));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var endValue = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var endValue = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+\n+        @Test\n+        public void percentageAndAbsolutePositionsCannotBeInterpolated() {\n+            var startValue = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var endValue = new BackgroundPosition(Side.LEFT, 10, true, Side.TOP, 20, true);\n+            assertEquals(startValue, startValue.interpolate(endValue, 0.25)); \/\/ equal to 'startValue' for t < 0.5\n+            assertEquals(endValue, startValue.interpolate(endValue, 0.5)); \/\/ equal to 'endValue' otherwise\n+        }\n+\n+        @Test\n+        public void differentSidesCannotBeInterpolated() {\n+            var startValue = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var endValue = new BackgroundPosition(Side.RIGHT, 10, false, Side.TOP, 20, false);\n+            var expect = new BackgroundPosition(Side.RIGHT, 10, false, Side.TOP, 10, false);\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+\n+            startValue = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            endValue = new BackgroundPosition(Side.LEFT, 10, false, Side.BOTTOM, 20, false);\n+            expect = new BackgroundPosition(Side.LEFT, 5, false, Side.BOTTOM, 20, false);\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundPositionTest.java","additions":117,"deletions":12,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,3 @@\n-import org.junit.Ignore;\n-import org.junit.Test;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -32,1 +33,2 @@\n-import static org.junit.Assert.*;\n+import static javafx.scene.layout.BackgroundSize.AUTO;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -37,1 +39,2 @@\n-    @Test public void instanceCreation() {\n+    @Test\n+    public void instanceCreation() {\n@@ -67,1 +70,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -69,1 +72,3 @@\n-        new BackgroundSize(-.2, 1, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(-.2, 1, true, true, false, false));\n@@ -72,1 +77,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -74,1 +79,3 @@\n-        new BackgroundSize(-2, 1, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(-2, 1, true, true, false, false));\n@@ -77,2 +84,2 @@\n-    @Ignore(\"JDK-8234090\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Disabled(\"JDK-8234090\")\n+    @Test\n@@ -80,1 +87,3 @@\n-        new BackgroundSize(Double.POSITIVE_INFINITY, 1, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(Double.POSITIVE_INFINITY, 1, true, true, false, false));\n@@ -83,2 +92,2 @@\n-    @Ignore(\"JDK-8234090\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Disabled(\"JDK-8234090\")\n+    @Test\n@@ -86,1 +95,3 @@\n-        new BackgroundSize(Double.NEGATIVE_INFINITY, 1, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(Double.NEGATIVE_INFINITY, 1, true, true, false, false));\n@@ -89,2 +100,2 @@\n-    @Ignore(\"JDK-8234090\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Disabled(\"JDK-8234090\")\n+    @Test\n@@ -92,1 +103,3 @@\n-        new BackgroundSize(Double.NaN, 1, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(Double.NaN, 1, true, true, false, false));\n@@ -102,1 +115,1 @@\n-        assertEquals(BackgroundSize.AUTO, size.getWidth(), 0);\n+        assertEquals(AUTO, size.getWidth(), 0);\n@@ -105,1 +118,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -107,1 +120,3 @@\n-        new BackgroundSize(1, -.1, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(1, -.1, true, true, false, false));\n@@ -110,1 +125,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -112,1 +127,3 @@\n-        new BackgroundSize(1, -2, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(1, -2, true, true, false, false));\n@@ -115,2 +132,2 @@\n-    @Ignore(\"JDK-8234090\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Disabled(\"JDK-8234090\")\n+    @Test\n@@ -118,1 +135,3 @@\n-        new BackgroundSize(1, Double.POSITIVE_INFINITY, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(1, Double.POSITIVE_INFINITY, true, true, false, false));\n@@ -121,2 +140,2 @@\n-    @Ignore(\"JDK-8234090\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Disabled(\"JDK-8234090\")\n+    @Test\n@@ -124,1 +143,3 @@\n-        new BackgroundSize(1, Double.NEGATIVE_INFINITY, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(1, Double.NEGATIVE_INFINITY, true, true, false, false));\n@@ -127,2 +148,2 @@\n-    @Ignore(\"JDK-8234090\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Disabled(\"JDK-8234090\")\n+    @Test\n@@ -130,1 +151,3 @@\n-        new BackgroundSize(1, Double.NaN, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(1, Double.NaN, true, true, false, false));\n@@ -140,1 +163,1 @@\n-        assertEquals(BackgroundSize.AUTO, size.getHeight(), 0);\n+        assertEquals(AUTO, size.getHeight(), 0);\n@@ -249,0 +272,105 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateComponentWithAbsoluteAndPercentageMismatch() {\n+            record TestCase(BackgroundSize endValue, BackgroundSize expected) {}\n+\n+            final double v0 = 0, v25 = 10, v50 = 20, v100 = 40;\n+            final var startValue = new BackgroundSize(v0, v0, false, false, false, false);\n+\n+            \/\/ For each component: interpolation with t=0.25 returns start value on absolute\/percentage mismatch.\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new BackgroundSize(v100, v100, false, false, false, false),\n+                    new BackgroundSize(v25, v25, false, false, false, false)),\n+                new TestCase(\n+                    new BackgroundSize(v100, v100, true, false, false, false),\n+                    new BackgroundSize(v0, v25, false, false, false, false)),\n+                new TestCase(\n+                    new BackgroundSize(v100, v100, false, true, false, false),\n+                    new BackgroundSize(v25, v0, false, false, false, false))\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.25));\n+            }\n+\n+            \/\/ For each component: interpolation with t=0.5 returns end value on absolute\/percentage mismatch.\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new BackgroundSize(v100, v100, false, false, false, false),\n+                    new BackgroundSize(v50, v50, false, false, false, false)),\n+                new TestCase(\n+                    new BackgroundSize(v100, v100, true, false, false, false),\n+                    new BackgroundSize(v100, v50, true, false, false, false)),\n+                new TestCase(\n+                    new BackgroundSize(v100, v100, false, true, false, false),\n+                    new BackgroundSize(v50, v100, false, true, false, false))\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.5));\n+            }\n+        }\n+\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new BackgroundSize(10, 20, false, false, false, false);\n+            var endValue = new BackgroundSize(20, 40, false, false, false, false);\n+            var expect = new BackgroundSize(15, 30, false, false, false, false);\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var startValue = new BackgroundSize(10, 20, false, false, false, false);\n+            var endValue = new BackgroundSize(10, 20, false, false, false, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.75));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new BackgroundSize(10, 20, false, false, false, false);\n+            var endValue = new BackgroundSize(20, 40, false, false, false, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new BackgroundSize(10, 20, false, false, false, false);\n+            var endValue = new BackgroundSize(20, 40, false, false, false, false);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+\n+        @Test\n+        public void widthOrHeightLessThanZeroCannotBeInterpolated() {\n+            var startValue = new BackgroundSize(10, 20, false, false, false, false);\n+            var endValue = new BackgroundSize(AUTO, 40, false, false, false, false);\n+            var expect = new BackgroundSize(AUTO, 30, false, false, false, false);\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+\n+            startValue = new BackgroundSize(20, 10, false, false, false, false);\n+            endValue = new BackgroundSize(40, AUTO, false, false, false, false);\n+            expect = new BackgroundSize(30, AUTO, false, false, false, false);\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void notInterpolatableReturnsStartOrEndInstance() {\n+            var startValue = new BackgroundSize(10, 10, false, false, false, true);\n+            var endValue = new BackgroundSize(20, 20, false, false, false, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+\n+            startValue = new BackgroundSize(10, 10, false, false, false, false);\n+            endValue = new BackgroundSize(20, 20, false, false, true, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+\n+            startValue = new BackgroundSize(AUTO, AUTO, false, false, false, false);\n+            endValue = new BackgroundSize(20, 20, false, false, false, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundSizeTest.java","additions":161,"deletions":33,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import javafx.scene.layout.BackgroundSize;\n@@ -38,1 +39,3 @@\n-import org.junit.Test;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import java.util.List;\n@@ -41,1 +44,1 @@\n-import static org.junit.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -69,1 +72,2 @@\n-    @Test public void instanceCreation() {\n+    @Test\n+    public void instanceCreation() {\n@@ -234,1 +238,1 @@\n-    @Test(expected = UnsupportedOperationException.class)\n+    @Test\n@@ -239,1 +243,2 @@\n-        b.getFills().add(new BackgroundFill(Color.BLUE, new CornerRadii(6), new Insets(8)));\n+        assertThrows(UnsupportedOperationException.class,\n+            () -> b.getFills().add(new BackgroundFill(Color.BLUE, new CornerRadii(6), new Insets(8))));\n@@ -242,1 +247,1 @@\n-    @Test(expected = UnsupportedOperationException.class)\n+    @Test\n@@ -247,1 +252,2 @@\n-        b.getImages().add(new BackgroundImage(IMAGE_3, ROUND, ROUND, null, null));\n+        assertThrows(UnsupportedOperationException.class,\n+            () -> b.getImages().add(new BackgroundImage(IMAGE_3, ROUND, ROUND, null, null)));\n@@ -722,1 +728,1 @@\n-        assertEquals(\"The factory method should give the same result as the constructor\", background1, background2);\n+        assertEquals(background1, background2, \"The factory method should give the same result as the constructor\");\n@@ -729,1 +735,87 @@\n-        assertEquals(\"The factory method should give the same result as the constructor\", background1, background2);\n+        assertEquals(background1, background2, \"The factory method should give the same result as the constructor\");\n+    }\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new Background(\n+                List.of(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)),\n+                        new BackgroundFill(Color.BLUE, new CornerRadii(2), new Insets(2))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 5, false),\n+                                            new BackgroundSize(10, 10, false, false, false, false))));\n+\n+            var endValue = new Background(\n+                List.of(new BackgroundFill(Color.GREEN, new CornerRadii(20), new Insets(20)),\n+                        new BackgroundFill(Color.YELLOW, new CornerRadii(6), new Insets(6))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 20, false, Side.TOP, 15, false),\n+                                            new BackgroundSize(20, 30, false, false, false, false))));\n+\n+            var expect = new Background(\n+                List.of(new BackgroundFill(Color.RED.interpolate(Color.GREEN, 0.5), new CornerRadii(15), new Insets(15)),\n+                        new BackgroundFill(Color.BLUE.interpolate(Color.YELLOW, 0.5), new CornerRadii(4), new Insets(4))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 15, false, Side.TOP, 10, false),\n+                                            new BackgroundSize(15, 20, false, false, false, false))));\n+\n+            var actual = startValue.interpolate(endValue, 0.5);\n+\n+            assertEquals(expect, actual);\n+            assertNotSame(expect, actual);\n+        }\n+\n+        @Test\n+        public void interpolateBetweenDifferentNumberOfFillsAndImages() {\n+            var startValue = new Background(\n+                List.of(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 5, false),\n+                                            new BackgroundSize(10, 10, false, false, false, false))));\n+\n+            var endValue = new Background(\n+                List.of(new BackgroundFill(Color.GREEN, new CornerRadii(20), new Insets(20)),\n+                        new BackgroundFill(Color.BLUE, new CornerRadii(2), new Insets(2))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 20, false, Side.TOP, 15, false),\n+                                            new BackgroundSize(20, 30, false, false, false, false)),\n+                        new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 30, false, Side.TOP, 40, false),\n+                                            new BackgroundSize(50, 60, false, false, false, false))));\n+\n+            var expect = new Background(\n+                List.of(new BackgroundFill(Color.RED.interpolate(Color.GREEN, 0.5), new CornerRadii(15), new Insets(15)),\n+                        new BackgroundFill(Color.BLUE, new CornerRadii(2), new Insets(2))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 15, false, Side.TOP, 10, false),\n+                                            new BackgroundSize(15, 20, false, false, false, false)),\n+                        new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 30, false, Side.TOP, 40, false),\n+                                            new BackgroundSize(50, 60, false, false, false, false))));\n+\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var startValue = new Background(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)));\n+            var endValue = new Background(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new Background(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)));\n+            var endValue = new Background(new BackgroundFill(Color.GREEN, new CornerRadii(15), new Insets(20)));\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new Background(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)));\n+            var endValue = new Background(new BackgroundFill(Color.GREEN, new CornerRadii(15), new Insets(20)));\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundTest.java","additions":102,"deletions":10,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.layout;\n+\n+import javafx.geometry.Insets;\n+import javafx.scene.image.Image;\n+import javafx.scene.layout.BorderImage;\n+import javafx.scene.layout.BorderRepeat;\n+import javafx.scene.layout.BorderWidths;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class BorderImageTest {\n+\n+    private static final Image IMAGE_1 = new Image(\"test\/javafx\/scene\/layout\/red.png\");\n+    private static final Image IMAGE_2 = new Image(\"test\/javafx\/scene\/layout\/blue.png\");\n+\n+    @Nested\n+    class InterpolationTests {\n+        final BorderImage BORDER_IMAGE_A = new BorderImage(\n+            IMAGE_1, new BorderWidths(10), new Insets(8), new BorderWidths(6),\n+            false, BorderRepeat.REPEAT, BorderRepeat.REPEAT);\n+\n+        final BorderImage BORDER_IMAGE_B = new BorderImage(\n+            IMAGE_2, new BorderWidths(20), new Insets(4), new BorderWidths(12),\n+            false, BorderRepeat.REPEAT, BorderRepeat.REPEAT);\n+\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var image = new BorderImage(\n+                IMAGE_2, new BorderWidths(15), new Insets(6), new BorderWidths(9),\n+                false, BorderRepeat.REPEAT, BorderRepeat.REPEAT);\n+\n+            assertEquals(image, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var image = new BorderImage(\n+                IMAGE_1, new BorderWidths(10), new Insets(8), new BorderWidths(6),\n+                false, BorderRepeat.REPEAT, BorderRepeat.REPEAT);\n+\n+            assertSame(image, image.interpolate(BORDER_IMAGE_A, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            assertSame(BORDER_IMAGE_A, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, 0));\n+            assertSame(BORDER_IMAGE_A, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            assertSame(BORDER_IMAGE_B, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, 1));\n+            assertSame(BORDER_IMAGE_B, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, 1.5));\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BorderImageTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,10 @@\n-import org.junit.Test;\n+import javafx.geometry.Insets;\n+import javafx.scene.layout.BorderStroke;\n+import javafx.scene.layout.BorderWidths;\n+import javafx.scene.layout.CornerRadii;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static javafx.scene.layout.BorderStrokeStyle.*;\n+import static javafx.scene.paint.Color.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -36,0 +45,34 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            var endValue = new BorderStroke(GREEN, DOTTED, new CornerRadii(20), new BorderWidths(15), new Insets(6));\n+            var expect = new BorderStroke(RED.interpolate(GREEN, 0.5), DOTTED, new CornerRadii(15), new BorderWidths(10), new Insets(4));\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var startValue = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            var endValue = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            var endValue = new BorderStroke(GREEN, SOLID, new CornerRadii(20), new BorderWidths(15), new Insets(6));\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            var endValue = new BorderStroke(GREEN, SOLID, new CornerRadii(20), new BorderWidths(15), new Insets(6));\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BorderStrokeTest.java","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.List;\n@@ -39,1 +40,2 @@\n-import org.junit.Test;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -42,1 +44,1 @@\n-import static org.junit.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -237,1 +239,1 @@\n-    @Test(expected = UnsupportedOperationException.class)\n+    @Test\n@@ -242,1 +244,2 @@\n-        b.getStrokes().add(new BorderStroke(Color.BLUE, BorderStrokeStyle.SOLID, new CornerRadii(6), new BorderWidths(8)));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+            b.getStrokes().add(new BorderStroke(Color.BLUE, BorderStrokeStyle.SOLID, new CornerRadii(6), new BorderWidths(8))));\n@@ -245,1 +248,1 @@\n-    @Test(expected = UnsupportedOperationException.class)\n+    @Test\n@@ -251,4 +254,5 @@\n-        b.getImages().add(\n-                new BorderImage(\n-                        IMAGE_4, new BorderWidths(3), Insets.EMPTY,\n-                        new BorderWidths(3, 4, 5, 6), true, STRETCH, SPACE));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+            b.getImages().add(\n+                    new BorderImage(\n+                            IMAGE_4, new BorderWidths(3), Insets.EMPTY,\n+                            new BorderWidths(3, 4, 5, 6), true, STRETCH, SPACE)));\n@@ -570,1 +574,1 @@\n-        assertEquals(\"The factory method should give the same result as the constructor\", border2, border1);\n+        assertEquals(border2, border1, \"The factory method should give the same result as the constructor\");\n@@ -577,1 +581,71 @@\n-        assertEquals(\"The factory method should give the same result as the constructor\", border2, border1);\n+        assertEquals(border2, border1, \"The factory method should give the same result as the constructor\");\n+    }\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new Border(\n+                List.of(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)),\n+                        new BorderStroke(Color.BLUE, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20))),\n+                List.of(new BorderImage(IMAGE_1, new BorderWidths(10), new Insets(5), new BorderWidths(10), false, REPEAT, REPEAT)));\n+\n+            var endValue = new Border(\n+                List.of(new BorderStroke(Color.GREEN, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20)),\n+                        new BorderStroke(Color.YELLOW, BorderStrokeStyle.SOLID, new CornerRadii(40), new BorderWidths(40))),\n+                List.of(new BorderImage(IMAGE_2, new BorderWidths(30), new Insets(15), new BorderWidths(30), false, REPEAT, REPEAT)));\n+\n+            var expect = new Border(\n+                List.of(new BorderStroke(Color.RED.interpolate(Color.GREEN, 0.5), BorderStrokeStyle.SOLID, new CornerRadii(15), new BorderWidths(15)),\n+                        new BorderStroke(Color.BLUE.interpolate(Color.YELLOW, 0.5), BorderStrokeStyle.SOLID, new CornerRadii(30), new BorderWidths(30))),\n+                List.of(new BorderImage(IMAGE_2, new BorderWidths(20), new Insets(10), new BorderWidths(20), false, REPEAT, REPEAT)));\n+\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenDifferentNumberOfStrokesAndImages() {\n+            var startValue = new Border(\n+                List.of(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10))),\n+                List.of(new BorderImage(IMAGE_1, new BorderWidths(10), new Insets(5), new BorderWidths(10), false, REPEAT, REPEAT)));\n+\n+            var endValue = new Border(\n+                List.of(new BorderStroke(Color.GREEN, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20)),\n+                        new BorderStroke(Color.YELLOW, BorderStrokeStyle.SOLID, new CornerRadii(40), new BorderWidths(40))),\n+                List.of(new BorderImage(IMAGE_1, new BorderWidths(30), new Insets(15), new BorderWidths(30), false, REPEAT, REPEAT),\n+                        new BorderImage(IMAGE_2, new BorderWidths(30), new Insets(15), new BorderWidths(30), false, REPEAT, REPEAT)));\n+\n+            var expect = new Border(\n+                List.of(new BorderStroke(Color.RED.interpolate(Color.GREEN, 0.5), BorderStrokeStyle.SOLID, new CornerRadii(15), new BorderWidths(15)),\n+                        new BorderStroke(Color.YELLOW, BorderStrokeStyle.SOLID, new CornerRadii(40), new BorderWidths(40))),\n+                List.of(new BorderImage(IMAGE_1, new BorderWidths(20), new Insets(10), new BorderWidths(20), false, REPEAT, REPEAT),\n+                        new BorderImage(IMAGE_2, new BorderWidths(30), new Insets(15), new BorderWidths(30), false, REPEAT, REPEAT)));\n+\n+            var actual = startValue.interpolate(endValue, 0.5);\n+\n+            assertEquals(expect, actual);\n+            assertNotSame(expect, actual);\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var startValue = new Border(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)));\n+            var endValue = new Border(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new Border(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)));\n+            var endValue = new Border(new BorderStroke(Color.GREEN, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20)));\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new Border(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)));\n+            var endValue = new Border(new BorderStroke(Color.GREEN, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20)));\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BorderTest.java","additions":86,"deletions":12,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n-import org.junit.Test;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -31,1 +32,1 @@\n-import static org.junit.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -98,1 +99,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -100,1 +101,1 @@\n-        new BorderWidths(-2);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(-2));\n@@ -103,1 +104,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -105,1 +106,1 @@\n-        new BorderWidths(-2, 0, 0, 0, false, false, false, false);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(-2, 0, 0, 0, false, false, false, false));\n@@ -108,1 +109,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -110,1 +111,1 @@\n-        new BorderWidths(-2, 0, 0, 0);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(-2, 0, 0, 0));\n@@ -113,1 +114,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -115,1 +116,1 @@\n-        new BorderWidths(0, -2, 0, 0, false, false, false, false);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(0, -2, 0, 0, false, false, false, false));\n@@ -118,1 +119,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -120,1 +121,1 @@\n-        new BorderWidths(0, -2, 0, 0);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(0, -2, 0, 0));\n@@ -123,1 +124,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -125,1 +126,1 @@\n-        new BorderWidths(0, 0, -2, 0, false, false, false, false);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(0, 0, -2, 0, false, false, false, false));\n@@ -128,1 +129,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -130,1 +131,1 @@\n-        new BorderWidths(0, 0, -2, 0);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(0, 0, -2, 0));\n@@ -133,1 +134,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -135,1 +136,1 @@\n-        new BorderWidths(0, 0, 0, -2, false, false, false, false);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(0, 0, 0, -2, false, false, false, false));\n@@ -138,1 +139,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -140,1 +141,1 @@\n-        new BorderWidths(0, 0, 0, -2);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(0, 0, 0, -2));\n@@ -209,0 +210,97 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateComponentWithAbsoluteAndPercentageMismatch() {\n+            record TestCase(BorderWidths endValue, BorderWidths expected) {}\n+\n+            final double v0 = 10, v25 = 12.5, v50 = 15, v100 = 20;\n+            final var startValue = new BorderWidths(v0, v0, v0, v0, false, false, false, false);\n+\n+            \/\/ For each component: interpolation with t=0.25 returns start value on absolute\/percentage mismatch\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, false, false, false),\n+                    new BorderWidths(v25, v25, v25, v25, false, false, false, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, true, false, false, false),\n+                    new BorderWidths(v0, v25, v25, v25, false, false, false, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, true, false, false),\n+                    new BorderWidths(v25, v0, v25, v25, false, false, false, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, false, true, false),\n+                    new BorderWidths(v25, v25, v0, v25, false, false, false, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, false, false, true),\n+                    new BorderWidths(v25, v25, v25, v0, false, false, false, false))\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.25));\n+            }\n+\n+            \/\/ For each component: interpolation with t=0.5 returns end value on absolute\/percentage mismatch\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, false, false, false),\n+                    new BorderWidths(v50, v50, v50, v50, false, false, false, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, true, false, false, false),\n+                    new BorderWidths(v100, v50, v50, v50, true, false, false, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, true, false, false),\n+                    new BorderWidths(v50, v100, v50, v50, false, true, false, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, false, true, false),\n+                    new BorderWidths(v50, v50, v100, v50, false, false, true, false)),\n+                new TestCase(\n+                    new BorderWidths(v100, v100, v100, v100, false, false, false, true),\n+                    new BorderWidths(v50, v50, v50, v100, false, false, false, true))\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.5));\n+            }\n+        }\n+\n+        @Test\n+        public void interpolateReturnsStartOrEndInstanceWhenResultIsEqual() {\n+            var startValue = new BorderWidths(10, 20, 30, 40, true, true, true, true);\n+            var endValue = new BorderWidths(20, 40, 60, 80, false, false, false, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            var endValue = new BorderWidths(20, 40, 60, 80, true, false, true, false);\n+            var expect = new BorderWidths(15, 30, 45, 60, true, false, true, false);\n+            var actual = startValue.interpolate(endValue, 0.5);\n+            assertEquals(expect, actual);\n+            assertNotSame(startValue, actual);\n+            assertNotSame(endValue, actual);\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var startValue = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            var endValue = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.75));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            var endValue = new BorderWidths(20, 40, 60, 80, true, false, true, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            var endValue = new BorderWidths(20, 40, 60, 80, true, false, true, false);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BorderWidthsTest.java","additions":119,"deletions":21,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,31 @@\n+    @Test\n+    public void equality() {\n+        for (int i = 0; i < 8; ++i) {\n+            double[] r = new double[8];\n+            boolean[] p = new boolean[8];\n+\n+            r[i] = 1;\n+            p[i] = true;\n+\n+            var expected = new CornerRadii(\n+                r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7],\n+                p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);\n+\n+            var a = new CornerRadii(\n+                r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7],\n+                p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);\n+\n+            assertEquals(expected, a);\n+\n+            \/\/ change one radius at a time\n+            r[i] = 0;\n+            p[i] = false;\n+\n+            var b = new CornerRadii(\n+                r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7],\n+                p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);\n+\n+            assertNotEquals(expected, b);\n+        }\n+    }\n+\n@@ -126,0 +157,141 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateComponentWithAbsoluteAndPercentageMismatch() {\n+            record TestCase(CornerRadii endValue, CornerRadii expected) {}\n+\n+            final double v0 = 10, v25 = 12.5, v50 = 15, v100 = 20;\n+            final var startValue = new CornerRadii(\n+                v0, v0, v0, v0, v0, v0, v0, v0, false, false, false, false, false, false, false, false);\n+\n+            \/\/ For each component: interpolation with t=0.25 returns start value on absolute\/percentage mismatch.\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, false, false, false),\n+                    new CornerRadii(v25, v25, v25, v25, v25, v25, v25, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, true, false, false, false, false, false, false, false),\n+                    new CornerRadii(v0, v25, v25, v25, v25, v25, v25, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, true, false, false, false, false, false, false),\n+                    new CornerRadii(v25, v0, v25, v25, v25, v25, v25, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, true, false, false, false, false, false),\n+                    new CornerRadii(v25, v25, v0, v25, v25, v25, v25, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, true, false, false, false, false),\n+                    new CornerRadii(v25, v25, v25, v0, v25, v25, v25, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, true, false, false, false),\n+                    new CornerRadii(v25, v25, v25, v25, v0, v25, v25, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, true, false, false),\n+                    new CornerRadii(v25, v25, v25, v25, v25, v0, v25, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, false, true, false),\n+                    new CornerRadii(v25, v25, v25, v25, v25, v25, v0, v25, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, false, false, true),\n+                    new CornerRadii(v25, v25, v25, v25, v25, v25, v25, v0, false, false, false, false, false, false, false, false)),\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.25));\n+            }\n+\n+            \/\/ For each component: interpolation with t=0.5 returns end value on absolute\/percentage mismatch\n+            for (var testCase : new TestCase[] {\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, false, false, false),\n+                    new CornerRadii(v50, v50, v50, v50, v50, v50, v50, v50, false, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, true, false, false, false, false, false, false, false),\n+                    new CornerRadii(v100, v50, v50, v50, v50, v50, v50, v50, true, false, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, true, false, false, false, false, false, false),\n+                    new CornerRadii(v50, v100, v50, v50, v50, v50, v50, v50, false, true, false, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, true, false, false, false, false, false),\n+                    new CornerRadii(v50, v50, v100, v50, v50, v50, v50, v50, false, false, true, false, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, true, false, false, false, false),\n+                    new CornerRadii(v50, v50, v50, v100, v50, v50, v50, v50, false, false, false, true, false, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, true, false, false, false),\n+                    new CornerRadii(v50, v50, v50, v50, v100, v50, v50, v50, false, false, false, false, true, false, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, true, false, false),\n+                    new CornerRadii(v50, v50, v50, v50, v50, v100, v50, v50, false, false, false, false, false, true, false, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, false, true, false),\n+                    new CornerRadii(v50, v50, v50, v50, v50, v50, v100, v50, false, false, false, false, false, false, true, false)),\n+                new TestCase(\n+                    new CornerRadii(v100, v100, v100, v100, v100, v100, v100, v100, false, false, false, false, false, false, false, true),\n+                    new CornerRadii(v50, v50, v50, v50, v50, v50, v50, v100, false, false, false, false, false, false, false, true)),\n+            }) {\n+                assertEquals(testCase.expected, startValue.interpolate(testCase.endValue, 0.5));\n+            }\n+        }\n+\n+        @Test\n+        public void interpolateReturnsStartOrEndInstanceWhenResultIsEqual() {\n+            \/\/ non-uniform values\n+            var startValue = new CornerRadii(10, 20, 30, 40, true);\n+            var endValue = new CornerRadii(20, 40, 60, 80, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+\n+            \/\/ uniform values\n+            startValue = new CornerRadii(10, true);\n+            endValue = new CornerRadii(20, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            \/\/ non-uniform values\n+            var startValue = new CornerRadii(10, 20, 30, 40, false);\n+            var endValue = new CornerRadii(20, 40, 60, 80, false);\n+            var expect = new CornerRadii(15, 30, 45, 60, false);\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+\n+            \/\/ uniform values\n+            startValue = new CornerRadii(10, 10, 10, 10, false);\n+            endValue = new CornerRadii(20, 20, 20, 20, false);\n+            expect = new CornerRadii(15, 15, 15, 15, false);\n+            assertEquals(expect, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            \/\/ non-uniform values\n+            var startValue = new CornerRadii(10, 20, 30, 40, false);\n+            var endValue = new CornerRadii(10, 20, 30, 40, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.75));\n+\n+            \/\/ uniform values\n+            startValue = new CornerRadii(10, 10, 10, 10, false);\n+            endValue = new CornerRadii(10, 10, 10, 10, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+            assertSame(startValue, startValue.interpolate(endValue, 0.75));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new CornerRadii(10, 20, 30, 40, false);\n+            var endValue = new CornerRadii(20, 30, 40, 50, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new CornerRadii(10, 20, 30, 40, false);\n+            var endValue = new CornerRadii(20, 30, 40, 50, false);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/CornerRadiiTest.java","additions":173,"deletions":1,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,5 +34,4 @@\n-import org.junit.Test;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -358,1 +357,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -360,1 +359,1 @@\n-        Color.web(\"#aabbccddee\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"#aabbccddee\"));\n@@ -363,1 +362,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -365,1 +364,1 @@\n-        Color.web(null);\n+        assertThrows(NullPointerException.class, () -> Color.web(null));\n@@ -368,1 +367,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -370,1 +369,1 @@\n-        Color.web(\"\", 0.5);\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"\", 0.5));\n@@ -390,1 +389,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -392,1 +391,1 @@\n-        Color.web(\"0xaabbccddee\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"0xaabbccddee\"));\n@@ -429,1 +428,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -431,1 +430,1 @@\n-        Color.web(\"foobar\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"foobar\"));\n@@ -656,1 +655,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -658,1 +657,1 @@\n-        Color.web(\"rgb(100, 100)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgb(100, 100)\"));\n@@ -661,1 +660,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -663,1 +662,1 @@\n-        Color.web(\"rgb(100)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgb(100)\"));\n@@ -666,1 +665,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -668,1 +667,1 @@\n-        Color.web(\"rgb()\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgb()\"));\n@@ -671,1 +670,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -673,1 +672,1 @@\n-        Color.web(\"rgb 100, 100, 100\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgb 100, 100, 100\"));\n@@ -676,1 +675,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -678,1 +677,1 @@\n-        Color.web(\"rgb(100, 100, 100\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgb(100, 100, 100\"));\n@@ -681,1 +680,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -683,1 +682,1 @@\n-        Color.web(\"rgba(100, 100, 100)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgba(100, 100, 100)\"));\n@@ -686,1 +685,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -688,1 +687,1 @@\n-        Color.web(\"rgba(100, 100)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgba(100, 100)\"));\n@@ -691,1 +690,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -693,1 +692,1 @@\n-        Color.web(\"rgba(100)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgba(100)\"));\n@@ -696,1 +695,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -698,1 +697,1 @@\n-        Color.web(\"rgba()\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgba()\"));\n@@ -701,1 +700,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -703,1 +702,1 @@\n-        Color.web(\"rgba 100, 100, 100\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgba 100, 100, 100\"));\n@@ -706,1 +705,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -708,1 +707,1 @@\n-        Color.web(\"rgba(100, 100, 100, 0.5\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgba(100, 100, 100, 0.5\"));\n@@ -711,1 +710,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -713,1 +712,1 @@\n-        Color.web(\"hsl(240, 50%)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsl(240, 50%)\"));\n@@ -716,1 +715,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -718,1 +717,1 @@\n-        Color.web(\"hsl(240)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsl(240)\"));\n@@ -721,1 +720,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -723,1 +722,1 @@\n-        Color.web(\"hsl()\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsl()\"));\n@@ -726,1 +725,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -728,1 +727,1 @@\n-        Color.web(\"hsl 240, 50%, 50%\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsl 240, 50%, 50%\"));\n@@ -731,1 +730,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -733,1 +732,1 @@\n-        Color.web(\"hsl(240, 50%, 50%\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsl(240, 50%, 50%\"));\n@@ -736,1 +735,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -738,1 +737,1 @@\n-        Color.web(\"hsla(240, 50%, 50%)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsla(240, 50%, 50%)\"));\n@@ -741,1 +740,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -743,1 +742,1 @@\n-        Color.web(\"hsla(240, 50%)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsla(240, 50%)\"));\n@@ -746,1 +745,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -748,1 +747,1 @@\n-        Color.web(\"hsla(240)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsla(240)\"));\n@@ -751,1 +750,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -753,1 +752,1 @@\n-        Color.web(\"hsla()\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsla()\"));\n@@ -756,1 +755,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -758,1 +757,1 @@\n-        Color.web(\"hsla 240, 50%, 50%, 0.5\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsla 240, 50%, 50%, 0.5\"));\n@@ -761,1 +760,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -763,1 +762,1 @@\n-        Color.web(\"hsla(240, 50%, 50%, 0.5\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsla(240, 50%, 50%, 0.5\"));\n@@ -951,0 +950,33 @@\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenTwoDifferentValuesReturnsNewInstance() {\n+            var startValue = new Color(0.2, 0.4, 0.6, 0.8);\n+            var endValue = new Color(0.3, 0.5, 0.7, 0.9);\n+            assertEquals(new Color(0.25, 0.45, 0.65, 0.85), startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsSameInstance() {\n+            var startValue = new Color(0.2, 0.4, 0.6, 0.8);\n+            var endValue = new Color(0.2, 0.4, 0.6, 0.8);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new Color(0.2, 0.4, 0.6, 0.8);\n+            var endValue = new Color(0.3, 0.5, 0.7, 0.9);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new Color(0.2, 0.4, 0.6, 0.8);\n+            var endValue = new Color(0.3, 0.5, 0.7, 0.9);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/ColorTest.java","additions":92,"deletions":60,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,5 +28,0 @@\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n@@ -35,3 +30,2 @@\n-\n-import org.junit.Test;\n-\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -43,0 +37,2 @@\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -93,1 +89,46 @@\n-\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var image = createImage();\n+            var startValue = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var endValue = new ImagePattern(image, 20, 30, 40, 50, false);\n+            var expected = new ImagePattern(image, 15, 25, 35, 45, false);\n+            assertEquals(expected, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenProportionalAndNonProportionalReturnsStartInstanceOrEndInstance() {\n+            var image = createImage();\n+            var startValue = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var endValue = new ImagePattern(image, 20, 30, 40, 50, true);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsStartInstance() {\n+            var image = createImage();\n+            var startValue = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var endValue = new ImagePattern(image, 10, 20, 30, 40, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var image = createImage();\n+            var startValue = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var endValue = new ImagePattern(image, 20, 30, 40, 50, false);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var image = createImage();\n+            var startValue = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var endValue = new ImagePattern(image, 20, 30, 40, 50, false);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/ImagePatternTest.java","additions":51,"deletions":10,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,7 +37,4 @@\n-import org.junit.Test;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -84,1 +81,1 @@\n-    @Test(expected=UnsupportedOperationException.class)\n+    @Test\n@@ -90,1 +87,1 @@\n-        returned.set(0, stop2);\n+        assertThrows(UnsupportedOperationException.class, () -> returned.set(0, stop2));\n@@ -190,1 +187,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -192,1 +189,1 @@\n-        LinearGradient.valueOf(null);\n+        assertThrows(NullPointerException.class, () -> LinearGradient.valueOf(null));\n@@ -195,1 +192,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -197,1 +194,1 @@\n-        LinearGradient.valueOf(\"\");\n+        assertThrows(IllegalArgumentException.class, () -> LinearGradient.valueOf(\"\"));\n@@ -463,0 +460,87 @@\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLACK), new Stop(1, Color.WHITE)));\n+\n+            var endValue = new LinearGradient(\n+                20, 40, 60, 80,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.WHITE), new Stop(1, Color.BLACK)));\n+\n+            var expected = new LinearGradient(\n+                15, 30, 45, 60,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.gray(0.5)), new Stop(1, Color.gray(0.5))));\n+\n+            assertEquals(expected, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenProportionalAndNonProportionalReturnsStartValuesOrEndValues() {\n+            var startValue = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new LinearGradient(\n+                10, 20, 30, 40,\n+                false, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.75));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsStartInstance() {\n+            var startValue = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new LinearGradient(\n+                20, 40, 60, 80,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.RED)));\n+\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new LinearGradient(\n+                20, 40, 60, 80,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.RED)));\n+\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/LinearGradientTest.java","additions":98,"deletions":14,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.paint;\n+\n+import com.sun.javafx.scene.paint.PaintUtils;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.CycleMethod;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.RadialGradient;\n+import javafx.scene.paint.Stop;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class PaintUtilsTest {\n+\n+    @Nested\n+    class InterpolateColorTest {\n+        @Test\n+        void toLinearGradient() {\n+            var paint = PaintUtils.interpolate(\n+                Color.BLUE,\n+                new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, Color.RED), new Stop(1, Color.GREEN)),\n+                0.5);\n+\n+            var expected = new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                              new Stop(0, Color.BLUE.interpolate(Color.RED, 0.5)),\n+                                              new Stop(1, Color.BLUE.interpolate(Color.GREEN, 0.5)));\n+\n+            assertEquals(expected, paint);\n+        }\n+\n+        @Test\n+        void toRadialGradient() {\n+            var paint = PaintUtils.interpolate(\n+                Color.BLUE,\n+                new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, Color.RED), new Stop(1, Color.GREEN)),\n+                0.5);\n+\n+            var expected = new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                              new Stop(0, Color.BLUE.interpolate(Color.RED, 0.5)),\n+                                              new Stop(1, Color.BLUE.interpolate(Color.GREEN, 0.5)));\n+\n+            assertEquals(expected, paint);\n+        }\n+    }\n+\n+    @Nested\n+    class InterpolateLinearGradientTest {\n+        @Test\n+        void toColor() {\n+            var paint = PaintUtils.interpolate(\n+                new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, Color.RED), new Stop(1, Color.GREEN)),\n+                Color.BLUE,\n+                0.5);\n+\n+            var expected = new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                              new Stop(0, Color.RED.interpolate(Color.BLUE, 0.5)),\n+                                              new Stop(1, Color.GREEN.interpolate(Color.BLUE, 0.5)));\n+\n+            assertEquals(expected, paint);\n+        }\n+\n+        @Test\n+        void toRadialGradient() {\n+            var toPaint = new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                             new Stop(0, Color.RED), new Stop(1, Color.GREEN));\n+\n+            var actual = PaintUtils.interpolate(\n+                new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, Color.RED), new Stop(1, Color.GREEN)),\n+                toPaint,\n+                0.5);\n+\n+            assertSame(actual, toPaint);\n+        }\n+    }\n+\n+    @Nested\n+    class InterpolateRadialGradientTest {\n+        @Test\n+        void toColor() {\n+            var paint = PaintUtils.interpolate(\n+                new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, Color.RED), new Stop(1, Color.GREEN)),\n+                Color.BLUE,\n+                0.5);\n+\n+            var expected = new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                              new Stop(0, Color.RED.interpolate(Color.BLUE, 0.5)),\n+                                              new Stop(1, Color.GREEN.interpolate(Color.BLUE, 0.5)));\n+\n+            assertEquals(expected, paint);\n+        }\n+\n+        @Test\n+        void toLinearGradient() {\n+            var toPaint = new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                             new Stop(0, Color.RED), new Stop(1, Color.GREEN));\n+\n+            var actual = PaintUtils.interpolate(\n+                new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, Color.RED), new Stop(1, Color.GREEN)),\n+                toPaint,\n+                0.5);\n+\n+            assertSame(actual, toPaint);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/PaintUtilsTest.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,7 +37,4 @@\n-import org.junit.Test;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -85,1 +82,1 @@\n-    @Test(expected=UnsupportedOperationException.class)\n+    @Test\n@@ -91,1 +88,1 @@\n-        returned.set(0, stop2);\n+        assertThrows(UnsupportedOperationException.class, () -> returned.set(0, stop2));\n@@ -213,1 +210,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -215,1 +212,1 @@\n-        RadialGradient.valueOf(null);\n+        assertThrows(NullPointerException.class, () -> RadialGradient.valueOf(null));\n@@ -218,1 +215,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -220,1 +217,1 @@\n-        RadialGradient.valueOf(\"\");\n+        assertThrows(IllegalArgumentException.class, () -> RadialGradient.valueOf(\"\"));\n@@ -491,0 +488,87 @@\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var startValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLACK), new Stop(1, Color.WHITE)));\n+\n+            var endValue = new RadialGradient(\n+                20, 40, 60, 80, 100,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.WHITE), new Stop(1, Color.BLACK)));\n+\n+            var expected = new RadialGradient(\n+                15, 30, 45, 60, 75,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.gray(0.5)), new Stop(1, Color.gray(0.5))));\n+\n+            assertEquals(expected, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenProportionalAndNonProportionalReturnsStartInstanceOrEndInstance() {\n+            var startValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                false, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            assertSame(startValue, startValue.interpolate(endValue, 0.25));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.5));\n+            assertSame(endValue, startValue.interpolate(endValue, 0.75));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsStartInstance() {\n+            var startValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.RED)));\n+\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var endValue = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.RED)));\n+\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/RadialGradientTest.java","additions":98,"deletions":14,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import static org.junit.Assert.assertEquals;\n-\n@@ -37,0 +35,3 @@\n+import javafx.scene.paint.StopShim;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -38,1 +39,1 @@\n-import org.junit.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -154,0 +155,130 @@\n+\n+    @Test\n+    public void testInterpolateStop() {\n+        assertSame(zerostop, zerostop.interpolate(onestop, -0.5));\n+        assertSame(zerostop, zerostop.interpolate(onestop, 0));\n+        assertSame(onestop, zerostop.interpolate(onestop, 1));\n+        assertSame(onestop, zerostop.interpolate(onestop, 1.5));\n+        assertEquals(new Stop(0.5, color2), zerostop.interpolate(onestop, 0.5));\n+    }\n+\n+    @Nested\n+    class ListInterpolationTest {\n+        @Test\n+        public void returnFirstListBeforeInterval() {\n+            var firstList = List.of(new Stop(0, color1), new Stop(1, color3));\n+            var secondList = List.of(new Stop(0, color3), new Stop(1, color1));\n+            assertSame(firstList, StopShim.interpolateLists(firstList, secondList, 0));\n+            assertSame(firstList, StopShim.interpolateLists(firstList, secondList, -0.5));\n+        }\n+\n+        @Test\n+        public void returnSecondListAfterInterval() {\n+            var firstList = List.of(new Stop(0, color1), new Stop(1, color3));\n+            var secondList = List.of(new Stop(0, color3), new Stop(1, color1));\n+            assertSame(secondList, StopShim.interpolateLists(firstList, secondList, 1));\n+            assertSame(secondList, StopShim.interpolateLists(firstList, secondList, 1.5));\n+        }\n+\n+        @Test\n+        public void sameSize_sameOffsets() {\n+            var firstList = List.of(new Stop(0, color1), new Stop(1, color3));\n+            var secondList = List.of(new Stop(0, color3), new Stop(1, color1));\n+            var res = StopShim.interpolateLists(firstList, secondList, 0.5);\n+            assertEquals(List.of(\n+                new Stop(0, color2),\n+                new Stop(1, color2)),\n+            res);\n+        }\n+\n+        @Test\n+        public void sameSize_differentOffsets() {\n+            double t = 0.5;\n+            var firstList = normalize(List.of(new Stop(0.1, color1), new Stop(0.9, color3)));\n+            var secondList = normalize(List.of(new Stop(0.2, color3), new Stop(0.8, color1)));\n+            var res = StopShim.interpolateLists(firstList, secondList, t);\n+            assertEquals(List.of(\n+                new Stop(0, color2),\n+                new Stop(0.1, color2),\n+                new Stop(0.2, color1.interpolate(color3, 0.125).interpolate(color3, t)),\n+                new Stop(0.8, color1.interpolate(color3, 0.875).interpolate(color1, t)),\n+                new Stop(0.9, color2),\n+                new Stop(1, color2)),\n+            res);\n+        }\n+\n+        @Test\n+        public void firstListLargerThanSecondList_sameFirstAndLastOffset() {\n+            var firstList = normalize(List.of(new Stop(0, color1), new Stop(0.5, color3), new Stop(1, color1)));\n+            var secondList = normalize(List.of(new Stop(0, color1), new Stop(1, color3)));\n+\n+            var expected = List.of(\n+                new Stop(0, color1),\n+                new Stop(0.5, color2.interpolate(color3, 0.5)),\n+                new Stop(1, color2));\n+            assertEquals(expected, StopShim.interpolateLists(firstList, secondList, 0.5));\n+\n+            \/\/ An interpolation factor close to zero should yield a stop list very similar to the first list\n+            expected = firstList;\n+            assertSimilar(expected, StopShim.interpolateLists(firstList, secondList, 0.001));\n+\n+            \/\/ An interpolation factor close to one should yield a stop list very similar to the second list,\n+            \/\/ but with a different number of stops (3 instead of 2).\n+            expected = List.of(new Stop(0, color1), new Stop(0.5, color2), new Stop(1, color3));\n+            assertSimilar(expected, StopShim.interpolateLists(firstList, secondList, 0.999));\n+        }\n+\n+        @Test\n+        public void firstListSmallerThanSecondList_sameFirstAndLastOffset() {\n+            var firstList = normalize(List.of(new Stop(0, color1), new Stop(1, color3)));\n+            var secondList = normalize(List.of(new Stop(0, color1), new Stop(0.5, color3), new Stop(1, color1)));\n+\n+            var expected = List.of(\n+                new Stop(0, color1),\n+                new Stop(0.5, color2.interpolate(color3, 0.5)),\n+                new Stop(1, color2));\n+            assertEquals(expected, StopShim.interpolateLists(firstList, secondList, 0.5));\n+\n+            \/\/ An interpolation factor close to zero should yield a stop list very similar to the first list,\n+            \/\/ but with a different number of stops (3 instead of 2).\n+            expected = List.of( new Stop(0, color1), new Stop(0.5, color2), new Stop(1, color3));\n+            assertSimilar(expected, StopShim.interpolateLists(firstList, secondList, 0.001));\n+\n+            \/\/ An interpolation factor close to one should yield a stop list very similar to the second list.\n+            expected = secondList;\n+            assertSimilar(expected, StopShim.interpolateLists(firstList, secondList, 0.999));\n+        }\n+\n+        @Test\n+        public void differentSize_differentOffsets() {\n+            double t = 0.5;\n+            var firstList = normalize(List.of(new Stop(0, color1), new Stop(1, color3)));\n+            var secondList = normalize(List.of(new Stop(0.25, color3), new Stop(0.75, color1)));\n+            var res = StopShim.interpolateLists(firstList, secondList, t);\n+            assertEquals(List.of(\n+                new Stop(0, color2),\n+                new Stop(0.25, color1.interpolate(color3, 0.25).interpolate(color3, t)),\n+                new Stop(0.75, color1.interpolate(color3, 0.75).interpolate(color1, t)),\n+                new Stop(1, color2)),\n+            res);\n+        }\n+\n+        private void assertSimilar(List<Stop> a, List<Stop> b) {\n+            assertEquals(a.size(), b.size());\n+            for (int i = 0; i < a.size(); ++i) {\n+                assertSimilar(a.get(i), b.get(i));\n+            }\n+        }\n+\n+        private void assertSimilar(Stop a, Stop b) {\n+            assertSimilar(a.getColor(), b.getColor());\n+            assertTrue(Math.abs(a.getOffset() - b.getOffset()) < 0.1);\n+        }\n+\n+        private void assertSimilar(Color a, Color b) {\n+            assertTrue(Math.abs(a.getRed() - b.getRed()) < 0.01);\n+            assertTrue(Math.abs(a.getGreen() - b.getGreen()) < 0.01);\n+            assertTrue(Math.abs(a.getBlue() - b.getBlue()) < 0.01);\n+            assertTrue(Math.abs(a.getOpacity() - b.getOpacity()) < 0.01);\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/StopListTest.java","additions":135,"deletions":4,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,4 +30,2 @@\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -35,1 +33,2 @@\n-import org.junit.Test;\n+import static javafx.scene.paint.Color.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -50,0 +49,6 @@\n+    @Test\n+    public void testNullColorIsTransparent() {\n+        var stop = new Stop(0.2f, null);\n+        assertEquals(TRANSPARENT, stop.getColor());\n+    }\n+\n@@ -59,2 +64,0 @@\n-        Stop nullColor = new Stop(0.2f, null);\n-        Stop nullColor2 = new Stop(0.2f, null);\n@@ -68,2 +71,0 @@\n-        assertTrue(nullColor.equals(nullColor2));\n-        assertFalse(nullColor.equals(basic));\n@@ -104,0 +105,33 @@\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenTwoDifferentValuesReturnsNewInstance() {\n+            var startValue = new Stop(0, RED);\n+            var endValue = new Stop(1, GREEN);\n+            assertEquals(new Stop(0.5, RED.interpolate(GREEN, 0.5)), startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsSameInstance() {\n+            var startValue = new Stop(0.25, RED);\n+            var endValue = new Stop(0.25, RED);\n+            assertSame(startValue, startValue.interpolate(endValue, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var startValue = new Stop(0.25, RED);\n+            var endValue = new Stop(0.75, GREEN);\n+            assertSame(startValue, startValue.interpolate(endValue, 0));\n+            assertSame(startValue, startValue.interpolate(endValue, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var startValue = new Stop(0.25, RED);\n+            var endValue = new Stop(0.75, GREEN);\n+            assertSame(endValue, startValue.interpolate(endValue, 1));\n+            assertSame(endValue, startValue.interpolate(endValue, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/StopTest.java","additions":44,"deletions":10,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+        var tab4 = new Tab(\"backgrounds\", new ScrollPane(createBackgroundTransitionsTab()));\n+        var tab5 = new Tab(\"borders\", new ScrollPane(createBorderTransitionsTab()));\n@@ -51,1 +53,1 @@\n-        var tabPane = new TabPane(tab1, tab2, tab3);\n+        var tabPane = new TabPane(tab1, tab2, tab3, tab4, tab5);\n@@ -118,0 +120,69 @@\n+\n+    private Region createBackgroundTransitionsTab() {\n+        return createContent(\"\"\"\n+            .rect {\n+              -fx-min-width: 100;\n+              -fx-min-height: 50;\n+              transition: all 2s;\n+            }\n+\n+            .rect:hover {\n+              -fx-min-width: 300;\n+            }\n+\n+            \/\/ Color transition\n+            #rect1 { -fx-background-color: red; }\n+            #rect1:hover { -fx-background-color: blue; }\n+\n+            \/\/ LinearGradient transition\n+            #rect2 { -fx-background-color: linear-gradient(to right, red, blue); }\n+            #rect2:hover { -fx-background-color: linear-gradient(to right, purple, yellow); }\n+\n+            \/\/ LinearGradient transition with different number of stops\n+            #rect3 { -fx-background-color: linear-gradient(to right, red, green); }\n+            #rect3:hover { -fx-background-color: linear-gradient(to right, red, yellow, blue); }\n+\n+            \/\/ RadialGradient transition with different number of stops\n+            #rect4 { -fx-background-color: radial-gradient(radius 100%, red, green); }\n+            #rect4:hover { -fx-background-color: radial-gradient(radius 100%, red, yellow, blue); }\n+            \"\"\",\n+            new RectInfo(\"#rect1\", \"rect1\"),\n+            new RectInfo(\"#rect2\", \"rect2\"),\n+            new RectInfo(\"#rect3\", \"rect3\"),\n+            new RectInfo(\"#rect4\", \"rect4\"));\n+    }\n+\n+    private Region createBorderTransitionsTab() {\n+        return createContent(\"\"\"\n+            .rect {\n+              -fx-min-width: 100;\n+              -fx-min-height: 50;\n+              -fx-border-width: 10;\n+              transition: all 2s;\n+            }\n+\n+            .rect:hover {\n+              -fx-min-width: 300;\n+            }\n+\n+            \/\/ Color transition\n+            #rect1 { -fx-border-color: red; }\n+            #rect1:hover { -fx-border-color: blue; }\n+\n+            \/\/ LinearGradient transition\n+            #rect2 { -fx-border-color: linear-gradient(to right, red, blue); }\n+            #rect2:hover { -fx-border-color: linear-gradient(to right, purple, yellow); }\n+\n+            \/\/ LinearGradient transition with different number of stops\n+            #rect3 { -fx-border-color: linear-gradient(to right, red, green); }\n+            #rect3:hover { -fx-border-color: linear-gradient(to right, red, yellow, blue); }\n+\n+            \/\/ RadialGradient transition with different number of stops\n+            #rect4 { -fx-border-color: radial-gradient(radius 100%, red, green); }\n+            #rect4:hover { -fx-border-color: radial-gradient(radius 100%, red, yellow, blue); }\n+            \"\"\",\n+            new RectInfo(\"#rect1\", \"rect1\"),\n+            new RectInfo(\"#rect2\", \"rect2\"),\n+            new RectInfo(\"#rect3\", \"rect3\"),\n+            new RectInfo(\"#rect4\", \"rect4\"));\n+    }\n","filename":"tests\/manual\/graphics\/CssTransitionsTest.java","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"}]}