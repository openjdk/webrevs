{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.util.List;\n+import java.util.Objects;\n@@ -63,0 +65,64 @@\n+\n+    \/**\n+     * Converts the specified list into an unmodifiable list that does not contain {@code null} values.\n+     * The returned list is a copy of, and not a wrapper around the specified list.\n+     *\n+     * @param <T> the type of elements in the list\n+     * @param list the list, not {@code null}\n+     * @return an unmodifiable list that does not contain null values\n+     *\/\n+    public static <T> UnmodifiableArrayList<T> copyOfNullFiltered(List<T> list) {\n+        Objects.requireNonNull(list, \"list cannot be null\");\n+\n+        int index = 0;\n+        int numNonNullValues = 0;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newValues = (T[])new Object[list.size()];\n+\n+        if (list instanceof RandomAccess) {\n+            \/\/ Prevents the iterator allocation for random-access lists.\n+            for (int i = 0, max = list.size(); i < max; ++i) {\n+                T value = list.get(i);\n+                if (value != null) {\n+                    newValues[index++] = value;\n+                    ++numNonNullValues;\n+                }\n+            }\n+        } else {\n+            for (T value : list) {\n+                if (value != null) {\n+                    newValues[index++] = value;\n+                    ++numNonNullValues;\n+                }\n+            }\n+        }\n+\n+        return new UnmodifiableArrayList<>(newValues, numNonNullValues);\n+    }\n+\n+    \/**\n+     * Converts the specified array into an unmodifiable list that does not contain {@code null} values.\n+     * The returned list is a copy of, and not a wrapper around the specified array.\n+     *\n+     * @param <T> the type of elements in the array\n+     * @param elements the array, not {@code null}\n+     * @return an unmodifiable list that does not contain null values\n+     *\/\n+    public static <T> UnmodifiableArrayList<T> copyOfNullFiltered(T[] elements) {\n+        Objects.requireNonNull(elements, \"elements cannot be null\");\n+\n+        int numNonNullValues = 0;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newValues = (T[])new Object[elements.length];\n+\n+        for (int i = 0, j = 0; i < elements.length; ++i) {\n+            if (elements[i] != null) {\n+                newValues[j++] = elements[i];\n+                ++numNonNullValues;\n+            }\n+        }\n+\n+        return new UnmodifiableArrayList<>(newValues, numNonNullValues);\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/UnmodifiableArrayList.java","additions":67,"deletions":1,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+--add-exports javafx.base\/com.sun.javafx=ALL-UNNAMED\n","filename":"modules\/javafx.base\/src\/test\/addExports","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx;\n+\n+import com.sun.javafx.UnmodifiableArrayList;\n+import org.junit.jupiter.api.Test;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class UnmodifiableArrayListTest {\n+\n+    @Test\n+    void testCopyOfNullFilteredList_nullList() {\n+        assertThrows(NullPointerException.class, () -> UnmodifiableArrayList.copyOfNullFiltered((List<?>)null));\n+    }\n+\n+    @Test\n+    void testCopyOfNullFilteredList_nullArray() {\n+        assertThrows(NullPointerException.class, () -> UnmodifiableArrayList.copyOfNullFiltered((Object[])null));\n+    }\n+\n+    @Test\n+    void testCopyOfNullFilteredList_randomAccess() {\n+        var list = new ArrayList<String>();\n+        list.add(\"a\");\n+        list.add(null);\n+        list.add(\"b\");\n+        list.add(null);\n+\n+        assertEquals(List.of(\"a\", \"b\"), UnmodifiableArrayList.copyOfNullFiltered(list));\n+    }\n+\n+    @Test\n+    void testCopyOfNullFilteredList_nonRandomAccess() {\n+        var list = new LinkedList<String>();\n+        list.add(\"a\");\n+        list.add(null);\n+        list.add(\"b\");\n+        list.add(null);\n+\n+        assertEquals(List.of(\"a\", \"b\"), UnmodifiableArrayList.copyOfNullFiltered(list));\n+    }\n+\n+    @Test\n+    void testCopyOfNullFilteredArray() {\n+        var list = new String[4];\n+        list[0] = \"a\";\n+        list[1] = null;\n+        list[2] = \"b\";\n+        list[3] = null;\n+\n+        assertEquals(List.of(\"a\", \"b\"), UnmodifiableArrayList.copyOfNullFiltered(list));\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/UnmodifiableArrayListTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene.paint;\n+\n+import javafx.animation.Interpolatable;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.Paint;\n+import javafx.scene.paint.RadialGradient;\n+import javafx.scene.paint.Stop;\n+import java.util.List;\n+\n+public final class PaintUtils {\n+\n+    private PaintUtils() {}\n+\n+    \/**\n+     * Interpolates between potentially different types of paint.\n+     * <p>\n+     * In addition to homogeneous interpolations between paints of the same type, the following\n+     * heterogeneous interpolations are supported:\n+     * <ul>\n+     *     <li>Color ↔ LinearGradient\n+     *     <li>Color ↔ RadialGradient\n+     * <\/ul>\n+     * If a paint is not interpolatable, {@code startValue} is returned for {@code t == 0},\n+     * and {@code endValue} is returned otherwise.\n+     *\/\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public static Paint interpolate(Paint startValue, Paint endValue, double t) {\n+        if (startValue instanceof Color start) {\n+            if (endValue instanceof Color end) {\n+                return start.interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof LinearGradient end) {\n+                return newSolidGradient(end, start).interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof RadialGradient end) {\n+                return newSolidGradient(end, start).interpolate(end, t);\n+            }\n+        }\n+\n+        if (startValue instanceof LinearGradient start) {\n+            if (endValue instanceof LinearGradient end) {\n+                return start.interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof Color end) {\n+                return start.interpolate(newSolidGradient(start, end), t);\n+            }\n+        }\n+\n+        if (startValue instanceof RadialGradient start) {\n+            if (endValue instanceof RadialGradient end) {\n+                return start.interpolate(end, t);\n+            }\n+\n+            if (endValue instanceof Color end) {\n+                return start.interpolate(newSolidGradient(start, end), t);\n+            }\n+        }\n+\n+        if (startValue instanceof Interpolatable start\n+                && endValue instanceof Interpolatable end\n+                && startValue.getClass().isInstance(endValue)) {\n+            return (Paint)start.interpolate(end, t);\n+        }\n+\n+        return t > 0 ? endValue : startValue;\n+    }\n+\n+    \/**\n+     * Creates a new linear gradient that consists of two stops with the same color.\n+     *\/\n+    public static LinearGradient newSolidGradient(LinearGradient source, Color color) {\n+        return new LinearGradient(\n+                source.getStartX(), source.getStartY(),\n+                source.getEndX(), source.getEndY(),\n+                source.isProportional(),\n+                source.getCycleMethod(),\n+                List.of(new Stop(0, color), new Stop(1, color)));\n+    }\n+\n+    \/**\n+     * Creates a new radial gradient that consists of two stops with the same color.\n+     *\/\n+    public static RadialGradient newSolidGradient(RadialGradient source, Color color) {\n+        return new RadialGradient(\n+                source.getFocusAngle(), source.getFocusDistance(),\n+                source.getCenterX(), source.getCenterY(),\n+                source.getRadius(),\n+                source.isProportional(),\n+                source.getCycleMethod(),\n+                List.of(new Stop(0, color), new Stop(1, color)));\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/paint\/PaintUtils.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -30,0 +30,2 @@\n+import com.sun.javafx.UnmodifiableArrayList;\n+import javafx.animation.Interpolatable;\n@@ -50,0 +52,2 @@\n+import java.util.Objects;\n+\n@@ -146,0 +150,166 @@\n+    \/**\n+     * Utility function that interpolates between two double values.\n+     *\/\n+    public static double interpolate(double from, double to, double t) {\n+        return from + t * (to - from);\n+    }\n+\n+    \/**\n+     * Utility function that interpolates between two double values, taking into account whether\n+     * the values are absolute or percentage-based. If one value is absolute and the other is a\n+     * percentage, then {@code from} is returned when {@code t == 0}, and {@code to} is returned\n+     * otherwise.\n+     *\/\n+    public static double interpolate(double from, double to,\n+                                     boolean fromIsPercentage, boolean toIsPercentage,\n+                                     double t) {\n+        if (fromIsPercentage == toIsPercentage) {\n+            return interpolate(from, to, t);\n+        }\n+\n+        return t > 0 ? to : from;\n+    }\n+\n+    \/**\n+     * Computes an intermediate list that consists of the pairwise interpolation between two lists,\n+     * using the following rules:\n+     * <ol>\n+     *     <li>The size of the returned list corresponds to the size of the second list.\n+     *     <li>If the first list has fewer elements than the second list, the missing elements are copied\n+     *         from the second list.\n+     *     <li>If the first list has more elements than the second list, the excess elements are discarded.\n+     *     <li>If the intermediate list is shallow-equal to the first list passed into the method (i.e. its\n+     *         elements are references to the same objects), the existing list is returned.\n+     *     <li>If a new list is returned, it is unmodifiable.\n+     * <\/ol>\n+     *\n+     * @param firstList the first list, not {@code null}\n+     * @param secondList the second list, not {@code null}\n+     * @return the intermediate list\n+     *\/\n+    public static <T extends Interpolatable<T>> List<T> interpolateListsPairwise(\n+            List<T> firstList, List<T> secondList, double t) {\n+        Objects.requireNonNull(firstList, \"firstList\");\n+        Objects.requireNonNull(secondList, \"secondList\");\n+\n+        if (secondList.isEmpty()) {\n+            return firstList.isEmpty() ? firstList : secondList;\n+        }\n+\n+        int listSize = firstList.size();\n+\n+        \/\/ For small equisized lists (up to 8 elements), we use an optimization to prevent the allocation\n+        \/\/ of a new array in case the intermediate list would be equal to the existing list.\n+        if (listSize <= 8 && listSize == secondList.size()) {\n+            return interpolateEquisizedListsPairwise(firstList, secondList, t);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newArray = (T[])new Interpolatable[secondList.size()];\n+        boolean equal = firstList.size() == secondList.size();\n+\n+        for (int i = 0, firstListSize = firstList.size(); i < newArray.length; ++i) {\n+            if (firstListSize > i) {\n+                newArray[i] = firstList.get(i).interpolate(secondList.get(i), t);\n+                equal &= newArray[i] == firstList.get(i);\n+            } else {\n+                newArray[i] = secondList.get(i);\n+            }\n+        }\n+\n+        return equal ? firstList : new UnmodifiableArrayList<>(newArray, newArray.length);\n+    }\n+\n+    \/**\n+     * Computes an intermediate list that consists of the pairwise interpolation between two lists\n+     * of equal size, each containing up to 8 elements.\n+     * <p>\n+     * This method is an optimization: it does not allocate memory when the intermediate list is\n+     * shallow-equal to the list that is passed into this method, i.e. its elements are references\n+     * to the same objects. The existing list is returned in this case.\n+     *\/\n+    private static <T extends Interpolatable<T>> List<T> interpolateEquisizedListsPairwise(\n+            List<T> firstList, List<T> secondList, double t) {\n+        int listSize = firstList.size();\n+        if (listSize > 8 || listSize != secondList.size()) {\n+            throw new AssertionError();\n+        }\n+\n+        T item1 = null, item2 = null, item3 = null, item4 = null, item5 = null, item6 = null, item7 = null;\n+        T item0 = firstList.get(0).interpolate(secondList.get(0), t);\n+        boolean same = item0 == firstList.get(0);\n+\n+        if (listSize > 1) {\n+            item1 = firstList.get(1).interpolate(secondList.get(1), t);\n+            same &= item1 == firstList.get(1);\n+\n+            if (listSize > 2) {\n+                item2 = firstList.get(2).interpolate(secondList.get(2), t);\n+                same &= item2 == firstList.get(2);\n+\n+                if (listSize > 3) {\n+                    item3 = firstList.get(3).interpolate(secondList.get(3), t);\n+                    same &= item3 == firstList.get(3);\n+\n+                    if (listSize > 4) {\n+                        item4 = firstList.get(4).interpolate(secondList.get(4), t);\n+                        same &= item4 == firstList.get(4);\n+\n+                        if (listSize > 5) {\n+                            item5 = firstList.get(5).interpolate(secondList.get(5), t);\n+                            same &= item5 == firstList.get(5);\n+\n+                            if (listSize > 6) {\n+                                item6 = firstList.get(6).interpolate(secondList.get(6), t);\n+                                same &= item6 == firstList.get(6);\n+\n+                                if (listSize > 7) {\n+                                    item7 = firstList.get(7).interpolate(secondList.get(7), t);\n+                                    same &= item7 == firstList.get(7);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (same) {\n+            return firstList;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] newArray = (T[])new Interpolatable[listSize];\n+        newArray[0] = item0;\n+\n+        if (listSize > 1) {\n+            newArray[1] = item1;\n+\n+            if (listSize > 2) {\n+                newArray[2] = item2;\n+\n+                if (listSize > 3) {\n+                    newArray[3] = item3;\n+\n+                    if (listSize > 4) {\n+                        newArray[4] = item4;\n+\n+                        if (listSize > 5) {\n+                            newArray[5] = item5;\n+\n+                            if (listSize > 6) {\n+                                newArray[6] = item6;\n+\n+                                if (listSize > 7) {\n+                                    newArray[7] = item7;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return new UnmodifiableArrayList<>(newArray, listSize);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/util\/Utils.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -29,3 +29,3 @@\n- * A value that can be interpolated. It defines single\n- * {@link #interpolate(Object, double)} method, which returns interpolated value\n- * of given fraction.\n+ * A value that can be interpolated. It defines a single {@link #interpolate(Object, double)}\n+ * method, which returns an intermediate value between the value of this {@code Interpolatable}\n+ * and the specified target value.\n@@ -40,3 +40,13 @@\n-     * The function calculates an interpolated value along the fraction\n-     * {@code t} between {@code 0.0} and {@code 1.0}. When {@code t} = 1.0,\n-     * {@code endVal} is returned.\n+     * Returns an intermediate value between the value of this {@code Interpolatable} and the specified\n+     * {@code endValue} using the linear interpolation factor {@code t}, ranging from 0 (inclusive)\n+     * to 1 (inclusive).\n+     * <p>\n+     * The returned value may not be a new instance; an implementation might also return one of the\n+     * two existing instances if the intermediate value would be equal to one of the existing values.\n+     * However, this is an optimization and applications should not assume any particular identity\n+     * of the returned value.\n+     * <p>\n+     * An implementation is not required to reject interpolation factors less than 0 or larger than 1,\n+     * but this specification gives no meaning to values returned outside of this range. For example,\n+     * an implementation might clamp the interpolation factor to [0..1], or it might continue the linear\n+     * interpolation outside of this range.\n@@ -44,5 +54,3 @@\n-     * @param endValue\n-     *            target value\n-     * @param t\n-     *            fraction between {@code 0.0} and {@code 1.0}\n-     * @return interpolated value\n+     * @param endValue the target value\n+     * @param t the interpolation factor\n+     * @return the intermediate value\n@@ -50,1 +58,1 @@\n-    public T interpolate(T endValue, double t);\n+    T interpolate(T endValue, double t);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/animation\/Interpolatable.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ import com.sun.javafx.util.Utils;\n+ import javafx.animation.Interpolatable;\n@@ -34,1 +36,1 @@\n-public class Insets {\n+public class Insets implements Interpolatable<Insets> {\n@@ -102,0 +104,17 @@\n+    @Override\n+    public Insets interpolate(Insets endValue, double t) {\n+        if (t <= 0 || equals(endValue)) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        return new Insets(\n+            Utils.interpolate(top, endValue.top, t),\n+            Utils.interpolate(right, endValue.right, t),\n+            Utils.interpolate(bottom, endValue.bottom, t),\n+            Utils.interpolate(left, endValue.left, t));\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/geometry\/Insets.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -39,0 +41,2 @@\n+import java.util.Objects;\n+\n@@ -73,1 +77,1 @@\n-public final class Background {\n+public final class Background implements Interpolatable<Background> {\n@@ -247,3 +251,3 @@\n-        \/\/ array based constructor (for speed).\n-        this(fills == null ? null : fills.toArray(new BackgroundFill[fills.size()]),\n-             images == null ? null : images.toArray(new BackgroundImage[images.size()]));\n+        \/\/ array based constructor.\n+        this(fills != null ? UnmodifiableArrayList.copyOfNullFiltered(fills) : List.of(),\n+             images != null ? UnmodifiableArrayList.copyOfNullFiltered(images) : List.of(), 0);\n@@ -267,0 +271,18 @@\n+        this(fills != null ? UnmodifiableArrayList.copyOfNullFiltered(fills) : List.of(),\n+             images != null ? UnmodifiableArrayList.copyOfNullFiltered(images) : List.of(), 0);\n+    }\n+\n+    \/**\n+     * Creates a new Background with the specified fills and images.\n+     * This constructor requires that both lists do not contain null values, and that the lists\n+     * are immutable. The purpose of this constructor is to prevent an unnecessary array creation\n+     * when the caller already knows that the specified lists satisfy the non-null precondition\n+     * and preserve the immutability invariant.\n+     *\n+     * @param fills the fills, not {@code null}\n+     * @param images the images, not {@code null}\n+     *\/\n+    private Background(List<BackgroundFill> fills, List<BackgroundImage> images, int ignored) {\n+        Objects.requireNonNull(fills, \"fills cannot be null\");\n+        Objects.requireNonNull(images, \"images cannot be null\");\n+\n@@ -273,33 +295,21 @@\n-        \/\/ If the fills is empty or null then we know we can just use the shared\n-        \/\/ immutable empty list from Collections.\n-        if (fills == null || fills.length == 0) {\n-            this.fills = Collections.emptyList();\n-        } else {\n-            \/\/ We need to iterate over all of the supplied elements in the fills array.\n-            \/\/ Each null element is ignored. Each non-null element is inspected to\n-            \/\/ see if it contributes to the outsets.\n-            final BackgroundFill[] noNulls = new BackgroundFill[fills.length];\n-            int size = 0;\n-            for (int i=0; i<fills.length; i++) {\n-                final BackgroundFill fill = fills[i];\n-                if (fill != null) {\n-                    noNulls[size++] = fill;\n-                    final Insets fillInsets = fill.getInsets();\n-                    final double fillTop = fillInsets.getTop();\n-                    final double fillRight = fillInsets.getRight();\n-                    final double fillBottom = fillInsets.getBottom();\n-                    final double fillLeft = fillInsets.getLeft();\n-                    outerTop = outerTop <= fillTop ? outerTop : fillTop; \/\/ min\n-                    outerRight = outerRight <= fillRight ? outerRight : fillRight; \/\/ min\n-                    outerBottom = outerBottom <= fillBottom ? outerBottom : fillBottom; \/\/ min\n-                    outerLeft = outerLeft <= fillLeft ? outerLeft : fillLeft; \/\/ min\n-\n-                    \/\/ The common case is to NOT have percent based radii\n-                    final boolean b = fill.getRadii().hasPercentBasedRadii;\n-                    hasPercentFillRadii |= b;\n-                    if (fill.fill.isOpaque()) {\n-                        opaqueFill = true;\n-                        if (b) {\n-                            hasPercentOpaqueInsets = true;\n-                        }\n-                    }\n+        \/\/ We need to iterate over all of the supplied elements in the fills list.\n+        \/\/ Each element is inspected to see if it contributes to the outsets.\n+        for (int i = 0, max = fills.size(); i < max; i++) {\n+            final BackgroundFill fill = fills.get(i);\n+            final Insets fillInsets = fill.getInsets();\n+            final double fillTop = fillInsets.getTop();\n+            final double fillRight = fillInsets.getRight();\n+            final double fillBottom = fillInsets.getBottom();\n+            final double fillLeft = fillInsets.getLeft();\n+            outerTop = outerTop <= fillTop ? outerTop : fillTop; \/\/ min\n+            outerRight = outerRight <= fillRight ? outerRight : fillRight; \/\/ min\n+            outerBottom = outerBottom <= fillBottom ? outerBottom : fillBottom; \/\/ min\n+            outerLeft = outerLeft <= fillLeft ? outerLeft : fillLeft; \/\/ min\n+\n+            \/\/ The common case is to NOT have percent based radii\n+            final boolean b = fill.getRadii().hasPercentBasedRadii;\n+            hasPercentFillRadii |= b;\n+            if (fill.fill.isOpaque()) {\n+                opaqueFill = true;\n+                if (b) {\n+                    hasPercentOpaqueInsets = true;\n@@ -308,1 +318,0 @@\n-            this.fills = new UnmodifiableArrayList<>(noNulls, size);\n@@ -310,0 +319,2 @@\n+\n+        this.fills = fills;\n@@ -320,13 +331,1 @@\n-        \/\/ An null or empty images array results in an empty list\n-        if (images == null || images.length == 0) {\n-            this.images = Collections.emptyList();\n-        } else {\n-            \/\/ Filter out any  null values and create an immutable array list\n-            final BackgroundImage[] noNulls = new BackgroundImage[images.length];\n-            int size = 0;\n-            for (int i=0; i<images.length; i++) {\n-                final BackgroundImage image = images[i];\n-                if (image != null) noNulls[size++] = image;\n-            }\n-            this.images = new UnmodifiableArrayList<>(noNulls, size);\n-        }\n+        this.images = images;\n@@ -638,0 +637,24 @@\n+    @Override\n+    public Background interpolate(Background endValue, double t) {\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        List<BackgroundFill> newFills = Utils.interpolateListsPairwise(fills, endValue.fills, t);\n+        List<BackgroundImage> newImages = Utils.interpolateListsPairwise(images, endValue.images, t);\n+\n+        if (newFills == this.fills && newImages == this.images) {\n+            return this;\n+        }\n+\n+        if (newFills == endValue.fills && newImages == endValue.images) {\n+            return endValue;\n+        }\n+\n+        return new Background(newFills, newImages, 0);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Background.java","additions":75,"deletions":52,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.scene.paint.PaintUtils;\n+import javafx.animation.Interpolatable;\n@@ -44,1 +46,1 @@\n-public final class BackgroundFill {\n+public final class BackgroundFill implements Interpolatable<BackgroundFill> {\n@@ -106,0 +108,31 @@\n+    @Override\n+    public BackgroundFill interpolate(BackgroundFill endValue, double t) {\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        \/\/ CornerRadii, Insets and Paint are implemented such that interpolate() always returns the\n+        \/\/ existing instance if the intermediate value is equal to the start value or the end value,\n+        \/\/ which allows us to use an identity comparison in place of a value comparison to determine\n+        \/\/ equality.\n+        CornerRadii newRadii = radii.interpolate(endValue.radii, t);\n+        Insets newInsets = insets.interpolate(endValue.insets, t);\n+        Paint newFill = PaintUtils.interpolate(fill, endValue.fill, t);\n+\n+        if (newFill == fill && newRadii == radii && newInsets == insets) {\n+            return this;\n+        }\n+\n+        if (newFill == endValue.fill && newRadii == endValue.radii && newInsets == endValue.insets) {\n+            return endValue;\n+        }\n+\n+        return new BackgroundFill(newFill, newRadii, newInsets);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundFill.java","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import javafx.animation.Interpolatable;\n@@ -46,1 +47,1 @@\n-public final class BackgroundImage {\n+public final class BackgroundImage implements Interpolatable<BackgroundImage> {\n@@ -141,0 +142,34 @@\n+    @Override\n+    public BackgroundImage interpolate(BackgroundImage endValue, double t) {\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        \/\/ BackgroundPosition and BackgroundSize are implemented such that interpolate() always returns\n+        \/\/ the existing instance if the intermediate value is equal to the start value or the end value,\n+        \/\/ which allows us to use an identity comparison in place of a value comparison to determine\n+        \/\/ equality.\n+        BackgroundPosition newPosition = this.position.interpolate(endValue.position, t);\n+        BackgroundSize newSize = this.size.interpolate(endValue.size, t);\n+\n+        if (image == endValue.image\n+                && repeatX == endValue.repeatX\n+                && repeatY == endValue.repeatY\n+                && position == newPosition\n+                && size == newSize) {\n+            return this;\n+        }\n+\n+        if (endValue.position == newPosition && endValue.size == newSize) {\n+            return endValue;\n+        }\n+\n+        return new BackgroundImage(endValue.image, endValue.repeatX, endValue.repeatY, newPosition, newSize);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundImage.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -52,1 +54,1 @@\n-public class BackgroundPosition {\n+public final class BackgroundPosition implements Interpolatable<BackgroundPosition> {\n@@ -178,0 +180,27 @@\n+    @Override\n+    public BackgroundPosition interpolate(BackgroundPosition endValue, double t) {\n+        if (t <= 0 || equals(endValue)) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        double horizontalPosition = horizontalSide == endValue.horizontalSide ?\n+            Utils.interpolate(\n+                this.horizontalPosition, endValue.horizontalPosition,\n+                this.horizontalAsPercentage, endValue.horizontalAsPercentage, t) :\n+            endValue.horizontalPosition;\n+\n+        double verticalPosition = verticalSide == endValue.verticalSide ?\n+            Utils.interpolate(\n+                this.verticalPosition, endValue.verticalPosition,\n+                this.verticalAsPercentage, endValue.verticalAsPercentage, t) :\n+            endValue.verticalPosition;\n+\n+        return new BackgroundPosition(\n+            endValue.horizontalSide, horizontalPosition, endValue.horizontalAsPercentage,\n+            endValue.verticalSide, verticalPosition, endValue.verticalAsPercentage);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundPosition.java","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -57,1 +59,1 @@\n-public final class BackgroundSize {\n+public final class BackgroundSize implements Interpolatable<BackgroundSize> {\n@@ -183,0 +185,27 @@\n+    @Override\n+    public BackgroundSize interpolate(BackgroundSize endValue, double t) {\n+        if (t <= 0 || equals(endValue)) {\n+            return this;\n+        }\n+\n+        if (t >= 1 || !isInterpolatable() || !endValue.isInterpolatable()) {\n+            return endValue;\n+        }\n+\n+        double width = this.width != AUTO && endValue.width != AUTO ?\n+            Utils.interpolate(this.width, endValue.width, this.widthAsPercentage, endValue.widthAsPercentage, t) :\n+            endValue.width;\n+\n+        double height = this.height != AUTO && endValue.height != AUTO ?\n+            Utils.interpolate(this.height, endValue.height, this.heightAsPercentage, endValue.heightAsPercentage, t) :\n+            endValue.height;\n+\n+        return new BackgroundSize(width, height,\n+                                  endValue.widthAsPercentage, endValue.heightAsPercentage,\n+                                  endValue.contain, endValue.cover);\n+    }\n+\n+    private boolean isInterpolatable() {\n+        return !cover && !contain && (width != AUTO || height != AUTO);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BackgroundSize.java","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -32,0 +33,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -90,1 +93,1 @@\n-public final class Border {\n+public final class Border implements Interpolatable<Border> {\n@@ -280,2 +283,2 @@\n-        this(strokes == null ? null : strokes.toArray(new BorderStroke[strokes.size()]),\n-             images == null ? null : images.toArray(new BorderImage[images.size()]));\n+        this(strokes != null ? UnmodifiableArrayList.copyOfNullFiltered(strokes) : List.of(),\n+             images != null ? UnmodifiableArrayList.copyOfNullFiltered(images) : List.of(), 0);\n@@ -303,0 +306,18 @@\n+        this(strokes != null ? UnmodifiableArrayList.copyOfNullFiltered(strokes) : List.of(),\n+             images != null ? UnmodifiableArrayList.copyOfNullFiltered(images) : List.of(), 0);\n+    }\n+\n+    \/**\n+     * Creates a new Border with the specified strokes and images.\n+     * This constructor requires that both lists do not contain null values, and that the lists\n+     * are immutable. The purpose of this constructor is to prevent an unnecessary array creation\n+     * when the caller already knows that the specified lists satisfy the non-null precondition\n+     * and preserve the immutability invariant.\n+     *\n+     * @param strokes the strokes, not {@code null}\n+     * @param images the images, not {@code null}\n+     *\/\n+    private Border(List<BorderStroke> strokes, List<BorderImage> images, int ignored) {\n+        Objects.requireNonNull(strokes, \"strokes cannot be null\");\n+        Objects.requireNonNull(images, \"images cannot be null\");\n+\n@@ -306,36 +327,26 @@\n-        if (strokes == null || strokes.length == 0) {\n-            this.strokes = Collections.emptyList();\n-        } else {\n-            final BorderStroke[] noNulls = new BorderStroke[strokes.length];\n-            int size = 0;\n-            for (int i=0; i<strokes.length; i++) {\n-                final BorderStroke stroke = strokes[i];\n-                if (stroke != null) {\n-                    noNulls[size++] = stroke;\n-\n-                    \/\/ Calculate the insets and outsets. \"insets\" are the distance\n-                    \/\/ from the edge of the region to the inmost edge of the inmost border.\n-                    \/\/ Outsets are the distance from the edge of the region out towards the\n-                    \/\/ outer-most edge of the outer-most border.\n-                    final double strokeInnerTop = stroke.innerEdge.getTop();\n-                    final double strokeInnerRight = stroke.innerEdge.getRight();\n-                    final double strokeInnerBottom = stroke.innerEdge.getBottom();\n-                    final double strokeInnerLeft = stroke.innerEdge.getLeft();\n-\n-                    innerTop = innerTop >= strokeInnerTop ? innerTop : strokeInnerTop;\n-                    innerRight = innerRight >= strokeInnerRight? innerRight : strokeInnerRight;\n-                    innerBottom = innerBottom >= strokeInnerBottom ? innerBottom : strokeInnerBottom;\n-                    innerLeft = innerLeft >= strokeInnerLeft ? innerLeft : strokeInnerLeft;\n-\n-                    final double strokeOuterTop = stroke.outerEdge.getTop();\n-                    final double strokeOuterRight = stroke.outerEdge.getRight();\n-                    final double strokeOuterBottom = stroke.outerEdge.getBottom();\n-                    final double strokeOuterLeft = stroke.outerEdge.getLeft();\n-\n-                    outerTop = outerTop >= strokeOuterTop ? outerTop : strokeOuterTop;\n-                    outerRight = outerRight >= strokeOuterRight? outerRight : strokeOuterRight;\n-                    outerBottom = outerBottom >= strokeOuterBottom ? outerBottom : strokeOuterBottom;\n-                    outerLeft = outerLeft >= strokeOuterLeft ? outerLeft : strokeOuterLeft;\n-                }\n-            }\n-            this.strokes = new UnmodifiableArrayList<>(noNulls, size);\n+        for (int i = 0, max = strokes.size(); i < max; i++) {\n+            final BorderStroke stroke = strokes.get(i);\n+\n+            \/\/ Calculate the insets and outsets. \"insets\" are the distance\n+            \/\/ from the edge of the region to the inmost edge of the inmost border.\n+            \/\/ Outsets are the distance from the edge of the region out towards the\n+            \/\/ outer-most edge of the outer-most border.\n+            final double strokeInnerTop = stroke.innerEdge.getTop();\n+            final double strokeInnerRight = stroke.innerEdge.getRight();\n+            final double strokeInnerBottom = stroke.innerEdge.getBottom();\n+            final double strokeInnerLeft = stroke.innerEdge.getLeft();\n+\n+            innerTop = innerTop >= strokeInnerTop ? innerTop : strokeInnerTop;\n+            innerRight = innerRight >= strokeInnerRight? innerRight : strokeInnerRight;\n+            innerBottom = innerBottom >= strokeInnerBottom ? innerBottom : strokeInnerBottom;\n+            innerLeft = innerLeft >= strokeInnerLeft ? innerLeft : strokeInnerLeft;\n+\n+            final double strokeOuterTop = stroke.outerEdge.getTop();\n+            final double strokeOuterRight = stroke.outerEdge.getRight();\n+            final double strokeOuterBottom = stroke.outerEdge.getBottom();\n+            final double strokeOuterLeft = stroke.outerEdge.getLeft();\n+\n+            outerTop = outerTop >= strokeOuterTop ? outerTop : strokeOuterTop;\n+            outerRight = outerRight >= strokeOuterRight? outerRight : strokeOuterRight;\n+            outerBottom = outerBottom >= strokeOuterBottom ? outerBottom : strokeOuterBottom;\n+            outerLeft = outerLeft >= strokeOuterLeft ? outerLeft : strokeOuterLeft;\n@@ -344,34 +355,26 @@\n-        if (images == null || images.length == 0) {\n-            this.images = Collections.emptyList();\n-        } else {\n-            final BorderImage[] noNulls = new BorderImage[images.length];\n-            int size = 0;\n-            for (int i=0; i<images.length; i++) {\n-                final BorderImage image = images[i];\n-                if (image != null){\n-                    noNulls[size++] = image;\n-\n-                    \/\/ The Image width + insets may contribute to the insets \/ outsets of\n-                    \/\/ this border.\n-                    final double imageInnerTop = image.innerEdge.getTop();\n-                    final double imageInnerRight = image.innerEdge.getRight();\n-                    final double imageInnerBottom = image.innerEdge.getBottom();\n-                    final double imageInnerLeft = image.innerEdge.getLeft();\n-\n-                    innerTop = innerTop >= imageInnerTop ? innerTop : imageInnerTop;\n-                    innerRight = innerRight >= imageInnerRight? innerRight : imageInnerRight;\n-                    innerBottom = innerBottom >= imageInnerBottom ? innerBottom : imageInnerBottom;\n-                    innerLeft = innerLeft >= imageInnerLeft ? innerLeft : imageInnerLeft;\n-\n-                    final double imageOuterTop = image.outerEdge.getTop();\n-                    final double imageOuterRight = image.outerEdge.getRight();\n-                    final double imageOuterBottom = image.outerEdge.getBottom();\n-                    final double imageOuterLeft = image.outerEdge.getLeft();\n-\n-                    outerTop = outerTop >= imageOuterTop ? outerTop : imageOuterTop;\n-                    outerRight = outerRight >= imageOuterRight? outerRight : imageOuterRight;\n-                    outerBottom = outerBottom >= imageOuterBottom ? outerBottom : imageOuterBottom;\n-                    outerLeft = outerLeft >= imageOuterLeft ? outerLeft : imageOuterLeft;\n-                }\n-            }\n-            this.images = new UnmodifiableArrayList<>(noNulls, size);\n+        this.strokes = strokes;\n+\n+        for (int i = 0, max = images.size(); i < max; i++) {\n+            final BorderImage image = images.get(i);\n+\n+            \/\/ The Image width + insets may contribute to the insets \/ outsets of\n+            \/\/ this border.\n+            final double imageInnerTop = image.innerEdge.getTop();\n+            final double imageInnerRight = image.innerEdge.getRight();\n+            final double imageInnerBottom = image.innerEdge.getBottom();\n+            final double imageInnerLeft = image.innerEdge.getLeft();\n+\n+            innerTop = innerTop >= imageInnerTop ? innerTop : imageInnerTop;\n+            innerRight = innerRight >= imageInnerRight? innerRight : imageInnerRight;\n+            innerBottom = innerBottom >= imageInnerBottom ? innerBottom : imageInnerBottom;\n+            innerLeft = innerLeft >= imageInnerLeft ? innerLeft : imageInnerLeft;\n+\n+            final double imageOuterTop = image.outerEdge.getTop();\n+            final double imageOuterRight = image.outerEdge.getRight();\n+            final double imageOuterBottom = image.outerEdge.getBottom();\n+            final double imageOuterLeft = image.outerEdge.getLeft();\n+\n+            outerTop = outerTop >= imageOuterTop ? outerTop : imageOuterTop;\n+            outerRight = outerRight >= imageOuterRight? outerRight : imageOuterRight;\n+            outerBottom = outerBottom >= imageOuterBottom ? outerBottom : imageOuterBottom;\n+            outerLeft = outerLeft >= imageOuterLeft ? outerLeft : imageOuterLeft;\n@@ -380,0 +383,2 @@\n+        this.images = images;\n+\n@@ -408,0 +413,24 @@\n+    @Override\n+    public Border interpolate(Border endValue, double t) {\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        List<BorderImage> newImages = Utils.interpolateListsPairwise(images, endValue.images, t);\n+        List<BorderStroke> newStrokes = Utils.interpolateListsPairwise(strokes, endValue.strokes, t);\n+\n+        if (images == newImages && strokes == newStrokes) {\n+            return this;\n+        }\n+\n+        if (endValue.images == newImages && endValue.strokes == newStrokes) {\n+            return endValue;\n+        }\n+\n+        return new Border(newStrokes, newImages);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Border.java","additions":103,"deletions":74,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javafx.animation.Interpolatable;\n@@ -51,1 +52,1 @@\n-public class BorderImage {\n+public class BorderImage implements Interpolatable<BorderImage> {\n@@ -189,0 +190,39 @@\n+    @Override\n+    public BorderImage interpolate(BorderImage endValue, double t) {\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        \/\/ BorderWidths and Insets are implemented such that interpolate() always returns the existing\n+        \/\/ instance if the intermediate value is equal to the start value or the end value, which allows\n+        \/\/ us to use an identity comparison in place of a value comparison to determine equality.\n+        BorderWidths newWidths = widths.interpolate(endValue.widths, t);\n+        BorderWidths newSlices = slices.interpolate(endValue.slices, t);\n+        Insets newInsets = insets.interpolate(endValue.insets, t);\n+\n+        if (filled == endValue.filled\n+                && image == endValue.image\n+                && repeatX == endValue.repeatX\n+                && repeatY == endValue.repeatY\n+                && widths == newWidths\n+                && slices == newSlices\n+                && insets == newInsets) {\n+            return this;\n+        }\n+\n+        if (endValue.widths == newWidths\n+                && endValue.slices == newSlices\n+                && endValue.insets == newInsets) {\n+            return endValue;\n+        }\n+\n+        return new BorderImage(\n+            endValue.image, newWidths, newInsets, newSlices, endValue.filled, endValue.repeatX, endValue.repeatY);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BorderImage.java","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.scene.paint.PaintUtils;\n+import javafx.animation.Interpolatable;\n@@ -48,1 +50,1 @@\n-public class BorderStroke {\n+public final class BorderStroke implements Interpolatable<BorderStroke> {\n@@ -361,0 +363,53 @@\n+    @Override\n+    public BorderStroke interpolate(BorderStroke endValue, double t) {\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        \/\/ CornerRadii, BorderWidths, Insets and Paint are implemented such that interpolate() always returns\n+        \/\/ the existing instance if the intermediate value is equal to the start value or the end value,\n+        \/\/ which allows us to use an identity comparison in place of a value comparison to determine equality.\n+        CornerRadii newRadii = this.radii.interpolate(endValue.radii, t);\n+        BorderWidths newWidths = this.widths.interpolate(endValue.widths, t);\n+        Insets newInsets = this.insets.interpolate(endValue.insets, t);\n+        Paint newTopStroke = PaintUtils.interpolate(this.topStroke, endValue.topStroke, t);\n+        Paint newRightStroke = PaintUtils.interpolate(this.rightStroke, endValue.rightStroke, t);\n+        Paint newBottomStroke = PaintUtils.interpolate(this.bottomStroke, endValue.bottomStroke, t);\n+        Paint newLeftStroke = PaintUtils.interpolate(this.leftStroke, endValue.leftStroke, t);\n+\n+        if (topStyle == endValue.topStyle\n+                && rightStyle == endValue.rightStyle\n+                && bottomStyle == endValue.bottomStyle\n+                && leftStyle == endValue.leftStyle\n+                && isSame(newTopStroke, newRightStroke, newBottomStroke, newLeftStroke,\n+                          newRadii, newWidths, newInsets)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newTopStroke, newRightStroke, newBottomStroke, newLeftStroke,\n+                            newRadii, newWidths, newInsets)) {\n+            return endValue;\n+        }\n+\n+        return new BorderStroke(newTopStroke, newRightStroke, newBottomStroke, newLeftStroke,\n+                                endValue.topStyle, endValue.rightStyle, endValue.bottomStyle, endValue.leftStyle,\n+                                newRadii, newWidths, newInsets);\n+    }\n+\n+    private boolean isSame(Paint topStroke, Paint rightStroke, Paint bottomStroke, Paint leftStroke,\n+                           CornerRadii radii, BorderWidths widths, Insets insets) {\n+        return this.topStroke == topStroke\n+            && this.rightStroke == rightStroke\n+            && this.bottomStroke == bottomStroke\n+            && this.leftStroke == leftStroke\n+            && this.radii == radii\n+            && this.widths == widths\n+            && this.insets == insets;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BorderStroke.java","additions":57,"deletions":2,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -30,1 +32,0 @@\n-\n@@ -44,1 +45,1 @@\n-public final class BorderWidths {\n+public final class BorderWidths implements Interpolatable<BorderWidths> {\n@@ -226,0 +227,19 @@\n+    @Override\n+    public BorderWidths interpolate(BorderWidths endValue, double t) {\n+        if (t <= 0 || equals(endValue)) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        double top = Utils.interpolate(this.top, endValue.top, this.topAsPercentage, endValue.topAsPercentage, t);\n+        double right = Utils.interpolate(this.right, endValue.right, this.rightAsPercentage, endValue.rightAsPercentage, t);\n+        double bottom = Utils.interpolate(this.bottom, endValue.bottom, this.bottomAsPercentage, endValue.bottomAsPercentage, t);\n+        double left = Utils.interpolate(this.left, endValue.left, this.leftAsPercentage, endValue.leftAsPercentage, t);\n+\n+        return new BorderWidths(top, right, bottom, left, endValue.topAsPercentage, endValue.rightAsPercentage,\n+                                endValue.bottomAsPercentage, endValue.leftAsPercentage);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BorderWidths.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -30,1 +32,0 @@\n-\n@@ -40,1 +41,1 @@\n-public class CornerRadii {\n+public class CornerRadii implements Interpolatable<CornerRadii> {\n@@ -362,0 +363,67 @@\n+    @Override\n+    public CornerRadii interpolate(CornerRadii endValue, double t) {\n+        if (t <= 0 || equals(endValue)) {\n+            return this;\n+        }\n+\n+        if (t >= 1) {\n+            return endValue;\n+        }\n+\n+        return uniform && endValue.uniform ?\n+            interpolateUniform(endValue, t) :\n+            interpolateNonUniform(endValue, t);\n+    }\n+\n+    private CornerRadii interpolateUniform(CornerRadii endValue, double t) {\n+        double radius = Utils.interpolate(\n+            this.topLeftHorizontalRadius, endValue.topLeftHorizontalRadius,\n+            this.topLeftHorizontalRadiusAsPercentage, endValue.topLeftHorizontalRadiusAsPercentage, t);\n+\n+        return new CornerRadii(radius, endValue.topLeftHorizontalRadiusAsPercentage);\n+    }\n+\n+    private CornerRadii interpolateNonUniform(CornerRadii endValue, double t) {\n+        double topLeftHorizontalRadius = Utils.interpolate(\n+            this.topLeftHorizontalRadius, endValue.topLeftHorizontalRadius,\n+            this.topLeftHorizontalRadiusAsPercentage, endValue.topLeftHorizontalRadiusAsPercentage, t);\n+\n+        double topLeftVerticalRadius = Utils.interpolate(\n+            this.topLeftVerticalRadius, endValue.topLeftVerticalRadius,\n+            this.topLeftVerticalRadiusAsPercentage, endValue.topLeftVerticalRadiusAsPercentage, t);\n+\n+        double topRightVerticalRadius = Utils.interpolate(\n+            this.topRightVerticalRadius, endValue.topRightVerticalRadius,\n+            this.topRightVerticalRadiusAsPercentage, endValue.topRightVerticalRadiusAsPercentage, t);\n+\n+        double topRightHorizontalRadius = Utils.interpolate(\n+            this.topRightHorizontalRadius, endValue.topRightHorizontalRadius,\n+            this.topRightHorizontalRadiusAsPercentage, endValue.topRightHorizontalRadiusAsPercentage, t);\n+\n+        double bottomRightHorizontalRadius = Utils.interpolate(\n+            this.bottomRightHorizontalRadius, endValue.bottomRightHorizontalRadius,\n+            this.bottomRightHorizontalRadiusAsPercentage, endValue.bottomRightHorizontalRadiusAsPercentage, t);\n+\n+        double bottomRightVerticalRadius = Utils.interpolate(\n+            this.bottomRightVerticalRadius, endValue.bottomRightVerticalRadius,\n+            this.bottomRightVerticalRadiusAsPercentage, endValue.bottomRightVerticalRadiusAsPercentage, t);\n+\n+        double bottomLeftVerticalRadius = Utils.interpolate(\n+            this.bottomLeftVerticalRadius, endValue.bottomLeftVerticalRadius,\n+            this.bottomLeftVerticalRadiusAsPercentage, endValue.bottomLeftVerticalRadiusAsPercentage, t);\n+\n+        double bottomLeftHorizontalRadius = Utils.interpolate(\n+            this.bottomLeftHorizontalRadius, endValue.bottomLeftHorizontalRadius,\n+            this.bottomLeftHorizontalRadiusAsPercentage, endValue.bottomLeftHorizontalRadiusAsPercentage, t);\n+\n+        return new CornerRadii(\n+            topLeftHorizontalRadius, topLeftVerticalRadius,\n+            topRightVerticalRadius, topRightHorizontalRadius,\n+            bottomRightHorizontalRadius, bottomRightVerticalRadius,\n+            bottomLeftVerticalRadius, bottomLeftHorizontalRadius,\n+            endValue.topLeftHorizontalRadiusAsPercentage, endValue.topLeftVerticalRadiusAsPercentage,\n+            endValue.topRightVerticalRadiusAsPercentage, endValue.topRightHorizontalRadiusAsPercentage,\n+            endValue.bottomRightHorizontalRadiusAsPercentage, endValue.bottomRightVerticalRadiusAsPercentage,\n+            endValue.bottomLeftVerticalRadiusAsPercentage, endValue.bottomLeftHorizontalRadiusAsPercentage);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/CornerRadii.java","additions":71,"deletions":3,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1941,1 +1941,2 @@\n-        if (t <= 0.0) return this;\n+        \/\/ If both instances are equal, return this instance to prevent the creation of numerous small objects.\n+        if (t <= 0.0 || equals(endValue)) return this;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/Color.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -133,1 +135,1 @@\n-public final class ImagePattern extends Paint {\n+public final class ImagePattern extends Paint implements Interpolatable<ImagePattern> {\n@@ -273,0 +275,33 @@\n+    @Override\n+    public ImagePattern interpolate(ImagePattern endValue, double t) {\n+        if (t <= 0 || equals(endValue)) {\n+            return this;\n+        }\n+\n+        if (t >= 1 || proportional != endValue.proportional) {\n+            return endValue;\n+        }\n+\n+        return new ImagePattern(\n+            endValue.image,\n+            Utils.interpolate(x, endValue.x, t),\n+            Utils.interpolate(y, endValue.y, t),\n+            Utils.interpolate(width, endValue.width, t),\n+            Utils.interpolate(height, endValue.height, t),\n+            endValue.proportional);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof ImagePattern other) {\n+            return proportional == other.proportional\n+                && x == other.x\n+                && y == other.y\n+                && width == other.width\n+                && height == other.height\n+                && image.equals(other.image);\n+        }\n+\n+        return false;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/ImagePattern.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -75,1 +77,1 @@\n-public final class LinearGradient extends Paint {\n+public final class LinearGradient extends Paint implements Interpolatable<LinearGradient> {\n@@ -267,0 +269,18 @@\n+    \/**\n+     * Private constructor accepting a stop list that is already normalized.\n+     * This constructor is only called from the {@link #interpolate} method.\n+     *\/\n+    private LinearGradient(\n+            double startX, double startY, double endX, double endY,\n+            boolean proportional, CycleMethod cycleMethod, List<Stop> stops,\n+            int ignored) {\n+        this.startX = startX;\n+        this.startY = startY;\n+        this.endX = endX;\n+        this.endY = endY;\n+        this.proportional = proportional;\n+        this.cycleMethod = cycleMethod;\n+        this.stops = stops;\n+        this.opaque = determineOpacity();\n+    }\n+\n@@ -293,0 +313,39 @@\n+    @Override\n+    public LinearGradient interpolate(LinearGradient endValue, double t) {\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0.0) {\n+            return this;\n+        }\n+\n+        if (t >= 1.0 || proportional != endValue.proportional) {\n+            return endValue;\n+        }\n+\n+        double newStartX = Utils.interpolate(this.startX, endValue.startX, t);\n+        double newStartY = Utils.interpolate(this.startY, endValue.startY, t);\n+        double newEndX = Utils.interpolate(this.endX, endValue.endX, t);\n+        double newEndY = Utils.interpolate(this.endY, endValue.endY, t);\n+        List<Stop> newStops = Stop.interpolateLists(this.stops, endValue.stops, t);\n+\n+        if (cycleMethod == endValue.cycleMethod\n+                && isSame(newStartX, newStartY, newEndX, newEndY, newStops)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newStartX, newStartY, newEndX, newEndY, newStops)) {\n+            return endValue;\n+        }\n+\n+        return new LinearGradient(newStartX, newStartY, newEndX, newEndY,\n+                                  endValue.proportional, endValue.cycleMethod, newStops, 0);\n+    }\n+\n+    private boolean isSame(double startX, double startY, double endX, double endY, List<Stop> stops) {\n+        return this.startX == startX\n+            && this.startY == startY\n+            && this.endX == endX\n+            && this.endY == endY\n+            && this.stops == stops;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/LinearGradient.java","additions":61,"deletions":2,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -68,1 +70,1 @@\n-public final class RadialGradient extends Paint {\n+public final class RadialGradient extends Paint implements Interpolatable<RadialGradient> {\n@@ -288,0 +290,18 @@\n+    \/**\n+     * Private constructor accepting a stop list that is already normalized.\n+     * This constructor is only called from the {@link #interpolate} method.\n+     *\/\n+    private RadialGradient(\n+            double focusAngle, double focusDistance, double centerX, double centerY, double radius,\n+            boolean proportional, CycleMethod cycleMethod, List<Stop> stops, int ignored) {\n+        this.focusAngle = focusAngle;\n+        this.focusDistance = focusDistance;\n+        this.centerX = centerX;\n+        this.centerY = centerY;\n+        this.radius = radius;\n+        this.proportional = proportional;\n+        this.cycleMethod = cycleMethod;\n+        this.stops = stops;\n+        this.opaque = determineOpacity();\n+    }\n+\n@@ -314,0 +334,42 @@\n+    @Override\n+    public RadialGradient interpolate(RadialGradient endValue, double t) {\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0.0) {\n+            return this;\n+        }\n+\n+        if (t >= 1.0 || proportional != endValue.proportional) {\n+            return endValue;\n+        }\n+\n+        double newFocusAngle = Utils.interpolate(this.focusAngle, endValue.focusAngle, t);\n+        double newFocusDistance = Utils.interpolate(this.focusDistance, endValue.focusDistance, t);\n+        double newCenterX = Utils.interpolate(this.centerX, endValue.centerX, t);\n+        double newCenterY = Utils.interpolate(this.centerY, endValue.centerY, t);\n+        double newRadius = Utils.interpolate(this.radius, endValue.radius, t);\n+        List<Stop> newStops = Stop.interpolateLists(this.stops, endValue.stops, t);\n+\n+        if (cycleMethod == endValue.cycleMethod\n+                && isSame(newFocusAngle, newFocusDistance, newCenterX, newCenterY, newRadius, newStops)) {\n+            return this;\n+        }\n+\n+        if (endValue.isSame(newFocusAngle, newFocusDistance, newCenterX, newCenterY, newRadius, newStops)) {\n+            return endValue;\n+        }\n+\n+        return new RadialGradient(newFocusAngle, newFocusDistance, newCenterX, newCenterY, newRadius,\n+                                  endValue.proportional, endValue.cycleMethod, newStops, 0);\n+    }\n+\n+    private boolean isSame(double focusAngle, double focusDistance, double centerX, double centerY,\n+                           double radius, List<Stop> stops) {\n+        return this.focusAngle == focusAngle\n+            && this.focusDistance == focusDistance\n+            && this.centerX == centerX\n+            && this.centerY == centerY\n+            && this.radius == radius\n+            && this.stops == stops;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/RadialGradient.java","additions":64,"deletions":2,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,4 @@\n+import java.util.Objects;\n+import com.sun.javafx.UnmodifiableArrayList;\n+import com.sun.javafx.util.Utils;\n+import javafx.animation.Interpolatable;\n@@ -49,1 +53,1 @@\n-public final class Stop {\n+public final class Stop implements Interpolatable<Stop> {\n@@ -68,1 +72,1 @@\n-            if (s == null || s.getColor() == null) continue;\n+            if (s == null) continue;\n@@ -134,0 +138,73 @@\n+    \/**\n+     * Interpolates between two lists of stops.\n+     *\n+     * @param firstList the first list, not {@code null}\n+     * @param secondList the second list, not {@code null}\n+     * @return a new unmodifiable list, or {@code firstList} when {@code t <= 0} or both lists are equal\n+     *\/\n+    static List<Stop> interpolateLists(List<Stop> firstList, List<Stop> secondList, double t) {\n+        Objects.requireNonNull(firstList, \"firstList cannot be null\");\n+        Objects.requireNonNull(secondList, \"secondList cannot be null\");\n+\n+        if (t <= 0 || firstList.equals(secondList)) {\n+            return firstList;\n+        }\n+\n+        if (t >= 1) {\n+            return secondList;\n+        }\n+\n+        \/\/ We need a new list that is at most the combined size of firstList and secondList.\n+        \/\/ In many cases we don't need all of that capacity, but allocating once is better than\n+        \/\/ re-allocating when we run out of space. In general, we expect the size of stop lists\n+        \/\/ to be quite small (a single-digit number of stops at most).\n+        Stop[] stops = new Stop[firstList.size() + secondList.size()];\n+        int size = 0;\n+\n+        for (int i = 0, j = 0, imax = firstList.size(), jmax = secondList.size(); i < imax && j < jmax; ++size) {\n+            Stop first = firstList.get(i);\n+            Stop second = secondList.get(j);\n+\n+            if (first.offset == second.offset) {\n+                stops[size] = first.color.equals(second.color) ?\n+                    first : new Stop(first.offset, first.color.interpolate(second.color, t));\n+                ++i;\n+                ++j;\n+            } else if (first.offset < second.offset) {\n+                stops[size] = j == 0 ?\n+                    new Stop(first.offset, second.color) :\n+                    interpolateVirtualStop(first, second, secondList.get(j - 1), t);\n+                ++i;\n+            } else {\n+                stops[size] = i == 0 ?\n+                    new Stop(second.offset, first.color) :\n+                    interpolateVirtualStop(second, first, firstList.get(i - 1), t);\n+                ++j;\n+            }\n+        }\n+\n+        return new UnmodifiableArrayList<>(stops, size);\n+    }\n+\n+    \/**\n+     * Consider two lists A and B, where A contains three stops, and B contains two stops:\n+     * <pre>{@code\n+     *               A2\n+     *             \/   \\\n+     *           \/      \\\n+     *    B1---\/----[X]--\\--B2\n+     *       \/            \\\n+     *     \/               \\\n+     *   A1                 A3\n+     * }<\/pre>\n+     *\n+     * Given the stops A{1,2,3} and B{1,2} in the diagram above, this method computes a new virtual\n+     * stop X that matches the offset of A2, and then interpolates between A2 and X.\n+     *\/\n+    private static Stop interpolateVirtualStop(Stop A2, Stop B2, Stop B1, double t) {\n+        double u = (A2.offset - B1.offset) \/ (B2.offset - B1.offset);\n+        Color colorX = B1.color.interpolate(B2.color, u);\n+        Color colorR = A2.color.interpolate(colorX, t);\n+        return colorR.equals(A2.color) ? A2 : new Stop(A2.offset, colorR);\n+    }\n+\n@@ -143,1 +220,1 @@\n-    private double offset;\n+    private final double offset;\n@@ -164,1 +241,1 @@\n-    private Color color;\n+    private final Color color;\n@@ -184,0 +261,1 @@\n+     * @throws NullPointerException if {@code color} is null\n@@ -187,1 +265,31 @@\n-        this.color = color;\n+        this.color = Objects.requireNonNull(color, \"color cannot be null\");\n+    }\n+\n+    @Override\n+    public Stop interpolate(Stop endValue, double t) {\n+        \/\/ We don't check equals(endValue) here to prevent unnecessary equality checks,\n+        \/\/ and only check for equality with 'this' or 'endValue' after interpolation.\n+        if (t <= 0.0) {\n+            return this;\n+        }\n+\n+        if (t >= 1.0) {\n+            return endValue;\n+        }\n+\n+        double offset = Utils.interpolate(this.offset, endValue.offset, t);\n+\n+        \/\/ Color is implemented such that interpolate() always returns the existing instance if the\n+        \/\/ intermediate value is equal to the start value or the end value, which allows us to use an\n+        \/\/ identity comparison in place of a value comparison to determine equality.\n+        Color color = this.color.interpolate(endValue.color, t);\n+\n+        if (offset == this.offset && color == this.color) {\n+            return this;\n+        }\n+\n+        if (offset == endValue.offset && color == endValue.color) {\n+            return endValue;\n+        }\n+\n+        return new Stop(offset, color);\n@@ -198,4 +306,2 @@\n-        if (obj instanceof Stop) {\n-            Stop other = (Stop) obj;\n-            return offset == other.offset &&\n-              (color == null ? other.color == null : color.equals(other.color));\n+        if (obj instanceof Stop other) {\n+            return offset == other.offset && color.equals(other.color);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/Stop.java","additions":116,"deletions":10,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.paint;\n+\n+import java.util.List;\n+\n+public final class StopShim {\n+\n+    private StopShim() {}\n+\n+    public static List<Stop> interpolateLists(List<Stop> firstList, List<Stop> secondList, double t) {\n+        return Stop.interpolateLists(firstList, secondList, t);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/javafx\/scene\/paint\/StopShim.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+--add-exports javafx.graphics\/com.sun.javafx.scene.paint=ALL-UNNAMED\n","filename":"modules\/javafx.graphics\/src\/test\/addExports","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,2 @@\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -34,1 +32,1 @@\n-import org.junit.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -65,0 +63,26 @@\n+    }\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenTwoDifferentValuesReturnsNewInstance() {\n+            var a = new Insets(2, 4, 6, 8);\n+            var b = new Insets(4, 8, 12, 16);\n+            var expected = new Insets(3, 6, 9, 12);\n+            assertEquals(expected, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsStartInstance() {\n+            var a = new Insets(2, 4, 6, 8);\n+            var b = new Insets(2, 4, 6, 8);\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var a = new Insets(2, 4, 6, 8);\n+            var b = new Insets(4, 8, 12, 16);\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -1));\n+        }\n@@ -66,0 +90,7 @@\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var a = new Insets(2, 4, 6, 8);\n+            var b = new Insets(4, 8, 12, 16);\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/geometry\/InsetsTest.java","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.scene.paint.PaintUtils;\n@@ -29,0 +30,1 @@\n+import javafx.scene.image.Image;\n@@ -32,1 +34,6 @@\n-import org.junit.Test;\n+import javafx.scene.paint.ImagePattern;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.RadialGradient;\n+import java.io.ByteArrayInputStream;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -34,1 +41,1 @@\n-import static org.junit.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -40,1 +47,2 @@\n-    @Test public void nullPaintDefaultsToTransparent() {\n+    @Test\n+    public void nullPaintDefaultsToTransparent() {\n@@ -100,0 +108,108 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void twoColorFills() {\n+            BackgroundFill a = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            BackgroundFill b = new BackgroundFill(Color.RED, new CornerRadii(4), new Insets(6));\n+            BackgroundFill r = a.interpolate(b, 0.5);\n+            assertEquals(Color.ORANGE.interpolate(Color.RED, 0.5), r.getFill());\n+            assertEquals(new CornerRadii(3), r.getRadii());\n+            assertEquals(new Insets(4), r.getInsets());\n+        }\n+\n+        @Test\n+        public void twoLinearGradientFills() {\n+            var gradient1 = LinearGradient.valueOf(\"linear-gradient(to left top, red, blue)\");\n+            var gradient2 = LinearGradient.valueOf(\"linear-gradient(to left top, yellow, white)\");\n+            BackgroundFill a = new BackgroundFill(gradient1, new CornerRadii(2), new Insets(2));\n+            BackgroundFill b = new BackgroundFill(gradient2, new CornerRadii(4), new Insets(6));\n+            BackgroundFill r = a.interpolate(b, 0.5);\n+            assertEquals(gradient1.interpolate(gradient2, 0.5), r.getFill());\n+            assertEquals(new CornerRadii(3), r.getRadii());\n+            assertEquals(new Insets(4), r.getInsets());\n+        }\n+\n+        @Test\n+        public void linearGradientAndColorFills() {\n+            var gradient = LinearGradient.valueOf(\"linear-gradient(to left top, red, blue)\");\n+            BackgroundFill a = new BackgroundFill(gradient, new CornerRadii(2), new Insets(2));\n+            BackgroundFill b = new BackgroundFill(Color.ORANGE, new CornerRadii(4), new Insets(6));\n+\n+            BackgroundFill r = a.interpolate(b, 0.5);\n+            assertEquals(gradient.interpolate(PaintUtils.newSolidGradient(gradient, Color.ORANGE), 0.5), r.getFill());\n+            assertEquals(new CornerRadii(3), r.getRadii());\n+            assertEquals(new Insets(4), r.getInsets());\n+\n+            r = b.interpolate(a, 0.5);\n+            assertEquals(PaintUtils.newSolidGradient(gradient, Color.ORANGE).interpolate(gradient, 0.5), r.getFill());\n+            assertEquals(new CornerRadii(3), r.getRadii());\n+            assertEquals(new Insets(4), r.getInsets());\n+        }\n+\n+        @Test\n+        public void twoRadialGradientFills() {\n+            var gradient1 = RadialGradient.valueOf(\"radial-gradient(radius 100%, red, blue)\");\n+            var gradient2 = RadialGradient.valueOf(\"radial-gradient(radius 50%, yellow, white)\");\n+            BackgroundFill a = new BackgroundFill(gradient1, new CornerRadii(2), new Insets(2));\n+            BackgroundFill b = new BackgroundFill(gradient2, new CornerRadii(4), new Insets(6));\n+            BackgroundFill r = a.interpolate(b, 0.5);\n+            assertEquals(gradient1.interpolate(gradient2, 0.5), r.getFill());\n+            assertEquals(new CornerRadii(3), r.getRadii());\n+            assertEquals(new Insets(4), r.getInsets());\n+        }\n+\n+        @Test\n+        public void radialGradientAndColorFills() {\n+            var gradient = RadialGradient.valueOf(\"radial-gradient(radius 100%, red, blue)\");\n+            BackgroundFill a = new BackgroundFill(gradient, new CornerRadii(2), new Insets(2));\n+            BackgroundFill b = new BackgroundFill(Color.ORANGE, new CornerRadii(4), new Insets(6));\n+\n+            BackgroundFill r = a.interpolate(b, 0.5);\n+            assertEquals(gradient.interpolate(PaintUtils.newSolidGradient(gradient, Color.ORANGE), 0.5), r.getFill());\n+            assertEquals(new CornerRadii(3), r.getRadii());\n+            assertEquals(new Insets(4), r.getInsets());\n+\n+            r = b.interpolate(a, 0.5);\n+            assertEquals(PaintUtils.newSolidGradient(gradient, Color.ORANGE).interpolate(gradient, 0.5), r.getFill());\n+            assertEquals(new CornerRadii(3), r.getRadii());\n+            assertEquals(new Insets(4), r.getInsets());\n+        }\n+\n+        @Test\n+        public void incompatibleFillsReturnsEndFillWhenInterpolationFactorIsLargerThanZero() {\n+            var pattern = new ImagePattern(new Image(new ByteArrayInputStream(new byte[] {})));\n+            BackgroundFill a = new BackgroundFill(pattern, new CornerRadii(2), new Insets(2));\n+            BackgroundFill b = new BackgroundFill(Color.RED, new CornerRadii(4), new Insets(6));\n+            BackgroundFill c = a.interpolate(b, 0);\n+            assertSame(a, c);\n+\n+            c = a.interpolate(b, 0.5);\n+            assertEquals(b.getFill(), c.getFill());\n+            assertEquals(new CornerRadii(3), c.getRadii());\n+            assertEquals(new Insets(4), c.getInsets());\n+        }\n+\n+        @Test\n+        public void twoEqualFillsReturnsExistingInstance() {\n+            BackgroundFill a = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            BackgroundFill b = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            BackgroundFill a = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            BackgroundFill b = new BackgroundFill(Color.RED, new CornerRadii(4), new Insets(6));\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            BackgroundFill a = new BackgroundFill(Color.ORANGE, new CornerRadii(2), new Insets(2));\n+            BackgroundFill b = new BackgroundFill(Color.RED, new CornerRadii(4), new Insets(6));\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundFillTest.java","additions":120,"deletions":4,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n-import org.junit.Test;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -36,1 +37,1 @@\n-import static org.junit.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -68,1 +69,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -70,1 +71,1 @@\n-        new BackgroundImage(null, NO_REPEAT, ROUND, POS_2, SIZE_2);\n+        assertThrows(NullPointerException.class, () -> new BackgroundImage(null, NO_REPEAT, ROUND, POS_2, SIZE_2));\n@@ -221,0 +222,53 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        final BackgroundImage BACKGROUND_IMAGE_A = new BackgroundImage(\n+            IMAGE_1, NO_REPEAT, NO_REPEAT,\n+            new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false),\n+            new BackgroundSize(50, 100, false, false, false, false));\n+\n+        final BackgroundImage BACKGROUND_IMAGE_B = new BackgroundImage(\n+            IMAGE_2, REPEAT, SPACE,\n+            new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false),\n+            new BackgroundSize(100, 200, false, false, false, false));\n+\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var expect = new BackgroundImage(\n+                IMAGE_2, REPEAT, SPACE,\n+                new BackgroundPosition(Side.LEFT, 5, false, Side.TOP, 10, false),\n+                new BackgroundSize(75, 150, false, false, false, false));\n+\n+            var actual = BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, 0.5);\n+\n+            assertEquals(expect, actual);\n+            assertNotSame(expect, actual);\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var a = new BackgroundImage(\n+                IMAGE_1, NO_REPEAT, NO_REPEAT,\n+                new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false),\n+                new BackgroundSize(50, 100, false, false, false, false));\n+\n+            var b = new BackgroundImage(\n+                IMAGE_1, NO_REPEAT, NO_REPEAT,\n+                new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false),\n+                new BackgroundSize(50, 100, false, false, false, false));\n+\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            assertSame(BACKGROUND_IMAGE_A, BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, 0));\n+            assertSame(BACKGROUND_IMAGE_A, BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            assertSame(BACKGROUND_IMAGE_B, BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, 1));\n+            assertSame(BACKGROUND_IMAGE_B, BACKGROUND_IMAGE_A.interpolate(BACKGROUND_IMAGE_B, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundImageTest.java","additions":59,"deletions":5,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,2 @@\n-import org.junit.Test;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -32,1 +33,1 @@\n-import static org.junit.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -37,1 +38,2 @@\n-    @Test public void valuesAreCorrectAfterConstruction() {\n+    @Test\n+    public void valuesAreCorrectAfterConstruction() {\n@@ -64,1 +66,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -66,1 +68,3 @@\n-        new BackgroundPosition(Side.TOP, 10, true, Side.BOTTOM, 20, true);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundPosition(Side.TOP, 10, true, Side.BOTTOM, 20, true));\n@@ -69,1 +73,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -71,1 +75,3 @@\n-        new BackgroundPosition(Side.BOTTOM, 10, true, Side.BOTTOM, 20, true);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundPosition(Side.BOTTOM, 10, true, Side.BOTTOM, 20, true));\n@@ -84,1 +90,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -86,1 +92,3 @@\n-        new BackgroundPosition(Side.LEFT, 10, true, Side.LEFT, 20, true);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundPosition(Side.LEFT, 10, true, Side.LEFT, 20, true));\n@@ -89,1 +97,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -91,1 +99,3 @@\n-        new BackgroundPosition(Side.LEFT, 10, true, Side.RIGHT, 20, true);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundPosition(Side.LEFT, 10, true, Side.RIGHT, 20, true));\n@@ -170,0 +180,55 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var a = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var b = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            var expected = new BackgroundPosition(Side.LEFT, 5, false, Side.TOP, 10, false);\n+            assertEquals(expected, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var a = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            var b = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var a = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var b = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var a = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var b = new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 20, false);\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n+\n+        @Test\n+        public void percentageAndAbsolutePositionsCannotBeInterpolated() {\n+            var a = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var b = new BackgroundPosition(Side.LEFT, 10, true, Side.TOP, 20, true);\n+            assertEquals(a, a.interpolate(b, 0)); \/\/ equal to 'a' for t == 0\n+            assertEquals(b, a.interpolate(b, 0.1)); \/\/ equal to 'b' otherwise\n+        }\n+\n+        @Test\n+        public void differentSidesCannotBeInterpolated() {\n+            var a = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            var b = new BackgroundPosition(Side.RIGHT, 10, false, Side.TOP, 20, false);\n+            var expect = new BackgroundPosition(Side.RIGHT, 10, false, Side.TOP, 10, false);\n+            assertEquals(expect, a.interpolate(b, 0.5));\n+\n+            a = new BackgroundPosition(Side.LEFT, 0, false, Side.TOP, 0, false);\n+            b = new BackgroundPosition(Side.LEFT, 10, false, Side.BOTTOM, 20, false);\n+            expect = new BackgroundPosition(Side.LEFT, 5, false, Side.BOTTOM, 20, false);\n+            assertEquals(expect, a.interpolate(b, 0.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundPositionTest.java","additions":77,"deletions":12,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,3 @@\n-import org.junit.Ignore;\n-import org.junit.Test;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -32,1 +33,2 @@\n-import static org.junit.Assert.*;\n+import static javafx.scene.layout.BackgroundSize.AUTO;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -37,1 +39,2 @@\n-    @Test public void instanceCreation() {\n+    @Test\n+    public void instanceCreation() {\n@@ -67,1 +70,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -69,1 +72,3 @@\n-        new BackgroundSize(-.2, 1, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(-.2, 1, true, true, false, false));\n@@ -72,1 +77,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -74,1 +79,3 @@\n-        new BackgroundSize(-2, 1, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(-2, 1, true, true, false, false));\n@@ -77,2 +84,2 @@\n-    @Ignore(\"JDK-8234090\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Disabled(\"JDK-8234090\")\n+    @Test\n@@ -80,1 +87,3 @@\n-        new BackgroundSize(Double.POSITIVE_INFINITY, 1, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(Double.POSITIVE_INFINITY, 1, true, true, false, false));\n@@ -83,2 +92,2 @@\n-    @Ignore(\"JDK-8234090\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Disabled(\"JDK-8234090\")\n+    @Test\n@@ -86,1 +95,3 @@\n-        new BackgroundSize(Double.NEGATIVE_INFINITY, 1, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(Double.NEGATIVE_INFINITY, 1, true, true, false, false));\n@@ -89,2 +100,2 @@\n-    @Ignore(\"JDK-8234090\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Disabled(\"JDK-8234090\")\n+    @Test\n@@ -92,1 +103,3 @@\n-        new BackgroundSize(Double.NaN, 1, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(Double.NaN, 1, true, true, false, false));\n@@ -102,1 +115,1 @@\n-        assertEquals(BackgroundSize.AUTO, size.getWidth(), 0);\n+        assertEquals(AUTO, size.getWidth(), 0);\n@@ -105,1 +118,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -107,1 +120,3 @@\n-        new BackgroundSize(1, -.1, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(1, -.1, true, true, false, false));\n@@ -110,1 +125,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -112,1 +127,3 @@\n-        new BackgroundSize(1, -2, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(1, -2, true, true, false, false));\n@@ -115,2 +132,2 @@\n-    @Ignore(\"JDK-8234090\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Disabled(\"JDK-8234090\")\n+    @Test\n@@ -118,1 +135,3 @@\n-        new BackgroundSize(1, Double.POSITIVE_INFINITY, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(1, Double.POSITIVE_INFINITY, true, true, false, false));\n@@ -121,2 +140,2 @@\n-    @Ignore(\"JDK-8234090\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Disabled(\"JDK-8234090\")\n+    @Test\n@@ -124,1 +143,3 @@\n-        new BackgroundSize(1, Double.NEGATIVE_INFINITY, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(1, Double.NEGATIVE_INFINITY, true, true, false, false));\n@@ -127,2 +148,2 @@\n-    @Ignore(\"JDK-8234090\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Disabled(\"JDK-8234090\")\n+    @Test\n@@ -130,1 +151,3 @@\n-        new BackgroundSize(1, Double.NaN, true, true, false, false);\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> new BackgroundSize(1, Double.NaN, true, true, false, false));\n@@ -140,1 +163,1 @@\n-        assertEquals(BackgroundSize.AUTO, size.getHeight(), 0);\n+        assertEquals(AUTO, size.getHeight(), 0);\n@@ -249,0 +272,62 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var a = new BackgroundSize(10, 20, false, false, false, false);\n+            var b = new BackgroundSize(20, 40, false, false, false, false);\n+            var expect = new BackgroundSize(15, 30, false, false, false, false);\n+            assertEquals(expect, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var a = new BackgroundSize(10, 20, false, false, false, false);\n+            var b = new BackgroundSize(10, 20, false, false, false, false);\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var a = new BackgroundSize(10, 20, false, false, false, false);\n+            var b = new BackgroundSize(20, 40, false, false, false, false);\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var a = new BackgroundSize(10, 20, false, false, false, false);\n+            var b = new BackgroundSize(20, 40, false, false, false, false);\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n+\n+        @Test\n+        public void widthOrHeightLessThanZeroCannotBeInterpolated() {\n+            var a = new BackgroundSize(10, 20, false, false, false, false);\n+            var b = new BackgroundSize(AUTO, 40, false, false, false, false);\n+            var expect = new BackgroundSize(AUTO, 30, false, false, false, false);\n+            assertEquals(expect, a.interpolate(b, 0.5));\n+\n+            a = new BackgroundSize(20, 10, false, false, false, false);\n+            b = new BackgroundSize(40, AUTO, false, false, false, false);\n+            expect = new BackgroundSize(30, AUTO, false, false, false, false);\n+            assertEquals(expect, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void notInterpolatableReturnsEndInstance() {\n+            var a = new BackgroundSize(10, 10, false, false, false, true);\n+            var b = new BackgroundSize(20, 20, false, false, false, false);\n+            assertSame(b, a.interpolate(b, 0.5));\n+\n+            a = new BackgroundSize(10, 10, false, false, false, false);\n+            b = new BackgroundSize(20, 20, false, false, true, false);\n+            assertSame(b, a.interpolate(b, 0.5));\n+\n+            a = new BackgroundSize(AUTO, AUTO, false, false, false, false);\n+            b = new BackgroundSize(20, 20, false, false, false, false);\n+            assertSame(b, a.interpolate(b, 0.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundSizeTest.java","additions":118,"deletions":33,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import javafx.scene.layout.BackgroundSize;\n@@ -38,1 +39,3 @@\n-import org.junit.Test;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import java.util.List;\n@@ -41,1 +44,1 @@\n-import static org.junit.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -69,1 +72,2 @@\n-    @Test public void instanceCreation() {\n+    @Test\n+    public void instanceCreation() {\n@@ -234,1 +238,1 @@\n-    @Test(expected = UnsupportedOperationException.class)\n+    @Test\n@@ -239,1 +243,2 @@\n-        b.getFills().add(new BackgroundFill(Color.BLUE, new CornerRadii(6), new Insets(8)));\n+        assertThrows(UnsupportedOperationException.class,\n+            () -> b.getFills().add(new BackgroundFill(Color.BLUE, new CornerRadii(6), new Insets(8))));\n@@ -242,1 +247,1 @@\n-    @Test(expected = UnsupportedOperationException.class)\n+    @Test\n@@ -247,1 +252,2 @@\n-        b.getImages().add(new BackgroundImage(IMAGE_3, ROUND, ROUND, null, null));\n+        assertThrows(UnsupportedOperationException.class,\n+            () -> b.getImages().add(new BackgroundImage(IMAGE_3, ROUND, ROUND, null, null)));\n@@ -722,1 +728,1 @@\n-        assertEquals(\"The factory method should give the same result as the constructor\", background1, background2);\n+        assertEquals(background1, background2, \"The factory method should give the same result as the constructor\");\n@@ -729,1 +735,87 @@\n-        assertEquals(\"The factory method should give the same result as the constructor\", background1, background2);\n+        assertEquals(background1, background2, \"The factory method should give the same result as the constructor\");\n+    }\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var a = new Background(\n+                List.of(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)),\n+                        new BackgroundFill(Color.BLUE, new CornerRadii(2), new Insets(2))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 5, false),\n+                                            new BackgroundSize(10, 10, false, false, false, false))));\n+\n+            var b = new Background(\n+                List.of(new BackgroundFill(Color.GREEN, new CornerRadii(20), new Insets(20)),\n+                        new BackgroundFill(Color.YELLOW, new CornerRadii(6), new Insets(6))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 20, false, Side.TOP, 15, false),\n+                                            new BackgroundSize(20, 30, false, false, false, false))));\n+\n+            var expect = new Background(\n+                List.of(new BackgroundFill(Color.RED.interpolate(Color.GREEN, 0.5), new CornerRadii(15), new Insets(15)),\n+                        new BackgroundFill(Color.BLUE.interpolate(Color.YELLOW, 0.5), new CornerRadii(4), new Insets(4))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 15, false, Side.TOP, 10, false),\n+                                            new BackgroundSize(15, 20, false, false, false, false))));\n+\n+            var actual = a.interpolate(b, 0.5);\n+\n+            assertEquals(expect, actual);\n+            assertNotSame(expect, actual);\n+        }\n+\n+        @Test\n+        public void interpolateBetweenDifferentNumberOfFillsAndImages() {\n+            var a = new Background(\n+                List.of(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 10, false, Side.TOP, 5, false),\n+                                            new BackgroundSize(10, 10, false, false, false, false))));\n+\n+            var b = new Background(\n+                List.of(new BackgroundFill(Color.GREEN, new CornerRadii(20), new Insets(20)),\n+                        new BackgroundFill(Color.BLUE, new CornerRadii(2), new Insets(2))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 20, false, Side.TOP, 15, false),\n+                                            new BackgroundSize(20, 30, false, false, false, false)),\n+                        new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 30, false, Side.TOP, 40, false),\n+                                            new BackgroundSize(50, 60, false, false, false, false))));\n+\n+            var expect = new Background(\n+                List.of(new BackgroundFill(Color.RED.interpolate(Color.GREEN, 0.5), new CornerRadii(15), new Insets(15)),\n+                        new BackgroundFill(Color.BLUE, new CornerRadii(2), new Insets(2))),\n+                List.of(new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 15, false, Side.TOP, 10, false),\n+                                            new BackgroundSize(15, 20, false, false, false, false)),\n+                        new BackgroundImage(IMAGE_1, REPEAT, REPEAT,\n+                                            new BackgroundPosition(Side.LEFT, 30, false, Side.TOP, 40, false),\n+                                            new BackgroundSize(50, 60, false, false, false, false))));\n+\n+            assertEquals(expect, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var a = new Background(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)));\n+            var b = new Background(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)));\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var a = new Background(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)));\n+            var b = new Background(new BackgroundFill(Color.GREEN, new CornerRadii(15), new Insets(20)));\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var a = new Background(new BackgroundFill(Color.RED, new CornerRadii(10), new Insets(10)));\n+            var b = new Background(new BackgroundFill(Color.GREEN, new CornerRadii(15), new Insets(20)));\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BackgroundTest.java","additions":102,"deletions":10,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.layout;\n+\n+import javafx.geometry.Insets;\n+import javafx.scene.image.Image;\n+import javafx.scene.layout.BorderImage;\n+import javafx.scene.layout.BorderRepeat;\n+import javafx.scene.layout.BorderWidths;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class BorderImageTest {\n+\n+    private static final Image IMAGE_1 = new Image(\"test\/javafx\/scene\/layout\/red.png\");\n+    private static final Image IMAGE_2 = new Image(\"test\/javafx\/scene\/layout\/blue.png\");\n+\n+    @Nested\n+    class InterpolationTests {\n+        final BorderImage BORDER_IMAGE_A = new BorderImage(\n+            IMAGE_1, new BorderWidths(10), new Insets(8), new BorderWidths(6),\n+            false, BorderRepeat.REPEAT, BorderRepeat.REPEAT);\n+\n+        final BorderImage BORDER_IMAGE_B = new BorderImage(\n+            IMAGE_2, new BorderWidths(20), new Insets(4), new BorderWidths(12),\n+            false, BorderRepeat.REPEAT, BorderRepeat.REPEAT);\n+\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var image = new BorderImage(\n+                IMAGE_2, new BorderWidths(15), new Insets(6), new BorderWidths(9),\n+                false, BorderRepeat.REPEAT, BorderRepeat.REPEAT);\n+\n+            assertEquals(image, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var image = new BorderImage(\n+                IMAGE_1, new BorderWidths(10), new Insets(8), new BorderWidths(6),\n+                false, BorderRepeat.REPEAT, BorderRepeat.REPEAT);\n+\n+            assertSame(image, image.interpolate(BORDER_IMAGE_A, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            assertSame(BORDER_IMAGE_A, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, 0));\n+            assertSame(BORDER_IMAGE_A, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            assertSame(BORDER_IMAGE_B, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, 1));\n+            assertSame(BORDER_IMAGE_B, BORDER_IMAGE_A.interpolate(BORDER_IMAGE_B, 1.5));\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BorderImageTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,10 @@\n-import org.junit.Test;\n+import javafx.geometry.Insets;\n+import javafx.scene.layout.BorderStroke;\n+import javafx.scene.layout.BorderWidths;\n+import javafx.scene.layout.CornerRadii;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static javafx.scene.layout.BorderStrokeStyle.*;\n+import static javafx.scene.paint.Color.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -36,0 +45,34 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var a = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            var b = new BorderStroke(GREEN, DOTTED, new CornerRadii(20), new BorderWidths(15), new Insets(6));\n+            var expect = new BorderStroke(RED.interpolate(GREEN, 0.5), DOTTED, new CornerRadii(15), new BorderWidths(10), new Insets(4));\n+            assertEquals(expect, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var a = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            var b = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var a = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            var b = new BorderStroke(GREEN, SOLID, new CornerRadii(20), new BorderWidths(15), new Insets(6));\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var a = new BorderStroke(RED, SOLID, new CornerRadii(10), new BorderWidths(5), new Insets(2));\n+            var b = new BorderStroke(GREEN, SOLID, new CornerRadii(20), new BorderWidths(15), new Insets(6));\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BorderStrokeTest.java","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.List;\n@@ -39,1 +40,2 @@\n-import org.junit.Test;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -42,1 +44,1 @@\n-import static org.junit.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -237,1 +239,1 @@\n-    @Test(expected = UnsupportedOperationException.class)\n+    @Test\n@@ -242,1 +244,2 @@\n-        b.getStrokes().add(new BorderStroke(Color.BLUE, BorderStrokeStyle.SOLID, new CornerRadii(6), new BorderWidths(8)));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+            b.getStrokes().add(new BorderStroke(Color.BLUE, BorderStrokeStyle.SOLID, new CornerRadii(6), new BorderWidths(8))));\n@@ -245,1 +248,1 @@\n-    @Test(expected = UnsupportedOperationException.class)\n+    @Test\n@@ -251,4 +254,5 @@\n-        b.getImages().add(\n-                new BorderImage(\n-                        IMAGE_4, new BorderWidths(3), Insets.EMPTY,\n-                        new BorderWidths(3, 4, 5, 6), true, STRETCH, SPACE));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+            b.getImages().add(\n+                    new BorderImage(\n+                            IMAGE_4, new BorderWidths(3), Insets.EMPTY,\n+                            new BorderWidths(3, 4, 5, 6), true, STRETCH, SPACE)));\n@@ -570,1 +574,1 @@\n-        assertEquals(\"The factory method should give the same result as the constructor\", border2, border1);\n+        assertEquals(border2, border1, \"The factory method should give the same result as the constructor\");\n@@ -577,1 +581,71 @@\n-        assertEquals(\"The factory method should give the same result as the constructor\", border2, border1);\n+        assertEquals(border2, border1, \"The factory method should give the same result as the constructor\");\n+    }\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var a = new Border(\n+                List.of(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)),\n+                        new BorderStroke(Color.BLUE, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20))),\n+                List.of(new BorderImage(IMAGE_1, new BorderWidths(10), new Insets(5), new BorderWidths(10), false, REPEAT, REPEAT)));\n+\n+            var b = new Border(\n+                List.of(new BorderStroke(Color.GREEN, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20)),\n+                        new BorderStroke(Color.YELLOW, BorderStrokeStyle.SOLID, new CornerRadii(40), new BorderWidths(40))),\n+                List.of(new BorderImage(IMAGE_2, new BorderWidths(30), new Insets(15), new BorderWidths(30), false, REPEAT, REPEAT)));\n+\n+            var expect = new Border(\n+                List.of(new BorderStroke(Color.RED.interpolate(Color.GREEN, 0.5), BorderStrokeStyle.SOLID, new CornerRadii(15), new BorderWidths(15)),\n+                        new BorderStroke(Color.BLUE.interpolate(Color.YELLOW, 0.5), BorderStrokeStyle.SOLID, new CornerRadii(30), new BorderWidths(30))),\n+                List.of(new BorderImage(IMAGE_2, new BorderWidths(20), new Insets(10), new BorderWidths(20), false, REPEAT, REPEAT)));\n+\n+            assertEquals(expect, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenDifferentNumberOfStrokesAndImages() {\n+            var a = new Border(\n+                List.of(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10))),\n+                List.of(new BorderImage(IMAGE_1, new BorderWidths(10), new Insets(5), new BorderWidths(10), false, REPEAT, REPEAT)));\n+\n+            var b = new Border(\n+                List.of(new BorderStroke(Color.GREEN, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20)),\n+                        new BorderStroke(Color.YELLOW, BorderStrokeStyle.SOLID, new CornerRadii(40), new BorderWidths(40))),\n+                List.of(new BorderImage(IMAGE_1, new BorderWidths(30), new Insets(15), new BorderWidths(30), false, REPEAT, REPEAT),\n+                        new BorderImage(IMAGE_2, new BorderWidths(30), new Insets(15), new BorderWidths(30), false, REPEAT, REPEAT)));\n+\n+            var expect = new Border(\n+                List.of(new BorderStroke(Color.RED.interpolate(Color.GREEN, 0.5), BorderStrokeStyle.SOLID, new CornerRadii(15), new BorderWidths(15)),\n+                        new BorderStroke(Color.YELLOW, BorderStrokeStyle.SOLID, new CornerRadii(40), new BorderWidths(40))),\n+                List.of(new BorderImage(IMAGE_1, new BorderWidths(20), new Insets(10), new BorderWidths(20), false, REPEAT, REPEAT),\n+                        new BorderImage(IMAGE_2, new BorderWidths(30), new Insets(15), new BorderWidths(30), false, REPEAT, REPEAT)));\n+\n+            var actual = a.interpolate(b, 0.5);\n+\n+            assertEquals(expect, actual);\n+            assertNotSame(expect, actual);\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var a = new Border(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)));\n+            var b = new Border(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)));\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var a = new Border(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)));\n+            var b = new Border(new BorderStroke(Color.GREEN, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20)));\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var a = new Border(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(10), new BorderWidths(10)));\n+            var b = new Border(new BorderStroke(Color.GREEN, BorderStrokeStyle.SOLID, new CornerRadii(20), new BorderWidths(20)));\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BorderTest.java","additions":86,"deletions":12,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n-import org.junit.Test;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -31,1 +32,1 @@\n-import static org.junit.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -38,1 +39,2 @@\n-    @Test public void instanceCreation() {\n+    @Test\n+    public void instanceCreation() {\n@@ -98,1 +100,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -100,1 +102,1 @@\n-        new BorderWidths(-2);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(-2));\n@@ -103,1 +105,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -105,1 +107,1 @@\n-        new BorderWidths(-2, 0, 0, 0, false, false, false, false);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(-2, 0, 0, 0, false, false, false, false));\n@@ -108,1 +110,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -110,1 +112,1 @@\n-        new BorderWidths(-2, 0, 0, 0);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(-2, 0, 0, 0));\n@@ -113,1 +115,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -115,1 +117,1 @@\n-        new BorderWidths(0, -2, 0, 0, false, false, false, false);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(0, -2, 0, 0, false, false, false, false));\n@@ -118,1 +120,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -120,1 +122,1 @@\n-        new BorderWidths(0, -2, 0, 0);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(0, -2, 0, 0));\n@@ -123,1 +125,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -125,1 +127,1 @@\n-        new BorderWidths(0, 0, -2, 0, false, false, false, false);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(0, 0, -2, 0, false, false, false, false));\n@@ -128,1 +130,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -130,1 +132,1 @@\n-        new BorderWidths(0, 0, -2, 0);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(0, 0, -2, 0));\n@@ -133,1 +135,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -135,1 +137,1 @@\n-        new BorderWidths(0, 0, 0, -2, false, false, false, false);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(0, 0, 0, -2, false, false, false, false));\n@@ -138,1 +140,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -140,1 +142,1 @@\n-        new BorderWidths(0, 0, 0, -2);\n+        assertThrows(IllegalArgumentException.class, () -> new BorderWidths(0, 0, 0, -2));\n@@ -209,0 +211,46 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var a = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            var b = new BorderWidths(20, 40, 60, 80, true, false, true, false);\n+            var expect = new BorderWidths(15, 30, 45, 60, true, false, true, false);\n+            assertEquals(expect, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            var a = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            var b = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenAbsoluteAndRelativeValuesReturnsStartInstanceOrNewInstanceEqualToEndValue() {\n+            var a = new BorderWidths(10, 20, 30, 40, false, false, false, false);\n+            var b = new BorderWidths(10, 20, 30, 40, true, false, false, false);\n+            assertSame(a, a.interpolate(b, 0)); \/\/ start value for t == 0\n+\n+            var v = a.interpolate(b, 0.5); \/\/ new instance for t > 0\n+            assertEquals(b, v);\n+            assertNotSame(a, v);\n+            assertNotSame(b, v);\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var a = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            var b = new BorderWidths(20, 40, 60, 80, true, false, true, false);\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var a = new BorderWidths(10, 20, 30, 40, true, false, true, false);\n+            var b = new BorderWidths(20, 40, 60, 80, true, false, true, false);\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BorderWidthsTest.java","additions":70,"deletions":22,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,31 @@\n+    @Test\n+    public void equality() {\n+        for (int i = 0; i < 8; ++i) {\n+            double[] r = new double[8];\n+            boolean[] p = new boolean[8];\n+\n+            r[i] = 1;\n+            p[i] = true;\n+\n+            var expected = new CornerRadii(\n+                r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7],\n+                p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);\n+\n+            var a = new CornerRadii(\n+                r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7],\n+                p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);\n+\n+            assertEquals(expected, a);\n+\n+            \/\/ change one radius at a time\n+            r[i] = 0;\n+            p[i] = false;\n+\n+            var b = new CornerRadii(\n+                r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7],\n+                p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);\n+\n+            assertNotEquals(expected, b);\n+        }\n+    }\n+\n@@ -126,0 +157,59 @@\n+\n+    @Nested\n+    class InterpolationTests {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            \/\/ non-uniform values\n+            var a = new CornerRadii(10, 20, 30, 40, false);\n+            var b = new CornerRadii(20, 40, 60, 80, false);\n+            var expect = new CornerRadii(15, 30, 45, 60, false);\n+            assertEquals(expect, a.interpolate(b, 0.5));\n+\n+            \/\/ uniform values\n+            a = new CornerRadii(10, 10, 10, 10, false);\n+            b = new CornerRadii(20, 20, 20, 20, false);\n+            expect = new CornerRadii(15, 15, 15, 15, false);\n+            assertEquals(expect, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenEqualValuesReturnsStartInstance() {\n+            \/\/ non-uniform values\n+            var a = new CornerRadii(10, 20, 30, 40, false);\n+            var b = new CornerRadii(10, 20, 30, 40, false);\n+            assertSame(a, a.interpolate(b, 0.5));\n+\n+            \/\/ uniform values\n+            a = new CornerRadii(10, 10, 10, 10, false);\n+            b = new CornerRadii(10, 10, 10, 10, false);\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenAbsoluteAndRelativeValuesReturnsStartInstanceOrNewInstanceEqualToEndValue() {\n+            var a = new CornerRadii(10, 20, 30, 40, false);\n+            var b = new CornerRadii(0.5, 0.6, 0.7, 0.8, true);\n+            assertSame(a, a.interpolate(b, 0)); \/\/ start value for t == 0\n+\n+            var v = a.interpolate(b, 0.5); \/\/ new instance for t > 0\n+            assertEquals(b, v);\n+            assertNotSame(a, v);\n+            assertNotSame(b, v);\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var a = new CornerRadii(10, 20, 30, 40, false);\n+            var b = new CornerRadii(20, 30, 40, 50, false);\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var a = new CornerRadii(10, 20, 30, 40, false);\n+            var b = new CornerRadii(20, 30, 40, 50, false);\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/CornerRadiiTest.java","additions":91,"deletions":1,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,5 +34,4 @@\n-import org.junit.Test;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -358,1 +357,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -360,1 +359,1 @@\n-        Color.web(\"#aabbccddee\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"#aabbccddee\"));\n@@ -363,1 +362,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -365,1 +364,1 @@\n-        Color.web(null);\n+        assertThrows(NullPointerException.class, () -> Color.web(null));\n@@ -368,1 +367,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -370,1 +369,1 @@\n-        Color.web(\"\", 0.5);\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"\", 0.5));\n@@ -390,1 +389,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -392,1 +391,1 @@\n-        Color.web(\"0xaabbccddee\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"0xaabbccddee\"));\n@@ -429,1 +428,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -431,1 +430,1 @@\n-        Color.web(\"foobar\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"foobar\"));\n@@ -656,1 +655,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -658,1 +657,1 @@\n-        Color.web(\"rgb(100, 100)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgb(100, 100)\"));\n@@ -661,1 +660,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -663,1 +662,1 @@\n-        Color.web(\"rgb(100)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgb(100)\"));\n@@ -666,1 +665,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -668,1 +667,1 @@\n-        Color.web(\"rgb()\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgb()\"));\n@@ -671,1 +670,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -673,1 +672,1 @@\n-        Color.web(\"rgb 100, 100, 100\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgb 100, 100, 100\"));\n@@ -676,1 +675,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -678,1 +677,1 @@\n-        Color.web(\"rgb(100, 100, 100\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgb(100, 100, 100\"));\n@@ -681,1 +680,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -683,1 +682,1 @@\n-        Color.web(\"rgba(100, 100, 100)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgba(100, 100, 100)\"));\n@@ -686,1 +685,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -688,1 +687,1 @@\n-        Color.web(\"rgba(100, 100)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgba(100, 100)\"));\n@@ -691,1 +690,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -693,1 +692,1 @@\n-        Color.web(\"rgba(100)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgba(100)\"));\n@@ -696,1 +695,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -698,1 +697,1 @@\n-        Color.web(\"rgba()\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgba()\"));\n@@ -701,1 +700,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -703,1 +702,1 @@\n-        Color.web(\"rgba 100, 100, 100\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgba 100, 100, 100\"));\n@@ -706,1 +705,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -708,1 +707,1 @@\n-        Color.web(\"rgba(100, 100, 100, 0.5\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"rgba(100, 100, 100, 0.5\"));\n@@ -711,1 +710,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -713,1 +712,1 @@\n-        Color.web(\"hsl(240, 50%)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsl(240, 50%)\"));\n@@ -716,1 +715,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -718,1 +717,1 @@\n-        Color.web(\"hsl(240)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsl(240)\"));\n@@ -721,1 +720,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -723,1 +722,1 @@\n-        Color.web(\"hsl()\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsl()\"));\n@@ -726,1 +725,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -728,1 +727,1 @@\n-        Color.web(\"hsl 240, 50%, 50%\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsl 240, 50%, 50%\"));\n@@ -731,1 +730,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -733,1 +732,1 @@\n-        Color.web(\"hsl(240, 50%, 50%\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsl(240, 50%, 50%\"));\n@@ -736,1 +735,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -738,1 +737,1 @@\n-        Color.web(\"hsla(240, 50%, 50%)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsla(240, 50%, 50%)\"));\n@@ -741,1 +740,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -743,1 +742,1 @@\n-        Color.web(\"hsla(240, 50%)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsla(240, 50%)\"));\n@@ -746,1 +745,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -748,1 +747,1 @@\n-        Color.web(\"hsla(240)\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsla(240)\"));\n@@ -751,1 +750,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -753,1 +752,1 @@\n-        Color.web(\"hsla()\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsla()\"));\n@@ -756,1 +755,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -758,1 +757,1 @@\n-        Color.web(\"hsla 240, 50%, 50%, 0.5\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsla 240, 50%, 50%, 0.5\"));\n@@ -761,1 +760,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -763,1 +762,1 @@\n-        Color.web(\"hsla(240, 50%, 50%, 0.5\");\n+        assertThrows(IllegalArgumentException.class, () -> Color.web(\"hsla(240, 50%, 50%, 0.5\"));\n@@ -951,0 +950,33 @@\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenTwoDifferentValuesReturnsNewInstance() {\n+            var a = new Color(0.2, 0.4, 0.6, 0.8);\n+            var b = new Color(0.3, 0.5, 0.7, 0.9);\n+            assertEquals(new Color(0.25, 0.45, 0.65, 0.85), a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsSameInstance() {\n+            var a = new Color(0.2, 0.4, 0.6, 0.8);\n+            var b = new Color(0.2, 0.4, 0.6, 0.8);\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var a = new Color(0.2, 0.4, 0.6, 0.8);\n+            var b = new Color(0.3, 0.5, 0.7, 0.9);\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var a = new Color(0.2, 0.4, 0.6, 0.8);\n+            var b = new Color(0.3, 0.5, 0.7, 0.9);\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/ColorTest.java","additions":92,"deletions":60,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,5 +28,0 @@\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n@@ -35,3 +30,2 @@\n-\n-import org.junit.Test;\n-\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -43,0 +37,2 @@\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -93,1 +89,46 @@\n-\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var image = createImage();\n+            var a = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var b = new ImagePattern(image, 20, 30, 40, 50, false);\n+            var expected = new ImagePattern(image, 15, 25, 35, 45, false);\n+            assertEquals(expected, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenProportionalAndNonProportionalReturnsStartInstanceOrEndInstance() {\n+            var image = createImage();\n+            var a = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var b = new ImagePattern(image, 20, 30, 40, 50, true);\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(b, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsStartInstance() {\n+            var image = createImage();\n+            var a = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var b = new ImagePattern(image, 10, 20, 30, 40, false);\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var image = createImage();\n+            var a = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var b = new ImagePattern(image, 20, 30, 40, 50, false);\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var image = createImage();\n+            var a = new ImagePattern(image, 10, 20, 30, 40, false);\n+            var b = new ImagePattern(image, 20, 30, 40, 50, false);\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/ImagePatternTest.java","additions":51,"deletions":10,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,7 +37,4 @@\n-import org.junit.Test;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -84,1 +81,1 @@\n-    @Test(expected=UnsupportedOperationException.class)\n+    @Test\n@@ -90,1 +87,1 @@\n-        returned.set(0, stop2);\n+        assertThrows(UnsupportedOperationException.class, () -> returned.set(0, stop2));\n@@ -190,1 +187,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -192,1 +189,1 @@\n-        LinearGradient.valueOf(null);\n+        assertThrows(NullPointerException.class, () -> LinearGradient.valueOf(null));\n@@ -195,1 +192,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -197,1 +194,1 @@\n-        LinearGradient.valueOf(\"\");\n+        assertThrows(IllegalArgumentException.class, () -> LinearGradient.valueOf(\"\"));\n@@ -463,0 +460,86 @@\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var a = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLACK), new Stop(1, Color.WHITE)));\n+\n+            var b = new LinearGradient(\n+                20, 40, 60, 80,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.WHITE), new Stop(1, Color.BLACK)));\n+\n+            var expected = new LinearGradient(\n+                15, 30, 45, 60,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.gray(0.5)), new Stop(1, Color.gray(0.5))));\n+\n+            assertEquals(expected, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenProportionalAndNonProportionalReturnsStartInstanceOrEndInstance() {\n+            var a = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var b = new LinearGradient(\n+                10, 20, 30, 40,\n+                false, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(b, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsStartInstance() {\n+            var a = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var b = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var a = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var b = new LinearGradient(\n+                20, 40, 60, 80,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.RED)));\n+\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var a = new LinearGradient(\n+                10, 20, 30, 40,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var b = new LinearGradient(\n+                20, 40, 60, 80,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.RED)));\n+\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/LinearGradientTest.java","additions":97,"deletions":14,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.paint;\n+\n+import com.sun.javafx.scene.paint.PaintUtils;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.CycleMethod;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.RadialGradient;\n+import javafx.scene.paint.Stop;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class PaintUtilsTest {\n+\n+    @Nested\n+    class InterpolateColorTest {\n+        @Test\n+        void toLinearGradient() {\n+            var paint = PaintUtils.interpolate(\n+                Color.BLUE,\n+                new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, Color.RED), new Stop(1, Color.GREEN)),\n+                0.5);\n+\n+            var expected = new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                              new Stop(0, Color.BLUE.interpolate(Color.RED, 0.5)),\n+                                              new Stop(1, Color.BLUE.interpolate(Color.GREEN, 0.5)));\n+\n+            assertEquals(expected, paint);\n+        }\n+\n+        @Test\n+        void toRadialGradient() {\n+            var paint = PaintUtils.interpolate(\n+                Color.BLUE,\n+                new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, Color.RED), new Stop(1, Color.GREEN)),\n+                0.5);\n+\n+            var expected = new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                              new Stop(0, Color.BLUE.interpolate(Color.RED, 0.5)),\n+                                              new Stop(1, Color.BLUE.interpolate(Color.GREEN, 0.5)));\n+\n+            assertEquals(expected, paint);\n+        }\n+    }\n+\n+    @Nested\n+    class InterpolateLinearGradientTest {\n+        @Test\n+        void toColor() {\n+            var paint = PaintUtils.interpolate(\n+                new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, Color.RED), new Stop(1, Color.GREEN)),\n+                Color.BLUE,\n+                0.5);\n+\n+            var expected = new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                              new Stop(0, Color.RED.interpolate(Color.BLUE, 0.5)),\n+                                              new Stop(1, Color.GREEN.interpolate(Color.BLUE, 0.5)));\n+\n+            assertEquals(expected, paint);\n+        }\n+\n+        @Test\n+        void toRadialGradient() {\n+            var toPaint = new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                             new Stop(0, Color.RED), new Stop(1, Color.GREEN));\n+\n+            var actual = PaintUtils.interpolate(\n+                new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, Color.RED), new Stop(1, Color.GREEN)),\n+                toPaint,\n+                0.5);\n+\n+            assertSame(actual, toPaint);\n+        }\n+    }\n+\n+    @Nested\n+    class InterpolateRadialGradientTest {\n+        @Test\n+        void toColor() {\n+            var paint = PaintUtils.interpolate(\n+                new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, Color.RED), new Stop(1, Color.GREEN)),\n+                Color.BLUE,\n+                0.5);\n+\n+            var expected = new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                              new Stop(0, Color.RED.interpolate(Color.BLUE, 0.5)),\n+                                              new Stop(1, Color.GREEN.interpolate(Color.BLUE, 0.5)));\n+\n+            assertEquals(expected, paint);\n+        }\n+\n+        @Test\n+        void toLinearGradient() {\n+            var toPaint = new LinearGradient(0, 0, 1, 1, false, CycleMethod.NO_CYCLE,\n+                                             new Stop(0, Color.RED), new Stop(1, Color.GREEN));\n+\n+            var actual = PaintUtils.interpolate(\n+                new RadialGradient(0, 0, 0, 0, 10, false, CycleMethod.NO_CYCLE,\n+                                   new Stop(0, Color.RED), new Stop(1, Color.GREEN)),\n+                toPaint,\n+                0.5);\n+\n+            assertSame(actual, toPaint);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/PaintUtilsTest.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,7 +37,4 @@\n-import org.junit.Test;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -85,1 +82,1 @@\n-    @Test(expected=UnsupportedOperationException.class)\n+    @Test\n@@ -91,1 +88,1 @@\n-        returned.set(0, stop2);\n+        assertThrows(UnsupportedOperationException.class, () -> returned.set(0, stop2));\n@@ -213,1 +210,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -215,1 +212,1 @@\n-        RadialGradient.valueOf(null);\n+        assertThrows(NullPointerException.class, () -> RadialGradient.valueOf(null));\n@@ -218,1 +215,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -220,1 +217,1 @@\n-        RadialGradient.valueOf(\"\");\n+        assertThrows(IllegalArgumentException.class, () -> RadialGradient.valueOf(\"\"));\n@@ -491,0 +488,86 @@\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenDifferentValuesReturnsNewInstance() {\n+            var a = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLACK), new Stop(1, Color.WHITE)));\n+\n+            var b = new RadialGradient(\n+                20, 40, 60, 80, 100,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.WHITE), new Stop(1, Color.BLACK)));\n+\n+            var expected = new RadialGradient(\n+                15, 30, 45, 60, 75,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.gray(0.5)), new Stop(1, Color.gray(0.5))));\n+\n+            assertEquals(expected, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenProportionalAndNonProportionalReturnsStartInstanceOrEndInstance() {\n+            var a = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var b = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                false, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(b, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsStartInstance() {\n+            var a = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var b = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var a = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var b = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.RED)));\n+\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var a = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.BLUE)));\n+\n+            var b = new RadialGradient(\n+                10, 20, 30, 40, 50,\n+                true, CycleMethod.NO_CYCLE,\n+                List.of(new Stop(0, Color.RED)));\n+\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/RadialGradientTest.java","additions":97,"deletions":14,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import static org.junit.Assert.assertEquals;\n-\n@@ -37,0 +35,3 @@\n+import javafx.scene.paint.StopShim;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -38,1 +39,1 @@\n-import org.junit.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -78,1 +79,1 @@\n-        assertEquals(zeroOneList, normalize(new Stop(0.5, null)));\n+        assertThrows(NullPointerException.class, () -> normalize(new Stop(0.5, null)));\n@@ -154,0 +155,80 @@\n+\n+    @Test\n+    public void testInterpolateStop() {\n+        assertSame(zerostop, zerostop.interpolate(onestop, -0.5));\n+        assertSame(zerostop, zerostop.interpolate(onestop, 0));\n+        assertSame(onestop, zerostop.interpolate(onestop, 1));\n+        assertSame(onestop, zerostop.interpolate(onestop, 1.5));\n+        assertEquals(new Stop(0.5, color2), zerostop.interpolate(onestop, 0.5));\n+    }\n+\n+    @Nested\n+    class ListInterpolationTest {\n+        @Test\n+        public void returnFirstListBeforeInterval() {\n+            var firstList = List.of(new Stop(0, color1), new Stop(1, color3));\n+            var secondList = List.of(new Stop(0, color3), new Stop(1, color1));\n+            assertSame(firstList, StopShim.interpolateLists(firstList, secondList, 0));\n+            assertSame(firstList, StopShim.interpolateLists(firstList, secondList, -0.5));\n+        }\n+\n+        @Test\n+        public void returnSecondListAfterInterval() {\n+            var firstList = List.of(new Stop(0, color1), new Stop(1, color3));\n+            var secondList = List.of(new Stop(0, color3), new Stop(1, color1));\n+            assertSame(secondList, StopShim.interpolateLists(firstList, secondList, 1));\n+            assertSame(secondList, StopShim.interpolateLists(firstList, secondList, 1.5));\n+        }\n+\n+        @Test\n+        public void sameSize_sameOffsets() {\n+            var firstList = List.of(new Stop(0, color1), new Stop(1, color3));\n+            var secondList = List.of(new Stop(0, color3), new Stop(1, color1));\n+            var res = StopShim.interpolateLists(firstList, secondList, 0.5);\n+            assertEquals(List.of(\n+                new Stop(0, color2),\n+                new Stop(1, color2)),\n+            res);\n+        }\n+\n+        @Test\n+        public void sameSize_differentOffsets() {\n+            double t = 0.5;\n+            var firstList = normalize(List.of(new Stop(0.1, color1), new Stop(0.9, color3)));\n+            var secondList = normalize(List.of(new Stop(0.2, color3), new Stop(0.8, color1)));\n+            var res = StopShim.interpolateLists(firstList, secondList, t);\n+            assertEquals(List.of(\n+                new Stop(0, color2),\n+                new Stop(0.1, color2),\n+                new Stop(0.2, color1.interpolate(color3, 0.125).interpolate(color3, t)),\n+                new Stop(0.8, color1.interpolate(color3, 0.875).interpolate(color1, t)),\n+                new Stop(0.9, color2),\n+                new Stop(1, color2)),\n+            res);\n+        }\n+\n+        @Test\n+        public void differentSize_sameFirstAndLastOffset() {\n+            var firstList = normalize(List.of(new Stop(0, color1), new Stop(0.5, color3), new Stop(1, color1)));\n+            var secondList = normalize(List.of(new Stop(0, color1), new Stop(1, color3)));\n+            var expected = List.of(\n+                new Stop(0, color1),\n+                new Stop(0.5, color2.interpolate(color3, 0.5)),\n+                new Stop(1, color2));\n+            assertEquals(expected, StopShim.interpolateLists(firstList, secondList, 0.5));\n+        }\n+\n+        @Test\n+        public void differentSize_differentOffsets() {\n+            double t = 0.5;\n+            var firstList = normalize(List.of(new Stop(0, color1), new Stop(1, color3)));\n+            var secondList = normalize(List.of(new Stop(0.25, color3), new Stop(0.75, color1)));\n+            var res = StopShim.interpolateLists(firstList, secondList, t);\n+            assertEquals(List.of(\n+                new Stop(0, color2),\n+                new Stop(0.25, color1.interpolate(color3, 0.25).interpolate(color3, t)),\n+                new Stop(0.75, color1.interpolate(color3, 0.75).interpolate(color1, t)),\n+                new Stop(1, color2)),\n+            res);\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/StopListTest.java","additions":86,"deletions":5,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,4 +30,2 @@\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n@@ -35,1 +33,2 @@\n-import org.junit.Test;\n+import static javafx.scene.paint.Color.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -50,0 +49,5 @@\n+    @Test\n+    public void testNullColor() {\n+        assertThrows(NullPointerException.class, () -> new Stop(0.2f, null));\n+    }\n+\n@@ -59,2 +63,0 @@\n-        Stop nullColor = new Stop(0.2f, null);\n-        Stop nullColor2 = new Stop(0.2f, null);\n@@ -68,2 +70,0 @@\n-        assertTrue(nullColor.equals(nullColor2));\n-        assertFalse(nullColor.equals(basic));\n@@ -104,0 +104,33 @@\n+\n+    @Nested\n+    class InterpolationTest {\n+        @Test\n+        public void interpolateBetweenTwoDifferentValuesReturnsNewInstance() {\n+            var a = new Stop(0, RED);\n+            var b = new Stop(1, GREEN);\n+            assertEquals(new Stop(0.5, RED.interpolate(GREEN, 0.5)), a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolateBetweenTwoEqualValuesReturnsSameInstance() {\n+            var a = new Stop(0.25, RED);\n+            var b = new Stop(0.25, RED);\n+            assertSame(a, a.interpolate(b, 0.5));\n+        }\n+\n+        @Test\n+        public void interpolationFactorSmallerThanOrEqualToZeroReturnsStartInstance() {\n+            var a = new Stop(0.25, RED);\n+            var b = new Stop(0.75, GREEN);\n+            assertSame(a, a.interpolate(b, 0));\n+            assertSame(a, a.interpolate(b, -1));\n+        }\n+\n+        @Test\n+        public void interpolationFactorGreaterThanOrEqualToOneReturnsEndInstance() {\n+            var a = new Stop(0.25, RED);\n+            var b = new Stop(0.75, GREEN);\n+            assertSame(b, a.interpolate(b, 1));\n+            assertSame(b, a.interpolate(b, 1.5));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/paint\/StopTest.java","additions":43,"deletions":10,"binary":false,"changes":53,"status":"modified"}]}