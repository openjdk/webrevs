{"files":[{"patch":"@@ -172,5 +172,0 @@\n-    \/\/ Set of functions apart from CoreSymbols.getFunctions(), that are used by our fragment shaders.\n-    private static final Set<String> libraryFunctionsUsedInShader = Set.of(\n-        \"min\", \"max\", \"mix\", \"pow\", \"normalize\", \"abs\", \"fract\",\n-        \"dot\", \"clamp\", \"sqrt\", \"ceil\", \"floor\", \"sign\", \"sampleTex\");\n-\n@@ -216,2 +211,1 @@\n-                if (!CoreSymbols.getFunctions().contains(getFuncName(e.getFunction().getName())) &&\n-                        !libraryFunctionsUsedInShader.contains(getFuncName(e.getFunction().getName()))) {\n+                if (!CoreSymbols.getFunctions().contains(e.getFunction())) {\n@@ -238,2 +232,1 @@\n-                if (!CoreSymbols.getFunctions().contains(getFuncName(d.getFunction().getName())) &&\n-                        !libraryFunctionsUsedInShader.contains(getFuncName(d.getFunction().getName()))) {\n+                if (!CoreSymbols.getFunctions().contains(d.getFunction())) {\n@@ -462,0 +455,1 @@\n+        \/\/ Remove the un-required samplers out of the 4 samplers added to all user defined functions\n","filename":"modules\/javafx.graphics\/src\/jslc\/java\/com\/sun\/scenario\/effect\/compiler\/backend\/hw\/MSLBackend.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -90,0 +90,100 @@\n+    private void updateTextureInt(Buffer buffer, PixelFormat format,\n+                                int dstx, int dsty,\n+                                int srcx, int srcy,\n+                                int srcw, int srch,\n+                                int srcscan) {\n+        if (format == PixelFormat.INT_ARGB_PRE) {\n+            IntBuffer buf = (IntBuffer) buffer;\n+            int[] arr = buf.hasArray() ? buf.array() : null;\n+            nUpdateInt(getNativeHandle(), buf, arr,\n+                       dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported INT PixelFormat: \" + format);\n+        }\n+    }\n+\n+    private void updateTextureFloat(Buffer buffer, PixelFormat format,\n+                                int dstx, int dsty,\n+                                int srcx, int srcy,\n+                                int srcw, int srch,\n+                                int srcscan) {\n+        if (format == PixelFormat.FLOAT_XYZW) {\n+            FloatBuffer buf = (FloatBuffer) buffer;\n+            float[] arr = buf.hasArray() ? buf.array() : null;\n+            nUpdateFloat(getNativeHandle(), buf, arr,\n+                         dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported FLOAT PixelFormat: \" + format);\n+        }\n+    }\n+\n+    private void updateTextureByte(Buffer buffer, PixelFormat format,\n+                                int dstx, int dsty,\n+                                int srcx, int srcy,\n+                                int srcw, int srch,\n+                                int srcscan) {\n+        ByteBuffer buf = (ByteBuffer) buffer;\n+        buf.rewind();\n+        byte[] arr = buf.hasArray() ? buf.array() : null;\n+\n+        switch (format) {\n+            case PixelFormat.BYTE_BGRA_PRE,\n+                 PixelFormat.BYTE_ALPHA ->\n+                nUpdate(getNativeHandle(), buf, arr,\n+                        dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n+\n+            case PixelFormat.BYTE_RGB -> {\n+                \/\/ Convert 24-bit RGB to 32-bit BGRA\n+                \/\/ Metal does not support 24-bit format\n+                \/\/ hence `arr` data needs to be converted to BGRA format\n+                byte[] arr32Bit = new byte[srcw * srch * 4];\n+                int dstIndex = 0;\n+                int index = 0;\n+\n+                int rowStride = srcw * 3;\n+                int totalBytes = srch * rowStride;\n+\n+                for (int rowIndex = 0; rowIndex < totalBytes; rowIndex += rowStride) {\n+                    for (int colIndex = 0; colIndex < rowStride; colIndex += 3) {\n+                        index = rowIndex + colIndex;\n+                        arr32Bit[dstIndex++] = arr[index + 2];\n+                        arr32Bit[dstIndex++] = arr[index + 1];\n+                        arr32Bit[dstIndex++] = arr[index];\n+                        arr32Bit[dstIndex++] = (byte)255;\n+                    }\n+                }\n+                nUpdate(getNativeHandle(), null, arr32Bit,\n+                        dstx, dsty, srcx, srcy, srcw, srch, srcw * 4);\n+            }\n+\n+            case PixelFormat.BYTE_GRAY -> {\n+                \/\/ Suitable 8-bit native formats are MTLPixelFormatA8Unorm & MTLPixelFormatR8Unorm.\n+                \/\/ These formats do not work well with our generated shader - Texture_RGB.\n+                \/\/ hence `arr` data is converted to BGRA format here.\n+                \/\/ In future, if needed for performance reason:\n+                \/\/ Texture_RGB shader can be tweaked to fill up R,G,B fields from single byte grayscale value.\n+                \/\/ Care must be taken not to break current behavior of this shader.\n+                byte[] arr32Bit = new byte[srcw * srch * 4];\n+                int dstIndex = 0;\n+                int index = 0;\n+                int totalBytes = srch * srcw;\n+\n+                for (int rowIndex = 0; rowIndex < totalBytes; rowIndex += srcw) {\n+                    for (int colIndex = 0; colIndex < srcw; colIndex++) {\n+                        index = rowIndex + colIndex;\n+                        arr32Bit[dstIndex++] = arr[index];\n+                        arr32Bit[dstIndex++] = arr[index];\n+                        arr32Bit[dstIndex++] = arr[index];\n+                        arr32Bit[dstIndex++] = (byte) 255;\n+                    }\n+                }\n+                nUpdate(getNativeHandle(), null, arr32Bit,\n+                        dstx, dsty, srcx, srcy, srcw, srch, srcw * 4);\n+            }\n+\n+            case PixelFormat.MULTI_YCbCr_420,\n+                 PixelFormat.BYTE_APPLE_422 ->\n+                throw new IllegalArgumentException(\"Unsupported PixelFormat \" + format);\n+        }\n+    }\n+\n@@ -98,10 +198,2 @@\n-            case PixelFormat.DataType.INT -> {\n-                if (format == PixelFormat.INT_ARGB_PRE) {\n-                    IntBuffer buf = (IntBuffer) buffer;\n-                    int[] arr = buf.hasArray() ? buf.array() : null;\n-                    nUpdateInt(getNativeHandle(), buf, arr,\n-                               dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n-                } else {\n-                    throw new IllegalArgumentException(\"Unsupported INT PixelFormat: \" + format);\n-                }\n-            }\n+            case PixelFormat.DataType.INT -> updateTextureInt(buffer, format,\n+                dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n@@ -109,10 +201,2 @@\n-            case PixelFormat.DataType.FLOAT -> {\n-                if (format == PixelFormat.FLOAT_XYZW) {\n-                    FloatBuffer buf = (FloatBuffer) buffer;\n-                    float[] arr = buf.hasArray() ? buf.array() : null;\n-                    nUpdateFloat(getNativeHandle(), buf, arr,\n-                                 dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n-                } else {\n-                    throw new IllegalArgumentException(\"Unsupported FLOAT PixelFormat: \" + format);\n-                }\n-            }\n+            case PixelFormat.DataType.FLOAT -> updateTextureFloat(buffer, format,\n+                dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n@@ -120,65 +204,2 @@\n-            case PixelFormat.DataType.BYTE -> {\n-                ByteBuffer buf = (ByteBuffer) buffer;\n-                buf.rewind();\n-                byte[] arr = buf.hasArray() ? buf.array() : null;\n-\n-                switch (format) {\n-                    case PixelFormat.BYTE_BGRA_PRE,\n-                         PixelFormat.BYTE_ALPHA ->\n-                        nUpdate(getNativeHandle(), buf, arr,\n-                                dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n-\n-                    case PixelFormat.BYTE_RGB -> {\n-                        \/\/ Convert 24-bit RGB to 32-bit BGRA\n-                        \/\/ Metal does not support 24-bit format\n-                        \/\/ hence `arr` data needs to be converted to BGRA format\n-                        byte[] arr32Bit = new byte[srcw * srch * 4];\n-                        int dstIndex = 0;\n-                        int index = 0;\n-\n-                        int rowStride = srcw * 3;\n-                        int totalBytes = srch * rowStride;\n-\n-                        for (int rowIndex = 0; rowIndex < totalBytes; rowIndex += rowStride) {\n-                            for (int colIndex = 0; colIndex < rowStride; colIndex += 3) {\n-                                index = rowIndex + colIndex;\n-                                arr32Bit[dstIndex++] = arr[index + 2];\n-                                arr32Bit[dstIndex++] = arr[index + 1];\n-                                arr32Bit[dstIndex++] = arr[index];\n-                                arr32Bit[dstIndex++] = (byte)255;\n-                            }\n-                        }\n-                        nUpdate(getNativeHandle(), null, arr32Bit,\n-                                dstx, dsty, srcx, srcy, srcw, srch, srcw * 4);\n-                    }\n-\n-                    case PixelFormat.BYTE_GRAY -> {\n-                        \/\/ Suitable 8-bit native formats are MTLPixelFormatA8Unorm & MTLPixelFormatR8Unorm.\n-                        \/\/ These formats do not work well with our generated shader - Texture_RGB.\n-                        \/\/ hence `arr` data is converted to BGRA format here.\n-                        \/\/ In future, if needed for performance reason:\n-                        \/\/ Texture_RGB shader can be tweaked to fill up R,G,B fields from single byte grayscale value.\n-                        \/\/ Care must be taken not to break current behavior of this shader.\n-                        byte[] arr32Bit = new byte[srcw * srch * 4];\n-                        int dstIndex = 0;\n-                        int index = 0;\n-                        int totalBytes = srch * srcw;\n-\n-                        for (int rowIndex = 0; rowIndex < totalBytes; rowIndex += srcw) {\n-                            for (int colIndex = 0; colIndex < srcw; colIndex++) {\n-                                index = rowIndex + colIndex;\n-                                arr32Bit[dstIndex++] = arr[index];\n-                                arr32Bit[dstIndex++] = arr[index];\n-                                arr32Bit[dstIndex++] = arr[index];\n-                                arr32Bit[dstIndex++] = (byte) 255;\n-                            }\n-                        }\n-                        nUpdate(getNativeHandle(), null, arr32Bit,\n-                                dstx, dsty, srcx, srcy, srcw, srch, srcw * 4);\n-                    }\n-\n-                    case PixelFormat.MULTI_YCbCr_420,\n-                         PixelFormat.BYTE_APPLE_422 ->\n-                        throw new IllegalArgumentException(\"Unsupported PixelFormat \" + format);\n-                }\n-            }\n+            case PixelFormat.DataType.BYTE -> updateTextureByte(buffer, format,\n+                dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLTexture.java","additions":106,"deletions":85,"binary":false,"changes":191,"status":"modified"}]}