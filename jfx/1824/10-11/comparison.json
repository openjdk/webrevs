{"files":[{"patch":"@@ -1717,2 +1717,2 @@\n-        output project.file(\"$project.buildDir\/hlsl\/$name\/$pkg\")\n-        source project.file(\"$project.buildDir\/gensrc\/jsl-$lowerName\/$pkg\")\n+        output project.file(\"$project.buildDir\/hlsl\/$name\/$pkg\/d3d\/hlsl\")\n+        source project.file(\"$project.buildDir\/gensrc\/jsl-$lowerName\/$pkg\/d3d\/hlsl\")\n@@ -1728,2 +1728,2 @@\n-        output project.file(\"$project.buildDir\/msl\/$name\/$pkg\")\n-        source project.file(\"$project.buildDir\/gensrc\/jsl-$lowerName\/$pkg\")\n+        output project.file(\"$project.buildDir\/msl\/$name\/$pkg\/mtl\/msl\")\n+        source project.file(\"$project.buildDir\/gensrc\/jsl-$lowerName\/$pkg\/mtl\/msl\")\n@@ -2583,1 +2583,0 @@\n-    def outPkg = IS_WINDOWS ? \"com\/sun\/scenario\/effect\/impl\/hw\/d3d\/hlsl\" : (IS_MAC ? \"com\/sun\/scenario\/effect\/impl\/hw\/mtl\/msl\" : \"\")\n@@ -2586,1 +2585,1 @@\n-    addJSL(project, \"Decora\", outPkg, decoraAddExports) { sourceDir, destinationDir ->\n+    addJSL(project, \"Decora\", \"com\/sun\/scenario\/effect\/impl\/hw\", decoraAddExports) { sourceDir, destinationDir ->\n@@ -2679,2 +2678,1 @@\n-    outPkg = IS_WINDOWS ? \"com\/sun\/prism\/d3d\/hlsl\" : (IS_MAC ? \"com\/sun\/prism\/mtl\/msl\" : \"\")\n-    addJSL(project, \"Prism\", outPkg, null) { sourceDir, destinationDir ->\n+    addJSL(project, \"Prism\", \"com\/sun\/prism\", null) { sourceDir, destinationDir ->\n@@ -2705,1 +2703,1 @@\n-                    args += [ \"-std=macos-metal2.4\" ]\n+                    args += [ \"-std=${mslVersion}\" ]\n@@ -2721,1 +2719,1 @@\n-                    args += [ \"-std=macos-metal2.4\" ]\n+                    args += [ \"-std=${mslVersion}\" ]\n@@ -2737,1 +2735,1 @@\n-                    args += [ \"-std=macos-metal2.4\" ]\n+                    args += [ \"-std=${mslVersion}\" ]\n@@ -2753,1 +2751,1 @@\n-                    args += [ \"-std=macos-metal2.4\" ]\n+                    args += [ \"-std=${mslVersion}\" ]\n@@ -2769,1 +2767,1 @@\n-                    args += [ \"-std=macos-metal2.4\" ]\n+                    args += [ \"-std=${mslVersion}\" ]\n","filename":"build.gradle","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -128,0 +128,4 @@\n+\n+# Metal version, for Metal Shader compilation\n+# 2.4 is required for supporting macOS 12\n+msl.version=macos-metal2.4\n","filename":"build.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,0 +52,4 @@\n+\/*\n+ * Class that generates Metal shaders from JSL.\n+ *\/\n+\n@@ -55,1 +59,0 @@\n-    private static StringBuilder fragmentShaderHeader;\n@@ -64,1 +67,0 @@\n-    private String textureSamplerName;\n@@ -67,1 +69,1 @@\n-    private List<String> uniformNames;\n+    private final List<String> uniformNames = new ArrayList<>();\n@@ -76,1 +78,1 @@\n-    private List<String> helperFunctions;\n+    private final List<String> helperFunctions = new ArrayList<>();;\n@@ -83,1 +85,1 @@\n-    private static Map<String, String> texSamplerMap = new HashMap<>();\n+    private static final Map<String, String> texSamplerMap = new HashMap<>();\n@@ -181,2 +183,2 @@\n-        String qual = QUAL_MAP.get(q.toString());\n-        return (qual != null) ? qual : q.toString();\n+        String qualifier = q.toString();\n+        return QUAL_MAP.getOrDefault(qualifier, qualifier);\n@@ -187,2 +189,2 @@\n-        String type = TYPE_MAP.get(t.toString());\n-        return (type != null) ? type : t.toString();\n+        String type = t.toString();\n+        return TYPE_MAP.getOrDefault(type, type);\n@@ -193,2 +195,1 @@\n-        String s = VAR_MAP.get(v);\n-        return (s != null) ? s : v;\n+        return VAR_MAP.getOrDefault(v, v);\n@@ -199,2 +200,1 @@\n-        String s = FUNC_MAP.get(f);\n-        return (s != null) ? s : f;\n+        return FUNC_MAP.getOrDefault(f, f);\n@@ -256,23 +256,13 @@\n-        if (qual == Qualifier.CONST) { \/\/ example. const int i = 10;\n-            \/\/ const variables are converted into macro.\n-            \/\/ reason: In MSL, only the program scoped variables can be declared as constant(address space).\n-            \/\/ Function scope variables cannot be declared as constant.\n-            \/\/ In our shaders, there is one function scope variable 'const float third'\n-            \/\/ which causes a compilation error if all const are replaced with constant.\n-            \/\/ So alternate approach is to use macros for all const variables.\n-            output(\"#define \" + var.getName());\n-            output(\" (\");\n-            scan(d.getInit());\n-            output(\")\\n\");\n-        } else if (qual == Qualifier.PARAM) { \/\/ These are uniform variables.\n-            \/\/ In MSL, uniform variables can be declared by using function_constant attribute.\n-            \/\/ function_constant variables can only be scalar or vector type.\n-            \/\/ User defined type or array of scalar or vector cannot be declared as function_constants.\n-            \/\/ So we combine all uniform variables into a struct named Uniforms.\n-            String aUniform = \"\";\n-            Precision precision = var.getPrecision();\n-            if (precision != null) {\n-                String precisionStr = getPrecision(precision);\n-                if (precisionStr != null) {\n-                    aUniform += precisionStr + \" \";\n-                }\n+        switch (qual) {\n+            case Qualifier.CONST -> {\n+                \/\/ example: const int i = 10;\n+                \/\/ const variables are converted into macro.\n+                \/\/ reason: In MSL, only the program scoped variables can be declared as constant(address space).\n+                \/\/ Function scope variables cannot be declared as constant.\n+                \/\/ In our shaders, there is one function scope variable 'const float third'\n+                \/\/ which causes a compilation error if all const are replaced with constant.\n+                \/\/ So alternate approach is to use macros for all const variables.\n+                output(\"#define \" + var.getName());\n+                output(\" (\");\n+                scan(d.getInit());\n+                output(\")\\n\");\n@@ -280,12 +270,20 @@\n-            if (getType(var.getType()).contains(\"texture2d\")) {\n-                hasTextureVar = true;\n-                texSamplerMap.put(var.getName(), \"sampler\" + texSamplerMap.size());\n-            }\n-            uniformNames.add(var.getName());\n-            aUniform += getType(var.getType()) + \" \" + var.getName();\n-            if (var.isArray()) {\n-                aUniform += \"[\" + var.getArraySize() + \"]\";\n-            }\n-\n-            if (!uniformIDs.contains(var.getName())) {\n-                uniformIDs += \"    \" + shaderFunctionName + \"_\" + var.getName() + \"_ID = \" + uniformIDCount + \",\\n\";\n+            case Qualifier.PARAM -> {\n+                \/\/ These are uniform variables.\n+                \/\/ In MSL, uniform variables can be declared by using function_constant attribute.\n+                \/\/ function_constant variables can only be scalar or vector type.\n+                \/\/ User defined type or array of scalar or vector cannot be declared as function_constants.\n+                \/\/ So we combine all uniform variables into a struct named Uniforms.\n+                String aUniform = \"\";\n+                Precision precision = var.getPrecision();\n+                if (precision != null) {\n+                    String precisionStr = getPrecision(precision);\n+                    if (precisionStr != null) {\n+                        aUniform += precisionStr + \" \";\n+                    }\n+                }\n+                if (getType(var.getType()).contains(\"texture2d\")) {\n+                    hasTextureVar = true;\n+                    texSamplerMap.put(var.getName(), \"sampler\" + texSamplerMap.size());\n+                }\n+                uniformNames.add(var.getName());\n+                aUniform += getType(var.getType()) + \" \" + var.getName();\n@@ -293,3 +291,16 @@\n-                    uniformIDCount += var.getArraySize();\n-                } else {\n-                    uniformIDCount++;\n+                    aUniform += \"[\" + var.getArraySize() + \"]\";\n+                }\n+\n+                if (!uniformIDs.contains(var.getName())) {\n+                    uniformIDs += \"    \" + shaderFunctionName + \"_\" + var.getName() + \"_ID = \" + uniformIDCount + \",\\n\";\n+                    if (var.isArray()) {\n+                        uniformIDCount += var.getArraySize();\n+                    } else {\n+                        uniformIDCount++;\n+                    }\n+                }\n+                if (!uniformsForShaderFile.contains(var.getName())) {\n+                    uniformsForShaderFile += \"    \" + aUniform + \";\\n\";\n+                }\n+                if (!uniformsForObjCFiles.contains(var.getName())) {\n+                    uniformsForObjCFiles += \"    \" + aUniform + \";\\n\";\n@@ -298,8 +309,1 @@\n-            if (!uniformsForShaderFile.contains(var.getName())) {\n-                uniformsForShaderFile += \"    \" + aUniform + \";\\n\";\n-            }\n-            if (!uniformsForObjCFiles.contains(var.getName())) {\n-                uniformsForObjCFiles += \"    \" + aUniform + \";\\n\";\n-            }\n-        } else {\n-            super.visitVarDecl(d);\n+            case null -> super.visitVarDecl(d);\n@@ -317,26 +321,0 @@\n-        if (fragmentShaderHeader == null) {\n-            fragmentShaderHeader = new StringBuilder();\n-            fragmentShaderHeader.append(\"#ifndef FRAGMENT_COMMON_H\\n\");\n-            fragmentShaderHeader.append(\"#define FRAGMENT_COMMON_H\\n\\n\");\n-            fragmentShaderHeader.append(\"#pragma clang diagnostic ignored \\\"-Wunused\\\"\\n\\n\");\n-            fragmentShaderHeader.append(\"#include <simd\/simd.h>\\n\");\n-            fragmentShaderHeader.append(\"#include <metal_stdlib>\\n\\n\");\n-            fragmentShaderHeader.append(\"using namespace metal;\\n\\n\");\n-\n-            fragmentShaderHeader.append(\"struct VS_OUTPUT {\\n\");\n-            fragmentShaderHeader.append(\"    float4 position [[ position ]];\\n\");\n-            fragmentShaderHeader.append(\"    float4 fragColor;\\n\");\n-            fragmentShaderHeader.append(\"    float2 texCoord0;\\n\");\n-            fragmentShaderHeader.append(\"    float2 texCoord1;\\n\");\n-            fragmentShaderHeader.append(\"};\\n\\n\");\n-            fragmentShaderHeader.append(\"#endif\\n\");\n-\n-            try (FileWriter fragmentShaderHeaderFile = new FileWriter(headerFilesDir + FRAGMENT_SHADER_HEADER_FILE_NAME)) {\n-                fragmentShaderHeaderFile.write(fragmentShaderHeader.toString());\n-            } catch (IOException e) {\n-                System.err.println(\"IOException occurred while creating \" + FRAGMENT_SHADER_HEADER_FILE_NAME +\n-                    \": \" + e.getMessage());\n-                e.printStackTrace();\n-            }\n-        }\n-\n@@ -498,0 +476,1 @@\n+            writeFragmentShaderHeader();\n@@ -503,0 +482,31 @@\n+    private void writeFragmentShaderHeader() {\n+        String fragmentShaderHeader = \"\"\"\n+        #ifndef FRAGMENT_COMMON_H\n+        #define FRAGMENT_COMMON_H\n+\n+        #pragma clang diagnostic ignored \"-Wunused\"\n+\n+        #include <simd\/simd.h>\n+        #include <metal_stdlib>\n+\n+        using namespace metal;\n+\n+        struct VS_OUTPUT {\n+            float4 position [[ position ]];\n+            float4 fragColor;\n+            float2 texCoord0;\n+            float2 texCoord1;\n+        };\n+\n+        #endif\n+        \"\"\";\n+\n+        try (FileWriter fragmentShaderHeaderFile = new FileWriter(headerFilesDir + FRAGMENT_SHADER_HEADER_FILE_NAME)) {\n+            fragmentShaderHeaderFile.write(fragmentShaderHeader);\n+        } catch (IOException e) {\n+            System.err.println(\"IOException occurred while creating \" + FRAGMENT_SHADER_HEADER_FILE_NAME +\n+                \": \" + e.getMessage());\n+            e.printStackTrace();\n+        }\n+    }\n+\n@@ -506,1 +516,0 @@\n-        textureSamplerName = shaderFunctionName + \"_textureSampler\";\n@@ -509,3 +518,3 @@\n-        texSamplerMap = new HashMap<>();\n-        helperFunctions = new ArrayList<>();\n-        uniformNames = new ArrayList<>();\n+        texSamplerMap.clear();\n+        helperFunctions.clear();\n+        uniformNames.clear();\n@@ -525,5 +534,2 @@\n-        if (isPrismShader) {\n-            objCHeaderFileName = PRISM_SHADER_HEADER_FILE_NAME;\n-        } else {\n-            objCHeaderFileName = DECORA_SHADER_HEADER_FILE_NAME;\n-        }\n+        objCHeaderFileName = isPrismShader ? PRISM_SHADER_HEADER_FILE_NAME :\n+                                                DECORA_SHADER_HEADER_FILE_NAME;\n","filename":"modules\/javafx.graphics\/src\/jslc\/java\/com\/sun\/scenario\/effect\/compiler\/backend\/hw\/MSLBackend.java","additions":100,"deletions":94,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-public class MTLContext extends BaseShaderContext {\n+class MTLContext extends BaseShaderContext {\n@@ -54,5 +54,5 @@\n-    public static final int MTL_COMPMODE_CLEAR           = 0;\n-    public static final int MTL_COMPMODE_SRC             = 1;\n-    public static final int MTL_COMPMODE_SRCOVER         = 2;\n-    public static final int MTL_COMPMODE_DSTOUT          = 3;\n-    public static final int MTL_COMPMODE_ADD             = 4;\n+    private static final int MTL_COMPMODE_CLEAR   = 0;\n+    private static final int MTL_COMPMODE_SRC     = 1;\n+    private static final int MTL_COMPMODE_SRCOVER = 2;\n+    private static final int MTL_COMPMODE_DSTOUT  = 3;\n+    private static final int MTL_COMPMODE_ADD     = 4;\n@@ -60,1 +60,1 @@\n-    public static final int MTL_SAMPLER_ADDR_MODE_NOP                    = -1;\n+    private static final int MTL_SAMPLER_ADDR_MODE_NOP                   = -1;\n@@ -62,2 +62,2 @@\n-    public static final int MTL_SAMPLER_ADDR_MODE_CLAMP_TO_EDGE          = 0; \/\/ MTLSamplerAddressModeClampToEdge\n-    public static final int MTL_SAMPLER_ADDR_MODE_MIRR_CLAMP_TO_EDGE     = 1; \/\/ MTLSamplerAddressModeMirrorClampToEdge\n+    private static final int MTL_SAMPLER_ADDR_MODE_CLAMP_TO_EDGE         = 0; \/\/ MTLSamplerAddressModeClampToEdge\n+    private static final int MTL_SAMPLER_ADDR_MODE_MIRR_CLAMP_TO_EDGE    = 1; \/\/ MTLSamplerAddressModeMirrorClampToEdge\n@@ -65,2 +65,2 @@\n-    public static final int MTL_SAMPLER_ADDR_MODE_REPEAT                 = 2; \/\/ MTLSamplerAddressModeRepeat\n-    public static final int MTL_SAMPLER_ADDR_MODE_MIRR_REPEAT            = 3; \/\/ MTLSamplerAddressModeMirrorRepeat\n+    private static final int MTL_SAMPLER_ADDR_MODE_REPEAT                = 2; \/\/ MTLSamplerAddressModeRepeat\n+    private static final int MTL_SAMPLER_ADDR_MODE_MIRR_REPEAT           = 3; \/\/ MTLSamplerAddressModeMirrorRepeat\n@@ -68,2 +68,2 @@\n-    public static final int MTL_SAMPLER_ADDR_MODE_CLAMP_TO_ZERO          = 4; \/\/ MTLSamplerAddressModeClampToZero\n-    public static final int MTL_SAMPLER_ADDR_MODE_CLAMP_TO_BORDER_COLOR  = 5; \/\/ MTLSamplerAddressModeClampToBorderColor\n+    private static final int MTL_SAMPLER_ADDR_MODE_CLAMP_TO_ZERO         = 4; \/\/ MTLSamplerAddressModeClampToZero\n+    private static final int MTL_SAMPLER_ADDR_MODE_CLAMP_TO_BORDER_COLOR = 5; \/\/ MTLSamplerAddressModeClampToBorderColor\n@@ -97,1 +97,1 @@\n-        final Class clazz = MTLContext.class;\n+        final Class<MTLContext> clazz = MTLContext.class;\n@@ -315,1 +315,1 @@\n-        long srcNativeHandle = ((MTLTexture)srcRTT).getNativeHandle();\n+        long srcNativeHandle = ((MTLTexture<?>)srcRTT).getNativeHandle();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLContext.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-public class MTLFBOTextureData extends MTLTextureData {\n+class MTLFBOTextureData extends MTLTextureData {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLFBOTextureData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public class MTLGraphics extends BaseShaderGraphics {\n+class MTLGraphics extends BaseShaderGraphics {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLGraphics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+\n@@ -83,1 +84,1 @@\n-    static class MTLMeshDisposerRecord implements Disposer.Record {\n+    private static class MTLMeshDisposerRecord implements Disposer.Record {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLMesh.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    static class MTLMeshViewDisposerRecord implements Disposer.Record {\n+    private static class MTLMeshViewDisposerRecord implements Disposer.Record {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLMeshView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-class MTLPhongMaterial extends BasePhongMaterial implements PhongMaterial {\n+class MTLPhongMaterial extends BasePhongMaterial {\n@@ -43,1 +43,1 @@\n-    private TextureMap maps[] = new TextureMap[MAX_MAP_TYPE];\n+    private final TextureMap maps[] = new TextureMap[MAX_MAP_TYPE];\n@@ -81,1 +81,4 @@\n-        long hTexture = (texture != null) ? ((MTLTexture) texture).getNativeHandle() : 0;\n+        long hTexture = 0;\n+        if (texture instanceof MTLTexture mtlTex) {\n+            hTexture = mtlTex.getNativeHandle();\n+        }\n@@ -134,1 +137,1 @@\n-    static class MTLPhongMaterialDisposerRecord implements Disposer.Record {\n+    private static class MTLPhongMaterialDisposerRecord implements Disposer.Record {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLPhongMaterial.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        Map devDetails = new HashMap();\n+        Map<String, Long> devDetails = new HashMap<>();\n@@ -124,6 +124,4 @@\n-        switch (type) {\n-            case MSL: \/\/ Metal Shading Language\n-                return true;\n-            default:\n-                return false;\n-        }\n+        return switch (type) {\n+            case MSL -> true;\n+            default -> false;\n+        };\n@@ -134,6 +132,4 @@\n-        switch (model) {\n-            case SM3:\n-                return true;\n-            default:\n-                return false;\n-        }\n+        return switch (model) {\n+            case SM3 -> true;\n+            default -> false;\n+        };\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLPipeline.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-public class MTLRTTexture extends MTLTexture<MTLTextureData>\n+class MTLRTTexture extends MTLTexture<MTLTextureData>\n@@ -47,4 +47,4 @@\n-    private int[] pixels;\n-    private int  rttWidth;\n-    private int  rttHeight;\n-    private long nTexPtr;\n+    private final int[] pixels;\n+    private final int  rttWidth;\n+    private final int  rttHeight;\n+    private final long nTexPtr;\n@@ -53,1 +53,1 @@\n-    private boolean MSAA;\n+    private final boolean MSAA;\n@@ -89,1 +89,1 @@\n-        MTLTextureResource resource = new MTLTextureResource(textData, true);\n+        MTLTextureResource<MTLTextureData> resource = new MTLTextureResource<>(textData, true);\n@@ -101,1 +101,1 @@\n-        MTLTextureResource resource = new MTLTextureResource(textData, false);\n+        MTLTextureResource<MTLTextureData> resource = new MTLTextureResource<>(textData, false);\n@@ -132,2 +132,2 @@\n-        if (pix instanceof IntBuffer) {\n-            nReadPixelsFromRTT(nTexPtr, (IntBuffer)pix);\n+        if (pix instanceof IntBuffer pixBuf) {\n+            nReadPixelsFromRTT(nTexPtr, pixBuf);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLRTTexture.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-public class MTLRTTextureData extends MTLTextureData {\n+class MTLRTTextureData extends MTLTextureData {\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLRTTextureData.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import com.sun.prism.mtl.MTLContext;\n@@ -54,0 +53,1 @@\n+import java.util.Objects;\n@@ -56,1 +56,2 @@\n-public class MTLResourceFactory extends BaseShaderFactory {\n+class MTLResourceFactory extends BaseShaderFactory {\n+\n@@ -104,0 +105,1 @@\n+            e.printStackTrace();\n@@ -112,1 +114,1 @@\n-        Shader shader = MTLShader.createShader(getContext(), shaderName, samplers,\n+        return MTLShader.createShader(getContext(), shaderName, samplers,\n@@ -114,1 +116,0 @@\n-        return shader;\n@@ -119,3 +120,1 @@\n-        if (shaderName == null) {\n-            throw new IllegalArgumentException(\"Shader name must be non-null\");\n-        }\n+        Objects.requireNonNull(shaderName, \"Shader name must be non-null\");\n@@ -126,1 +125,1 @@\n-            Class klass = Class.forName(\"com.sun.prism.shader.\" + shaderName + \"_Loader\");\n+            Class<?> klass = Class.forName(\"com.sun.prism.shader.\" + shaderName + \"_Loader\");\n@@ -137,1 +136,1 @@\n-    public TextureResourcePool getTextureResourcePool() {\n+    public TextureResourcePool<?> getTextureResourcePool() {\n@@ -194,1 +193,1 @@\n-        MTLTextureResource resource = new MTLTextureResource(textData, true);\n+        MTLTextureResource<MTLTextureData> resource = new MTLTextureResource(textData, true);\n@@ -347,2 +346,0 @@\n-        int cx = 0;\n-        int cy = 0;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLResourceFactory.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-public class MTLShader implements Shader {\n+class MTLShader implements Shader {\n@@ -46,1 +46,1 @@\n-    private static Map<String, MTLShader> shaderMap = new HashMap<>();\n+    private static final Map<String, MTLShader> shaderMap = new HashMap<>();\n@@ -83,3 +83,1 @@\n-        for (Map.Entry<String, Integer> entry : samplers.entrySet()) {\n-            this.samplers.put(entry.getValue(), entry.getKey());\n-        }\n+        samplers.forEach((name, id) -> this.samplers.put(id, name));\n@@ -105,5 +103,1 @@\n-        if (nMetalShaderRef != 0) {\n-            return true;\n-        } else {\n-            return false;\n-        }\n+        return nMetalShaderRef != 0;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLShader.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import com.sun.prism.CompositeMode;\n@@ -39,1 +38,1 @@\n-    private PresentableState pState;\n+    private final PresentableState pState;\n@@ -59,1 +58,0 @@\n-\n@@ -87,1 +85,1 @@\n-        MTLGraphics g = (MTLGraphics) MTLGraphics.create(context, stableBackbuffer);\n+        MTLGraphics g = MTLGraphics.create(context, stableBackbuffer);\n@@ -126,1 +124,0 @@\n-\n@@ -148,1 +145,1 @@\n-            stableBackbuffer = (MTLRTTexture)MTLRTTexture.create(getContext(), pTex, w, h, 0);\n+            stableBackbuffer = MTLRTTexture.create(getContext(), pTex, w, h, 0);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLSwapChain.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-public class MTLTexture<T extends MTLTextureData> extends BaseTexture<MTLTextureResource<T>> {\n+class MTLTexture<T extends MTLTextureData> extends BaseTexture<MTLTextureResource<T>> {\n@@ -41,1 +41,1 @@\n-    private long texPtr;\n+    private final long texPtr;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLTexture.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-public class MTLTextureData implements Disposer.Record {\n+class MTLTextureData implements Disposer.Record {\n@@ -36,4 +36,0 @@\n-    private MTLTextureData() {\n-        mtlContext = null;\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLTextureData.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-public class MTLTextureResource<T extends MTLTextureData> extends DisposerManagedResource<T> {\n+class MTLTextureResource<T extends MTLTextureData> extends DisposerManagedResource<T> {\n@@ -32,1 +32,1 @@\n-    boolean canDispose;\n+    private final boolean canDispose;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLTextureResource.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    private static MTLVramPool theInstance = new MTLVramPool();\n+    private static final MTLVramPool theInstance = new MTLVramPool();\n@@ -48,2 +48,1 @@\n-        return ((long) width) * ((long) height) *\n-               ((long) format.getBytesPerPixelUnit());\n+        return (long) width * height * format.getBytesPerPixelUnit();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLVramPool.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    static String [][] compileShaders = {\n+    private static final String [][] compileShaders = {\n","filename":"modules\/javafx.graphics\/src\/main\/jsl-decora\/GenAllDecoraShaders.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}