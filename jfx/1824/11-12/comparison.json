{"files":[{"patch":"@@ -96,6 +96,0 @@\n-        final String shaderLibName = \"msl\/jfxshaders.metallib\";\n-        final Class<MTLContext> clazz = MTLContext.class;\n-\n-        \/\/ Get the native shader library as a stream resource and read it into\n-        \/\/ an NIO ByteBuffer. This will be passed to the native MetalContext\n-        \/\/ initialization, which will load the shader library for each device.\n@@ -103,0 +97,6 @@\n+            final String shaderLibName = \"msl\/jfxshaders.metallib\";\n+            final Class<?> clazz = Class.forName(\"com.sun.prism.mtl.MTLContext\");\n+\n+            \/\/ Get the native shader library as a stream resource and read it into\n+            \/\/ an NIO ByteBuffer. This will be passed to the native MetalContext\n+            \/\/ initialization, which will load the shader library for each device.\n@@ -108,1 +108,1 @@\n-        } catch (IOException ex) {\n+        } catch (ClassNotFoundException | IOException ex) {\n@@ -212,19 +212,12 @@\n-            switch (tex.getWrapMode()) {\n-                case CLAMP_NOT_NEEDED:\n-                    wrapMode = MTL_SAMPLER_ADDR_MODE_NOP;\n-                    break;\n-                case CLAMP_TO_EDGE:\n-                case CLAMP_TO_EDGE_SIMULATED:\n-                case CLAMP_TO_ZERO_SIMULATED:\n-                    wrapMode = MTL_SAMPLER_ADDR_MODE_CLAMP_TO_EDGE;\n-                    break;\n-                case CLAMP_TO_ZERO:\n-                    wrapMode = MTL_SAMPLER_ADDR_MODE_CLAMP_TO_ZERO;\n-                    break;\n-                case REPEAT:\n-                case REPEAT_SIMULATED:\n-                    wrapMode = MTL_SAMPLER_ADDR_MODE_REPEAT;\n-                    break;\n-                default:\n-                    throw new InternalError(\"Unrecognized wrap mode: \" + tex.getWrapMode());\n-            }\n+            wrapMode = switch (tex.getWrapMode()) {\n+                case CLAMP_NOT_NEEDED -> MTL_SAMPLER_ADDR_MODE_NOP;\n+\n+                case CLAMP_TO_EDGE,\n+                     CLAMP_TO_EDGE_SIMULATED,\n+                     CLAMP_TO_ZERO_SIMULATED -> MTL_SAMPLER_ADDR_MODE_CLAMP_TO_EDGE;\n+\n+                case CLAMP_TO_ZERO -> MTL_SAMPLER_ADDR_MODE_CLAMP_TO_ZERO;\n+\n+                case REPEAT,\n+                     REPEAT_SIMULATED -> MTL_SAMPLER_ADDR_MODE_REPEAT;\n+            };\n@@ -278,25 +271,7 @@\n-        int mtlCompMode;\n-        switch (mode) {\n-            case CLEAR:\n-                mtlCompMode = MTL_COMPMODE_CLEAR;\n-                break;\n-\n-            case SRC:\n-                mtlCompMode = MTL_COMPMODE_SRC;\n-                break;\n-\n-            case SRC_OVER:\n-                mtlCompMode = MTL_COMPMODE_SRCOVER;\n-                break;\n-\n-            case DST_OUT:\n-                mtlCompMode = MTL_COMPMODE_DSTOUT;\n-                break;\n-\n-            case ADD:\n-                mtlCompMode = MTL_COMPMODE_ADD;\n-                break;\n-\n-            default:\n-                throw new InternalError(\"Unrecognized composite mode: \" + mode);\n-        }\n+        int mtlCompMode = switch (mode) {\n+            case CLEAR    -> MTL_COMPMODE_CLEAR;\n+            case SRC      -> MTL_COMPMODE_SRC;\n+            case SRC_OVER -> MTL_COMPMODE_SRCOVER;\n+            case DST_OUT  -> MTL_COMPMODE_DSTOUT;\n+            case ADD      -> MTL_COMPMODE_ADD;\n+        };\n@@ -314,2 +289,2 @@\n-        long dstNativeHandle = dstRTT == null ? 0L : ((MTLTexture)dstRTT).getNativeHandle();\n-        long srcNativeHandle = ((MTLTexture<?>)srcRTT).getNativeHandle();\n+        long dstNativeHandle = (dstRTT instanceof MTLTexture mtl) ? mtl.getNativeHandle() : 0L;\n+        long srcNativeHandle = (srcRTT instanceof MTLTexture mtl) ? mtl.getNativeHandle() : 0L;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLContext.java","additions":28,"deletions":53,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -42,4 +42,1 @@\n-        if (target == null) {\n-            return null;\n-        }\n-        return new MTLGraphics(context, target);\n+        return target == null ? null : new MTLGraphics(context, target);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLGraphics.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,2 +56,1 @@\n-    private MTLPipeline() {\n-    }\n+    private MTLPipeline() {}\n@@ -91,1 +90,1 @@\n-            Map devDetails = MTLPipeline.getInstance().getDeviceDetails();\n+            Map<String, Long> devDetails = MTLPipeline.getInstance().getDeviceDetails();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLPipeline.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-        Objects.requireNonNull(shaderName, \"Shader name must be non-null\");\n+        Objects.requireNonNull(shaderName, \"Shader name not be null\");\n@@ -259,1 +259,1 @@\n-                    byte arr[] = new byte[texWidth * texHeight];\n+                    byte[] arr = new byte[texWidth * texHeight];\n@@ -280,14 +280,11 @@\n-        switch (format) {\n-            case BYTE_RGB:\n-            case BYTE_GRAY:\n-            case BYTE_ALPHA:\n-            case BYTE_BGRA_PRE:\n-            case INT_ARGB_PRE:\n-            case FLOAT_XYZW:\n-            case BYTE_APPLE_422:\n-                return true;\n-\n-            case MULTI_YCbCr_420:\n-            default:\n-                return false;\n-        }\n+        return switch (format) {\n+            case BYTE_RGB,\n+                 BYTE_GRAY,\n+                 BYTE_ALPHA,\n+                 BYTE_BGRA_PRE,\n+                 BYTE_APPLE_422,\n+                 INT_ARGB_PRE,\n+                 FLOAT_XYZW -> true;\n+\n+            case MULTI_YCbCr_420 -> false;\n+        };\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLResourceFactory.java","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-        currentEnabledShader.textureIdRefMap.put(texUnit, new WeakReference(tex));\n+        currentEnabledShader.textureIdRefMap.put(texUnit, new WeakReference<>(tex));\n@@ -191,1 +191,1 @@\n-    private static native Map  nGetUniformNameIdMap(long nMetalShader);\n+    private static native Map<String, Integer>  nGetUniformNameIdMap(long nMetalShader);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLShader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        if (this.pState != state ||\n+        if (pState != state ||\n@@ -153,0 +153,3 @@\n+        if (g == null) {\n+            return null;\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLSwapChain.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-            case PixelFormat.DataType.INT:\n+            case PixelFormat.DataType.INT -> {\n@@ -107,1 +107,1 @@\n-                break;\n+            }\n@@ -109,1 +109,1 @@\n-            case PixelFormat.DataType.FLOAT:\n+            case PixelFormat.DataType.FLOAT -> {\n@@ -118,1 +118,1 @@\n-                break;\n+            }\n@@ -120,1 +120,1 @@\n-            case PixelFormat.DataType.BYTE:\n+            case PixelFormat.DataType.BYTE -> {\n@@ -126,2 +126,2 @@\n-                    case PixelFormat.BYTE_BGRA_PRE:\n-                    case PixelFormat.BYTE_ALPHA:\n+                    case PixelFormat.BYTE_BGRA_PRE,\n+                         PixelFormat.BYTE_ALPHA ->\n@@ -130,1 +130,0 @@\n-                        break;\n@@ -132,1 +131,1 @@\n-                    case PixelFormat.BYTE_RGB:\n+                    case PixelFormat.BYTE_RGB -> {\n@@ -154,1 +153,1 @@\n-                        break;\n+                    }\n@@ -156,1 +155,1 @@\n-                    case PixelFormat.BYTE_GRAY:\n+                    case PixelFormat.BYTE_GRAY -> {\n@@ -163,4 +162,4 @@\n-                        arr32Bit = new byte[srcw * srch * 4];\n-                        dstIndex = 0;\n-                        index = 0;\n-                        totalBytes = srch * srcw;\n+                        byte[] arr32Bit = new byte[srcw * srch * 4];\n+                        int dstIndex = 0;\n+                        int index = 0;\n+                        int totalBytes = srch * srcw;\n@@ -179,4 +178,4 @@\n-                        break;\n-                    case PixelFormat.MULTI_YCbCr_420:\n-                    case PixelFormat.BYTE_APPLE_422:\n-                    default:\n+                    }\n+\n+                    case PixelFormat.MULTI_YCbCr_420,\n+                         PixelFormat.BYTE_APPLE_422 ->\n@@ -185,4 +184,1 @@\n-                break;\n-\n-            default:\n-                throw new IllegalArgumentException(\"Unsupported PixelFormat DataType: \" + format);\n+            }\n@@ -204,1 +200,1 @@\n-        byte[] arr = pixels.hasArray()? pixels.array(): null;\n+        byte[] arr = pixels.hasArray() ? pixels.array() : null;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLTexture.java","additions":20,"deletions":24,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-        Objects.requireNonNull(context);\n+        Objects.requireNonNull(context, \"MTLContext must not be null\");\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLTextureData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}