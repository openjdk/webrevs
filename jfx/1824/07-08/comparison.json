{"files":[{"patch":"@@ -332,0 +332,1 @@\n+            fragmentShaderHeader.append(\"#endif\\n\");\n@@ -333,2 +334,1 @@\n-            try {\n-                FileWriter fragmentShaderHeaderFile = new FileWriter(headerFilesDir + FRAGMENT_SHADER_HEADER_FILE_NAME);\n+            try (FileWriter fragmentShaderHeaderFile = new FileWriter(headerFilesDir + FRAGMENT_SHADER_HEADER_FILE_NAME)) {\n@@ -336,2 +336,0 @@\n-                fragmentShaderHeaderFile.write(\"#endif\\n\");\n-                fragmentShaderHeaderFile.close();\n@@ -345,2 +343,1 @@\n-        try {\n-            FileWriter objCHeaderFile = new FileWriter(headerFilesDir + objCHeaderFileName);\n+        try (FileWriter objCHeaderFile = new FileWriter(headerFilesDir + objCHeaderFileName)) {\n@@ -413,2 +410,3 @@\n-            objCHeaderFile.write(\"NSDictionary* get\" + shaderType + \"Dict(NSString* inShaderName) {\\n\");\n-            objCHeaderFile.write(\"    MSL_LOG(@\\\"get\" + shaderType + \"Dict \\\");\\n\");\n+            StringBuilder getShaderDictFunc = new StringBuilder();\n+            getShaderDictFunc.append(\"NSDictionary* get\" + shaderType + \"Dict(NSString* inShaderName) {\\n\");\n+            getShaderDictFunc.append(\"    MSL_LOG(@\\\"get\" + shaderType + \"Dict \\\");\\n\");\n@@ -416,4 +414,4 @@\n-                objCHeaderFile.write(\"    if ([inShaderName isEqualToString:@\\\"\" + aShaderName + \"\\\"]) {\\n\");\n-                objCHeaderFile.write(\"        MSL_LOG(@\\\"get\" + shaderType + \"Dict() : calling -> get\" + aShaderName + \"_Uniform_VarID_Dict()\\\");\\n\");\n-                objCHeaderFile.write(\"        return get\" + aShaderName + \"_Uniform_VarID_Dict();\\n\");\n-                objCHeaderFile.write(\"    }\\n\");\n+                getShaderDictFunc.append(\"    if ([inShaderName isEqualToString:@\\\"\" + aShaderName + \"\\\"]) {\\n\");\n+                getShaderDictFunc.append(\"        MSL_LOG(@\\\"get\" + shaderType + \"Dict() : calling -> get\" + aShaderName + \"_Uniform_VarID_Dict()\\\");\\n\");\n+                getShaderDictFunc.append(\"        return get\" + aShaderName + \"_Uniform_VarID_Dict();\\n\");\n+                getShaderDictFunc.append(\"    }\\n\");\n@@ -421,3 +419,3 @@\n-\n-            objCHeaderFile.write(\"    return nil;\\n\");\n-            objCHeaderFile.write(\"};\\n\\n\");\n+            getShaderDictFunc.append(\"    return nil;\\n\");\n+            getShaderDictFunc.append(\"};\\n\\n\");\n+            objCHeaderFile.write(getShaderDictFunc.toString());\n@@ -426,1 +424,0 @@\n-            objCHeaderFile.close();\n","filename":"modules\/javafx.graphics\/src\/jslc\/java\/com\/sun\/scenario\/effect\/compiler\/backend\/hw\/MSLBackend.java","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -172,2 +172,2 @@\n-        if (camera instanceof NGDefaultCamera) {\n-            ((NGDefaultCamera) camera).validate(targetWidth, targetHeight);\n+        if (camera instanceof NGDefaultCamera ngDefCam) {\n+            ngDefCam.validate(targetWidth, targetHeight);\n@@ -338,2 +338,1 @@\n-    public long getMetalCommandQueue()\n-    {\n+    public long getMetalCommandQueue() {\n@@ -348,2 +347,0 @@\n-        \/\/ if (checkDisposed()) return;\n-        \/\/ nSetDeviceParametersFor2D(pContext);\n@@ -357,2 +354,0 @@\n-        \/\/ if (checkDisposed()) return;\n-        \/\/ nSetDeviceParametersFor3D(pContext);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLContext.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.Map;\n@@ -64,1 +65,1 @@\n-        HashMap devDetails = new HashMap();\n+        Map devDetails = new HashMap();\n@@ -90,1 +91,1 @@\n-            HashMap devDetails = (HashMap) MTLPipeline.getInstance().getDeviceDetails();\n+            Map devDetails = MTLPipeline.getInstance().getDeviceDetails();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLPipeline.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,2 +39,1 @@\n-            MTLResourceFactory.releaseTexture(pTexture);\n-            pTexture = 0L;\n+            super.dispose();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLRTTextureData.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,0 +71,6 @@\n+\n+        \/\/ check if number is power of 2\n+        if ((val & (val - 1)) == 0) {\n+            return val;\n+        }\n+\n@@ -73,1 +79,1 @@\n-            i *= 2;\n+            i <<= 1; \/\/ i *= 2;\n@@ -82,1 +88,1 @@\n-    private void checkTextureSize(int width, int height, MediaFrame frame) {\n+    private void checkTextureSize(int width, int height) {\n@@ -86,3 +92,0 @@\n-            if (frame != null) {\n-                frame.releaseFrame();\n-            }\n@@ -169,1 +172,1 @@\n-        checkTextureSize(allocw, alloch, null);\n+        checkTextureSize(allocw, alloch);\n@@ -183,1 +186,1 @@\n-                (int) formatHint.ordinal(), (int) usageHint.ordinal(),\n+                formatHint.ordinal(), usageHint.ordinal(),\n@@ -202,7 +205,6 @@\n-        int width = frame.getWidth();\n-        int height = frame.getHeight();\n-        int texWidth = frame.getEncodedWidth();\n-        int texHeight = frame.getEncodedHeight();\n-        PixelFormat texFormat = frame.getPixelFormat();\n-\n-        checkTextureSize(texWidth, texHeight, frame);\n+        try {\n+            int width = frame.getWidth();\n+            int height = frame.getHeight();\n+            int texWidth = frame.getEncodedWidth();\n+            int texHeight = frame.getEncodedHeight();\n+            PixelFormat texFormat = frame.getPixelFormat();\n@@ -210,5 +212,1 @@\n-        int bpp = texFormat.getBytesPerPixelUnit();\n-        if (texWidth >= (Integer.MAX_VALUE \/ texHeight \/ bpp)) {\n-            frame.releaseFrame();\n-            throw new RuntimeException(\"Illegal texture dimensions (\" + texWidth + \"x\" + texHeight + \")\");\n-        }\n+            checkTextureSize(texWidth, texHeight);\n@@ -216,16 +214,4 @@\n-        if (texFormat == PixelFormat.MULTI_YCbCr_420) {\n-            \/\/ Create a MultiTexture\n-            MultiTexture tex = new MultiTexture(texFormat, WrapMode.CLAMP_TO_EDGE, width, height);\n-\n-            \/\/ create\/add the subtextures\n-            \/\/ Textures: 0 = luma, 1 = Chroma blue, 2 = Chroma red, 3 = alpha\n-            for (int index = 0; index < frame.planeCount(); index++) {\n-                int subWidth = texWidth;\n-                int subHeight =  texHeight;\n-\n-                if (index == PixelFormat.YCBCR_PLANE_CHROMABLUE\n-                        || index == PixelFormat.YCBCR_PLANE_CHROMARED)\n-                {\n-                    subWidth \/= 2;\n-                    subHeight \/= 2;\n-                }\n+            int bpp = texFormat.getBytesPerPixelUnit();\n+            if (texWidth >= (Integer.MAX_VALUE \/ texHeight \/ bpp)) {\n+                throw new RuntimeException(\"Illegal texture dimensions (\" + texWidth + \"x\" + texHeight + \")\");\n+            }\n@@ -233,2 +219,3 @@\n-                Texture subTex = createTexture(PixelFormat.BYTE_ALPHA, Usage.DYNAMIC, WrapMode.CLAMP_TO_EDGE,\n-                                                  subWidth, subHeight);\n+            if (texFormat == PixelFormat.MULTI_YCbCr_420) {\n+                \/\/ Create a MultiTexture\n+                MultiTexture tex = new MultiTexture(texFormat, WrapMode.CLAMP_TO_EDGE, width, height);\n@@ -236,5 +223,5 @@\n-                if (subTex == null) {\n-                    tex.dispose();\n-                    frame.releaseFrame();\n-                    return null;\n-                }\n+                \/\/ create\/add the subtextures\n+                \/\/ Textures: 0 = luma, 1 = Chroma blue, 2 = Chroma red, 3 = alpha\n+                for (int index = 0; index < frame.planeCount(); index++) {\n+                    int subWidth = texWidth;\n+                    int subHeight =  texHeight;\n@@ -242,2 +229,6 @@\n-                tex.setTexture(subTex, index);\n-            }\n+                    if (index == PixelFormat.YCBCR_PLANE_CHROMABLUE\n+                            || index == PixelFormat.YCBCR_PLANE_CHROMARED)\n+                    {\n+                        subWidth \/= 2;\n+                        subHeight \/= 2;\n+                    }\n@@ -245,4 +236,2 @@\n-            \/\/ Note : Solid_TexuteYV12.metal shader that is used to render this pixel format\n-            \/\/ expects 4 texture parameters\n-            \/\/ Generate alpha texture artificially if it is unavailable in the MediaFrame\n-            if (frame.planeCount() == 3) {\n+                    Texture subTex = createTexture(PixelFormat.BYTE_ALPHA, Usage.DYNAMIC, WrapMode.CLAMP_TO_EDGE,\n+                                                      subWidth, subHeight);\n@@ -250,2 +239,4 @@\n-                Texture subTex = createTexture(PixelFormat.BYTE_ALPHA, Usage.DYNAMIC, WrapMode.CLAMP_TO_EDGE,\n-                                               texWidth, texHeight);\n+                    if (subTex == null) {\n+                        tex.dispose();\n+                        return null;\n+                    }\n@@ -253,4 +244,1 @@\n-                if (subTex == null) {\n-                    tex.dispose();\n-                    frame.releaseFrame();\n-                    return null;\n+                    tex.setTexture(subTex, index);\n@@ -259,5 +247,4 @@\n-                byte arr[] = new byte[texWidth * texHeight];\n-                Arrays.fill(arr, (byte)255);\n-                ByteBuffer pixels = ByteBuffer.wrap(arr);\n-                subTex.update(pixels, PixelFormat.BYTE_ALPHA, 0, 0, 0, 0,\n-                              texWidth, texHeight, texWidth, true);\n+                \/\/ Note : Solid_TexuteYV12.metal shader that is used to render this pixel format\n+                \/\/ expects 4 texture parameters\n+                \/\/ Generate alpha texture artificially if it is unavailable in the MediaFrame\n+                if (frame.planeCount() == 3) {\n@@ -265,2 +252,2 @@\n-                tex.setTexture(subTex, 3);\n-            }\n+                    Texture subTex = createTexture(PixelFormat.BYTE_ALPHA, Usage.DYNAMIC, WrapMode.CLAMP_TO_EDGE,\n+                                                   texWidth, texHeight);\n@@ -268,3 +255,15 @@\n-            frame.releaseFrame();\n-            return tex;\n-        } \/\/ PixelFormat.MULTI_YCbCr_420\n+                    if (subTex == null) {\n+                        tex.dispose();\n+                        return null;\n+                    }\n+\n+                    byte arr[] = new byte[texWidth * texHeight];\n+                    Arrays.fill(arr, (byte)255);\n+                    ByteBuffer pixels = ByteBuffer.wrap(arr);\n+                    subTex.update(pixels, PixelFormat.BYTE_ALPHA, 0, 0, 0, 0,\n+                                  texWidth, texHeight, texWidth, true);\n+\n+                    tex.setTexture(subTex, 3);\n+                }\n+                return tex;\n+            } \/\/ PixelFormat.MULTI_YCbCr_420\n@@ -272,1 +271,1 @@\n-        Texture tex = createTexture(texFormat, Usage.DEFAULT, WrapMode.CLAMP_TO_EDGE, texWidth, texHeight);\n+            Texture tex = createTexture(texFormat, Usage.DEFAULT, WrapMode.CLAMP_TO_EDGE, texWidth, texHeight);\n@@ -274,2 +273,4 @@\n-        frame.releaseFrame();\n-        return tex;\n+            return tex;\n+        } finally {\n+            frame.releaseFrame();\n+        }\n@@ -354,1 +355,1 @@\n-        checkTextureSize(createw, createh, null);\n+        checkTextureSize(createw, createh);\n@@ -389,1 +390,1 @@\n-        checkTextureSize(pState.getRenderWidth(), pState.getRenderHeight(), null);\n+        checkTextureSize(pState.getRenderWidth(), pState.getRenderHeight());\n@@ -395,1 +396,0 @@\n-        super.dispose();\n@@ -397,0 +397,1 @@\n+        super.dispose();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLResourceFactory.java","additions":71,"deletions":70,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            throw new AssertionError(\"Failed to create Shader\");\n+            throw new InternalError(\"Failed to create the Shader : \" + fragmentFunctionName);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLShader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,8 +142,1 @@\n-            } \/*else {\n-                \/\/ RT-27554\n-                \/\/ TODO: this implementation was done to make sure there is a\n-                \/\/ context current for the hardware backbuffer before we start\n-                \/\/ attempting to use the FBO associated with the\n-                \/\/ RTTexture \"backbuffer\"...\n-                MTLGraphics.create(pContext, this);\n-            }*\/\n+            }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLSwapChain.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -97,48 +97,9 @@\n-        if (format.getDataType() == PixelFormat.DataType.INT) {\n-            if (format == PixelFormat.INT_ARGB_PRE) {\n-                IntBuffer buf = (IntBuffer)buffer;\n-                int[] arr = buf.hasArray() ? buf.array() : null;\n-                nUpdateInt(getNativeHandle(), buf, arr,\n-                                dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n-            } else {\n-                throw new IllegalArgumentException(\"Unsupported INT PixelFormat: \" + format);\n-            }\n-\n-        } else if (format.getDataType() == PixelFormat.DataType.FLOAT) {\n-            if (format == PixelFormat.FLOAT_XYZW) {\n-                FloatBuffer buf = (FloatBuffer)buffer;\n-                float[] arr = buf.hasArray() ? buf.array() : null;\n-                nUpdateFloat(getNativeHandle(), buf, arr,\n-                                dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n-            } else {\n-                throw new IllegalArgumentException(\"Unsupported FLOAT PixelFormat: \" + format);\n-            }\n-\n-        } else if (format.getDataType() == PixelFormat.DataType.BYTE) {\n-            ByteBuffer buf = (ByteBuffer)buffer;\n-            buf.rewind();\n-            byte[] arr = buf.hasArray() ? buf.array() : null;\n-\n-            if (format == PixelFormat.BYTE_BGRA_PRE || format == PixelFormat.BYTE_ALPHA) {\n-                nUpdate(getNativeHandle(), buf, arr,\n-                            dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n-\n-            } else if (format == PixelFormat.BYTE_RGB) {\n-                \/\/ Metal does not support 24-bit format\n-                \/\/ hence `arr` data needs to be converted to BGRA format that\n-                \/\/ the native metal texture expects\n-                byte[] arr32Bit = new byte[srcw * srch * 4];\n-                int dstIndex = 0;\n-                int index = 0;\n-\n-                final int rowStride = srcw * 3;\n-                final int totalBytes = srch * rowStride;\n-\n-                for (int rowIndex = 0; rowIndex < totalBytes; rowIndex += rowStride) {\n-                    for (int colIndex = 0; colIndex < rowStride; colIndex += 3) {\n-                        index = rowIndex + colIndex;\n-                        arr32Bit[dstIndex++] = arr[index + 2];\n-                        arr32Bit[dstIndex++] = arr[index + 1];\n-                        arr32Bit[dstIndex++] = arr[index];\n-                        arr32Bit[dstIndex++] = (byte)255;\n-                    }\n+        switch (format.getDataType()) {\n+            case PixelFormat.DataType.INT:\n+                if (format == PixelFormat.INT_ARGB_PRE) {\n+                    IntBuffer buf = (IntBuffer) buffer;\n+                    int[] arr = buf.hasArray() ? buf.array() : null;\n+                    nUpdateInt(getNativeHandle(), buf, arr,\n+                               dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n+                } else {\n+                    throw new IllegalArgumentException(\"Unsupported INT PixelFormat: \" + format);\n@@ -146,23 +107,77 @@\n-                nUpdate(getNativeHandle(), null, arr32Bit,\n-                            dstx, dsty, srcx, srcy, srcw, srch, srcw * 4);\n-\n-            } else if (format == PixelFormat.BYTE_GRAY) {\n-                \/\/ Suitable 8-bit native formats are MTLPixelFormatA8Unorm & MTLPixelFormatR8Unorm.\n-                \/\/ These formats do not work well with our generated shader - Texture_RGB.\n-                \/\/ hence `arr` data is converted to BGRA format here.\n-                \/\/ In future, if needed for performance reason:\n-                \/\/ Texture_RGB shader can be tweaked to fill up R,G,B fields from single byte grayscale value.\n-                \/\/ Care must be taken not to break current behavior of this shader.\n-                byte[] arr32Bit = new byte[srcw * srch * 4];\n-                int dstIndex = 0;\n-                int index = 0;\n-                final int totalBytes = srch * srcw;\n-\n-                for (int rowIndex = 0; rowIndex < totalBytes; rowIndex += srcw) {\n-                    for (int colIndex = 0; colIndex < srcw; colIndex++) {\n-                        index = rowIndex + colIndex;\n-                        arr32Bit[dstIndex++] = arr[index];\n-                        arr32Bit[dstIndex++] = arr[index];\n-                        arr32Bit[dstIndex++] = arr[index];\n-                        arr32Bit[dstIndex++] = (byte)255;\n-                    }\n+                break;\n+\n+            case PixelFormat.DataType.FLOAT:\n+                if (format == PixelFormat.FLOAT_XYZW) {\n+                    FloatBuffer buf = (FloatBuffer) buffer;\n+                    float[] arr = buf.hasArray() ? buf.array() : null;\n+                    nUpdateFloat(getNativeHandle(), buf, arr,\n+                                 dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n+                } else {\n+                    throw new IllegalArgumentException(\"Unsupported FLOAT PixelFormat: \" + format);\n+                }\n+                break;\n+\n+            case PixelFormat.DataType.BYTE:\n+                ByteBuffer buf = (ByteBuffer) buffer;\n+                buf.rewind();\n+                byte[] arr = buf.hasArray() ? buf.array() : null;\n+\n+                switch (format) {\n+                    case PixelFormat.BYTE_BGRA_PRE:\n+                    case PixelFormat.BYTE_ALPHA:\n+                        nUpdate(getNativeHandle(), buf, arr,\n+                                dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n+                        break;\n+\n+                    case PixelFormat.BYTE_RGB:\n+                        \/\/ Convert 24-bit RGB to 32-bit BGRA\n+                        \/\/ Metal does not support 24-bit format\n+                        \/\/ hence `arr` data needs to be converted to BGRA format\n+                        byte[] arr32Bit = new byte[srcw * srch * 4];\n+                        int dstIndex = 0;\n+                        int index = 0;\n+\n+                        int rowStride = srcw * 3;\n+                        int totalBytes = srch * rowStride;\n+\n+                        for (int rowIndex = 0; rowIndex < totalBytes; rowIndex += rowStride) {\n+                            for (int colIndex = 0; colIndex < rowStride; colIndex += 3) {\n+                                index = rowIndex + colIndex;\n+                                arr32Bit[dstIndex++] = arr[index + 2];\n+                                arr32Bit[dstIndex++] = arr[index + 1];\n+                                arr32Bit[dstIndex++] = arr[index];\n+                                arr32Bit[dstIndex++] = (byte)255;\n+                            }\n+                        }\n+                        nUpdate(getNativeHandle(), null, arr32Bit,\n+                                dstx, dsty, srcx, srcy, srcw, srch, srcw * 4);\n+                        break;\n+\n+                    case PixelFormat.BYTE_GRAY:\n+                        \/\/ Suitable 8-bit native formats are MTLPixelFormatA8Unorm & MTLPixelFormatR8Unorm.\n+                        \/\/ These formats do not work well with our generated shader - Texture_RGB.\n+                        \/\/ hence `arr` data is converted to BGRA format here.\n+                        \/\/ In future, if needed for performance reason:\n+                        \/\/ Texture_RGB shader can be tweaked to fill up R,G,B fields from single byte grayscale value.\n+                        \/\/ Care must be taken not to break current behavior of this shader.\n+                        arr32Bit = new byte[srcw * srch * 4];\n+                        dstIndex = 0;\n+                        index = 0;\n+                        totalBytes = srch * srcw;\n+\n+                        for (int rowIndex = 0; rowIndex < totalBytes; rowIndex += srcw) {\n+                            for (int colIndex = 0; colIndex < srcw; colIndex++) {\n+                                index = rowIndex + colIndex;\n+                                arr32Bit[dstIndex++] = arr[index];\n+                                arr32Bit[dstIndex++] = arr[index];\n+                                arr32Bit[dstIndex++] = arr[index];\n+                                arr32Bit[dstIndex++] = (byte) 255;\n+                            }\n+                        }\n+                        nUpdate(getNativeHandle(), null, arr32Bit,\n+                                dstx, dsty, srcx, srcy, srcw, srch, srcw * 4);\n+                        break;\n+                    case PixelFormat.MULTI_YCbCr_420:\n+                    case PixelFormat.BYTE_APPLE_422:\n+                    default:\n+                        throw new IllegalArgumentException(\"Unsupported PixelFormat \" + format);\n@@ -170,8 +185,4 @@\n-                nUpdate(getNativeHandle(), null, arr32Bit,\n-                            dstx, dsty, srcx, srcy, srcw, srch, srcw * 4);\n-\n-            } else if (format == PixelFormat.MULTI_YCbCr_420 || format == PixelFormat.BYTE_APPLE_422) {\n-                throw new IllegalArgumentException(\"PixelFormat not yet supported by Metal pipeline: \" + format);\n-            }\n-        } else {\n-            throw new IllegalArgumentException(\"Unsupported PixelFormat DataType: \" + format);\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported PixelFormat DataType: \" + format);\n@@ -181,0 +192,1 @@\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLTexture.java","additions":91,"deletions":79,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-        \/\/ MSL shaders are compilend and linked into a MTLLibrary at build time.\n+        \/\/ MSL shaders are compiled and linked into a MTLLibrary at build time.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/scenario\/effect\/impl\/hw\/mtl\/MTLShaderSource.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,4 +140,5 @@\n-            [[(GlassCGLOffscreen*)glassOffScreen getLayer] performSelectorOnMainThread:@selector(setNeedsDisplay)\n-                                                                            withObject:nil\n-                                                                         waitUntilDone:NO\n-                                                                                 modes:allModes];\n+            [[(GlassCGLOffscreen*)glassOffScreen getLayer]\n+                performSelectorOnMainThread:@selector(setNeedsDisplay)\n+                                 withObject:nil\n+                              waitUntilDone:NO\n+                                      modes:allModes];\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassCGLOffscreen.m","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -66,3 +66,5 @@\n-    [(NSObject*)self->_fbo release];\n-    self->_fbo = nil;\n-    [super dealloc];\n+    if (self->_fbo != nil) {\n+        [(NSObject*)self->_fbo release];\n+        self->_fbo = nil;\n+        [super dealloc];\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassMTLOffscreen.m","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}