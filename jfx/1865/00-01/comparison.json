{"files":[{"patch":"@@ -80,1 +80,1 @@\n-    return !m_zstream.avail_in && (!m_didFinish || (m_didFinish && result == Z_STREAM_END));\n+    return !m_zstream.getPlatformStream().avail_in && (!m_didFinish || (m_didFinish && result == Z_STREAM_END));\n@@ -91,0 +91,1 @@\n+    return true;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/Modules\/compression\/CompressionStreamEncoder.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"FEColorMatrixSkiaApplier.h\"\n-\n-#if USE(SKIA)\n-\n-#include \"FEColorMatrix.h\"\n-#include \"FilterImage.h\"\n-#include \"GraphicsContext.h\"\n-#include \"ImageBuffer.h\"\n-#include \"NativeImage.h\"\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN \/\/ GLib\/Win port\n-#include <skia\/core\/SkCanvas.h>\n-#include <skia\/core\/SkColorFilter.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-#include <wtf\/TZoneMallocInlines.h>\n-\n-namespace WebCore {\n-\n-WTF_MAKE_TZONE_ALLOCATED_IMPL(FEColorMatrixSkiaApplier);\n-\n-bool FEColorMatrixSkiaApplier::apply(const Filter&, const FilterImageVector& inputs, FilterImage& result) const\n-{\n-    ASSERT(inputs.size() == 1);\n-    Ref input = inputs[0];\n-\n-    RefPtr resultImage = result.imageBuffer();\n-    RefPtr sourceImage = input->imageBuffer();\n-    if (!resultImage || !sourceImage)\n-        return false;\n-\n-    auto nativeImage = sourceImage->createNativeImageReference();\n-    if (!nativeImage || !nativeImage->platformImage())\n-        return false;\n-\n-    auto values = FEColorMatrix::normalizedFloats(m_effect->values());\n-    Vector<float> matrix;\n-\n-    std::array<float, 9> components;\n-\n-    switch (m_effect->type()) {\n-    case ColorMatrixType::FECOLORMATRIX_TYPE_MATRIX:\n-        matrix = values;\n-        break;\n-\n-    case ColorMatrixType::FECOLORMATRIX_TYPE_SATURATE:\n-        FEColorMatrix::calculateSaturateComponents(components, values[0]);\n-        matrix = Vector<float>({\n-            components[0], components[1], components[2], 0.0, 0.0,\n-            components[3], components[4], components[5], 0.0, 0.0,\n-            components[6], components[7], components[8], 0.0, 0.0,\n-            0.0, 0.0, 0.0, 1.0, 0.0,\n-        });\n-        break;\n-\n-    case ColorMatrixType::FECOLORMATRIX_TYPE_HUEROTATE:\n-        FEColorMatrix::calculateHueRotateComponents(components, values[0]);\n-        matrix = Vector<float>({\n-            components[0], components[1], components[2], 0.0, 0.0,\n-            components[3], components[4], components[5], 0.0, 0.0,\n-            components[6], components[7], components[8], 0.0, 0.0,\n-            0.0, 0.0, 0.0, 1.0, 0.0,\n-        });\n-        break;\n-\n-    case ColorMatrixType::FECOLORMATRIX_TYPE_LUMINANCETOALPHA:\n-        matrix = Vector<float>({\n-            0.0,    0.0,    0.0,    0.0, 0.0,\n-            0.0,    0.0,    0.0,    0.0, 0.0,\n-            0.0,    0.0,    0.0,    0.0, 0.0,\n-            0.2125, 0.7154, 0.0721, 0.0, 0.0,\n-        });\n-        break;\n-\n-    case ColorMatrixType::FECOLORMATRIX_TYPE_UNKNOWN:\n-        return false;\n-    }\n-\n-    SkPaint paint;\n-    paint.setColorFilter(SkColorFilters::Matrix(matrix.data()));\n-\n-    auto inputOffsetWithinResult = input->absoluteImageRectRelativeTo(result).location();\n-    resultImage->context().platformContext()->drawImage(nativeImage->platformImage(), inputOffsetWithinResult.x(), inputOffsetWithinResult.y(), { }, &paint);\n-    return true;\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/filters\/skia\/FEColorMatrixSkiaApplier.cpp","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"FEComponentTransferSkiaApplier.h\"\n-\n-#if USE(SKIA)\n-\n-#include \"FEComponentTransfer.h\"\n-#include \"FilterImage.h\"\n-#include \"GraphicsContext.h\"\n-#include \"ImageBuffer.h\"\n-#include \"NativeImage.h\"\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN \/\/ GLib\/Win ports\n-#include <skia\/core\/SkCanvas.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-#include <skia\/core\/SkColorFilter.h>\n-#include <wtf\/TZoneMallocInlines.h>\n-\n-namespace WebCore {\n-\n-WTF_MAKE_TZONE_ALLOCATED_IMPL(FEComponentTransferSkiaApplier);\n-\n-bool FEComponentTransferSkiaApplier::apply(const Filter&, const FilterImageVector& inputs, FilterImage& result) const\n-{\n-    ASSERT(inputs.size() == 1);\n-    Ref input = inputs[0];\n-\n-    RefPtr resultImage = result.imageBuffer();\n-    RefPtr sourceImage = input->imageBuffer();\n-    if (!resultImage || !sourceImage)\n-        return false;\n-\n-    auto nativeImage = sourceImage->createNativeImageReference();\n-    if (!nativeImage || !nativeImage->platformImage())\n-        return false;\n-\n-    auto alphaTable = m_effect->computeLookupTable(m_effect->alphaFunction());\n-    auto redTable = m_effect->computeLookupTable(m_effect->redFunction());\n-    auto greenTable = m_effect->computeLookupTable(m_effect->greenFunction());\n-    auto blueTable = m_effect->computeLookupTable(m_effect->blueFunction());\n-\n-    SkPaint paint;\n-    paint.setColorFilter(SkColorFilters::TableARGB(alphaTable.data(), redTable.data(), greenTable.data(), blueTable.data()));\n-\n-    auto inputOffsetWithinResult = input->absoluteImageRectRelativeTo(result).location();\n-    resultImage->context().platformContext()->drawImage(nativeImage->platformImage(), inputOffsetWithinResult.x(), inputOffsetWithinResult.y(), { }, &paint);\n-    return true;\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/filters\/skia\/FEComponentTransferSkiaApplier.cpp","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"FEDropShadowSkiaApplier.h\"\n-\n-#if USE(SKIA)\n-\n-#include \"FEDropShadow.h\"\n-#include \"Filter.h\"\n-#include \"FilterImage.h\"\n-#include \"GraphicsContext.h\"\n-#include \"ImageBuffer.h\"\n-#include \"NativeImage.h\"\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN \/\/ GLib\/Win ports\n-#include <skia\/core\/SkCanvas.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-#include <skia\/effects\/SkImageFilters.h>\n-#include <wtf\/TZoneMallocInlines.h>\n-\n-namespace WebCore {\n-\n-WTF_MAKE_TZONE_ALLOCATED_IMPL(FEDropShadowSkiaApplier);\n-\n-bool FEDropShadowSkiaApplier::apply(const Filter& filter, const FilterImageVector& inputs, FilterImage& result) const\n-{\n-    ASSERT(inputs.size() == 1);\n-    Ref input = inputs[0];\n-\n-    RefPtr resultImage = result.imageBuffer();\n-    RefPtr sourceImage = input->imageBuffer();\n-    if (!resultImage || !sourceImage)\n-        return false;\n-\n-    auto nativeImage = sourceImage->createNativeImageReference();\n-    if (!nativeImage || !nativeImage->platformImage())\n-        return false;\n-\n-    auto offset = filter.scaledByFilterScale(filter.resolvedSize({ m_effect->dx(), m_effect->dy() }));\n-    auto sigma = filter.scaledByFilterScale(filter.resolvedSize({ m_effect->stdDeviationX(), m_effect->stdDeviationY() }));\n-\n-    SkPaint paint;\n-\n-    auto shadowColorWithAlpha = m_effect->shadowColor().colorWithAlphaMultipliedBy(m_effect->shadowOpacity());\n-    paint.setImageFilter(SkImageFilters::DropShadow(offset.width(), offset.height(), sigma.width(), sigma.height(), shadowColorWithAlpha, nullptr));\n-\n-    auto inputOffsetWithinResult = input->absoluteImageRectRelativeTo(result).location();\n-    resultImage->context().platformContext()->drawImage(nativeImage->platformImage(), inputOffsetWithinResult.x(), inputOffsetWithinResult.y(), { }, &paint);\n-    return true;\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/filters\/skia\/FEDropShadowSkiaApplier.cpp","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"FEGaussianBlurSkiaApplier.h\"\n-\n-#if USE(SKIA)\n-\n-#include \"FEGaussianBlur.h\"\n-#include \"Filter.h\"\n-#include \"FilterImage.h\"\n-#include \"GraphicsContext.h\"\n-#include \"NativeImage.h\"\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN \/\/ GLib\/Win ports\n-#include <skia\/core\/SkCanvas.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-#include <skia\/effects\/SkImageFilters.h>\n-#include <wtf\/TZoneMallocInlines.h>\n-\n-namespace WebCore {\n-\n-WTF_MAKE_TZONE_ALLOCATED_IMPL(FEGaussianBlurSkiaApplier);\n-\n-bool FEGaussianBlurSkiaApplier::apply(const Filter& filter, const FilterImageVector& inputs, FilterImage& result) const\n-{\n-    ASSERT(inputs.size() == 1);\n-    Ref input = inputs[0];\n-\n-    RefPtr resultImage = result.imageBuffer();\n-    RefPtr sourceImage = input->imageBuffer();\n-    if (!resultImage || !sourceImage)\n-        return false;\n-\n-    auto nativeImage = sourceImage->createNativeImageReference();\n-    if (!nativeImage || !nativeImage->platformImage())\n-        return false;\n-\n-    FloatSize sigma = FloatSize(m_effect->stdDeviationX(), m_effect->stdDeviationY()) * filter.filterScale();\n-\n-    SkPaint paint;\n-    paint.setImageFilter(SkImageFilters::Blur(sigma.width(), sigma.height(), nullptr));\n-\n-    auto inputOffsetWithinResult = input->absoluteImageRectRelativeTo(result).location();\n-    resultImage->context().platformContext()->drawImage(nativeImage->platformImage(), inputOffsetWithinResult.x(), inputOffsetWithinResult.y(), { }, &paint);\n-    return true;\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/filters\/skia\/FEGaussianBlurSkiaApplier.cpp","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,223 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"ComplexTextController.h\"\n-\n-#include \"FontCascade.h\"\n-#include \"FontFeatureValues.h\"\n-#include \"FontTaggedSettings.h\"\n-#include \"HbUniquePtr.h\"\n-#include \"SurrogatePairAwareTextIterator.h\"\n-#include \"text\/TextFlags.h\"\n-#include <hb-icu.h>\n-#include <hb-ot.h>\n-#include <hb.h>\n-\n-namespace WebCore {\n-\n-static inline float harfBuzzPositionToFloat(hb_position_t value)\n-{\n-    return static_cast<float>(value) \/ (1 << 16);\n-}\n-\n-ComplexTextController::ComplexTextRun::ComplexTextRun(hb_buffer_t* buffer, const Font& font, std::span<const UChar> characters, unsigned stringLocation, unsigned indexBegin, unsigned indexEnd)\n-    : m_initialAdvance(0, 0)\n-    , m_font(font)\n-    , m_characters(characters)\n-    , m_indexBegin(indexBegin)\n-    , m_indexEnd(indexEnd)\n-    , m_glyphCount(hb_buffer_get_length(buffer))\n-    , m_stringLocation(stringLocation)\n-    , m_isLTR(HB_DIRECTION_IS_FORWARD(hb_buffer_get_direction(buffer)))\n-    , m_textAutospaceSize(TextAutospace::textAutospaceSize(font))\n-{\n-    if (!m_glyphCount)\n-        return;\n-\n-    m_glyphs.grow(m_glyphCount);\n-    m_baseAdvances.grow(m_glyphCount);\n-    m_glyphOrigins.grow(m_glyphCount);\n-    m_coreTextIndices.grow(m_glyphCount);\n-\n-    WTF_ALLOW_UNSAFE_BUFFER_USAGE_BEGIN \/\/ GLib\/Win port\n-    hb_glyph_info_t* glyphInfos = hb_buffer_get_glyph_infos(buffer, nullptr);\n-    hb_glyph_position_t* glyphPositions = hb_buffer_get_glyph_positions(buffer, nullptr);\n-    WTF_ALLOW_UNSAFE_BUFFER_USAGE_END\n-\n-    \/\/ HarfBuzz returns the shaping result in visual order. We don't need to flip for RTL.\n-    for (unsigned i = 0; i < m_glyphCount; ++i) {\n-        m_coreTextIndices[i] = glyphInfos[i].cluster;\n-\n-        uint16_t glyph = glyphInfos[i].codepoint;\n-        if (m_font.isZeroWidthSpaceGlyph(glyph) || !m_font.platformData().size()) {\n-            m_glyphs[i] = glyph;\n-            m_baseAdvances[i] = { };\n-            m_glyphOrigins[i] = { };\n-            continue;\n-        }\n-\n-        float offsetX = harfBuzzPositionToFloat(glyphPositions[i].x_offset);\n-        float offsetY = harfBuzzPositionToFloat(glyphPositions[i].y_offset);\n-        float advanceX = harfBuzzPositionToFloat(glyphPositions[i].x_advance);\n-        float advanceY = harfBuzzPositionToFloat(glyphPositions[i].y_advance);\n-\n-        m_glyphs[i] = glyph;\n-        m_baseAdvances[i] = { advanceX, advanceY };\n-        m_glyphOrigins[i] = { offsetX, offsetY };\n-    }\n-    m_initialAdvance = toFloatSize(m_glyphOrigins[0]);\n-}\n-\n-static std::optional<UScriptCode> characterScript(char32_t character)\n-{\n-    UErrorCode errorCode = U_ZERO_ERROR;\n-    UScriptCode script = uscript_getScript(character, &errorCode);\n-    if (U_FAILURE(errorCode))\n-        return std::nullopt;\n-    return script;\n-}\n-\n-struct HBRun {\n-    unsigned startIndex;\n-    unsigned endIndex;\n-    UScriptCode script;\n-};\n-\n-static std::optional<HBRun> findNextRun(std::span<const UChar> characters, unsigned offset)\n-{\n-    SurrogatePairAwareTextIterator textIterator(characters.subspan(offset), offset, characters.size());\n-    char32_t character;\n-    unsigned clusterLength = 0;\n-    if (!textIterator.consume(character, clusterLength))\n-        return std::nullopt;\n-\n-    auto currentScript = characterScript(character);\n-    if (!currentScript)\n-        return std::nullopt;\n-\n-    unsigned startIndex = offset;\n-    for (textIterator.advance(clusterLength); textIterator.consume(character, clusterLength); textIterator.advance(clusterLength)) {\n-        if (FontCascade::treatAsZeroWidthSpace(character))\n-            continue;\n-\n-        auto nextScript = characterScript(character);\n-        if (!nextScript)\n-            return std::nullopt;\n-\n-        \/\/ §5.1 Handling Characters with the Common Script Property.\n-        \/\/ Programs must resolve any of the special Script property values, such as Common,\n-        \/\/ based on the context of the surrounding characters. A simple heuristic uses the\n-        \/\/ script of the preceding character, which works well in many cases.\n-        \/\/ http:\/\/www.unicode.org\/reports\/tr24\/#Common.\n-        \/\/\n-        \/\/ FIXME: cover all other cases mentioned in the spec (ie. brackets or quotation marks).\n-        \/\/ https:\/\/bugs.webkit.org\/show_bug.cgi?id=177003.\n-        \/\/\n-        \/\/ If next script is inherited or common, keep using the current script.\n-        if (nextScript == USCRIPT_INHERITED || nextScript == USCRIPT_COMMON)\n-            continue;\n-        \/\/ If current script is inherited or common, set the next script as current.\n-        if (currentScript == USCRIPT_INHERITED || currentScript == USCRIPT_COMMON) {\n-            currentScript = nextScript;\n-            continue;\n-        }\n-\n-        if (currentScript != nextScript && !uscript_hasScript(character, currentScript.value()))\n-            return std::optional<HBRun>({ startIndex, textIterator.currentIndex(), currentScript.value() });\n-    }\n-\n-    return std::optional<HBRun>({ startIndex, textIterator.currentIndex(), currentScript.value() });\n-}\n-\n-void ComplexTextController::collectComplexTextRunsForCharacters(std::span<const UChar> characters, unsigned stringLocation, const Font* font)\n-{\n-    if (!font) {\n-        \/\/ Create a run of missing glyphs from the primary font.\n-        m_complexTextRuns.append(ComplexTextRun::create(m_font.primaryFont(), characters, stringLocation, 0, characters.size(), m_run.ltr()));\n-        return;\n-    }\n-\n-    Vector<HBRun> runList;\n-    size_t offset = 0;\n-    while (offset < characters.size()) {\n-        auto run = findNextRun(characters, offset);\n-        if (!run)\n-            break;\n-        runList.append(run.value());\n-        offset = run->endIndex;\n-    }\n-\n-    size_t runCount = runList.size();\n-    if (!runCount)\n-        return;\n-\n-    const auto& fontPlatformData = font->platformData();\n-    auto* hbFont = fontPlatformData.hbFont();\n-    RELEASE_ASSERT(hbFont);\n-\n-    const auto& features = fontPlatformData.features();\n-    \/\/ Kerning is not handled as font features, so only in case it's explicitly disabled\n-    \/\/ we need to create a new vector to include kern feature.\n-    const hb_feature_t* featuresData = features.isEmpty() ? nullptr : features.data();\n-    unsigned featuresSize = features.size();\n-    Vector<hb_feature_t> featuresWithKerning;\n-    if (!m_font.enableKerning()) {\n-        featuresWithKerning.reserveInitialCapacity(featuresSize + 1);\n-        featuresWithKerning.append({ HB_TAG('k', 'e', 'r', 'n'), 0, 0, static_cast<unsigned>(-1) });\n-        featuresWithKerning.appendVector(features);\n-        featuresData = featuresWithKerning.data();\n-        featuresSize = featuresWithKerning.size();\n-    }\n-\n-    HbUniquePtr<hb_buffer_t> buffer(hb_buffer_create());\n-\n-    \/\/ The computed \"locale\" equals the \"lang\" attribute. The latter must be a valid BCP 47 language tag,\n-    \/\/ according to <https:\/\/html.spec.whatwg.org\/multipage\/dom.html#attr-lang>.\n-    \/\/ According to <https:\/\/datatracker.ietf.org\/doc\/html\/rfc5646#section-2.1>\n-    \/\/ \"the language tags described in this document are sequences of characters\n-    \/\/ from the US-ASCII [ISO646] repertoire.\".\n-    auto language = hb_language_from_string(m_font.fontDescription().computedLocale().string().ascii().data(), -1);\n-\n-    for (unsigned i = 0; i < runCount; ++i) {\n-        hb_buffer_set_language(buffer.get(), language);\n-\n-        auto& run = runList[m_run.rtl() ? runCount - i - 1 : i];\n-\n-        hb_buffer_set_script(buffer.get(), hb_icu_script_to_script(run.script));\n-\n-        if (!m_mayUseNaturalWritingDirection || m_run.directionalOverride())\n-            hb_buffer_set_direction(buffer.get(), m_run.rtl() ? HB_DIRECTION_RTL : HB_DIRECTION_LTR);\n-        else\n-            hb_buffer_set_direction(buffer.get(), hb_script_get_horizontal_direction(hb_icu_script_to_script(run.script)));\n-\n-        hb_buffer_add_utf16(buffer.get(), reinterpret_cast<const uint16_t*>(characters.data()), characters.size(), run.startIndex, run.endIndex - run.startIndex);\n-\n-        hb_shape(hbFont, buffer.get(), featuresData, featuresSize);\n-        m_complexTextRuns.append(ComplexTextRun::create(buffer.get(), *font, characters, stringLocation, run.startIndex, run.endIndex));\n-        hb_buffer_reset(buffer.get());\n-    }\n-}\n-\n-} \/\/ namespace WebCore\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/ComplexTextControllerSkia.cpp","additions":0,"deletions":223,"binary":false,"changes":223,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"DrawGlyphsRecorder.h\"\n-\n-#include \"FloatPoint.h\"\n-#include \"Font.h\"\n-#include \"GlyphBuffer.h\"\n-\n-namespace WebCore {\n-\n-DrawGlyphsRecorder::DrawGlyphsRecorder(GraphicsContext& owner, float, DeriveFontFromContext deriveFontFromContext)\n-    : m_owner(owner)\n-    , m_deriveFontFromContext(deriveFontFromContext)\n-{\n-}\n-\n-void DrawGlyphsRecorder::drawGlyphs(const Font& font, std::span<const GlyphBufferGlyph> glyphs, std::span<const GlyphBufferAdvance> advances, const FloatPoint& startPoint, FontSmoothingMode smoothingMode)\n-{\n-    m_owner.drawGlyphsAndCacheResources(font, glyphs, advances, startPoint, smoothingMode);\n-}\n-\n-} \/\/ namespace WebCore\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/DrawGlyphsRecorderSkia.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"FloatRoundedRect.h\"\n-\n-#if USE(SKIA)\n-\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkRRect.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-\n-namespace WebCore {\n-\n-FloatRoundedRect::FloatRoundedRect(const SkRRect& skRect)\n-    : m_rect(skRect.rect())\n-{\n-    SkVector corner = skRect.radii(SkRRect::kUpperLeft_Corner);\n-    m_radii.setTopLeft({ corner.x(), corner.y() });\n-    corner = skRect.radii(SkRRect::kUpperRight_Corner);\n-    m_radii.setTopRight({ corner.x(), corner.y() });\n-    corner = skRect.radii(SkRRect::kLowerRight_Corner);\n-    m_radii.setBottomRight({ corner.x(), corner.y() });\n-    corner = skRect.radii(SkRRect::kLowerLeft_Corner);\n-    m_radii.setBottomLeft({ corner.x(), corner.y() });\n-}\n-\n-FloatRoundedRect::operator SkRRect() const\n-{\n-    if (!isRounded())\n-        return SkRRect::MakeRect(rect());\n-\n-    WTF_ALLOW_UNSAFE_BUFFER_USAGE_BEGIN \/\/ GLib\/Win port\n-    SkVector radii[4];\n-    radii[SkRRect::kUpperLeft_Corner].set(m_radii.topLeft().width(), m_radii.topLeft().height());\n-    radii[SkRRect::kUpperRight_Corner].set(m_radii.topRight().width(), m_radii.topRight().height());\n-    radii[SkRRect::kLowerRight_Corner].set(m_radii.bottomRight().width(), m_radii.bottomRight().height());\n-    radii[SkRRect::kLowerLeft_Corner].set(m_radii.bottomLeft().width(), m_radii.bottomLeft().height());\n-    WTF_ALLOW_UNSAFE_BUFFER_USAGE_END\n-\n-    SkRRect skRect;\n-    skRect.setRectRadii(rect(), radii);\n-    return skRect;\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/FloatRoundedRectSkia.cpp","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,409 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"FontCache.h\"\n-\n-#include \"Font.h\"\n-#include \"FontDescription.h\"\n-#include \"StyleFontSizeFunctions.h\"\n-#include <wtf\/Assertions.h>\n-#include <wtf\/text\/CString.h>\n-#include <wtf\/text\/CharacterProperties.h>\n-#include <wtf\/unicode\/CharacterNames.h>\n-\n-#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))\n-#include \"SystemSettings.h\"\n-#endif\n-\n-#if OS(ANDROID)\n-#include <skia\/ports\/SkFontMgr_android.h>\n-#elif PLATFORM(WIN)\n-#include <dwrite.h>\n-#include <skia\/ports\/SkTypeface_win.h>\n-#else\n-#include <skia\/ports\/SkFontMgr_fontconfig.h>\n-#endif\n-\n-namespace WebCore {\n-\n-void FontCache::platformInit()\n-{\n-}\n-\n-SkFontMgr& FontCache::fontManager() const\n-{\n-    if (!m_fontManager) {\n-#if OS(ANDROID)\n-        m_fontManager = SkFontMgr_New_Android(nullptr);\n-#elif OS(WINDOWS)\n-        auto result = createDWriteFactory();\n-        m_fontManager = SkFontMgr_New_DirectWrite(result.factory.get(), result.fontCollection.get());\n-#else\n-        m_fontManager = SkFontMgr_New_FontConfig(FcConfigReference(nullptr));\n-#endif\n-    }\n-    RELEASE_ASSERT(m_fontManager);\n-    return *m_fontManager.get();\n-}\n-\n-static SkFontStyle skiaFontStyle(const FontDescription& fontDescription)\n-{\n-    int skWeight = SkFontStyle::kNormal_Weight;\n-    auto weight = fontDescription.weight();\n-    if (weight > FontSelectionValue(SkFontStyle::kInvisible_Weight) && weight <= FontSelectionValue(SkFontStyle::kExtraBlack_Weight))\n-        skWeight = static_cast<int>(weight);\n-\n-    int skWidth = SkFontStyle::kNormal_Width;\n-    auto width = fontDescription.width();\n-    if (width <= ultraCondensedWidthValue())\n-        skWidth = SkFontStyle::kUltraCondensed_Width;\n-    else if (width <= extraCondensedWidthValue())\n-        skWidth = SkFontStyle::kExtraCondensed_Width;\n-    else if (width <= condensedWidthValue())\n-        skWidth = SkFontStyle::kCondensed_Width;\n-    else if (width <= semiCondensedWidthValue())\n-        skWidth = SkFontStyle::kSemiCondensed_Width;\n-    else if (width >= semiExpandedWidthValue())\n-        skWidth = SkFontStyle::kSemiExpanded_Width;\n-    else if (width >= expandedWidthValue())\n-        skWidth = SkFontStyle::kExpanded_Width;\n-    if (width >= extraExpandedWidthValue())\n-        skWidth = SkFontStyle::kExtraExpanded_Width;\n-    if (width >= ultraExpandedWidthValue())\n-        skWidth = SkFontStyle::kUltraExpanded_Width;\n-\n-    SkFontStyle::Slant skSlant = SkFontStyle::kUpright_Slant;\n-    if (auto italic = fontDescription.italic()) {\n-        if (italic.value() > normalItalicValue() && italic.value() <= italicThreshold())\n-            skSlant = SkFontStyle::kItalic_Slant;\n-        else if (italic.value() > italicThreshold())\n-            skSlant = SkFontStyle::kOblique_Slant;\n-    }\n-\n-    return SkFontStyle(skWeight, skWidth, skSlant);\n-}\n-\n-static std::pair<bool, bool> computeSynthesisProperties(const SkTypeface& typeface, const FontDescription& fontDescription, OptionSet<FontLookupOptions> synthesisOptions)\n-{\n-    bool allowsSyntheticBold = fontDescription.hasAutoFontSynthesisWeight() && !synthesisOptions.contains(FontLookupOptions::DisallowBoldSynthesis);\n-    bool syntheticBold = allowsSyntheticBold && isFontWeightBold(fontDescription.weight()) && !typeface.isBold();\n-    bool allowsSyntheticOblique = fontDescription.hasAutoFontSynthesisStyle() && !synthesisOptions.contains(FontLookupOptions::DisallowObliqueSynthesis);\n-    bool syntheticOblique = allowsSyntheticOblique && isItalic(fontDescription.italic()) && !typeface.isItalic();\n-    return { syntheticBold, syntheticOblique };\n-}\n-\n-RefPtr<Font> FontCache::systemFallbackForCharacterCluster(const FontDescription& description, const Font&, IsForPlatformFont, PreferColoredFont, StringView stringView)\n-{\n-    \/\/ FIXME: matchFamilyStyleCharacter is slow, we need a cache here, see https:\/\/bugs.webkit.org\/show_bug.cgi?id=203544.\n-    auto codePoints = stringView.codePoints();\n-    auto codePointsIterator = codePoints.begin();\n-    char32_t baseCharacter = *codePointsIterator;\n-    ++codePointsIterator;\n-    if (isDefaultIgnorableCodePoint(baseCharacter) || isPrivateUseAreaCharacter(baseCharacter))\n-        return nullptr;\n-\n-    bool isEmoji = codePointsIterator != codePoints.end() && *codePointsIterator == emojiVariationSelector;\n-\n-    \/\/ FIXME: handle locale.\n-    Vector<const char*, 1> bcp47;\n-    if (isEmoji)\n-        bcp47.append(\"und-Zsye\");\n-\n-    auto features = computeFeatures(description, { });\n-    auto typeface = fontManager().matchFamilyStyleCharacter(nullptr, skiaFontStyle(description), bcp47.data(), bcp47.size(), baseCharacter);\n-    if (!typeface)\n-        return nullptr;\n-\n-    auto [syntheticBold, syntheticOblique] = computeSynthesisProperties(*typeface, description, { });\n-    FontPlatformData alternateFontData(WTFMove(typeface), description.computedSize(), syntheticBold, syntheticOblique, description.orientation(), description.widthVariant(), description.textRenderingMode(), WTFMove(features));\n-    return fontForPlatformData(alternateFontData);\n-}\n-\n-Vector<String> FontCache::systemFontFamilies()\n-{\n-    auto& manager = fontManager();\n-    int count = manager.countFamilies();\n-    Vector<String> fontFamilies;\n-    fontFamilies.reserveInitialCapacity(count);\n-    for (int i = 0; i < count; ++i) {\n-        SkString familyName;\n-        manager.getFamilyName(i, &familyName);\n-        fontFamilies.append(String::fromUTF8(familyName.data()));\n-    }\n-    return fontFamilies;\n-}\n-\n-bool FontCache::isSystemFontForbiddenForEditing(const String&)\n-{\n-    return false;\n-}\n-\n-Ref<Font> FontCache::lastResortFallbackFont(const FontDescription& fontDescription)\n-{\n-#if PLATFORM(WIN)\n-    const auto defaultFontName = \"Times New Roman\"_s;\n-#else\n-    const auto defaultFontName = \"serif\"_s;\n-#endif\n-    if (RefPtr<Font> font = fontForFamily(fontDescription, defaultFontName))\n-        return font.releaseNonNull();\n-\n-    \/\/ Passing nullptr as family name makes Skia use a weak match.\n-    auto typeface = fontManager().matchFamilyStyle(nullptr, skiaFontStyle(fontDescription));\n-    if (!typeface) {\n-        \/\/ LastResort is guaranteed to be non-null, so fallback to empty font with not glyphs.\n-        typeface = SkTypeface::MakeEmpty();\n-    }\n-\n-    auto [syntheticBold, syntheticOblique] = computeSynthesisProperties(*typeface, fontDescription, { });\n-    FontPlatformData platformData(WTFMove(typeface), fontDescription.computedSize(), syntheticBold, syntheticOblique,\n-        fontDescription.orientation(), fontDescription.widthVariant(), fontDescription.textRenderingMode(), computeFeatures(fontDescription, { }));\n-    return fontForPlatformData(platformData);\n-}\n-\n-Vector<FontSelectionCapabilities> FontCache::getFontSelectionCapabilitiesInFamily(const AtomString&, AllowUserInstalledFonts)\n-{\n-    return { };\n-}\n-\n-static String getFamilyNameStringFromFamily(const String& family)\n-{\n-    \/\/ If we're creating a fallback font (e.g. \"-webkit-monospace\"), convert the name into\n-    \/\/ the fallback name (like \"monospace\") that fontconfig understands.\n-    if (family.length() && !family.startsWith(\"-webkit-\"_s))\n-        return family;\n-\n-    if (family == familyNamesData->at(FamilyNamesIndex::StandardFamily) || family == familyNamesData->at(FamilyNamesIndex::SerifFamily))\n-        return \"serif\"_s;\n-    if (family == familyNamesData->at(FamilyNamesIndex::SansSerifFamily))\n-        return \"sans-serif\"_s;\n-    if (family == familyNamesData->at(FamilyNamesIndex::MonospaceFamily))\n-        return \"monospace\"_s;\n-    if (family == familyNamesData->at(FamilyNamesIndex::CursiveFamily))\n-        return \"cursive\"_s;\n-    if (family == familyNamesData->at(FamilyNamesIndex::FantasyFamily))\n-        return \"fantasy\"_s;\n-\n-#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))\n-    if (family == familyNamesData->at(FamilyNamesIndex::SystemUiFamily) || family == \"-webkit-system-font\"_s)\n-        return SystemSettings::singleton().defaultSystemFont();\n-#endif\n-\n-    return emptyString();\n-}\n-\n-Vector<hb_feature_t> FontCache::computeFeatures(const FontDescription& fontDescription, const FontCreationContext& fontCreationContext)\n-{\n-    FeaturesMap featuresToBeApplied;\n-\n-    \/\/ 7.2. Feature precedence\n-    \/\/ https:\/\/www.w3.org\/TR\/css-fonts-3\/#feature-precedence\n-\n-    \/\/ 1. Font features enabled by default, including features required for a given script.\n-\n-    \/\/ FIXME: optical sizing.\n-\n-    \/\/ 2. If the font is defined via an @font-face rule, the font features implied by the\n-    \/\/    font-feature-settings descriptor in the @font-face rule.\n-    if (fontCreationContext.fontFaceFeatures()) {\n-        for (auto& fontFaceFeature : *fontCreationContext.fontFaceFeatures())\n-            featuresToBeApplied.set(fontFaceFeature.tag(), fontFaceFeature.value());\n-    }\n-\n-    \/\/ 3. Font features implied by the value of the ‘font-variant’ property, the related ‘font-variant’\n-    \/\/    subproperties and any other CSS property that uses OpenType features.\n-    for (auto& newFeature : computeFeatureSettingsFromVariants(fontDescription.variantSettings(), fontCreationContext.fontFeatureValues()))\n-        featuresToBeApplied.set(newFeature.key, newFeature.value);\n-\n-    \/\/ 4. Feature settings determined by properties other than ‘font-variant’ or ‘font-feature-settings’.\n-    bool optimizeSpeed = fontDescription.textRenderingMode() == TextRenderingMode::OptimizeSpeed;\n-    bool shouldDisableLigaturesForSpacing = fontDescription.shouldDisableLigaturesForSpacing();\n-\n-    \/\/ clig and liga are on by default in HarfBuzz.\n-    auto commonLigatures = fontDescription.variantCommonLigatures();\n-    if (shouldDisableLigaturesForSpacing || (commonLigatures == FontVariantLigatures::No || (commonLigatures == FontVariantLigatures::Normal && optimizeSpeed))) {\n-        featuresToBeApplied.set(fontFeatureTag(\"liga\"), 0);\n-        featuresToBeApplied.set(fontFeatureTag(\"clig\"), 0);\n-    }\n-\n-    \/\/ dlig is off by default in HarfBuzz.\n-    auto discretionaryLigatures = fontDescription.variantDiscretionaryLigatures();\n-    if (!shouldDisableLigaturesForSpacing && discretionaryLigatures == FontVariantLigatures::Yes)\n-        featuresToBeApplied.set(fontFeatureTag(\"dlig\"), 1);\n-\n-    \/\/ hlig is off by default in HarfBuzz.\n-    auto historicalLigatures = fontDescription.variantHistoricalLigatures();\n-    if (!shouldDisableLigaturesForSpacing && historicalLigatures == FontVariantLigatures::Yes)\n-        featuresToBeApplied.set(fontFeatureTag(\"hlig\"), 1);\n-\n-    \/\/ calt is on by default in HarfBuzz.\n-    auto contextualAlternates = fontDescription.variantContextualAlternates();\n-    if (shouldDisableLigaturesForSpacing || (contextualAlternates == FontVariantLigatures::No || (contextualAlternates == FontVariantLigatures::Normal && optimizeSpeed)))\n-        featuresToBeApplied.set(fontFeatureTag(\"calt\"), 0);\n-\n-    switch (fontDescription.widthVariant()) {\n-    case FontWidthVariant::RegularWidth:\n-        break;\n-    case FontWidthVariant::HalfWidth:\n-        featuresToBeApplied.set(fontFeatureTag(\"hwid\"), 1);\n-        break;\n-    case FontWidthVariant::ThirdWidth:\n-        featuresToBeApplied.set(fontFeatureTag(\"twid\"), 1);\n-        break;\n-    case FontWidthVariant::QuarterWidth:\n-        featuresToBeApplied.set(fontFeatureTag(\"qwid\"), 1);\n-        break;\n-    }\n-\n-    switch (fontDescription.variantEastAsianVariant()) {\n-    case FontVariantEastAsianVariant::Normal:\n-        break;\n-    case FontVariantEastAsianVariant::Jis78:\n-        featuresToBeApplied.set(fontFeatureTag(\"jp78\"), 1);\n-        break;\n-    case FontVariantEastAsianVariant::Jis83:\n-        featuresToBeApplied.set(fontFeatureTag(\"jp83\"), 1);\n-        break;\n-    case FontVariantEastAsianVariant::Jis90:\n-        featuresToBeApplied.set(fontFeatureTag(\"jp90\"), 1);\n-        break;\n-    case FontVariantEastAsianVariant::Jis04:\n-        featuresToBeApplied.set(fontFeatureTag(\"jp04\"), 1);\n-        break;\n-    case FontVariantEastAsianVariant::Simplified:\n-        featuresToBeApplied.set(fontFeatureTag(\"smpl\"), 1);\n-        break;\n-    case FontVariantEastAsianVariant::Traditional:\n-        featuresToBeApplied.set(fontFeatureTag(\"trad\"), 1);\n-        break;\n-    }\n-\n-    switch (fontDescription.variantEastAsianWidth()) {\n-    case FontVariantEastAsianWidth::Normal:\n-        break;\n-    case FontVariantEastAsianWidth::Full:\n-        featuresToBeApplied.set(fontFeatureTag(\"fwid\"), 1);\n-        break;\n-    case FontVariantEastAsianWidth::Proportional:\n-        featuresToBeApplied.set(fontFeatureTag(\"pwid\"), 1);\n-        break;\n-    }\n-\n-    switch (fontDescription.variantEastAsianRuby()) {\n-    case FontVariantEastAsianRuby::Normal:\n-        break;\n-    case FontVariantEastAsianRuby::Yes:\n-        featuresToBeApplied.set(fontFeatureTag(\"ruby\"), 1);\n-        break;\n-    }\n-\n-    switch (fontDescription.variantNumericFigure()) {\n-    case FontVariantNumericFigure::Normal:\n-        break;\n-    case FontVariantNumericFigure::LiningNumbers:\n-        featuresToBeApplied.set(fontFeatureTag(\"lnum\"), 1);\n-        break;\n-    case FontVariantNumericFigure::OldStyleNumbers:\n-        featuresToBeApplied.set(fontFeatureTag(\"onum\"), 1);\n-        break;\n-    }\n-\n-    switch (fontDescription.variantNumericSpacing()) {\n-    case FontVariantNumericSpacing::Normal:\n-        break;\n-    case FontVariantNumericSpacing::ProportionalNumbers:\n-        featuresToBeApplied.set(fontFeatureTag(\"pnum\"), 1);\n-        break;\n-    case FontVariantNumericSpacing::TabularNumbers:\n-        featuresToBeApplied.set(fontFeatureTag(\"tnum\"), 1);\n-        break;\n-    }\n-\n-    switch (fontDescription.variantNumericFraction()) {\n-    case FontVariantNumericFraction::Normal:\n-        break;\n-    case FontVariantNumericFraction::DiagonalFractions:\n-        featuresToBeApplied.set(fontFeatureTag(\"frac\"), 1);\n-        break;\n-    case FontVariantNumericFraction::StackedFractions:\n-        featuresToBeApplied.set(fontFeatureTag(\"afrc\"), 1);\n-        break;\n-    }\n-\n-    if (fontDescription.variantNumericOrdinal() == FontVariantNumericOrdinal::Yes)\n-        featuresToBeApplied.set(fontFeatureTag(\"ordn\"), 1);\n-\n-    if (fontDescription.variantNumericSlashedZero() == FontVariantNumericSlashedZero::Yes)\n-        featuresToBeApplied.set(fontFeatureTag(\"zero\"), 1);\n-\n-    \/\/ 5. Font features implied by the value of ‘font-feature-settings’ property.\n-    for (auto& newFeature : fontDescription.featureSettings())\n-        featuresToBeApplied.set(newFeature.tag(), newFeature.value());\n-\n-    if (featuresToBeApplied.isEmpty())\n-        return { };\n-\n-    Vector<hb_feature_t> features;\n-    features.reserveInitialCapacity(featuresToBeApplied.size());\n-    for (const auto& iter : featuresToBeApplied)\n-        features.append({ HB_TAG(iter.key[0], iter.key[1], iter.key[2], iter.key[3]), static_cast<uint32_t>(iter.value), 0, static_cast<unsigned>(-1) });\n-    return features;\n-}\n-\n-std::unique_ptr<FontPlatformData> FontCache::createFontPlatformData(const FontDescription& fontDescription, const AtomString& family, const FontCreationContext& fontCreationContext, OptionSet<FontLookupOptions> options)\n-{\n-    auto familyName = getFamilyNameStringFromFamily(family);\n-    auto skFontStyle = skiaFontStyle(fontDescription);\n-    auto typeface = fontManager().matchFamilyStyle(familyName.utf8().data(), skFontStyle);\n-    if (!typeface)\n-        return nullptr;\n-\n-    auto size = fontDescription.adjustedSizeForFontFace(fontCreationContext.sizeAdjust());\n-    auto features = computeFeatures(fontDescription, fontCreationContext);\n-    auto [syntheticBold, syntheticOblique] = computeSynthesisProperties(*typeface, fontDescription, options);\n-    FontPlatformData platformData(WTFMove(typeface), size, syntheticBold, syntheticOblique, fontDescription.orientation(), fontDescription.widthVariant(), fontDescription.textRenderingMode(), WTFMove(features));\n-\n-    platformData.updateSizeWithFontSizeAdjust(fontDescription.fontSizeAdjust(), fontDescription.computedSize());\n-    auto platformDataUniquePtr = makeUnique<FontPlatformData>(platformData);\n-\n-    return platformDataUniquePtr;\n-}\n-\n-ASCIILiteral FontCache::platformAlternateFamilyName(const String&)\n-{\n-    return { };\n-}\n-\n-void FontCache::platformInvalidate()\n-{\n-}\n-\n-void FontCache::platformPurgeInactiveFontData()\n-{\n-    m_harfBuzzFontCache.clear();\n-}\n-\n-} \/\/ namespace WebCore\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/FontCacheSkia.cpp","additions":0,"deletions":409,"binary":false,"changes":409,"status":"deleted"},{"patch":"@@ -1,178 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"FontCascade.h\"\n-\n-#if USE(SKIA)\n-#include \"FontCache.h\"\n-#include \"GraphicsContextSkia.h\"\n-#include \"SurrogatePairAwareTextIterator.h\"\n-#include <skia\/core\/SkTextBlob.h>\n-#include <wtf\/text\/CharacterProperties.h>\n-\n-namespace WebCore {\n-\n-WTF_ALLOW_UNSAFE_BUFFER_USAGE_BEGIN \/\/ GLib\/Win port\n-\n-void FontCascade::drawGlyphs(GraphicsContext& graphicsContext, const Font& font, std::span<const GlyphBufferGlyph> glyphs, std::span<const GlyphBufferAdvance> advances, const FloatPoint& position, FontSmoothingMode smoothingMode)\n-{\n-    if (!font.platformData().size())\n-        return;\n-\n-    const auto& fontPlatformData = font.platformData();\n-    const auto& skFont = fontPlatformData.skFont();\n-\n-    if (!font.allowsAntialiasing())\n-        smoothingMode = FontSmoothingMode::NoSmoothing;\n-\n-    SkFont::Edging edging;\n-    switch (smoothingMode) {\n-    case FontSmoothingMode::AutoSmoothing:\n-        edging = skFont.getEdging();\n-        break;\n-    case FontSmoothingMode::Antialiased:\n-        edging = SkFont::Edging::kAntiAlias;\n-        break;\n-    case FontSmoothingMode::SubpixelAntialiased:\n-        edging = SkFont::Edging::kSubpixelAntiAlias;\n-        break;\n-    case FontSmoothingMode::NoSmoothing:\n-        edging = SkFont::Edging::kAlias;\n-        break;\n-    }\n-\n-    bool isVertical = fontPlatformData.orientation() == FontOrientation::Vertical;\n-    SkTextBlobBuilder builder;\n-    const auto& buffer = [&]() {\n-        if (skFont.getEdging() == edging)\n-            return isVertical ? builder.allocRunPos(skFont, glyphs.size()) : builder.allocRunPosH(skFont, glyphs.size(), 0);\n-\n-        SkFont copiedFont = skFont;\n-        copiedFont.setEdging(edging);\n-        return isVertical ? builder.allocRunPos(copiedFont, glyphs.size()) : builder.allocRunPosH(copiedFont, glyphs.size(), 0);\n-    }();\n-\n-    FloatSize glyphPosition;\n-    for (size_t i = 0; i < glyphs.size(); ++i) {\n-        buffer.glyphs[i] = glyphs[i];\n-\n-        if (isVertical) {\n-            glyphPosition += advances[i];\n-            buffer.pos[2 * i] = glyphPosition.height();\n-            buffer.pos[2 * i + 1] = glyphPosition.width();\n-        } else {\n-            buffer.pos[i] = glyphPosition.width();\n-            glyphPosition += advances[i];\n-        }\n-    }\n-\n-    auto blob = builder.make();\n-    static_cast<GraphicsContextSkia*>(&graphicsContext)->drawSkiaText(blob, SkFloatToScalar(position.x()), SkFloatToScalar(position.y()), edging != SkFont::Edging::kAlias, isVertical);\n-}\n-\n-WTF_ALLOW_UNSAFE_BUFFER_USAGE_END\n-\n-bool FontCascade::canReturnFallbackFontsForComplexText()\n-{\n-    return false;\n-}\n-\n-bool FontCascade::canExpandAroundIdeographsInComplexText()\n-{\n-    return false;\n-}\n-\n-bool FontCascade::canUseGlyphDisplayList(const RenderStyle&)\n-{\n-    return true;\n-}\n-\n-ResolvedEmojiPolicy FontCascade::resolveEmojiPolicy(FontVariantEmoji fontVariantEmoji, char32_t character)\n-{\n-    switch (fontVariantEmoji) {\n-    case FontVariantEmoji::Normal:\n-    case FontVariantEmoji::Unicode:\n-        if (isEmojiWithPresentationByDefault(character)\n-            || isEmojiModifierBase(character)\n-            || isEmojiFitzpatrickModifier(character))\n-            return ResolvedEmojiPolicy::RequireEmoji;\n-        break;\n-    case FontVariantEmoji::Text:\n-        return ResolvedEmojiPolicy::RequireText;\n-    case FontVariantEmoji::Emoji:\n-        return ResolvedEmojiPolicy::RequireEmoji;\n-    }\n-\n-    return ResolvedEmojiPolicy::NoPreference;\n-}\n-\n-RefPtr<const Font> FontCascade::fontForCombiningCharacterSequence(StringView stringView) const\n-{\n-    ASSERT(!stringView.isEmpty());\n-    auto codePoints = stringView.codePoints();\n-    auto codePointsIterator = codePoints.begin();\n-    char32_t baseCharacter = *codePointsIterator;\n-    ++codePointsIterator;\n-    bool isOnlySingleCodePoint = codePointsIterator == codePoints.end();\n-\n-    char32_t baseCharacterForBaseFont = baseCharacter;\n-    if (!isOnlySingleCodePoint && *codePointsIterator == emojiVariationSelector) {\n-        \/\/ System fallback doesn't support character sequences, so here we override\n-        \/\/ the base character with the cat emoji to try to force an emoji font.\n-        baseCharacterForBaseFont = emojiCat;\n-    }\n-    GlyphData baseCharacterGlyphData = glyphDataForCharacter(baseCharacterForBaseFont, false, NormalVariant);\n-    if (!baseCharacterGlyphData.glyph)\n-        return nullptr;\n-\n-    if (isOnlySingleCodePoint)\n-        return baseCharacterGlyphData.font.get();\n-\n-    bool triedBaseCharacterFont = false;\n-    for (unsigned i = 0; !fallbackRangesAt(i).isNull(); ++i) {\n-        auto& fontRanges = fallbackRangesAt(i);\n-        if (fontRanges.isGenericFontFamily() && isPrivateUseAreaCharacter(baseCharacter))\n-            continue;\n-\n-        const Font* font = fontRanges.fontForCharacter(baseCharacter);\n-        if (!font)\n-            continue;\n-\n-        if (font == baseCharacterGlyphData.font)\n-            triedBaseCharacterFont = true;\n-\n-        if (font->canRenderCombiningCharacterSequence(stringView))\n-            return font;\n-    }\n-\n-    if (!triedBaseCharacterFont && baseCharacterGlyphData.font && baseCharacterGlyphData.font->canRenderCombiningCharacterSequence(stringView))\n-        return baseCharacterGlyphData.font.get();\n-    return nullptr;\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/FontCascadeSkia.cpp","additions":0,"deletions":178,"binary":false,"changes":178,"status":"deleted"},{"patch":"@@ -1,157 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"FontCustomPlatformData.h\"\n-\n-#include \"FontCache.h\"\n-#include \"FontCreationContext.h\"\n-#include \"FontDescription.h\"\n-#include \"FontVariationsSkia.h\"\n-#include \"NotImplemented.h\"\n-#include <skia\/core\/SkData.h>\n-\n-namespace WebCore {\n-\n-FontCustomPlatformData::FontCustomPlatformData(sk_sp<SkTypeface>&& typeface, FontPlatformData::CreationData&& data)\n-    : m_typeface(WTFMove(typeface))\n-    , creationData(WTFMove(data))\n-    , m_renderingResourceIdentifier(RenderingResourceIdentifier::generate())\n-{\n-}\n-\n-FontCustomPlatformData::~FontCustomPlatformData() = default;\n-\n-FontPlatformData FontCustomPlatformData::fontPlatformData(const FontDescription& description, bool bold, bool italic, const FontCreationContext& fontCreationContext)\n-{\n-    sk_sp<SkTypeface> typeface = m_typeface;\n-\n-    auto defaultValues = defaultFontVariationValues(*typeface);\n-    if (!defaultValues.isEmpty()) {\n-        Vector<SkFontArguments::VariationPosition::Coordinate> variationsToBeApplied;\n-        auto applyVariation = [&](const FontTag& tag, float value) {\n-            auto iterator = defaultValues.find(tag);\n-            if (iterator == defaultValues.end())\n-                return;\n-\n-            variationsToBeApplied.append({ SkSetFourByteTag(tag[0], tag[1], tag[2], tag[3]), iterator->value.clamp(value) });\n-        };\n-\n-        float weight = description.weight();\n-        if (auto weightValue = fontCreationContext.fontFaceCapabilities().weight)\n-            weight = std::max(std::min(weight, static_cast<float>(weightValue->maximum)), static_cast<float>(weightValue->minimum));\n-        applyVariation({ { 'w', 'g', 'h', 't' } }, weight);\n-\n-        float width = description.width();\n-        if (auto widthValue = fontCreationContext.fontFaceCapabilities().width)\n-            width = std::max(std::min(width, static_cast<float>(widthValue->maximum)), static_cast<float>(widthValue->minimum));\n-        applyVariation({ { 'w', 'd', 't', 'h' } }, width);\n-\n-        if (description.fontStyleAxis() == FontStyleAxis::ital)\n-            applyVariation({ { 'i', 't', 'a', 'l' } }, 1);\n-        else {\n-            float slope = description.italic().value_or(normalItalicValue());\n-            if (auto slopeValue = fontCreationContext.fontFaceCapabilities().weight)\n-                slope = std::max(std::min(slope, static_cast<float>(slopeValue->maximum)), static_cast<float>(slopeValue->minimum));\n-            applyVariation({ { 's', 'l', 'n', 't' } }, slope);\n-        }\n-\n-        \/\/ FIXME: optical sizing.\n-\n-        const auto& variations = description.variationSettings();\n-        for (auto& variation : variations)\n-            applyVariation(variation.tag(), variation.value());\n-\n-        if (!variationsToBeApplied.isEmpty()) {\n-            SkFontArguments fontArgs;\n-            fontArgs.setVariationDesignPosition({ variationsToBeApplied.data(), static_cast<int>(variationsToBeApplied.size()) });\n-            if (auto variationTypeface = typeface->makeClone(fontArgs))\n-                typeface = WTFMove(variationTypeface);\n-        }\n-    }\n-\n-    auto size = description.adjustedSizeForFontFace(fontCreationContext.sizeAdjust());\n-    auto features = FontCache::computeFeatures(description, fontCreationContext);\n-    FontPlatformData platformData(WTFMove(typeface), size, bold, italic, description.orientation(), description.widthVariant(), description.textRenderingMode(), WTFMove(features), this);\n-    platformData.updateSizeWithFontSizeAdjust(description.fontSizeAdjust(), description.computedSize());\n-    return platformData;\n-}\n-\n-RefPtr<FontCustomPlatformData> FontCustomPlatformData::create(SharedBuffer& buffer, const String& itemInCollection)\n-{\n-    sk_sp<SkTypeface> typeface = FontCache::forCurrentThread().fontManager().makeFromData(buffer.createSkData());\n-    if (!typeface)\n-        return nullptr;\n-\n-    FontPlatformData::CreationData creationData = { buffer, itemInCollection };\n-    return adoptRef(new FontCustomPlatformData(WTFMove(typeface), WTFMove(creationData)));\n-}\n-\n-RefPtr<FontCustomPlatformData> FontCustomPlatformData::createMemorySafe(SharedBuffer&, const String&)\n-{\n-    return nullptr;\n-}\n-\n-bool FontCustomPlatformData::supportsFormat(const String& format)\n-{\n-    return equalLettersIgnoringASCIICase(format, \"truetype\"_s)\n-        || equalLettersIgnoringASCIICase(format, \"opentype\"_s)\n-#if HAVE(WOFF_SUPPORT) || USE(WOFF2)\n-        || equalLettersIgnoringASCIICase(format, \"woff2\"_s)\n-#if ENABLE(VARIATION_FONTS)\n-        || equalLettersIgnoringASCIICase(format, \"woff2-variations\"_s)\n-#endif\n-#endif\n-#if ENABLE(VARIATION_FONTS)\n-        || equalLettersIgnoringASCIICase(format, \"woff-variations\"_s)\n-        || equalLettersIgnoringASCIICase(format, \"truetype-variations\"_s)\n-        || equalLettersIgnoringASCIICase(format, \"opentype-variations\"_s)\n-#endif\n-        || equalLettersIgnoringASCIICase(format, \"woff\"_s)\n-        || equalLettersIgnoringASCIICase(format, \"svg\"_s);\n-}\n-\n-bool FontCustomPlatformData::supportsTechnology(const FontTechnology&)\n-{\n-    \/\/ FIXME: define supported technologies for this platform (webkit.org\/b\/256310).\n-    notImplemented();\n-    return true;\n-}\n-\n-std::optional<Ref<FontCustomPlatformData>> FontCustomPlatformData::tryMakeFromSerializationData(FontCustomPlatformSerializedData&& data, bool)\n-{\n-    RefPtr fontCustomPlatformData = FontCustomPlatformData::create(WTFMove(data.fontFaceData), data.itemInCollection);\n-    if (!fontCustomPlatformData)\n-        return std::nullopt;\n-    fontCustomPlatformData->m_renderingResourceIdentifier = data.renderingResourceIdentifier;\n-    return fontCustomPlatformData.releaseNonNull();\n-}\n-\n-FontCustomPlatformSerializedData FontCustomPlatformData::serializedData() const\n-{\n-    return FontCustomPlatformSerializedData { creationData.fontFaceData, creationData.itemInCollection, m_renderingResourceIdentifier };\n-}\n-\n-}\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/FontCustomPlatformDataSkia.cpp","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -1,221 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"FontPlatformData.h\"\n-\n-#include \"FontCache.h\"\n-#include \"FontCustomPlatformData.h\"\n-#include \"FontRenderOptions.h\"\n-#include \"FontVariationsSkia.h\"\n-#include \"NotImplemented.h\"\n-#include \"OpenTypeTypes.h\"\n-#include \"SkiaHarfBuzzFont.h\"\n-#include <skia\/core\/SkStream.h>\n-#include <skia\/core\/SkTypeface.h>\n-#include <wtf\/Hasher.h>\n-#include <wtf\/VectorHash.h>\n-\n-namespace WebCore {\n-\n-FontPlatformData::FontPlatformData(sk_sp<SkTypeface>&& typeface, float size, bool syntheticBold, bool syntheticOblique, FontOrientation orientation, FontWidthVariant widthVariant, TextRenderingMode textRenderingMode, Vector<hb_feature_t>&& features, const FontCustomPlatformData* customPlatformData)\n-    : FontPlatformData(size, syntheticBold, syntheticOblique, orientation, widthVariant, textRenderingMode, customPlatformData)\n-{\n-    m_font = SkFont(typeface, m_size);\n-    m_features = WTFMove(features);\n-\n-    platformDataInit();\n-}\n-\n-FontPlatformData::FontPlatformData(float size, FontOrientation&& orientation, FontWidthVariant&& widthVariant, TextRenderingMode&& textRenderingMode, bool syntheticBold, bool syntheticOblique, RefPtr<FontCustomPlatformData>&& customPlatformData)\n-    : FontPlatformData(size, syntheticBold, syntheticOblique, orientation, widthVariant, textRenderingMode, customPlatformData.get())\n-{\n-    m_font = SkFont(customPlatformData->m_typeface, m_size);\n-\n-    platformDataInit();\n-}\n-\n-void FontPlatformData::platformDataInit()\n-{\n-    m_font.setEmbolden(m_syntheticBold);\n-    m_font.setSkewX(m_syntheticOblique ? -SK_Scalar1 \/ 4 : 0);\n-\n-    bool useSubpixelPositioning = FontRenderOptions::singleton().useSubpixelPositioning();\n-\n-    m_font.setEdging(FontRenderOptions::singleton().antialias());\n-    if (m_font.getEdging() == SkFont::Edging::kAlias) {\n-        \/\/ Force full hinting when antialiasing is disabled like Cairo does.\n-        m_font.setHinting(SkFontHinting::kFull);\n-    } else if (useSubpixelPositioning) {\n-        \/\/ Disable hinting when subpixel positioning is enabled.\n-        m_font.setHinting(SkFontHinting::kNone);\n-    } else\n-        m_font.setHinting(FontRenderOptions::singleton().hinting());\n-\n-    \/\/ Force subpixel positioning when not running tests and full hinting was not requested.\n-    bool forceSubpixel = !FontRenderOptions::singleton().isHintingDisabledForTesting() && m_font.getHinting() != SkFontHinting::kFull;\n-    m_font.setSubpixel(forceSubpixel || useSubpixelPositioning);\n-\n-    m_font.setLinearMetrics(m_font.getHinting() == SkFontHinting::kNone && m_font.isSubpixel());\n-\n-    m_hbFont = SkiaHarfBuzzFont::getOrCreate(*m_font.getTypeface());\n-}\n-\n-std::optional<FontPlatformData> FontPlatformData::fromIPCData(float size, FontOrientation&& orientation, FontWidthVariant&& widthVariant, TextRenderingMode&& textRenderingMode, bool syntheticBold, bool syntheticOblique, IPCData&& ipcData)\n-{\n-    return WTF::switchOn(ipcData,\n-        [&] (const FontPlatformSerializedData& d) -> std::optional<FontPlatformData> {\n-            if (sk_sp<SkTypeface> typeface = SkTypeface::MakeDeserialize(SkMemoryStream::Make(d.typefaceData).get(), nullptr))\n-                return FontPlatformData(WTFMove(typeface), size, syntheticBold, syntheticOblique, WTFMove(orientation), WTFMove(widthVariant), WTFMove(textRenderingMode), { });\n-\n-            return std::nullopt;\n-        },\n-        [&] (FontPlatformSerializedCreationData& d) -> std::optional<FontPlatformData> {\n-            auto fontFaceData = SharedBuffer::create(WTFMove(d.fontFaceData));\n-            if (RefPtr fontCustomPlatformData = FontCustomPlatformData::create(fontFaceData, d.itemInCollection))\n-                return FontPlatformData(size, WTFMove(orientation), WTFMove(widthVariant), WTFMove(textRenderingMode), syntheticBold, syntheticOblique, WTFMove(fontCustomPlatformData));\n-\n-            return std::nullopt;\n-        }\n-    );\n-}\n-\n-FontPlatformData::IPCData FontPlatformData::toIPCData() const\n-{\n-    if (auto* data = creationData())\n-        return FontPlatformSerializedCreationData { { data->fontFaceData->span() }, data->itemInCollection };\n-\n-    return FontPlatformSerializedData { m_font.getTypeface()->serialize() };\n-}\n-\n-bool FontPlatformData::isFixedPitch() const\n-{\n-    return m_font.getTypeface()->isFixedPitch();\n-}\n-\n-unsigned FontPlatformData::hash() const\n-{\n-    \/\/ FIXME: do we need to consider m_features for the hash?\n-    return computeHash(m_font.getTypeface()->uniqueID(), m_widthVariant, m_isHashTableDeletedValue, m_textRenderingMode, m_orientation, m_syntheticBold, m_syntheticOblique);\n-}\n-\n-bool FontPlatformData::platformIsEqual(const FontPlatformData& other) const\n-{\n-\n-    return SkTypeface::Equal(m_font.getTypeface(), other.skFont().getTypeface()) && m_features == other.m_features;\n-}\n-\n-#if !LOG_DISABLED\n-String FontPlatformData::description() const\n-{\n-    return String();\n-}\n-#endif\n-\n-String FontPlatformData::familyName() const\n-{\n-    if (auto* typeface = m_font.getTypeface()) {\n-        SkString familyName;\n-        typeface->getFamilyName(&familyName);\n-        return String::fromUTF8(familyName.data());\n-    }\n-    return { };\n-}\n-\n-static_assert(std::is_same<SkFontTableTag, OpenType::Tag>::value);\n-\n-RefPtr<SharedBuffer> FontPlatformData::openTypeTable(uint32_t table) const\n-{\n-    auto* typeface = m_font.getTypeface();\n-    if (!typeface)\n-        return nullptr;\n-\n-    OpenType::Tag tag = OT_MAKE_TAG(table >> 24, (table & 0xff0000) >> 16, (table & 0xff00) >> 8, (table & 0xff));\n-    size_t tableSize = typeface->getTableSize(tag);\n-    if (!tableSize)\n-        return nullptr;\n-\n-    Vector<uint8_t> data(tableSize);\n-    if (typeface->getTableData(tag, 0, tableSize, data.data()) != tableSize)\n-        return nullptr;\n-\n-    return SharedBuffer::create(WTFMove(data));\n-}\n-\n-FontPlatformData FontPlatformData::create(const Attributes& data, const FontCustomPlatformData* custom)\n-{\n-    Vector<hb_feature_t> features = data.m_features;\n-    if (custom) {\n-        sk_sp<SkTypeface> typeface = custom->m_typeface;\n-        return { WTFMove(typeface), data.m_size, data.m_syntheticBold, data.m_syntheticOblique, data.m_orientation, data.m_widthVariant, data.m_textRenderingMode, WTFMove(features), custom };\n-    }\n-    sk_sp<SkTypeface> typeface = FontCache::forCurrentThread().fontManager().matchFamilyStyle(data.m_familyName.c_str(), data.m_style);\n-    return { WTFMove(typeface), data.m_size, data.m_syntheticBold, data.m_syntheticOblique, data.m_orientation, data.m_widthVariant, data.m_textRenderingMode, WTFMove(features) };\n-}\n-\n-FontPlatformData::Attributes FontPlatformData::attributes() const\n-{\n-    SkString familyName;\n-    skFont().getTypeface()->getFamilyName(&familyName);\n-    SkFontStyle style = skFont().getTypeface()->fontStyle();\n-    Vector<hb_feature_t> features = m_features;\n-    return { m_size, m_orientation, m_widthVariant, m_textRenderingMode, m_syntheticBold, m_syntheticOblique, familyName, style, WTFMove(features) };\n-}\n-\n-hb_font_t* FontPlatformData::hbFont() const\n-{\n-    return m_hbFont->scaledFont(*this);\n-}\n-\n-#if ENABLE(MATHML)\n-HbUniquePtr<hb_font_t> FontPlatformData::createOpenTypeMathHarfBuzzFont() const\n-{\n-    auto* face = hb_font_get_face(hbFont());\n-    if (!hb_ot_math_has_data(face))\n-        return nullptr;\n-\n-    return HbUniquePtr<hb_font_t>(hb_font_create(face));\n-}\n-#endif\n-\n-void FontPlatformData::updateSize(float size)\n-{\n-    m_size = size;\n-    m_font.setSize(m_size);\n-}\n-\n-Vector<FontPlatformData::FontVariationAxis> FontPlatformData::variationAxes(ShouldLocalizeAxisNames) const\n-{\n-    auto* typeface = m_font.getTypeface();\n-    if (!typeface)\n-        return { };\n-\n-    return WTF::map(defaultFontVariationValues(*typeface), [](auto&& entry) {\n-        auto& [tag, values] = entry;\n-        return FontPlatformData::FontVariationAxis { values.axisName, String(tag), values.defaultValue, values.minimumValue, values.maximumValue };\n-    });\n-}\n-\n-} \/\/ namespace WebCore\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/FontPlatformDataSkia.cpp","additions":0,"deletions":221,"binary":false,"changes":221,"status":"deleted"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"FontRenderOptions.h\"\n-\n-#if USE(SKIA)\n-\n-namespace WebCore {\n-\n-FontRenderOptions::FontRenderOptions() = default;\n-\n-void FontRenderOptions::setHinting(std::optional<Hinting> hinting)\n-{\n-    switch (hinting.value_or(Hinting::Medium)) {\n-    case Hinting::None:\n-        m_hinting = SkFontHinting::kNone;\n-        break;\n-    case Hinting::Slight:\n-        m_hinting = SkFontHinting::kSlight;\n-        break;\n-    case Hinting::Medium:\n-        m_hinting = SkFontHinting::kNormal;\n-        break;\n-    case Hinting::Full:\n-        m_hinting = SkFontHinting::kFull;\n-        break;\n-    }\n-}\n-\n-SkFontHinting FontRenderOptions::hinting() const\n-{\n-    if (m_isHintingDisabledForTesting)\n-        return SkFontHinting::kNone;\n-\n-    if (m_followSystemSettings)\n-        return m_hinting;\n-\n-    return SkFontHinting::kSlight;\n-}\n-\n-void FontRenderOptions::setAntialias(std::optional<Antialias> antialias)\n-{\n-    switch (antialias.value_or(Antialias::Normal)) {\n-    case Antialias::None:\n-        m_antialias = SkFont::Edging::kAlias;\n-        break;\n-    case Antialias::Normal:\n-        m_antialias = SkFont::Edging::kAntiAlias;\n-        break;\n-    case Antialias::Subpixel:\n-        m_antialias = SkFont::Edging::kSubpixelAntiAlias;\n-        break;\n-    }\n-}\n-\n-SkFont::Edging FontRenderOptions::antialias() const\n-{\n-    if (m_followSystemSettings)\n-        return m_antialias;\n-\n-    return SkFont::Edging::kAntiAlias;\n-}\n-\n-void FontRenderOptions::setSubpixelOrder(std::optional<SubpixelOrder> subpixelOrder)\n-{\n-    switch (subpixelOrder.value_or(SubpixelOrder::Unknown)) {\n-    case SubpixelOrder::Unknown:\n-        m_subpixelOrder = kUnknown_SkPixelGeometry;\n-        break;\n-    case SubpixelOrder::HorizontalRGB:\n-        m_subpixelOrder = kRGB_H_SkPixelGeometry;\n-        break;\n-    case SubpixelOrder::HorizontalBGR:\n-        m_subpixelOrder = kBGR_H_SkPixelGeometry;\n-        break;\n-    case SubpixelOrder::VerticalRGB:\n-        m_subpixelOrder = kRGB_V_SkPixelGeometry;\n-        break;\n-    case SubpixelOrder::VerticalBGR:\n-        m_subpixelOrder = kBGR_V_SkPixelGeometry;\n-        break;\n-    }\n-}\n-\n-SkPixelGeometry FontRenderOptions::subpixelOrder() const\n-{\n-    if (m_followSystemSettings)\n-        return m_subpixelOrder;\n-\n-    return kUnknown_SkPixelGeometry;\n-}\n-\n-bool FontRenderOptions::useSubpixelPositioning() const\n-{\n-    \/\/ Subpixel positioning is not a system setting, it's set when device scale factor is >= 2.\n-    \/\/ So, we only apply it when not following system settings to force subpixel position with\n-    \/\/ linear metrics and no hinting.\n-    if (!m_followSystemSettings)\n-        return m_useSubpixelPositioning;\n-\n-    return false;\n-}\n-\n-void FontRenderOptions::disableHintingForTesting()\n-{\n-    m_isHintingDisabledForTesting = true;\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/FontRenderOptionsSkia.cpp","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -1,169 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"Font.h\"\n-\n-#include \"GlyphBuffer.h\"\n-#include \"NotImplemented.h\"\n-#include \"PathSkia.h\"\n-#include <skia\/core\/SkFont.h>\n-#include <skia\/core\/SkFontMetrics.h>\n-\n-namespace WebCore {\n-\n-Path Font::platformPathForGlyph(Glyph glyph) const\n-{\n-    auto path = PathSkia::create();\n-    const auto& font = m_platformData.skFont();\n-    font.getPath(glyph, path->platformPath());\n-    return { path };\n-}\n-\n-FloatRect Font::platformBoundsForGlyph(Glyph glyph) const\n-{\n-    if (!m_platformData.size())\n-        return { };\n-\n-    const auto& font = m_platformData.skFont();\n-    SkRect bounds;\n-    font.getBounds(&glyph, 1, &bounds, nullptr);\n-    if (!font.isSubpixel()) {\n-        SkIRect rect;\n-        bounds.roundOut(&rect);\n-        bounds.set(rect);\n-    }\n-    return bounds;\n-}\n-\n-float Font::platformWidthForGlyph(Glyph glyph) const\n-{\n-    if (!m_platformData.size())\n-        return 0;\n-\n-    const auto& font = m_platformData.skFont();\n-    SkScalar width;\n-    font.getWidths(&glyph, 1, &width);\n-\n-    if (!font.isSubpixel())\n-        width = SkScalarRoundToInt(width);\n-\n-    return SkScalarToFloat(width);\n-}\n-\n-void Font::platformInit()\n-{\n-    if (!m_platformData.size())\n-        return;\n-\n-    const auto& font = m_platformData.skFont();\n-    SkFontMetrics metrics;\n-    font.getMetrics(&metrics);\n-\n-    auto ascent = SkScalarRoundToScalar(-metrics.fAscent);\n-    auto descent = SkScalarRoundToScalar(metrics.fDescent);\n-    m_fontMetrics.setAscent(ascent);\n-    m_fontMetrics.setDescent(descent);\n-\n-    auto lineGap = SkScalarToFloat(metrics.fLeading);\n-    m_fontMetrics.setLineGap(lineGap);\n-    m_fontMetrics.setLineSpacing(lroundf(ascent) + lroundf(descent) + lroundf(lineGap));\n-\n-    m_fontMetrics.setCapHeight(metrics.fCapHeight);\n-\n-    float underlinePosition;\n-    if (metrics.hasUnderlinePosition(&underlinePosition))\n-        m_fontMetrics.setUnderlinePosition(underlinePosition);\n-    float underlineThickness;\n-    if (metrics.hasUnderlineThickness(&underlineThickness))\n-        m_fontMetrics.setUnderlineThickness(underlineThickness);\n-\n-    if (metrics.fXHeight)\n-        m_fontMetrics.setXHeight(metrics.fXHeight);\n-\n-    m_maxCharWidth = SkScalarRoundToInt(metrics.fXMax - metrics.fXMin);\n-    if (metrics.fAvgCharWidth)\n-        m_avgCharWidth = SkScalarToFloat(metrics.fAvgCharWidth);\n-\n-    m_fontMetrics.setUnitsPerEm(font.getTypeface()->getUnitsPerEm());\n-\n-    SkString familyName;\n-    font.getTypeface()->getFamilyName(&familyName);\n-    if (equalIgnoringASCIICase(familyName.c_str(), \"Ahem\"_s))\n-        m_allowsAntialiasing = false;\n-}\n-\n-void Font::platformCharWidthInit()\n-{\n-    m_avgCharWidth = 0.f;\n-    m_maxCharWidth = 0.f;\n-    initCharWidths();\n-}\n-\n-RefPtr<Font> Font::platformCreateScaledFont(const FontDescription&, float scaleFactor) const\n-{\n-    return Font::create(FontPlatformData(m_platformData.skFont().refTypeface(), scaleFactor * m_platformData.size(),\n-        m_platformData.syntheticBold(),\n-        m_platformData.syntheticOblique(),\n-        m_platformData.orientation(),\n-        m_platformData.widthVariant(),\n-        m_platformData.textRenderingMode(),\n-        Vector<hb_feature_t> { m_platformData.features() },\n-        m_platformData.customPlatformData()),\n-        origin(), IsInterstitial::No);\n-}\n-\n-RefPtr<Font> Font::platformCreateHalfWidthFont() const\n-{\n-    \/\/ FIXME: https:\/\/bugs.webkit.org\/show_bug.cgi?id=281333 : implement half width font for this platform.\n-    notImplemented();\n-    return nullptr;\n-}\n-\n-void Font::determinePitch()\n-{\n-    m_treatAsFixedPitch = m_platformData.isFixedPitch();\n-}\n-\n-bool Font::variantCapsSupportedForSynthesis(FontVariantCaps fontVariantCaps) const\n-{\n-    switch (fontVariantCaps) {\n-    case FontVariantCaps::Small:\n-    case FontVariantCaps::Petite:\n-    case FontVariantCaps::AllSmall:\n-    case FontVariantCaps::AllPetite:\n-        return false;\n-    default:\n-        \/\/ Synthesis only supports the variant-caps values listed above.\n-        return true;\n-    }\n-}\n-\n-bool Font::platformSupportsCodePoint(char32_t character, std::optional<char32_t>) const\n-{\n-    return m_platformData.skFont().getTypeface()->unicharToGlyph(character);\n-}\n-\n-} \/\/ namespace WebCore\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/FontSkia.cpp","additions":0,"deletions":169,"binary":false,"changes":169,"status":"deleted"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"Gradient.h\"\n-\n-#if USE(SKIA)\n-\n-#include \"AffineTransform.h\"\n-#include \"GradientColorStops.h\"\n-#include \"GraphicsContextSkia.h\"\n-#include \"NotImplemented.h\"\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkColor.h>\n-#include <skia\/core\/SkScalar.h>\n-#include <skia\/effects\/SkGradientShader.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-\n-namespace WebCore {\n-\n-void Gradient::stopsChanged()\n-{\n-    m_shader = { };\n-}\n-\n-inline SkScalar webCoreDoubleToSkScalar(double d)\n-{\n-    return SkDoubleToScalar(std::isfinite(d) ? d : 0);\n-}\n-\n-static SkGradientShader::Interpolation toSkiaInterpolation(const ColorInterpolationMethod& method)\n-{\n-    SkGradientShader::Interpolation interpolation;\n-\n-    WTF::switchOn(method.colorSpace,\n-        [&] (const ColorInterpolationMethod::HSL&) {\n-            interpolation.fColorSpace = SkGradientShader::Interpolation::ColorSpace::kHSL;\n-        },\n-        [&] (const ColorInterpolationMethod::HWB&) {\n-            interpolation.fColorSpace = SkGradientShader::Interpolation::ColorSpace::kHWB;\n-        },\n-        [&] (const ColorInterpolationMethod::LCH&) {\n-            interpolation.fColorSpace = SkGradientShader::Interpolation::ColorSpace::kLCH;\n-        },\n-        [&] (const ColorInterpolationMethod::Lab&) {\n-            interpolation.fColorSpace = SkGradientShader::Interpolation::ColorSpace::kLab;\n-        },\n-        [&] (const ColorInterpolationMethod::OKLCH&) {\n-            interpolation.fColorSpace = SkGradientShader::Interpolation::ColorSpace::kOKLCH;\n-        },\n-        [&] (const ColorInterpolationMethod::OKLab&) {\n-            interpolation.fColorSpace = SkGradientShader::Interpolation::ColorSpace::kOKLab;\n-        },\n-        [&] (const ColorInterpolationMethod::SRGB&) {\n-            interpolation.fColorSpace = SkGradientShader::Interpolation::ColorSpace::kSRGB;\n-        },\n-        [&] (const ColorInterpolationMethod::SRGBLinear&) {\n-            interpolation.fColorSpace = SkGradientShader::Interpolation::ColorSpace::kSRGBLinear;\n-        },\n-        [&] (const ColorInterpolationMethod::XYZD50&) {\n-            interpolation.fColorSpace = SkGradientShader::Interpolation::ColorSpace::kSRGBLinear;\n-        },\n-        [&] (const ColorInterpolationMethod::XYZD65&) {\n-            interpolation.fColorSpace = SkGradientShader::Interpolation::ColorSpace::kSRGBLinear;\n-        },\n-        [&] (const auto&) {\n-            \/\/ FIXME: Support other color spaces once skia has support for them.\n-        });\n-\n-    switch (method.alphaPremultiplication) {\n-    case AlphaPremultiplication::Premultiplied:\n-        interpolation.fInPremul = SkGradientShader::Interpolation::InPremul::kYes;\n-        break;\n-    case AlphaPremultiplication::Unpremultiplied:\n-        interpolation.fInPremul = SkGradientShader::Interpolation::InPremul::kNo;\n-        break;\n-    }\n-\n-    return interpolation;\n-}\n-\n-sk_sp<SkShader> Gradient::shader(float globalAlpha, const AffineTransform& gradientSpaceTransform)\n-{\n-    if (m_shader)\n-        return m_shader;\n-\n-    Vector<SkColor4f, 8> colors;\n-    colors.reserveInitialCapacity(stops().size());\n-    Vector<SkScalar, 8> positions;\n-    positions.reserveInitialCapacity(stops().size());\n-    auto fillStops = [&](const GradientColorStops::StopVector& stops) {\n-        if (stops.isEmpty()) {\n-            positions.append(webCoreDoubleToSkScalar(0));\n-            colors.append(SkColors::kTransparent);\n-        } else if (stops.begin()->offset > 0) {\n-            positions.append(webCoreDoubleToSkScalar(0));\n-            colors.append(stops.begin()->color.colorWithAlphaMultipliedBy(globalAlpha));\n-        }\n-\n-        for (size_t i = 0; i < stops.size(); i++) {\n-            positions.append(webCoreDoubleToSkScalar(stops[i].offset));\n-            colors.append(stops[i].color.colorWithAlphaMultipliedBy(globalAlpha));\n-        }\n-\n-        if (positions.last() < 1) {\n-            positions.append(webCoreDoubleToSkScalar(1));\n-            colors.append(colors.last());\n-        }\n-    };\n-    fillStops(stops().sorted().stops());\n-\n-    SkTileMode tileMode = SkTileMode::kClamp;\n-    switch (m_spreadMethod) {\n-    case GradientSpreadMethod::Pad:\n-        tileMode = SkTileMode::kClamp;\n-        break;\n-    case GradientSpreadMethod::Reflect:\n-        tileMode = SkTileMode::kMirror;\n-        break;\n-    case GradientSpreadMethod::Repeat:\n-        tileMode = SkTileMode::kRepeat;\n-        break;\n-    }\n-\n-    auto interpolation = toSkiaInterpolation(colorInterpolationMethod());\n-    SkMatrix matrix = gradientSpaceTransform;\n-\n-    m_shader = WTF::switchOn(\n-        m_data,\n-        [&](const LinearData& data) {\n-            SkPoint points[] = { SkPoint::Make(data.point0.x(), data.point0.y()), SkPoint::Make(data.point1.x(), data.point1.y()) };\n-\n-            return SkGradientShader::MakeLinear(points, colors.data(), nullptr, positions.data(), colors.size(), tileMode, interpolation, &matrix);\n-        },\n-        [&](const RadialData& data) {\n-            if (data.aspectRatio != 1)\n-                matrix.preScale(1, 1 \/ data.aspectRatio, data.point0.x(), data.point0.y());\n-\n-            SkPoint start = SkPoint::Make(data.point0.x(), data.point0.y());\n-            SkPoint end = SkPoint::Make(data.point1.x(), data.point1.y());\n-            SkScalar startRadius = std::max(webCoreDoubleToSkScalar(data.startRadius), 0.0f);\n-            SkScalar endRadius = std::max(webCoreDoubleToSkScalar(data.endRadius), 0.0f);\n-\n-            return SkGradientShader::MakeTwoPointConical(start, startRadius, end, endRadius, colors.data(), nullptr, positions.data(), colors.size(), tileMode, interpolation, &matrix);\n-        },\n-        [&](const ConicData& data) {\n-            \/\/ Skia's renders it tilted by 90 degrees, so offset that rotation in the matrix\n-            matrix.preRotate(SkRadiansToDegrees(data.angleRadians) - 90.0f, data.point0.x(), data.point0.y());\n-\n-            return SkGradientShader::MakeSweep(data.point0.x(), data.point0.y(), colors.data(), nullptr, positions.data(), colors.size(), tileMode, 0, 360, interpolation, &matrix);\n-        });\n-\n-    return m_shader;\n-}\n-\n-void Gradient::fill(GraphicsContext& context, const FloatRect& rect)\n-{\n-    auto paint = static_cast<GraphicsContextSkia*>(&context)->createFillPaint();\n-    paint.setShader(shader(context.alpha(), context.fillGradientSpaceTransform()));\n-    context.platformContext()->drawRect(rect, paint);\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/GradientSkia.cpp","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"GraphicsContextGL.h\"\n-\n-#if ENABLE(WEBGL) && USE(SKIA)\n-#include \"BitmapImage.h\"\n-#include \"GLContext.h\"\n-#include \"GraphicsContextGLImageExtractor.h\"\n-#include \"NotImplemented.h\"\n-#include \"PixelBuffer.h\"\n-#include \"PlatformDisplay.h\"\n-#include \"SharedBuffer.h\"\n-#include \"SkiaSpanExtras.h\"\n-#include <skia\/core\/SkData.h>\n-\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkImage.h>\n-#include <skia\/core\/SkPixmap.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-\n-namespace WebCore {\n-\n-GraphicsContextGLImageExtractor::~GraphicsContextGLImageExtractor() = default;\n-\n-bool GraphicsContextGLImageExtractor::extractImage(bool premultiplyAlpha, bool ignoreGammaAndColorProfile, bool ignoreNativeImageAlphaPremultiplication)\n-{\n-    PlatformImagePtr platformImage;\n-    bool hasAlpha = !m_image->currentFrameKnownToBeOpaque();\n-    if ((ignoreGammaAndColorProfile || (hasAlpha && !premultiplyAlpha)) && m_image->data()) {\n-        auto image = BitmapImage::create(nullptr,  AlphaOption::NotPremultiplied, ignoreGammaAndColorProfile ? GammaAndColorProfileOption::Ignored : GammaAndColorProfileOption::Applied);\n-        image->setData(m_image->data(), true);\n-        if (!image->frameCount())\n-            return false;\n-\n-        platformImage = image->currentNativeImage()->platformImage();\n-    } else\n-        platformImage = m_image->currentNativeImage()->platformImage();\n-\n-    if (!platformImage)\n-        return false;\n-\n-    m_imageWidth = platformImage->width();\n-    m_imageHeight = platformImage->height();\n-    if (!m_imageWidth || !m_imageHeight)\n-        return false;\n-\n-    const auto& imageInfo = platformImage->imageInfo();\n-    m_alphaOp = AlphaOp::DoNothing;\n-    switch (imageInfo.alphaType()) {\n-    case kUnknown_SkAlphaType:\n-    case kOpaque_SkAlphaType:\n-        break;\n-    case kPremul_SkAlphaType:\n-        if (!premultiplyAlpha)\n-            m_alphaOp = AlphaOp::DoUnmultiply;\n-        else if (ignoreNativeImageAlphaPremultiplication)\n-            m_alphaOp = AlphaOp::DoPremultiply;\n-        break;\n-    case kUnpremul_SkAlphaType:\n-        if (premultiplyAlpha)\n-            m_alphaOp = AlphaOp::DoPremultiply;\n-        break;\n-    }\n-\n-    unsigned srcUnpackAlignment = 1;\n-    size_t bytesPerRow = imageInfo.minRowBytes();\n-    size_t bytesPerPixel = imageInfo.bytesPerPixel();\n-    unsigned padding = bytesPerRow - bytesPerPixel * m_imageWidth;\n-    if (padding) {\n-        srcUnpackAlignment = padding + 1;\n-        while (bytesPerRow % srcUnpackAlignment)\n-            ++srcUnpackAlignment;\n-    }\n-\n-    if (platformImage->isTextureBacked()) {\n-        auto data = SkData::MakeUninitialized(imageInfo.computeMinByteSize());\n-        if (!PlatformDisplay::sharedDisplay().skiaGLContext()->makeContextCurrent())\n-            return false;\n-\n-        GrDirectContext* grContext = PlatformDisplay::sharedDisplay().skiaGrContext();\n-        if (!platformImage->readPixels(grContext, imageInfo, static_cast<uint8_t*>(data->writable_data()), bytesPerRow, 0, 0))\n-            return false;\n-\n-        m_pixelData = WTFMove(data);\n-        m_imagePixelData = span(m_pixelData.get());\n-\n-        \/\/ SkSurfaces backed by textures have RGBA format.\n-        m_imageSourceFormat = DataFormat::RGBA8;\n-    } else {\n-        SkPixmap pixmap;\n-        if (!platformImage->peekPixels(&pixmap))\n-            return false;\n-\n-        m_skImage = WTFMove(platformImage);\n-        m_imagePixelData = span(pixmap);\n-\n-        \/\/ Raster SkSurfaces have BGRA format.\n-        m_imageSourceFormat = DataFormat::BGRA8;\n-    }\n-\n-    m_imageSourceUnpackAlignment = srcUnpackAlignment;\n-    return true;\n-}\n-\n-RefPtr<NativeImage> GraphicsContextGL::createNativeImageFromPixelBuffer(const GraphicsContextGLAttributes& sourceContextAttributes, Ref<PixelBuffer>&& pixelBuffer)\n-{\n-    ASSERT(!pixelBuffer->size().isEmpty());\n-    auto imageSize = pixelBuffer->size();\n-    SkAlphaType alphaType = kUnpremul_SkAlphaType;\n-    if (!sourceContextAttributes.alpha)\n-        alphaType = kOpaque_SkAlphaType;\n-    else if (sourceContextAttributes.premultipliedAlpha)\n-        alphaType = kPremul_SkAlphaType;\n-    auto imageInfo = SkImageInfo::Make(imageSize.width(), imageSize.height(), kRGBA_8888_SkColorType, alphaType, SkColorSpace::MakeSRGB());\n-\n-    Ref protectedPixelBuffer = pixelBuffer;\n-    SkPixmap pixmap(imageInfo, pixelBuffer->bytes().data(), imageInfo.minRowBytes());\n-    auto image = SkImages::RasterFromPixmap(pixmap, [](const void*, void* context) {\n-        static_cast<PixelBuffer*>(context)->deref();\n-    }, &protectedPixelBuffer.leakRef());\n-    return NativeImage::create(WTFMove(image));\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ ENABLE(WEBGL) && USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/GraphicsContextGLSkia.cpp","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -1,1144 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"GraphicsContextSkia.h\"\n-\n-#if USE(SKIA)\n-#include \"AffineTransform.h\"\n-#include \"DecomposedGlyphs.h\"\n-#include \"FloatRect.h\"\n-#include \"FloatRoundedRect.h\"\n-#include \"FontRenderOptions.h\"\n-#include \"GLContext.h\"\n-#include \"ImageBuffer.h\"\n-#include \"IntRect.h\"\n-#include \"NotImplemented.h\"\n-#include \"PlatformDisplay.h\"\n-#include \"ProcessCapabilities.h\"\n-#include \"SkiaPaintingEngine.h\"\n-#include <cmath>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkColorFilter.h>\n-#include <skia\/core\/SkImage.h>\n-#include <skia\/core\/SkPath.h>\n-#include <skia\/core\/SkPathEffect.h>\n-#include <skia\/core\/SkPathTypes.h>\n-#include <skia\/core\/SkPictureRecorder.h>\n-#include <skia\/core\/SkPoint3.h>\n-#include <skia\/core\/SkRRect.h>\n-#include <skia\/core\/SkRegion.h>\n-#include <skia\/core\/SkSurface.h>\n-#include <skia\/core\/SkTileMode.h>\n-#include <skia\/effects\/SkImageFilters.h>\n-#include <skia\/gpu\/ganesh\/GrBackendSurface.h>\n-#include <skia\/gpu\/ganesh\/SkSurfaceGanesh.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-#include <wtf\/MathExtras.h>\n-\n-#if USE(THEME_ADWAITA)\n-#include \"Adwaita.h\"\n-#endif\n-\n-namespace WebCore {\n-\n-GraphicsContextSkia::GraphicsContextSkia(SkCanvas& canvas, RenderingMode renderingMode, RenderingPurpose renderingPurpose, CompletionHandler<void()>&& destroyNotify)\n-    : m_canvas(canvas)\n-    , m_renderingMode(renderingMode)\n-    , m_renderingPurpose(renderingPurpose)\n-    , m_destroyNotify(WTFMove(destroyNotify))\n-    , m_colorSpace(canvas.imageInfo().colorSpace() ? DestinationColorSpace(canvas.imageInfo().refColorSpace()) : DestinationColorSpace::SRGB())\n-{\n-}\n-\n-GraphicsContextSkia::~GraphicsContextSkia()\n-{\n-    if (m_destroyNotify)\n-        m_destroyNotify();\n-}\n-\n-bool GraphicsContextSkia::hasPlatformContext() const\n-{\n-    return true;\n-}\n-\n-AffineTransform GraphicsContextSkia::getCTM(IncludeDeviceScale includeScale) const\n-{\n-    UNUSED_PARAM(includeScale);\n-    return m_canvas.getTotalMatrix();\n-}\n-\n-SkCanvas* GraphicsContextSkia::platformContext() const\n-{\n-    return &m_canvas;\n-}\n-\n-const DestinationColorSpace& GraphicsContextSkia::colorSpace() const\n-{\n-    return m_colorSpace;\n-}\n-\n-bool GraphicsContextSkia::makeGLContextCurrentIfNeeded() const\n-{\n-    if (m_renderingMode == RenderingMode::Unaccelerated || m_renderingPurpose != RenderingPurpose::Canvas)\n-        return true;\n-\n-    return PlatformDisplay::sharedDisplay().skiaGLContext()->makeContextCurrent();\n-}\n-\n-void GraphicsContextSkia::save(GraphicsContextState::Purpose purpose)\n-{\n-    GraphicsContext::save(purpose);\n-    m_skiaStateStack.append(m_skiaState);\n-    m_canvas.save();\n-}\n-\n-void GraphicsContextSkia::restore(GraphicsContextState::Purpose purpose)\n-{\n-    if (!stackSize())\n-        return;\n-\n-    GraphicsContext::restore(purpose);\n-\n-    if (!m_skiaStateStack.isEmpty()) {\n-        m_skiaState = m_skiaStateStack.takeLast();\n-        if (m_skiaStateStack.isEmpty())\n-            m_skiaStateStack.clear();\n-    }\n-\n-    m_canvas.restore();\n-}\n-\n-\/\/ Draws a filled rectangle with a stroked border.\n-void GraphicsContextSkia::drawRect(const FloatRect& rect, float borderThickness)\n-{\n-    ASSERT(!rect.isEmpty());\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    SkPaint paint = createFillPaint();\n-    setupFillSource(paint);\n-    m_canvas.drawRect(rect, paint);\n-    if (strokeStyle() == StrokeStyle::NoStroke)\n-        return;\n-\n-    SkIRect rects[4] = {\n-        SkIRect::MakeXYWH(rect.x(), rect.y(), rect.width(), borderThickness),\n-        SkIRect::MakeXYWH(rect.x(), rect.maxY() - borderThickness, rect.width(), borderThickness),\n-        SkIRect::MakeXYWH(rect.x(), rect.y() + borderThickness, borderThickness, rect.height() - 2 * borderThickness),\n-        SkIRect::MakeXYWH(rect.maxX() - borderThickness, rect.y() + borderThickness, borderThickness, rect.height() - 2 * borderThickness)\n-    };\n-\n-    SkRegion region;\n-    region.setRects(rects, 4);\n-    SkPaint strokePaint = createStrokePaint();\n-    setupStrokeSource(strokePaint);\n-    m_canvas.drawRegion(region, strokePaint);\n-}\n-\n-static SkBlendMode toSkiaBlendMode(CompositeOperator operation, BlendMode blendMode)\n-{\n-    switch (blendMode) {\n-    case BlendMode::Normal:\n-        switch (operation) {\n-        case CompositeOperator::Clear:\n-            return SkBlendMode::kClear;\n-        case CompositeOperator::Copy:\n-            return SkBlendMode::kSrc;\n-        case CompositeOperator::SourceOver:\n-            return SkBlendMode::kSrcOver;\n-        case CompositeOperator::SourceIn:\n-            return SkBlendMode::kSrcIn;\n-        case CompositeOperator::SourceOut:\n-            return SkBlendMode::kSrcOut;\n-        case CompositeOperator::SourceAtop:\n-            return SkBlendMode::kSrcATop;\n-        case CompositeOperator::DestinationOver:\n-            return SkBlendMode::kDstOver;\n-        case CompositeOperator::DestinationIn:\n-            return SkBlendMode::kDstIn;\n-        case CompositeOperator::DestinationOut:\n-            return SkBlendMode::kDstOut;\n-        case CompositeOperator::DestinationAtop:\n-            return SkBlendMode::kDstATop;\n-        case CompositeOperator::XOR:\n-            return SkBlendMode::kXor;\n-        case CompositeOperator::PlusLighter:\n-            return SkBlendMode::kPlus;\n-        case CompositeOperator::PlusDarker:\n-            notImplemented();\n-            return SkBlendMode::kSrcOver;\n-        case CompositeOperator::Difference:\n-            return SkBlendMode::kDifference;\n-        }\n-        break;\n-    case BlendMode::Multiply:\n-        return SkBlendMode::kMultiply;\n-    case BlendMode::Screen:\n-        return SkBlendMode::kScreen;\n-    case BlendMode::Overlay:\n-        return SkBlendMode::kOverlay;\n-    case BlendMode::Darken:\n-        return SkBlendMode::kDarken;\n-    case BlendMode::Lighten:\n-        return SkBlendMode::kLighten;\n-    case BlendMode::ColorDodge:\n-        return SkBlendMode::kColorDodge;\n-    case BlendMode::ColorBurn:\n-        return SkBlendMode::kColorBurn;\n-    case BlendMode::HardLight:\n-        return SkBlendMode::kHardLight;\n-    case BlendMode::SoftLight:\n-        return SkBlendMode::kSoftLight;\n-    case BlendMode::Difference:\n-        return SkBlendMode::kDifference;\n-    case BlendMode::Exclusion:\n-        return SkBlendMode::kExclusion;\n-    case BlendMode::Hue:\n-        return SkBlendMode::kHue;\n-    case BlendMode::Saturation:\n-        return SkBlendMode::kSaturation;\n-    case BlendMode::Color:\n-        return SkBlendMode::kColor;\n-    case BlendMode::Luminosity:\n-        return SkBlendMode::kLuminosity;\n-    case BlendMode::PlusLighter:\n-        return SkBlendMode::kPlus;\n-    case BlendMode::PlusDarker:\n-        notImplemented();\n-        break;\n-    }\n-\n-    return SkBlendMode::kSrcOver;\n-}\n-\n-static SkSamplingOptions toSkSamplingOptions(InterpolationQuality quality)\n-{\n-    switch (quality) {\n-    case InterpolationQuality::DoNotInterpolate:\n-        return SkSamplingOptions(SkFilterMode::kNearest, SkMipmapMode::kNone);\n-    case InterpolationQuality::Low:\n-        return SkSamplingOptions(SkFilterMode::kLinear, SkMipmapMode::kNone);\n-    case InterpolationQuality::Medium:\n-    case InterpolationQuality::Default:\n-        return SkSamplingOptions(SkFilterMode::kLinear, SkMipmapMode::kNearest);\n-    case InterpolationQuality::High:\n-        return SkSamplingOptions(SkCubicResampler::CatmullRom());\n-    }\n-\n-    return SkSamplingOptions(SkFilterMode::kLinear, SkMipmapMode::kNearest);\n-}\n-\n-void GraphicsContextSkia::drawNativeImageInternal(NativeImage& nativeImage, const FloatRect& destRect, const FloatRect& srcRect, ImagePaintingOptions options)\n-{\n-    auto image = nativeImage.platformImage();\n-    if (!image)\n-        return;\n-\n-    auto imageSize = nativeImage.size();\n-    if (options.orientation().usesWidthAsHeight())\n-        imageSize = imageSize.transposedSize();\n-    auto imageRect = FloatRect { { }, imageSize };\n-    auto normalizedSrcRect = normalizeRect(srcRect);\n-    if (!imageRect.intersects(normalizedSrcRect))\n-        return;\n-\n-    if (options.orientation().usesWidthAsHeight())\n-        normalizedSrcRect = normalizedSrcRect.transposedRect();\n-\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    auto normalizedDestRect = normalizeRect(destRect);\n-    if (options.orientation() != ImageOrientation::Orientation::None) {\n-        m_canvas.save();\n-\n-        \/\/ ImageOrientation expects the origin to be at (0, 0).\n-        m_canvas.translate(normalizedDestRect.x(), normalizedDestRect.y());\n-        normalizedDestRect.setLocation(FloatPoint());\n-        m_canvas.concat(options.orientation().transformFromDefault(normalizedDestRect.size()));\n-\n-        if (options.orientation().usesWidthAsHeight()) {\n-            \/\/ The destination rectangle will have its width and height already reversed for the orientation of\n-            \/\/ the image, as it was needed for page layout, so we need to reverse it back here.\n-            normalizedDestRect.setSize(normalizedDestRect.size().transposedSize());\n-        }\n-    }\n-\n-    SkPaint paint = createFillPaint();\n-    paint.setAlphaf(alpha());\n-    paint.setBlendMode(toSkiaBlendMode(options.compositeOperator(), options.blendMode()));\n-    bool inExtraTransparencyLayer = false;\n-    auto clampingConstraint = options.strictImageClamping() == StrictImageClamping::Yes ? SkCanvas::kStrict_SrcRectConstraint : SkCanvas::kFast_SrcRectConstraint;\n-\n-    SkImage* useImage = image.get();\n-\n-    sk_sp<SkImage> rasterImage;\n-    if (hasDropShadow()) {\n-        if (image->isTextureBacked()) {\n-            if (renderingMode() == RenderingMode::Unaccelerated) {\n-            \/\/ When drawing GPU-backed image on CPU-backed canvas with filter, we need to convert image to CPU-backed one.\n-            rasterImage = image->makeRasterImage();\n-            useImage = rasterImage.get();\n-            } else\n-                trackAcceleratedRenderingFenceIfNeeded(image);\n-        }\n-        inExtraTransparencyLayer = drawOutsetShadow(paint, [&](const SkPaint& paint) {\n-            m_canvas.drawImageRect(useImage, normalizedSrcRect, normalizedDestRect, toSkSamplingOptions(m_state.imageInterpolationQuality()), &paint, clampingConstraint);\n-        });\n-    } else\n-        trackAcceleratedRenderingFenceIfNeeded(image);\n-\n-    m_canvas.drawImageRect(useImage, normalizedSrcRect, normalizedDestRect, toSkSamplingOptions(m_state.imageInterpolationQuality()), &paint, clampingConstraint);\n-    if (inExtraTransparencyLayer)\n-        endTransparencyLayer();\n-\n-    if (options.orientation() != ImageOrientation::Orientation::None)\n-        m_canvas.restore();\n-}\n-\n-\/\/ This is only used to draw borders, so we should not draw shadows.\n-void GraphicsContextSkia::drawLine(const FloatPoint& point1, const FloatPoint& point2)\n-{\n-    if (strokeStyle() == StrokeStyle::NoStroke)\n-        return;\n-\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    SkPaint paint = createStrokePaint();\n-    paint.setColor(SkColor(strokeColor().colorWithAlphaMultipliedBy(alpha())));\n-\n-    const bool isVertical = (point1.x() + strokeThickness() == point2.x());\n-    float strokeWidth = isVertical ? point2.y() - point1.y() : point2.x() - point1.x();\n-    if (!strokeThickness() || !strokeWidth)\n-        return;\n-\n-    float cornerWidth = 0;\n-\n-    if (strokeStyle() == StrokeStyle::DottedStroke || strokeStyle() == StrokeStyle::DashedStroke) {\n-        \/\/ Figure out end points to ensure we always paint corners.\n-        cornerWidth = dashedLineCornerWidthForStrokeWidth(strokeWidth);\n-        if (isVertical) {\n-            fillRect(FloatRect(point1.x(), point1.y(), strokeThickness(), cornerWidth), strokeColor());\n-            fillRect(FloatRect(point1.x(), point2.y() - cornerWidth, strokeThickness(), cornerWidth), strokeColor());\n-        } else {\n-            fillRect(FloatRect(point1.x(), point1.y(), cornerWidth, strokeThickness()), strokeColor());\n-            fillRect(FloatRect(point2.x() - cornerWidth, point1.y(), cornerWidth, strokeThickness()), strokeColor());\n-        }\n-        strokeWidth -= 2 * cornerWidth;\n-        const float patternWidth = dashedLinePatternWidthForStrokeWidth(strokeWidth);\n-        \/\/ Check if corner drawing sufficiently covers the line.\n-        if (strokeWidth <= patternWidth + 1)\n-            return;\n-\n-        const SkScalar dashIntervals[] = { SkFloatToScalar(patternWidth), SkFloatToScalar(patternWidth) };\n-        const float patternOffset = dashedLinePatternOffsetForPatternAndStrokeWidth(patternWidth, strokeWidth);\n-        paint.setPathEffect(SkDashPathEffect::Make(dashIntervals, 2, patternOffset));\n-    }\n-\n-    const auto centeredPoints = centerLineAndCutOffCorners(isVertical, cornerWidth, point1, point2);\n-    const auto& centeredPoint1 = centeredPoints[0];\n-    const auto& centeredPoint2 = centeredPoints[1];\n-\n-    m_canvas.drawLine(SkFloatToScalar(centeredPoint1.x()), SkFloatToScalar(centeredPoint1.y()), SkFloatToScalar(centeredPoint2.x()), SkFloatToScalar(centeredPoint2.y()), paint);\n-}\n-\n-\/\/ This method is only used to draw the little circles used in lists.\n-void GraphicsContextSkia::drawEllipse(const FloatRect& boundaries)\n-{\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    SkPaint paint = createFillPaint();\n-    setupFillSource(paint);\n-    m_canvas.drawOval(boundaries, paint);\n-}\n-\n-static inline SkPathFillType toSkiaFillType(const WindRule& windRule)\n-{\n-    switch (windRule) {\n-    case WindRule::EvenOdd:\n-        return SkPathFillType::kEvenOdd;\n-    case WindRule::NonZero:\n-        return SkPathFillType::kWinding;\n-    }\n-\n-    return SkPathFillType::kWinding;\n-}\n-\n-void GraphicsContextSkia::drawSkiaPath(const SkPath& path, SkPaint& paint)\n-{\n-    bool inExtraTransparencyLayer = false;\n-    if (hasDropShadow()) {\n-        inExtraTransparencyLayer = drawOutsetShadow(paint, [&](const SkPaint& paint) {\n-            m_canvas.drawPath(path, paint);\n-        });\n-    }\n-    m_canvas.drawPath(path, paint);\n-    if (inExtraTransparencyLayer)\n-        endTransparencyLayer();\n-}\n-\n-void GraphicsContextSkia::fillPath(const Path& path)\n-{\n-    if (path.isEmpty())\n-        return;\n-\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    SkPaint paint = createFillPaint();\n-    setupFillSource(paint);\n-\n-    auto fillRule = toSkiaFillType(state().fillRule());\n-    auto& skiaPath= *path.platformPath();\n-    if (skiaPath.getFillType() == fillRule) {\n-        drawSkiaPath(skiaPath, paint);\n-        return;\n-    }\n-\n-    auto skiaPathCopy = skiaPath;\n-    skiaPathCopy.setFillType(fillRule);\n-    drawSkiaPath(skiaPathCopy, paint);\n-}\n-\n-void GraphicsContextSkia::strokePath(const Path& path)\n-{\n-    if (path.isEmpty())\n-        return;\n-\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    SkPaint strokePaint = createStrokePaint();\n-    setupStrokeSource(strokePaint);\n-    drawSkiaPath(*path.platformPath(), strokePaint);\n-}\n-\n-sk_sp<SkImageFilter> GraphicsContextSkia::createDropShadowFilterIfNeeded(ShadowStyle shadowStyle) const\n-{\n-    if (!hasDropShadow())\n-        return nullptr;\n-\n-    const auto& shadow = dropShadow();\n-    ASSERT(shadow);\n-\n-    auto offset = shadow->offset;\n-    const auto& shadowColor = shadow->color;\n-\n-    if (!shadowColor.isVisible() || (!offset.width() && !offset.height() && !shadow->radius))\n-        return nullptr;\n-\n-    const auto& state = this->state();\n-    auto sigma = shadow->radius \/ 2.0;\n-\n-    if (shadowStyle == ShadowStyle::Inset) {\n-        auto dropShadow = SkImageFilters::DropShadowOnly(offset.width(), offset.height(), sigma, sigma, SK_ColorBLACK, nullptr);\n-        return SkImageFilters::ColorFilter(SkColorFilters::Blend(shadowColor, SkBlendMode::kSrcIn), dropShadow);\n-    }\n-\n-    RELEASE_ASSERT(shadowStyle == ShadowStyle::Outset);\n-\n-    if (!state.shadowsIgnoreTransforms())\n-        return SkImageFilters::DropShadowOnly(offset.width(), offset.height(), sigma, sigma, shadowColor, nullptr);\n-\n-    \/\/ Fast path: identity CTM doesn't need the transform compensation\n-    AffineTransform ctm = getCTM(GraphicsContext::IncludeDeviceScale::PossiblyIncludeDeviceScale);\n-    if (ctm.isIdentity())\n-        return SkImageFilters::DropShadowOnly(offset.width(), offset.height(), sigma, sigma, shadowColor, nullptr);\n-\n-    \/\/ Ignoring the CTM is practically equal as applying the inverse of\n-    \/\/ the CTM when post-processing the drop shadow.\n-    if (const std::optional<SkMatrix>& inverse = ctm.inverse()) {\n-        SkPoint3 p = SkPoint3::Make(offset.width(), offset.height(), 0);\n-        inverse->mapHomogeneousPoints(&p, &p, 1);\n-        sigma = inverse->mapRadius(sigma);\n-        return SkImageFilters::DropShadowOnly(p.x(), p.y(), sigma, sigma, shadowColor, nullptr);\n-    }\n-\n-    return nullptr;\n-}\n-\n-bool GraphicsContextSkia::drawOutsetShadow(SkPaint& paint, Function<void(const SkPaint&)>&& drawFunction)\n-{\n-    auto shadow = createDropShadowFilterIfNeeded(ShadowStyle::Outset);\n-    if (!shadow)\n-        return false;\n-\n-    paint.setImageFilter(shadow);\n-    drawFunction(paint);\n-    paint.setImageFilter(nullptr);\n-    if (!m_layerStateStack.isEmpty()) {\n-        if (auto compositeMode = m_layerStateStack.last().compositeMode) {\n-            beginTransparencyLayer(compositeMode->operation, compositeMode->blendMode);\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-SkPaint GraphicsContextSkia::createFillPaint() const\n-{\n-    SkPaint paint;\n-    paint.setAntiAlias(shouldAntialias());\n-    paint.setStyle(SkPaint::kFill_Style);\n-    paint.setBlendMode(toSkiaBlendMode(compositeMode().operation, blendMode()));\n-\n-    return paint;\n-}\n-\n-void GraphicsContextSkia::setupFillSource(SkPaint& paint)\n-{\n-    if (auto fillPattern = fillBrush().pattern()) {\n-        paint.setShader(fillPattern->createPlatformPattern({ }, toSkSamplingOptions(imageInterpolationQuality())));\n-        paint.setAlphaf(alpha());\n-        trackAcceleratedRenderingFenceIfNeeded(paint);\n-    } else if (auto fillGradient = fillBrush().gradient())\n-        paint.setShader(fillGradient->shader(alpha(), fillBrush().gradientSpaceTransform()));\n-    else\n-        paint.setColor(SkColor(fillColor().colorWithAlphaMultipliedBy(alpha())));\n-}\n-\n-SkPaint GraphicsContextSkia::createStrokePaint() const\n-{\n-    SkPaint paint;\n-    paint.setAntiAlias(shouldAntialias());\n-    paint.setStyle(SkPaint::kStroke_Style);\n-    paint.setBlendMode(toSkiaBlendMode(compositeMode().operation, blendMode()));\n-    paint.setStrokeCap(m_skiaState.m_stroke.cap);\n-    paint.setStrokeJoin(m_skiaState.m_stroke.join);\n-    paint.setStrokeMiter(m_skiaState.m_stroke.miter);\n-    paint.setStrokeWidth(SkFloatToScalar(strokeThickness()));\n-    paint.setPathEffect(m_skiaState.m_stroke.dash);\n-    return paint;\n-}\n-\n-void GraphicsContextSkia::setupStrokeSource(SkPaint& paint)\n-{\n-    if (auto strokePattern = strokeBrush().pattern()) {\n-        paint.setShader(strokePattern->createPlatformPattern({ }, toSkSamplingOptions(imageInterpolationQuality())));\n-        trackAcceleratedRenderingFenceIfNeeded(paint);\n-    } else if (auto strokeGradient = strokeBrush().gradient())\n-        paint.setShader(strokeGradient->shader(alpha(), strokeBrush().gradientSpaceTransform()));\n-    else\n-        paint.setColor(SkColor(strokeBrush().color().colorWithAlphaMultipliedBy(alpha())));\n-}\n-\n-void GraphicsContextSkia::drawSkiaRect(const SkRect& boundaries, SkPaint& paint)\n-{\n-    bool inExtraTransparencyLayer = false;\n-    if (hasDropShadow()) {\n-        inExtraTransparencyLayer = drawOutsetShadow(paint, [&](const SkPaint& paint) {\n-            m_canvas.drawRect(boundaries, paint);\n-        });\n-    }\n-    m_canvas.drawRect(boundaries, paint);\n-    if (inExtraTransparencyLayer)\n-        endTransparencyLayer();\n-}\n-\n-void GraphicsContextSkia::fillRect(const FloatRect& boundaries, RequiresClipToRect)\n-{\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    SkPaint paint = createFillPaint();\n-    setupFillSource(paint);\n-    drawSkiaRect(boundaries, paint);\n-}\n-\n-void GraphicsContextSkia::fillRect(const FloatRect& boundaries, const Color& fillColor)\n-{\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    SkPaint paint = createFillPaint();\n-    paint.setColor(SkColor(fillColor));\n-    drawSkiaRect(boundaries, paint);\n-}\n-\n-void GraphicsContextSkia::fillRect(const FloatRect& boundaries, Gradient& gradient, const AffineTransform& gradientSpaceTransform, RequiresClipToRect)\n-{\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    SkPaint paint = createFillPaint();\n-    paint.setShader(gradient.shader(alpha(), gradientSpaceTransform));\n-    drawSkiaRect(boundaries, paint);\n-}\n-\n-void GraphicsContextSkia::resetClip()\n-{\n-    notImplemented();\n-}\n-\n-void GraphicsContextSkia::clip(const FloatRect& rect)\n-{\n-    m_canvas.clipRect(rect, SkClipOp::kIntersect, false);\n-}\n-\n-void GraphicsContextSkia::clipPath(const Path& path, WindRule clipRule)\n-{\n-    auto fillRule = toSkiaFillType(clipRule);\n-    auto& skiaPath = *path.platformPath();\n-    if (skiaPath.getFillType() == fillRule) {\n-        m_canvas.clipPath(skiaPath, true);\n-        return;\n-    }\n-\n-    auto skiaPathCopy = skiaPath;\n-    skiaPathCopy.setFillType(fillRule);\n-    m_canvas.clipPath(skiaPathCopy, true);\n-}\n-\n-IntRect GraphicsContextSkia::clipBounds() const\n-{\n-    return enclosingIntRect(m_canvas.getLocalClipBounds());\n-}\n-\n-void GraphicsContextSkia::clipToImageBuffer(ImageBuffer& buffer, const FloatRect& destRect)\n-{\n-    if (auto nativeImage = nativeImageForDrawing(buffer)) {\n-        auto image = nativeImage->platformImage();\n-        trackAcceleratedRenderingFenceIfNeeded(image);\n-        m_canvas.clipShader(image->makeShader(SkTileMode::kDecal, SkTileMode::kDecal, { }, SkMatrix::Translate(SkFloatToScalar(destRect.x()), SkFloatToScalar(destRect.y()))));\n-    }\n-}\n-\n-void GraphicsContextSkia::drawFocusRing(const Path& path, float, const Color& color)\n-{\n-#if USE(THEME_ADWAITA)\n-    Adwaita::paintFocus(*this, path, color);\n-#else\n-    notImplemented();\n-    UNUSED_PARAM(path);\n-    UNUSED_PARAM(color);\n-#endif\n-}\n-\n-void GraphicsContextSkia::drawFocusRing(const Vector<FloatRect>& rects, float, float, const Color& color)\n-{\n-#if USE(THEME_ADWAITA)\n-    Adwaita::paintFocus(*this, rects, color);\n-#else\n-    notImplemented();\n-    UNUSED_PARAM(rects);\n-    UNUSED_PARAM(color);\n-#endif\n-}\n-\n-void GraphicsContextSkia::drawLinesForText(const FloatPoint& point, float thickness, std::span<const FloatSegment> lineSegments, bool printing, bool doubleUnderlines, StrokeStyle strokeStyle)\n-{\n-    auto [rects, strokeColor] = computeRectsAndStrokeColorForLinesForText(point, thickness, lineSegments, printing, doubleUnderlines, strokeStyle);\n-    if (rects.isEmpty())\n-        return;\n-    for (auto& rect : rects)\n-        fillRect(rect, strokeColor);\n-}\n-\n-\/\/ Creates a path comprising of two triangle waves separated by some empty space in Y axis.\n-\/\/ The empty space can be filled using SkPaint::kFill_Style thus forming an elegant triangle wave.\n-\/\/ Such triangle wave can be used e.g. as an error underline for text.\n-static SkPath createErrorUnderlinePath(const FloatRect& boundaries)\n-{\n-    const double y = boundaries.y();\n-    double width = boundaries.width();\n-    const double height = boundaries.height();\n-    static const double heightSquares = 2.5;\n-\n-    const double square = height \/ heightSquares;\n-    const double halfSquare = 0.5 * square;\n-\n-    const double unitWidth = (heightSquares - 1.0) * square;\n-    const int widthUnits = static_cast<int>((width + 0.5 * unitWidth) \/ unitWidth);\n-\n-    double x = boundaries.x() + 0.5 * (width - widthUnits * unitWidth);\n-    width = widthUnits * unitWidth;\n-\n-    const double bottom = y + height;\n-    const double top = y;\n-\n-    SkPath path;\n-\n-    \/\/ Bottom triangle wave, left to right.\n-    path.moveTo(SkDoubleToScalar(x - halfSquare), SkDoubleToScalar(top + halfSquare));\n-\n-    int i = 0;\n-    for (i = 0; i < widthUnits; i += 2) {\n-        const double middle = x + (i + 1) * unitWidth;\n-        const double right = x + (i + 2) * unitWidth;\n-\n-        path.lineTo(SkDoubleToScalar(middle), SkDoubleToScalar(bottom));\n-\n-        if (i + 2 == widthUnits)\n-            path.lineTo(SkDoubleToScalar(right + halfSquare), SkDoubleToScalar(top + halfSquare));\n-        else if (i + 1 != widthUnits)\n-            path.lineTo(SkDoubleToScalar(right), SkDoubleToScalar(top + square));\n-    }\n-\n-    \/\/ Top triangle wave, right to left.\n-    for (i -= 2; i >= 0; i -= 2) {\n-        const double left = x + i * unitWidth;\n-        const double middle = x + (i + 1) * unitWidth;\n-        const double right = x + (i + 2) * unitWidth;\n-\n-        if (i + 1 == widthUnits)\n-            path.lineTo(SkDoubleToScalar(middle + halfSquare), SkDoubleToScalar(bottom - halfSquare));\n-        else {\n-            if (i + 2 == widthUnits)\n-                path.lineTo(SkDoubleToScalar(right), SkDoubleToScalar(top));\n-\n-            path.lineTo(SkDoubleToScalar(middle), SkDoubleToScalar(bottom - halfSquare));\n-        }\n-\n-        path.lineTo(SkDoubleToScalar(left), SkDoubleToScalar(top));\n-    }\n-\n-    return path;\n-}\n-\n-void GraphicsContextSkia::drawDotsForDocumentMarker(const FloatRect& boundaries, DocumentMarkerLineStyle style)\n-{\n-    if (style.mode != DocumentMarkerLineStyleMode::Spelling\n-        && style.mode != DocumentMarkerLineStyleMode::Grammar)\n-        return;\n-\n-    SkPaint paint = createFillPaint();\n-    paint.setColor(SkColor(style.color));\n-    m_canvas.drawPath(createErrorUnderlinePath(boundaries), paint);\n-}\n-\n-void GraphicsContextSkia::translate(float x, float y)\n-{\n-    m_canvas.translate(SkFloatToScalar(x), SkFloatToScalar(y));\n-}\n-\n-void GraphicsContextSkia::didUpdateState(GraphicsContextState& state)\n-{\n-    \/\/ FIXME: Handle stroke changes.\n-    state.didApplyChanges();\n-}\n-\n-void GraphicsContextSkia::concatCTM(const AffineTransform& ctm)\n-{\n-    m_canvas.concat(ctm);\n-}\n-\n-void GraphicsContextSkia::setCTM(const AffineTransform& ctm)\n-{\n-    m_canvas.setMatrix(ctm);\n-}\n-\n-void GraphicsContextSkia::beginTransparencyLayer(float opacity)\n-{\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    GraphicsContext::beginTransparencyLayer(opacity);\n-    m_layerStateStack.append({ });\n-\n-    SkPaint paint;\n-    paint.setAlphaf(opacity);\n-    paint.setBlendMode(toSkiaBlendMode(m_state.compositeMode().operation, m_state.compositeMode().blendMode));\n-    m_canvas.saveLayer(nullptr, &paint);\n-}\n-\n-void GraphicsContextSkia::beginTransparencyLayer(CompositeOperator operation, BlendMode blendMode)\n-{\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    GraphicsContext::beginTransparencyLayer(operation, blendMode);\n-    m_layerStateStack.append({ CompositeMode(operation, blendMode) });\n-\n-    SkPaint paint;\n-    paint.setBlendMode(toSkiaBlendMode(operation, blendMode));\n-    m_canvas.saveLayer(nullptr, &paint);\n-    \/\/ When on transparency layer, we don't want to blend operations as when layer ends, we blend it as a whole.\n-    setCompositeMode({ CompositeOperator::SourceOver, BlendMode::Normal });\n-}\n-\n-void GraphicsContextSkia::endTransparencyLayer()\n-{\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    GraphicsContext::endTransparencyLayer();\n-    m_canvas.restore();\n-    if (!m_layerStateStack.isEmpty()) {\n-        auto layerState = m_layerStateStack.takeLast();\n-        if (layerState.compositeMode)\n-            setCompositeMode(*layerState.compositeMode);\n-    }\n-}\n-\n-void GraphicsContextSkia::clearRect(const FloatRect& rect)\n-{\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    auto paint = createFillPaint();\n-    paint.setBlendMode(SkBlendMode::kClear);\n-    m_canvas.drawRect(rect, paint);\n-}\n-\n-void GraphicsContextSkia::strokeRect(const FloatRect& boundaries, float lineWidth)\n-{\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    auto strokePaint = createStrokePaint();\n-    strokePaint.setStrokeWidth(SkFloatToScalar(lineWidth));\n-    setupStrokeSource(strokePaint);\n-    drawSkiaRect(boundaries, strokePaint);\n-}\n-\n-void GraphicsContextSkia::setLineCap(LineCap lineCap)\n-{\n-    auto toSkiaCap = [](const LineCap& lineCap) -> SkPaint::Cap {\n-        switch (lineCap) {\n-        case LineCap::Butt:\n-            return SkPaint::Cap::kButt_Cap;\n-        case LineCap::Round:\n-            return SkPaint::Cap::kRound_Cap;\n-        case LineCap::Square:\n-            return SkPaint::Cap::kSquare_Cap;\n-        }\n-\n-        return SkPaint::Cap::kDefault_Cap;\n-    };\n-\n-    m_skiaState.m_stroke.cap = toSkiaCap(lineCap);\n-}\n-\n-static bool isValidDashArray(const DashArray& dashArray)\n-{\n-    \/\/ See 'dom-context-2d-setlinedash': if the array contains not finite or negative values, return.\n-    DashArray::value_type total = 0;\n-    for (const auto& dash : dashArray) {\n-        if (dash < 0 || !std::isfinite(dash))\n-            return false;\n-        total += dash;\n-    }\n-    \/\/ Nothing to be done for all-zero or empty arrays.\n-    return total > 0;\n-}\n-\n-void GraphicsContextSkia::setLineDash(const DashArray& dashArray, float dashOffset)\n-{\n-    if (!isValidDashArray(dashArray)) {\n-        m_skiaState.m_stroke.dash = nullptr;\n-        return;\n-    }\n-\n-    if (dashArray.size() % 2 == 1) {\n-        \/\/ Repeat the array to ensure even number of dash array elements, see e.g. 'stroke-dasharray' spec.\n-        DashArray repeatedDashArray(dashArray);\n-        repeatedDashArray.appendVector(dashArray);\n-        m_skiaState.m_stroke.dash = SkDashPathEffect::Make(repeatedDashArray.data(), repeatedDashArray.size(), dashOffset);\n-    } else\n-        m_skiaState.m_stroke.dash = SkDashPathEffect::Make(dashArray.data(), dashArray.size(), dashOffset);\n-}\n-\n-void GraphicsContextSkia::setLineJoin(LineJoin lineJoin)\n-{\n-    auto toSkiaJoin = [](const LineJoin& lineJoin) -> SkPaint::Join {\n-        switch (lineJoin) {\n-        case LineJoin::Miter:\n-            return SkPaint::Join::kMiter_Join;\n-        case LineJoin::Round:\n-            return SkPaint::Join::kRound_Join;\n-        case LineJoin::Bevel:\n-            return SkPaint::Join::kBevel_Join;\n-        }\n-\n-        return SkPaint::Join::kDefault_Join;\n-    };\n-\n-    m_skiaState.m_stroke.join = toSkiaJoin(lineJoin);\n-}\n-\n-void GraphicsContextSkia::setMiterLimit(float miter)\n-{\n-    m_skiaState.m_stroke.miter = SkFloatToScalar(miter);\n-}\n-\n-void GraphicsContextSkia::clipOut(const Path& path)\n-{\n-    auto& skiaPath = *path.platformPath();\n-    skiaPath.toggleInverseFillType();\n-    m_canvas.clipPath(skiaPath, true);\n-    skiaPath.toggleInverseFillType();\n-}\n-\n-void GraphicsContextSkia::rotate(float radians)\n-{\n-    m_canvas.rotate(SkFloatToScalar(rad2deg(radians)));\n-}\n-\n-void GraphicsContextSkia::scale(const FloatSize& scale)\n-{\n-    m_canvas.scale(SkFloatToScalar(scale.width()), SkFloatToScalar(scale.height()));\n-}\n-\n-void GraphicsContextSkia::clipOut(const FloatRect& rect)\n-{\n-    m_canvas.clipRect(rect, SkClipOp::kDifference, false);\n-}\n-\n-void GraphicsContextSkia::fillRoundedRectImpl(const FloatRoundedRect& rect, const Color& color)\n-{\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    SkPaint paint = createFillPaint();\n-    paint.setColor(SkColor(color));\n-    bool inExtraTransparencyLayer = false;\n-    if (hasDropShadow()) {\n-        inExtraTransparencyLayer = drawOutsetShadow(paint, [&](const SkPaint& paint) {\n-            m_canvas.drawRRect(rect, paint);\n-        });\n-    }\n-    m_canvas.drawRRect(rect, paint);\n-    if (inExtraTransparencyLayer)\n-        endTransparencyLayer();\n-}\n-\n-void GraphicsContextSkia::fillRectWithRoundedHole(const FloatRect& outerRect, const FloatRoundedRect& innerRRect, const Color& color)\n-{\n-    if (!color.isValid())\n-        return;\n-\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    SkPaint paint = createFillPaint();\n-    paint.setColor(SkColor(color));\n-    paint.setImageFilter(createDropShadowFilterIfNeeded(ShadowStyle::Inset));\n-    m_canvas.drawDRRect(SkRRect::MakeRect(outerRect), innerRRect, paint);\n-}\n-\n-\/\/ FIXME: Make this a GraphicsContextSkia static function, and use it throughout WebCore.\n-static sk_sp<SkSurface> createAcceleratedSurface(const IntSize& size)\n-{\n-    auto* glContext = PlatformDisplay::sharedDisplay().skiaGLContext();\n-    if (!glContext || !glContext->makeContextCurrent())\n-        return nullptr;\n-\n-    auto* grContext = PlatformDisplay::sharedDisplay().skiaGrContext();\n-    RELEASE_ASSERT(grContext);\n-\n-    auto imageInfo = SkImageInfo::Make(size.width(), size.height(), kRGBA_8888_SkColorType, kPremul_SkAlphaType, SkColorSpace::MakeSRGB());\n-    SkSurfaceProps properties { 0, FontRenderOptions::singleton().subpixelOrder() };\n-    auto surface = SkSurfaces::RenderTarget(grContext, skgpu::Budgeted::kNo, imageInfo, PlatformDisplay::sharedDisplay().msaaSampleCount(), kTopLeft_GrSurfaceOrigin, &properties);\n-    if (!surface || !surface->getCanvas())\n-        return nullptr;\n-\n-    return surface;\n-}\n-\n-void GraphicsContextSkia::drawPattern(NativeImage& nativeImage, const FloatRect& destRect, const FloatRect& tileRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, ImagePaintingOptions options)\n-{\n-    if (!patternTransform.isInvertible())\n-        return;\n-\n-    auto image = nativeImage.platformImage();\n-    if (!image)\n-        return;\n-\n-    if (!makeGLContextCurrentIfNeeded())\n-        return;\n-\n-    FloatPoint phaseOffset(tileRect.location());\n-    phaseOffset.scale(patternTransform.a(), patternTransform.d());\n-    phaseOffset.moveBy(phase);\n-    SkMatrix phaseMatrix;\n-    phaseMatrix.setTranslate(phaseOffset.x(), phaseOffset.y());\n-    SkMatrix shaderMatrix = SkMatrix::Concat(phaseMatrix, patternTransform);\n-    auto samplingOptions = toSkSamplingOptions(m_state.imageInterpolationQuality());\n-\n-    SkPaint paint = createFillPaint();\n-    paint.setBlendMode(toSkiaBlendMode(options.compositeOperator(), options.blendMode()));\n-\n-    auto size = nativeImage.size();\n-    if (spacing.isZero() && tileRect.size() == size) {\n-        \/\/ Check whether we're sampling the pattern beyond the image size. If this is the case, we need to set the repeat\n-        \/\/ flag when sampling. Otherwise we use the clamp flag. This is done to avoid a situation where the pattern is scaled\n-        \/\/ to fit perfectly the destinationRect, but if we use the repeat flag in that case the edges are wrong because the\n-        \/\/ scaling interpolation is using pixels from the other end of the image.\n-        bool repeatX = true;\n-        bool repeatY = true;\n-        SkMatrix inverse;\n-        if (shaderMatrix.invert(&inverse)) {\n-            SkRect imageSampledRect;\n-            inverse.mapRect(&imageSampledRect, SkRect::MakeXYWH(destRect.x(), destRect.y(), destRect.width(), destRect.height()));\n-            repeatX = imageSampledRect.x() < 0 || std::trunc(imageSampledRect.right()) > size.width();\n-            repeatY = imageSampledRect.y() < 0 || std::trunc(imageSampledRect.bottom()) > size.height();\n-        }\n-        paint.setShader(image->makeShader(repeatX ? SkTileMode::kRepeat : SkTileMode::kClamp, repeatY ? SkTileMode::kRepeat : SkTileMode::kClamp, samplingOptions, &shaderMatrix));\n-        trackAcceleratedRenderingFenceIfNeeded(image);\n-    } else {\n-        auto tileFloatRectWithSpacing = FloatRect(0, 0, tileRect.width() + spacing.width() \/ patternTransform.a(), tileRect.height() + spacing.height() \/ patternTransform.d());\n-        if (image->isTextureBacked()) {\n-            auto enclosingTileIntRect = enclosingIntRect(tileRect);\n-            auto dstRect = SkRect::MakeWH(enclosingTileIntRect.width(), enclosingTileIntRect.height());\n-            auto clipRect = enclosingIntRect(tileFloatRectWithSpacing);\n-            if (auto surface = createAcceleratedSurface({ clipRect.width(), clipRect.height() })) {\n-                surface->getCanvas()->drawImageRect(image, tileRect, dstRect, samplingOptions, nullptr, SkCanvas::kStrict_SrcRectConstraint);\n-                auto tileImage = surface->makeImageSnapshot();\n-                paint.setShader(tileImage->makeShader(SkTileMode::kRepeat, SkTileMode::kRepeat, samplingOptions, &shaderMatrix));\n-                trackAcceleratedRenderingFenceIfNeeded(tileImage);\n-            }\n-        } else {\n-            auto dstRect = SkRect::MakeWH(tileRect.width(), tileRect.height());\n-            auto clipRect = SkRect::MakeWH(tileFloatRectWithSpacing.width(), tileFloatRectWithSpacing.height());\n-            \/\/ For raster images we can save creating a copy altogether, by using SkPicture recording instead.\n-        SkPictureRecorder recorder;\n-            auto* recordCanvas = recorder.beginRecording(clipRect);\n-        \/\/ The below call effectively extracts a tile from the image thus performing a clipping.\n-            recordCanvas->drawImageRect(image, tileRect, dstRect, samplingOptions, nullptr, SkCanvas::kStrict_SrcRectConstraint);\n-        auto picture = recorder.finishRecordingAsPicture();\n-        paint.setShader(picture->makeShader(SkTileMode::kRepeat, SkTileMode::kRepeat, samplingOptions.filter, &shaderMatrix, nullptr));\n-    }\n-    }\n-\n-    m_canvas.drawRect(destRect, paint);\n-}\n-\n-void GraphicsContextSkia::beginRecording()\n-{\n-    ASSERT(m_contextMode == ContextMode::PaintingMode);\n-    m_contextMode = ContextMode::RecordingMode;\n-}\n-\n-SkiaImageToFenceMap GraphicsContextSkia::endRecording()\n-{\n-    ASSERT(m_contextMode == ContextMode::RecordingMode);\n-    m_contextMode = ContextMode::PaintingMode;\n-    return WTFMove(m_imageToFenceMap);\n-}\n-\n-template<typename T>\n-inline std::unique_ptr<GLFence> createAcceleratedRenderingFence(T object)\n-{\n-    auto* glContext = PlatformDisplay::sharedDisplay().skiaGLContext();\n-    if (!glContext || !glContext->makeContextCurrent())\n-        return nullptr;\n-\n-    auto* grContext = PlatformDisplay::sharedDisplay().skiaGrContext();\n-    RELEASE_ASSERT(grContext);\n-\n-    grContext->flush(object);\n-\n-    if (GLFence::isSupported()) {\n-        grContext->submit(GrSyncCpu::kNo);\n-\n-        if (auto fence = GLFence::create())\n-            return fence;\n-    }\n-\n-    grContext->submit(GrSyncCpu::kYes);\n-    return nullptr;\n-}\n-\n-std::unique_ptr<GLFence> GraphicsContextSkia::createAcceleratedRenderingFenceIfNeeded(SkSurface* surface)\n-{\n-    if (!surface || !surface->recordingContext())\n-        return nullptr;\n-    return createAcceleratedRenderingFence<SkSurface*>(surface);\n-}\n-\n-std::unique_ptr<GLFence> GraphicsContextSkia::createAcceleratedRenderingFenceIfNeeded(const sk_sp<SkImage>& image)\n-{\n-    if (!image || !image->isTextureBacked())\n-        return nullptr;\n-    return createAcceleratedRenderingFence<const sk_sp<SkImage>>(image);\n-}\n-\n-void GraphicsContextSkia::trackAcceleratedRenderingFenceIfNeeded(const sk_sp<SkImage>& image)\n-{\n-    if (m_contextMode != ContextMode::RecordingMode)\n-        return;\n-\n-    if (auto fence = createAcceleratedRenderingFenceIfNeeded(image))\n-        m_imageToFenceMap.add(image.get(), WTFMove(fence));\n-}\n-\n-void GraphicsContextSkia::trackAcceleratedRenderingFenceIfNeeded(SkPaint& paint)\n-{\n-    if (m_contextMode != ContextMode::RecordingMode)\n-        return;\n-\n-    auto* shader = paint.getShader();\n-    auto* image = shader ? shader->isAImage(nullptr, nullptr) : nullptr;\n-    if (auto fence = createAcceleratedRenderingFenceIfNeeded(sk_ref_sp(image)))\n-        m_imageToFenceMap.add(image, WTFMove(fence));\n-}\n-\n-void GraphicsContextSkia::drawSkiaText(const sk_sp<SkTextBlob>& blob, SkScalar x, SkScalar y, bool enableAntialias, bool isVertical)\n-{\n-    if (isVertical) {\n-        m_canvas.save();\n-\n-        SkMatrix matrix;\n-        matrix.setSinCos(-1, 0, x, y);\n-        m_canvas.concat(matrix);\n-    }\n-\n-    if (textDrawingMode().contains(TextDrawingMode::Fill)) {\n-        SkPaint paint = createFillPaint();\n-        setupFillSource(paint);\n-        paint.setAntiAlias(enableAntialias);\n-        bool inExtraTransparencyLayer = false;\n-        if (hasDropShadow()) {\n-            inExtraTransparencyLayer = drawOutsetShadow(paint, [&](const SkPaint& paint) {\n-                m_canvas.drawTextBlob(blob, x, y, paint);\n-            });\n-        }\n-        m_canvas.drawTextBlob(blob, x, y, paint);\n-        if (inExtraTransparencyLayer)\n-            endTransparencyLayer();\n-    }\n-\n-    if (textDrawingMode().contains(TextDrawingMode::Stroke)) {\n-        SkPaint paint = createStrokePaint();\n-        setupStrokeSource(paint);\n-        paint.setAntiAlias(enableAntialias);\n-        m_canvas.drawTextBlob(blob, x, y, paint);\n-    }\n-\n-    if (isVertical)\n-        m_canvas.restore();\n-}\n-\n-RenderingMode GraphicsContextSkia::renderingMode() const\n-{\n-    return m_renderingMode;\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/GraphicsContextSkia.cpp","additions":0,"deletions":1144,"binary":false,"changes":1144,"status":"deleted"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright (C) 2024, 2025 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#pragma once\n-\n-#if USE(SKIA)\n-\n-#include \"GLFence.h\"\n-#include \"GraphicsContext.h\"\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkCanvas.h>\n-#include <skia\/core\/SkImage.h>\n-#include <skia\/effects\/SkDashPathEffect.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-#include <wtf\/CompletionHandler.h>\n-#include <wtf\/HashMap.h>\n-\n-class SkSurface;\n-\n-namespace WebCore {\n-\n-using SkiaImageToFenceMap = HashMap<const SkImage*, std::unique_ptr<GLFence>>;\n-\n-class WEBCORE_EXPORT GraphicsContextSkia final : public GraphicsContext {\n-public:\n-    GraphicsContextSkia(SkCanvas&, RenderingMode, RenderingPurpose, CompletionHandler<void()>&& = nullptr);\n-    virtual ~GraphicsContextSkia();\n-\n-    bool hasPlatformContext() const final;\n-    SkCanvas* platformContext() const final;\n-\n-    const DestinationColorSpace& colorSpace() const final;\n-\n-    void beginRecording();\n-    SkiaImageToFenceMap endRecording();\n-\n-    void didUpdateState(GraphicsContextState&);\n-\n-    void setLineCap(LineCap) final;\n-    void setLineDash(const DashArray&, float) final;\n-    void setLineJoin(LineJoin) final;\n-    void setMiterLimit(float) final;\n-\n-    using GraphicsContext::fillRect;\n-    void fillRect(const FloatRect&, RequiresClipToRect = RequiresClipToRect::Yes) final;\n-    void fillRect(const FloatRect&, const Color&) final;\n-    void fillRect(const FloatRect&, Gradient&, const AffineTransform&, RequiresClipToRect = RequiresClipToRect::Yes) final;\n-    void fillRoundedRectImpl(const FloatRoundedRect&, const Color&) final;\n-    void fillRectWithRoundedHole(const FloatRect&, const FloatRoundedRect&, const Color&) final;\n-    void fillPath(const Path&) final;\n-    void strokeRect(const FloatRect&, float) final;\n-    void strokePath(const Path&) final;\n-    void clearRect(const FloatRect&) final;\n-\n-    void drawNativeImageInternal(NativeImage&, const FloatRect&, const FloatRect&, ImagePaintingOptions) final;\n-    void drawPattern(NativeImage&, const FloatRect& destRect, const FloatRect& srcRect, const AffineTransform&, const FloatPoint& phase, const FloatSize& spacing, ImagePaintingOptions) final;\n-    void drawRect(const FloatRect&, float) final;\n-    void drawLine(const FloatPoint&, const FloatPoint&) final;\n-    void drawLinesForText(const FloatPoint&, float thickness, std::span<const FloatSegment>, bool isPrinting, bool doubleLines, StrokeStyle) final;\n-    void drawDotsForDocumentMarker(const FloatRect&, DocumentMarkerLineStyle) final;\n-    void drawEllipse(const FloatRect&) final;\n-\n-    void drawFocusRing(const Path&, float outlineWidth, const Color&) final;\n-    void drawFocusRing(const Vector<FloatRect>&, float outlineOffset, float outlineWidth, const Color&) final;\n-\n-    void save(GraphicsContextState::Purpose = GraphicsContextState::Purpose::SaveRestore) final;\n-    void restore(GraphicsContextState::Purpose = GraphicsContextState::Purpose::SaveRestore) final;\n-\n-    void translate(float, float) final;\n-    void rotate(float) final;\n-    using GraphicsContext::scale;\n-    void scale(const FloatSize&) final;\n-    void concatCTM(const AffineTransform&) final;\n-    void setCTM(const AffineTransform&) final;\n-    AffineTransform getCTM(GraphicsContext::IncludeDeviceScale) const final;\n-\n-    void beginTransparencyLayer(float) final;\n-    void beginTransparencyLayer(CompositeOperator, BlendMode) final;\n-    void endTransparencyLayer() final;\n-\n-    void resetClip() final;\n-    void clip(const FloatRect&) final;\n-    void clipOut(const FloatRect&) final;\n-    void clipOut(const Path&) final;\n-    void clipPath(const Path&, WindRule) final;\n-    IntRect clipBounds() const final;\n-    void clipToImageBuffer(ImageBuffer&, const FloatRect&) final;\n-\n-    RenderingMode renderingMode() const final;\n-\n-    SkPaint createFillPaint() const;\n-    SkPaint createStrokePaint() const;\n-\n-    void drawSkiaText(const sk_sp<SkTextBlob>&, SkScalar, SkScalar, bool, bool);\n-\n-    static std::unique_ptr<GLFence> createAcceleratedRenderingFenceIfNeeded(SkSurface*);\n-    static std::unique_ptr<GLFence> createAcceleratedRenderingFenceIfNeeded(const sk_sp<SkImage>&);\n-\n-private:\n-    enum class ContextMode : bool {\n-        PaintingMode,\n-        RecordingMode\n-    };\n-\n-    bool makeGLContextCurrentIfNeeded() const;\n-    void trackAcceleratedRenderingFenceIfNeeded(const sk_sp<SkImage>&);\n-    void trackAcceleratedRenderingFenceIfNeeded(SkPaint&);\n-\n-    void setupFillSource(SkPaint&);\n-    void setupStrokeSource(SkPaint&);\n-\n-    enum class ShadowStyle : uint8_t { Outset, Inset };\n-    sk_sp<SkImageFilter> createDropShadowFilterIfNeeded(ShadowStyle) const;\n-    bool drawOutsetShadow(SkPaint&, Function<void(const SkPaint&)>&&);\n-\n-    void drawSkiaRect(const SkRect&, SkPaint&);\n-    void drawSkiaPath(const SkPath&, SkPaint&);\n-\n-    class SkiaState {\n-    public:\n-        SkiaState() = default;\n-\n-        struct {\n-            SkScalar miter { SkFloatToScalar(4) };\n-            SkPaint::Cap cap { SkPaint::kButt_Cap };\n-            SkPaint::Join join { SkPaint::kMiter_Join };\n-            sk_sp<SkPathEffect> dash;\n-        } m_stroke;\n-    };\n-\n-    struct LayerState {\n-        std::optional<CompositeMode> compositeMode;\n-    };\n-\n-    SkCanvas& m_canvas;\n-    ContextMode m_contextMode { ContextMode::PaintingMode };\n-    RenderingMode m_renderingMode { RenderingMode::Accelerated };\n-    RenderingPurpose m_renderingPurpose { RenderingPurpose::Unspecified };\n-    CompletionHandler<void()> m_destroyNotify;\n-    SkiaState m_skiaState;\n-    Vector<SkiaState, 1> m_skiaStateStack;\n-    Vector<LayerState, 1> m_layerStateStack;\n-    SkiaImageToFenceMap m_imageToFenceMap;\n-    const DestinationColorSpace m_colorSpace;\n-};\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/GraphicsContextSkia.h","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"},{"patch":"@@ -1,241 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"ImageBufferSkiaAcceleratedBackend.h\"\n-\n-#if USE(SKIA)\n-#include \"FontRenderOptions.h\"\n-#include \"GLContext.h\"\n-#include \"GLFence.h\"\n-#include \"IntRect.h\"\n-#include \"PixelBuffer.h\"\n-#include \"PixelBufferConversion.h\"\n-#include \"PlatformDisplay.h\"\n-#include \"ProcessCapabilities.h\"\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkPixmap.h>\n-#include <skia\/gpu\/ganesh\/GrBackendSurface.h>\n-#include <skia\/gpu\/ganesh\/SkSurfaceGanesh.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-#include <wtf\/TZoneMallocInlines.h>\n-\n-#if USE(COORDINATED_GRAPHICS)\n-#include \"BitmapTexture.h\"\n-#include \"CoordinatedPlatformLayerBufferNativeImage.h\"\n-#include \"CoordinatedPlatformLayerBufferRGB.h\"\n-#include \"GraphicsLayerContentsDisplayDelegateCoordinated.h\"\n-#include \"TextureMapperFlags.h\"\n-#endif\n-\n-namespace WebCore {\n-\n-WTF_MAKE_TZONE_OR_ISO_ALLOCATED_IMPL(ImageBufferSkiaAcceleratedBackend);\n-\n-std::unique_ptr<ImageBufferSkiaAcceleratedBackend> ImageBufferSkiaAcceleratedBackend::create(const Parameters& parameters, const ImageBufferCreationContext& creationContext)\n-{\n-    IntSize backendSize = calculateSafeBackendSize(parameters);\n-    if (backendSize.isEmpty())\n-        return nullptr;\n-\n-    \/\/ We always want to accelerate the canvas when Accelerated2DCanvas setting is true, even if skia CPU is enabled.\n-    if (parameters.purpose != RenderingPurpose::Canvas && !ProcessCapabilities::canUseAcceleratedBuffers())\n-        return nullptr;\n-\n-    auto* glContext = PlatformDisplay::sharedDisplay().skiaGLContext();\n-    if (!glContext || !glContext->makeContextCurrent())\n-        return nullptr;\n-\n-    auto* grContext = PlatformDisplay::sharedDisplay().skiaGrContext();\n-    RELEASE_ASSERT(grContext);\n-\n-    auto imageInfo = SkImageInfo::Make(backendSize.width(), backendSize.height(), kRGBA_8888_SkColorType, kPremul_SkAlphaType, parameters.colorSpace.platformColorSpace());\n-    SkSurfaceProps properties { 0, FontRenderOptions::singleton().subpixelOrder() };\n-    auto surface = SkSurfaces::RenderTarget(grContext, skgpu::Budgeted::kNo, imageInfo, PlatformDisplay::sharedDisplay().msaaSampleCount(), kTopLeft_GrSurfaceOrigin, &properties);\n-    if (!surface || !surface->getCanvas())\n-        return nullptr;\n-\n-    return create(parameters, creationContext, WTFMove(surface));\n-}\n-\n-std::unique_ptr<ImageBufferSkiaAcceleratedBackend> ImageBufferSkiaAcceleratedBackend::create(const Parameters& parameters, const ImageBufferCreationContext&, sk_sp<SkSurface>&& surface)\n-{\n-    ASSERT(surface);\n-    ASSERT(surface->getCanvas());\n-    return std::unique_ptr<ImageBufferSkiaAcceleratedBackend>(new ImageBufferSkiaAcceleratedBackend(parameters, WTFMove(surface)));\n-}\n-\n-ImageBufferSkiaAcceleratedBackend::ImageBufferSkiaAcceleratedBackend(const Parameters& parameters, sk_sp<SkSurface>&& surface)\n-    : ImageBufferSkiaSurfaceBackend(parameters, WTFMove(surface), RenderingMode::Accelerated)\n-{\n-#if USE(COORDINATED_GRAPHICS)\n-    \/\/ Use a content layer for canvas.\n-    if (parameters.purpose == RenderingPurpose::Canvas)\n-        m_layerContentsDisplayDelegate = GraphicsLayerContentsDisplayDelegateCoordinated::create();\n-#endif\n-}\n-\n-ImageBufferSkiaAcceleratedBackend::~ImageBufferSkiaAcceleratedBackend() = default;\n-\n-void ImageBufferSkiaAcceleratedBackend::prepareForDisplay()\n-{\n-#if USE(COORDINATED_GRAPHICS)\n-    if (!m_layerContentsDisplayDelegate)\n-        return;\n-\n-    auto image = createNativeImageReference();\n-    if (!image)\n-        return;\n-\n-    m_layerContentsDisplayDelegate->setDisplayBuffer(CoordinatedPlatformLayerBufferNativeImage::create(image.releaseNonNull(), GLFence::create()));\n-#endif\n-}\n-\n-RefPtr<NativeImage> ImageBufferSkiaAcceleratedBackend::copyNativeImage()\n-{\n-    \/\/ SkSurface uses a copy-on-write mechanism for makeImageSnapshot(), so it's\n-    \/\/ always safe to return the SkImage without copying.\n-    return createNativeImageReference();\n-}\n-\n-RefPtr<NativeImage> ImageBufferSkiaAcceleratedBackend::createNativeImageReference()\n-{\n-    \/\/ If we're using MSAA, we need to flush the surface before calling makeImageSnapshot(),\n-    \/\/ because that call doesn't force the MSAA resolution, which can produce outdated results\n-    \/\/ in the resulting SkImage.\n-    auto& display = PlatformDisplay::sharedDisplay();\n-    if (display.msaaSampleCount() > 0) {\n-        if (display.skiaGLContext()->makeContextCurrent())\n-            display.skiaGrContext()->flush(m_surface.get());\n-    }\n-    return NativeImage::create(m_surface->makeImageSnapshot());\n-}\n-\n-void ImageBufferSkiaAcceleratedBackend::getPixelBuffer(const IntRect& srcRect, PixelBuffer& destination)\n-{\n-    if (!PlatformDisplay::sharedDisplay().skiaGLContext()->makeContextCurrent())\n-        return;\n-\n-    const IntRect backendRect { { }, size() };\n-    const auto sourceRectClipped = intersection(backendRect, srcRect);\n-    IntRect destinationRect { IntPoint::zero(), sourceRectClipped.size() };\n-\n-    if (srcRect.x() < 0)\n-        destinationRect.setX(destinationRect.x() - srcRect.x());\n-    if (srcRect.y() < 0)\n-        destinationRect.setY(destinationRect.y() - srcRect.y());\n-\n-    if (destination.size() != sourceRectClipped.size())\n-        destination.zeroFill();\n-\n-    const auto destinationColorType = (destination.format().pixelFormat == PixelFormat::RGBA8)\n-        ? SkColorType::kRGBA_8888_SkColorType : SkColorType::kBGRA_8888_SkColorType;\n-\n-    const auto destinationAlphaType = (destination.format().alphaFormat == AlphaPremultiplication::Premultiplied)\n-        ? SkAlphaType::kPremul_SkAlphaType : SkAlphaType::kUnpremul_SkAlphaType;\n-\n-    auto destinationInfo = SkImageInfo::Make(destination.size().width(), destination.size().height(),\n-        destinationColorType, destinationAlphaType, destination.format().colorSpace.platformColorSpace());\n-    SkPixmap pixmap(destinationInfo, destination.bytes().data(), destination.size().width() * 4);\n-\n-    SkPixmap dstPixmap;\n-    if (UNLIKELY(!pixmap.extractSubset(&dstPixmap, destinationRect)))\n-        return;\n-\n-    m_surface->readPixels(dstPixmap, sourceRectClipped.x(), sourceRectClipped.y());\n-}\n-\n-static std::span<uint8_t> mutableSpan(SkData* data)\n-{\n-    return unsafeMakeSpan(static_cast<uint8_t*>(data->writable_data()), data->size());\n-}\n-\n-void ImageBufferSkiaAcceleratedBackend::putPixelBuffer(const PixelBuffer& pixelBuffer, const IntRect& srcRect, const IntPoint& destPoint, AlphaPremultiplication destFormat)\n-{\n-    UNUSED_PARAM(destFormat);\n-\n-    if (!PlatformDisplay::sharedDisplay().skiaGLContext()->makeContextCurrent())\n-        return;\n-\n-    ASSERT(IntRect({ 0, 0 }, pixelBuffer.size()).contains(srcRect));\n-    ASSERT(pixelBuffer.format().pixelFormat == PixelFormat::RGBA8 || pixelBuffer.format().pixelFormat == PixelFormat::BGRA8);\n-    ASSERT(pixelBuffer.format().alphaFormat == AlphaPremultiplication::Premultiplied || pixelBuffer.format().alphaFormat == AlphaPremultiplication::Unpremultiplied);\n-\n-    const auto colorType = (pixelBuffer.format().pixelFormat == PixelFormat::RGBA8)\n-        ? SkColorType::kRGBA_8888_SkColorType : SkColorType::kBGRA_8888_SkColorType;\n-\n-    const auto alphaType = (pixelBuffer.format().alphaFormat == AlphaPremultiplication::Premultiplied)\n-        ? SkAlphaType::kPremul_SkAlphaType : SkAlphaType::kUnpremul_SkAlphaType;\n-\n-    const IntRect backendRect { { }, size() };\n-    auto sourceRectClipped = intersection({ IntPoint::zero(), pixelBuffer.size() }, srcRect);\n-    auto destinationRect = sourceRectClipped;\n-    destinationRect.moveBy(destPoint);\n-\n-    if (srcRect.x() < 0)\n-        destinationRect.setX(destinationRect.x() - srcRect.x());\n-    if (srcRect.y() < 0)\n-        destinationRect.setY(destinationRect.y() - srcRect.y());\n-\n-    destinationRect.intersect(backendRect);\n-    sourceRectClipped.setSize(destinationRect.size());\n-\n-    auto pixelBufferInfo = SkImageInfo::Make(pixelBuffer.size().width(), pixelBuffer.size().height(),\n-        colorType, alphaType, pixelBuffer.format().colorSpace.platformColorSpace());\n-    SkPixmap pixmap(pixelBufferInfo, pixelBuffer.bytes().data(), pixelBuffer.size().width() * 4);\n-\n-    SkPixmap srcPixmap;\n-    if (UNLIKELY(!pixmap.extractSubset(&srcPixmap, sourceRectClipped)))\n-        return;\n-\n-    const auto destAlphaType = (destFormat == AlphaPremultiplication::Premultiplied)\n-        ? SkAlphaType::kPremul_SkAlphaType : SkAlphaType::kUnpremul_SkAlphaType;\n-\n-    \/\/ If all the pixels in the source rectangle are opaque, it does not matter which kind\n-    \/\/ of alpha is involved: the destination pixels will be replaced by the source ones.\n-    if (m_surface->imageInfo().alphaType() == destAlphaType || srcPixmap.computeIsOpaque()) {\n-        m_surface->writePixels(srcPixmap, destinationRect.x(), destinationRect.y());\n-        return;\n-    }\n-\n-    \/\/ Fall back to converting, but only the part covered by sourceRectClipped\/srcPixmap.\n-    auto data = SkData::MakeUninitialized(srcPixmap.computeByteSize());\n-    ImageBufferBackend::putPixelBuffer(pixelBuffer, sourceRectClipped, IntPoint::zero(), destFormat, mutableSpan(data.get()));\n-    auto convertedSrcInfo = SkImageInfo::Make(srcPixmap.dimensions(), SkColorType::kBGRA_8888_SkColorType,\n-        SkAlphaType::kPremul_SkAlphaType, colorSpace().platformColorSpace());\n-    SkPixmap convertedSrcPixmap(convertedSrcInfo, data->writable_data(), convertedSrcInfo.minRowBytes64());\n-    m_surface->writePixels(convertedSrcPixmap, destinationRect.x(), destinationRect.y());\n-}\n-\n-#if USE(COORDINATED_GRAPHICS)\n-RefPtr<GraphicsLayerContentsDisplayDelegate> ImageBufferSkiaAcceleratedBackend::layerContentsDisplayDelegate() const\n-{\n-    return m_layerContentsDisplayDelegate;\n-}\n-#endif\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/ImageBufferSkiaAcceleratedBackend.cpp","additions":0,"deletions":241,"binary":false,"changes":241,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#pragma once\n-\n-#if USE(SKIA)\n-#include \"ImageBuffer.h\"\n-#include \"ImageBufferSkiaSurfaceBackend.h\"\n-#include <wtf\/TZoneMalloc.h>\n-\n-namespace WebCore {\n-\n-class ImageBufferSkiaAcceleratedBackend final : public ImageBufferSkiaSurfaceBackend\n-{\n-    WTF_MAKE_TZONE_OR_ISO_ALLOCATED(ImageBufferSkiaAcceleratedBackend);\n-    WTF_MAKE_NONCOPYABLE(ImageBufferSkiaAcceleratedBackend);\n-public:\n-    static std::unique_ptr<ImageBufferSkiaAcceleratedBackend> create(const Parameters&, const ImageBufferCreationContext&);\n-    static std::unique_ptr<ImageBufferSkiaAcceleratedBackend> create(const Parameters&, const ImageBufferCreationContext&, sk_sp<SkSurface>&&);\n-    ~ImageBufferSkiaAcceleratedBackend();\n-\n-    static constexpr RenderingMode renderingMode = RenderingMode::Accelerated;\n-\n-private:\n-    ImageBufferSkiaAcceleratedBackend(const Parameters&, sk_sp<SkSurface>&&);\n-\n-    void prepareForDisplay() final;\n-\n-    RefPtr<NativeImage> copyNativeImage() final;\n-    RefPtr<NativeImage> createNativeImageReference() final;\n-\n-    void getPixelBuffer(const IntRect&, PixelBuffer&) final;\n-    void putPixelBuffer(const PixelBuffer&, const IntRect& srcRect, const IntPoint& destPoint, AlphaPremultiplication destFormat) final;\n-\n-#if USE(COORDINATED_GRAPHICS)\n-    RefPtr<GraphicsLayerContentsDisplayDelegate> layerContentsDisplayDelegate() const final;\n-\n-    RefPtr<GraphicsLayerContentsDisplayDelegate> m_layerContentsDisplayDelegate;\n-#endif\n-};\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/ImageBufferSkiaAcceleratedBackend.h","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"ImageBufferSkiaSurfaceBackend.h\"\n-\n-#if USE(SKIA)\n-\n-namespace WebCore {\n-\n-IntSize ImageBufferSkiaSurfaceBackend::calculateSafeBackendSize(const Parameters& parameters)\n-{\n-    IntSize backendSize = parameters.backendSize;\n-    if (backendSize.isEmpty())\n-        return backendSize;\n-\n-    auto bytesPerRow = 4 * CheckedUint32(backendSize.width());\n-    if (bytesPerRow.hasOverflowed())\n-        return { };\n-\n-    CheckedSize numBytes = CheckedUint32(backendSize.height()) * bytesPerRow;\n-    if (numBytes.hasOverflowed())\n-        return { };\n-\n-    return backendSize;\n-}\n-\n-unsigned ImageBufferSkiaSurfaceBackend::calculateBytesPerRow(const IntSize& backendSize)\n-{\n-    ASSERT(!backendSize.isEmpty());\n-    return CheckedUint32(backendSize.width()) * 4;\n-}\n-\n-size_t ImageBufferSkiaSurfaceBackend::calculateMemoryCost(const Parameters& parameters)\n-{\n-    return ImageBufferBackend::calculateMemoryCost(parameters.backendSize, calculateBytesPerRow(parameters.backendSize));\n-}\n-\n-ImageBufferSkiaSurfaceBackend::ImageBufferSkiaSurfaceBackend(const Parameters& parameters, sk_sp<SkSurface>&& surface, RenderingMode renderingMode)\n-    : ImageBufferSkiaBackend(parameters)\n-    , m_surface(WTFMove(surface))\n-    , m_context(*m_surface->getCanvas(), renderingMode, parameters.purpose)\n-{\n-    m_context.applyDeviceScaleFactor(parameters.resolutionScale);\n-}\n-\n-ImageBufferSkiaSurfaceBackend::~ImageBufferSkiaSurfaceBackend() = default;\n-\n-unsigned ImageBufferSkiaSurfaceBackend::bytesPerRow() const\n-{\n-    return m_surface->imageInfo().minRowBytes64();\n-}\n-\n-bool ImageBufferSkiaSurfaceBackend::canMapBackingStore() const\n-{\n-    return true;\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/ImageBufferSkiaSurfaceBackend.cpp","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#pragma once\n-\n-#if USE(SKIA)\n-#include \"GraphicsContextSkia.h\"\n-#include \"ImageBufferSkiaBackend.h\"\n-\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkSurface.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-\n-#include <wtf\/Forward.h>\n-\n-namespace WebCore {\n-\n-class ImageBufferSkiaSurfaceBackend : public ImageBufferSkiaBackend {\n-public:\n-    virtual ~ImageBufferSkiaSurfaceBackend();\n-\n-    static IntSize calculateSafeBackendSize(const Parameters&);\n-    static unsigned calculateBytesPerRow(const IntSize&);\n-    static size_t calculateMemoryCost(const Parameters&);\n-\n-    SkSurface* surface() const final { return m_surface.get(); }\n-\n-protected:\n-    ImageBufferSkiaSurfaceBackend(const Parameters&, sk_sp<SkSurface>&&, RenderingMode);\n-\n-    GraphicsContext& context() final { return m_context; }\n-    unsigned bytesPerRow() const final;\n-    bool canMapBackingStore() const final;\n-\n-    sk_sp<SkSurface> m_surface;\n-    GraphicsContextSkia m_context;\n-};\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/ImageBufferSkiaSurfaceBackend.h","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"ImageBufferSkiaUnacceleratedBackend.h\"\n-\n-#if USE(SKIA)\n-#include \"FontRenderOptions.h\"\n-#include \"IntRect.h\"\n-#include \"PixelBuffer.h\"\n-#include \"SkiaSpanExtras.h\"\n-#include <skia\/core\/SkPixmap.h>\n-#include <wtf\/TZoneMallocInlines.h>\n-\n-namespace WebCore {\n-\n-WTF_MAKE_TZONE_OR_ISO_ALLOCATED_IMPL(ImageBufferSkiaUnacceleratedBackend);\n-\n-std::unique_ptr<ImageBufferSkiaUnacceleratedBackend> ImageBufferSkiaUnacceleratedBackend::create(const Parameters& parameters, const ImageBufferCreationContext&)\n-{\n-    IntSize backendSize = calculateSafeBackendSize(parameters);\n-    if (backendSize.isEmpty())\n-        return nullptr;\n-\n-    auto imageInfo = SkImageInfo::MakeN32Premul(backendSize.width(), backendSize.height(), parameters.colorSpace.platformColorSpace());\n-    SkSurfaceProps properties = { 0, FontRenderOptions::singleton().subpixelOrder() };\n-    auto surface = SkSurfaces::Raster(imageInfo, &properties);\n-    if (!surface || !surface->getCanvas())\n-        return nullptr;\n-\n-    return std::unique_ptr<ImageBufferSkiaUnacceleratedBackend>(new ImageBufferSkiaUnacceleratedBackend(parameters, WTFMove(surface)));\n-}\n-\n-ImageBufferSkiaUnacceleratedBackend::ImageBufferSkiaUnacceleratedBackend(const Parameters& parameters, sk_sp<SkSurface>&& surface)\n-    : ImageBufferSkiaSurfaceBackend(parameters, WTFMove(surface), RenderingMode::Unaccelerated)\n-{\n-}\n-\n-ImageBufferSkiaUnacceleratedBackend::~ImageBufferSkiaUnacceleratedBackend() = default;\n-\n-RefPtr<NativeImage> ImageBufferSkiaUnacceleratedBackend::copyNativeImage()\n-{\n-    SkPixmap pixmap;\n-    if (m_surface->peekPixels(&pixmap))\n-        return NativeImage::create(SkImages::RasterFromPixmapCopy(pixmap));\n-    return nullptr;\n-}\n-\n-RefPtr<NativeImage> ImageBufferSkiaUnacceleratedBackend::createNativeImageReference()\n-{\n-    SkPixmap pixmap;\n-    if (m_surface->peekPixels(&pixmap)) {\n-        return NativeImage::create(SkImages::RasterFromPixmap(pixmap, [](const void*, void* context) {\n-            static_cast<SkSurface*>(context)->unref();\n-        }, SkSafeRef(m_surface.get())));\n-    }\n-    return nullptr;\n-}\n-\n-void ImageBufferSkiaUnacceleratedBackend::getPixelBuffer(const IntRect& srcRect, PixelBuffer& destination)\n-{\n-    SkPixmap pixmap;\n-    if (m_surface->peekPixels(&pixmap))\n-        ImageBufferBackend::getPixelBuffer(srcRect, span(pixmap), destination);\n-}\n-\n-void ImageBufferSkiaUnacceleratedBackend::putPixelBuffer(const PixelBuffer& pixelBuffer, const IntRect& srcRect, const IntPoint& destPoint, AlphaPremultiplication destFormat)\n-{\n-    SkPixmap pixmap;\n-    if (m_surface->peekPixels(&pixmap))\n-        ImageBufferBackend::putPixelBuffer(pixelBuffer, srcRect, destPoint, destFormat, mutableSpan(pixmap));\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/ImageBufferSkiaUnacceleratedBackend.cpp","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,139 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"ImageBufferUtilitiesSkia.h\"\n-\n-#if USE(SKIA)\n-#include \"GLContext.h\"\n-#include \"MIMETypeRegistry.h\"\n-#include \"PlatformDisplay.h\"\n-\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkData.h>\n-#include <skia\/core\/SkImage.h>\n-#include <skia\/core\/SkStream.h>\n-#include <skia\/encode\/SkJpegEncoder.h>\n-#include <skia\/encode\/SkPngEncoder.h>\n-#include <skia\/encode\/SkWebpEncoder.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-\n-#include <wtf\/text\/WTFString.h>\n-\n-namespace WebCore {\n-\n-class VectorSkiaWritableStream final : public SkWStream {\n-public:\n-    explicit VectorSkiaWritableStream(Vector<uint8_t>& vector)\n-        : m_vector(vector)\n-    {\n-    }\n-\n-    bool write(const void* data, size_t length) override\n-    {\n-        m_vector.append(unsafeMakeSpan(static_cast<const uint8_t*>(data), length));\n-        return true;\n-    }\n-\n-    void flush() override { }\n-\n-    size_t bytesWritten() const override { return m_vector.size(); }\n-\n-private:\n-    Vector<uint8_t>& m_vector;\n-};\n-\n-static sk_sp<SkData> encodeAcceleratedImage(SkImage* image, const String& mimeType, std::optional<double> quality)\n-{\n-    if (!PlatformDisplay::sharedDisplay().skiaGLContext()->makeContextCurrent())\n-        return nullptr;\n-\n-    GrDirectContext* grContext = PlatformDisplay::sharedDisplay().skiaGrContext();\n-\n-    if (MIMETypeRegistry::isJPEGMIMEType(mimeType)) {\n-        SkJpegEncoder::Options options;\n-        if (quality && *quality >= 0.0 && *quality <= 1.0)\n-            options.fQuality = static_cast<int>(*quality * 100.0 + 0.5);\n-        return SkJpegEncoder::Encode(grContext, image, options);\n-    }\n-\n-    if (equalLettersIgnoringASCIICase(mimeType, \"image\/webp\"_s)) {\n-        SkWebpEncoder::Options options;\n-        if (quality && *quality >= 0.0 && *quality <= 1.0)\n-            options.fQuality = static_cast<int>(*quality * 100.0 + 0.5);\n-        return SkWebpEncoder::Encode(grContext, image, options);\n-    }\n-\n-    if (equalLettersIgnoringASCIICase(mimeType, \"image\/png\"_s))\n-        return SkPngEncoder::Encode(grContext, image, { });\n-\n-    return nullptr;\n-}\n-\n-static Vector<uint8_t> encodeUnacceleratedImage(const SkPixmap& pixmap, const String& mimeType, std::optional<double> quality)\n-{\n-    Vector<uint8_t> result;\n-    VectorSkiaWritableStream stream(result);\n-\n-    if (MIMETypeRegistry::isJPEGMIMEType(mimeType)) {\n-        SkJpegEncoder::Options options;\n-        if (quality && *quality >= 0.0 && *quality <= 1.0)\n-            options.fQuality = static_cast<int>(*quality * 100.0 + 0.5);\n-        if (!SkJpegEncoder::Encode(&stream, pixmap, options))\n-            return { };\n-    } else if (equalLettersIgnoringASCIICase(mimeType, \"image\/webp\"_s)) {\n-        SkWebpEncoder::Options options;\n-        if (quality && *quality >= 0.0 && *quality <= 1.0)\n-            options.fQuality = static_cast<int>(*quality * 100.0 + 0.5);\n-        if (!SkWebpEncoder::Encode(&stream, pixmap, options))\n-            return { };\n-    } else if (equalLettersIgnoringASCIICase(mimeType, \"image\/png\"_s)) {\n-        if (!SkPngEncoder::Encode(&stream, pixmap, { }))\n-            return { };\n-    }\n-\n-    return result;\n-}\n-\n-Vector<uint8_t> encodeData(SkImage* image, const String& mimeType, std::optional<double> quality)\n-{\n-    if (image->isTextureBacked()) {\n-        auto data = encodeAcceleratedImage(image, mimeType, quality);\n-        if (!data)\n-            return { };\n-\n-        return unsafeMakeSpan(reinterpret_cast<const uint8_t*>(data->data()), data->size());\n-    }\n-\n-    SkPixmap pixmap;\n-    if (!image->peekPixels(&pixmap))\n-        return { };\n-\n-    return encodeUnacceleratedImage(pixmap, mimeType, quality);\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/ImageBufferUtilitiesSkia.cpp","additions":0,"deletions":139,"binary":false,"changes":139,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"IntRect.h\"\n-\n-#if USE(SKIA)\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN \/\/ GLib\/Win ports\n-#include <skia\/core\/SkRect.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-\n-namespace WebCore {\n-\n-IntRect::IntRect(const SkIRect& r)\n-    : m_location(r.left(), r.top())\n-    , m_size(r.width(), r.height())\n-{\n-}\n-\n-IntRect::operator SkIRect() const\n-{\n-    return { x(), y(), maxX(), maxY() };\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/IntRectSkia.cpp","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"NativeImage.h\"\n-\n-#if USE(SKIA)\n-#include \"GLContext.h\"\n-#include \"GraphicsContextSkia.h\"\n-#include \"PlatformDisplay.h\"\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN \/\/ GLib\/Win ports\n-#include <skia\/core\/SkPixmap.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-\n-namespace WebCore {\n-\n-IntSize PlatformImageNativeImageBackend::size() const\n-{\n-    return m_platformImage ? IntSize(m_platformImage->width(), m_platformImage->height()) : IntSize();\n-}\n-\n-bool PlatformImageNativeImageBackend::hasAlpha() const\n-{\n-    switch (m_platformImage->imageInfo().alphaType()) {\n-    case kUnknown_SkAlphaType:\n-    case kOpaque_SkAlphaType:\n-        return false;\n-    case kPremul_SkAlphaType:\n-    case kUnpremul_SkAlphaType:\n-        return true;\n-    }\n-    return false;\n-}\n-\n-DestinationColorSpace PlatformImageNativeImageBackend::colorSpace() const\n-{\n-    if (auto colorSpace = platformImage()->refColorSpace())\n-        return DestinationColorSpace(colorSpace);\n-    \/\/ No color space means the default - SRGB.\n-    return DestinationColorSpace::SRGB();\n-}\n-\n-Headroom PlatformImageNativeImageBackend::headroom() const\n-{\n-    return Headroom::None;\n-}\n-\n-std::optional<Color> NativeImage::singlePixelSolidColor() const\n-{\n-    if (size() != IntSize(1, 1))\n-        return std::nullopt;\n-\n-    auto platformImage = this->platformImage();\n-    if (platformImage->isTextureBacked()) {\n-        if (!PlatformDisplay::sharedDisplay().skiaGLContext()->makeContextCurrent())\n-            return std::nullopt;\n-\n-        GrDirectContext* grContext = PlatformDisplay::sharedDisplay().skiaGrContext();\n-        const auto& imageInfo = platformImage->imageInfo();\n-        uint32_t pixel;\n-        SkPixmap pixmap(imageInfo, &pixel, imageInfo.minRowBytes());\n-        if (!platformImage->readPixels(grContext, pixmap, 0, 0))\n-            return std::nullopt;\n-\n-        return pixmap.getColor(0, 0);\n-    }\n-\n-    SkPixmap pixmap;\n-    if (!platformImage->peekPixels(&pixmap))\n-        return std::nullopt;\n-\n-    return pixmap.getColor(0, 0);\n-}\n-\n-void NativeImage::draw(GraphicsContext& context, const FloatRect& destinationRect, const FloatRect& sourceRect, ImagePaintingOptions options)\n-{\n-    context.drawNativeImageInternal(*this, destinationRect, sourceRect, options);\n-}\n-\n-void NativeImage::clearSubimages()\n-{\n-}\n-\n-#if USE(COORDINATED_GRAPHICS)\n-uint64_t NativeImage::uniqueID() const\n-{\n-    if (auto& image = platformImage())\n-        return image->uniqueID();\n-    return 0;\n-}\n-#endif\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/NativeImageSkia.cpp","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,368 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"PathSkia.h\"\n-\n-#if USE(SKIA)\n-#include \"GraphicsContextSkia.h\"\n-#include \"NotImplemented.h\"\n-#include \"PathStream.h\"\n-\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkPathUtils.h>\n-#include <skia\/core\/SkRRect.h>\n-#include <skia\/core\/SkSurface.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-\n-#include <wtf\/NeverDestroyed.h>\n-\n-namespace WebCore {\n-\n-Ref<PathSkia> PathSkia::create()\n-{\n-    return adoptRef(*new PathSkia);\n-}\n-\n-Ref<PathSkia> PathSkia::create(const PathSegment& segment)\n-{\n-    auto pathSkia = PathSkia::create();\n-    pathSkia->addSegment(segment);\n-    return pathSkia;\n-}\n-\n-Ref<PathSkia> PathSkia::create(const PathStream& stream)\n-{\n-    auto pathSkia = PathSkia::create();\n-    for (auto& segment : stream.segments())\n-        pathSkia->addSegment(segment);\n-    return pathSkia;\n-}\n-\n-PathSkia::PathSkia(const SkPath& platformPath)\n-    : m_platformPath(platformPath)\n-{\n-}\n-\n-bool PathSkia::definitelyEqual(const PathImpl& otherImpl) const\n-{\n-    RefPtr otherAsPathSkia = dynamicDowncast<PathSkia>(otherImpl);\n-    if (!otherAsPathSkia) {\n-        \/\/ We could convert other to a platform path to compare, but that would be expensive.\n-        return false;\n-    }\n-\n-    if (otherAsPathSkia.get() == this)\n-        return true;\n-\n-    return m_platformPath == otherAsPathSkia->m_platformPath;\n-}\n-\n-Ref<PathImpl> PathSkia::copy() const\n-{\n-    return adoptRef(*new PathSkia(m_platformPath));\n-}\n-\n-PlatformPathPtr PathSkia::platformPath() const\n-{\n-    return const_cast<SkPath*>(&m_platformPath);\n-}\n-\n-void PathSkia::add(PathMoveTo moveTo)\n-{\n-    m_platformPath.moveTo(SkFloatToScalar(moveTo.point.x()), SkFloatToScalar(moveTo.point.y()));\n-}\n-\n-void PathSkia::add(PathLineTo lineTo)\n-{\n-    m_platformPath.lineTo(SkFloatToScalar(lineTo.point.x()), SkFloatToScalar(lineTo.point.y()));\n-}\n-\n-void PathSkia::add(PathQuadCurveTo quadTo)\n-{\n-    m_platformPath.quadTo(SkFloatToScalar(quadTo.controlPoint.x()), SkFloatToScalar(quadTo.controlPoint.y()), SkFloatToScalar(quadTo.endPoint.x()), SkFloatToScalar(quadTo.endPoint.y()));\n-}\n-\n-void PathSkia::add(PathBezierCurveTo cubicTo)\n-{\n-    m_platformPath.cubicTo(SkFloatToScalar(cubicTo.controlPoint1.x()), SkFloatToScalar(cubicTo.controlPoint1.y()), SkFloatToScalar(cubicTo.controlPoint2.x()), SkFloatToScalar(cubicTo.controlPoint2.y()),\n-        SkFloatToScalar(cubicTo.endPoint.x()), SkFloatToScalar(cubicTo.endPoint.y()));\n-}\n-\n-void PathSkia::add(PathArcTo arcTo)\n-{\n-    m_platformPath.arcTo(SkFloatToScalar(arcTo.controlPoint1.x()), SkFloatToScalar(arcTo.controlPoint1.y()), SkFloatToScalar(arcTo.controlPoint2.x()), SkFloatToScalar(arcTo.controlPoint2.y()),\n-        SkFloatToScalar(arcTo.radius));\n-}\n-\n-void PathSkia::addEllipse(const FloatPoint& center, float radiusX, float radiusY, float startAngle, float endAngle, RotationDirection direction)\n-{\n-    auto x = SkFloatToScalar(center.x());\n-    auto y = SkFloatToScalar(center.y());\n-    auto radiusXScalar = SkFloatToScalar(radiusX);\n-    auto radiusYScalar = SkFloatToScalar(radiusY);\n-    SkRect oval = { x - radiusXScalar, y - radiusYScalar, x + radiusXScalar, y + radiusYScalar };\n-\n-    if (direction == RotationDirection::Clockwise && startAngle > endAngle)\n-        endAngle = startAngle + (2 * piFloat - fmodf(startAngle - endAngle, 2 * piFloat));\n-    else if (direction == RotationDirection::Counterclockwise && startAngle < endAngle)\n-        endAngle = startAngle - (2 * piFloat - fmodf(endAngle - startAngle, 2 * piFloat));\n-\n-    auto sweepAngle = endAngle - startAngle;\n-    SkScalar startDegrees = SkFloatToScalar(startAngle * 180 \/ piFloat);\n-    SkScalar sweepDegrees = SkFloatToScalar(sweepAngle * 180 \/ piFloat);\n-\n-    \/\/ SkPath::arcTo can't handle the sweepAngle that is equal to 360, so in those\n-    \/\/ cases we add two arcs with sweepAngle = 180. SkPath::addOval can handle sweepAngle\n-    \/\/ that is 360, but it creates a closed path.\n-    SkScalar s360 = SkIntToScalar(360);\n-    if (SkScalarNearlyEqual(sweepDegrees, s360)) {\n-        SkScalar s180 = SkIntToScalar(180);\n-        m_platformPath.arcTo(oval, startDegrees, s180, false);\n-        m_platformPath.arcTo(oval, startDegrees + s180, s180, false);\n-    } else if (SkScalarNearlyEqual(sweepDegrees, -s360)) {\n-        SkScalar s180 = SkIntToScalar(180);\n-        m_platformPath.arcTo(oval, startDegrees, -s180, false);\n-        m_platformPath.arcTo(oval, startDegrees - s180, -s180, false);\n-    } else\n-        m_platformPath.arcTo(oval, startDegrees, sweepDegrees, false);\n-}\n-\n-void PathSkia::add(PathArc arc)\n-{\n-    addEllipse(arc.center, arc.radius, arc.radius, arc.startAngle, arc.endAngle, arc.direction);\n-}\n-\n-void PathSkia::add(PathClosedArc closedArc)\n-{\n-    add(closedArc.arc);\n-    add(PathCloseSubpath());\n-}\n-\n-void PathSkia::add(PathEllipse ellipse)\n-{\n-    if (!ellipse.rotation) {\n-        addEllipse(ellipse.center, ellipse.radiusX, ellipse.radiusY, ellipse.startAngle, ellipse.endAngle, ellipse.direction);\n-        return;\n-    }\n-\n-    AffineTransform transform;\n-    transform.translate(ellipse.center.x(), ellipse.center.y()).rotateRadians(ellipse.rotation);\n-    auto inverseTransform = transform.inverse().value();\n-    m_platformPath.transform(inverseTransform, nullptr);\n-    addEllipse({ }, ellipse.radiusX, ellipse.radiusY, ellipse.startAngle, ellipse.endAngle, ellipse.direction);\n-    m_platformPath.transform(transform);\n-}\n-\n-void PathSkia::add(PathEllipseInRect ellipseInRect)\n-{\n-    m_platformPath.addOval(ellipseInRect.rect);\n-}\n-\n-void PathSkia::add(PathRect rect)\n-{\n-    m_platformPath.addRect(rect.rect);\n-}\n-\n-void PathSkia::add(PathRoundedRect roundedRect)\n-{\n-    if (roundedRect.strategy == PathRoundedRect::Strategy::PreferNative)\n-        m_platformPath.addRRect(roundedRect.roundedRect);\n-    else\n-        addBeziersForRoundedRect(roundedRect.roundedRect);\n-}\n-\n-void PathSkia::add(PathContinuousRoundedRect continuousRoundedRect)\n-{\n-    \/\/ Continuous rounded rects are unavailable. Paint a normal rounded rect instead.\n-    \/\/ FIXME: Determine if PreferNative is the optimal strategy here.\n-    add(PathRoundedRect { FloatRoundedRect { continuousRoundedRect.rect, FloatRoundedRect::Radii { continuousRoundedRect.cornerWidth, continuousRoundedRect.cornerHeight } }, PathRoundedRect::Strategy::PreferNative });\n-}\n-\n-void PathSkia::add(PathCloseSubpath)\n-{\n-    m_platformPath.close();\n-}\n-\n-void PathSkia::addPath(const PathSkia& path, const AffineTransform& transform)\n-{\n-    m_platformPath.addPath(*path.platformPath(), transform);\n-}\n-\n-bool PathSkia::applyElements(const PathElementApplier& applier) const\n-{\n-    WTF_ALLOW_UNSAFE_BUFFER_USAGE_BEGIN \/\/ GLib\/Win port\n-\n-    auto convertPoints = [](std::span<FloatPoint, 3> dst, const SkPoint src[], int count) {\n-        for (int i = 0; i < count; ++i) {\n-            dst[i].setX(SkScalarToFloat(src[i].fX));\n-            dst[i].setY(SkScalarToFloat(src[i].fY));\n-        }\n-    };\n-\n-    SkPath::RawIter iter(m_platformPath);\n-    SkPoint skPoints[4];\n-    PathElement pathElement;\n-    while (true) {\n-        switch (iter.next(skPoints)) {\n-        case SkPath::kMove_Verb:\n-            pathElement.type = PathElement::Type::MoveToPoint;\n-            convertPoints(pathElement.points, &skPoints[0], 1);\n-            break;\n-        case SkPath::kLine_Verb:\n-            pathElement.type = PathElement::Type::AddLineToPoint;\n-            convertPoints(pathElement.points, &skPoints[1], 1);\n-            break;\n-        case SkPath::kQuad_Verb:\n-            pathElement.type = PathElement::Type::AddQuadCurveToPoint;\n-            convertPoints(pathElement.points, &skPoints[1], 2);\n-            break;\n-        case SkPath::kCubic_Verb:\n-            pathElement.type = PathElement::Type::AddCurveToPoint;\n-            convertPoints(pathElement.points, &skPoints[1], 3);\n-            break;\n-        case SkPath::kConic_Verb: {\n-            \/\/ Approximate conic with quads.\n-            \/\/ The amount of quads can be altered to change the performance\/precision tradeoff.\n-            \/\/ At the moment of writing, at least 4 quads are needed to satisfy layout tests.\n-            pathElement.type = PathElement::Type::AddQuadCurveToPoint;\n-            const int quadCountLog2 = 2;\n-            const unsigned quadCount = 1 << quadCountLog2;\n-            SkPoint quadPoints[1 + 2 * quadCount];\n-            SkPath::ConvertConicToQuads(skPoints[0], skPoints[1], skPoints[2], iter.conicWeight(), quadPoints, quadCountLog2);\n-            for (unsigned quadIndex = 0; quadIndex < quadCount; quadIndex++) {\n-                convertPoints(pathElement.points, &quadPoints[1 + 2 * quadIndex], 2);\n-                applier(pathElement);\n-            }\n-            continue;\n-        }\n-        case SkPath::kClose_Verb:\n-            pathElement.type = PathElement::Type::CloseSubpath;\n-            break;\n-        case SkPath::kDone_Verb:\n-            return true;\n-        }\n-        applier(pathElement);\n-    }\n-    return true;\n-\n-    WTF_ALLOW_UNSAFE_BUFFER_USAGE_END\n-}\n-\n-bool PathSkia::isEmpty() const\n-{\n-    return m_platformPath.isEmpty();\n-}\n-\n-FloatPoint PathSkia::currentPoint() const\n-{\n-    if (m_platformPath.countPoints() > 0) {\n-        SkPoint lastPoint;\n-        m_platformPath.getLastPt(&lastPoint);\n-        return { SkScalarToFloat(lastPoint.fX), SkScalarToFloat(lastPoint.fY) };\n-    }\n-\n-    return { };\n-}\n-\n-bool PathSkia::transform(const AffineTransform& matrix)\n-{\n-    m_platformPath.transform(matrix, nullptr);\n-    return true;\n-}\n-\n-bool PathSkia::contains(const FloatPoint& point, WindRule windRule) const\n-{\n-    if (isEmpty() || !std::isfinite(point.x()) || !std::isfinite(point.y()))\n-        return false;\n-\n-    auto toSkiaFillType = [](const WindRule& windRule) -> SkPathFillType {\n-        switch (windRule) {\n-        case WindRule::EvenOdd:\n-            return SkPathFillType::kEvenOdd;\n-        case WindRule::NonZero:\n-            return SkPathFillType::kWinding;\n-        }\n-\n-        return SkPathFillType::kWinding;\n-    };\n-\n-    SkScalar x = point.x();\n-    SkScalar y = point.y();\n-    auto fillType = toSkiaFillType(windRule);\n-    if (m_platformPath.getFillType() != fillType) {\n-        SkPath pathCopy = m_platformPath;\n-        pathCopy.setFillType(fillType);\n-        return pathCopy.contains(x, y);\n-    }\n-    return m_platformPath.contains(x, y);\n-}\n-\n-bool PathSkia::strokeContains(const FloatPoint& point, NOESCAPE const Function<void(GraphicsContext&)>& strokeStyleApplier) const\n-{\n-    if (isEmpty() || !std::isfinite(point.x()) || !std::isfinite(point.y()))\n-        return false;\n-\n-    auto surface = SkSurfaces::Null(1, 1);\n-    GraphicsContextSkia graphicsContext(*surface->getCanvas(), RenderingMode::Unaccelerated, RenderingPurpose::Unspecified);\n-    strokeStyleApplier(graphicsContext);\n-\n-    \/\/ FIXME: Compute stroke precision.\n-    SkPaint paint = graphicsContext.createStrokePaint();\n-    SkPath strokePath;\n-    skpathutils::FillPathWithPaint(m_platformPath, paint, &strokePath, nullptr);\n-    return strokePath.contains(SkScalar(point.x()), SkScalar(point.y()));\n-}\n-\n-FloatRect PathSkia::fastBoundingRect() const\n-{\n-    return m_platformPath.getBounds();\n-}\n-\n-FloatRect PathSkia::boundingRect() const\n-{\n-    return m_platformPath.computeTightBounds();\n-}\n-\n-FloatRect PathSkia::strokeBoundingRect(NOESCAPE const Function<void(GraphicsContext&)>& strokeStyleApplier) const\n-{\n-    if (isEmpty())\n-        return { };\n-\n-    auto surface = SkSurfaces::Null(1, 1);\n-    GraphicsContextSkia graphicsContext(*surface->getCanvas(), RenderingMode::Unaccelerated, RenderingPurpose::Unspecified);\n-    strokeStyleApplier(graphicsContext);\n-\n-    \/\/ Skia stroke resolution scale for reduced-precision requirements.\n-    constexpr float strokePrecision = 0.3f;\n-    SkPaint paint = graphicsContext.createStrokePaint();\n-    SkPath strokePath;\n-    skpathutils::FillPathWithPaint(m_platformPath, paint, &strokePath, nullptr, strokePrecision);\n-    return strokePath.computeTightBounds();\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/PathSkia.cpp","additions":0,"deletions":368,"binary":false,"changes":368,"status":"deleted"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#pragma once\n-\n-#if USE(SKIA)\n-\n-#include \"PathImpl.h\"\n-#include \"PlatformPath.h\"\n-#include \"WindRule.h\"\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkPath.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-#include <wtf\/Function.h>\n-\n-namespace WebCore {\n-\n-class GraphicsContext;\n-class PathStream;\n-\n-class PathSkia final : public PathImpl {\n-public:\n-    static Ref<PathSkia> create();\n-    static Ref<PathSkia> create(const PathSegment&);\n-    static Ref<PathSkia> create(const PathStream&);\n-    static Ref<PathSkia> create(SkPath&&, RefPtr<PathStream>&&);\n-\n-    PlatformPathPtr platformPath() const;\n-\n-    void addPath(const PathSkia&, const AffineTransform&);\n-\n-    bool definitelyEqual(const PathImpl&) const final;\n-    Ref<PathImpl> copy() const final;\n-    void add(PathMoveTo) final;\n-    void add(PathLineTo) final;\n-    void add(PathQuadCurveTo) final;\n-    void add(PathBezierCurveTo) final;\n-    void add(PathArcTo) final;\n-    void add(PathArc) final;\n-    void add(PathClosedArc) final;\n-    void add(PathEllipse) final;\n-    void add(PathEllipseInRect) final;\n-    void add(PathRect) final;\n-    void add(PathRoundedRect) final;\n-    void add(PathContinuousRoundedRect) final;\n-    void add(PathCloseSubpath) final;\n-\n-    bool applyElements(const PathElementApplier&) const final;\n-\n-    bool transform(const AffineTransform&) final;\n-\n-    bool contains(const FloatPoint&, WindRule) const;\n-    bool strokeContains(const FloatPoint&, NOESCAPE const Function<void(GraphicsContext&)>& strokeStyleApplier) const;\n-\n-    FloatRect strokeBoundingRect(NOESCAPE const Function<void(GraphicsContext&)>& strokeStyleApplier) const;\n-\n-private:\n-    PathSkia() = default;\n-    explicit PathSkia(const SkPath&);\n-\n-    bool isEmpty() const final;\n-\n-    FloatPoint currentPoint() const final;\n-\n-    FloatRect fastBoundingRect() const final;\n-    FloatRect boundingRect() const final;\n-\n-    void addEllipse(const FloatPoint&, float radiusX, float radiusY, float startAngle, float endAngle, RotationDirection);\n-\n-    SkPath m_platformPath;\n-};\n-\n-} \/\/ namespace WebCore\n-\n-SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::PathSkia)\n-    static bool isType(const WebCore::PathImpl& pathImpl) { return !pathImpl.isPathStream(); }\n-SPECIALIZE_TYPE_TRAITS_END()\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/PathSkia.h","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"Pattern.h\"\n-\n-#if USE(SKIA)\n-#include \"AffineTransform.h\"\n-#include \"ImageBuffer.h\"\n-#include \"NativeImage.h\"\n-#include <skia\/core\/SkImage.h>\n-#include <skia\/core\/SkSamplingOptions.h>\n-#include <skia\/core\/SkTileMode.h>\n-\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkMatrix.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-\n-namespace WebCore {\n-\n-sk_sp<SkShader> Pattern::createPlatformPattern(const AffineTransform&, const SkSamplingOptions& samplingOptions) const\n-{\n-    auto nativeImage = tileNativeImage();\n-    if (!nativeImage)\n-        return nullptr;\n-\n-    auto platformImage = nativeImage->platformImage();\n-    if (!platformImage)\n-        return nullptr;\n-\n-    return platformImage->makeShader(repeatX() ? SkTileMode::kRepeat : SkTileMode::kDecal, repeatY() ? SkTileMode::kRepeat : SkTileMode::kDecal, samplingOptions, patternSpaceTransform());\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/PatternSkia.cpp","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,228 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"PlatformDisplay.h\"\n-\n-#if USE(SKIA)\n-#include \"FontRenderOptions.h\"\n-#include \"GLContext.h\"\n-\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkColorSpace.h>\n-#include <skia\/gpu\/ganesh\/GrBackendSurface.h>\n-#include <skia\/gpu\/ganesh\/SkSurfaceGanesh.h>\n-#include <skia\/gpu\/ganesh\/gl\/GrGLBackendSurface.h>\n-#include <skia\/gpu\/ganesh\/gl\/GrGLDirectContext.h>\n-#include <skia\/gpu\/ganesh\/gl\/GrGLInterface.h>\n-\n-#if USE(LIBEPOXY)\n-#include <skia\/gpu\/ganesh\/gl\/epoxy\/GrGLMakeEpoxyEGLInterface.h>\n-#else\n-#include <skia\/gpu\/ganesh\/gl\/egl\/GrGLMakeEGLInterface.h>\n-#endif\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-\n-#include <wtf\/NeverDestroyed.h>\n-#include <wtf\/RunLoop.h>\n-#include <wtf\/ThreadSafeWeakPtr.h>\n-#include <wtf\/text\/StringToIntegerConversion.h>\n-#include <wtf\/threads\/BinarySemaphore.h>\n-\n-\n-namespace WebCore {\n-\n-#if PLATFORM(WPE)\n-#if CPU(X86) || CPU(X86_64)\n-\/\/ On x86 ot x86_64 we need at least 8 samples for the antialiasing result to be similar\n-\/\/ to non MSAA.\n-static const unsigned s_defaultSampleCount = 8;\n-#else\n-\/\/ On embedded, we sacrifice a bit of antialiasing quality to save memory and improve\n-\/\/ performance.\n-static const unsigned s_defaultSampleCount = 4;\n-#endif\n-#else\n-\/\/ Disable MSAA by default.\n-static const unsigned s_defaultSampleCount = 0;\n-#endif\n-\n-#if !(PLATFORM(PLAYSTATION) && USE(COORDINATED_GRAPHICS))\n-static sk_sp<const GrGLInterface> skiaGLInterface()\n-{\n-    static NeverDestroyed<sk_sp<const GrGLInterface>> grGLInterface {\n-#if USE(LIBEPOXY)\n-        GrGLInterfaces::MakeEpoxyEGL()\n-#else\n-        GrGLInterfaces::MakeEGL()\n-#endif\n-    };\n-\n-    return grGLInterface.get();\n-}\n-\n-static thread_local RefPtr<SkiaGLContext> s_skiaGLContext;\n-\n-unsigned initializeMSAASampleCount(GrDirectContext* grContext)\n-{\n-    static std::once_flag onceFlag;\n-    static int sampleCount = s_defaultSampleCount;\n-\n-    std::call_once(onceFlag, [grContext] {\n-        \/\/ Let the user override the default sample count if they want to.\n-        String envString = String::fromLatin1(getenv(\"WEBKIT_SKIA_MSAA_SAMPLE_COUNT\"));\n-        if (!envString.isEmpty())\n-            sampleCount = parseInteger<unsigned>(envString).value_or(0);\n-\n-        if (sampleCount <= 1) {\n-            \/\/ Values of 0 or 1 mean disabling MSAA.\n-            sampleCount = 0;\n-            return;\n-        }\n-\n-        \/\/ Skia checks internally whether MSAA is supported, but also disables it for several platforms where it\n-        \/\/ knows there are bugs. The only way to know whether our sample count will work is trying to create a\n-        \/\/ surface with that value and check whether it works.\n-        auto imageInfo = SkImageInfo::Make(512, 512, kRGBA_8888_SkColorType, kPremul_SkAlphaType, SkColorSpace::MakeSRGB());\n-        SkSurfaceProps properties = { 0, FontRenderOptions::singleton().subpixelOrder() };\n-        auto surface = SkSurfaces::RenderTarget(grContext, skgpu::Budgeted::kNo, imageInfo, sampleCount, kTopLeft_GrSurfaceOrigin, &properties);\n-\n-        \/\/ If the creation of the surface failed, disable MSAA.\n-        if (!surface)\n-            sampleCount = 0;\n-    });\n-\n-    return sampleCount;\n-}\n-\n-class SkiaGLContext : public ThreadSafeRefCountedAndCanMakeThreadSafeWeakPtr<SkiaGLContext> {\n-public:\n-    static Ref<SkiaGLContext> create(PlatformDisplay& display)\n-    {\n-        return adoptRef(*new SkiaGLContext(display));\n-    }\n-\n-    ~SkiaGLContext() = default;\n-\n-    void invalidate()\n-    {\n-        if (&RunLoop::current() == m_runLoop) {\n-            invalidateOnCurrentThread();\n-            return;\n-        }\n-\n-        BinarySemaphore semaphore;\n-        m_runLoop->dispatch([&semaphore, this] {\n-            invalidateOnCurrentThread();\n-            semaphore.signal();\n-        });\n-        semaphore.wait();\n-    }\n-\n-    GLContext* skiaGLContext() const\n-    {\n-        Locker locker { m_lock };\n-        return m_skiaGLContext.get();\n-    }\n-\n-    GrDirectContext* skiaGrContext() const\n-    {\n-        Locker locker { m_lock };\n-        return m_skiaGrContext.get();\n-    }\n-\n-    unsigned sampleCount() const\n-    {\n-        return m_sampleCount;\n-    }\n-\n-private:\n-    explicit SkiaGLContext(PlatformDisplay& display)\n-        : m_runLoop(&RunLoop::current())\n-    {\n-        auto glContext = GLContext::createOffscreen(display);\n-        if (!glContext || !glContext->makeContextCurrent())\n-            return;\n-\n-        \/\/ FIXME: add GrContextOptions, shader cache, etc.\n-        if (auto grContext = GrDirectContexts::MakeGL(skiaGLInterface())) {\n-            m_skiaGLContext = WTFMove(glContext);\n-            m_skiaGrContext = WTFMove(grContext);\n-            m_sampleCount = initializeMSAASampleCount(m_skiaGrContext.get());\n-        }\n-    }\n-\n-    void invalidateOnCurrentThread()\n-    {\n-        Locker locker { m_lock };\n-        m_skiaGrContext = nullptr;\n-        m_skiaGLContext = nullptr;\n-    }\n-\n-    RunLoop* m_runLoop { nullptr };\n-    std::unique_ptr<GLContext> m_skiaGLContext WTF_GUARDED_BY_LOCK(m_lock);\n-    sk_sp<GrDirectContext> m_skiaGrContext WTF_GUARDED_BY_LOCK(m_lock);\n-    mutable Lock m_lock;\n-    unsigned m_sampleCount { 0 };\n-};\n-#endif\n-\n-GLContext* PlatformDisplay::skiaGLContext()\n-{\n-#if PLATFORM(GTK) || PLATFORM(WPE) || (PLATFORM(PLAYSTATION) && !USE(COORDINATED_GRAPHICS))\n-    if (!s_skiaGLContext) {\n-        s_skiaGLContext = SkiaGLContext::create(*this);\n-        m_skiaGLContexts.add(*s_skiaGLContext);\n-    }\n-    return s_skiaGLContext->skiaGLContext();\n-#else\n-    \/\/ The PlayStation OpenGL implementation does not dispatch to the context bound to\n-    \/\/ the current thread so Skia cannot use OpenGL with coordinated graphics.\n-    return nullptr;\n-#endif\n-}\n-\n-GrDirectContext* PlatformDisplay::skiaGrContext()\n-{\n-    RELEASE_ASSERT(s_skiaGLContext);\n-    return s_skiaGLContext->skiaGrContext();\n-}\n-\n-unsigned PlatformDisplay::msaaSampleCount() const\n-{\n-    return s_skiaGLContext->sampleCount();\n-}\n-\n-void PlatformDisplay::invalidateSkiaGLContexts()\n-{\n-    auto contexts = WTFMove(m_skiaGLContexts);\n-    contexts.forEach([](auto& context) {\n-        context.invalidate();\n-    });\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/PlatformDisplaySkia.cpp","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS\n- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n- * THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"ShareableBitmap.h\"\n-\n-#include \"BitmapImage.h\"\n-#include \"FontRenderOptions.h\"\n-#include \"GraphicsContextSkia.h\"\n-#include \"NotImplemented.h\"\n-\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN \/\/ GLib\/Win ports\n-#include <skia\/core\/SkSurface.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-\n-namespace WebCore {\n-\n-std::optional<DestinationColorSpace> ShareableBitmapConfiguration::validateColorSpace(std::optional<DestinationColorSpace> colorSpace)\n-{\n-    return colorSpace;\n-}\n-\n-CheckedUint32 ShareableBitmapConfiguration::calculateBytesPerPixel(const DestinationColorSpace& colorSpace)\n-{\n-    return SkImageInfo::MakeN32Premul(1, 1, colorSpace.platformColorSpace()).bytesPerPixel();\n-}\n-\n-CheckedUint32 ShareableBitmapConfiguration::calculateBytesPerRow(const IntSize& size, const DestinationColorSpace& colorSpace)\n-{\n-    return SkImageInfo::MakeN32Premul(size.width(), size.height(), colorSpace.platformColorSpace()).minRowBytes();\n-}\n-\n-std::unique_ptr<GraphicsContext> ShareableBitmap::createGraphicsContext()\n-{\n-    ref();\n-    SkSurfaceProps properties = { 0, FontRenderOptions::singleton().subpixelOrder() };\n-    auto surface = SkSurfaces::WrapPixels(m_configuration.imageInfo(), mutableSpan().data(), bytesPerRow(), [](void*, void* context) {\n-        static_cast<ShareableBitmap*>(context)->deref();\n-    }, this, &properties);\n-\n-    auto* canvas = surface->getCanvas();\n-    if (!canvas)\n-        return nullptr;\n-\n-    return makeUnique<GraphicsContextSkia>(*canvas, RenderingMode::Unaccelerated, RenderingPurpose::ShareableSnapshot, [surface = WTFMove(surface)] { });\n-}\n-\n-void ShareableBitmap::paint(GraphicsContext& context, const IntPoint& dstPoint, const IntRect& srcRect)\n-{\n-    paint(context, 1, dstPoint, srcRect);\n-}\n-\n-void ShareableBitmap::paint(GraphicsContext& context, float scaleFactor, const IntPoint& dstPoint, const IntRect& srcRect)\n-{\n-    FloatRect scaledSrcRect(srcRect);\n-    scaledSrcRect.scale(scaleFactor);\n-    FloatRect scaledDestRect(dstPoint, srcRect.size());\n-    scaledDestRect.scale(scaleFactor);\n-    auto image = createPlatformImage(BackingStoreCopy::DontCopyBackingStore);\n-    context.platformContext()->drawImageRect(image.get(), scaledSrcRect, scaledDestRect, { }, nullptr, { });\n-}\n-\n-RefPtr<Image> ShareableBitmap::createImage()\n-{\n-    return BitmapImage::create(createPlatformImage(BackingStoreCopy::DontCopyBackingStore));\n-}\n-\n-PlatformImagePtr ShareableBitmap::createPlatformImage(BackingStoreCopy backingStoreCopy, ShouldInterpolate)\n-{\n-    sk_sp<SkData> pixelData;\n-    if (backingStoreCopy == BackingStoreCopy::CopyBackingStore)\n-        pixelData = SkData::MakeWithCopy(span().data(), sizeInBytes());\n-    else {\n-        ref();\n-        pixelData = SkData::MakeWithProc(span().data(), sizeInBytes(), [](const void*, void* bitmap) -> void {\n-            static_cast<ShareableBitmap*>(bitmap)->deref();\n-        }, this);\n-    }\n-    return SkImages::RasterFromData(m_configuration.imageInfo(), pixelData, bytesPerRow());\n-}\n-\n-void ShareableBitmap::setOwnershipOfMemory(const ProcessIdentity&)\n-{\n-}\n-\n-} \/\/ namespace WebCore\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/ShareableBitmapSkia.cpp","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,226 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"SkiaHarfBuzzFont.h\"\n-\n-#if USE(SKIA)\n-#include \"FontCache.h\"\n-#include \"FontCascade.h\"\n-#include \"FontPlatformData.h\"\n-#include \"NotImplemented.h\"\n-#include \"SkiaHarfBuzzFontCache.h\"\n-#include <skia\/core\/SkStream.h>\n-#include <wtf\/unicode\/CharacterNames.h>\n-\n-namespace WebCore {\n-\n-Ref<SkiaHarfBuzzFont> SkiaHarfBuzzFont::getOrCreate(SkTypeface& typeface)\n-{\n-    return FontCache::forCurrentThread().harfBuzzFontCache().font(typeface);\n-}\n-\n-static hb_font_funcs_t* harfBuzzFontFunctions()\n-{\n-    static hb_font_funcs_t* fontFunctions = nullptr;\n-\n-    if (!fontFunctions) {\n-        fontFunctions = hb_font_funcs_create();\n-\n-        hb_font_funcs_set_nominal_glyph_func(fontFunctions, [](hb_font_t*, void* context, hb_codepoint_t unicode, hb_codepoint_t* glyph, void*) -> hb_bool_t {\n-            auto& skiaHarfBuzzFont = *static_cast<SkiaHarfBuzzFont*>(context);\n-            auto hbGlyph = skiaHarfBuzzFont.glyph(unicode);\n-            if (!hbGlyph)\n-                return false;\n-            *glyph = hbGlyph.value();\n-            return true;\n-        }, nullptr, nullptr);\n-\n-        hb_font_funcs_set_variation_glyph_func(fontFunctions, [](hb_font_t*, void* context, hb_codepoint_t unicode, hb_codepoint_t variation, hb_codepoint_t* glyph, void*) -> hb_bool_t {\n-            auto& skiaHarfBuzzFont = *static_cast<SkiaHarfBuzzFont*>(context);\n-            auto hbGlyph = skiaHarfBuzzFont.glyph(unicode, variation);\n-            if (!hbGlyph)\n-                return false;\n-            *glyph = hbGlyph.value();\n-            return true;\n-        }, nullptr, nullptr);\n-\n-        hb_font_funcs_set_glyph_h_advance_func(fontFunctions, [](hb_font_t*, void* context, hb_codepoint_t glyph, void*) -> hb_position_t {\n-            auto& skiaHarfBuzzFont = *static_cast<SkiaHarfBuzzFont*>(context);\n-            return skiaHarfBuzzFont.glyphWidth(glyph);\n-        }, nullptr, nullptr);\n-\n-#if HB_VERSION_ATLEAST(1, 8, 6)\n-        hb_font_funcs_set_glyph_h_advances_func(fontFunctions, [](hb_font_t*, void* context, unsigned count, const hb_codepoint_t* glyphs, unsigned glyphStride, hb_position_t* advances, unsigned advanceStride, void*) {\n-            auto& skiaHarfBuzzFont = *static_cast<SkiaHarfBuzzFont*>(context);\n-            skiaHarfBuzzFont.glyphWidths(count, glyphs, glyphStride, advances, advanceStride);\n-        }, nullptr, nullptr);\n-\n-#endif\n-\n-        hb_font_funcs_set_glyph_extents_func(fontFunctions, [](hb_font_t*, void* context, hb_codepoint_t glyph, hb_glyph_extents_t* extents, void*) -> hb_bool_t {\n-            auto& skiaHarfBuzzFont = *static_cast<SkiaHarfBuzzFont*>(context);\n-            skiaHarfBuzzFont.glyphExtents(glyph, extents);\n-            return true;\n-        }, nullptr, nullptr);\n-\n-        hb_font_funcs_make_immutable(fontFunctions);\n-    }\n-    return fontFunctions;\n-}\n-\n-static HbUniquePtr<hb_face_t> createHarfBuzzFace(SkTypeface& typeface)\n-{\n-    int index;\n-    std::unique_ptr<SkStreamAsset> stream(typeface.openStream(&index));\n-    if (stream) {\n-        if (const auto* memory = stream->getMemoryBase()) {\n-            auto size = static_cast<unsigned>(stream->getLength());\n-            HbUniquePtr<hb_blob_t> blob(hb_blob_create(reinterpret_cast<const char*>(memory), size, HB_MEMORY_MODE_READONLY, stream.release(), [](void* data) {\n-                delete reinterpret_cast<SkStreamAsset*>(data);\n-            }));\n-            auto faceCount = hb_face_count(blob.get());\n-            if (faceCount && static_cast<unsigned>(index) < faceCount)\n-                return HbUniquePtr<hb_face_t>(hb_face_create(blob.get(), index));\n-        }\n-    }\n-\n-    return HbUniquePtr<hb_face_t>(hb_face_create_for_tables([](hb_face_t*, hb_tag_t tag, void* userData) -> hb_blob_t* {\n-        SkTypeface& typeface = *reinterpret_cast<SkTypeface*>(userData);\n-        auto tableData = typeface.copyTableData(tag);\n-        if (!tableData)\n-            return nullptr;\n-\n-        const auto* data = reinterpret_cast<const char*>(tableData->data());\n-        auto dataSize = tableData->size();\n-        return hb_blob_create(data, dataSize, HB_MEMORY_MODE_WRITABLE, tableData.release(), [](void* data) {\n-            sk_sp<SkData> tableData(reinterpret_cast<SkData*>(data));\n-        });\n-    }, &typeface, nullptr));\n-}\n-\n-SkiaHarfBuzzFont::SkiaHarfBuzzFont(SkTypeface& typeface)\n-    : m_uniqueID(typeface.uniqueID())\n-{\n-    auto hbFace = createHarfBuzzFace(typeface);\n-    HbUniquePtr<hb_font_t> hbFont(hb_font_create(hbFace.get()));\n-\n-    if (int axisCount = typeface.getVariationDesignPosition(nullptr, 0)) {\n-        Vector<SkFontArguments::VariationPosition::Coordinate> axisValues(axisCount);\n-        if (typeface.getVariationDesignPosition(axisValues.data(), axisValues.size()) != -1)\n-            hb_font_set_variations(hbFont.get(), reinterpret_cast<hb_variation_t*>(axisValues.data()), axisValues.size());\n-    }\n-\n-    \/\/ Create a subfont with custom functions so that the missing ones are taken from the parent.\n-    m_font.reset(hb_font_create_sub_font(hbFont.get()));\n-    hb_font_set_funcs(m_font.get(), harfBuzzFontFunctions(), this, nullptr);\n-}\n-\n-SkiaHarfBuzzFont::~SkiaHarfBuzzFont()\n-{\n-    FontCache::forCurrentThread().harfBuzzFontCache().remove(m_uniqueID);\n-}\n-\n-static inline hb_position_t skScalarToHarfBuzzPosition(SkScalar value)\n-{\n-    static constexpr int hbPosition = 1 << 16;\n-    return clampTo<int>(value * hbPosition);\n-}\n-\n-hb_font_t* SkiaHarfBuzzFont::scaledFont(const FontPlatformData& fontPlatformData)\n-{\n-    float size = fontPlatformData.size();\n-    auto scale = skScalarToHarfBuzzPosition(size);\n-    hb_font_set_scale(m_font.get(), scale, scale);\n-    hb_font_set_ptem(m_font.get(), size);\n-    m_scaledFont = fontPlatformData.skFont();\n-    return m_font.get();\n-}\n-\n-std::optional<hb_codepoint_t> SkiaHarfBuzzFont::glyph(hb_codepoint_t unicode, std::optional<hb_codepoint_t> variation)\n-{\n-    if (FontCascade::treatAsSpace(unicode))\n-        unicode = space;\n-    else if (FontCascade::treatAsZeroWidthSpaceInComplexScript(unicode))\n-        unicode = zeroWidthSpace;\n-\n-    hb_codepoint_t returnValue;\n-    if (hb_font_get_glyph(hb_font_get_parent(m_font.get()), unicode, variation.value_or(0), &returnValue))\n-        return returnValue;\n-    return std::nullopt;\n-}\n-\n-hb_position_t SkiaHarfBuzzFont::glyphWidth(hb_codepoint_t glyph)\n-{\n-    SkGlyphID glyphID = glyph;\n-    SkScalar width;\n-    m_scaledFont.getWidths(&glyphID, 1, &width);\n-    if (!m_scaledFont.isSubpixel())\n-        width = SkScalarRoundToInt(width);\n-    return skScalarToHarfBuzzPosition(width);\n-}\n-\n-void SkiaHarfBuzzFont::glyphWidths(unsigned count, const hb_codepoint_t* glyphs, unsigned glyphStride, hb_position_t* advances, unsigned advanceStride)\n-{\n-    WTF_ALLOW_UNSAFE_BUFFER_USAGE_BEGIN \/\/ Glib\/Win port\n-\n-    Vector<SkGlyphID, 256> skGlyphs(count);\n-    for (unsigned i = 0; i < count; ++i) {\n-        skGlyphs[i] = *glyphs;\n-        glyphs = reinterpret_cast<const hb_codepoint_t*>(reinterpret_cast<const uint8_t*>(glyphs) + glyphStride);\n-    }\n-\n-    Vector<SkScalar, 256> widths(count);\n-    m_scaledFont.getWidths(skGlyphs.data(), count, widths.data());\n-    if (!m_scaledFont.isSubpixel()) {\n-        for (unsigned i = 0; i < count; ++i)\n-            widths[i] = SkScalarRoundToInt(widths[i]);\n-    }\n-\n-    for (unsigned i = 0; i < count; ++i) {\n-        *advances = skScalarToHarfBuzzPosition(widths[i]);\n-        advances = reinterpret_cast<hb_position_t*>(reinterpret_cast<uint8_t*>(advances) + advanceStride);\n-    }\n-\n-    WTF_ALLOW_UNSAFE_BUFFER_USAGE_END\n-}\n-\n-void SkiaHarfBuzzFont::glyphExtents(hb_codepoint_t glyph, hb_glyph_extents_t* extents)\n-{\n-    SkGlyphID glyphID = glyph;\n-    SkRect bounds;\n-    m_scaledFont.getBounds(&glyphID, 1, &bounds, nullptr);\n-    if (!m_scaledFont.isSubpixel())\n-        bounds.set(bounds.roundOut());\n-\n-    extents->x_bearing = skScalarToHarfBuzzPosition(bounds.fLeft);\n-    extents->y_bearing = skScalarToHarfBuzzPosition(-bounds.fTop);\n-    extents->width = skScalarToHarfBuzzPosition(bounds.width());\n-    extents->height = skScalarToHarfBuzzPosition(-bounds.height());\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/SkiaHarfBuzzFont.cpp","additions":0,"deletions":226,"binary":false,"changes":226,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#pragma once\n-\n-#if USE(SKIA)\n-\n-#include \"HbUniquePtr.h\"\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkFont.h>\n-#include <skia\/core\/SkTypeface.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-#include <wtf\/RefCounted.h>\n-\n-namespace WebCore {\n-\n-class FontPlatformData;\n-\n-class SkiaHarfBuzzFont final : public RefCounted<SkiaHarfBuzzFont> {\n-public:\n-    static Ref<SkiaHarfBuzzFont> getOrCreate(SkTypeface&);\n-\n-    hb_font_t* scaledFont(const FontPlatformData&);\n-\n-    std::optional<hb_codepoint_t> glyph(hb_codepoint_t, std::optional<hb_codepoint_t> variation = std::nullopt);\n-    hb_position_t glyphWidth(hb_codepoint_t);\n-    void glyphWidths(unsigned count, const hb_codepoint_t* glyphs, unsigned glyphStride, hb_position_t* advances, unsigned advanceStride);\n-    void glyphExtents(hb_codepoint_t, hb_glyph_extents_t*);\n-\n-    ~SkiaHarfBuzzFont();\n-\n-private:\n-    friend class SkiaHarfBuzzFontCache;\n-\n-    explicit SkiaHarfBuzzFont(SkTypeface&);\n-\n-    SkTypefaceID m_uniqueID { 0 };\n-    HbUniquePtr<hb_font_t> m_font;\n-    SkFont m_scaledFont;\n-};\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/SkiaHarfBuzzFont.h","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,272 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"SkiaPaintingEngine.h\"\n-\n-#if USE(COORDINATED_GRAPHICS) && USE(SKIA)\n-#include \"BitmapTexturePool.h\"\n-#include \"CoordinatedTileBuffer.h\"\n-#include \"GLContext.h\"\n-#include \"GraphicsLayer.h\"\n-#include \"PlatformDisplay.h\"\n-#include \"ProcessCapabilities.h\"\n-#include \"RenderingMode.h\"\n-#include \"SkiaRecordingResult.h\"\n-#include \"SkiaReplayCanvas.h\"\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkPictureRecorder.h>\n-#include <skia\/gpu\/ganesh\/GrBackendSurface.h>\n-#include <skia\/gpu\/ganesh\/SkImageGanesh.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-#include <wtf\/NumberOfCores.h>\n-#include <wtf\/SystemTracing.h>\n-#include <wtf\/text\/StringToIntegerConversion.h>\n-\n-namespace WebCore {\n-\n-WTF_MAKE_TZONE_ALLOCATED_IMPL(SkiaPaintingEngine);\n-\n-\/\/ Note:\n-\/\/ If WEBKIT_SKIA_ENABLE_CPU_RENDERING is unset, we will allocate a GPU-only worker pool with WEBKIT_SKIA_GPU_PAINTING_THREADS threads (default: 1).\n-\/\/ If WEBKIT_SKIA_ENABLE_CPU_RENDERING is unset, and WEBKIT_SKIA_GPU_PAINTING_THREADS is set to 0, we will use GPU rendering on main thread.\n-\/\/\n-\/\/ If WEBKIT_SKIA_ENABLE_CPU_RENDERING=1 is set, we will allocate a CPU-only worker pool with WEBKIT_SKIA_CPU_PAINTING_THREADS threads (default: nCores\/2).\n-\/\/ if WEBKIT_SKIA_ENABLE_CPU_RENDERING=1 is set, and WEBKIT_SKIA_CPU_PAINTING_THREADS is set to 0, we will use CPU rendering on main thread.\n-\n-SkiaPaintingEngine::SkiaPaintingEngine(unsigned numberOfCPUThreads, unsigned numberOfGPUThreads)\n-{\n-    \/\/ By default, GPU rendering, if activated, takes precedence over CPU rendering.\n-    if (ProcessCapabilities::canUseAcceleratedBuffers()) {\n-        m_texturePool = makeUnique<BitmapTexturePool>();\n-\n-        if (numberOfGPUThreads)\n-            m_gpuWorkerPool = WorkerPool::create(\"SkiaGPUWorker\"_s, numberOfGPUThreads);\n-    } else if (numberOfCPUThreads)\n-        m_cpuWorkerPool = WorkerPool::create(\"SkiaCPUWorker\"_s, numberOfCPUThreads);\n-}\n-\n-SkiaPaintingEngine::~SkiaPaintingEngine() = default;\n-\n-std::unique_ptr<SkiaPaintingEngine> SkiaPaintingEngine::create()\n-{\n-    return makeUnique<SkiaPaintingEngine>(numberOfCPUPaintingThreads(), numberOfGPUPaintingThreads());\n-}\n-\n-void SkiaPaintingEngine::paintIntoGraphicsContext(const GraphicsLayer& layer, GraphicsContext& context, const IntRect& dirtyRect, bool contentsOpaque, float contentsScale) const\n-{\n-    IntRect initialClip(IntPoint::zero(), dirtyRect.size());\n-    context.clip(initialClip);\n-\n-    if (!contentsOpaque) {\n-        context.setCompositeOperation(CompositeOperator::Copy);\n-        context.fillRect(initialClip, Color::transparentBlack);\n-        context.setCompositeOperation(CompositeOperator::SourceOver);\n-    }\n-\n-    FloatRect clipRect(dirtyRect);\n-    clipRect.scale(1 \/ contentsScale);\n-\n-    context.translate(-dirtyRect.x(), -dirtyRect.y());\n-    context.scale(contentsScale);\n-    layer.paintGraphicsLayerContents(context, clipRect);\n-}\n-\n-static bool canPerformAcceleratedRendering()\n-{\n-    return ProcessCapabilities::canUseAcceleratedBuffers() && PlatformDisplay::sharedDisplay().skiaGLContext();\n-}\n-\n-RenderingMode SkiaPaintingEngine::renderingMode() const\n-{\n-    if (canPerformAcceleratedRendering())\n-        return RenderingMode::Accelerated;\n-\n-    return RenderingMode::Unaccelerated;\n-}\n-\n-std::optional<RenderingMode> SkiaPaintingEngine::threadedRenderingMode() const\n-{\n-    if (m_gpuWorkerPool && canPerformAcceleratedRendering())\n-        return RenderingMode::Accelerated;\n-\n-    if (m_cpuWorkerPool)\n-        return RenderingMode::Unaccelerated;\n-\n-    return std::nullopt;\n-}\n-\n-Ref<CoordinatedTileBuffer> SkiaPaintingEngine::createBuffer(RenderingMode renderingMode, const IntSize& size, bool contentsOpaque) const\n-{\n-    if (renderingMode == RenderingMode::Accelerated) {\n-        PlatformDisplay::sharedDisplay().skiaGLContext()->makeContextCurrent();\n-\n-        OptionSet<BitmapTexture::Flags> textureFlags;\n-        if (!contentsOpaque)\n-            textureFlags.add(BitmapTexture::Flags::SupportsAlpha);\n-\n-        ASSERT(m_texturePool);\n-        return CoordinatedAcceleratedTileBuffer::create(m_texturePool->acquireTexture(size, textureFlags));\n-    }\n-\n-    return CoordinatedUnacceleratedTileBuffer::create(size, contentsOpaque ? CoordinatedTileBuffer::NoFlags : CoordinatedTileBuffer::SupportsAlpha);\n-}\n-\n-Ref<CoordinatedTileBuffer> SkiaPaintingEngine::paint(const GraphicsLayer& layer, const IntRect& dirtyRect, bool contentsOpaque, float contentsScale)\n-{\n-    \/\/ ### Synchronous rendering on main thread ###\n-    ASSERT(!useThreadedRendering());\n-\n-    auto renderingMode = canPerformAcceleratedRendering() ? RenderingMode::Accelerated : RenderingMode::Unaccelerated;\n-\n-    auto buffer = createBuffer(renderingMode, dirtyRect.size(), contentsOpaque);\n-    buffer->beginPainting();\n-\n-        if (auto* canvas = buffer->canvas()) {\n-        WTFBeginSignpost(canvas, PaintTile, \"Skia\/%s, dirty region %ix%i+%i+%i\", buffer->isBackedByOpenGL() ? \"GPU\" : \"CPU\", dirtyRect.x(), dirtyRect.y(), dirtyRect.width(), dirtyRect.height());\n-        canvas->save();\n-        canvas->clear(SkColors::kTransparent);\n-\n-        GraphicsContextSkia context(*canvas, renderingMode, RenderingPurpose::LayerBacking);\n-        paintIntoGraphicsContext(layer, context, dirtyRect, contentsOpaque, contentsScale);\n-\n-        canvas->restore();\n-            WTFEndSignpost(canvas, PaintTile);\n-        }\n-\n-        buffer->completePainting();\n-    return buffer;\n-}\n-\n-Ref<SkiaRecordingResult> SkiaPaintingEngine::record(const GraphicsLayer& layer, const IntRect& recordRect, bool contentsOpaque, float contentsScale)\n-{\n-    \/\/ ### Asynchronous rendering on worker threads ###\n-    ASSERT(useThreadedRendering());\n-\n-    auto renderingMode = (m_gpuWorkerPool && canPerformAcceleratedRendering()) ? RenderingMode::Accelerated : RenderingMode::Unaccelerated;\n-\n-    WTFBeginSignpost(this, RecordTile);\n-    SkPictureRecorder pictureRecorder;\n-    auto* recordingCanvas = pictureRecorder.beginRecording(recordRect.width(), recordRect.height());\n-    GraphicsContextSkia recordingContext(*recordingCanvas, renderingMode, RenderingPurpose::LayerBacking);\n-    recordingContext.beginRecording();\n-    paintIntoGraphicsContext(layer, recordingContext, recordRect, contentsOpaque, contentsScale);\n-    auto imageToFenceMap = recordingContext.endRecording();\n-    auto picture = pictureRecorder.finishRecordingAsPicture();\n-    WTFEndSignpost(this, RecordTile);\n-\n-    return SkiaRecordingResult::create(WTFMove(picture), WTFMove(imageToFenceMap), recordRect, renderingMode, contentsOpaque, contentsScale);\n-}\n-\n-Ref<CoordinatedTileBuffer> SkiaPaintingEngine::replay(const RefPtr<SkiaRecordingResult>& recording, const IntRect& dirtyRect)\n-{\n-    \/\/ ### Asynchronous rendering on worker threads ###\n-    ASSERT(useThreadedRendering());\n-\n-    auto renderingMode = recording->renderingMode();\n-    auto buffer = createBuffer(renderingMode, dirtyRect.size(), recording->contentsOpaque());\n-    buffer->beginPainting();\n-\n-    auto& workerPool = renderingMode == RenderingMode::Accelerated ? *m_gpuWorkerPool.get() : *m_cpuWorkerPool.get();\n-    workerPool.postTask([buffer = Ref { buffer }, dirtyRect, recording = RefPtr { recording }]() mutable {\n-        auto* canvas = buffer->canvas();\n-        if (!canvas) {\n-            buffer->completePainting();\n-            return;\n-    }\n-\n-        auto replayPicture = [](const sk_sp<SkPicture>& picture, SkCanvas* canvas, const IntRect& recordRect, const IntRect& paintRect) {\n-            canvas->save();\n-            canvas->clear(SkColors::kTransparent);\n-            canvas->clipRect(SkRect::MakeXYWH(0, 0, paintRect.width(), paintRect.height()));\n-            canvas->translate(recordRect.x() - paintRect.x(), recordRect.y() - paintRect.y());\n-            picture->playback(canvas);\n-            canvas->restore();\n-        };\n-\n-        WTFBeginSignpost(canvas, PaintTile, \"Skia\/%s threaded, dirty region %ix%i+%i+%i\", buffer->isBackedByOpenGL() ? \"GPU\" : \"CPU\", dirtyRect.x(), dirtyRect.y(), dirtyRect.width(), dirtyRect.height());\n-        if (recording->hasFences()) {\n-            auto replayCanvas = SkiaReplayCanvas::create(dirtyRect.size(), recording);\n-            replayCanvas->addCanvas(canvas);\n-            replayPicture(replayCanvas->picture(), &replayCanvas.get(), recording->recordRect(), dirtyRect);\n-            replayCanvas->removeCanvas(canvas);\n-        } else\n-            replayPicture(recording->picture(), canvas, recording->recordRect(), dirtyRect);\n-        WTFEndSignpost(canvas, PaintTile);\n-\n-    buffer->completePainting();\n-    });\n-\n-    return buffer;\n-}\n-\n-unsigned SkiaPaintingEngine::numberOfCPUPaintingThreads()\n-{\n-    static std::once_flag onceFlag;\n-    static unsigned numberOfThreads = 0;\n-\n-    std::call_once(onceFlag, [] {\n-        numberOfThreads = std::max(1, std::min(8, WTF::numberOfProcessorCores() \/ 2)); \/\/ By default, use half the CPU cores, capped at 8.\n-\n-        if (const char* envString = getenv(\"WEBKIT_SKIA_CPU_PAINTING_THREADS\")) {\n-            auto newValue = parseInteger<unsigned>(StringView::fromLatin1(envString));\n-            if (newValue && *newValue <= 8)\n-                numberOfThreads = *newValue;\n-            else\n-                WTFLogAlways(\"The number of Skia painting threads is not between 0 and 8. Using the default value %u\\n\", numberOfThreads);\n-        }\n-    });\n-\n-    return numberOfThreads;\n-}\n-\n-unsigned SkiaPaintingEngine::numberOfGPUPaintingThreads()\n-{\n-    static std::once_flag onceFlag;\n-    static unsigned numberOfThreads = 0;\n-\n-    std::call_once(onceFlag, [] {\n-        \/\/ If WEBKIT_SKIA_ENABLE_CPU_RENDERING=1 is set in the environment, no GPU painting is used.\n-        if (!ProcessCapabilities::canUseAcceleratedBuffers())\n-            return;\n-\n-        \/\/ By default, use 2 GPU worker threads if there are four or more CPU cores, otherwise use 1 thread only.\n-        numberOfThreads = WTF::numberOfProcessorCores() >= 4 ? 2 : 1;\n-\n-        if (const char* envString = getenv(\"WEBKIT_SKIA_GPU_PAINTING_THREADS\")) {\n-            auto newValue = parseInteger<unsigned>(StringView::fromLatin1(envString));\n-            if (newValue && *newValue <= 4)\n-                numberOfThreads = *newValue;\n-            else\n-                WTFLogAlways(\"The number of Skia\/GPU painting threads is not between 0 and 4. Using the default value %u\\n\", numberOfThreads);\n-        }\n-    });\n-\n-    return numberOfThreads;\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(COORDINATED_GRAPHICS) && USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/SkiaPaintingEngine.cpp","additions":0,"deletions":272,"binary":false,"changes":272,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#pragma once\n-\n-#if USE(COORDINATED_GRAPHICS) && USE(SKIA)\n-#include <wtf\/RefPtr.h>\n-#include <wtf\/TZoneMalloc.h>\n-#include <wtf\/WorkerPool.h>\n-\n-namespace WebCore {\n-\n-class BitmapTexturePool;\n-class CoordinatedTileBuffer;\n-class GraphicsContext;\n-class GraphicsLayer;\n-class IntRect;\n-class IntSize;\n-class SkiaRecordingResult;\n-enum class RenderingMode : uint8_t;\n-\n-class SkiaPaintingEngine {\n-    WTF_MAKE_TZONE_ALLOCATED(SkiaPaintingEngine);\n-    WTF_MAKE_NONCOPYABLE(SkiaPaintingEngine);\n-public:\n-    SkiaPaintingEngine(unsigned numberOfCPUThreads, unsigned numberOfGPUThreads);\n-    ~SkiaPaintingEngine();\n-\n-    static std::unique_ptr<SkiaPaintingEngine> create();\n-\n-    static unsigned numberOfCPUPaintingThreads();\n-    static unsigned numberOfGPUPaintingThreads();\n-\n-    bool useThreadedRendering() const { return m_cpuWorkerPool || m_gpuWorkerPool; }\n-\n-    Ref<CoordinatedTileBuffer> paint(const GraphicsLayer&, const IntRect& dirtyRect, bool contentsOpaque, float contentsScale);\n-    Ref<SkiaRecordingResult> record(const GraphicsLayer&, const IntRect& recordRect, bool contentsOpaque, float contentsScale);\n-    Ref<CoordinatedTileBuffer> replay(const RefPtr<SkiaRecordingResult>&, const IntRect& dirtyRect);\n-\n-private:\n-    Ref<CoordinatedTileBuffer> createBuffer(RenderingMode, const IntSize&, bool contentsOpaque) const;\n-\n-    void paintIntoGraphicsContext(const GraphicsLayer&, GraphicsContext&, const IntRect&, bool contentsOpaque, float contentsScale) const;\n-\n-    RenderingMode renderingMode() const;\n-    std::optional<RenderingMode> threadedRenderingMode() const;\n-\n-    RefPtr<WorkerPool> m_cpuWorkerPool;\n-    RefPtr<WorkerPool> m_gpuWorkerPool;\n-    std::unique_ptr<BitmapTexturePool> m_texturePool;\n-};\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(COORDINATED_GRAPHICS) && USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/SkiaPaintingEngine.h","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (C) 2025 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#pragma once\n-\n-#if USE(COORDINATED_GRAPHICS) && USE(SKIA)\n-#include \"GraphicsContextSkia.h\"\n-\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkPicture.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-\n-#include <wtf\/Lock.h>\n-#include <wtf\/ThreadSafeRefCounted.h>\n-\n-class SkImage;\n-\n-namespace WebCore {\n-\n-class SkiaRecordingResult final : public ThreadSafeRefCounted<SkiaRecordingResult, WTF::DestructionThread::Main> {\n-public:\n-    virtual ~SkiaRecordingResult();\n-    static Ref<SkiaRecordingResult> create(sk_sp<SkPicture>&&, SkiaImageToFenceMap&&, const IntRect& recordRect, RenderingMode, bool contentsOpaque, float contentsScale);\n-\n-    void waitForFenceIfNeeded(const SkImage&);\n-    bool hasFences();\n-\n-    const sk_sp<SkPicture>& picture() const { return m_picture; }\n-    const IntRect& recordRect() const { return m_recordRect; }\n-    RenderingMode renderingMode() const { return m_renderingMode; }\n-    bool contentsOpaque() const { return m_contentsOpaque; }\n-    float contentsScale() const { return m_contentsScale; }\n-\n-private:\n-    SkiaRecordingResult(sk_sp<SkPicture>&&, SkiaImageToFenceMap&&, const IntRect& recordRect, RenderingMode, bool contentsOpaque, float contentsScale);\n-\n-    sk_sp<SkPicture> m_picture;\n-    SkiaImageToFenceMap m_imageToFenceMap WTF_GUARDED_BY_LOCK(m_imageToFenceMapLock);\n-    Lock m_imageToFenceMapLock;\n-    IntRect m_recordRect;\n-    RenderingMode m_renderingMode { RenderingMode::Unaccelerated };\n-    bool m_contentsOpaque : 1 { true };\n-    float m_contentsScale { 0 };\n-};\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(COORDINATED_GRAPHICS) && USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/SkiaRecordingResult.h","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Red Hat Inc.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#pragma once\n-\n-#include <wtf\/StdLibExtras.h>\n-\n-#if USE(SKIA)\n-\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN\n-#include <skia\/core\/SkPixmap.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-\n-namespace WebCore {\n-\n-inline std::span<const uint8_t> span(SkData* data)\n-{\n-    return unsafeMakeSpan<const uint8_t>(data->bytes(), data->size());\n-}\n-\n-inline std::span<const uint8_t> span(const sk_sp<SkData>& data)\n-{\n-    return span(data.get());\n-}\n-\n-inline std::span<const uint8_t> span(const SkPixmap& pixmap)\n-{\n-    return unsafeMakeSpan(static_cast<const uint8_t*>(pixmap.addr()), pixmap.computeByteSize());\n-}\n-\n-inline std::span<uint8_t> mutableSpan(SkPixmap& pixmap)\n-{\n-    return unsafeMakeSpan(static_cast<uint8_t*>(pixmap.writable_addr()), pixmap.computeByteSize());\n-}\n-\n-} \/\/ namespace WebCore\n-\n-using WebCore::span;\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/SkiaSpanExtras.h","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (C) 2024 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include \"TransformationMatrix.h\"\n-\n-#if USE(SKIA)\n-#include \"AffineTransform.h\"\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_BEGIN \/\/ GLib\/Win ports\n-#include <skia\/core\/SkM44.h>\n-WTF_IGNORE_WARNINGS_IN_THIRD_PARTY_CODE_END\n-\n-namespace WebCore {\n-\n-TransformationMatrix::TransformationMatrix(const SkM44& t)\n-    : TransformationMatrix(SkScalarToDouble(t.rc(0, 0)), SkScalarToDouble(t.rc(0, 1)), SkScalarToDouble(t.rc(0, 2)), SkScalarToDouble(t.rc(0, 3)),\n-        SkScalarToDouble(t.rc(1, 0)), SkScalarToDouble(t.rc(1, 1)), SkScalarToDouble(t.rc(1, 2)), SkScalarToDouble(t.rc(1, 3)),\n-        SkScalarToDouble(t.rc(2, 0)), SkScalarToDouble(t.rc(2, 1)), SkScalarToDouble(t.rc(2, 2)), SkScalarToDouble(t.rc(2, 3)),\n-        SkScalarToDouble(t.rc(3, 0)), SkScalarToDouble(t.rc(3, 1)), SkScalarToDouble(t.rc(3, 2)), SkScalarToDouble(t.rc(3, 3)))\n-{\n-}\n-\n-TransformationMatrix::operator SkM44() const\n-{\n-    return SkM44 {\n-        SkDoubleToScalar(m11()),\n-        SkDoubleToScalar(m12()),\n-        SkDoubleToScalar(m13()),\n-        SkDoubleToScalar(m14()),\n-        SkDoubleToScalar(m21()),\n-        SkDoubleToScalar(m22()),\n-        SkDoubleToScalar(m23()),\n-        SkDoubleToScalar(m24()),\n-        SkDoubleToScalar(m31()),\n-        SkDoubleToScalar(m32()),\n-        SkDoubleToScalar(m33()),\n-        SkDoubleToScalar(m34()),\n-        SkDoubleToScalar(m41()),\n-        SkDoubleToScalar(m42()),\n-        SkDoubleToScalar(m43()),\n-        SkDoubleToScalar(m44())\n-    };\n-}\n-\n-AffineTransform::AffineTransform(const SkMatrix& t)\n-    : AffineTransform(SkScalarToDouble(t[SkMatrix::kMScaleX]), SkScalarToDouble(t[SkMatrix::kMSkewY]), SkScalarToDouble(t[SkMatrix::kMSkewX]),  SkScalarToDouble(t[SkMatrix::kMScaleY]),\n-        SkScalarToDouble(t[SkMatrix::kMTransX]), SkScalarToDouble(t[SkMatrix::kMTransY]))\n-{\n-}\n-\n-AffineTransform::operator SkMatrix() const\n-{\n-    return SkMatrix::MakeAll(SkDoubleToScalar(a()), SkDoubleToScalar(c()), SkDoubleToScalar(e()), SkDoubleToScalar(b()), SkDoubleToScalar(d()), SkDoubleToScalar(f()), 0, 0, SK_Scalar1);\n-}\n-\n-} \/\/ namespace WebCore\n-\n-#endif \/\/ USE(SKIA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/skia\/TransformationMatrixSkia.cpp","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"}]}