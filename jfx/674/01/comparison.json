{"files":[{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.marlin;\n+\n+import static com.sun.marlin.ArrayCacheConst.ARRAY_SIZES;\n+import static com.sun.marlin.ArrayCacheConst.BUCKETS;\n+import static com.sun.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n+\n+import static com.sun.marlin.MarlinConst.DO_STATS;\n+import static com.sun.marlin.MarlinConst.DO_CHECKS;\n+import static com.sun.marlin.MarlinConst.DO_CLEAN_DIRTY;\n+import static com.sun.marlin.MarlinConst.DO_LOG_WIDEN_ARRAY;\n+import static com.sun.marlin.MarlinConst.DO_LOG_OVERSIZE;\n+\n+import static com.sun.marlin.MarlinUtils.logInfo;\n+import static com.sun.marlin.MarlinUtils.logException;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Arrays;\n+\n+import com.sun.marlin.ArrayCacheConst.BucketStats;\n+import com.sun.marlin.ArrayCacheConst.CacheStats;\n+\n+\/*\n+ * Note that the ArrayCache[BYTE\/INT\/FLOAT\/DOUBLE] files are nearly identical except\n+ * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n+ * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n+ * files are generated with the following command lines:\n+ *\/\n+\n+public final class ArrayCacheByte {\n+\n+    \/* members *\/\n+    private final int bucketCapacity;\n+    private WeakReference<Bucket[]> refBuckets = null;\n+    final CacheStats stats;\n+\n+    ArrayCacheByte(final int bucketCapacity) {\n+        this.bucketCapacity = bucketCapacity;\n+        this.stats = (DO_STATS) ?\n+            new CacheStats(\"ArrayCacheByte(Dirty)\") : null;\n+    }\n+\n+    Bucket getCacheBucket(final int length) {\n+        final int bucket = ArrayCacheConst.getBucket(length);\n+        return getBuckets()[bucket];\n+    }\n+\n+    private Bucket[] getBuckets() {\n+        \/\/ resolve reference:\n+        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n+\n+        \/\/ create a new buckets ?\n+        if (buckets == null) {\n+            buckets = new Bucket[BUCKETS];\n+\n+            for (int i = 0; i < BUCKETS; i++) {\n+                buckets[i] = new Bucket(ARRAY_SIZES[i], bucketCapacity,\n+                        (DO_STATS) ? stats.bucketStats[i] : null);\n+            }\n+\n+            \/\/ update weak reference:\n+            refBuckets = new WeakReference<>(buckets);\n+        }\n+        return buckets;\n+    }\n+\n+    Reference createRef(final int initialSize) {\n+        return new Reference(this, initialSize);\n+    }\n+\n+    static final class Reference {\n+\n+        \/\/ initial array reference (direct access)\n+        final byte[] initial;\n+        private final ArrayCacheByte cache;\n+\n+        Reference(final ArrayCacheByte cache, final int initialSize) {\n+            this.cache = cache;\n+            this.initial = createArray(initialSize);\n+            if (DO_STATS) {\n+                cache.stats.totalInitial += initialSize;\n+            }\n+        }\n+\n+        byte[] getArray(final int length) {\n+            if (length <= MAX_ARRAY_SIZE) {\n+                return cache.getCacheBucket(length).getArray();\n+            }\n+            if (DO_STATS) {\n+                cache.stats.oversize++;\n+            }\n+            if (DO_LOG_OVERSIZE) {\n+                logInfo(\"ArrayCacheByte(Dirty): \"\n+                        + \"getArray[oversize]: length=\\t\" + length);\n+            }\n+            return createArray(length);\n+        }\n+\n+        byte[] widenArray(final byte[] array, final int usedSize,\n+                          final int needSize)\n+        {\n+            final int length = array.length;\n+            if (DO_CHECKS && length >= needSize) {\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                cache.stats.resize++;\n+            }\n+\n+            \/\/ maybe change bucket:\n+            \/\/ ensure getNewSize() > newSize:\n+            final byte[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n+\n+            \/\/ use wrapper to ensure proper copy:\n+            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n+\n+            \/\/ maybe return current array:\n+            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n+\n+            if (DO_LOG_WIDEN_ARRAY) {\n+                logInfo(\"ArrayCacheByte(Dirty): \"\n+                        + \"widenArray[\" + res.length\n+                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n+                        + \"\\tneeded length=\\t\" + needSize);\n+            }\n+            return res;\n+        }\n+\n+        boolean doCleanRef(final byte[] array) {\n+            return DO_CLEAN_DIRTY || (array != initial);\n+        }\n+\n+        byte[] putArray(final byte[] array)\n+        {\n+            \/\/ dirty array helper:\n+            return putArray(array, 0, array.length);\n+        }\n+\n+        byte[] putArray(final byte[] array, final int fromIndex,\n+                        final int toIndex)\n+        {\n+            if (array.length <= MAX_ARRAY_SIZE) {\n+                if (DO_CLEAN_DIRTY && (toIndex != 0)) {\n+                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n+                    fill(array, fromIndex, toIndex, (byte)0);\n+                }\n+                \/\/ ensure to never store initial arrays in cache:\n+                if (array != initial) {\n+                    cache.getCacheBucket(array.length).putArray(array);\n+                }\n+            }\n+            return initial;\n+        }\n+    }\n+\n+    static final class Bucket {\n+\n+        private int tail = 0;\n+        private final int arraySize;\n+        private final byte[][] arrays;\n+        private final BucketStats stats;\n+\n+        Bucket(final int arraySize,\n+               final int capacity, final BucketStats stats)\n+        {\n+            this.arraySize = arraySize;\n+            this.stats = stats;\n+            this.arrays = new byte[capacity][];\n+        }\n+\n+        byte[] getArray() {\n+            if (DO_STATS) {\n+                stats.getOp++;\n+            }\n+            \/\/ use cache:\n+            if (tail != 0) {\n+                final byte[] array = arrays[--tail];\n+                arrays[tail] = null;\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                stats.createOp++;\n+            }\n+            return createArray(arraySize);\n+        }\n+\n+        void putArray(final byte[] array)\n+        {\n+            if (DO_CHECKS && (array.length != arraySize)) {\n+                logInfo(\"ArrayCacheByte(Dirty): \"\n+                        + \"bad length = \" + array.length);\n+                return;\n+            }\n+            if (DO_STATS) {\n+                stats.returnOp++;\n+            }\n+            \/\/ fill cache:\n+            if (arrays.length > tail) {\n+                arrays[tail++] = array;\n+\n+                if (DO_STATS) {\n+                    stats.updateMaxSize(tail);\n+                }\n+            } else if (DO_CHECKS) {\n+                logInfo(\"ArrayCacheByte(Dirty): \"\n+                        + \"array capacity exceeded !\");\n+            }\n+        }\n+    }\n+\n+    static byte[] createArray(final int length) {\n+        return new byte[length];\n+    }\n+\n+    static void fill(final byte[] array, final int fromIndex,\n+                     final int toIndex, final byte value)\n+    {\n+        \/\/ clear array data:\n+        Arrays.fill(array, fromIndex, toIndex, value);\n+        if (DO_CHECKS) {\n+            check(array, fromIndex, toIndex, value);\n+        }\n+    }\n+\n+    static void check(final byte[] array, final int fromIndex,\n+                      final int toIndex, final byte value)\n+    {\n+        if (DO_CHECKS) {\n+            \/\/ check zero on full array:\n+            for (int i = 0; i < array.length; i++) {\n+                if (array[i] != value) {\n+                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n+                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n+                            + Arrays.toString(array), new Throwable());\n+\n+                    \/\/ ensure array is correctly filled:\n+                    Arrays.fill(array, value);\n+\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/ArrayCacheByte.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.marlin;\n+\n+import static com.sun.marlin.ArrayCacheConst.ARRAY_SIZES;\n+import static com.sun.marlin.ArrayCacheConst.BUCKETS;\n+import static com.sun.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n+\n+import static com.sun.marlin.MarlinConst.DO_STATS;\n+import static com.sun.marlin.MarlinConst.DO_CHECKS;\n+import static com.sun.marlin.MarlinConst.DO_CLEAN_DIRTY;\n+import static com.sun.marlin.MarlinConst.DO_LOG_WIDEN_ARRAY;\n+import static com.sun.marlin.MarlinConst.DO_LOG_OVERSIZE;\n+\n+import static com.sun.marlin.MarlinUtils.logInfo;\n+import static com.sun.marlin.MarlinUtils.logException;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Arrays;\n+\n+import com.sun.marlin.ArrayCacheConst.BucketStats;\n+import com.sun.marlin.ArrayCacheConst.CacheStats;\n+\n+\/*\n+ * Note that the ArrayCache[BYTE\/INT\/FLOAT\/DOUBLE] files are nearly identical except\n+ * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n+ * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n+ * files are generated with the following command lines:\n+ *\/\n+\n+public final class ArrayCacheDouble {\n+\n+    \/* members *\/\n+    private final int bucketCapacity;\n+    private WeakReference<Bucket[]> refBuckets = null;\n+    final CacheStats stats;\n+\n+    ArrayCacheDouble(final int bucketCapacity) {\n+        this.bucketCapacity = bucketCapacity;\n+        this.stats = (DO_STATS) ?\n+            new CacheStats(\"ArrayCacheDouble(Dirty)\") : null;\n+    }\n+\n+    Bucket getCacheBucket(final int length) {\n+        final int bucket = ArrayCacheConst.getBucket(length);\n+        return getBuckets()[bucket];\n+    }\n+\n+    private Bucket[] getBuckets() {\n+        \/\/ resolve reference:\n+        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n+\n+        \/\/ create a new buckets ?\n+        if (buckets == null) {\n+            buckets = new Bucket[BUCKETS];\n+\n+            for (int i = 0; i < BUCKETS; i++) {\n+                buckets[i] = new Bucket(ARRAY_SIZES[i], bucketCapacity,\n+                        (DO_STATS) ? stats.bucketStats[i] : null);\n+            }\n+\n+            \/\/ update weak reference:\n+            refBuckets = new WeakReference<>(buckets);\n+        }\n+        return buckets;\n+    }\n+\n+    Reference createRef(final int initialSize) {\n+        return new Reference(this, initialSize);\n+    }\n+\n+    static final class Reference {\n+\n+        \/\/ initial array reference (direct access)\n+        final double[] initial;\n+        private final ArrayCacheDouble cache;\n+\n+        Reference(final ArrayCacheDouble cache, final int initialSize) {\n+            this.cache = cache;\n+            this.initial = createArray(initialSize);\n+            if (DO_STATS) {\n+                cache.stats.totalInitial += initialSize;\n+            }\n+        }\n+\n+        double[] getArray(final int length) {\n+            if (length <= MAX_ARRAY_SIZE) {\n+                return cache.getCacheBucket(length).getArray();\n+            }\n+            if (DO_STATS) {\n+                cache.stats.oversize++;\n+            }\n+            if (DO_LOG_OVERSIZE) {\n+                logInfo(\"ArrayCacheDouble(Dirty): \"\n+                        + \"getArray[oversize]: length=\\t\" + length);\n+            }\n+            return createArray(length);\n+        }\n+\n+        double[] widenArray(final double[] array, final int usedSize,\n+                          final int needSize)\n+        {\n+            final int length = array.length;\n+            if (DO_CHECKS && length >= needSize) {\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                cache.stats.resize++;\n+            }\n+\n+            \/\/ maybe change bucket:\n+            \/\/ ensure getNewSize() > newSize:\n+            final double[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n+\n+            \/\/ use wrapper to ensure proper copy:\n+            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n+\n+            \/\/ maybe return current array:\n+            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n+\n+            if (DO_LOG_WIDEN_ARRAY) {\n+                logInfo(\"ArrayCacheDouble(Dirty): \"\n+                        + \"widenArray[\" + res.length\n+                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n+                        + \"\\tneeded length=\\t\" + needSize);\n+            }\n+            return res;\n+        }\n+\n+        boolean doCleanRef(final double[] array) {\n+            return DO_CLEAN_DIRTY || (array != initial);\n+        }\n+\n+        double[] putArray(final double[] array)\n+        {\n+            \/\/ dirty array helper:\n+            return putArray(array, 0, array.length);\n+        }\n+\n+        double[] putArray(final double[] array, final int fromIndex,\n+                        final int toIndex)\n+        {\n+            if (array.length <= MAX_ARRAY_SIZE) {\n+                if (DO_CLEAN_DIRTY && (toIndex != 0)) {\n+                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n+                    fill(array, fromIndex, toIndex, 0.0d);\n+                }\n+                \/\/ ensure to never store initial arrays in cache:\n+                if (array != initial) {\n+                    cache.getCacheBucket(array.length).putArray(array);\n+                }\n+            }\n+            return initial;\n+        }\n+    }\n+\n+    static final class Bucket {\n+\n+        private int tail = 0;\n+        private final int arraySize;\n+        private final double[][] arrays;\n+        private final BucketStats stats;\n+\n+        Bucket(final int arraySize,\n+               final int capacity, final BucketStats stats)\n+        {\n+            this.arraySize = arraySize;\n+            this.stats = stats;\n+            this.arrays = new double[capacity][];\n+        }\n+\n+        double[] getArray() {\n+            if (DO_STATS) {\n+                stats.getOp++;\n+            }\n+            \/\/ use cache:\n+            if (tail != 0) {\n+                final double[] array = arrays[--tail];\n+                arrays[tail] = null;\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                stats.createOp++;\n+            }\n+            return createArray(arraySize);\n+        }\n+\n+        void putArray(final double[] array)\n+        {\n+            if (DO_CHECKS && (array.length != arraySize)) {\n+                logInfo(\"ArrayCacheDouble(Dirty): \"\n+                        + \"bad length = \" + array.length);\n+                return;\n+            }\n+            if (DO_STATS) {\n+                stats.returnOp++;\n+            }\n+            \/\/ fill cache:\n+            if (arrays.length > tail) {\n+                arrays[tail++] = array;\n+\n+                if (DO_STATS) {\n+                    stats.updateMaxSize(tail);\n+                }\n+            } else if (DO_CHECKS) {\n+                logInfo(\"ArrayCacheDouble(Dirty): \"\n+                        + \"array capacity exceeded !\");\n+            }\n+        }\n+    }\n+\n+    static double[] createArray(final int length) {\n+        return new double[length];\n+    }\n+\n+    static void fill(final double[] array, final int fromIndex,\n+                     final int toIndex, final double value)\n+    {\n+        \/\/ clear array data:\n+        Arrays.fill(array, fromIndex, toIndex, value);\n+        if (DO_CHECKS) {\n+            check(array, fromIndex, toIndex, value);\n+        }\n+    }\n+\n+    static void check(final double[] array, final int fromIndex,\n+                      final int toIndex, final double value)\n+    {\n+        if (DO_CHECKS) {\n+            \/\/ check zero on full array:\n+            for (int i = 0; i < array.length; i++) {\n+                if (array[i] != value) {\n+                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n+                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n+                            + Arrays.toString(array), new Throwable());\n+\n+                    \/\/ ensure array is correctly filled:\n+                    Arrays.fill(array, value);\n+\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/ArrayCacheDouble.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.marlin;\n+\n+import static com.sun.marlin.ArrayCacheConst.ARRAY_SIZES;\n+import static com.sun.marlin.ArrayCacheConst.BUCKETS;\n+import static com.sun.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n+\n+import static com.sun.marlin.MarlinConst.DO_STATS;\n+import static com.sun.marlin.MarlinConst.DO_CHECKS;\n+import static com.sun.marlin.MarlinConst.DO_CLEAN_DIRTY;\n+import static com.sun.marlin.MarlinConst.DO_LOG_WIDEN_ARRAY;\n+import static com.sun.marlin.MarlinConst.DO_LOG_OVERSIZE;\n+\n+import static com.sun.marlin.MarlinUtils.logInfo;\n+import static com.sun.marlin.MarlinUtils.logException;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Arrays;\n+\n+import com.sun.marlin.ArrayCacheConst.BucketStats;\n+import com.sun.marlin.ArrayCacheConst.CacheStats;\n+\n+\/*\n+ * Note that the ArrayCache[BYTE\/INT\/FLOAT\/DOUBLE] files are nearly identical except\n+ * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n+ * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n+ * files are generated with the following command lines:\n+ *\/\n+\n+public final class ArrayCacheInt {\n+\n+    \/* members *\/\n+    private final int bucketCapacity;\n+    private WeakReference<Bucket[]> refBuckets = null;\n+    final CacheStats stats;\n+\n+    ArrayCacheInt(final int bucketCapacity) {\n+        this.bucketCapacity = bucketCapacity;\n+        this.stats = (DO_STATS) ?\n+            new CacheStats(\"ArrayCacheInt(Dirty)\") : null;\n+    }\n+\n+    Bucket getCacheBucket(final int length) {\n+        final int bucket = ArrayCacheConst.getBucket(length);\n+        return getBuckets()[bucket];\n+    }\n+\n+    private Bucket[] getBuckets() {\n+        \/\/ resolve reference:\n+        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n+\n+        \/\/ create a new buckets ?\n+        if (buckets == null) {\n+            buckets = new Bucket[BUCKETS];\n+\n+            for (int i = 0; i < BUCKETS; i++) {\n+                buckets[i] = new Bucket(ARRAY_SIZES[i], bucketCapacity,\n+                        (DO_STATS) ? stats.bucketStats[i] : null);\n+            }\n+\n+            \/\/ update weak reference:\n+            refBuckets = new WeakReference<>(buckets);\n+        }\n+        return buckets;\n+    }\n+\n+    Reference createRef(final int initialSize) {\n+        return new Reference(this, initialSize);\n+    }\n+\n+    static final class Reference {\n+\n+        \/\/ initial array reference (direct access)\n+        final int[] initial;\n+        private final ArrayCacheInt cache;\n+\n+        Reference(final ArrayCacheInt cache, final int initialSize) {\n+            this.cache = cache;\n+            this.initial = createArray(initialSize);\n+            if (DO_STATS) {\n+                cache.stats.totalInitial += initialSize;\n+            }\n+        }\n+\n+        int[] getArray(final int length) {\n+            if (length <= MAX_ARRAY_SIZE) {\n+                return cache.getCacheBucket(length).getArray();\n+            }\n+            if (DO_STATS) {\n+                cache.stats.oversize++;\n+            }\n+            if (DO_LOG_OVERSIZE) {\n+                logInfo(\"ArrayCacheInt(Dirty): \"\n+                        + \"getArray[oversize]: length=\\t\" + length);\n+            }\n+            return createArray(length);\n+        }\n+\n+        int[] widenArray(final int[] array, final int usedSize,\n+                          final int needSize)\n+        {\n+            final int length = array.length;\n+            if (DO_CHECKS && length >= needSize) {\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                cache.stats.resize++;\n+            }\n+\n+            \/\/ maybe change bucket:\n+            \/\/ ensure getNewSize() > newSize:\n+            final int[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n+\n+            \/\/ use wrapper to ensure proper copy:\n+            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n+\n+            \/\/ maybe return current array:\n+            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n+\n+            if (DO_LOG_WIDEN_ARRAY) {\n+                logInfo(\"ArrayCacheInt(Dirty): \"\n+                        + \"widenArray[\" + res.length\n+                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n+                        + \"\\tneeded length=\\t\" + needSize);\n+            }\n+            return res;\n+        }\n+\n+        boolean doCleanRef(final int[] array) {\n+            return DO_CLEAN_DIRTY || (array != initial);\n+        }\n+\n+        int[] putArray(final int[] array)\n+        {\n+            \/\/ dirty array helper:\n+            return putArray(array, 0, array.length);\n+        }\n+\n+        int[] putArray(final int[] array, final int fromIndex,\n+                        final int toIndex)\n+        {\n+            if (array.length <= MAX_ARRAY_SIZE) {\n+                if (DO_CLEAN_DIRTY && (toIndex != 0)) {\n+                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n+                    fill(array, fromIndex, toIndex, 0);\n+                }\n+                \/\/ ensure to never store initial arrays in cache:\n+                if (array != initial) {\n+                    cache.getCacheBucket(array.length).putArray(array);\n+                }\n+            }\n+            return initial;\n+        }\n+    }\n+\n+    static final class Bucket {\n+\n+        private int tail = 0;\n+        private final int arraySize;\n+        private final int[][] arrays;\n+        private final BucketStats stats;\n+\n+        Bucket(final int arraySize,\n+               final int capacity, final BucketStats stats)\n+        {\n+            this.arraySize = arraySize;\n+            this.stats = stats;\n+            this.arrays = new int[capacity][];\n+        }\n+\n+        int[] getArray() {\n+            if (DO_STATS) {\n+                stats.getOp++;\n+            }\n+            \/\/ use cache:\n+            if (tail != 0) {\n+                final int[] array = arrays[--tail];\n+                arrays[tail] = null;\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                stats.createOp++;\n+            }\n+            return createArray(arraySize);\n+        }\n+\n+        void putArray(final int[] array)\n+        {\n+            if (DO_CHECKS && (array.length != arraySize)) {\n+                logInfo(\"ArrayCacheInt(Dirty): \"\n+                        + \"bad length = \" + array.length);\n+                return;\n+            }\n+            if (DO_STATS) {\n+                stats.returnOp++;\n+            }\n+            \/\/ fill cache:\n+            if (arrays.length > tail) {\n+                arrays[tail++] = array;\n+\n+                if (DO_STATS) {\n+                    stats.updateMaxSize(tail);\n+                }\n+            } else if (DO_CHECKS) {\n+                logInfo(\"ArrayCacheInt(Dirty): \"\n+                        + \"array capacity exceeded !\");\n+            }\n+        }\n+    }\n+\n+    static int[] createArray(final int length) {\n+        return new int[length];\n+    }\n+\n+    static void fill(final int[] array, final int fromIndex,\n+                     final int toIndex, final int value)\n+    {\n+        \/\/ clear array data:\n+        Arrays.fill(array, fromIndex, toIndex, value);\n+        if (DO_CHECKS) {\n+            check(array, fromIndex, toIndex, value);\n+        }\n+    }\n+\n+    static void check(final int[] array, final int fromIndex,\n+                      final int toIndex, final int value)\n+    {\n+        if (DO_CHECKS) {\n+            \/\/ check zero on full array:\n+            for (int i = 0; i < array.length; i++) {\n+                if (array[i] != value) {\n+                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n+                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n+                            + Arrays.toString(array), new Throwable());\n+\n+                    \/\/ ensure array is correctly filled:\n+                    Arrays.fill(array, value);\n+\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/ArrayCacheInt.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.marlin;\n+\n+import static com.sun.marlin.ArrayCacheConst.ARRAY_SIZES;\n+import static com.sun.marlin.ArrayCacheConst.BUCKETS;\n+import static com.sun.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n+\n+import static com.sun.marlin.MarlinConst.DO_STATS;\n+import static com.sun.marlin.MarlinConst.DO_CHECKS;\n+import static com.sun.marlin.MarlinConst.DO_LOG_WIDEN_ARRAY;\n+import static com.sun.marlin.MarlinConst.DO_LOG_OVERSIZE;\n+\n+import static com.sun.marlin.MarlinUtils.logInfo;\n+import static com.sun.marlin.MarlinUtils.logException;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Arrays;\n+\n+import com.sun.marlin.ArrayCacheConst.BucketStats;\n+import com.sun.marlin.ArrayCacheConst.CacheStats;\n+\n+\/*\n+ * Note that the ArrayCache[BYTE\/INT\/FLOAT\/DOUBLE] files are nearly identical except\n+ * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n+ * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n+ * files are generated with the following command lines:\n+ *\/\n+\n+public final class ArrayCacheIntClean {\n+\n+    \/* members *\/\n+    private final int bucketCapacity;\n+    private WeakReference<Bucket[]> refBuckets = null;\n+    final CacheStats stats;\n+\n+    ArrayCacheIntClean(final int bucketCapacity) {\n+        this.bucketCapacity = bucketCapacity;\n+        this.stats = (DO_STATS) ?\n+            new CacheStats(\"ArrayCacheInt(Clean)\") : null;\n+    }\n+\n+    Bucket getCacheBucket(final int length) {\n+        final int bucket = ArrayCacheConst.getBucket(length);\n+        return getBuckets()[bucket];\n+    }\n+\n+    private Bucket[] getBuckets() {\n+        \/\/ resolve reference:\n+        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n+\n+        \/\/ create a new buckets ?\n+        if (buckets == null) {\n+            buckets = new Bucket[BUCKETS];\n+\n+            for (int i = 0; i < BUCKETS; i++) {\n+                buckets[i] = new Bucket(ARRAY_SIZES[i], bucketCapacity,\n+                        (DO_STATS) ? stats.bucketStats[i] : null);\n+            }\n+\n+            \/\/ update weak reference:\n+            refBuckets = new WeakReference<>(buckets);\n+        }\n+        return buckets;\n+    }\n+\n+    Reference createRef(final int initialSize) {\n+        return new Reference(this, initialSize);\n+    }\n+\n+    static final class Reference {\n+\n+        \/\/ initial array reference (direct access)\n+        final int[] initial;\n+        private final ArrayCacheIntClean cache;\n+\n+        Reference(final ArrayCacheIntClean cache, final int initialSize) {\n+            this.cache = cache;\n+            this.initial = createArray(initialSize);\n+            if (DO_STATS) {\n+                cache.stats.totalInitial += initialSize;\n+            }\n+        }\n+\n+        int[] getArray(final int length) {\n+            if (length <= MAX_ARRAY_SIZE) {\n+                return cache.getCacheBucket(length).getArray();\n+            }\n+            if (DO_STATS) {\n+                cache.stats.oversize++;\n+            }\n+            if (DO_LOG_OVERSIZE) {\n+                logInfo(\"ArrayCacheInt(Clean): \"\n+                        + \"getArray[oversize]: length=\\t\" + length);\n+            }\n+            return createArray(length);\n+        }\n+\n+        int[] widenArray(final int[] array, final int usedSize,\n+                          final int needSize)\n+        {\n+            final int length = array.length;\n+            if (DO_CHECKS && length >= needSize) {\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                cache.stats.resize++;\n+            }\n+\n+            \/\/ maybe change bucket:\n+            \/\/ ensure getNewSize() > newSize:\n+            final int[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n+\n+            \/\/ use wrapper to ensure proper copy:\n+            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n+\n+            \/\/ maybe return current array:\n+            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n+\n+            if (DO_LOG_WIDEN_ARRAY) {\n+                logInfo(\"ArrayCacheInt(Clean): \"\n+                        + \"widenArray[\" + res.length\n+                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n+                        + \"\\tneeded length=\\t\" + needSize);\n+            }\n+            return res;\n+        }\n+\n+        boolean doSetRef(final int[] array) {\n+            return (array != initial);\n+        }\n+\n+        int[] putArrayClean(final int[] array)\n+        {\n+            \/\/ must be protected by doSetRef() call !\n+            if (array.length <= MAX_ARRAY_SIZE) {\n+                \/\/ ensure to never store initial arrays in cache:\n+                cache.getCacheBucket(array.length).putArray(array);\n+            }\n+            return initial;\n+        }\n+\n+        int[] putArray(final int[] array, final int fromIndex,\n+                        final int toIndex)\n+        {\n+            if (array.length <= MAX_ARRAY_SIZE) {\n+                if (toIndex != 0) {\n+                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n+                    fill(array, fromIndex, toIndex, 0);\n+                }\n+                \/\/ ensure to never store initial arrays in cache:\n+                if (array != initial) {\n+                    cache.getCacheBucket(array.length).putArray(array);\n+                }\n+            }\n+            return initial;\n+        }\n+    }\n+\n+    static final class Bucket {\n+\n+        private int tail = 0;\n+        private final int arraySize;\n+        private final int[][] arrays;\n+        private final BucketStats stats;\n+\n+        Bucket(final int arraySize,\n+               final int capacity, final BucketStats stats)\n+        {\n+            this.arraySize = arraySize;\n+            this.stats = stats;\n+            this.arrays = new int[capacity][];\n+        }\n+\n+        int[] getArray() {\n+            if (DO_STATS) {\n+                stats.getOp++;\n+            }\n+            \/\/ use cache:\n+            if (tail != 0) {\n+                final int[] array = arrays[--tail];\n+                arrays[tail] = null;\n+                return array;\n+            }\n+            if (DO_STATS) {\n+                stats.createOp++;\n+            }\n+            return createArray(arraySize);\n+        }\n+\n+        void putArray(final int[] array)\n+        {\n+            if (DO_CHECKS && (array.length != arraySize)) {\n+                logInfo(\"ArrayCacheInt(Clean): \"\n+                        + \"bad length = \" + array.length);\n+                return;\n+            }\n+            if (DO_STATS) {\n+                stats.returnOp++;\n+            }\n+            \/\/ fill cache:\n+            if (arrays.length > tail) {\n+                arrays[tail++] = array;\n+\n+                if (DO_STATS) {\n+                    stats.updateMaxSize(tail);\n+                }\n+            } else if (DO_CHECKS) {\n+                logInfo(\"ArrayCacheInt(Clean): \"\n+                        + \"array capacity exceeded !\");\n+            }\n+        }\n+    }\n+\n+    static int[] createArray(final int length) {\n+        return new int[length];\n+    }\n+\n+    static void fill(final int[] array, final int fromIndex,\n+                     final int toIndex, final int value)\n+    {\n+        \/\/ clear array data:\n+        Arrays.fill(array, fromIndex, toIndex, value);\n+        if (DO_CHECKS) {\n+            check(array, fromIndex, toIndex, value);\n+        }\n+    }\n+\n+    public static void check(final int[] array, final int fromIndex,\n+                      final int toIndex, final int value)\n+    {\n+        if (DO_CHECKS) {\n+            \/\/ check zero on full array:\n+            for (int i = 0; i < array.length; i++) {\n+                if (array[i] != value) {\n+                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n+                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n+                            + Arrays.toString(array), new Throwable());\n+\n+                    \/\/ ensure array is correctly filled:\n+                    Arrays.fill(array, value);\n+\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/ArrayCacheIntClean.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -1,269 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.marlin;\n-\n-import static com.sun.marlin.ArrayCacheConst.ARRAY_SIZES;\n-import static com.sun.marlin.ArrayCacheConst.BUCKETS;\n-import static com.sun.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n-import static com.sun.marlin.MarlinUtils.logInfo;\n-import static com.sun.marlin.MarlinUtils.logException;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Arrays;\n-\n-import com.sun.marlin.ArrayCacheConst.BucketStats;\n-import com.sun.marlin.ArrayCacheConst.CacheStats;\n-\n-\/*\n- * Note that the [BYTE\/INT\/FLOAT\/DOUBLE]ArrayCache files are nearly identical except\n- * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n- * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n- * files are generated with the following command lines:\n- *\/\n-\/\/ % sed -e 's\/(b\\yte)[ ]*\/\/g' -e 's\/b\\yte\/int\/g' -e 's\/B\\yte\/Int\/g' < B\\yteArrayCache.java > IntArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0f\/g' -e 's\/(b\\yte)[ ]*\/(float) \/g' -e 's\/b\\yte\/float\/g' -e 's\/B\\yte\/Float\/g' < B\\yteArrayCache.java > FloatArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0d\/g' -e 's\/(b\\yte)[ ]*\/(double) \/g' -e 's\/b\\yte\/double\/g' -e 's\/B\\yte\/Double\/g' < B\\yteArrayCache.java > DoubleArrayCache.java\n-\n-public final class ByteArrayCache implements MarlinConst {\n-\n-    final boolean clean;\n-    private final int bucketCapacity;\n-    private WeakReference<Bucket[]> refBuckets = null;\n-    final CacheStats stats;\n-\n-    ByteArrayCache(final boolean clean, final int bucketCapacity) {\n-        this.clean = clean;\n-        this.bucketCapacity = bucketCapacity;\n-        this.stats = (DO_STATS) ?\n-            new CacheStats(getLogPrefix(clean) + \"ByteArrayCache\") : null;\n-    }\n-\n-    Bucket getCacheBucket(final int length) {\n-        final int bucket = ArrayCacheConst.getBucket(length);\n-        return getBuckets()[bucket];\n-    }\n-\n-    private Bucket[] getBuckets() {\n-        \/\/ resolve reference:\n-        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n-\n-        \/\/ create a new buckets ?\n-        if (buckets == null) {\n-            buckets = new Bucket[BUCKETS];\n-\n-            for (int i = 0; i < BUCKETS; i++) {\n-                buckets[i] = new Bucket(clean, ARRAY_SIZES[i], bucketCapacity,\n-                        (DO_STATS) ? stats.bucketStats[i] : null);\n-            }\n-\n-            \/\/ update weak reference:\n-            refBuckets = new WeakReference<Bucket[]>(buckets);\n-        }\n-        return buckets;\n-    }\n-\n-    Reference createRef(final int initialSize) {\n-        return new Reference(this, initialSize);\n-    }\n-\n-    static final class Reference {\n-\n-        \/\/ initial array reference (direct access)\n-        final byte[] initial;\n-        private final boolean clean;\n-        private final ByteArrayCache cache;\n-\n-        Reference(final ByteArrayCache cache, final int initialSize) {\n-            this.cache = cache;\n-            this.clean = cache.clean;\n-            this.initial = createArray(initialSize);\n-            if (DO_STATS) {\n-                cache.stats.totalInitial += initialSize;\n-            }\n-        }\n-\n-        byte[] getArray(final int length) {\n-            if (length <= MAX_ARRAY_SIZE) {\n-                return cache.getCacheBucket(length).getArray();\n-            }\n-            if (DO_STATS) {\n-                cache.stats.oversize++;\n-            }\n-            if (DO_LOG_OVERSIZE) {\n-                logInfo(getLogPrefix(clean) + \"ByteArrayCache: \"\n-                        + \"getArray[oversize]: length=\\t\" + length);\n-            }\n-            return createArray(length);\n-        }\n-\n-        byte[] widenArray(final byte[] array, final int usedSize,\n-                          final int needSize)\n-        {\n-            final int length = array.length;\n-            if (DO_CHECKS && length >= needSize) {\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                cache.stats.resize++;\n-            }\n-\n-            \/\/ maybe change bucket:\n-            \/\/ ensure getNewSize() > newSize:\n-            final byte[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n-\n-            \/\/ use wrapper to ensure proper copy:\n-            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n-\n-            \/\/ maybe return current array:\n-            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n-\n-            if (DO_LOG_WIDEN_ARRAY) {\n-                logInfo(getLogPrefix(clean) + \"ByteArrayCache: \"\n-                        + \"widenArray[\" + res.length\n-                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n-                        + \"\\tneeded length=\\t\" + needSize);\n-            }\n-            return res;\n-        }\n-\n-        byte[] putArray(final byte[] array)\n-        {\n-            \/\/ dirty array helper:\n-            return putArray(array, 0, array.length);\n-        }\n-\n-        byte[] putArray(final byte[] array, final int fromIndex,\n-                        final int toIndex)\n-        {\n-            if (array.length <= MAX_ARRAY_SIZE) {\n-                if ((clean || DO_CLEAN_DIRTY) && (toIndex != 0)) {\n-                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n-                    fill(array, fromIndex, toIndex, (byte)0);\n-                }\n-                \/\/ ensure to never store initial arrays in cache:\n-                if (array != initial) {\n-                    cache.getCacheBucket(array.length).putArray(array);\n-                }\n-            }\n-            return initial;\n-        }\n-    }\n-\n-    static final class Bucket {\n-\n-        private int tail = 0;\n-        private final int arraySize;\n-        private final boolean clean;\n-        private final byte[][] arrays;\n-        private final BucketStats stats;\n-\n-        Bucket(final boolean clean, final int arraySize,\n-               final int capacity, final BucketStats stats)\n-        {\n-            this.arraySize = arraySize;\n-            this.clean = clean;\n-            this.stats = stats;\n-            this.arrays = new byte[capacity][];\n-        }\n-\n-        byte[] getArray() {\n-            if (DO_STATS) {\n-                stats.getOp++;\n-            }\n-            \/\/ use cache:\n-            if (tail != 0) {\n-                final byte[] array = arrays[--tail];\n-                arrays[tail] = null;\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                stats.createOp++;\n-            }\n-            return createArray(arraySize);\n-        }\n-\n-        void putArray(final byte[] array)\n-        {\n-            if (DO_CHECKS && (array.length != arraySize)) {\n-                logInfo(getLogPrefix(clean) + \"ByteArrayCache: \"\n-                        + \"bad length = \" + array.length);\n-                return;\n-            }\n-            if (DO_STATS) {\n-                stats.returnOp++;\n-            }\n-            \/\/ fill cache:\n-            if (arrays.length > tail) {\n-                arrays[tail++] = array;\n-\n-                if (DO_STATS) {\n-                    stats.updateMaxSize(tail);\n-                }\n-            } else if (DO_CHECKS) {\n-                logInfo(getLogPrefix(clean) + \"ByteArrayCache: \"\n-                        + \"array capacity exceeded !\");\n-            }\n-        }\n-    }\n-\n-    static byte[] createArray(final int length) {\n-        return new byte[length];\n-    }\n-\n-    static void fill(final byte[] array, final int fromIndex,\n-                     final int toIndex, final byte value)\n-    {\n-        \/\/ clear array data:\n-        Arrays.fill(array, fromIndex, toIndex, value);\n-        if (DO_CHECKS) {\n-            check(array, fromIndex, toIndex, value);\n-        }\n-    }\n-\n-    public static void check(final byte[] array, final int fromIndex,\n-                             final int toIndex, final byte value)\n-    {\n-        if (DO_CHECKS) {\n-            \/\/ check zero on full array:\n-            for (int i = 0; i < array.length; i++) {\n-                if (array[i] != value) {\n-                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n-                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n-                            + Arrays.toString(array), new Throwable());\n-\n-                    \/\/ ensure array is correctly filled:\n-                    Arrays.fill(array, value);\n-\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    static String getLogPrefix(final boolean clean) {\n-        return (clean) ? \"Clean\" : \"Dirty\";\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/ByteArrayCache.java","additions":0,"deletions":269,"binary":false,"changes":269,"status":"deleted"},{"patch":"@@ -35,1 +35,2 @@\n-    };\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/CollinearSimplifier.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -193,0 +193,5 @@\n+        logInfo(\"prism.marlin.stroker.joinError= \"\n+                + MarlinProperties.getStrokerJoinError());\n+        logInfo(\"prism.marlin.stroker.joinStyle= \"\n+                + MarlinProperties.getStrokerJoinStyle());\n+\n@@ -211,0 +216,5 @@\n+        logInfo(\"prism.marlin.skip_rdr         = \"\n+                + MarlinProperties.isSkipRenderer());\n+        logInfo(\"prism.marlin.skip_pipe        = \"\n+                + MarlinProperties.isSkipRenderTiles());\n+\n@@ -232,0 +242,1 @@\n+        logInfo(\"SORT         = \" + MergeSort.SORT_TYPE);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/DMarlinRenderingEngine.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation. Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.marlin;\n+\n+\/**\n+ * DPQS Sorter context\n+ *\/\n+final class DPQSSorterContext {\n+\n+    static final boolean LOG_ALLOC = false;\n+    static final boolean CHECK_ALLOC = false && LOG_ALLOC;\n+\n+    \/**\n+     * Max capacity of the index array for tracking runs.\n+     *\/\n+    static final int MAX_RUN_CAPACITY = DualPivotQuicksort20191112Ext.MAX_RUN_CAPACITY;\n+\n+    \/* members *\/\n+    final int[] run;\n+    int[] auxA;\n+    int[] auxB;\n+    boolean runInit;\n+\n+    DPQSSorterContext() {\n+        \/\/ preallocate max runs:\n+        if (LOG_ALLOC) {\n+            MarlinUtils.logInfo(\"alloc run: \" + MAX_RUN_CAPACITY);\n+        }\n+        run = new int[MAX_RUN_CAPACITY];\n+    }\n+\n+    void initBuffers(final int length, final int[] a, final int[] b) {\n+        auxA = a;\n+        if (CHECK_ALLOC && (a.length < length)) {\n+            if (LOG_ALLOC) {\n+                MarlinUtils.logInfo(\"alloc auxA: \" + length);\n+            }\n+            auxA = new int[length];\n+        }\n+        auxB = b;\n+        if (CHECK_ALLOC && (b.length < length)) {\n+            if (LOG_ALLOC) {\n+                MarlinUtils.logInfo(\"alloc auxB: \" + length);\n+            }\n+            auxB = new int[length];\n+        }\n+        runInit = true;\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/DPQSSorterContext.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import com.sun.marlin.TransformingPathConsumer2D.StartFlagPathConsumer2D;\n@@ -43,1 +44,1 @@\n-public final class Dasher implements DPathConsumer2D, MarlinConst {\n+public final class Dasher implements StartFlagPathConsumer2D, MarlinConst {\n@@ -93,1 +94,1 @@\n-    final DoubleArrayCache.Reference dashes_ref;\n+    final ArrayCacheDouble.Reference dashes_ref;\n@@ -95,1 +96,1 @@\n-    final DoubleArrayCache.Reference firstSegmentsBuffer_ref;\n+    final ArrayCacheDouble.Reference firstSegmentsBuffer_ref;\n@@ -226,1 +227,6 @@\n-            dash = dashes_ref.putArray(dash);\n+            if (dashes_ref.doCleanRef(dash)) {\n+                dash = dashes_ref.putArray(dash);\n+            }\n+        }\n+        if (firstSegmentsBuffer_ref.doCleanRef(firstSegmentsBuffer)) {\n+            firstSegmentsBuffer = firstSegmentsBuffer_ref.putArray(firstSegmentsBuffer);\n@@ -228,1 +234,0 @@\n-        firstSegmentsBuffer = firstSegmentsBuffer_ref.putArray(firstSegmentsBuffer);\n@@ -351,0 +356,20 @@\n+    \/* Callback from CurveClipSplitter *\/\n+    @Override\n+    public void setStartFlag(boolean first) {\n+        if (first) {\n+            \/\/ reset flag:\n+            rdrCtx.firstFlags &= 0b011;\n+        } else {\n+            rdrCtx.firstFlags |= 0b100;\n+        }\n+    }\n+\n+    public void setMonotonizerStartFlag(boolean first) {\n+        if (first) {\n+            \/\/ reset flag:\n+            rdrCtx.firstFlags &= 0b101;\n+        } else {\n+            rdrCtx.firstFlags |= 0b010;\n+        }\n+    }\n+\n@@ -541,1 +566,1 @@\n-        if (pointCurve(_curCurvepts, type)) {\n+        if (Helpers.isPointCurve(_curCurvepts, type)) {\n@@ -597,1 +622,1 @@\n-        if (pointCurve(_curCurvepts, type)) {\n+        if (Helpers.isPointCurve(_curCurvepts, type)) {\n@@ -617,9 +642,0 @@\n-    private static boolean pointCurve(final double[] curve, final int type) {\n-        for (int i = 2; i < type; i++) {\n-            if (curve[i] != curve[i-2]) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n@@ -707,1 +723,3 @@\n-            goLeft(); \/\/ initializes nextT and lenAtNextT properly\n+            \/\/ initializes nextT and lenAtNextT properly\n+            goLeft();\n+\n@@ -813,1 +831,1 @@\n-                if (n == 1 && !Double.isNaN(nextRoots[0])) {\n+                if (n == 1) {\n@@ -960,1 +978,0 @@\n-\n@@ -990,0 +1007,5 @@\n+\n+            if (i == 0) {\n+                \/\/ disable start flag:\n+                setMonotonizerStartFlag(false);\n+            }\n@@ -991,0 +1013,2 @@\n+        \/\/ reset start flag:\n+        setMonotonizerStartFlag(true);\n@@ -1046,1 +1070,0 @@\n-\n@@ -1075,0 +1098,5 @@\n+\n+            if (i == 0) {\n+                \/\/ disable start flag:\n+                setMonotonizerStartFlag(false);\n+            }\n@@ -1076,0 +1104,2 @@\n+        \/\/ reset start flag:\n+        setMonotonizerStartFlag(true);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/Dasher.java","additions":50,"deletions":20,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1,269 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.marlin;\n-\n-import static com.sun.marlin.ArrayCacheConst.ARRAY_SIZES;\n-import static com.sun.marlin.ArrayCacheConst.BUCKETS;\n-import static com.sun.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n-import static com.sun.marlin.MarlinUtils.logInfo;\n-import static com.sun.marlin.MarlinUtils.logException;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Arrays;\n-\n-import com.sun.marlin.ArrayCacheConst.BucketStats;\n-import com.sun.marlin.ArrayCacheConst.CacheStats;\n-\n-\/*\n- * Note that the [BYTE\/INT\/FLOAT\/DOUBLE]ArrayCache files are nearly identical except\n- * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n- * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n- * files are generated with the following command lines:\n- *\/\n-\/\/ % sed -e 's\/(b\\yte)[ ]*\/\/g' -e 's\/b\\yte\/int\/g' -e 's\/B\\yte\/Int\/g' < B\\yteArrayCache.java > IntArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0f\/g' -e 's\/(b\\yte)[ ]*\/(float) \/g' -e 's\/b\\yte\/float\/g' -e 's\/B\\yte\/Float\/g' < B\\yteArrayCache.java > FloatArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0d\/g' -e 's\/(b\\yte)[ ]*\/(double) \/g' -e 's\/b\\yte\/double\/g' -e 's\/B\\yte\/Double\/g' < B\\yteArrayCache.java > DoubleArrayCache.java\n-\n-public final class DoubleArrayCache implements MarlinConst {\n-\n-    final boolean clean;\n-    private final int bucketCapacity;\n-    private WeakReference<Bucket[]> refBuckets = null;\n-    final CacheStats stats;\n-\n-    DoubleArrayCache(final boolean clean, final int bucketCapacity) {\n-        this.clean = clean;\n-        this.bucketCapacity = bucketCapacity;\n-        this.stats = (DO_STATS) ?\n-            new CacheStats(getLogPrefix(clean) + \"DoubleArrayCache\") : null;\n-    }\n-\n-    Bucket getCacheBucket(final int length) {\n-        final int bucket = ArrayCacheConst.getBucket(length);\n-        return getBuckets()[bucket];\n-    }\n-\n-    private Bucket[] getBuckets() {\n-        \/\/ resolve reference:\n-        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n-\n-        \/\/ create a new buckets ?\n-        if (buckets == null) {\n-            buckets = new Bucket[BUCKETS];\n-\n-            for (int i = 0; i < BUCKETS; i++) {\n-                buckets[i] = new Bucket(clean, ARRAY_SIZES[i], bucketCapacity,\n-                        (DO_STATS) ? stats.bucketStats[i] : null);\n-            }\n-\n-            \/\/ update weak reference:\n-            refBuckets = new WeakReference<Bucket[]>(buckets);\n-        }\n-        return buckets;\n-    }\n-\n-    Reference createRef(final int initialSize) {\n-        return new Reference(this, initialSize);\n-    }\n-\n-    static final class Reference {\n-\n-        \/\/ initial array reference (direct access)\n-        final double[] initial;\n-        private final boolean clean;\n-        private final DoubleArrayCache cache;\n-\n-        Reference(final DoubleArrayCache cache, final int initialSize) {\n-            this.cache = cache;\n-            this.clean = cache.clean;\n-            this.initial = createArray(initialSize);\n-            if (DO_STATS) {\n-                cache.stats.totalInitial += initialSize;\n-            }\n-        }\n-\n-        double[] getArray(final int length) {\n-            if (length <= MAX_ARRAY_SIZE) {\n-                return cache.getCacheBucket(length).getArray();\n-            }\n-            if (DO_STATS) {\n-                cache.stats.oversize++;\n-            }\n-            if (DO_LOG_OVERSIZE) {\n-                logInfo(getLogPrefix(clean) + \"DoubleArrayCache: \"\n-                        + \"getArray[oversize]: length=\\t\" + length);\n-            }\n-            return createArray(length);\n-        }\n-\n-        double[] widenArray(final double[] array, final int usedSize,\n-                          final int needSize)\n-        {\n-            final int length = array.length;\n-            if (DO_CHECKS && length >= needSize) {\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                cache.stats.resize++;\n-            }\n-\n-            \/\/ maybe change bucket:\n-            \/\/ ensure getNewSize() > newSize:\n-            final double[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n-\n-            \/\/ use wrapper to ensure proper copy:\n-            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n-\n-            \/\/ maybe return current array:\n-            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n-\n-            if (DO_LOG_WIDEN_ARRAY) {\n-                logInfo(getLogPrefix(clean) + \"DoubleArrayCache: \"\n-                        + \"widenArray[\" + res.length\n-                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n-                        + \"\\tneeded length=\\t\" + needSize);\n-            }\n-            return res;\n-        }\n-\n-        double[] putArray(final double[] array)\n-        {\n-            \/\/ dirty array helper:\n-            return putArray(array, 0, array.length);\n-        }\n-\n-        double[] putArray(final double[] array, final int fromIndex,\n-                        final int toIndex)\n-        {\n-            if (array.length <= MAX_ARRAY_SIZE) {\n-                if ((clean || DO_CLEAN_DIRTY) && (toIndex != 0)) {\n-                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n-                    fill(array, fromIndex, toIndex, 0.0d);\n-                }\n-                \/\/ ensure to never store initial arrays in cache:\n-                if (array != initial) {\n-                    cache.getCacheBucket(array.length).putArray(array);\n-                }\n-            }\n-            return initial;\n-        }\n-    }\n-\n-    static final class Bucket {\n-\n-        private int tail = 0;\n-        private final int arraySize;\n-        private final boolean clean;\n-        private final double[][] arrays;\n-        private final BucketStats stats;\n-\n-        Bucket(final boolean clean, final int arraySize,\n-               final int capacity, final BucketStats stats)\n-        {\n-            this.arraySize = arraySize;\n-            this.clean = clean;\n-            this.stats = stats;\n-            this.arrays = new double[capacity][];\n-        }\n-\n-        double[] getArray() {\n-            if (DO_STATS) {\n-                stats.getOp++;\n-            }\n-            \/\/ use cache:\n-            if (tail != 0) {\n-                final double[] array = arrays[--tail];\n-                arrays[tail] = null;\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                stats.createOp++;\n-            }\n-            return createArray(arraySize);\n-        }\n-\n-        void putArray(final double[] array)\n-        {\n-            if (DO_CHECKS && (array.length != arraySize)) {\n-                logInfo(getLogPrefix(clean) + \"DoubleArrayCache: \"\n-                        + \"bad length = \" + array.length);\n-                return;\n-            }\n-            if (DO_STATS) {\n-                stats.returnOp++;\n-            }\n-            \/\/ fill cache:\n-            if (arrays.length > tail) {\n-                arrays[tail++] = array;\n-\n-                if (DO_STATS) {\n-                    stats.updateMaxSize(tail);\n-                }\n-            } else if (DO_CHECKS) {\n-                logInfo(getLogPrefix(clean) + \"DoubleArrayCache: \"\n-                        + \"array capacity exceeded !\");\n-            }\n-        }\n-    }\n-\n-    static double[] createArray(final int length) {\n-        return new double[length];\n-    }\n-\n-    static void fill(final double[] array, final int fromIndex,\n-                     final int toIndex, final double value)\n-    {\n-        \/\/ clear array data:\n-        Arrays.fill(array, fromIndex, toIndex, value);\n-        if (DO_CHECKS) {\n-            check(array, fromIndex, toIndex, value);\n-        }\n-    }\n-\n-    public static void check(final double[] array, final int fromIndex,\n-                             final int toIndex, final double value)\n-    {\n-        if (DO_CHECKS) {\n-            \/\/ check zero on full array:\n-            for (int i = 0; i < array.length; i++) {\n-                if (array[i] != value) {\n-                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n-                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n-                            + Arrays.toString(array), new Throwable());\n-\n-                    \/\/ ensure array is correctly filled:\n-                    Arrays.fill(array, value);\n-\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    static String getLogPrefix(final boolean clean) {\n-        return (clean) ? \"Clean\" : \"Dirty\";\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/DoubleArrayCache.java","additions":0,"deletions":269,"binary":false,"changes":269,"status":"deleted"},{"patch":"@@ -0,0 +1,867 @@\n+\/*\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.marlin;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * This class implements powerful and fully optimized versions, both\n+ * sequential and parallel, of the Dual-Pivot Quicksort algorithm by\n+ * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n+ * offers O(n log(n)) performance on all data sets, and is typically\n+ * faster than traditional (one-pivot) Quicksort implementations.\n+ *\n+ * There are also additional algorithms, invoked from the Dual-Pivot\n+ * Quicksort, such as mixed insertion sort, merging of runs and heap\n+ * sort, counting sort and parallel merge sort.\n+ *\n+ * @author Vladimir Yaroslavskiy\n+ * @author Jon Bentley\n+ * @author Josh Bloch\n+ * @author Doug Lea\n+ *\n+ * @version 2018.08.18\n+ *\n+ * @since 1.7 * 14\n+ *\/\n+public final class DualPivotQuicksort20191112Ext {\n+\n+    private static final boolean FAST_ISORT = false;\n+\n+    \/*\n+    From OpenJDK14 source code:\n+    8226297: Dual-pivot quicksort improvements\n+        Reviewed-by: dl, lbourges\n+        Contributed-by: Vladimir Yaroslavskiy <vlv.spb.ru@mail.ru>\n+        Tue, 12 Nov 2019 13:49:40 -0800\n+     *\/\n+    \/**\n+     * Prevents instantiation.\n+     *\/\n+    private DualPivotQuicksort20191112Ext() {\n+    }\n+\n+    \/**\n+     * Max array size to use mixed insertion sort.\n+     *\/\n+    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 65;\n+\n+    \/**\n+     * Max array size to use insertion sort.\n+     *\/\n+    private static final int MAX_INSERTION_SORT_SIZE = 44;\n+\n+    \/**\n+     * Min array size to try merging of runs.\n+     *\/\n+    private static final int MIN_TRY_MERGE_SIZE = 4 << 10;\n+\n+    \/**\n+     * Min size of the first run to continue with scanning.\n+     *\/\n+    private static final int MIN_FIRST_RUN_SIZE = 16;\n+\n+    \/**\n+     * Min factor for the first runs to continue scanning.\n+     *\/\n+    private static final int MIN_FIRST_RUNS_FACTOR = 7;\n+\n+    \/**\n+     * Max capacity of the index array for tracking runs.\n+     *\/\n+    \/* private *\/ static final int MAX_RUN_CAPACITY = 5 << 10;\n+\n+    \/**\n+     * Threshold of mixed insertion sort is incremented by this value.\n+     *\/\n+    private static final int DELTA = 3 << 1;\n+\n+    \/**\n+     * Max recursive partitioning depth before using heap sort.\n+     *\/\n+    private static final int MAX_RECURSION_DEPTH = 64 * DELTA;\n+\n+\n+    \/**\n+     * Sorts the specified range of the array.\n+     *\n+     * @param a the array to be sorted\n+     * @param b the permutation array to be handled\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort(DPQSSorterContext sorter, int[] a, int[] auxA, int[] b, int[] auxB, int low, int high) {\n+        \/*\n+         * LBO Shortcut: Invoke insertion sort on the leftmost part.\n+         *\/\n+        if (FAST_ISORT && ((high - low) <= 24)) {\n+            insertionSort(a, b, low, high);\n+            return;\n+        }\n+\n+        sorter.initBuffers(high, auxA, auxB);\n+        sort(sorter, a, b, 0, low, high);\n+    }\n+\n+    \/**\n+     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n+     * other sorts in special-cases, possibly with parallel partitions.\n+     *\n+     * @param sorter parallel context\n+     * @param a the array to be sorted\n+     * @param bits the combination of recursion depth and bit flag, where\n+     *        the right bit \"0\" indicates that array is the leftmost part\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void sort(DPQSSorterContext sorter, int[] a, int[] b, int bits, int low, int high) {\n+        while (true) {\n+            int end = high - 1, size = high - low;\n+\n+            \/*\n+             * Run mixed insertion sort on small non-leftmost parts.\n+             *\/\n+            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                mixedInsertionSort(a, b, low, high - 3 * ((size >> 5) << 3), high);\n+                return;\n+            }\n+\n+            \/*\n+             * Invoke insertion sort on small leftmost part.\n+             *\/\n+            if (size < MAX_INSERTION_SORT_SIZE) {\n+                insertionSort(a, b, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * Check if the whole array or large non-leftmost\n+             * parts are nearly sorted and then merge runs.\n+             *\/\n+            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n+                    && tryMergeRuns(sorter, a, b, low, size)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Switch to heap sort if execution\n+             * time is becoming quadratic.\n+             *\/\n+            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, b, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * Use an inexpensive approximation of the golden ratio\n+             * to select five sample elements and determine pivots.\n+             *\/\n+            int step = (size >> 3) * 3 + 3;\n+\n+            \/*\n+             * Five elements around (and including) the central element\n+             * will be used for pivot selection as described below. The\n+             * unequal choice of spacing these elements was empirically\n+             * determined to work well on a wide variety of inputs.\n+             *\/\n+            int e1 = low + step;\n+            int e5 = end - step;\n+            int e3 = (e1 + e5) >>> 1;\n+            int e2 = (e1 + e3) >>> 1;\n+            int e4 = (e3 + e5) >>> 1;\n+            int a3 = a[e3];\n+\n+            \/*\n+             * Sort these elements in place by the combination\n+             * of 4-element sorting network and insertion sort.\n+             *\n+             *    5 ------o-----------o------------\n+             *            |           |\n+             *    4 ------|-----o-----o-----o------\n+             *            |     |           |\n+             *    2 ------o-----|-----o-----o------\n+             *                  |     |\n+             *    1 ------------o-----o------------\n+             *\/\n+            if (a[e5] < a[e2]) { int t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n+            if (a[e4] < a[e1]) { int t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n+            if (a[e5] < a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n+            if (a[e2] < a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n+            if (a[e4] < a[e2]) { int t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+\n+            if (a3 < a[e2]) {\n+                if (a3 < a[e1]) {\n+                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+                } else {\n+                    a[e3] = a[e2]; a[e2] = a3;\n+                }\n+            } else if (a3 > a[e4]) {\n+                if (a3 > a[e5]) {\n+                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+                } else {\n+                    a[e3] = a[e4]; a[e4] = a3;\n+                }\n+            }\n+\n+            \/\/ Pointers\n+            int lower = low; \/\/ The index of the last element of the left part\n+            int upper = end; \/\/ The index of the first element of the right part\n+\n+            \/*\n+             * Partitioning with 2 pivots in case of different elements.\n+             *\/\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n+\n+                \/*\n+                 * Use the first and fifth of the five sorted elements as\n+                 * the pivots. These values are inexpensive approximation\n+                 * of tertiles. Note, that pivot1 < pivot2.\n+                 *\/\n+                int pivotA1 = a[e1];\n+                int pivotA2 = a[e5];\n+                int pivotB1 = b[e1];\n+                int pivotB2 = b[e5];\n+\n+                \/*\n+                 * The first and the last elements to be sorted are moved\n+                 * to the locations formerly occupied by the pivots. When\n+                 * partitioning is completed, the pivots are swapped back\n+                 * into their final positions, and excluded from the next\n+                 * subsequent sorting.\n+                 *\/\n+                a[e1] = a[lower];\n+                a[e5] = a[upper];\n+                b[e1] = b[lower];\n+                b[e5] = b[upper];\n+\n+                \/*\n+                 * Skip elements, which are less or greater than the pivots.\n+                 *\/\n+                while (a[++lower] < pivotA1);\n+                while (a[--upper] > pivotA2);\n+\n+                \/*\n+                 * Backward 3-interval partitioning\n+                 *\n+                 *   left part                 central part          right part\n+                 * +------------------------------------------------------------+\n+                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n+                 * +------------------------------------------------------------+\n+                 *             ^       ^                            ^\n+                 *             |       |                            |\n+                 *           lower     k                          upper\n+                 *\n+                 * Invariants:\n+                 *\n+                 *              all in (low, lower] < pivot1\n+                 *    pivot1 <= all in (k, upper)  <= pivot2\n+                 *              all in [upper, end) > pivot2\n+                 *\n+                 * Pointer k is the last index of ?-part\n+                 *\/\n+                for (int unused = --lower, k = ++upper; --k > lower; ) {\n+                    int ak = a[k];\n+                    int bk = b[k];\n+\n+                    if (ak < pivotA1) { \/\/ Move a[k] to the left side\n+                        while (lower < k) {\n+                            if (a[++lower] >= pivotA1) {\n+                                if (a[lower] > pivotA2) {\n+                                    a[k] = a[--upper];\n+                                    a[upper] = a[lower];\n+                                    b[k] = b[  upper];\n+                                    b[upper] = b[lower];\n+                                } else {\n+                                    a[k] = a[lower];\n+                                    b[k] = b[lower];\n+                                }\n+                                a[lower] = ak;\n+                                b[lower] = bk;\n+                                break;\n+                            }\n+                        }\n+                    } else if (ak > pivotA2) { \/\/ Move a[k] to the right side\n+                        a[k] = a[--upper];\n+                        a[upper] = ak;\n+                        b[k] = b[  upper];\n+                        b[upper] = bk;\n+                    }\n+                }\n+\n+                \/*\n+                 * Swap the pivots into their final positions.\n+                 *\/\n+                a[low] = a[lower]; a[lower] = pivotA1;\n+                a[end] = a[upper]; a[upper] = pivotA2;\n+\n+                b[low] = b[lower]; b[lower] = pivotB1;\n+                b[end] = b[upper]; b[upper] = pivotB2;\n+\n+                \/*\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n+                 *\/\n+                sort(sorter, a, b, bits | 1, lower + 1, upper);\n+                sort(sorter, a, b, bits | 1, upper + 1, high);\n+\n+            } else { \/\/ Use single pivot in case of many equal elements\n+\n+                \/*\n+                 * Use the third of the five sorted elements as the pivot.\n+                 * This value is inexpensive approximation of the median.\n+                 *\/\n+                int pivotA = a[e3];\n+                int pivotB = b[e3];\n+\n+                \/*\n+                 * The first element to be sorted is moved to the\n+                 * location formerly occupied by the pivot. After\n+                 * completion of partitioning the pivot is swapped\n+                 * back into its final position, and excluded from\n+                 * the next subsequent sorting.\n+                 *\/\n+                a[e3] = a[lower];\n+                b[e3] = b[lower];\n+\n+                \/*\n+                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 *\n+                 *   left part                 central part    right part\n+                 * +------------------------------------------------------+\n+                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+                 * +------------------------------------------------------+\n+                 *              ^           ^                ^\n+                 *              |           |                |\n+                 *            lower         k              upper\n+                 *\n+                 * Invariants:\n+                 *\n+                 *   all in (low, lower] < pivot\n+                 *   all in (k, upper)  == pivot\n+                 *   all in [upper, end] > pivot\n+                 *\n+                 * Pointer k is the last index of ?-part\n+                 *\/\n+                for (int k = ++upper; --k > lower; ) {\n+                    int ak = a[k];\n+\n+                    if (ak != pivotA) {\n+                        a[k] = pivotA;\n+                        int bk = b[k];\n+\n+                        if (ak < pivotA) { \/\/ Move a[k] to the left side\n+                            while (a[++lower] < pivotA);\n+\n+                            if (a[lower] > pivotA) {\n+                                a[k] = a[--upper];\n+                                a[upper] = a[lower];\n+                                b[k] = b[  upper];\n+                                b[upper] = b[lower];\n+                            } else {\n+                                a[k] = a[lower];\n+                                b[k] = b[lower];\n+                            }\n+                            a[lower] = ak;\n+                            b[lower] = bk;\n+                        } else { \/\/ ak > pivot - Move a[k] to the right side\n+                            a[k] = a[--upper];\n+                            a[upper] = ak;\n+                            b[k] = b[  upper];\n+                            b[upper] = bk;\n+                        }\n+                    }\n+                }\n+\n+                \/*\n+                 * Swap the pivot into its final position.\n+                 *\/\n+                a[low] = a[lower]; a[lower] = pivotA;\n+                b[low] = b[lower]; b[lower] = pivotB;\n+\n+                \/*\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n+                 *\/\n+                sort(sorter, a, b, bits | 1, upper, high);\n+            }\n+            high = lower; \/\/ Iterate along the left part\n+        }\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using mixed insertion sort.\n+     *\n+     * Mixed insertion sort is combination of simple insertion sort,\n+     * pin insertion sort and pair insertion sort.\n+     *\n+     * In the context of Dual-Pivot Quicksort, the pivot element\n+     * from the left part plays the role of sentinel, because it\n+     * is less than any elements from the given part. Therefore,\n+     * expensive check of the left range can be skipped on each\n+     * iteration unless it is the leftmost call.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param end the index of the last element for simple insertion sort\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void mixedInsertionSort(int[] a, int[] b, int low, int end, int high) {\n+        if (end == high) {\n+\n+            \/*\n+             * Invoke simple insertion sort on tiny array.\n+             *\/\n+            for (int i; ++low < end; ) {\n+                int ai = a[i = low];\n+\n+                if (ai < a[i - 1]) {\n+                    int bi = b[i];\n+\n+                    while (ai < a[--i]) {\n+                        a[i + 1] = a[i];\n+                        b[i + 1] = b[i];\n+                    }\n+                    a[i + 1] = ai;\n+                    b[i + 1] = bi;\n+                }\n+            }\n+        } else {\n+\n+            \/*\n+             * Start with pin insertion sort on small part.\n+             *\n+             * Pin insertion sort is extended simple insertion sort.\n+             * The main idea of this sort is to put elements larger\n+             * than an element called pin to the end of array (the\n+             * proper area for such elements). It avoids expensive\n+             * movements of these elements through the whole array.\n+             *\/\n+            int pin = a[end];\n+\n+            for (int i, p = high; ++low < end; ) {\n+                int ai = a[i = low];\n+                int bi = b[i];\n+\n+                if (ai < a[i - 1]) { \/\/ Small element\n+\n+                    \/*\n+                     * Insert small element into sorted part.\n+                     *\/\n+                    a[i] = a[i - 1];\n+                    b[i] = b[--i];\n+\n+                    while (ai < a[--i]) {\n+                        a[i + 1] = a[i];\n+                        b[i + 1] = b[i];\n+                    }\n+                    a[i + 1] = ai;\n+                    b[i + 1] = bi;\n+\n+                } else if (p > i && ai > pin) { \/\/ Large element\n+\n+                    \/*\n+                     * Find element smaller than pin.\n+                     *\/\n+                    while (a[--p] > pin);\n+\n+                    \/*\n+                     * Swap it with large element.\n+                     *\/\n+                    if (p > i) {\n+                        ai = a[p];\n+                        a[p] = a[i];\n+                        bi = b[p];\n+                        b[p] = b[i];\n+                    }\n+\n+                    \/*\n+                     * Insert small element into sorted part.\n+                     *\/\n+                    while (ai < a[--i]) {\n+                        a[i + 1] = a[i];\n+                        b[i + 1] = b[i];\n+                    }\n+                    a[i + 1] = ai;\n+                    b[i + 1] = bi;\n+                }\n+            }\n+\n+            \/*\n+             * Continue with pair insertion sort on remain part.\n+             *\/\n+            for (int i; low < high; ++low) {\n+                int a1 = a[i = low], a2 = a[++low];\n+                int b1 = b[i],       b2 = b[  low];\n+\n+                \/*\n+                 * Insert two elements per iteration: at first, insert the\n+                 * larger element and then insert the smaller element, but\n+                 * from the position where the larger element was inserted.\n+                 *\/\n+                if (a1 > a2) {\n+\n+                    while (a1 < a[--i]) {\n+                        a[i + 2] = a[i];\n+                        b[i + 2] = b[i];\n+                    }\n+                    a[++i + 1] = a1;\n+                    b[  i + 1] = b1;\n+\n+                    while (a2 < a[--i]) {\n+                        a[i + 1] = a[i];\n+                        b[i + 1] = b[i];\n+                    }\n+                    a[i + 1] = a2;\n+                    b[i + 1] = b2;\n+\n+                } else if (a1 < a[i - 1]) {\n+\n+                    while (a2 < a[--i]) {\n+                        a[i + 2] = a[i];\n+                        b[i + 2] = b[i];\n+                    }\n+                    a[++i + 1] = a2;\n+                    b[  i + 1] = b2;\n+\n+                    while (a1 < a[--i]) {\n+                        a[i + 1] = a[i];\n+                        b[i + 1] = b[i];\n+                    }\n+                    a[i + 1] = a1;\n+                    b[i + 1] = b1;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void insertionSort(int[] a, int[] b, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            int ai = a[i = k];\n+\n+            if (ai < a[i - 1]) {\n+                int bi = b[i];\n+\n+                while (--i >= low && ai < a[i]) {\n+                    a[i + 1] = a[i];\n+                    b[i + 1] = b[i];\n+                }\n+                a[i + 1] = ai;\n+                b[i + 1] = bi;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void heapSort(int[] a, int[] b, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, b, --k, a[k], b[k], low, high);\n+        }\n+        while (--high > low) {\n+            int maxA = a[low];\n+            int maxB = b[low];\n+            pushDown(a, b, low, a[high], b[high], low, high);\n+            a[high] = maxA;\n+            b[high] = maxB;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param valueA the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(int[] a, int[] b, int p, int valueA, int valueB, int low, int high) {\n+        for (int k;; a[p] = a[k], b[p] = b[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= valueA) {\n+                break;\n+            }\n+        }\n+        a[p] = valueA;\n+        b[p] = valueB;\n+    }\n+\n+    \/**\n+     * Tries to sort the specified range of the array.\n+     *\n+     * @param sorter parallel context\n+     * @param a the array to be sorted\n+     * @param low the index of the first element to be sorted\n+     * @param size the array size\n+     * @return true if finally sorted, false otherwise\n+     *\/\n+    private static boolean tryMergeRuns(DPQSSorterContext sorter, int[] a, int[] b, int low, int size) {\n+\n+        \/*\n+         * The run array is constructed only if initial runs are\n+         * long enough to continue, run[i] then holds start index\n+         * of the i-th sequence of elements in non-descending order.\n+         *\/\n+        int[] run = null;\n+        int high = low + size;\n+        int count = 1, last = low;\n+\n+        \/*\n+         * Identify all possible runs.\n+         *\/\n+        for (int k = low + 1; k < high; ) {\n+\n+            \/*\n+             * Find the end index of the current run.\n+             *\/\n+            if (a[k - 1] < a[k]) {\n+\n+                \/\/ Identify ascending sequence\n+                while (++k < high && a[k - 1] <= a[k]);\n+\n+            } else if (a[k - 1] > a[k]) {\n+\n+                \/\/ Identify descending sequence\n+                while (++k < high && a[k - 1] >= a[k]);\n+\n+                \/\/ Reverse into ascending order\n+                for (int i = last - 1, j = k, t; ++i < --j && a[i] > a[j]; ) {\n+                    t = a[i]; a[i] = a[j]; a[j] = t;\n+                    t = b[i]; b[i] = b[j]; b[j] = t;\n+                }\n+            } else { \/\/ Identify constant sequence\n+                for (int ak = a[k]; ++k < high && ak == a[k]; );\n+\n+                if (k < high) {\n+                    continue;\n+                }\n+            }\n+\n+            \/*\n+             * Check special cases.\n+             *\/\n+            if (sorter.runInit || run == null) {\n+                sorter.runInit = false; \/\/ LBO\n+\n+                if (k == high) {\n+\n+                    \/*\n+                     * The array is monotonous sequence,\n+                     * and therefore already sorted.\n+                     *\/\n+                    return true;\n+                }\n+\n+                if (k - low < MIN_FIRST_RUN_SIZE) {\n+\n+                    \/*\n+                     * The first run is too small\n+                     * to proceed with scanning.\n+                     *\/\n+                    return false;\n+                }\n+\n+\/\/                System.out.println(\"alloc run\");\n+\/\/                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = sorter.run; \/\/ LBO: prealloc\n+                run[0] = low;\n+\n+            } else if (a[last - 1] > a[last]) {\n+\n+                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+\n+                    \/*\n+                     * The first runs are not long\n+                     * enough to continue scanning.\n+                     *\/\n+                    return false;\n+                }\n+\n+                if (++count == MAX_RUN_CAPACITY) {\n+\n+                    \/*\n+                     * Array is not highly structured.\n+                     *\/\n+                    return false;\n+                }\n+\n+                if (false && count == run.length) {\n+\n+                    \/*\n+                     * Increase capacity of index array.\n+                     *\/\n+\/\/                  System.out.println(\"alloc run (resize)\");\n+                    run = Arrays.copyOf(run, count << 1);\n+                }\n+            }\n+            run[count] = (last = k);\n+\n+            \/\/ fix ALMOST_CONTIGUOUS ie consecutive (ascending \/ descending runs)\n+            if (k < high - 1) {\n+                k++; \/\/ LBO\n+            }\n+        }\n+\n+        \/*\n+         * Merge runs of highly structured array.\n+         *\/\n+        if (count > 1) {\n+            int[] auxA = sorter.auxA;\n+            int[] auxB = sorter.auxB;\n+            int offset = low;\n+\n+            \/\/ LBO: prealloc\n+            if ((auxA.length < size || auxB.length < size)) {\n+\/\/                System.out.println(\"alloc aux: \"+size);\n+                auxA = new int[size];\n+                auxB = new int[size];\n+            }\n+            mergeRuns(a, auxA, b, auxB, offset, 1, run, 0, count);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Merges the specified runs.\n+     *\n+     * @param srcA the source array\n+     * @param dstA the temporary buffer used in merging\n+     * @param offset the start index in the source, inclusive\n+     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n+     * @param run the start indexes of the runs, inclusive\n+     * @param lo the start index of the first run, inclusive\n+     * @param hi the start index of the last run, inclusive\n+     * @return the destination where runs are merged\n+     *\/\n+    private static int[] mergeRuns(int[] srcA, int[] dstA, int[] srcB, int[] dstB, int offset,\n+                                   int aim, int[] run, int lo, int hi) {\n+\n+        if (hi - lo == 1) {\n+            if (aim >= 0) {\n+                return srcA;\n+            }\n+            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n+                --j, --i, dstA[j] = srcA[i], dstB[j] = srcB[i]\n+            );\n+            return dstA;\n+        }\n+\n+        \/*\n+         * Split into approximately equal parts.\n+         *\/\n+        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= rmi);\n+\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        int[] a1, a2;\n+        a1 = mergeRuns(srcA, dstA, srcB, dstB, offset, -aim, run, lo, mi);\n+        a2 = mergeRuns(srcA, dstA, srcB, dstB, offset,    0, run, mi, hi);\n+\n+        int[] b1, b2;\n+        b1 = a1 == srcA ? srcB : dstB;\n+        b2 = a2 == srcA ? srcB : dstB;\n+\n+        int[] resA = a1 == srcA ? dstA : srcA;\n+        int[] resB = a1 == srcA ? dstB : srcB;\n+\n+        int k   = a1 == srcA ? run[lo] - offset : run[lo];\n+        int lo1 = a1 == dstA ? run[lo] - offset : run[lo];\n+        int hi1 = a1 == dstA ? run[mi] - offset : run[mi];\n+        int lo2 = a2 == dstA ? run[mi] - offset : run[mi];\n+        int hi2 = a2 == dstA ? run[hi] - offset : run[hi];\n+\n+        mergeParts(resA, resB, k, a1, b1, lo1, hi1, a2, b2, lo2, hi2);\n+\n+        return resA;\n+    }\n+\n+    \/**\n+     * Merges the sorted parts.\n+     *\n+     * @param dstA the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param a1 the first part\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param a2 the second part\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(int[] dstA, int[] dstB, int k,\n+                                   int[] a1, int[] b1, int lo1, int hi1, int[] a2, int[] b2, int lo2, int hi2) {\n+\/\/ ...\n+        \/*\n+         * Merge small parts sequentially.\n+         *\/\n+        while (lo1 < hi1 && lo2 < hi2) {\n+            if (a1[lo1] < a2[lo2]) {\n+                dstA[k] = a1[lo1];\n+                dstB[k] = b1[lo1];\n+                k++; lo1++;\n+            } else {\n+                dstA[k] = a2[lo2];\n+                dstB[k] = b2[lo2];\n+                k++; lo2++;\n+            }\n+        }\n+        if (dstA != a1 || k < lo1) {\n+            while (lo1 < hi1) {\n+                dstA[k] = a1[lo1];\n+                dstB[k] = b1[lo1];\n+                k++; lo1++;\n+            }\n+        }\n+        if (dstA != a2 || k < lo2) {\n+            while (lo2 < hi2) {\n+                dstA[k] = a2[lo2];\n+                dstB[k] = b2[lo2];\n+                k++; lo2++;\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/DualPivotQuicksort20191112Ext.java","additions":867,"deletions":0,"binary":false,"changes":867,"status":"added"},{"patch":"@@ -1,269 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.marlin;\n-\n-import static com.sun.marlin.ArrayCacheConst.ARRAY_SIZES;\n-import static com.sun.marlin.ArrayCacheConst.BUCKETS;\n-import static com.sun.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n-import static com.sun.marlin.MarlinUtils.logInfo;\n-import static com.sun.marlin.MarlinUtils.logException;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Arrays;\n-\n-import com.sun.marlin.ArrayCacheConst.BucketStats;\n-import com.sun.marlin.ArrayCacheConst.CacheStats;\n-\n-\/*\n- * Note that the [BYTE\/INT\/FLOAT\/DOUBLE]ArrayCache files are nearly identical except\n- * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n- * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n- * files are generated with the following command lines:\n- *\/\n-\/\/ % sed -e 's\/(b\\yte)[ ]*\/\/g' -e 's\/b\\yte\/int\/g' -e 's\/B\\yte\/Int\/g' < B\\yteArrayCache.java > IntArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0f\/g' -e 's\/(b\\yte)[ ]*\/(float) \/g' -e 's\/b\\yte\/float\/g' -e 's\/B\\yte\/Float\/g' < B\\yteArrayCache.java > FloatArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0d\/g' -e 's\/(b\\yte)[ ]*\/(double) \/g' -e 's\/b\\yte\/double\/g' -e 's\/B\\yte\/Double\/g' < B\\yteArrayCache.java > DoubleArrayCache.java\n-\n-public final class FloatArrayCache implements MarlinConst {\n-\n-    final boolean clean;\n-    private final int bucketCapacity;\n-    private WeakReference<Bucket[]> refBuckets = null;\n-    final CacheStats stats;\n-\n-    FloatArrayCache(final boolean clean, final int bucketCapacity) {\n-        this.clean = clean;\n-        this.bucketCapacity = bucketCapacity;\n-        this.stats = (DO_STATS) ?\n-            new CacheStats(getLogPrefix(clean) + \"FloatArrayCache\") : null;\n-    }\n-\n-    Bucket getCacheBucket(final int length) {\n-        final int bucket = ArrayCacheConst.getBucket(length);\n-        return getBuckets()[bucket];\n-    }\n-\n-    private Bucket[] getBuckets() {\n-        \/\/ resolve reference:\n-        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n-\n-        \/\/ create a new buckets ?\n-        if (buckets == null) {\n-            buckets = new Bucket[BUCKETS];\n-\n-            for (int i = 0; i < BUCKETS; i++) {\n-                buckets[i] = new Bucket(clean, ARRAY_SIZES[i], bucketCapacity,\n-                        (DO_STATS) ? stats.bucketStats[i] : null);\n-            }\n-\n-            \/\/ update weak reference:\n-            refBuckets = new WeakReference<Bucket[]>(buckets);\n-        }\n-        return buckets;\n-    }\n-\n-    Reference createRef(final int initialSize) {\n-        return new Reference(this, initialSize);\n-    }\n-\n-    static final class Reference {\n-\n-        \/\/ initial array reference (direct access)\n-        final float[] initial;\n-        private final boolean clean;\n-        private final FloatArrayCache cache;\n-\n-        Reference(final FloatArrayCache cache, final int initialSize) {\n-            this.cache = cache;\n-            this.clean = cache.clean;\n-            this.initial = createArray(initialSize);\n-            if (DO_STATS) {\n-                cache.stats.totalInitial += initialSize;\n-            }\n-        }\n-\n-        float[] getArray(final int length) {\n-            if (length <= MAX_ARRAY_SIZE) {\n-                return cache.getCacheBucket(length).getArray();\n-            }\n-            if (DO_STATS) {\n-                cache.stats.oversize++;\n-            }\n-            if (DO_LOG_OVERSIZE) {\n-                logInfo(getLogPrefix(clean) + \"FloatArrayCache: \"\n-                        + \"getArray[oversize]: length=\\t\" + length);\n-            }\n-            return createArray(length);\n-        }\n-\n-        float[] widenArray(final float[] array, final int usedSize,\n-                          final int needSize)\n-        {\n-            final int length = array.length;\n-            if (DO_CHECKS && length >= needSize) {\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                cache.stats.resize++;\n-            }\n-\n-            \/\/ maybe change bucket:\n-            \/\/ ensure getNewSize() > newSize:\n-            final float[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n-\n-            \/\/ use wrapper to ensure proper copy:\n-            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n-\n-            \/\/ maybe return current array:\n-            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n-\n-            if (DO_LOG_WIDEN_ARRAY) {\n-                logInfo(getLogPrefix(clean) + \"FloatArrayCache: \"\n-                        + \"widenArray[\" + res.length\n-                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n-                        + \"\\tneeded length=\\t\" + needSize);\n-            }\n-            return res;\n-        }\n-\n-        float[] putArray(final float[] array)\n-        {\n-            \/\/ dirty array helper:\n-            return putArray(array, 0, array.length);\n-        }\n-\n-        float[] putArray(final float[] array, final int fromIndex,\n-                        final int toIndex)\n-        {\n-            if (array.length <= MAX_ARRAY_SIZE) {\n-                if ((clean || DO_CLEAN_DIRTY) && (toIndex != 0)) {\n-                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n-                    fill(array, fromIndex, toIndex, 0.0f);\n-                }\n-                \/\/ ensure to never store initial arrays in cache:\n-                if (array != initial) {\n-                    cache.getCacheBucket(array.length).putArray(array);\n-                }\n-            }\n-            return initial;\n-        }\n-    }\n-\n-    static final class Bucket {\n-\n-        private int tail = 0;\n-        private final int arraySize;\n-        private final boolean clean;\n-        private final float[][] arrays;\n-        private final BucketStats stats;\n-\n-        Bucket(final boolean clean, final int arraySize,\n-               final int capacity, final BucketStats stats)\n-        {\n-            this.arraySize = arraySize;\n-            this.clean = clean;\n-            this.stats = stats;\n-            this.arrays = new float[capacity][];\n-        }\n-\n-        float[] getArray() {\n-            if (DO_STATS) {\n-                stats.getOp++;\n-            }\n-            \/\/ use cache:\n-            if (tail != 0) {\n-                final float[] array = arrays[--tail];\n-                arrays[tail] = null;\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                stats.createOp++;\n-            }\n-            return createArray(arraySize);\n-        }\n-\n-        void putArray(final float[] array)\n-        {\n-            if (DO_CHECKS && (array.length != arraySize)) {\n-                logInfo(getLogPrefix(clean) + \"FloatArrayCache: \"\n-                        + \"bad length = \" + array.length);\n-                return;\n-            }\n-            if (DO_STATS) {\n-                stats.returnOp++;\n-            }\n-            \/\/ fill cache:\n-            if (arrays.length > tail) {\n-                arrays[tail++] = array;\n-\n-                if (DO_STATS) {\n-                    stats.updateMaxSize(tail);\n-                }\n-            } else if (DO_CHECKS) {\n-                logInfo(getLogPrefix(clean) + \"FloatArrayCache: \"\n-                        + \"array capacity exceeded !\");\n-            }\n-        }\n-    }\n-\n-    static float[] createArray(final int length) {\n-        return new float[length];\n-    }\n-\n-    static void fill(final float[] array, final int fromIndex,\n-                     final int toIndex, final float value)\n-    {\n-        \/\/ clear array data:\n-        Arrays.fill(array, fromIndex, toIndex, value);\n-        if (DO_CHECKS) {\n-            check(array, fromIndex, toIndex, value);\n-        }\n-    }\n-\n-    public static void check(final float[] array, final int fromIndex,\n-                             final int toIndex, final float value)\n-    {\n-        if (DO_CHECKS) {\n-            \/\/ check zero on full array:\n-            for (int i = 0; i < array.length; i++) {\n-                if (array[i] != value) {\n-                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n-                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n-                            + Arrays.toString(array), new Throwable());\n-\n-                    \/\/ ensure array is correctly filled:\n-                    Arrays.fill(array, value);\n-\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    static String getLogPrefix(final boolean clean) {\n-        return (clean) ? \"Clean\" : \"Dirty\";\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/FloatArrayCache.java","additions":0,"deletions":269,"binary":false,"changes":269,"status":"deleted"},{"patch":"@@ -50,20 +50,0 @@\n-    \/**\n-     * Faster alternative to ceil(float) optimized for the integer domain\n-     * and supporting NaN and +\/-Infinity.\n-     *\n-     * @param a a value.\n-     * @return the largest (closest to positive infinity) integer value\n-     * that less than or equal to the argument and is equal to a mathematical\n-     * integer.\n-     *\/\n-    public static int ceil_int(final float a) {\n-        final int intpart = (int) a;\n-\n-        if (a <= intpart\n-                || (CHECK_OVERFLOW && intpart == Integer.MAX_VALUE)\n-                || CHECK_NAN && Float.isNaN(a)) {\n-            return intpart;\n-        }\n-        return intpart + 1;\n-    }\n-\n@@ -90,20 +70,0 @@\n-    \/**\n-     * Faster alternative to floor(float) optimized for the integer domain\n-     * and supporting NaN and +\/-Infinity.\n-     *\n-     * @param a a value.\n-     * @return the largest (closest to positive infinity) floating-point value\n-     * that less than or equal to the argument and is equal to a mathematical\n-     * integer.\n-     *\/\n-    public static int floor_int(final float a) {\n-        final int intpart = (int) a;\n-\n-        if (a >= intpart\n-                || (CHECK_OVERFLOW && intpart == Integer.MIN_VALUE)\n-                || CHECK_NAN && Float.isNaN(a)) {\n-            return intpart;\n-        }\n-        return intpart - 1;\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/FloatMath.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+    private static final double EPS = 1e-9d;\n+\n@@ -38,0 +40,4 @@\n+    static boolean within(final double x, final double y) {\n+        return within(x, y, EPS);\n+    }\n+\n@@ -39,1 +45,4 @@\n-        final double d = y - x;\n+        return withinD(y - x, err);\n+    }\n+\n+    static boolean withinD(final double d, final double err) {\n@@ -43,0 +52,22 @@\n+    static boolean withinD(final double dx, final double dy, final double err)\n+    {\n+        assert err > 0 : \"\";\n+        \/\/ compare taxicab distance. ERR will always be small, so using\n+        \/\/ true distance won't give much benefit\n+        return (withinD(dx, err) && \/\/ we want to avoid calling Math.abs\n+                withinD(dy, err));  \/\/ this is just as good.\n+    }\n+\n+    static boolean isPointCurve(final double[] curve, final int type) {\n+        return isPointCurve(curve, type, EPS);\n+    }\n+\n+    static boolean isPointCurve(final double[] curve, final int type, final double err) {\n+        for (int i = 2; i < type; i++) {\n+            if (!within(curve[i], curve[i - 2], err)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n@@ -61,13 +92,10 @@\n-            final double dis = b*b - 4.0d * a * c;\n-            if (dis > 0.0d) {\n-                final double sqrtDis = Math.sqrt(dis);\n-                \/\/ depending on the sign of b we use a slightly different\n-                \/\/ algorithm than the traditional one to find one of the roots\n-                \/\/ so we can avoid adding numbers of different signs (which\n-                \/\/ might result in loss of precision).\n-                if (b >= 0.0d) {\n-                    zeroes[ret++] = (2.0d * c) \/ (-b - sqrtDis);\n-                    zeroes[ret++] = (-b - sqrtDis) \/ (2.0d * a);\n-                } else {\n-                    zeroes[ret++] = (-b + sqrtDis) \/ (2.0d * a);\n-                    zeroes[ret++] = (2.0d * c) \/ (-b + sqrtDis);\n+            double d = b * b - 4.0d * a * c;\n+            if (d > 0.0d) {\n+                d = Math.sqrt(d);\n+                \/\/ For accuracy, calculate one root using:\n+                \/\/     (-b +\/- d) \/ 2a\n+                \/\/ and the other using:\n+                \/\/     2c \/ (-b +\/- d)\n+                \/\/ Choose the sign of the +\/- so that b+d gets larger in magnitude\n+                if (b < 0.0d) {\n+                    d = -d;\n@@ -75,1 +103,7 @@\n-            } else if (dis == 0.0d) {\n+                final double q = (b + d) \/ -2.0d;\n+                \/\/ We already tested a for being 0 above\n+                zeroes[ret++] = q \/ a;\n+                if (q != 0.0d) {\n+                    zeroes[ret++] = c \/ q;\n+                }\n+            } else if (d == 0.0d) {\n@@ -100,4 +134,0 @@\n-\n-        \/*\n-         * TODO: cleanup all that code after reading Roots3And4.c\n-         *\/\n@@ -116,1 +146,0 @@\n-        final double sub = (1.0d \/ 3.0d) * a;\n@@ -119,0 +148,1 @@\n+        final double sub = (1.0d \/ 3.0d) * a;\n@@ -122,1 +152,0 @@\n-\n@@ -127,1 +156,14 @@\n-        if (D < 0.0d) {\n+\n+        if (within(D, 0.0d)) {\n+            if (within(q, 0.0d)) {\n+                \/* one triple solution *\/\n+                pts[off    ] = (- sub);\n+                num = 1;\n+            } else {\n+                \/* one single and one double solution *\/\n+                final double u = Math.cbrt(-q);\n+                pts[off    ] = (2.0d * u - sub);\n+                pts[off + 1] = (- u - sub);\n+                num = 2;\n+            }\n+        } else if (D < 0.0d) {\n@@ -143,5 +185,0 @@\n-\n-            if (within(D, 0.0d, 1e-8d)) {\n-                pts[off + 1] = ((-1.0d \/ 2.0d) * (u + v) - sub);\n-                num = 2;\n-            }\n@@ -149,1 +186,0 @@\n-\n@@ -624,1 +660,1 @@\n-        final DoubleArrayCache.Reference curves_ref;\n+        final ArrayCacheDouble.Reference curves_ref;\n@@ -626,1 +662,1 @@\n-        final ByteArrayCache.Reference curveTypes_ref;\n+        final ArrayCacheByte.Reference curveTypes_ref;\n@@ -673,1 +709,1 @@\n-            end = 0;\n+            end       = 0;\n@@ -688,2 +724,6 @@\n-            curves     = curves_ref.putArray(curves);\n-            curveTypes = curveTypes_ref.putArray(curveTypes);\n+            if (curves_ref.doCleanRef(curves)) {\n+                curves = curves_ref.putArray(curves);\n+            }\n+            if (curveTypes_ref.doCleanRef(curveTypes)) {\n+                curveTypes = curveTypes_ref.putArray(curveTypes);\n+            }\n@@ -829,1 +869,1 @@\n-            String ret = \"\";\n+            StringBuilder ret = new StringBuilder();\n@@ -837,1 +877,1 @@\n-                    ret += \"line: \";\n+                    ret.append(\"line: \");\n@@ -841,1 +881,1 @@\n-                    ret += \"quad: \";\n+                    ret.append(\"quad: \");\n@@ -845,1 +885,1 @@\n-                    ret += \"cubic: \";\n+                    ret.append(\"cubic: \");\n@@ -851,2 +891,1 @@\n-                ret += Arrays.toString(Arrays.copyOfRange(curves, last, last+len))\n-                                       + \"\\n\";\n+                ret.append(Arrays.toString(Arrays.copyOfRange(curves, last, last + len))).append(\"\\n\");\n@@ -854,1 +893,1 @@\n-            return ret;\n+            return ret.toString();\n@@ -868,1 +907,1 @@\n-        private final IntArrayCache.Reference indices_ref;\n+        private final ArrayCacheInt.Reference indices_ref;\n@@ -914,2 +953,4 @@\n-            \/\/ values is kept dirty\n-            indices = indices_ref.putArray(indices);\n+            \/\/ indices is kept dirty\n+            if (indices_ref.doCleanRef(indices)) {\n+                indices = indices_ref.putArray(indices);\n+            }\n@@ -953,1 +994,3 @@\n-        void pullAll(final double[] points, final DPathConsumer2D io) {\n+        void pullAll(final double[] points, final DPathConsumer2D io,\n+                     final boolean moveFirst)\n+        {\n@@ -960,1 +1003,9 @@\n-            for (int i = 0, j; i < nc; i++) {\n+            int i = 0;\n+\n+            if (moveFirst) {\n+                int j = _values[i] << 1;\n+                io.moveTo(points[j], points[j + 1]);\n+                i++;\n+            }\n+\n+            for (int j; i < nc; i++) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/Helpers.java","additions":96,"deletions":45,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -1,269 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.marlin;\n-\n-import static com.sun.marlin.ArrayCacheConst.ARRAY_SIZES;\n-import static com.sun.marlin.ArrayCacheConst.BUCKETS;\n-import static com.sun.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n-import static com.sun.marlin.MarlinUtils.logInfo;\n-import static com.sun.marlin.MarlinUtils.logException;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Arrays;\n-\n-import com.sun.marlin.ArrayCacheConst.BucketStats;\n-import com.sun.marlin.ArrayCacheConst.CacheStats;\n-\n-\/*\n- * Note that the [BYTE\/INT\/FLOAT\/DOUBLE]ArrayCache files are nearly identical except\n- * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n- * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n- * files are generated with the following command lines:\n- *\/\n-\/\/ % sed -e 's\/(b\\yte)[ ]*\/\/g' -e 's\/b\\yte\/int\/g' -e 's\/B\\yte\/Int\/g' < B\\yteArrayCache.java > IntArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0f\/g' -e 's\/(b\\yte)[ ]*\/(float) \/g' -e 's\/b\\yte\/float\/g' -e 's\/B\\yte\/Float\/g' < B\\yteArrayCache.java > FloatArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0d\/g' -e 's\/(b\\yte)[ ]*\/(double) \/g' -e 's\/b\\yte\/double\/g' -e 's\/B\\yte\/Double\/g' < B\\yteArrayCache.java > DoubleArrayCache.java\n-\n-public final class IntArrayCache implements MarlinConst {\n-\n-    final boolean clean;\n-    private final int bucketCapacity;\n-    private WeakReference<Bucket[]> refBuckets = null;\n-    final CacheStats stats;\n-\n-    IntArrayCache(final boolean clean, final int bucketCapacity) {\n-        this.clean = clean;\n-        this.bucketCapacity = bucketCapacity;\n-        this.stats = (DO_STATS) ?\n-            new CacheStats(getLogPrefix(clean) + \"IntArrayCache\") : null;\n-    }\n-\n-    Bucket getCacheBucket(final int length) {\n-        final int bucket = ArrayCacheConst.getBucket(length);\n-        return getBuckets()[bucket];\n-    }\n-\n-    private Bucket[] getBuckets() {\n-        \/\/ resolve reference:\n-        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n-\n-        \/\/ create a new buckets ?\n-        if (buckets == null) {\n-            buckets = new Bucket[BUCKETS];\n-\n-            for (int i = 0; i < BUCKETS; i++) {\n-                buckets[i] = new Bucket(clean, ARRAY_SIZES[i], bucketCapacity,\n-                        (DO_STATS) ? stats.bucketStats[i] : null);\n-            }\n-\n-            \/\/ update weak reference:\n-            refBuckets = new WeakReference<Bucket[]>(buckets);\n-        }\n-        return buckets;\n-    }\n-\n-    Reference createRef(final int initialSize) {\n-        return new Reference(this, initialSize);\n-    }\n-\n-    static final class Reference {\n-\n-        \/\/ initial array reference (direct access)\n-        final int[] initial;\n-        private final boolean clean;\n-        private final IntArrayCache cache;\n-\n-        Reference(final IntArrayCache cache, final int initialSize) {\n-            this.cache = cache;\n-            this.clean = cache.clean;\n-            this.initial = createArray(initialSize);\n-            if (DO_STATS) {\n-                cache.stats.totalInitial += initialSize;\n-            }\n-        }\n-\n-        int[] getArray(final int length) {\n-            if (length <= MAX_ARRAY_SIZE) {\n-                return cache.getCacheBucket(length).getArray();\n-            }\n-            if (DO_STATS) {\n-                cache.stats.oversize++;\n-            }\n-            if (DO_LOG_OVERSIZE) {\n-                logInfo(getLogPrefix(clean) + \"IntArrayCache: \"\n-                        + \"getArray[oversize]: length=\\t\" + length);\n-            }\n-            return createArray(length);\n-        }\n-\n-        int[] widenArray(final int[] array, final int usedSize,\n-                          final int needSize)\n-        {\n-            final int length = array.length;\n-            if (DO_CHECKS && length >= needSize) {\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                cache.stats.resize++;\n-            }\n-\n-            \/\/ maybe change bucket:\n-            \/\/ ensure getNewSize() > newSize:\n-            final int[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n-\n-            \/\/ use wrapper to ensure proper copy:\n-            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n-\n-            \/\/ maybe return current array:\n-            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n-\n-            if (DO_LOG_WIDEN_ARRAY) {\n-                logInfo(getLogPrefix(clean) + \"IntArrayCache: \"\n-                        + \"widenArray[\" + res.length\n-                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n-                        + \"\\tneeded length=\\t\" + needSize);\n-            }\n-            return res;\n-        }\n-\n-        int[] putArray(final int[] array)\n-        {\n-            \/\/ dirty array helper:\n-            return putArray(array, 0, array.length);\n-        }\n-\n-        int[] putArray(final int[] array, final int fromIndex,\n-                        final int toIndex)\n-        {\n-            if (array.length <= MAX_ARRAY_SIZE) {\n-                if ((clean || DO_CLEAN_DIRTY) && (toIndex != 0)) {\n-                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n-                    fill(array, fromIndex, toIndex, 0);\n-                }\n-                \/\/ ensure to never store initial arrays in cache:\n-                if (array != initial) {\n-                    cache.getCacheBucket(array.length).putArray(array);\n-                }\n-            }\n-            return initial;\n-        }\n-    }\n-\n-    static final class Bucket {\n-\n-        private int tail = 0;\n-        private final int arraySize;\n-        private final boolean clean;\n-        private final int[][] arrays;\n-        private final BucketStats stats;\n-\n-        Bucket(final boolean clean, final int arraySize,\n-               final int capacity, final BucketStats stats)\n-        {\n-            this.arraySize = arraySize;\n-            this.clean = clean;\n-            this.stats = stats;\n-            this.arrays = new int[capacity][];\n-        }\n-\n-        int[] getArray() {\n-            if (DO_STATS) {\n-                stats.getOp++;\n-            }\n-            \/\/ use cache:\n-            if (tail != 0) {\n-                final int[] array = arrays[--tail];\n-                arrays[tail] = null;\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                stats.createOp++;\n-            }\n-            return createArray(arraySize);\n-        }\n-\n-        void putArray(final int[] array)\n-        {\n-            if (DO_CHECKS && (array.length != arraySize)) {\n-                logInfo(getLogPrefix(clean) + \"IntArrayCache: \"\n-                        + \"bad length = \" + array.length);\n-                return;\n-            }\n-            if (DO_STATS) {\n-                stats.returnOp++;\n-            }\n-            \/\/ fill cache:\n-            if (arrays.length > tail) {\n-                arrays[tail++] = array;\n-\n-                if (DO_STATS) {\n-                    stats.updateMaxSize(tail);\n-                }\n-            } else if (DO_CHECKS) {\n-                logInfo(getLogPrefix(clean) + \"IntArrayCache: \"\n-                        + \"array capacity exceeded !\");\n-            }\n-        }\n-    }\n-\n-    static int[] createArray(final int length) {\n-        return new int[length];\n-    }\n-\n-    static void fill(final int[] array, final int fromIndex,\n-                     final int toIndex, final int value)\n-    {\n-        \/\/ clear array data:\n-        Arrays.fill(array, fromIndex, toIndex, value);\n-        if (DO_CHECKS) {\n-            check(array, fromIndex, toIndex, value);\n-        }\n-    }\n-\n-    public static void check(final int[] array, final int fromIndex,\n-                             final int toIndex, final int value)\n-    {\n-        if (DO_CHECKS) {\n-            \/\/ check zero on full array:\n-            for (int i = 0; i < array.length; i++) {\n-                if (array[i] != value) {\n-                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n-                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n-                            + Arrays.toString(array), new Throwable());\n-\n-                    \/\/ ensure array is correctly filled:\n-                    Arrays.fill(array, value);\n-\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    static String getLogPrefix(final boolean clean) {\n-        return (clean) ? \"Clean\" : \"Dirty\";\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/IntArrayCache.java","additions":0,"deletions":269,"binary":false,"changes":269,"status":"deleted"},{"patch":"@@ -172,0 +172,13 @@\n+    public static float getStrokerJoinError() {\n+        final float def = (1.0f \/ MarlinConst.MIN_SUBPIXELS);\n+        float err = getFloat(\"prism.marlin.stroker.joinError\",\n+                def,\n+                -1.0f,\n+                10.0f);\n+        return (err < 0.0f) ? def : err;\n+    }\n+\n+    public static int getStrokerJoinStyle() {\n+        return getInteger(\"prism.marlin.stroker.joinStyle\", -1, -1, 2);\n+    }\n+\n@@ -192,0 +205,4 @@\n+    public static boolean isUseDPQS() {\n+        return getBoolean(\"prism.marlin.useDPQS\", \"true\");\n+    }\n+\n@@ -206,0 +223,8 @@\n+    public static boolean isSkipRenderer() {\n+        return getBoolean(\"prism.marlin.skip_rdr\", \"false\");\n+    }\n+\n+    public static boolean isSkipRenderTiles() {\n+        return getBoolean(\"prism.marlin.skip_pipe\", \"false\");\n+    }\n+\n@@ -225,0 +250,1 @@\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/MarlinProperties.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -216,1 +216,1 @@\n-        IntArrayCache.fill(alphaDeltas, from, to + 1, 0);\n+        ArrayCacheIntClean.fill(alphaDeltas, from, to + 1, 0);\n@@ -378,2 +378,2 @@\n-            IntArrayCache.check(blkFlags, blkW, blkE, 0);\n-            IntArrayCache.check(alphaDeltas, from, to + 1, 0);\n+            ArrayCacheIntClean.check(blkFlags, blkW, blkE, 0);\n+            ArrayCacheIntClean.check(alphaDeltas, from, to + 1, 0);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/MaskMarlinAlphaConsumer.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.util.Arrays;\n+import static com.sun.marlin.DualPivotQuicksort20191112Ext.sort;\n+\n@@ -35,2 +38,16 @@\n-    \/\/ insertion sort threshold\n-    public static final int INSERTION_SORT_THRESHOLD = 14;\n+    static final boolean USE_DPQS = MarlinProperties.isUseDPQS();\n+\n+    static final String SORT_TYPE = USE_DPQS ? \"DPQS_20191112\" : \"MERGE\";\n+\n+    static final int DPQS_THRESHOLD = 256;\n+    static final int DISABLE_ISORT_THRESHOLD = 1000;\n+\n+    private static final boolean CHECK_SORTED = false;\n+\n+    static {\n+        MarlinUtils.logInfo(\"MergeSort: DPQS_THRESHOLD: \" + DPQS_THRESHOLD);\n+        MarlinUtils.logInfo(\"MergeSort: DISABLE_ISORT_THRESHOLD: \" + DISABLE_ISORT_THRESHOLD);\n+        if (CHECK_SORTED) {\n+            MarlinUtils.logInfo(\"MergeSort: CHECK_SORTED: \" + CHECK_SORTED);\n+        }\n+    }\n@@ -47,1 +64,4 @@\n-                                final int insertionSortIndex)\n+                                final int insertionSortIndex,\n+                                final boolean skipISort,\n+                                final DPQSSorterContext sorter,\n+                                final boolean useDPQS)\n@@ -53,1 +73,23 @@\n-                                                     + toIndex);\n+                    + toIndex);\n+        }\n+        if (skipISort) {\n+            if (useDPQS) {\n+                \/\/ sort full x\/y in-place\n+                sort(sorter, x, auxX, y, auxY, 0, toIndex);\n+            } else {\n+                \/\/ sort full auxX\/auxY into x\/y\n+                mergeSort(auxX, auxY, auxX, x, auxY, y, 0, toIndex);\n+            }\n+            if (CHECK_SORTED) {\n+                checkRange(x, 0, toIndex);\n+            }\n+            return;\n+        } else {\n+            if (useDPQS) {\n+                \/\/ sort auxX\/auxY in-place\n+                sort(sorter, auxX, x, auxY, y, insertionSortIndex, toIndex);\n+            } else {\n+                \/\/ sort second part only using merge sort\n+                \/\/ x\/y into auxiliary storage (auxX\/auxY)\n+                mergeSort(x, y, x, auxX, y, auxY, insertionSortIndex, toIndex);\n+            }\n@@ -55,4 +97,0 @@\n-\n-        \/\/ sort second part only using merge \/ insertion sort\n-        \/\/ in auxiliary storage (auxX\/auxY)\n-        mergeSort(x, y, x, auxX, y, auxY, insertionSortIndex, toIndex);\n@@ -62,9 +100,0 @@\n-        if ((insertionSortIndex == 0)\n-            || (auxX[insertionSortIndex - 1] <= auxX[insertionSortIndex])) {\n-            \/\/ 34 occurences\n-            \/\/ no initial left part or both sublists (auxX, auxY) are sorted:\n-            \/\/ copy back data into (x, y):\n-            System.arraycopy(auxX, 0, x, 0, toIndex);\n-            System.arraycopy(auxY, 0, y, 0, toIndex);\n-            return;\n-        }\n@@ -74,1 +103,1 @@\n-                                   && (auxX[p] <= auxX[q]))) {\n+                    && (auxX[p] <= auxX[q]))) {\n@@ -84,0 +113,4 @@\n+\n+        if (CHECK_SORTED) {\n+            checkRange(x, 0, toIndex);\n+        }\n@@ -86,0 +119,3 @@\n+    \/\/ insertion sort threshold for MergeSort()\n+    static final int INSERTION_SORT_THRESHOLD = 14;\n+\n@@ -174,0 +210,9 @@\n+\n+    private static void checkRange(int[] x, int lo, int hi) {\n+        for (int i = lo + 1; i < hi; i++) {\n+            if (x[i - 1] > x[i]) {\n+                MarlinUtils.logInfo(\"Bad sorted x [\" + (i - 1) + \"]\" + Arrays.toString(Arrays.copyOf(x, hi)));\n+                return;\n+            }\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/MergeSort.java","additions":64,"deletions":19,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        MarlinUtils.getCleaner().register(parent, () -> this.free());\n+        MarlinUtils.getCleaner().register(parent, this::free);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/OffHeapArray.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    static final boolean DISABLE_RENDER = false;\n+    static final boolean DISABLE_RENDER = MarlinProperties.isSkipRenderer();\n@@ -133,1 +133,1 @@\n-    private final IntArrayCache.Reference crossings_ref;\n+    private final ArrayCacheInt.Reference crossings_ref;\n@@ -135,1 +135,1 @@\n-    private final IntArrayCache.Reference edgePtrs_ref;\n+    private final ArrayCacheInt.Reference edgePtrs_ref;\n@@ -138,1 +138,1 @@\n-    private final IntArrayCache.Reference aux_crossings_ref;\n+    private final ArrayCacheInt.Reference aux_crossings_ref;\n@@ -140,1 +140,1 @@\n-    private final IntArrayCache.Reference aux_edgePtrs_ref;\n+    private final ArrayCacheInt.Reference aux_edgePtrs_ref;\n@@ -160,1 +160,1 @@\n-    private final IntArrayCache.Reference edgeBuckets_ref;\n+    private final ArrayCacheIntClean.Reference edgeBuckets_ref;\n@@ -162,1 +162,1 @@\n-    private final IntArrayCache.Reference edgeBucketCounts_ref;\n+    private final ArrayCacheIntClean.Reference edgeBucketCounts_ref;\n@@ -499,1 +499,1 @@\n-    private final IntArrayCache.Reference alphaLine_ref;\n+    private final ArrayCacheIntClean.Reference alphaLine_ref;\n@@ -508,1 +508,1 @@\n-    private final IntArrayCache.Reference blkFlags_ref;\n+    private final ArrayCacheIntClean.Reference blkFlags_ref;\n@@ -603,2 +603,6 @@\n-        crossings = crossings_ref.putArray(crossings);\n-        aux_crossings = aux_crossings_ref.putArray(aux_crossings);\n+        if (crossings_ref.doCleanRef(crossings)) {\n+            crossings = crossings_ref.putArray(crossings);\n+        }\n+        if (aux_crossings_ref.doCleanRef(aux_crossings)) {\n+            aux_crossings = aux_crossings_ref.putArray(aux_crossings);\n+        }\n@@ -606,2 +610,6 @@\n-        edgePtrs = edgePtrs_ref.putArray(edgePtrs);\n-        aux_edgePtrs = aux_edgePtrs_ref.putArray(aux_edgePtrs);\n+        if (edgePtrs_ref.doCleanRef(edgePtrs)) {\n+            edgePtrs = edgePtrs_ref.putArray(edgePtrs);\n+        }\n+        if (aux_edgePtrs_ref.doCleanRef(aux_edgePtrs)) {\n+            aux_edgePtrs = aux_edgePtrs_ref.putArray(aux_edgePtrs);\n+        }\n@@ -609,2 +617,6 @@\n-        alphaLine = alphaLine_ref.putArray(alphaLine, 0, 0); \/\/ already zero filled\n-        blkFlags  = blkFlags_ref.putArray(blkFlags, 0, 0); \/\/ already zero filled\n+        if (alphaLine_ref.doSetRef(alphaLine)) {\n+            alphaLine = alphaLine_ref.putArrayClean(alphaLine); \/\/ already zero filled\n+        }\n+        if (blkFlags_ref.doSetRef(blkFlags)) {\n+            blkFlags  = blkFlags_ref.putArrayClean(blkFlags); \/\/ already zero filled\n+        }\n@@ -628,2 +640,6 @@\n-            edgeBuckets = edgeBuckets_ref.putArray(edgeBuckets, 0, 0);\n-            edgeBucketCounts = edgeBucketCounts_ref.putArray(edgeBucketCounts, 0, 0);\n+            if (edgeBuckets_ref.doSetRef(edgeBuckets)) {\n+                edgeBuckets = edgeBuckets_ref.putArrayClean(edgeBuckets);\n+            }\n+            if (edgeBucketCounts_ref.doSetRef(edgeBucketCounts)) {\n+                edgeBucketCounts = edgeBucketCounts_ref.putArrayClean(edgeBucketCounts);\n+            }\n@@ -707,1 +723,1 @@\n-        if (x0 != sx0 || y0 != sy0) {\n+        if ((x0 != sx0) || (y0 != sy0)) {\n@@ -814,0 +830,2 @@\n+        final DPQSSorterContext sorter = rdrCtx.sorterCtx;\n+        boolean skipISort, useDPQS;\n@@ -826,1 +844,1 @@\n-                    rdrCtx.stats.stat_rdr_activeEdges_updates.add(numCrossings);\n+                    rdrCtx.stats.stat_rdr_activeEdges_updates.add(prevNumCrossings);\n@@ -835,1 +853,1 @@\n-                    for (i = 0, newCount = 0; i < numCrossings; i++) {\n+                    for (i = 0, newCount = 0; i < prevNumCrossings; i++) {\n@@ -863,1 +881,1 @@\n-                            = edgePtrs_ref.widenArray(_edgePtrs, numCrossings,\n+                            = edgePtrs_ref.widenArray(_edgePtrs, edgePtrsLen, \/\/ bad mark ? TODO: fix edge ptr mark\n@@ -932,1 +950,1 @@\n-                if ((ptrLen < 10) || (numCrossings < 40)) {\n+                if (((numCrossings <= 40) || ((ptrLen <= 10) && (numCrossings <= MergeSort.DISABLE_ISORT_THRESHOLD)))) {\n@@ -1018,1 +1036,1 @@\n-                                _edgePtrs[i] = _edgePtrs[j];\n+                                _edgePtrs[i]  = _edgePtrs[j];\n@@ -1045,0 +1063,7 @@\n+                    skipISort = (prevNumCrossings >= MergeSort.DISABLE_ISORT_THRESHOLD);\n+                    useDPQS   = MergeSort.USE_DPQS && (skipISort || (ptrLen >= MergeSort.DPQS_THRESHOLD));\n+\n+                    if (DO_STATS && useDPQS) {\n+                        rdrCtx.stats.stat_rdr_crossings_dpqs.add((skipISort) ? numCrossings : ptrLen);\n+                    }\n+\n@@ -1081,8 +1106,10 @@\n-                        if (i >= prevNumCrossings) {\n-                            \/\/ simply store crossing as edgePtrs is in-place:\n-                            \/\/ will be copied and sorted efficiently by mergesort later:\n-                            _crossings[i]     = cross;\n-\n-                        } else if (cross < lastCross) {\n-                            if (DO_STATS) {\n-                                rdrCtx.stats.stat_rdr_crossings_sorts.add(i);\n+                        if (skipISort) {\n+                            if (useDPQS) {\n+                                \/\/ simply store crossing as edgePtrs is in-place:\n+                                \/\/ will be sorted efficiently by DPQS later:\n+                                _crossings[i]     = cross;\n+                            } else {\n+                                \/\/ store crossing\/edgePtrs in auxiliary arrays:\n+                                \/\/ will be sorted efficiently by MergeSort later:\n+                                _aux_crossings[i] = cross;\n+                                _aux_edgePtrs [i] = ecur;\n@@ -1090,9 +1117,10 @@\n-\n-                            \/\/ (straight) insertion sort of crossings:\n-                            j = i - 1;\n-                            _aux_crossings[i] = _aux_crossings[j];\n-                            _aux_edgePtrs[i] = _aux_edgePtrs[j];\n-\n-                            while ((--j >= 0) && (_aux_crossings[j] > cross)) {\n-                                _aux_crossings[j + 1] = _aux_crossings[j];\n-                                _aux_edgePtrs [j + 1] = _aux_edgePtrs[j];\n+                        } else if (i >= prevNumCrossings) {\n+                            if (useDPQS) {\n+                                \/\/ store crossing\/edgePtrs in auxiliary arrays:\n+                                \/\/ will be sorted efficiently by DPQS later:\n+                                _aux_crossings[i] = cross;\n+                                _aux_edgePtrs [i] = ecur;\n+                            } else {\n+                                \/\/ simply store crossing as edgePtrs is in-place:\n+                                \/\/ will be sorted efficiently by MergeSort later:\n+                                _crossings[i]      = cross;\n@@ -1100,3 +1128,0 @@\n-                            _aux_crossings[j + 1] = cross;\n-                            _aux_edgePtrs [j + 1] = ecur;\n-\n@@ -1104,3 +1129,20 @@\n-                            \/\/ auxiliary storage:\n-                            _aux_crossings[i] = lastCross = cross;\n-                            _aux_edgePtrs [i] = ecur;\n+                            if (cross < lastCross) {\n+                                if (DO_STATS) {\n+                                    rdrCtx.stats.stat_rdr_crossings_sorts.add(i);\n+                                }\n+                                \/\/ (straight) insertion sort of crossings:\n+                                j = i - 1;\n+                                _aux_crossings[i] = _aux_crossings[j];\n+                                _aux_edgePtrs [i]  = _aux_edgePtrs[j];\n+\n+                                while ((--j >= 0) && (_aux_crossings[j] > cross)) {\n+                                    _aux_crossings[j + 1] = _aux_crossings[j];\n+                                    _aux_edgePtrs [j + 1] = _aux_edgePtrs[j];\n+                                }\n+                                _aux_crossings[j + 1] = cross;\n+                                _aux_edgePtrs [j + 1] = ecur;\n+                            } else {\n+                                \/\/ auxiliary storage:\n+                                _aux_crossings[i] = lastCross = cross;\n+                                _aux_edgePtrs [i] = ecur;\n+                            }\n@@ -1113,1 +1155,3 @@\n-                                              numCrossings,   prevNumCrossings);\n+                                              numCrossings, prevNumCrossings,\n+                                              skipISort, sorter, useDPQS\n+                                            );\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/Renderer.java","additions":91,"deletions":47,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.marlin.ArrayCacheIntClean;\n@@ -51,2 +52,1 @@\n-        return new RendererContext(\"ctx\"\n-                       + Integer.toString(CTX_COUNT.getAndIncrement()));\n+        return new RendererContext(\"ctx\" + CTX_COUNT.getAndIncrement());\n@@ -86,0 +86,5 @@\n+    \/\/ bit flags indicating to skip the stroker to process joins\n+    \/\/ bits: 2 : Dasher CurveClipSplitter\n+    \/\/ bits: 1 : Dasher CurveBasicMonotonizer\n+    \/\/ bits: 0 : Stroker CurveClipSplitter\n+    public int firstFlags = 0;\n@@ -88,0 +93,2 @@\n+    \/\/ DPQS Sorter context\n+    final DPQSSorterContext sorterCtx;\n@@ -100,1 +107,1 @@\n-    private final IntArrayCache cleanIntCache = new IntArrayCache(true, 5);\n+    private final ArrayCacheIntClean cleanIntCache = new ArrayCacheIntClean(5);\n@@ -102,1 +109,1 @@\n-    private final IntArrayCache dirtyIntCache = new IntArrayCache(false, 5);\n+    private final ArrayCacheInt dirtyIntCache = new ArrayCacheInt(5);\n@@ -104,1 +111,1 @@\n-    private final DoubleArrayCache dirtyDoubleCache = new DoubleArrayCache(false, 4);\n+    private final ArrayCacheDouble dirtyDoubleCache = new ArrayCacheDouble(4);\n@@ -106,1 +113,1 @@\n-    private final ByteArrayCache dirtyByteCache = new ByteArrayCache(false, 2);\n+    private final ArrayCacheByte dirtyByteCache = new ArrayCacheByte(2);\n@@ -148,0 +155,2 @@\n+\n+        sorterCtx = (MergeSort.USE_DPQS) ? new DPQSSorterContext() : null;\n@@ -165,0 +174,1 @@\n+        firstFlags = 0;\n@@ -211,1 +221,1 @@\n-    IntArrayCache.Reference newCleanIntArrayRef(final int initialSize) {\n+    ArrayCacheIntClean.Reference newCleanIntArrayRef(final int initialSize) {\n@@ -215,1 +225,1 @@\n-    IntArrayCache.Reference newDirtyIntArrayRef(final int initialSize) {\n+    ArrayCacheInt.Reference newDirtyIntArrayRef(final int initialSize) {\n@@ -219,1 +229,1 @@\n-    DoubleArrayCache.Reference newDirtyDoubleArrayRef(final int initialSize) {\n+    ArrayCacheDouble.Reference newDirtyDoubleArrayRef(final int initialSize) {\n@@ -223,1 +233,1 @@\n-    ByteArrayCache.Reference newDirtyByteArrayRef(final int initialSize) {\n+    ArrayCacheByte.Reference newDirtyByteArrayRef(final int initialSize) {\n@@ -233,1 +243,1 @@\n-        final IntArrayCache.Reference edgeBuckets_ref;\n+        final ArrayCacheIntClean.Reference edgeBuckets_ref;\n@@ -235,1 +245,1 @@\n-        final IntArrayCache.Reference edgeBucketCounts_ref;\n+        final ArrayCacheIntClean.Reference edgeBucketCounts_ref;\n@@ -238,1 +248,1 @@\n-        final IntArrayCache.Reference alphaLine_ref;\n+        final ArrayCacheIntClean.Reference alphaLine_ref;\n@@ -241,1 +251,1 @@\n-        final IntArrayCache.Reference crossings_ref;\n+        final ArrayCacheInt.Reference crossings_ref;\n@@ -243,2 +253,2 @@\n-        final IntArrayCache.Reference edgePtrs_ref;\n-        \/\/ merge sort initial arrays\n+        final ArrayCacheInt.Reference edgePtrs_ref;\n+        \/\/ merge sort initial arrays (large enough to satisfy most usages) (1024)\n@@ -246,1 +256,1 @@\n-        final IntArrayCache.Reference aux_crossings_ref;\n+        final ArrayCacheInt.Reference aux_crossings_ref;\n@@ -248,1 +258,1 @@\n-        final IntArrayCache.Reference aux_edgePtrs_ref;\n+        final ArrayCacheInt.Reference aux_edgePtrs_ref;\n@@ -251,1 +261,1 @@\n-        final IntArrayCache.Reference blkFlags_ref;\n+        final ArrayCacheIntClean.Reference blkFlags_ref;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/RendererContext.java","additions":29,"deletions":19,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-    private final IntArrayCache.Reference crossings_ref;\n+    private final ArrayCacheInt.Reference crossings_ref;\n@@ -127,1 +127,1 @@\n-    private final IntArrayCache.Reference edgePtrs_ref;\n+    private final ArrayCacheInt.Reference edgePtrs_ref;\n@@ -130,1 +130,1 @@\n-    private final IntArrayCache.Reference aux_crossings_ref;\n+    private final ArrayCacheInt.Reference aux_crossings_ref;\n@@ -132,1 +132,1 @@\n-    private final IntArrayCache.Reference aux_edgePtrs_ref;\n+    private final ArrayCacheInt.Reference aux_edgePtrs_ref;\n@@ -152,1 +152,1 @@\n-    private final IntArrayCache.Reference edgeBuckets_ref;\n+    private final ArrayCacheIntClean.Reference edgeBuckets_ref;\n@@ -154,1 +154,1 @@\n-    private final IntArrayCache.Reference edgeBucketCounts_ref;\n+    private final ArrayCacheIntClean.Reference edgeBucketCounts_ref;\n@@ -490,1 +490,1 @@\n-    private final IntArrayCache.Reference alphaLine_ref;\n+    private final ArrayCacheIntClean.Reference alphaLine_ref;\n@@ -499,1 +499,1 @@\n-    private final IntArrayCache.Reference blkFlags_ref;\n+    private final ArrayCacheIntClean.Reference blkFlags_ref;\n@@ -797,0 +797,2 @@\n+        final DPQSSorterContext sorter = rdrCtx.sorterCtx;\n+        boolean skipISort, useDPQS;\n@@ -809,1 +811,1 @@\n-                    rdrCtx.stats.stat_rdr_activeEdges_updates.add(numCrossings);\n+                    rdrCtx.stats.stat_rdr_activeEdges_updates.add(prevNumCrossings);\n@@ -818,1 +820,1 @@\n-                    for (i = 0, newCount = 0; i < numCrossings; i++) {\n+                    for (i = 0, newCount = 0; i < prevNumCrossings; i++) {\n@@ -846,1 +848,1 @@\n-                            = edgePtrs_ref.widenArray(_edgePtrs, numCrossings,\n+                            = edgePtrs_ref.widenArray(_edgePtrs, edgePtrsLen, \/\/ bad mark ? TODO: fix edge ptr mark\n@@ -915,1 +917,1 @@\n-                if ((ptrLen < 10) || (numCrossings < 40)) {\n+                if (((numCrossings <= 40) || ((ptrLen <= 10) && (numCrossings <= MergeSort.DISABLE_ISORT_THRESHOLD)))) {\n@@ -1001,1 +1003,1 @@\n-                                _edgePtrs[i] = _edgePtrs[j];\n+                                _edgePtrs[i]  = _edgePtrs[j];\n@@ -1028,0 +1030,7 @@\n+                    skipISort = (prevNumCrossings >= MergeSort.DISABLE_ISORT_THRESHOLD);\n+                    useDPQS   = MergeSort.USE_DPQS && (skipISort || (ptrLen >= MergeSort.DPQS_THRESHOLD));\n+\n+                    if (DO_STATS && useDPQS) {\n+                        rdrCtx.stats.stat_rdr_crossings_dpqs.add((skipISort) ? numCrossings : ptrLen);\n+                    }\n+\n@@ -1064,8 +1073,10 @@\n-                        if (i >= prevNumCrossings) {\n-                            \/\/ simply store crossing as edgePtrs is in-place:\n-                            \/\/ will be copied and sorted efficiently by mergesort later:\n-                            _crossings[i]     = cross;\n-\n-                        } else if (cross < lastCross) {\n-                            if (DO_STATS) {\n-                                rdrCtx.stats.stat_rdr_crossings_sorts.add(i);\n+                        if (skipISort) {\n+                            if (useDPQS) {\n+                                \/\/ simply store crossing as edgePtrs is in-place:\n+                                \/\/ will be sorted efficiently by DPQS later:\n+                                _crossings[i]     = cross;\n+                            } else {\n+                                \/\/ store crossing\/edgePtrs in auxiliary arrays:\n+                                \/\/ will be sorted efficiently by MergeSort later:\n+                                _aux_crossings[i] = cross;\n+                                _aux_edgePtrs [i] = ecur;\n@@ -1073,9 +1084,10 @@\n-\n-                            \/\/ (straight) insertion sort of crossings:\n-                            j = i - 1;\n-                            _aux_crossings[i] = _aux_crossings[j];\n-                            _aux_edgePtrs[i] = _aux_edgePtrs[j];\n-\n-                            while ((--j >= 0) && (_aux_crossings[j] > cross)) {\n-                                _aux_crossings[j + 1] = _aux_crossings[j];\n-                                _aux_edgePtrs [j + 1] = _aux_edgePtrs[j];\n+                        } else if (i >= prevNumCrossings) {\n+                            if (useDPQS) {\n+                                \/\/ store crossing\/edgePtrs in auxiliary arrays:\n+                                \/\/ will be sorted efficiently by DPQS later:\n+                                _aux_crossings[i] = cross;\n+                                _aux_edgePtrs [i] = ecur;\n+                            } else {\n+                                \/\/ simply store crossing as edgePtrs is in-place:\n+                                \/\/ will be sorted efficiently by MergeSort later:\n+                                _crossings[i]      = cross;\n@@ -1083,3 +1095,0 @@\n-                            _aux_crossings[j + 1] = cross;\n-                            _aux_edgePtrs [j + 1] = ecur;\n-\n@@ -1087,3 +1096,20 @@\n-                            \/\/ auxiliary storage:\n-                            _aux_crossings[i] = lastCross = cross;\n-                            _aux_edgePtrs [i] = ecur;\n+                            if (cross < lastCross) {\n+                                if (DO_STATS) {\n+                                    rdrCtx.stats.stat_rdr_crossings_sorts.add(i);\n+                                }\n+                                \/\/ (straight) insertion sort of crossings:\n+                                j = i - 1;\n+                                _aux_crossings[i] = _aux_crossings[j];\n+                                _aux_edgePtrs [i]  = _aux_edgePtrs[j];\n+\n+                                while ((--j >= 0) && (_aux_crossings[j] > cross)) {\n+                                    _aux_crossings[j + 1] = _aux_crossings[j];\n+                                    _aux_edgePtrs [j + 1] = _aux_edgePtrs[j];\n+                                }\n+                                _aux_crossings[j + 1] = cross;\n+                                _aux_edgePtrs [j + 1] = ecur;\n+                            } else {\n+                                \/\/ auxiliary storage:\n+                                _aux_crossings[i] = lastCross = cross;\n+                                _aux_edgePtrs [i] = ecur;\n+                            }\n@@ -1096,1 +1122,3 @@\n-                                              numCrossings,   prevNumCrossings);\n+                                              numCrossings, prevNumCrossings,\n+                                              skipISort, sorter, useDPQS\n+                                            );\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/RendererNoAA.java","additions":65,"deletions":37,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -103,0 +103,2 @@\n+    final StatLong stat_rdr_crossings_dpqs\n+        = new StatLong(\"renderer.crossings.dpqs\");\n@@ -198,0 +200,1 @@\n+        stat_rdr_crossings_dpqs,\n@@ -336,1 +339,1 @@\n-        private static volatile RendererStatsHolder SINGLETON = null;\n+        private static volatile RendererStatsHolder SINGLETON;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/RendererStats.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import com.sun.marlin.TransformingPathConsumer2D.StartFlagPathConsumer2D;\n@@ -36,1 +37,1 @@\n-public final class Stroker implements DPathConsumer2D, MarlinConst {\n+public final class Stroker implements StartFlagPathConsumer2D, MarlinConst {\n@@ -42,3 +43,6 @@\n-    \/\/ round join threshold = 1 subpixel\n-    private static final double ERR_JOIN = (1.0f \/ MIN_SUBPIXELS);\n-    private static final double ROUND_JOIN_THRESHOLD = ERR_JOIN * ERR_JOIN;\n+    \/\/ join threshold = 1 subpixel (1\/8th pixel):\n+    private static final double JOIN_ERROR = MarlinProperties.getStrokerJoinError();\n+\n+    private static final double ROUND_JOIN_ERROR = 8.0 * JOIN_ERROR; \/\/ (8 h)\n+\n+    private static final int JOIN_STYLE = MarlinProperties.getStrokerJoinStyle();\n@@ -52,0 +56,1 @@\n+    \/\/ members:\n@@ -65,0 +70,1 @@\n+    private double joinLimitMinSq;\n@@ -159,1 +165,13 @@\n-        this.joinStyle = joinStyle;\n+        this.joinStyle = (JOIN_STYLE != -1) ? JOIN_STYLE : joinStyle;\n+\n+        double miterScaledLimit = 0.0;\n+\n+        if (joinStyle == JOIN_MITER) {\n+            miterScaledLimit = miterLimit * lineWidth2;\n+            this.miterLimitSq = miterScaledLimit * miterScaledLimit;\n+\n+            final double limitMin = ((this.rdrCtx.clipInvScale == 0.0d) ? JOIN_ERROR\n+                    : (JOIN_ERROR * this.rdrCtx.clipInvScale))\n+                    + lineWidth2;\n+\n+            this.joinLimitMinSq = limitMin * limitMin;\n@@ -161,2 +179,6 @@\n-        final double limit = miterLimit * lineWidth2;\n-        this.miterLimitSq = limit * limit;\n+        } else if (joinStyle == JOIN_ROUND) {\n+            \/\/ chord:  s = 2 r * sin( phi \/ 2)\n+            \/\/ height: h = 2 r * sin( phi \/ 4)^2\n+            \/\/ small angles (phi < 90):\n+            \/\/ h = s \/ (8 r)\n+            \/\/ so s = (8 h * r)\n@@ -164,0 +186,7 @@\n+            \/\/ height max (note ROUND_JOIN_ERROR = 8 * JOIN_ERROR)\n+            final double limitMin = ((this.rdrCtx.clipInvScale == 0.0d) ? ROUND_JOIN_ERROR\n+                    : (ROUND_JOIN_ERROR * this.rdrCtx.clipInvScale));\n+\n+            \/\/ chord limit (s):\n+            this.joinLimitMinSq = limitMin * this.lineWidth2;\n+        }\n@@ -175,2 +204,2 @@\n-            if ((joinStyle == JOIN_MITER) && (margin < limit)) {\n-                margin = limit;\n+            if ((joinStyle == JOIN_MITER) && (margin < miterScaledLimit)) {\n+                margin = miterScaledLimit;\n@@ -272,1 +301,0 @@\n-\n@@ -275,1 +303,1 @@\n-        final double lenSq = domx*domx + domy*domy;\n+        final double lenSq = domx * domx + domy * domy;\n@@ -277,1 +305,1 @@\n-        if (lenSq < ROUND_JOIN_THRESHOLD) {\n+        if (lenSq < joinLimitMinSq) {\n@@ -280,1 +308,0 @@\n-\n@@ -302,1 +329,1 @@\n-        if (cosext >= 0.0d) {\n+        if (cosext >= 0.0) {\n@@ -319,3 +346,4 @@\n-            double nx = my - omy, ny = omx - mx;\n-            double nlen = Math.sqrt(nx*nx + ny*ny);\n-            double scale = lineWidth2\/nlen;\n+            final double nx = my - omy;\n+            final double ny = omx - mx;\n+            final double nlen = Math.sqrt(nx * nx + ny * ny);\n+            final double scale = lineWidth2 \/ nlen;\n@@ -475,1 +503,1 @@\n-        double lenSq = (miterX-x0)*(miterX-x0) + (miterY-y0)*(miterY-y0);\n+        final double lenSq = (miterX - x0) * (miterX - x0) + (miterY - y0) * (miterY - y0);\n@@ -482,1 +510,1 @@\n-        if (lenSq < miterLimitSq) {\n+        if ((lenSq < miterLimitSq) && (lenSq >= joinLimitMinSq)) {\n@@ -523,0 +551,1 @@\n+    \/* Callback from CurveClipSplitter *\/\n@@ -524,2 +553,7 @@\n-    public void lineTo(final double x1, final double y1) {\n-        lineTo(x1, y1, false);\n+    public void setStartFlag(boolean first) {\n+        if (first) {\n+            \/\/ reset flag:\n+            rdrCtx.firstFlags &= 0b110;\n+        } else {\n+            rdrCtx.firstFlags |= 0b001;\n+        }\n@@ -528,3 +562,2 @@\n-    private void lineTo(final double x1, final double y1,\n-                        final boolean force)\n-    {\n+    @Override\n+    public void lineTo(final double x1, final double y1) {\n@@ -533,1 +566,1 @@\n-        if (!force && clipRect != null) {\n+        if (clipRect != null) {\n@@ -619,2 +652,3 @@\n-            if (cx0 != sx0 || cy0 != sy0) {\n-                lineTo(sx0, sy0, true);\n+            if ((cx0 != sx0) || (cy0 != sy0)) {\n+                \/\/ may subdivide line:\n+                lineTo(sx0, sy0);\n@@ -623,1 +657,3 @@\n-            drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy, sOutCode);\n+            \/\/ ignore starting point outside:\n+            if (sOutCode == 0) {\n+                drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy, sOutCode);\n@@ -625,1 +661,1 @@\n-            emitLineTo(sx0 + smx, sy0 + smy);\n+                emitLineTo(sx0 + smx, sy0 + smy);\n@@ -627,4 +663,5 @@\n-            if (opened) {\n-                emitLineTo(sx0 - smx, sy0 - smy);\n-            } else {\n-                emitMoveTo(sx0 - smx, sy0 - smy);\n+                if (opened) {\n+                    emitLineTo(sx0 - smx, sy0 - smy);\n+                } else {\n+                    emitMoveTo(sx0 - smx, sy0 - smy);\n+                }\n@@ -777,0 +814,1 @@\n+            prev = DRAWING_OP_TO;\n@@ -784,1 +822,2 @@\n-        } else {\n+        } else if (rdrCtx.firstFlags == 0) {\n+            \/\/ Precision on isCW is causing instabilities with Dasher !\n@@ -795,12 +834,0 @@\n-        prev = DRAWING_OP_TO;\n-    }\n-\n-    private static boolean within(final double x1, final double y1,\n-                                  final double x2, final double y2,\n-                                  final double err)\n-    {\n-        assert err > 0 : \"\";\n-        \/\/ compare taxicab distance. ERR will always be small, so using\n-        \/\/ true distance won't give much benefit\n-        return (Helpers.within(x1, x2, err) && \/\/ we want to avoid calling Math.abs\n-                Helpers.within(y1, y2, err));  \/\/ this is just as good.\n@@ -809,3 +836,3 @@\n-    private void getLineOffsets(final double x1, final double y1,\n-                                final double x2, final double y2,\n-                                final double[] left, final double[] right)\n+    private int getLineOffsets(final double x1, final double y1,\n+                               final double x2, final double y2,\n+                               final double[] left, final double[] right)\n@@ -825,0 +852,2 @@\n+\n+        return 4;\n@@ -838,4 +867,4 @@\n-        final double x1 = pts[off    ], y1 = pts[off + 1];\n-        final double x2 = pts[off + 2], y2 = pts[off + 3];\n-        final double x3 = pts[off + 4], y3 = pts[off + 5];\n-        final double x4 = pts[off + 6], y4 = pts[off + 7];\n+        final double x1 = pts[off    ]; final double y1 = pts[off + 1];\n+        final double x2 = pts[off + 2]; final double y2 = pts[off + 3];\n+        final double x3 = pts[off + 4]; final double y3 = pts[off + 5];\n+        final double x4 = pts[off + 6]; final double y4 = pts[off + 7];\n@@ -843,4 +872,2 @@\n-        double dx4 = x4 - x3;\n-        double dy4 = y4 - y3;\n-        double dx1 = x2 - x1;\n-        double dy1 = y2 - y1;\n+        double dx1 = x2 - x1; double dy1 = y2 - y1;\n+        double dx4 = x4 - x3; double dy4 = y4 - y3;\n@@ -850,2 +877,2 @@\n-        final boolean p1eqp2 = within(x1, y1, x2, y2, 6.0d * Math.ulp(y2));\n-        final boolean p3eqp4 = within(x3, y3, x4, y4, 6.0d * Math.ulp(y4));\n+        final boolean p1eqp2 = Helpers.withinD(dx1, dy1, 6.0d * Math.ulp(y2));\n+        final boolean p3eqp4 = Helpers.withinD(dx4, dy4, 6.0d * Math.ulp(y4));\n@@ -854,2 +881,1 @@\n-            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);\n-            return 4;\n+            return getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);\n@@ -867,1 +893,2 @@\n-        double l1sq = dx1 * dx1 + dy1 * dy1, l4sq = dx4 * dx4 + dy4 * dy4;\n+        final double l1sq = dx1 * dx1 + dy1 * dy1;\n+        final double l4sq = dx4 * dx4 + dy4 * dy4;\n@@ -870,2 +897,1 @@\n-            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);\n-            return 4;\n+            return getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);\n@@ -921,2 +947,2 @@\n-        double x = (x1 + 3.0d * (x2 + x3) + x4) \/ 8.0d;\n-        double y = (y1 + 3.0d * (y2 + y3) + y4) \/ 8.0d;\n+        final double xm = (x1 + x4 + 3.0d * (x2 + x3)) \/ 8.0d;\n+        final double ym = (y1 + y4 + 3.0d * (y2 + y3)) \/ 8.0d;\n@@ -925,1 +951,2 @@\n-        double dxm = x3 + x4 - x1 - x2, dym = y3 + y4 - y1 - y2;\n+        final double dxm = x3 + x4 - (x1 + x2);\n+        final double dym = y3 + y4 - (y1 + y2);\n@@ -933,0 +960,2 @@\n+\n+        \/\/ left side:\n@@ -935,2 +964,2 @@\n-        double xi  = x  + offset1[0]; \/\/ interpolation\n-        double yi  = y  + offset1[1]; \/\/ point\n+        double xi  = xm + offset1[0]; \/\/ interpolation\n+        double yi  = ym + offset1[1]; \/\/ point\n@@ -940,1 +969,4 @@\n-        double invdet43 = 4.0d \/ (3.0d * (dx1 * dy4 - dy1 * dx4));\n+        final double invdet43 = 4.0d \/ (3.0d * (dx1 * dy4 - dy1 * dx4));\n+\n+        double two_pi_m_p1_m_p4x = 2.0d * xi - (x1p + x4p);\n+        double two_pi_m_p1_m_p4y = 2.0d * yi - (y1p + y4p);\n@@ -942,2 +974,0 @@\n-        double two_pi_m_p1_m_p4x = 2.0d * xi - x1p - x4p;\n-        double two_pi_m_p1_m_p4y = 2.0d * yi - y1p - y4p;\n@@ -948,4 +978,20 @@\n-        x2p = x1p + c1*dx1;\n-        y2p = y1p + c1*dy1;\n-        x3p = x4p + c2*dx4;\n-        y3p = y4p + c2*dy4;\n+\n+        if (c1 * c2 > 0.0) {\n+\/\/            System.out.println(\"Buggy solver (left): c1 = \" + c1 + \" c2 = \" + c2);\n+\n+            \/\/ use lower quality approximation but good enough\n+            \/\/ to ensure cuve being in its convex hull\n+            x2p = x2 + offset1[0]; \/\/ 2nd\n+            y2p = y2 + offset1[1]; \/\/ point\n+            x3p = x3 + offset1[0]; \/\/ 3nd\n+            y3p = y3 + offset1[1]; \/\/ point\n+\n+            safeComputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x2p, y2p, x2p-dxm, y2p-dym, leftOff);\n+            x2p = leftOff[2]; y2p = leftOff[3];\n+\n+            safeComputeMiter(x4p, y4p, x4p+dx4, y4p+dy4, x3p, y3p, x3p-dxm, y3p-dym, leftOff);\n+            x3p = leftOff[2]; y3p = leftOff[3];\n+        } else {\n+            x2p = x1p + c1 * dx1; y2p = y1p + c1 * dy1;\n+            x3p = x4p + c2 * dx4; y3p = y4p + c2 * dy4;\n+        }\n@@ -958,3 +1004,10 @@\n-        x1p = x1 - offset0[0]; y1p = y1 - offset0[1];\n-        xi = xi - 2.0d * offset1[0]; yi = yi - 2.0d * offset1[1];\n-        x4p = x4 - offset2[0]; y4p = y4 - offset2[1];\n+        \/\/ Right side:\n+        x1p = x1 - offset0[0]; \/\/ start\n+        y1p = y1 - offset0[1]; \/\/ point\n+        xi =  xm  - offset1[0]; \/\/ interpolation\n+        yi =  ym  - offset1[1]; \/\/ point\n+        x4p = x4 - offset2[0]; \/\/ end\n+        y4p = y4 - offset2[1]; \/\/ point\n+\n+        two_pi_m_p1_m_p4x = 2.0d * xi - (x1p + x4p);\n+        two_pi_m_p1_m_p4y = 2.0d * yi - (y1p + y4p);\n@@ -962,2 +1015,0 @@\n-        two_pi_m_p1_m_p4x = 2.0d * xi - x1p - x4p;\n-        two_pi_m_p1_m_p4y = 2.0d * yi - y1p - y4p;\n@@ -967,4 +1018,19 @@\n-        x2p = x1p + c1*dx1;\n-        y2p = y1p + c1*dy1;\n-        x3p = x4p + c2*dx4;\n-        y3p = y4p + c2*dy4;\n+        if (c1 * c2 > 0.0) {\n+\/\/            System.out.println(\"Buggy solver (right): c1 = \" + c1 + \" c2 = \" + c2);\n+\n+            \/\/ use lower quality approximation but good enough\n+            \/\/ to ensure cuve being in its convex hull\n+            x2p = x2 - offset1[0]; \/\/ 2nd\n+            y2p = y2 - offset1[1]; \/\/ point\n+            x3p = x3 - offset1[0]; \/\/ 3nd\n+            y3p = y3 - offset1[1]; \/\/ point\n+\n+            safeComputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x2p, y2p, x2p-dxm, y2p-dym, rightOff);\n+            x2p = rightOff[2]; y2p = rightOff[3];\n+\n+            safeComputeMiter(x4p, y4p, x4p+dx4, y4p+dy4, x3p, y3p, x3p-dxm, y3p-dym, rightOff);\n+            x3p = rightOff[2]; y3p = rightOff[3];\n+        } else {\n+            x2p = x1p + c1 * dx1; y2p = y1p + c1 * dy1;\n+            x3p = x4p + c2 * dx4; y3p = y4p + c2 * dy4;\n+        }\n@@ -976,0 +1042,1 @@\n+\n@@ -986,3 +1053,3 @@\n-        final double x1 = pts[off    ], y1 = pts[off + 1];\n-        final double x2 = pts[off + 2], y2 = pts[off + 3];\n-        final double x3 = pts[off + 4], y3 = pts[off + 5];\n+        final double x1 = pts[off    ]; final double y1 = pts[off + 1];\n+        final double x2 = pts[off + 2]; final double y2 = pts[off + 3];\n+        final double x3 = pts[off + 4]; final double y3 = pts[off + 5];\n@@ -990,4 +1057,2 @@\n-        final double dx3 = x3 - x2;\n-        final double dy3 = y3 - y2;\n-        final double dx1 = x2 - x1;\n-        final double dy1 = y2 - y1;\n+        final double dx12 = x2 - x1; final double dy12 = y2 - y1;\n+        final double dx23 = x3 - x2; final double dy23 = y3 - y2;\n@@ -995,1 +1060,1 @@\n-        \/\/ if p1=p2 or p3=p4 it means that the derivative at the endpoint\n+        \/\/ if p1=p2 or p2=p3 it means that the derivative at the endpoint\n@@ -1003,4 +1068,3 @@\n-        \/\/ if p1 == p2 && p3 == p4: draw line from p1->p4, unless p1 == p4,\n-        \/\/ in which case ignore.\n-        final boolean p1eqp2 = within(x1, y1, x2, y2, 6.0d * Math.ulp(y2));\n-        final boolean p2eqp3 = within(x2, y2, x3, y3, 6.0d * Math.ulp(y3));\n+        \/\/ if p1 == p2 or p2 == p3: draw line from p1->p3\n+        final boolean p1eqp2 = Helpers.withinD(dx12, dy12, 6.0d * Math.ulp(y2));\n+        final boolean p2eqp3 = Helpers.withinD(dx23, dy23, 6.0d * Math.ulp(y3));\n@@ -1009,2 +1073,1 @@\n-            getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);\n-            return 4;\n+            return getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);\n@@ -1013,2 +1076,2 @@\n-        \/\/ if p2-p1 and p4-p3 are parallel, that must mean this curve is a line\n-        double dotsq = (dx1 * dx3 + dy1 * dy3);\n+        \/\/ if p2-p1 and p3-p2 are parallel, that must mean this curve is a line\n+        double dotsq = (dx12 * dx23 + dy12 * dy23);\n@@ -1016,1 +1079,2 @@\n-        double l1sq = dx1 * dx1 + dy1 * dy1, l3sq = dx3 * dx3 + dy3 * dy3;\n+        final double l1sq = dx12 * dx12 + dy12 * dy12;\n+        final double l3sq = dx23 * dx23 + dy23 * dy23;\n@@ -1019,2 +1083,1 @@\n-            getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);\n-            return 4;\n+            return getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);\n@@ -1024,1 +1087,1 @@\n-        \/\/ for any bezier curve the vectors p2-p1 and p4-p3 are parallel to\n+        \/\/ for any bezier curve the vectors p2-p1 and p3-p2 are parallel to\n@@ -1026,2 +1089,2 @@\n-        computeOffset(dx1, dy1, lineWidth2, offset0);\n-        computeOffset(dx3, dy3, lineWidth2, offset1);\n+        computeOffset(dx12, dy12, lineWidth2, offset0);\n+        computeOffset(dx23, dy23, lineWidth2, offset1);\n@@ -1033,1 +1096,2 @@\n-        safeComputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, leftOff);\n+\n+        safeComputeMiter(x1p, y1p, x1p+dx12, y1p+dy12, x3p, y3p, x3p-dx23, y3p-dy23, leftOff);\n@@ -1037,3 +1101,6 @@\n-        x1p = x1 - offset0[0]; y1p = y1 - offset0[1];\n-        x3p = x3 - offset1[0]; y3p = y3 - offset1[1];\n-        safeComputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, rightOff);\n+        x1p = x1 - offset0[0]; \/\/ start\n+        y1p = y1 - offset0[1]; \/\/ point\n+        x3p = x3 - offset1[0]; \/\/ end\n+        y3p = y3 - offset1[1]; \/\/ point\n+\n+        safeComputeMiter(x1p, y1p, x1p+dx12, y1p+dy12, x3p, y3p, x3p-dx23, y3p-dy23, rightOff);\n@@ -1042,0 +1109,1 @@\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/Stroker.java","additions":179,"deletions":111,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -495,1 +495,7 @@\n-    static final class PathClipFilter implements DPathConsumer2D {\n+    static final class PathClipFilter implements StartFlagPathConsumer2D {\n+\n+        private static final boolean TRACE = false;\n+\n+        private static final int MOVE_TO = 0;\n+        private static final int DRAWING_OP_TO = 1; \/\/ ie. curve, line, or quad\n+        private static final int CLOSE = 2;\n@@ -499,0 +505,2 @@\n+        private int prev;\n+\n@@ -510,0 +518,3 @@\n+        \/\/ the outcode of the starting point\n+        private int sOutCode = 0;\n+\n@@ -518,1 +529,1 @@\n-        \/\/ The current point (TODO stupid repeated info)\n+        \/\/ The current point\n@@ -521,3 +532,0 @@\n-        \/\/ The current point OUTSIDE\n-        private double cox0, coy0;\n-\n@@ -549,0 +557,1 @@\n+            this.prev = CLOSE;\n@@ -562,8 +571,6 @@\n-            if (outside) {\n-                \/\/ criteria: inside or totally outside ?\n-                if (gOutCode == 0) {\n-                    finish();\n-                } else {\n-                    this.outside = false;\n-                    stack.reset();\n-                }\n+            \/\/ criteria: inside or totally outside ?\n+            if (gOutCode == 0) {\n+                finish();\n+            } else {\n+                this.outside = false;\n+                stack.reset();\n@@ -595,1 +602,2 @@\n-                stack.pullAll(corners, out);\n+                stack.pullAll(corners, out, (prev == MOVE_TO));\n+                prev = DRAWING_OP_TO;\n@@ -597,3 +605,0 @@\n-            out.lineTo(cox0, coy0);\n-            this.cx0 = cox0;\n-            this.cy0 = coy0;\n@@ -604,1 +609,4 @@\n-            finishPath();\n+            if (TRACE) {\n+                MarlinUtils.logInfo(\"PathDone(\" + sx0 + \", \" + sy0 + \") prev: \" + prev);\n+            }\n+            _closePath();\n@@ -606,0 +614,1 @@\n+            \/\/ note: renderer's pathDone() must handle missing moveTo() if outside\n@@ -608,0 +617,4 @@\n+            \/\/ this shouldn't matter since this object won't be used\n+            \/\/ after the call to this method.\n+            this.prev = CLOSE;\n+\n@@ -615,1 +628,4 @@\n-            finishPath();\n+            if (TRACE) {\n+                MarlinUtils.logInfo(\"ClosePath(\" + sx0 + \", \" + sy0 + \") prev: \" + prev);\n+            }\n+            _closePath();\n@@ -617,1 +633,10 @@\n-            out.closePath();\n+            if (prev == DRAWING_OP_TO) {\n+                out.closePath();\n+            }\n+\n+            \/\/ if outside, moveTo is needed\n+            if (sOutCode != 0) {\n+                this.prev = MOVE_TO;\n+            } else {\n+                this.prev = CLOSE;\n+            }\n@@ -620,1 +645,1 @@\n-            this.cOutCode = Helpers.outcode(sx0, sy0, clipRect);\n+            this.cOutCode = sOutCode;\n@@ -625,0 +650,25 @@\n+        private void _closePath() {\n+            \/\/ preserve outside flag for the lineTo call below\n+            final boolean prevOutside = outside;\n+            if (prevOutside) {\n+                finishPath();\n+            }\n+\n+            if (prev == DRAWING_OP_TO) {\n+                \/\/ Should clip\n+                final int orCode = (cOutCode | sOutCode);\n+                if (orCode != 0) {\n+                    if ((cx0 != sx0) || (cy0 != sy0)) {\n+                        \/\/ restore outside flag before lineTo:\n+                        this.outside = prevOutside;\n+                        \/\/ may subdivide line:\n+                        lineTo(sx0, sy0);\n+                        \/\/ finish if outside caused by lineTo:\n+                        if (outside) {\n+                            finishPath();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -627,1 +677,4 @@\n-            finishPath();\n+            if (TRACE) {\n+                MarlinUtils.logInfo(\"MoveTo(\" + x0 + \", \" + y0 + \") prev: \" + prev);\n+            }\n+            _closePath();\n@@ -629,1 +682,1 @@\n-            out.moveTo(x0, y0);\n+            this.prev = MOVE_TO;\n@@ -632,1 +685,3 @@\n-            this.cOutCode = Helpers.outcode(x0, y0, clipRect);\n+            final int outcode = Helpers.outcode(x0, y0, clipRect);\n+            this.cOutCode = outcode;\n+            this.sOutCode = outcode;\n@@ -635,1 +690,0 @@\n-\n@@ -640,0 +694,6 @@\n+        \/* Callback from CurveClipSplitter *\/\n+        @Override\n+        public void setStartFlag(boolean first) {\n+            \/\/ no-op\n+        }\n+\n@@ -645,0 +705,8 @@\n+            if (TRACE) {\n+                if (subdivide) {\n+                    MarlinUtils.logInfo(\"----------------------\");\n+                }\n+                MarlinUtils.logInfo(\"LineTo c  (\" + cx0 + \", \" + cy0 + \") outcode: \" + outcode0);\n+                MarlinUtils.logInfo(\"LineTo (\" + xe + \", \" + ye + \") outcode: \" + outcode1 + \" outside: \" + outside);\n+            }\n+\n@@ -658,7 +726,2 @@\n-                        if (outside) {\n-                            ret = curveSplitter.splitLine(cox0, coy0, xe, ye,\n-                                                          orCode, this);\n-                        } else {\n-                            ret = curveSplitter.splitLine(cx0, cy0, xe, ye,\n-                                                          orCode, this);\n-                        }\n+                        ret = curveSplitter.splitLine(cx0, cy0, xe, ye,\n+                                                      orCode, this);\n@@ -677,2 +740,6 @@\n-                    this.cox0 = xe;\n-                    this.coy0 = ye;\n+                    this.cx0 = xe;\n+                    this.cy0 = ye;\n+\n+                    if (TRACE) {\n+                        MarlinUtils.logInfo(\"skipped: (\" + cx0 + \", \" + cy0 + \")\");\n+                    }\n@@ -690,0 +757,13 @@\n+\n+                \/\/ emit last point outside before entering again...\n+                if (outcode0 != 0) {\n+                    if (TRACE) {\n+                        MarlinUtils.logInfo(\"add last point outside: (\" + cx0 + \", \" + cy0 + \")\");\n+                    }\n+                    if (prev == MOVE_TO) {\n+                        out.moveTo(cx0, cy0);\n+                    } else {\n+                        out.lineTo(cx0, cy0);\n+                    }\n+                    prev = DRAWING_OP_TO;\n+                }\n@@ -692,0 +772,5 @@\n+            if (prev == MOVE_TO) {\n+                out.moveTo(cx0, cy0);\n+            }\n+            prev = DRAWING_OP_TO;\n+\n@@ -695,0 +780,4 @@\n+\n+            if (TRACE && subdivide) {\n+                MarlinUtils.logInfo(\"----------------------\");\n+            }\n@@ -744,0 +833,8 @@\n+            if (TRACE) {\n+                if (subdivide) {\n+                    MarlinUtils.logInfo(\"----------------------\");\n+                }\n+                MarlinUtils.logInfo(\"CurveTo c  (\" + cx0 + \", \" + cy0 + \") outcode: \" + outcode0);\n+                MarlinUtils.logInfo(\"CurveTo (\" + xe + \", \" + ye + \") outcode: \" + outcode3 + \" outside: \" + outside);\n+            }\n+\n@@ -757,9 +854,3 @@\n-                        if (outside) {\n-                            ret = curveSplitter.splitCurve(cox0, coy0, x1, y1,\n-                                                           x2, y2, xe, ye,\n-                                                           orCode, this);\n-                        } else {\n-                            ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,\n-                                                           x2, y2, xe, ye,\n-                                                           orCode, this);\n-                        }\n+                        ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,\n+                                                       x2, y2, xe, ye,\n+                                                       orCode, this);\n@@ -778,2 +869,6 @@\n-                    this.cox0 = xe;\n-                    this.coy0 = ye;\n+                    this.cx0 = xe;\n+                    this.cy0 = ye;\n+\n+                    if (TRACE) {\n+                        MarlinUtils.logInfo(\"skipped: (\" + cx0 + \", \" + cy0 + \")\");\n+                    }\n@@ -791,0 +886,13 @@\n+\n+                \/\/ emit last point outside before entering again...\n+                if (outcode0 != 0) {\n+                    if (TRACE) {\n+                        MarlinUtils.logInfo(\"add last point outside: (\" + cx0 + \", \" + cy0 + \")\");\n+                    }\n+                    if (prev == MOVE_TO) {\n+                        out.moveTo(cx0, cy0);\n+                    } else {\n+                        out.lineTo(cx0, cy0);\n+                    }\n+                    prev = DRAWING_OP_TO;\n+                }\n@@ -793,0 +901,5 @@\n+            if (prev == MOVE_TO) {\n+                out.moveTo(cx0, cy0);\n+            }\n+            prev = DRAWING_OP_TO;\n+\n@@ -796,0 +909,4 @@\n+\n+            if (TRACE && subdivide) {\n+                MarlinUtils.logInfo(\"----------------------\");\n+            }\n@@ -806,0 +923,8 @@\n+            if (TRACE) {\n+                if (subdivide) {\n+                    MarlinUtils.logInfo(\"----------------------\");\n+                }\n+                MarlinUtils.logInfo(\"QuadTo c  (\" + cx0 + \", \" + cy0 + \") outcode: \" + outcode0);\n+                MarlinUtils.logInfo(\"QuadTo (\" + xe + \", \" + ye + \") outcode: \" + outcode1 + \" outside: \" + outside);\n+            }\n+\n@@ -819,7 +944,2 @@\n-                        if (outside) {\n-                            ret = curveSplitter.splitQuad(cox0, coy0, x1, y1,\n-                                                          xe, ye, orCode, this);\n-                        } else {\n-                            ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,\n-                                                          xe, ye, orCode, this);\n-                        }\n+                        ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,\n+                                                      xe, ye, orCode, this);\n@@ -838,2 +958,2 @@\n-                    this.cox0 = xe;\n-                    this.coy0 = ye;\n+                    this.cx0 = xe;\n+                    this.cy0 = ye;\n@@ -851,0 +971,13 @@\n+\n+                \/\/ emit last point outside before entering again...\n+                if (outcode0 != 0) {\n+                    if (TRACE) {\n+                        MarlinUtils.logInfo(\"add last point outside: (\" + cx0 + \", \" + cy0 + \")\");\n+                    }\n+                    if (prev == MOVE_TO) {\n+                        out.moveTo(cx0, cy0);\n+                    } else {\n+                        out.lineTo(cx0, cy0);\n+                    }\n+                    prev = DRAWING_OP_TO;\n+                }\n@@ -853,0 +986,5 @@\n+            if (prev == MOVE_TO) {\n+                out.moveTo(cx0, cy0);\n+            }\n+            prev = DRAWING_OP_TO;\n+\n@@ -856,0 +994,4 @@\n+\n+            if (TRACE && subdivide) {\n+                MarlinUtils.logInfo(\"----------------------\");\n+            }\n@@ -859,0 +1001,5 @@\n+    interface StartFlagPathConsumer2D extends DPathConsumer2D {\n+\n+        void setStartFlag(boolean first);\n+    }\n+\n@@ -927,0 +1074,1 @@\n+        \/\/ Use a specific interface to make recursion more obvious\n@@ -930,1 +1078,1 @@\n-                          final DPathConsumer2D out)\n+                          final StartFlagPathConsumer2D out)\n@@ -951,1 +1099,1 @@\n-                          final DPathConsumer2D out)\n+                          final StartFlagPathConsumer2D out)\n@@ -974,1 +1122,1 @@\n-                           final DPathConsumer2D out)\n+                           final StartFlagPathConsumer2D out)\n@@ -994,1 +1142,1 @@\n-                                                 final DPathConsumer2D out)\n+                                                 final StartFlagPathConsumer2D out)\n@@ -1030,0 +1178,5 @@\n+\n+                if (i == 0) {\n+                    \/\/ disable start flag:\n+                    out.setStartFlag(false);\n+                }\n@@ -1031,0 +1184,2 @@\n+            \/\/ reset start flag:\n+            out.setStartFlag(true);\n@@ -1035,1 +1190,1 @@\n-                                final int off, final DPathConsumer2D out)\n+                                final int off, final StartFlagPathConsumer2D out)\n@@ -1043,1 +1198,1 @@\n-                out.lineTo(pts[off + 2], pts[off + 3]);\n+                out.lineTo( pts[off + 2], pts[off + 3]);\n@@ -1045,2 +1200,2 @@\n-                out.quadTo(pts[off + 2], pts[off + 3],\n-                           pts[off + 4], pts[off + 5]);\n+                out.quadTo( pts[off + 2], pts[off + 3],\n+                            pts[off + 4], pts[off + 5]);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/TransformingPathConsumer2D.java","additions":217,"deletions":62,"binary":false,"changes":279,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-    private static final String VERSION = \"marlinFX-0.9.3.2-Unsafe-OpenJFX\";\n+    private static final String VERSION = \"marlinFX-0.9.4.5-Unsafe-OpenJFX\";\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/Version.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-            if (stats[i].count != 0l) {\n+            if (stats[i].count != 0L) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/stats\/Histogram.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        if (start != INVALID && elapsed > 0l) {\n+        if (start != INVALID && elapsed > 0L) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/stats\/Monitor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    public long count = 0l;\n-    public long sum = 0l;\n+    public long count = 0L;\n+    public long sum = 0L;\n@@ -44,2 +44,2 @@\n-        count = 0l;\n-        sum = 0l;\n+        count = 0L;\n+        sum = 0L;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/stats\/StatLong.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.marlin.MarlinProperties;\n@@ -46,0 +47,2 @@\n+    private static final boolean DO_RENDER = !MarlinProperties.isSkipRenderTiles();\n+\n@@ -110,0 +113,3 @@\n+            if (!DO_RENDER) {\n+                return EMPTY_MASK;\n+            }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/impl\/shape\/DMarlinRasterizer.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import com.sun.marlin.ArrayCacheIntClean;\n@@ -35,1 +36,0 @@\n-import com.sun.marlin.IntArrayCache;\n@@ -140,1 +140,1 @@\n-                IntArrayCache.check(alphaDeltas, pix_from - x, to + 1, 0);\n+                ArrayCacheIntClean.check(alphaDeltas, pix_from - x, to + 1, 0);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/sw\/SWContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,278 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.com.sun.marlin;\n+\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.embed.swing.SwingFXUtils;\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.Group;\n+import javafx.scene.Scene;\n+import javafx.scene.SnapshotParameters;\n+import javafx.scene.image.PixelReader;\n+import javafx.scene.image.WritableImage;\n+import javafx.scene.paint.Color;\n+import javafx.scene.shape.Polygon;\n+import javafx.scene.transform.Translate;\n+import javafx.stage.Screen;\n+import javafx.stage.Stage;\n+import javax.imageio.IIOImage;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageWriteParam;\n+import javax.imageio.ImageWriter;\n+import javax.imageio.stream.ImageOutputStream;\n+\n+import junit.framework.AssertionFailedError;\n+import org.junit.AfterClass;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import test.util.Util;\n+import static test.util.Util.TIMEOUT;\n+\n+\/**\n+ * Clip rendering test\n+ *\n+ * @test\n+ * @summary verify that huge polygon is properly rasterized\n+ * @bug 8274066\n+ *\/\n+public class HugePolygonClipTest {\n+\n+    private static final Double LARGE_X_COORDINATE = 4194304.250;\n+    private static final int SCENE_WIDTH = 600;\n+    private static final int SCENE_HEIGHT = 400;\n+\n+    static final int BLUE_PIXEL = 0xff0000ff;\n+    static final int RED_PIXEL = 0xffff0000;\n+    static final int WHITE_PIXEL = 0xffffffff;\n+\n+    static final boolean SAVE_IMAGE = false;\n+\n+    \/\/ Used to launch the application before running any test\n+    private static final CountDownLatch launchLatch = new CountDownLatch(1);\n+\n+    static {\n+        Locale.setDefault(Locale.US);\n+        \/*\n+            System.out.println(\"BLUE_PIXEL: \" + BLUE_PIXEL);\n+            System.out.println(\"RED_PIXEL:  \" + RED_PIXEL);\n+         *\/\n+        \/\/ enable Marlin logging:\n+        System.setProperty(\"prism.marlin.log\", \"true\");\n+\n+        System.setProperty(\"prism.marlin.clip\", \"true\");\n+\n+        System.setProperty(\"prism.marlin.subPixel_log2_X\", \"8\");\n+    }\n+\n+    \/\/ Singleton Application instance\n+    static MyApp myApp;\n+\n+    \/\/ Application class. An instance is created and initialized before running\n+    \/\/ the first test, and it lives through the execution of all tests.\n+    public static class MyApp extends Application {\n+\n+        Stage stage = null;\n+\n+        public MyApp() {\n+            super();\n+        }\n+\n+        @Override\n+        public void init() {\n+            HugePolygonClipTest.myApp = this;\n+        }\n+\n+        @Override\n+        public void start(Stage primaryStage) throws Exception {\n+            this.stage = primaryStage;\n+\n+            stage.setScene(new Scene(new Group()));\n+            stage.setTitle(\"HugePolygonClipTest\");\n+            stage.show();\n+\n+            launchLatch.countDown();\n+        }\n+    }\n+\n+    @BeforeClass\n+    public static void setupOnce() {\n+\n+        \/\/ Start the Application\n+        new Thread(() -> Application.launch(MyApp.class, (String[]) null)).start();\n+\n+        try {\n+            if (!launchLatch.await(TIMEOUT, TimeUnit.MILLISECONDS)) {\n+                throw new AssertionFailedError(\"Timeout waiting for Application to launch\");\n+            }\n+\n+        } catch (InterruptedException ex) {\n+            AssertionFailedError err = new AssertionFailedError(\"Unexpected exception\");\n+            err.initCause(ex);\n+            throw err;\n+        }\n+\n+        assertEquals(0, launchLatch.getCount());\n+    }\n+\n+    @AfterClass\n+    public static void teardownOnce() {\n+        Platform.exit();\n+    }\n+\n+    @Test(timeout = 10000)\n+    public void TestHugePolygonCoords() throws InterruptedException {\n+        Util.runAndWait(() -> {\n+\n+            double dpi = Screen.getPrimary().getDpi();\n+            System.out.println(\"dpi: \" + dpi);\n+\n+            double dpiScale = Screen.getPrimary().getOutputScaleX();\n+            System.out.println(\"dpiScale: \" + dpiScale);\n+\n+            \/\/ original test case => large moveTo in Filler but no bug in Stroker:\n+            Double longWidth = LARGE_X_COORDINATE + SCENE_WIDTH + 0.001;\n+\n+            final Polygon veryWidePolygon;\n+\n+            veryWidePolygon = new Polygon(\n+                    longWidth, 50.0,\n+                    longWidth, 100.0,\n+                    0.0, 100.0,\n+                    0.0, 0.0\n+            );\n+\n+            veryWidePolygon.setFill(Color.BLUE);\n+            veryWidePolygon.setStroke(Color.RED);\n+            veryWidePolygon.setStrokeWidth(2);\n+\n+            Group group = new Group(veryWidePolygon);\n+            group.getTransforms().add(new Translate(-longWidth + SCENE_WIDTH, 100.0));\n+\n+            Scene scene = new Scene(group, SCENE_WIDTH, SCENE_HEIGHT, Color.WHITE);\n+            myApp.stage.setScene(scene);\n+\n+            final SnapshotParameters sp = new SnapshotParameters();\n+            sp.setViewport(new Rectangle2D(0, 0, SCENE_WIDTH, SCENE_HEIGHT));\n+\n+            final WritableImage img = scene.getRoot().snapshot(sp, new WritableImage(SCENE_WIDTH, SCENE_HEIGHT));\n+\n+            if (SAVE_IMAGE) {\n+                try {\n+                    saveImage(img, OUTPUT_DIR, \"TestHugePolygonCoords.png\");\n+                } catch (IOException ex) {\n+                    \/\/ ignore\n+                }\n+            }\n+\n+            \/\/ Check image on few pixels:\n+            final PixelReader pr = img.getPixelReader();\n+\n+            final int x = SCENE_WIDTH \/ 2;\n+            \/\/ 10, 5 = blue\n+            checkColumn(pr, x, SCENE_HEIGHT);\n+        });\n+    }\n+\n+    private static void checkColumn(final PixelReader pr, final int x, final int maxY) {\n+\n+        boolean inside = false;\n+        boolean prevRed = false;\n+\n+        for (int y = 0; y < maxY; y++) {\n+            final int rgb = pr.getArgb(x, y);\n+            \/\/ System.out.println(\"pixel at (\" + x + \", \" + y + \") = \" + rgb);\n+\n+            if (rgb == RED_PIXEL) {\n+                if (!prevRed) {\n+                    prevRed = true;\n+                    inside = !inside;\n+                    \/\/ System.out.println(\"inside: \"+inside);\n+                }\n+            } else {\n+                prevRed = false;\n+                final int expected = (inside) ? BLUE_PIXEL : WHITE_PIXEL;\n+\n+                if (rgb != expected) {\n+                    fail(\"bad pixel at (\" + x + \", \" + y\n+                            + \") = \" + rgb + \" expected: \" + expected);\n+                }\n+            }\n+        }\n+    }\n+\n+    static final File OUTPUT_DIR = new File(\".\");\n+\n+    static void saveImage(final WritableImage image, final File resDirectory, final String imageFileName) throws IOException {\n+        saveImage(SwingFXUtils.fromFXImage(image, null), resDirectory, imageFileName);\n+    }\n+\n+    static void saveImage(final BufferedImage image, final File resDirectory, final String imageFileName) throws IOException {\n+        final Iterator<ImageWriter> itWriters = ImageIO.getImageWritersByFormatName(\"PNG\");\n+        if (itWriters.hasNext()) {\n+            final ImageWriter writer = itWriters.next();\n+\n+            final ImageWriteParam writerParams = writer.getDefaultWriteParam();\n+            writerParams.setProgressiveMode(ImageWriteParam.MODE_DISABLED);\n+\n+            final File imgFile = new File(resDirectory, imageFileName);\n+\n+            if (!imgFile.exists() || imgFile.canWrite()) {\n+                System.out.println(\"saveImage: saving image as PNG [\" + imgFile + \"]...\");\n+                imgFile.delete();\n+\n+                \/\/ disable cache in temporary files:\n+                ImageIO.setUseCache(false);\n+\n+                final long start = System.nanoTime();\n+\n+                \/\/ PNG uses already buffering:\n+                final ImageOutputStream imgOutStream = ImageIO.createImageOutputStream(new FileOutputStream(imgFile));\n+\n+                writer.setOutput(imgOutStream);\n+                try {\n+                    writer.write(null, new IIOImage(image, null, null), writerParams);\n+                } finally {\n+                    imgOutStream.close();\n+\n+                    final long time = System.nanoTime() - start;\n+                    System.out.println(\"saveImage: duration= \" + (time \/ 1000000l) + \" ms.\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/com\/sun\/marlin\/HugePolygonClipTest.java","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"}]}