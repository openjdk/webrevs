{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## PipeWire 0.3.68\n+## PipeWire 1.3.81\n@@ -42,0 +42,5 @@\n+\n+spa\/utils\/cleanup.h:\n+```\n+Copyright © 2023 PipeWire authors\n+```\n","filename":"modules\/javafx.graphics\/src\/main\/legal\/pipewire.md","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+struct pw_impl_node;\n@@ -53,1 +54,1 @@\n-#define PW_VERSION_CONTEXT_EVENTS    0\n+#define PW_VERSION_CONTEXT_EVENTS    1\n@@ -66,0 +67,5 @@\n+\n+    \/** a driver was added, since 0.3.75 version:1 *\/\n+    void (*driver_added) (void *data, struct pw_impl_node *node);\n+    \/** a driver was removed, since 0.3.75 version:1 *\/\n+    void (*driver_removed) (void *data, struct pw_impl_node *node);\n@@ -68,4 +74,11 @@\n-\/** Make a new context object for a given main_loop. Ownership of the properties is taken *\/\n-struct pw_context * pw_context_new(struct pw_loop *main_loop,        \/**< a main loop to run in *\/\n-                 struct pw_properties *props,    \/**< extra properties *\/\n-                 size_t user_data_size        \/**< extra user data size *\/);\n+\/** Make a new context object for a given main_loop. Ownership of the properties is taken, even\n+ * if the function returns NULL.\n+ *\n+ * \\param main_loop A main loop to run in. This must stay alive unil pw_context_destroy() is called.\n+ * \\param props extra properties\n+ * \\param user_data_size extra user data size\n+ * \\return The context object on success, or NULL on failure, in which case errno is set.\n+ * *\/\n+struct pw_context * pw_context_new(struct pw_loop *main_loop,\n+                 struct pw_properties *props,\n+                 size_t user_data_size);\n@@ -116,1 +129,1 @@\n-\/** get the context main loop *\/\n+\/** Get the context main loop. Returns the value passed to pw_context_new(). *\/\n@@ -119,1 +132,3 @@\n-\/** get the context data loop. Since 0.3.56 *\/\n+\/** Get the context data loop. This loop runs on the realtime thread. This\n+ * acquires a loop from the generic data.rt class. Use pw_context_acquire_loop() instead.\n+ * Since 0.3.56 *\/\n@@ -122,0 +137,7 @@\n+\/** Get a data-loop.\n+ * Since 1.1.0 *\/\n+struct pw_loop *pw_context_acquire_loop(struct pw_context *context, const struct spa_dict *props);\n+\/** Release a data-loop.\n+ * Since 1.1.0 *\/\n+void pw_context_release_loop(struct pw_context *context, struct pw_loop *loop);\n+\n@@ -125,0 +147,3 @@\n+\/** Get the memory pool from the context: Since 0.3.74 *\/\n+struct pw_mempool *pw_context_get_mempool(struct pw_context *context);\n+\n@@ -133,1 +158,4 @@\n-\/** Find a context global by id *\/\n+\/** Find a context global by id.\n+ *\n+ * \\return The global on success, or NULL on failure. If id is \\ref PW_ID_CORE,\n+ *         this function will always return a non-NULL value. *\/\n@@ -143,0 +171,1 @@\n+\/** Load a SPA handle from a context. On failure returns NULL and sets errno. *\/\n@@ -163,1 +192,8 @@\n-\/** add an object to the context *\/\n+\/** add an object to the context\n+ *\n+ * \\param context The context.\n+ * \\param type The type of the object, usually a `TYPE_INTERFACE_` value.\n+ * \\param value The object value. Must last as long as the context and must\n+ *              be of the type corresponding to the type.\n+ * \\return A negative number on failure (out of memory).\n+ * *\/\n@@ -165,1 +201,6 @@\n-\/** get an object from the context *\/\n+\/** get an object from the context\n+ *\n+ * \\param context The context.\n+ * \\param type The string corresponding to the object's interface.\n+ * \\return The object, or NULL if the object does not exist.\n+ * *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/pipewire\/context.h","additions":51,"deletions":10,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -17,0 +17,2 @@\n+#include <pipewire\/type.h>\n+\n@@ -37,0 +39,2 @@\n+#define PW_CORE_PERM_MASK        PW_PERM_R|PW_PERM_X|PW_PERM_M\n+\n@@ -42,0 +46,7 @@\n+#ifndef PW_API_CORE_IMPL\n+#define PW_API_CORE_IMPL static inline\n+#endif\n+#ifndef PW_API_REGISTRY_IMPL\n+#define PW_API_REGISTRY_IMPL static inline\n+#endif\n+\n@@ -70,1 +81,2 @@\n-\/** Update an existing \\ref pw_core_info with \\a update with reset *\/\n+\/** Update an existing \\ref pw_core_info with \\a update with reset. When info is NULL,\n+ * a new one will be allocated. Returns NULL on failure. *\/\n@@ -74,1 +86,2 @@\n-\/** Update an existing \\ref pw_core_info with \\a update *\/\n+\/** Update an existing \\ref pw_core_info with \\a update. When info is NULL, a new one\n+ * will be allocated. Returns NULL on failure *\/\n@@ -165,0 +178,3 @@\n+     * The bound_props event is an enhanced version of this event that\n+     * also contains the extra global properties.\n+     *\n@@ -193,0 +209,15 @@\n+    \/**\n+     * Notify an object binding\n+     *\n+     * This event is emitted when a local object ID is bound to a\n+     * global ID. It is emitted before the global becomes visible in the\n+     * registry.\n+     *\n+     * This is an enhanced version of the bound_id event.\n+     *\n+     * \\param id bound object ID\n+     * \\param global_id the global id bound to\n+     * \\param props The properties of the new global object.\n+     *\n+     * Since version 4:1\n+     *\/\n@@ -226,0 +257,2 @@\n+     *\n+     * This requires X permissions on the core.\n@@ -238,0 +271,2 @@\n+     *\n+     * This requires X permissions on the core.\n@@ -246,0 +281,2 @@\n+     *\n+     * This requires X permissions on the core.\n@@ -260,1 +297,1 @@\n-         * \\param id object where the error occurred\n+         * \\param id resource id where the error occurred\n@@ -263,0 +300,2 @@\n+     *\n+     * This requires X permissions on the core.\n@@ -272,0 +311,2 @@\n+     *\n+     * This requires X permissions on the core.\n@@ -284,0 +325,2 @@\n+     *\n+     * This requires X permissions on the core.\n@@ -297,0 +340,2 @@\n+     *\n+     * This requires X permissions on the core.\n@@ -301,8 +346,0 @@\n-#define pw_core_method(o,method,version,...)            \\\n-({                                    \\\n-    int _res = -ENOTSUP;                        \\\n-    spa_interface_call_res((struct spa_interface*)o,        \\\n-            struct pw_core_methods, _res,        \\\n-            method, version, ##__VA_ARGS__);        \\\n-    _res;                                \\\n-})\n@@ -310,8 +347,44 @@\n-#define pw_core_add_listener(c,...)    pw_core_method(c,add_listener,0,__VA_ARGS__)\n-#define pw_core_hello(c,...)        pw_core_method(c,hello,0,__VA_ARGS__)\n-#define pw_core_sync(c,...)        pw_core_method(c,sync,0,__VA_ARGS__)\n-#define pw_core_pong(c,...)        pw_core_method(c,pong,0,__VA_ARGS__)\n-#define pw_core_error(c,...)        pw_core_method(c,error,0,__VA_ARGS__)\n-\n-\n-static inline\n+\/** \\copydoc pw_core_methods.add_listener\n+ * \\sa pw_core_methods.add_listener *\/\n+PW_API_CORE_IMPL int pw_core_add_listener(struct pw_core *object,\n+            struct spa_hook *listener,\n+            const struct pw_core_events *events,\n+            void *data)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            pw_core, (struct spa_interface*)object, add_listener, 0,\n+            listener, events, data);\n+}\n+\/** \\copydoc pw_core_methods.hello\n+ * \\sa pw_core_methods.hello *\/\n+PW_API_CORE_IMPL int pw_core_hello(struct pw_core *object, uint32_t version)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            pw_core, (struct spa_interface*)object, hello, 0,\n+            version);\n+}\n+\/** \\copydoc pw_core_methods.sync\n+ * \\sa pw_core_methods.sync *\/\n+PW_API_CORE_IMPL int pw_core_sync(struct pw_core *object, uint32_t id, int seq)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            pw_core, (struct spa_interface*)object, sync, 0,\n+            id, seq);\n+}\n+\/** \\copydoc pw_core_methods.pong\n+ * \\sa pw_core_methods.pong *\/\n+PW_API_CORE_IMPL int pw_core_pong(struct pw_core *object, uint32_t id, int seq)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            pw_core, (struct spa_interface*)object, pong, 0,\n+            id, seq);\n+}\n+\/** \\copydoc pw_core_methods.error\n+ * \\sa pw_core_methods.error *\/\n+PW_API_CORE_IMPL int pw_core_error(struct pw_core *object, uint32_t id, int seq, int res, const char *message)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            pw_core, (struct spa_interface*)object, error, 0,\n+            id, seq, res, message);\n+}\n+PW_API_CORE_IMPL\n@@ -328,1 +401,1 @@\n-static inline\n+PW_API_CORE_IMPL\n@@ -341,1 +414,3 @@\n-static inline struct pw_registry *\n+\/** \\copydoc pw_core_methods.get_registry\n+ * \\sa pw_core_methods.get_registry *\/\n+PW_API_CORE_IMPL struct pw_registry *\n@@ -344,5 +419,3 @@\n-    struct pw_registry *res = NULL;\n-    spa_interface_call_res((struct spa_interface*)core,\n-            struct pw_core_methods, res,\n-            get_registry, 0, version, user_data_size);\n-    return res;\n+    return spa_api_method_r(struct pw_registry*, NULL,\n+            pw_core, (struct spa_interface*)core, get_registry, 0,\n+            version, user_data_size);\n@@ -350,2 +423,3 @@\n-\n-static inline void *\n+\/** \\copydoc pw_core_methods.create_object\n+ * \\sa pw_core_methods.create_object *\/\n+PW_API_CORE_IMPL void *\n@@ -359,6 +433,11 @@\n-    void *res = NULL;\n-    spa_interface_call_res((struct spa_interface*)core,\n-            struct pw_core_methods, res,\n-            create_object, 0, factory_name,\n-            type, version, props, user_data_size);\n-    return res;\n+    return spa_api_method_r(void*, NULL,\n+            pw_core, (struct spa_interface*)core, create_object, 0,\n+            factory_name, type, version, props, user_data_size);\n+}\n+\/** \\copydoc pw_core_methods.destroy\n+ * \\sa pw_core_methods.destroy *\/\n+PW_API_CORE_IMPL void\n+pw_core_destroy(struct pw_core *core, void *proxy)\n+{\n+    spa_api_method_v(pw_core, (struct spa_interface*)core, destroy, 0,\n+            proxy);\n@@ -366,2 +445,0 @@\n-\n-#define pw_core_destroy(c,...)        pw_core_method(c,destroy,0,__VA_ARGS__)\n@@ -477,1 +554,2 @@\n-     * \\param id the global id to destroy\n+     * \\param id the global id to destroy. The client needs X permissions\n+     * on the global.\n@@ -482,8 +560,0 @@\n-#define pw_registry_method(o,method,version,...)            \\\n-({                                    \\\n-    int _res = -ENOTSUP;                        \\\n-    spa_interface_call_res((struct spa_interface*)o,        \\\n-            struct pw_registry_methods, _res,        \\\n-            method, version, ##__VA_ARGS__);        \\\n-    _res;                                \\\n-})\n@@ -492,3 +562,14 @@\n-#define pw_registry_add_listener(p,...)    pw_registry_method(p,add_listener,0,__VA_ARGS__)\n-\n-static inline void *\n+\/** \\copydoc pw_registry_methods.add_listener\n+ * \\sa pw_registry_methods.add_listener *\/\n+PW_API_REGISTRY_IMPL int pw_registry_add_listener(struct pw_registry *registry,\n+            struct spa_hook *listener,\n+            const struct pw_registry_events *events,\n+            void *data)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            pw_registry, (struct spa_interface*)registry, add_listener, 0,\n+            listener, events, data);\n+}\n+\/** \\copydoc pw_registry_methods.bind\n+ * \\sa pw_registry_methods.bind *\/\n+PW_API_REGISTRY_IMPL void *\n@@ -499,5 +580,11 @@\n-    void *res = NULL;\n-    spa_interface_call_res((struct spa_interface*)registry,\n-            struct pw_registry_methods, res,\n-            bind, 0, id, type, version, user_data_size);\n-    return res;\n+    return spa_api_method_r(void*, NULL,\n+            pw_registry, (struct spa_interface*)registry, bind, 0,\n+            id, type, version, user_data_size);\n+}\n+\/** \\copydoc pw_registry_methods.destroy\n+ * \\sa pw_registry_methods.destroy *\/\n+PW_API_REGISTRY_IMPL int\n+pw_registry_destroy(struct pw_registry *registry, uint32_t id)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            pw_registry, (struct spa_interface*)registry, destroy, 0, id);\n@@ -505,2 +592,0 @@\n-\n-#define pw_registry_destroy(p,...)    pw_registry_method(p,destroy,0,__VA_ARGS__)\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/pipewire\/core.h","additions":140,"deletions":55,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -41,0 +41,8 @@\n+#define PW_KEY_SEC_SOCKET        \"pipewire.sec.socket\"    \/**< client socket name, set by protocol *\/\n+\n+#define PW_KEY_SEC_ENGINE        \"pipewire.sec.engine\"    \/**< client secure context engine, set by protocol.\n+                                  *  This can also be set by a client when making a\n+                                  *  new security context. *\/\n+#define PW_KEY_SEC_APP_ID        \"pipewire.sec.app-id\"    \/**< client secure application id *\/\n+#define PW_KEY_SEC_INSTANCE_ID        \"pipewire.sec.instance-id\"    \/**< client secure instance id *\/\n+\n@@ -55,1 +63,2 @@\n-\n+#define PW_KEY_OBJECT_EXPORT        \"object.export\"        \/**< If the object should be exported,\n+                                  *  since 0.3.72 *\/\n@@ -63,0 +72,6 @@\n+\/* loop *\/\n+#define PW_KEY_LOOP_NAME        \"loop.name\"        \/**< the name of a loop *\/\n+#define PW_KEY_LOOP_CLASS        \"loop.class\"        \/**< the classes this loop handles, array of strings *\/\n+#define PW_KEY_LOOP_RT_PRIO        \"loop.rt-prio\"        \/**< realtime priority of the loop *\/\n+#define PW_KEY_LOOP_CANCEL        \"loop.cancel\"        \/**< if the loop can be canceled *\/\n+\n@@ -90,1 +105,3 @@\n-                                  *  env(PIPEWIRE_REMOTE) *\/\n+                                  *  env(PIPEWIRE_REMOTE). May also be\n+                                  *  a SPA-JSON array of sockets, to be tried\n+                                  *  in order. *\/\n@@ -135,1 +152,8 @@\n-                                  *  with the same driver. *\/\n+                                  *  with the same driver. Can be an array of\n+                                  *  group names. *\/\n+#define PW_KEY_NODE_SYNC_GROUP        \"node.sync-group\"    \/**< the sync group this node is part of. Nodes\n+                                  *  in the same sync group are always scheduled\n+                                  *  together with the same driver when the sync\n+                                  *  is active. Can be an array of sync names. *\/\n+#define PW_KEY_NODE_SYNC        \"node.sync\"        \/**< if the sync-group is active or not *\/\n+#define PW_KEY_NODE_TRANSPORT        \"node.transport\"    \/**< if the transport is active or not *\/\n@@ -166,1 +190,17 @@\n-#define PW_KEY_NODE_DRIVER        \"node.driver\"        \/**< node can drive the graph *\/\n+#define PW_KEY_NODE_DRIVER        \"node.driver\"        \/**< node can drive the graph. When the node is\n+                                  *  selected as the driver, it needs to start\n+                                  *  the graph periodically. *\/\n+#define PW_KEY_NODE_SUPPORTS_LAZY    \"node.supports-lazy\"    \/**< the node can be a lazy driver. It will listen\n+                                  *  to RequestProcess commands and take them into\n+                                  *  account when deciding to start the graph.\n+                                  *  A value of 0 disables support, a value of > 0\n+                                  *  enables with increasing preference. *\/\n+#define PW_KEY_NODE_SUPPORTS_REQUEST    \"node.supports-request\"    \/**< The node supports emiting RequestProcess events\n+                                  *  when it wants the graph to be scheduled.\n+                                  *  A value of 0 disables support, a value of > 0\n+                                  *  enables with increasing preference. *\/\n+#define PW_KEY_NODE_DRIVER_ID        \"node.driver-id\"    \/**< the node id of the node assigned as driver\n+                                  *   for this node *\/\n+#define PW_KEY_NODE_ASYNC        \"node.async\"        \/**< the node wants async scheduling *\/\n+#define PW_KEY_NODE_LOOP_NAME        \"node.loop.name\"    \/**< the loop name fnmatch pattern to run in *\/\n+#define PW_KEY_NODE_LOOP_CLASS        \"node.loop.class\"    \/**< the loop class fnmatch pattern to run in *\/\n@@ -175,1 +215,2 @@\n-                                  *  nodes with the same link-group *\/\n+                                  *  nodes with the same link-group. Can be an\n+                                  *  array of group names. *\/\n@@ -180,6 +221,8 @@\n-#define PW_KEY_NODE_CHANNELNAMES        \"node.channel-names\"        \/**< names of node's\n-                                    *   channels (unrelated to positions) *\/\n-#define PW_KEY_NODE_DEVICE_PORT_NAME_PREFIX            \"node.device-port-name-prefix\"        \/** override\n-                                    *        port name prefix for device ports, like capture and playback\n-                                    *        or disable the prefix completely if an empty string is provided *\/\n-\n+#define PW_KEY_NODE_CHANNELNAMES    \"node.channel-names\"    \/**< names of node's\n+                                *   channels (unrelated to positions) *\/\n+#define PW_KEY_NODE_DEVICE_PORT_NAME_PREFIX    \\\n+                    \"node.device-port-name-prefix\"    \/**< override port name prefix for\n+                                      *  device ports, like capture and\n+                                      *  playback or disable the prefix\n+                                      *  completely if an empty string\n+                                      *  is provided *\/\n@@ -200,0 +243,2 @@\n+#define PW_KEY_PORT_IGNORE_LATENCY    \"port.ignore-latency\"    \/**< latency ignored by peers, since 0.3.71 *\/\n+#define PW_KEY_PORT_GROUP        \"port.group\"        \/**< the port group of the port 1.2.0 *\/\n@@ -213,0 +258,1 @@\n+#define PW_KEY_LINK_ASYNC        \"link.async\"        \/**< the link is using async io *\/\n@@ -263,0 +309,1 @@\n+#define PW_KEY_MODULE_DEPRECATED    \"module.deprecated\"    \/**< the module is deprecated with this message *\/\n@@ -277,1 +324,4 @@\n-                                  *  conversion algorithm. *\/\n+                                  *  conversion algorithm. Monitor streams are also\n+                                  *  ignored when calculating the latency of their peer\n+                                  *  ports (since 0.3.71).\n+                                  *\/\n@@ -295,0 +345,1 @@\n+#define PW_KEY_MEDIA_ALBUM        \"media.album\"        \/**< album. Ex: \"Dark Side of the Moon\" *\/\n@@ -330,0 +381,1 @@\n+#  define PW_KEY_LOOP_RETRY_TIMEOUT    \"loop.retry-timeout\"    \/**< deprecated since 1.3.0 *\/\n@@ -333,0 +385,1 @@\n+#  define PW_KEY_LOOP_RETRY_TIMEOUT    PW_DEPRECATED(\"loop.retry-timeout\")\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/pipewire\/keys.h","additions":65,"deletions":12,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -20,0 +20,2 @@\n+ *\n+ * The members of \\ref pw_loop are read-only.\n@@ -32,0 +34,1 @@\n+    const char *name;\n@@ -34,0 +37,4 @@\n+#ifndef PW_API_LOOP_IMPL\n+#define PW_API_LOOP_IMPL static inline\n+#endif\n+\n@@ -40,21 +47,99 @@\n-#define pw_loop_add_source(l,...)    spa_loop_add_source((l)->loop,__VA_ARGS__)\n-#define pw_loop_update_source(l,...)    spa_loop_update_source((l)->loop,__VA_ARGS__)\n-#define pw_loop_remove_source(l,...)    spa_loop_remove_source((l)->loop,__VA_ARGS__)\n-#define pw_loop_invoke(l,...)        spa_loop_invoke((l)->loop,__VA_ARGS__)\n-\n-#define pw_loop_get_fd(l)        spa_loop_control_get_fd((l)->control)\n-#define pw_loop_add_hook(l,...)        spa_loop_control_add_hook((l)->control,__VA_ARGS__)\n-#define pw_loop_enter(l)        spa_loop_control_enter((l)->control)\n-#define pw_loop_iterate(l,...)        spa_loop_control_iterate((l)->control,__VA_ARGS__)\n-#define pw_loop_leave(l)        spa_loop_control_leave((l)->control)\n-\n-#define pw_loop_add_io(l,...)        spa_loop_utils_add_io((l)->utils,__VA_ARGS__)\n-#define pw_loop_update_io(l,...)    spa_loop_utils_update_io((l)->utils,__VA_ARGS__)\n-#define pw_loop_add_idle(l,...)        spa_loop_utils_add_idle((l)->utils,__VA_ARGS__)\n-#define pw_loop_enable_idle(l,...)    spa_loop_utils_enable_idle((l)->utils,__VA_ARGS__)\n-#define pw_loop_add_event(l,...)    spa_loop_utils_add_event((l)->utils,__VA_ARGS__)\n-#define pw_loop_signal_event(l,...)    spa_loop_utils_signal_event((l)->utils,__VA_ARGS__)\n-#define pw_loop_add_timer(l,...)    spa_loop_utils_add_timer((l)->utils,__VA_ARGS__)\n-#define pw_loop_update_timer(l,...)    spa_loop_utils_update_timer((l)->utils,__VA_ARGS__)\n-#define pw_loop_add_signal(l,...)    spa_loop_utils_add_signal((l)->utils,__VA_ARGS__)\n-#define pw_loop_destroy_source(l,...)    spa_loop_utils_destroy_source((l)->utils,__VA_ARGS__)\n+int pw_loop_set_name(struct pw_loop *loop, const char *name);\n+\n+PW_API_LOOP_IMPL int pw_loop_add_source(struct pw_loop *object, struct spa_source *source)\n+{\n+    return spa_loop_add_source(object->loop, source);\n+}\n+PW_API_LOOP_IMPL int pw_loop_update_source(struct pw_loop *object, struct spa_source *source)\n+{\n+    return spa_loop_update_source(object->loop, source);\n+}\n+PW_API_LOOP_IMPL int pw_loop_remove_source(struct pw_loop *object, struct spa_source *source)\n+{\n+    return spa_loop_remove_source(object->loop, source);\n+}\n+PW_API_LOOP_IMPL int pw_loop_invoke(struct pw_loop *object,\n+                spa_invoke_func_t func, uint32_t seq, const void *data,\n+                size_t size, bool block, void *user_data)\n+{\n+    return spa_loop_invoke(object->loop, func, seq, data, size, block, user_data);\n+}\n+\n+PW_API_LOOP_IMPL int pw_loop_get_fd(struct pw_loop *object)\n+{\n+    return spa_loop_control_get_fd(object->control);\n+}\n+PW_API_LOOP_IMPL void pw_loop_add_hook(struct pw_loop *object,\n+                struct spa_hook *hook, const struct spa_loop_control_hooks *hooks,\n+                void *data)\n+{\n+    spa_loop_control_add_hook(object->control, hook, hooks, data);\n+}\n+PW_API_LOOP_IMPL void pw_loop_enter(struct pw_loop *object)\n+{\n+    spa_loop_control_enter(object->control);\n+}\n+PW_API_LOOP_IMPL void pw_loop_leave(struct pw_loop *object)\n+{\n+    spa_loop_control_leave(object->control);\n+}\n+PW_API_LOOP_IMPL int pw_loop_iterate(struct pw_loop *object,\n+                int timeout)\n+{\n+    return spa_loop_control_iterate_fast(object->control, timeout);\n+}\n+\n+PW_API_LOOP_IMPL struct spa_source *\n+pw_loop_add_io(struct pw_loop *object, int fd, uint32_t mask,\n+                bool close, spa_source_io_func_t func, void *data)\n+{\n+    return spa_loop_utils_add_io(object->utils, fd, mask, close, func, data);\n+}\n+PW_API_LOOP_IMPL int pw_loop_update_io(struct pw_loop *object,\n+                struct spa_source *source, uint32_t mask)\n+{\n+    return spa_loop_utils_update_io(object->utils, source, mask);\n+}\n+PW_API_LOOP_IMPL struct spa_source *\n+pw_loop_add_idle(struct pw_loop *object, bool enabled,\n+                spa_source_idle_func_t func, void *data)\n+{\n+    return spa_loop_utils_add_idle(object->utils, enabled, func, data);\n+}\n+PW_API_LOOP_IMPL int pw_loop_enable_idle(struct pw_loop *object,\n+                struct spa_source *source, bool enabled)\n+{\n+    return spa_loop_utils_enable_idle(object->utils, source, enabled);\n+}\n+PW_API_LOOP_IMPL struct spa_source *\n+pw_loop_add_event(struct pw_loop *object, spa_source_event_func_t func, void *data)\n+{\n+    return spa_loop_utils_add_event(object->utils, func, data);\n+}\n+PW_API_LOOP_IMPL int pw_loop_signal_event(struct pw_loop *object,\n+                struct spa_source *source)\n+{\n+    return spa_loop_utils_signal_event(object->utils, source);\n+}\n+PW_API_LOOP_IMPL struct spa_source *\n+pw_loop_add_timer(struct pw_loop *object, spa_source_timer_func_t func, void *data)\n+{\n+    return spa_loop_utils_add_timer(object->utils, func, data);\n+}\n+PW_API_LOOP_IMPL int pw_loop_update_timer(struct pw_loop *object,\n+                struct spa_source *source, struct timespec *value,\n+                struct timespec *interval, bool absolute)\n+{\n+    return spa_loop_utils_update_timer(object->utils, source, value, interval, absolute);\n+}\n+PW_API_LOOP_IMPL struct spa_source *\n+pw_loop_add_signal(struct pw_loop *object, int signal_number,\n+                spa_source_signal_func_t func, void *data)\n+{\n+    return spa_loop_utils_add_signal(object->utils, signal_number, func, data);\n+}\n+PW_API_LOOP_IMPL void pw_loop_destroy_source(struct pw_loop *object,\n+                struct spa_source *source)\n+{\n+    return spa_loop_utils_destroy_source(object->utils, source);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/pipewire\/loop.h","additions":106,"deletions":21,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#define PW_PORT_PERM_MASK    PW_PERM_R|PW_PERM_X|PW_PERM_M\n+\n@@ -35,0 +37,4 @@\n+#ifndef PW_API_PORT_IMPL\n+#define PW_API_PORT_IMPL static inline\n+#endif\n+\n@@ -118,0 +124,2 @@\n+     *\n+     * This requires X permissions on the port.\n@@ -132,0 +140,2 @@\n+     *\n+     * This requires X permissions on the port.\n@@ -138,12 +148,29 @@\n-#define pw_port_method(o,method,version,...)                \\\n-({                                    \\\n-    int _res = -ENOTSUP;                        \\\n-    spa_interface_call_res((struct spa_interface*)o,        \\\n-            struct pw_port_methods, _res,            \\\n-            method, version, ##__VA_ARGS__);        \\\n-    _res;                                \\\n-})\n-\n-#define pw_port_add_listener(c,...)    pw_port_method(c,add_listener,0,__VA_ARGS__)\n-#define pw_port_subscribe_params(c,...)    pw_port_method(c,subscribe_params,0,__VA_ARGS__)\n-#define pw_port_enum_params(c,...)    pw_port_method(c,enum_params,0,__VA_ARGS__)\n+\/** \\copydoc pw_port_methods.add_listener\n+ * \\sa pw_port_methods.add_listener *\/\n+PW_API_PORT_IMPL int pw_port_add_listener(struct pw_port *object,\n+            struct spa_hook *listener,\n+            const struct pw_port_events *events,\n+            void *data)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            pw_port, (struct spa_interface*)object, add_listener, 0,\n+            listener, events, data);\n+}\n+\/** \\copydoc pw_port_methods.subscribe_params\n+ * \\sa pw_port_methods.subscribe_params *\/\n+PW_API_PORT_IMPL int pw_port_subscribe_params(struct pw_port *object, uint32_t *ids, uint32_t n_ids)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            pw_port, (struct spa_interface*)object, subscribe_params, 0,\n+            ids, n_ids);\n+}\n+\/** \\copydoc pw_port_methods.enum_params\n+ * \\sa pw_port_methods.enum_params *\/\n+PW_API_PORT_IMPL int pw_port_enum_params(struct pw_port *object,\n+        int seq, uint32_t id, uint32_t start, uint32_t num,\n+                const struct spa_pod *filter)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            pw_port, (struct spa_interface*)object, enum_params, 0,\n+            seq, id, start, num, filter);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/pipewire\/port.h","additions":39,"deletions":12,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -14,0 +14,1 @@\n+#include <spa\/utils\/cleanup.h>\n@@ -17,0 +18,4 @@\n+#ifndef PW_API_PROPERTIES\n+#define PW_API_PROPERTIES static inline\n+#endif\n+\n@@ -43,0 +48,4 @@\n+struct pw_properties *\n+pw_properties_new_string_checked(const char *args, size_t size,\n+        struct spa_error_location *loc);\n+\n@@ -54,0 +63,1 @@\n+\n@@ -58,0 +68,3 @@\n+int pw_properties_update_string_checked(struct pw_properties *props,\n+        const char *str, size_t size, struct spa_error_location *loc);\n+\n@@ -95,1 +108,1 @@\n-static inline uint32_t\n+PW_API_PROPERTIES uint32_t\n@@ -103,1 +116,1 @@\n-static inline int32_t\n+PW_API_PROPERTIES int32_t\n@@ -111,1 +124,1 @@\n-static inline uint64_t\n+PW_API_PROPERTIES uint64_t\n@@ -119,1 +132,1 @@\n-static inline int64_t\n+PW_API_PROPERTIES int64_t\n@@ -128,1 +141,1 @@\n-static inline bool\n+PW_API_PROPERTIES bool\n@@ -139,1 +152,5 @@\n-#define PW_PROPERTIES_FLAG_NL    (1<<0)\n+#define PW_PROPERTIES_FLAG_NL        (1<<0)\n+#define PW_PROPERTIES_FLAG_RECURSE    (1<<1)\n+#define PW_PROPERTIES_FLAG_ENCLOSE    (1<<2)\n+#define PW_PROPERTIES_FLAG_ARRAY    (1<<3)\n+#define PW_PROPERTIES_FLAG_COLORS    (1<<4)\n@@ -142,1 +159,1 @@\n-static inline bool pw_properties_parse_bool(const char *value) {\n+PW_API_PROPERTIES bool pw_properties_parse_bool(const char *value) {\n@@ -146,1 +163,1 @@\n-static inline int pw_properties_parse_int(const char *value) {\n+PW_API_PROPERTIES int pw_properties_parse_int(const char *value) {\n@@ -151,1 +168,1 @@\n-static inline int64_t pw_properties_parse_int64(const char *value) {\n+PW_API_PROPERTIES int64_t pw_properties_parse_int64(const char *value) {\n@@ -156,1 +173,1 @@\n-static inline uint64_t pw_properties_parse_uint64(const char *value) {\n+PW_API_PROPERTIES uint64_t pw_properties_parse_uint64(const char *value) {\n@@ -161,1 +178,1 @@\n-static inline float pw_properties_parse_float(const char *value) {\n+PW_API_PROPERTIES float pw_properties_parse_float(const char *value) {\n@@ -166,1 +183,1 @@\n-static inline double pw_properties_parse_double(const char *value) {\n+PW_API_PROPERTIES double pw_properties_parse_double(const char *value) {\n@@ -175,0 +192,4 @@\n+SPA_DEFINE_AUTOPTR_CLEANUP(pw_properties, struct pw_properties, {\n+    spa_clear_ptr(*thing, pw_properties_free);\n+})\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/pipewire\/properties.h","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-#define PW_VERSION_PROTOCOL_IMPLEMENTATION    0\n+#define PW_VERSION_PROTOCOL_IMPLEMENTATION    1\n@@ -93,0 +93,4 @@\n+    struct pw_protocol_server * (*add_fd_server) (struct pw_protocol *protocol,\n+                           struct pw_impl_core *core,\n+                           int listen_fd, int close_fd,\n+                           const struct spa_dict *props);\n@@ -104,0 +108,1 @@\n+#define pw_protocol_add_fd_server(p,...)    (pw_protocol_get_implementation(p)->add_fd_server(p,__VA_ARGS__))\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/pipewire\/protocol.h","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -15,0 +15,2 @@\n+ *\n+ * \\see \\ref pw_proxy\n@@ -79,1 +81,1 @@\n- * See \\ref page_proxy\n+ * \\see \\ref page_proxy\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/pipewire\/proxy.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -13,0 +13,2 @@\n+ *\n+ * \\see \\ref pw_stream\n@@ -59,1 +61,3 @@\n- * implement a Sink.\n+ * implement a Sink. An application will use a \\ref PW_DIRECTION_INPUT\n+ * stream to record data. A virtual sound card will use a\n+ * \\ref PW_DIRECTION_INPUT stream to implement audio playback.\n@@ -63,1 +67,3 @@\n- * a Source.\n+ * a Source. An application will use a \\ref PW_DIRECTION_OUTPUT\n+ * stream to produce data. A virtual sound card or camera will use a\n+ * \\ref PW_DIRECTION_OUTPUT stream to implement audio or video recording.\n@@ -130,0 +136,10 @@\n+ * Although not strictly required, it is recommended to call \\ref\n+ * pw_stream_dequeue_buffer() and pw_stream_queue_buffer() from the\n+ * process() callback to minimize the amount of buffering and\n+ * maximize the amount of buffer reuse in the stream.\n+ *\n+ * It is also possible to dequeue the buffer from the process event,\n+ * then process and queue the buffer from a helper thread. It is also\n+ * possible to dequeue, process and queue a buffer from a helper thread\n+ * after receiving the process event.\n+ *\n@@ -132,0 +148,7 @@\n+ * The process event is emitted when a new buffer should be queued.\n+ *\n+ * When the PW_STREAM_FLAG_RT_PROCESS flag was given, this function will be\n+ * called from a realtime thread and it is not safe to call non-reatime\n+ * functions such as doing file operations, blocking operations or any of\n+ * the PipeWire functions that are not explicitly marked as being RT safe.\n+ *\n@@ -139,2 +162,39 @@\n- * The process event is emitted when PipeWire has emptied a buffer that\n- * can now be refilled.\n+ * Although not strictly required, it is recommended to call \\ref\n+ * pw_stream_dequeue_buffer() and pw_stream_queue_buffer() from the\n+ * process() callback to minimize the amount of buffering and\n+ * maximize the amount of buffer reuse in the stream.\n+ *\n+ * Buffers that are queued after the process event completes will be delayed\n+ * to the next processing cycle.\n+ *\n+ * \\section sec_stream_driving Driving the graph\n+ *\n+ * Starting in 0.3.34, it is possible for a stream to drive the graph.\n+ * This allows interrupt-driven scheduling for drivers implemented as\n+ * PipeWire streams, without having to reimplement the stream as a SPA\n+ * plugin.\n+ *\n+ * A stream cannot drive the graph unless it is in the\n+ * \\ref PW_STREAM_STATE_STREAMING state and \\ref pw_stream_is_driving() returns\n+ * true. It must then use pw_stream_trigger_process() to start the graph\n+ * cycle.\n+ *\n+ * \\ref pw_stream_trigger_process() will result in a process event, where a buffer\n+ * should be dequeued, and queued again. This is the recommended behaviour that\n+ * minimizes buffering and maximized buffer reuse.\n+ *\n+ * Producers of data that drive the graph can also dequeue a buffer in a helper\n+ * thread, fill it with data and then call \\ref pw_stream_trigger_process() to\n+ * start the graph cycle. In the process event they will then queue the filled\n+ * buffer and dequeue a new empty buffer to fill again in the helper thread,\n+ *\n+ * Consumers of data that drive the graph (pull based scheduling) will use\n+ * \\ref pw_stream_trigger_process() to start the graph and will dequeue, process\n+ * and queue the buffers in the process event.\n+ *\n+ * \\section sec_stream_process_requests Request processing\n+ *\n+ * A stream that is not driving the graph can request a new graph cycle by doing\n+ * \\ref pw_stream_trigger_process(). This will result in a RequestProcess command\n+ * in the driver stream. If the driver supports this, it can then perform\n+ * \\ref pw_stream_trigger_process() to start the actual graph cycle.\n@@ -154,0 +214,3 @@\n+ * The environment variable PIPEWIRE_AUTOCONNECT can be used to override the\n+ * flag and force apps to autoconnect or not.\n+ *\n@@ -162,1 +225,1 @@\n- * See also \\ref page_streams and \\ref api_pw_core\n+ * \\see \\ref page_streams, \\ref api_pw_core\n@@ -174,0 +237,1 @@\n+#include <spa\/pod\/event.h>\n@@ -185,1 +249,1 @@\n-  * structure can grow as more field are added in the future *\/\n+  * structure can grow as more fields are added in the future *\/\n@@ -188,1 +252,6 @@\n-    void *user_data;        \/**< user data attached to the buffer *\/\n+    void *user_data;        \/**< user data attached to the buffer. The user of\n+                      *  the stream can set custom data associated with the\n+                      *  buffer, typically in the add_buffer event. Any\n+                      *  cleanup should be performed in the remove_buffer\n+                      *  event. The user data is returned unmodified each\n+                      *  time a buffer is dequeued. *\/\n@@ -190,1 +259,1 @@\n-                      *  all queued buffer is returned in the time info.\n+                      *  all queued buffers is returned in the time info.\n@@ -192,1 +261,1 @@\n-                      *  samples in the buffer for this field. *\/\n+                      *  frames in the buffer for this field. *\/\n@@ -195,1 +264,1 @@\n-                      *  streams this will be the amount of samples\n+                      *  streams this will be the amount of frames\n@@ -198,0 +267,5 @@\n+    uint64_t time;            \/**< For capture streams, this field contains the\n+                      *  cycle time in nanoseconds when this buffer was\n+                      *  queued in the stream. It can be compared against\n+                      *  the pw_time values or pw_stream_get_nsec()\n+                      *  Since 1.0.5 *\/\n@@ -226,3 +300,3 @@\n- *    struct timespec ts;\n- *    clock_gettime(CLOCK_MONOTONIC, &ts);\n- *    int64_t diff = SPA_TIMESPEC_TO_NSEC(&ts) - pw_time.now;\n+ *\\code{.c}\n+ *    uint64_t now = pw_stream_get_nsec(stream);\n+ *    int64_t diff = now - pw_time.now;\n@@ -230,0 +304,1 @@\n+ *\\endcode\n@@ -236,0 +311,7 @@\n+ * The delay requires the application to send the stream early relative to other synchronized\n+ * streams in order to arrive at the edge of the graph in time. This is usually done by\n+ * delaying the other streams with the given delay.\n+ *\n+ * Note that the delay can be negative. A negative delay means that this stream should be\n+ * delayed with the (positive) delay relative to other streams.\n+ *\n@@ -241,2 +323,2 @@\n- * the units of this value, for example, time, samples or bytes (below expressed\n- * as app.rate).\n+ * the units of this value, for example, time, samples, frames or bytes (below\n+ * expressed as app.rate).\n@@ -244,1 +326,1 @@\n- * pw_time.buffered is format dependent, for audio\/raw it contains the number of samples\n+ * pw_time.buffered is format dependent, for audio\/raw it contains the number of frames\n@@ -255,0 +337,1 @@\n+ *\\code{.unparsed}\n@@ -258,0 +341,1 @@\n+ *\\endcode\n@@ -261,0 +345,1 @@\n+ *\\code{.unparsed}\n@@ -262,0 +347,1 @@\n+ *\\endcode\n@@ -263,0 +349,1 @@\n+ * Below is an overview of the different timing values:\n@@ -264,0 +351,1 @@\n+ *\\code{.unparsed}\n@@ -275,0 +363,1 @@\n+ *\\endcode\n@@ -277,6 +366,6 @@\n-    int64_t now;            \/**< the monotonic time in nanoseconds. This is the time\n-                      *  when this time report was updated. It is usually\n-                      *  updated every graph cycle. You can use the current\n-                      *  monotonic time to calculate the elapsed time between\n-                      *  this report and the current state and calculate\n-                      *  updated ticks and delay values. *\/\n+    int64_t now;            \/**< the time in nanoseconds. This is the time when this\n+                      *  time report was updated. It is usually updated every\n+                      *  graph cycle. You can use pw_stream_get_nsec() to\n+                      *  calculate the elapsed time between this report and\n+                      *  the current time and calculate updated ticks and delay\n+                      *  values. *\/\n@@ -301,1 +390,1 @@\n-                      *  number of samples buffered in the resampler.\n+                      *  number of frames buffered in the resampler.\n@@ -303,2 +392,6 @@\n-    uint32_t queued_buffers;    \/**< The number of buffers that are queued. Since 0.3.50 *\/\n-    uint32_t avail_buffers;        \/**< The number of buffers that can be dequeued. Since 0.3.50 *\/\n+    uint32_t queued_buffers;    \/**< the number of buffers that are queued. Since 0.3.50 *\/\n+    uint32_t avail_buffers;        \/**< the number of buffers that can be dequeued. Since 0.3.50 *\/\n+    uint64_t size;            \/**< for audio\/raw playback streams, this contains the number of\n+                      *  samples requested by the resampler for the current\n+                      *  quantum. for audio\/raw capture streams this will be the number\n+                      *  of samples available for the current quantum. Since 1.1.0 *\/\n@@ -345,1 +438,4 @@\n-    \/** a trigger_process completed. Since version 0.3.40:2 *\/\n+    \/** a trigger_process completed. Since version 0.3.40:2.\n+     *  This is normally called from the mainloop but since 1.1.0 it\n+     *  can also be called directly from the realtime data\n+     *  thread if the user is prepared to deal with this. *\/\n@@ -360,1 +456,2 @@\n-    PW_STREAM_FLAG_MAP_BUFFERS    = (1 << 2),    \/**< mmap the buffers except DmaBuf *\/\n+    PW_STREAM_FLAG_MAP_BUFFERS    = (1 << 2),    \/**< mmap the buffers except DmaBuf that is not\n+                              *  explicitly marked as mappable. *\/\n@@ -378,0 +475,15 @@\n+    PW_STREAM_FLAG_ASYNC        = (1 << 10),    \/**< Buffers will not be dequeued\/queued from\n+                              *  the realtime process() function. This is\n+                              *  assumed when RT_PROCESS is unset but can\n+                              *  also be the case when the process() function\n+                              *  does a trigger_process() that will then\n+                              *  dequeue\/queue a buffer from another process()\n+                              *  function. since 0.3.73 *\/\n+    PW_STREAM_FLAG_EARLY_PROCESS    = (1 << 11),    \/**< Call process as soon as there is a buffer\n+                              *  to dequeue. This is only relevant for\n+                              *  playback and when not using RT_PROCESS. It\n+                              *  can be used to keep the maximum number of\n+                              *  buffers queued. Since 0.3.81 *\/\n+    PW_STREAM_FLAG_RT_TRIGGER_DONE    = (1 << 12),    \/**< Call trigger_done from the realtime\n+                              *  thread. You MUST use RT safe functions\n+                              *  in the trigger_done callback. Since 1.1.0 *\/\n@@ -380,1 +492,1 @@\n-\/** Create a new unconneced \\ref pw_stream\n+\/** Create a new unconnected \\ref pw_stream\n@@ -388,1 +500,1 @@\n-pw_stream_new_simple(struct pw_loop *loop,    \/**< a \\ref pw_loop to use *\/\n+pw_stream_new_simple(struct pw_loop *loop,    \/**< a \\ref pw_loop to use as the main loop *\/\n@@ -450,6 +562,1 @@\n-\/** Complete the negotiation process with result code \\a res\n- *\n- * This function should be called after notification of the format.\n-\n- * When \\a res indicates success, \\a params contain the parameters for the\n- * allocation state.  *\/\n+\/** Update the param exposed on the stream. *\/\n@@ -458,3 +565,1 @@\n-            const struct spa_pod **params,    \/**< an array of params. The params should\n-                              *  ideally contain parameters for doing\n-                              *  buffer allocation. *\/\n+            const struct spa_pod **params,    \/**< an array of params. *\/\n@@ -463,0 +568,8 @@\n+\/**\n+ * Set a parameter on the stream. This is like pw_stream_set_control() but with\n+ * a complete spa_pod param. It can also be called from the param_changed event handler\n+ * to intercept and modify the param for the adapter. Since 0.3.70 *\/\n+int pw_stream_set_param(struct pw_stream *stream,    \/**< a \\ref pw_stream *\/\n+            uint32_t id,            \/**< the id of the param *\/\n+            const struct spa_pod *param    \/**< the params to set *\/);\n+\n@@ -469,1 +582,1 @@\n-\/** Query the time on the stream *\/\n+\/** Query the time on the stream, RT safe *\/\n@@ -472,0 +585,8 @@\n+\/** Get the current time in nanoseconds. This value can be compared with\n+ * the \\ref pw_time.now value. RT safe. Since 1.1.0 *\/\n+uint64_t pw_stream_get_nsec(struct pw_stream *stream);\n+\n+\/** Get the data loop that is doing the processing of this stream. This loop\n+ * is assigned after pw_stream_connect().  * Since 1.1.0 *\/\n+struct pw_loop *pw_stream_get_data_loop(struct pw_stream *stream);\n+\n@@ -473,1 +594,1 @@\n- * use pw_stream_get_time_n() to get the fields added since 0.3.50. *\/\n+ * use pw_stream_get_time_n() to get the fields added since 0.3.50. RT safe. *\/\n@@ -478,1 +599,1 @@\n- * for capture streams. *\/\n+ * for capture streams. RT safe. *\/\n@@ -481,1 +602,1 @@\n-\/** Submit a buffer for playback or recycle a buffer for capture. *\/\n+\/** Submit a buffer for playback or recycle a buffer for capture. RT safe. *\/\n@@ -484,0 +605,4 @@\n+\/** Return a buffer to the queue without using it. This makes the buffer\n+ * immediately available to dequeue again. RT safe. *\/\n+int pw_stream_return_buffer(struct pw_stream *stream, struct pw_buffer *buffer);\n+\n@@ -488,1 +613,5 @@\n- * be called when all data is played or recorded *\/\n+ * be called when all data is played or recorded. The stream can be resumed\n+ * after the drain by setting it active again with\n+ * \\ref pw_stream_set_active(). A flush without a drain is mostly useful afer\n+ * a state change to PAUSED, to flush any remaining data from the queues and\n+ * the converters. RT safe. *\/\n@@ -497,0 +626,15 @@\n+\/** Check if the graph is using lazy scheduling. If the stream is\n+ * driving according to \\ref pw_stream_is_driving(), then it should\n+ * consider taking into account the RequestProcess commands when\n+ * driving the graph.\n+ *\n+ * If the stream is not driving, it should send out RequestProcess\n+ * events with \\ref pw_stream_emit_event() or indirectly with\n+ * \\ref pw_stream_trigger_process() to suggest a new graph cycle\n+ * to the driver.\n+ *\n+ * It is not a requirement that all RequestProcess events\/commands\n+ * need to start a graph cycle.\n+ * Since 1.4.0 *\/\n+bool pw_stream_is_lazy(struct pw_stream *stream);\n+\n@@ -498,1 +642,28 @@\n- * scheduled and process() will be called. Since 0.3.34 *\/\n+ * be scheduled when the stream is driving according to\n+ * \\ref pw_stream_is_driving(). If it successfully finishes, process()\n+ * will be called and the trigger_done event will be emitted. It is\n+ * possible for the graph iteration to not finish, so\n+ * pw_stream_trigger_process() needs to be called again even if process()\n+ * and trigger_done is not called.\n+ *\n+ * If there is a deadline after which the stream will have xrun,\n+ * pw_stream_trigger_process() should be called then, whether or not\n+ * process()\/trigger_done has been called. Sound hardware will xrun if\n+ * there is any delay in audio processing, so the ALSA plugin triggers the\n+ * graph every quantum to ensure audio keeps flowing. Drivers that\n+ * do not have a deadline, such as the freewheel driver, should\n+ * use a timeout to ensure that forward progress keeps being made.\n+ * A reasonable choice of deadline is three times the quantum: if\n+ * the graph is taking 3x longer than normal, it is likely that it\n+ * is hung and should be retriggered.\n+ *\n+ * Streams that are not drivers according to \\ref pw_stream_is_driving()\n+ * can also call this method. The result is that a RequestProcess event\n+ * is sent to the driver. If the graph is lazy scheduling according to\n+ * \\ref pw_stream_is_lazy(), this might result in a graph cycle by the\n+ * driver. If the graph is not lazy scheduling and the stream is not a\n+ * driver, this method will have no effect.\n+ *\n+ * RT safe.\n+ *\n+ * Since 0.3.34 *\/\n@@ -501,0 +672,12 @@\n+\/** Emit an event from this stream. RT safe.\n+ * Since 1.2.6 *\/\n+int pw_stream_emit_event(struct pw_stream *stream, const struct spa_event *event);\n+\n+\/** Adjust the rate of the stream.\n+ * When the stream is using an adaptive resampler, adjust the resampler rate.\n+ * When there is no resampler, -ENOTSUP is returned. Activating the adaptive\n+ * resampler will add a small amount of delay to the samples, you can deactivate\n+ * it again by setting a value <= 0.0. RT safe.\n+ * Since 1.4.0 *\/\n+int pw_stream_set_rate(struct pw_stream *stream, double rate);\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/pipewire\/stream.h","additions":227,"deletions":44,"binary":false,"changes":271,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_TYPE_H\n+#define PIPEWIRE_TYPE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type.h>\n+\n+\/** \\defgroup pw_type Type info\n+ * Type information\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_type\n+ * \\{\n+ *\/\n+\n+enum {\n+    PW_TYPE_FIRST = SPA_TYPE_VENDOR_PipeWire,\n+};\n+\n+#define PW_TYPE_INFO_BASE        \"PipeWire:\"\n+\n+#define PW_TYPE_INFO_Object        PW_TYPE_INFO_BASE \"Object\"\n+#define PW_TYPE_INFO_OBJECT_BASE    PW_TYPE_INFO_Object \":\"\n+\n+#define PW_TYPE_INFO_Interface        PW_TYPE_INFO_BASE \"Interface\"\n+#define PW_TYPE_INFO_INTERFACE_BASE    PW_TYPE_INFO_Interface \":\"\n+\n+const struct spa_type_info * pw_type_info(void);\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_TYPE_H *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/pipewire\/type.h","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -18,0 +18,1 @@\n+#include <errno.h>\n@@ -23,0 +24,1 @@\n+#include <spa\/utils\/cleanup.h>\n@@ -48,0 +50,6 @@\n+char **pw_strv_parse(const char *val, size_t len, int max_tokens, int *n_tokens);\n+\n+int pw_strv_find(char **a, const char *b);\n+\n+int pw_strv_find_common(char **a, char **b);\n+\n@@ -95,0 +103,4 @@\n+SPA_DEFINE_AUTO_CLEANUP(pw_strv, char **, {\n+    spa_clear_ptr(*thing, pw_free_strv);\n+})\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/pipewire\/utils.h","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -15,0 +15,8 @@\n+#ifndef SPA_API_BUFFER\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_BUFFER SPA_API_IMPL\n+ #else\n+  #define SPA_API_BUFFER static inline\n+ #endif\n+#endif\n+\n@@ -30,3 +38,9 @@\n-    SPA_DATA_MemFd,            \/**< generic fd, mmap to get to memory *\/\n-    SPA_DATA_DmaBuf,        \/**< fd to dmabuf memory *\/\n-    SPA_DATA_MemId,            \/**< memory is identified with an id *\/\n+    SPA_DATA_MemFd,            \/**< memfd, mmap to get to memory. *\/\n+    SPA_DATA_DmaBuf,        \/**< fd to dmabuf memory. This might not be readily\n+                      *  mappable (unless the MAPPABLE flag is set) and should\n+                      *  normally be handled with DMABUF apis. *\/\n+    SPA_DATA_MemId,            \/**< memory is identified with an id. The actual memory\n+                      *  can be obtained in some other way and can be identified\n+                      *  with this id. *\/\n+    SPA_DATA_SyncObj,        \/**< a syncobj, usually requires a spa_meta_sync_timeline metadata\n+                      *  with timeline points. *\/\n@@ -68,0 +82,3 @@\n+#define SPA_DATA_FLAG_MAPPABLE    (1u<<3)    \/**< data is mappable with simple mmap\/munmap. Some memory\n+                      *  types are not simply mappable (DmaBuf) unless explicitly\n+                      *  specified with this flag. *\/\n@@ -70,1 +87,1 @@\n-    uint32_t mapoffset;        \/**< offset to map fd at *\/\n+    uint32_t mapoffset;        \/**< offset to map fd at, this is page aligned *\/\n@@ -85,1 +102,1 @@\n-static inline struct spa_meta *spa_buffer_find_meta(const struct spa_buffer *b, uint32_t type)\n+SPA_API_BUFFER struct spa_meta *spa_buffer_find_meta(const struct spa_buffer *b, uint32_t type)\n@@ -96,1 +113,1 @@\n-static inline void *spa_buffer_find_meta_data(const struct spa_buffer *b, uint32_t type, size_t size)\n+SPA_API_BUFFER void *spa_buffer_find_meta_data(const struct spa_buffer *b, uint32_t type, size_t size)\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/buffer\/buffer.h","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -15,0 +15,8 @@\n+#ifndef SPA_API_META\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_META SPA_API_IMPL\n+ #else\n+  #define SPA_API_META static inline\n+ #endif\n+#endif\n+\n@@ -31,0 +39,1 @@\n+    SPA_META_SyncTimeline,        \/**< struct spa_meta_sync_timeline *\/\n@@ -48,1 +57,1 @@\n-static inline void *spa_meta_first(const struct spa_meta *m) {\n+SPA_API_META void *spa_meta_first(const struct spa_meta *m) {\n@@ -51,2 +60,2 @@\n-#define spa_meta_first spa_meta_first\n-static inline void *spa_meta_end(const struct spa_meta *m) {\n+\n+SPA_API_META void *spa_meta_end(const struct spa_meta *m) {\n@@ -55,1 +64,0 @@\n-#define spa_meta_end spa_meta_end\n@@ -82,1 +90,1 @@\n-static inline bool spa_meta_region_is_valid(const struct spa_meta_region *m) {\n+SPA_API_META bool spa_meta_region_is_valid(const struct spa_meta_region *m) {\n@@ -85,1 +93,0 @@\n-#define spa_meta_region_is_valid spa_meta_region_is_valid\n@@ -89,1 +96,1 @@\n-    for ((pos) = (__typeof(pos))spa_meta_first(meta);            \\\n+    for ((pos) = (__typeof(pos))spa_meta_first(meta);        \\\n@@ -93,2 +100,0 @@\n-#define spa_meta_bitmap_is_valid(m)    ((m)->format != 0)\n-\n@@ -114,1 +119,3 @@\n-#define spa_meta_cursor_is_valid(m)    ((m)->id != 0)\n+SPA_API_META bool spa_meta_bitmap_is_valid(const struct spa_meta_bitmap *m) {\n+    return m->format != 0;\n+}\n@@ -134,0 +141,4 @@\n+SPA_API_META bool spa_meta_cursor_is_valid(const struct spa_meta_cursor *m) {\n+    return m->id != 0;\n+}\n+\n@@ -152,1 +163,1 @@\n-                          * bufffer in two equal sized parts *\/\n+                          * buffer in two equal sized parts *\/\n@@ -164,0 +175,20 @@\n+\/**\n+ * A timeline point for explicit sync\n+ *\n+ * Metadata to describe the time on the timeline when the buffer\n+ * can be acquired and when it can be reused.\n+ *\n+ * This metadata will require negotiation of 2 extra fds for the acquire\n+ * and release timelines respectively.  One way to achieve this is to place\n+ * this metadata as SPA_PARAM_BUFFERS_metaType when negotiating a buffer\n+ * layout with 2 extra fds.\n+ *\/\n+struct spa_meta_sync_timeline {\n+    uint32_t flags;\n+    uint32_t padding;\n+    uint64_t acquire_point;            \/**< the timeline acquire point, this is when the data\n+                          *  can be accessed. *\/\n+    uint64_t release_point;            \/**< the timeline release point, this timeline point should\n+                          *  be signaled when the data is no longer accessed. *\/\n+};\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/buffer\/meta.h","additions":42,"deletions":11,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+    { SPA_DATA_SyncObj, SPA_TYPE_Int, SPA_TYPE_INFO_DATA_BASE \"SyncObj\", NULL },\n@@ -53,0 +54,16 @@\n+\/* VideoTransform meta *\/\n+#define SPA_TYPE_INFO_META_Transformation    SPA_TYPE_INFO_ENUM_BASE \"Meta:Transformation\"\n+#define SPA_TYPE_INFO_META_TRANSFORMATION_BASE    SPA_TYPE_INFO_META_Transformation \":\"\n+\n+static const struct spa_type_info spa_type_meta_videotransform_type[] = {\n+    { SPA_META_TRANSFORMATION_None, SPA_TYPE_Int, SPA_TYPE_INFO_META_TRANSFORMATION_BASE \"None\", NULL },\n+    { SPA_META_TRANSFORMATION_90, SPA_TYPE_Int, SPA_TYPE_INFO_META_TRANSFORMATION_BASE \"90\", NULL },\n+    { SPA_META_TRANSFORMATION_180, SPA_TYPE_Int, SPA_TYPE_INFO_META_TRANSFORMATION_BASE \"180\", NULL },\n+    { SPA_META_TRANSFORMATION_270, SPA_TYPE_Int, SPA_TYPE_INFO_META_TRANSFORMATION_BASE \"270\", NULL },\n+    { SPA_META_TRANSFORMATION_Flipped, SPA_TYPE_Int, SPA_TYPE_INFO_META_TRANSFORMATION_BASE \"Flipped\", NULL },\n+    { SPA_META_TRANSFORMATION_Flipped90, SPA_TYPE_Int, SPA_TYPE_INFO_META_TRANSFORMATION_BASE \"Flipped90\", NULL },\n+    { SPA_META_TRANSFORMATION_Flipped180, SPA_TYPE_Int, SPA_TYPE_INFO_META_TRANSFORMATION_BASE \"Flipped180\", NULL },\n+    { SPA_META_TRANSFORMATION_Flipped270, SPA_TYPE_Int, SPA_TYPE_INFO_META_TRANSFORMATION_BASE \"Flipped270\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n@@ -63,0 +80,1 @@\n+    { SPA_META_SyncTimeline, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"SyncTimeline\", NULL },\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/buffer\/type-info.h","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,3 +27,6 @@\n-    SPA_CONTROL_Properties,        \/**< data contains a SPA_TYPE_OBJECT_Props *\/\n-    SPA_CONTROL_Midi,        \/**< data contains a spa_pod_bytes with raw midi data *\/\n-    SPA_CONTROL_OSC,        \/**< data contains a spa_pod_bytes with an OSC packet *\/\n+    SPA_CONTROL_Properties,        \/**< SPA_TYPE_OBJECT_Props *\/\n+    SPA_CONTROL_Midi,        \/**< spa_pod_bytes with raw midi data (deprecated, use SPA_CONTROL_UMP) *\/\n+    SPA_CONTROL_OSC,        \/**< spa_pod_bytes with an OSC packet *\/\n+    SPA_CONTROL_UMP,        \/**< spa_pod_bytes with raw UMP (universal MIDI packet)\n+                      *  data. The UMP 32 bit words are stored in native endian\n+                      *  format. *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/control\/control.h","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+    { SPA_CONTROL_UMP, SPA_TYPE_Int, SPA_TYPE_INFO_CONTROL_BASE \"UMP\", NULL },\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/control\/type-info.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -21,1 +21,10 @@\n-static inline const struct spa_type_info *spa_debug_type_find(const struct spa_type_info *info, uint32_t type)\n+#ifndef SPA_API_DEBUG_TYPES\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_DEBUG_TYPES SPA_API_IMPL\n+ #else\n+  #define SPA_API_DEBUG_TYPES static inline\n+ #endif\n+#endif\n+\n+\n+SPA_API_DEBUG_TYPES const struct spa_type_info *spa_debug_type_find(const struct spa_type_info *info, uint32_t type)\n@@ -40,1 +49,1 @@\n-static inline const char *spa_debug_type_short_name(const char *name)\n+SPA_API_DEBUG_TYPES const char *spa_debug_type_short_name(const char *name)\n@@ -42,4 +51,1 @@\n-    const char *h;\n-    if ((h = strrchr(name, ':')) != NULL)\n-        name = h + 1;\n-    return name;\n+    return spa_type_short_name(name);\n@@ -48,1 +54,1 @@\n-static inline const char *spa_debug_type_find_name(const struct spa_type_info *info, uint32_t type)\n+SPA_API_DEBUG_TYPES const char *spa_debug_type_find_name(const struct spa_type_info *info, uint32_t type)\n@@ -55,1 +61,1 @@\n-static inline const char *spa_debug_type_find_short_name(const struct spa_type_info *info, uint32_t type)\n+SPA_API_DEBUG_TYPES const char *spa_debug_type_find_short_name(const struct spa_type_info *info, uint32_t type)\n@@ -63,1 +69,1 @@\n-static inline uint32_t spa_debug_type_find_type(const struct spa_type_info *info, const char *name)\n+SPA_API_DEBUG_TYPES uint32_t spa_debug_type_find_type(const struct spa_type_info *info, const char *name)\n@@ -79,1 +85,1 @@\n-static inline const struct spa_type_info *spa_debug_type_find_short(const struct spa_type_info *info, const char *name)\n+SPA_API_DEBUG_TYPES const struct spa_type_info *spa_debug_type_find_short(const struct spa_type_info *info, const char *name)\n@@ -93,1 +99,1 @@\n-static inline uint32_t spa_debug_type_find_type_short(const struct spa_type_info *info, const char *name)\n+SPA_API_DEBUG_TYPES uint32_t spa_debug_type_find_type_short(const struct spa_type_info *info, const char *name)\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/debug\/types.h","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    SPA_IO_Range,        \/**< expected byte range, struct spa_io_range *\/\n+    SPA_IO_Range,        \/**< expected byte range, struct spa_io_range (currently not used in PipeWire) *\/\n@@ -36,1 +36,2 @@\n-    SPA_IO_Latency,        \/**< latency reporting, struct spa_io_latency *\/\n+    SPA_IO_Latency,        \/**< latency reporting, struct spa_io_latency (currently not used in\n+                  * PipeWire). \\see spa_param_latency *\/\n@@ -41,1 +42,2 @@\n-    SPA_IO_Memory,        \/**< memory pointer, struct spa_io_memory *\/\n+    SPA_IO_Memory,        \/**< memory pointer, struct spa_io_memory (currently not used in PipeWire) *\/\n+    SPA_IO_AsyncBuffers,    \/**< async area to exchange buffers, struct spa_io_async_buffers *\/\n@@ -111,0 +113,13 @@\n+ *\n+ * Driver nodes are supposed to update the contents of \\ref SPA_IO_Clock before\n+ * signaling the start of a graph cycle.  These updated clock values become\n+ * visible to other nodes in \\ref SPA_IO_Position. Non-driver nodes do\n+ * not need to update the contents of their \\ref SPA_IO_Clock.\n+ *\n+ * The host generally gives each node a separate \\ref spa_io_clock in \\ref\n+ * SPA_IO_Clock, so that updates made by the driver are not visible in the\n+ * contents of \\ref SPA_IO_Clock of other nodes. Instead, \\ref SPA_IO_Position\n+ * is used to look up the current graph time.\n+ *\n+ * A node is a driver when \\ref spa_io_clock.id in \\ref SPA_IO_Clock and\n+ * \\ref spa_io_position.clock.id in \\ref SPA_IO_Position are the same.\n@@ -113,14 +128,24 @@\n-#define SPA_IO_CLOCK_FLAG_FREEWHEEL (1u<<0)\n-    uint32_t flags;            \/**< clock flags *\/\n-    uint32_t id;            \/**< unique clock id, set by application *\/\n-    char name[64];            \/**< clock name prefixed with API, set by node. The clock name\n-                      *  is unique per clock and can be used to check if nodes\n-                      *  share the same clock. *\/\n-    uint64_t nsec;            \/**< time in nanoseconds against monotonic clock *\/\n-    struct spa_fraction rate;    \/**< rate for position\/duration\/delay *\/\n-    uint64_t position;        \/**< current position *\/\n-    uint64_t duration;        \/**< duration of current cycle *\/\n-    int64_t delay;            \/**< delay between position and hardware,\n-                      *  positive for capture, negative for playback *\/\n-    double rate_diff;        \/**< rate difference between clock and monotonic time *\/\n-    uint64_t next_nsec;        \/**< estimated next wakeup time in nanoseconds *\/\n+#define SPA_IO_CLOCK_FLAG_FREEWHEEL    (1u<<0) \/* graph is freewheeling *\/\n+#define SPA_IO_CLOCK_FLAG_XRUN_RECOVER    (1u<<1) \/* recovering from xrun *\/\n+#define SPA_IO_CLOCK_FLAG_LAZY        (1u<<2) \/* lazy scheduling *\/\n+#define SPA_IO_CLOCK_FLAG_NO_RATE    (1u<<3) \/* the rate of the clock is only approximately.\n+                         * it is recommended to use the nsec as a clock source.\n+                         * The rate_diff contains the measured inaccuracy. *\/\n+    uint32_t flags;            \/**< Clock flags *\/\n+    uint32_t id;            \/**< Unique clock id, set by host application *\/\n+    char name[64];            \/**< Clock name prefixed with API, set by node when it receives\n+                      *  \\ref SPA_IO_Clock. The clock name is unique per clock and\n+                      *  can be used to check if nodes share the same clock. *\/\n+    uint64_t nsec;            \/**< Time in nanoseconds against monotonic clock\n+                      * (CLOCK_MONOTONIC). This fields reflects a real time instant\n+                      * in the past. The value may have jitter. *\/\n+    struct spa_fraction rate;    \/**< Rate for position\/duration\/delay\/xrun *\/\n+    uint64_t position;        \/**< Current position, in samples @ \\ref rate *\/\n+    uint64_t duration;        \/**< Duration of current cycle, in samples @ \\ref rate *\/\n+    int64_t delay;            \/**< Delay between position and hardware, in samples @ \\ref rate *\/\n+    double rate_diff;        \/**< Rate difference between clock and monotonic time, as a ratio of\n+                      *  clock speeds. *\/\n+    uint64_t next_nsec;        \/**< Estimated next wakeup time in nanoseconds.\n+                      *  This time is a logical start time of the next cycle, and\n+                      *  is not necessarily in the future.\n+                      *\/\n@@ -128,3 +153,3 @@\n-    struct spa_fraction target_rate;    \/**< target rate of next cycle *\/\n-    uint64_t target_duration;        \/**< target duration of next cycle *\/\n-    uint32_t target_seq;            \/**< seq counter. must be equal at start and\n+    struct spa_fraction target_rate;    \/**< Target rate of next cycle *\/\n+    uint64_t target_duration;        \/**< Target duration of next cycle *\/\n+    uint32_t target_seq;            \/**< Seq counter. must be equal at start and\n@@ -132,2 +157,2 @@\n-\n-    uint32_t padding[3];\n+    uint32_t cycle;            \/**< incremented each time the graph is started *\/\n+    uint64_t xrun;            \/**< Estimated accumulated xrun duration *\/\n@@ -148,1 +173,5 @@\n-\/** latency reporting *\/\n+\/**\n+ * Latency reporting\n+ *\n+ * Currently not used in PipeWire. Instead, \\see spa_param_latency\n+ *\/\n@@ -169,1 +198,3 @@\n-    uint32_t padding[8];\n+    double bar_start_tick;\n+    double ticks_per_beat;\n+    uint32_t padding[4];\n@@ -248,2 +279,7 @@\n- * It is set on all nodes and the clock id will contain the clock of the\n- * driving node in the graph.\n+ * It is set on all nodes in \\ref SPA_IO_Position, and the contents of \\ref\n+ * spa_io_position.clock contain the clock updates made by the driving node in\n+ * the graph in its \\ref SPA_IO_Clock.  Also, \\ref spa_io_position.clock.id\n+ * will contain the clock id of the driving node in the graph.\n+ *\n+ * The position clock indicates the logical start time of the current graph\n+ * cycle.\n@@ -272,1 +308,34 @@\n-\/** rate matching *\/\n+\/**\n+ * Rate matching.\n+ *\n+ * It is usually set on the nodes that process resampled data, by\n+ * the component (audioadapter) that handles resampling between graph\n+ * and node rates. The \\a flags and \\a rate fields may be modified by the node.\n+ *\n+ * The node can request a correction to the resampling rate in its process(), by setting\n+ * \\ref SPA_IO_RATE_MATCH_ACTIVE on \\a flags, and setting \\a rate to the desired rate\n+ * correction.  Usually the rate is obtained from DLL or other adaptive mechanism that\n+ * e.g. drives the node buffer fill level toward a specific value.\n+ *\n+ * When resampling to (graph->node) direction, the number of samples produced\n+ * by the resampler varies on each cycle, as the rates are not commensurate.\n+ *\n+ * When resampling to (node->graph) direction, the number of samples consumed by the\n+ * resampler varies. Node output ports in process() should produce \\a size number of\n+ * samples to match what the resampler needs to produce one graph quantum of output\n+ * samples.\n+ *\n+ * Resampling filters introduce processing delay, given by \\a delay and \\a delay_frac, in\n+ * samples at node rate. The delay varies on each cycle e.g. when resampling between\n+ * noncommensurate rates.\n+ *\n+ * The first sample output (graph->node) or consumed (node->graph) by the resampler is\n+ * offset by \\a delay + \\a delay_frac \/ 1e9 node samples relative to the nominal graph\n+ * cycle start position:\n+ *\n+ * \\code{.unparsed}\n+ * first_resampled_sample_nsec =\n+ *    first_original_sample_nsec\n+ *    - (rate_match->delay * SPA_NSEC_PER_SEC + rate_match->delay_frac) \/ node_rate\n+ * \\endcode\n+ *\/\n@@ -274,1 +343,2 @@\n-    uint32_t delay;            \/**< extra delay in samples for resampler *\/\n+    uint32_t delay;            \/**< resampling delay, in samples at\n+                     * node rate *\/\n@@ -276,1 +346,1 @@\n-    double rate;            \/**< rate for resampler *\/\n+    double rate;            \/**< rate for resampler (set by node) *\/\n@@ -278,2 +348,10 @@\n-    uint32_t flags;            \/**< extra flags *\/\n-    uint32_t padding[7];\n+    uint32_t flags;            \/**< extra flags (set by node) *\/\n+    int32_t delay_frac;        \/**< resampling delay fractional part,\n+                     * in units of nanosamples (1\/10^9 sample) at node rate *\/\n+    uint32_t padding[6];\n+};\n+\n+\/** async buffers *\/\n+struct spa_io_async_buffers {\n+    struct spa_io_buffers buffers[2];    \/**< async buffers, writers write to current (cycle+1)&1,\n+                          *  readers read from (cycle)&1 *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/node\/io.h","additions":109,"deletions":31,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+    { SPA_IO_AsyncBuffers, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"AsyncBuffers\", NULL },\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/node\/type-info.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -15,0 +15,5 @@\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/audio\/aac-types.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -14,0 +14,5 @@\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/audio\/aac.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -15,0 +15,5 @@\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/audio\/amr-types.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -14,0 +14,5 @@\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/audio\/amr.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -15,0 +15,13 @@\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#ifndef SPA_API_AUDIO_IEC958_TYPES\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_AUDIO_IEC958_TYPES SPA_API_IMPL\n+ #else\n+  #define SPA_API_AUDIO_IEC958_TYPES static inline\n+ #endif\n+#endif\n+\n@@ -31,0 +44,8 @@\n+SPA_API_AUDIO_IEC958_TYPES uint32_t spa_type_audio_iec958_codec_from_short_name(const char *name)\n+{\n+    return spa_type_from_short_name(name, spa_type_audio_iec958_codec, SPA_AUDIO_IEC958_CODEC_UNKNOWN);\n+}\n+SPA_API_AUDIO_IEC958_TYPES const char * spa_type_audio_iec958_codec_to_short_name(uint32_t type)\n+{\n+    return spa_type_to_short_name(type, spa_type_audio_iec958_codec, \"UNKNOWN\");\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/audio\/iec958-types.h","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -15,0 +15,5 @@\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/audio\/mp3-types.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -14,0 +14,5 @@\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/audio\/mp3.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -18,0 +18,1 @@\n+#include <spa\/utils\/string.h>\n@@ -20,0 +21,8 @@\n+#ifndef SPA_API_AUDIO_RAW_TYPES\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_AUDIO_RAW_TYPES SPA_API_IMPL\n+ #else\n+  #define SPA_API_AUDIO_RAW_TYPES static inline\n+ #endif\n+#endif\n+\n@@ -131,0 +140,9 @@\n+SPA_API_AUDIO_RAW_TYPES uint32_t spa_type_audio_format_from_short_name(const char *name)\n+{\n+    return spa_type_from_short_name(name, spa_type_audio_format, SPA_AUDIO_FORMAT_UNKNOWN);\n+}\n+SPA_API_AUDIO_RAW_TYPES const char * spa_type_audio_format_to_short_name(uint32_t type)\n+{\n+    return spa_type_to_short_name(type, spa_type_audio_format, \"UNKNOWN\");\n+}\n+\n@@ -250,0 +268,10 @@\n+SPA_API_AUDIO_RAW_TYPES uint32_t spa_type_audio_channel_from_short_name(const char *name)\n+{\n+    return spa_type_from_short_name(name, spa_type_audio_channel, SPA_AUDIO_CHANNEL_UNKNOWN);\n+}\n+SPA_API_AUDIO_RAW_TYPES const char * spa_type_audio_channel_to_short_name(uint32_t type)\n+{\n+    return spa_type_to_short_name(type, spa_type_audio_channel, \"UNK\");\n+}\n+\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/audio\/raw-types.h","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -14,9 +14,1 @@\n-#if !defined(__FreeBSD__) && !defined(__MidnightBSD__) && !defined(AIX)\n-#include <endian.h>\n-#endif\n-\n-#if defined(AIX)\n-#include <sys\/machine.h>\n-#define __BIG_ENDIAN      BIG_ENDIAN\n-#define __BYTE_ORDER      BIG_ENDIAN\n-#endif\n+#include <spa\/utils\/endian.h>\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/audio\/raw.h","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -15,0 +15,5 @@\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/audio\/wma-types.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -14,0 +14,5 @@\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/audio\/wma.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+    SPA_BLUETOOTH_AUDIO_CODEC_AAC_ELD,\n@@ -37,0 +38,1 @@\n+    SPA_BLUETOOTH_AUDIO_CODEC_OPUS_G,\n@@ -41,0 +43,1 @@\n+    SPA_BLUETOOTH_AUDIO_CODEC_LC3_SWB,\n@@ -44,0 +47,3 @@\n+\n+    \/* ASHA *\/\n+    SPA_BLUETOOTH_AUDIO_CODEC_G722 = 0x300,\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/bluetooth\/audio.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+    { SPA_BLUETOOTH_AUDIO_CODEC_AAC_ELD, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"aac_eld\", NULL },\n@@ -41,0 +42,1 @@\n+    { SPA_BLUETOOTH_AUDIO_CODEC_OPUS_G, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"opus_g\", NULL },\n@@ -44,0 +46,1 @@\n+    { SPA_BLUETOOTH_AUDIO_CODEC_LC3_SWB, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"lc3_swb\", NULL },\n@@ -47,0 +50,2 @@\n+    { SPA_BLUETOOTH_AUDIO_CODEC_G722, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"g722\", NULL },\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/bluetooth\/type-info.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+    { SPA_PARAM_BUFFERS_metaType, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BLOCK_INFO_BASE \"metaType\", NULL },\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/buffers-types.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-    SPA_PARAM_BUFFERS_dataType,    \/**< possible memory types (Int, mask of enum spa_data_type) *\/\n+    SPA_PARAM_BUFFERS_dataType,    \/**< possible memory types (flags choice Int, mask of enum spa_data_type) *\/\n+    SPA_PARAM_BUFFERS_metaType,    \/**< required meta data types (Int, mask of enum spa_meta_type) *\/\n@@ -33,2 +34,2 @@\n-    SPA_PARAM_META_type,    \/**< the metadata, one of enum spa_meta_type (Id enum spa_meta_type) *\/\n-    SPA_PARAM_META_size,    \/**< the expected maximum size the meta (Int) *\/\n+    SPA_PARAM_META_type,        \/**< the metadata, one of enum spa_meta_type (Id enum spa_meta_type) *\/\n+    SPA_PARAM_META_size,        \/**< the expected maximum size the meta (Int) *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/buffers.h","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -21,1 +21,9 @@\n-static inline int\n+#ifndef SPA_API_FORMAT_UTILS\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_FORMAT_UTILS SPA_API_IMPL\n+ #else\n+  #define SPA_API_FORMAT_UTILS static inline\n+ #endif\n+#endif\n+\n+SPA_API_FORMAT_UTILS int\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/format-utils.h","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -144,0 +144,2 @@\n+    SPA_FORMAT_CONTROL_types,        \/**< possible control types (flags choice Int,\n+                          *  mask of enum spa_control_type) *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/format.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -19,1 +19,18 @@\n-\/** properties for SPA_TYPE_OBJECT_ParamLatency *\/\n+\/**\n+ * Properties for SPA_TYPE_OBJECT_ParamLatency\n+ *\n+ * The latency indicates:\n+ *\n+ * - for playback: time delay between start of a graph cycle, and the rendering of\n+ *   the first sample of that cycle in audio output.\n+ *\n+ * - for capture: time delay between start of a graph cycle, and the first sample\n+ *   of that cycle having occurred in audio input.\n+ *\n+ * For physical output\/input, the latency is intended to correspond to the\n+ * rendering\/capture of physical audio, including hardware internal rendering delay.\n+ *\n+ * The latency values are adjusted by \\ref SPA_PROP_latencyOffsetNsec or\n+ * SPA_PARAM_ProcessLatency, if present. (e.g. for ALSA this is used to adjust for\n+ * the internal hardware latency).\n+ *\/\n@@ -25,2 +42,2 @@\n-    SPA_PARAM_LATENCY_minRate,        \/**< min latency (Int) relative to rate *\/\n-    SPA_PARAM_LATENCY_maxRate,        \/**< max latency (Int) relative to rate *\/\n+    SPA_PARAM_LATENCY_minRate,        \/**< min latency (Int) relative to graph rate *\/\n+    SPA_PARAM_LATENCY_maxRate,        \/**< max latency (Int) relative to graph rate *\/\n@@ -36,4 +53,4 @@\n-    uint32_t min_rate;\n-    uint32_t max_rate;\n-    uint64_t min_ns;\n-    uint64_t max_ns;\n+    int32_t min_rate;\n+    int32_t max_rate;\n+    int64_t min_ns;\n+    int64_t max_ns;\n@@ -44,1 +61,6 @@\n-\/** properties for SPA_TYPE_OBJECT_ParamProcessLatency *\/\n+\/**\n+ * Properties for SPA_TYPE_OBJECT_ParamProcessLatency\n+ *\n+ * The processing latency indicates logical time delay between a sample in an input port,\n+ * and a corresponding sample in an output port, relative to the graph time.\n+ *\/\n@@ -48,1 +70,1 @@\n-    SPA_PARAM_PROCESS_LATENCY_rate,        \/**< latency (Int) relative to rate *\/\n+    SPA_PARAM_PROCESS_LATENCY_rate,        \/**< latency (Int) relative to graph rate *\/\n@@ -55,2 +77,2 @@\n-    uint32_t rate;\n-    uint64_t ns;\n+    int32_t rate;\n+    int64_t ns;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/latency.h","additions":33,"deletions":11,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+    { SPA_PARAM_Tag, SPA_TYPE_OBJECT_ParamTag, SPA_TYPE_INFO_PARAM_ID_BASE \"Tag\", NULL },\n@@ -57,0 +58,5 @@\n+static const struct spa_type_info spa_type_prop_int_array[] = {\n+    { SPA_PROP_START, SPA_TYPE_Int, SPA_TYPE_INFO_BASE \"intArray\", NULL, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/param-types.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    SPA_PARAM_Tag,            \/**< tag reporting, a SPA_TYPE_OBJECT_ParamTag. Since 0.3.79 *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/param.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+    { SPA_PROFILER_followerClock, SPA_TYPE_Struct, SPA_TYPE_INFO_PROFILER_BASE \"followerClock\", NULL, },\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/profiler-types.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,4 @@\n-                              *      Long : clock next_nsec)) *\/\n+                              *      Long : clock next_nsec,\n+                              *      Int : transport_state,\n+                              *      Int : clock cycle,\n+                              *      Long : xrun duration)) *\/\n@@ -51,2 +54,3 @@\n-                              *      Int : driver status),\n-                              *      Fraction : latency))  *\/\n+                              *      Int : driver status,\n+                              *      Fraction : latency,\n+                              *      Int : xrun_count))  *\/\n@@ -64,2 +68,14 @@\n-                              *      Fraction : latency))  *\/\n-\n+                              *      Fraction : latency,\n+                              *      Int : xrun_count))  *\/\n+    SPA_PROFILER_followerClock,            \/**< follower clock information\n+                              *  (Struct(\n+                              *      Int : clock id,\n+                              *      String: clock name,\n+                              *      Long : clock nsec,\n+                              *      Fraction : clock rate,\n+                              *      Long : clock position,\n+                              *      Long : clock duration,\n+                              *      Long : clock delay,\n+                              *      Double : clock rate_diff,\n+                              *      Long : clock next_nsec,\n+                              *      Long : xrun duration)) *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/profiler.h","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -67,3 +67,3 @@\n-    { SPA_PROP_brightness, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"brightness\", NULL },\n-    { SPA_PROP_contrast, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"contrast\", NULL },\n-    { SPA_PROP_saturation, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"saturation\", NULL },\n+    { SPA_PROP_brightness, SPA_TYPE_Float, SPA_TYPE_INFO_PROPS_BASE \"brightness\", NULL },\n+    { SPA_PROP_contrast, SPA_TYPE_Float, SPA_TYPE_INFO_PROPS_BASE \"contrast\", NULL },\n+    { SPA_PROP_saturation, SPA_TYPE_Float, SPA_TYPE_INFO_PROPS_BASE \"saturation\", NULL },\n@@ -73,2 +73,2 @@\n-    { SPA_PROP_gain, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"gain\", NULL },\n-    { SPA_PROP_sharpness, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"sharpness\", NULL },\n+    { SPA_PROP_gain, SPA_TYPE_Float, SPA_TYPE_INFO_PROPS_BASE \"gain\", NULL },\n+    { SPA_PROP_sharpness, SPA_TYPE_Float, SPA_TYPE_INFO_PROPS_BASE \"sharpness\", NULL },\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/props-types.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    SPA_PROP_volume,                \/**< a volume (Float), 0.0 silence, 1.0 normal *\/\n+    SPA_PROP_volume,            \/**< a volume (Float), 0.0 silence, 1.0 no attenutation *\/\n@@ -67,2 +67,6 @@\n-    SPA_PROP_channelVolumes,        \/**< a volume array, one volume per\n-                          *  channel (Array of Float) *\/\n+    SPA_PROP_channelVolumes,        \/**< a volume array, one (linear) volume per channel\n+                          * (Array of Float). 0.0 is silence, 1.0 is\n+                          *  without attenuation. This is the effective\n+                          *  volume that is applied. It can result\n+                          *  in a hardware volume and software volume\n+                          *  (see softVolumes) *\/\n@@ -74,1 +78,1 @@\n-    SPA_PROP_monitorVolumes,        \/**< a volume array, one volume per\n+    SPA_PROP_monitorVolumes,        \/**< a volume array, one (linear) volume per\n@@ -77,3 +81,6 @@\n-    SPA_PROP_softMute,            \/**< mute (Bool) *\/\n-    SPA_PROP_softVolumes,            \/**< a volume array, one volume per\n-                          *  channel (Array of Float) *\/\n+    SPA_PROP_softMute,            \/**< mute (Bool) applied in software *\/\n+    SPA_PROP_softVolumes,            \/**< a volume array, one (linear) volume per channel\n+                          * (Array of Float). 0.0 is silence, 1.0 is without\n+                          * attenuation. This is the volume applied in\n+                          * software, there might be a part applied in\n+                          * hardware. *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/props.h","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    { SPA_PARAM_ROUTE_profiles, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"profiles\", NULL, },\n+    { SPA_PARAM_ROUTE_profiles, SPA_TYPE_Array, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"profiles\", spa_type_prop_int_array, },\n@@ -37,1 +37,1 @@\n-    { SPA_PARAM_ROUTE_devices, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"devices\", NULL, },\n+    { SPA_PARAM_ROUTE_devices, SPA_TYPE_Array, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"devices\", spa_type_prop_int_array, },\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/route-types.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_TAG_TYPES_H\n+#define SPA_PARAM_TAG_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/enum-types.h>\n+#include <spa\/param\/param-types.h>\n+#include <spa\/param\/tag.h>\n+\n+#define SPA_TYPE_INFO_PARAM_Tag        SPA_TYPE_INFO_PARAM_BASE \"Tag\"\n+#define SPA_TYPE_INFO_PARAM_TAG_BASE    SPA_TYPE_INFO_PARAM_Tag \":\"\n+\n+static const struct spa_type_info spa_type_param_tag[] = {\n+    { SPA_PARAM_TAG_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_TAG_BASE, spa_type_param, },\n+    { SPA_PARAM_TAG_direction, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_TAG_BASE \"direction\", spa_type_direction, },\n+    { SPA_PARAM_TAG_info, SPA_TYPE_Struct, SPA_TYPE_INFO_PARAM_TAG_BASE \"info\", NULL, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_TAG_TYPES_H *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/tag-types.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_TAG_H\n+#define SPA_PARAM_TAG_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamTag *\/\n+enum spa_param_tag {\n+    SPA_PARAM_TAG_START,\n+    SPA_PARAM_TAG_direction,        \/**< direction, input\/output (Id enum spa_direction) *\/\n+    SPA_PARAM_TAG_info,            \/**< Struct(\n+                          *      Int: n_items\n+                          *      (String: key\n+                          *       String: value)*\n+                          *  ) *\/\n+};\n+\n+\/** helper structure for managing tag objects *\/\n+struct spa_tag_info {\n+    enum spa_direction direction;\n+    const struct spa_pod *info;\n+};\n+\n+#define SPA_TAG_INFO(dir,...) ((struct spa_tag_info) { .direction = (dir), ## __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_TAG_H *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/tag.h","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -17,0 +17,1 @@\n+#include <spa\/param\/tag-types.h>\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/type-info.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -21,1 +21,9 @@\n-static inline int\n+#ifndef SPA_API_VIDEO_DSP_UTILS\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_VIDEO_DSP_UTILS SPA_API_IMPL\n+ #else\n+  #define SPA_API_VIDEO_DSP_UTILS static inline\n+ #endif\n+#endif\n+\n+SPA_API_VIDEO_DSP_UTILS int\n@@ -26,1 +34,2 @@\n-    if (spa_pod_find_prop (format, NULL, SPA_FORMAT_VIDEO_modifier)) {\n+    const struct spa_pod_prop *mod_prop;\n+    if ((mod_prop = spa_pod_find_prop (format, NULL, SPA_FORMAT_VIDEO_modifier)) != NULL) {\n@@ -28,0 +37,2 @@\n+        if ((mod_prop->flags & SPA_POD_PROP_FLAG_DONT_FIXATE) == SPA_POD_PROP_FLAG_DONT_FIXATE)\n+            info->flags |= SPA_VIDEO_FLAG_MODIFIER_FIXATION_REQUIRED;\n@@ -36,1 +47,1 @@\n-static inline struct spa_pod *\n+SPA_API_VIDEO_DSP_UTILS struct spa_pod *\n@@ -38,1 +49,1 @@\n-               struct spa_video_info_dsp *info)\n+               const struct spa_video_info_dsp *info)\n@@ -49,3 +60,5 @@\n-    if (info->modifier != 0 || info->flags & SPA_VIDEO_FLAG_MODIFIER)\n-        spa_pod_builder_add(builder,\n-            SPA_FORMAT_VIDEO_modifier,    SPA_POD_Long(info->modifier), 0);\n+    if (info->modifier != 0 || info->flags & SPA_VIDEO_FLAG_MODIFIER) {\n+        spa_pod_builder_prop(builder,\n+            SPA_FORMAT_VIDEO_modifier,    SPA_POD_PROP_FLAG_MANDATORY);\n+        spa_pod_builder_long(builder,           info->modifier);\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/video\/dsp-utils.h","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -19,1 +19,9 @@\n-static inline int\n+#ifndef SPA_API_VIDEO_FORMAT_UTILS\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_VIDEO_FORMAT_UTILS SPA_API_IMPL\n+ #else\n+  #define SPA_API_VIDEO_FORMAT_UTILS static inline\n+ #endif\n+#endif\n+\n+SPA_API_VIDEO_FORMAT_UTILS int\n@@ -43,2 +51,3 @@\n-static inline struct spa_pod *\n-spa_format_video_build(struct spa_pod_builder *builder, uint32_t id, struct spa_video_info *info)\n+SPA_API_VIDEO_FORMAT_UTILS struct spa_pod *\n+spa_format_video_build(struct spa_pod_builder *builder, uint32_t id,\n+               const struct spa_video_info *info)\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/video\/format-utils.h","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -21,1 +21,9 @@\n-static inline int\n+#ifndef SPA_API_VIDEO_H264_UTILS\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_VIDEO_H264_UTILS SPA_API_IMPL\n+ #else\n+  #define SPA_API_VIDEO_H264_UTILS static inline\n+ #endif\n+#endif\n+\n+SPA_API_VIDEO_H264_UTILS int\n@@ -34,1 +42,1 @@\n-static inline struct spa_pod *\n+SPA_API_VIDEO_H264_UTILS struct spa_pod *\n@@ -36,1 +44,1 @@\n-               struct spa_video_info_h264 *info)\n+                const struct spa_video_info_h264 *info)\n@@ -52,1 +60,1 @@\n-            SPA_FORMAT_VIDEO_maxFramerate,    SPA_POD_Fraction(info->max_framerate), 0);\n+            SPA_FORMAT_VIDEO_maxFramerate,    SPA_POD_Fraction(&info->max_framerate), 0);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/video\/h264-utils.h","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -21,1 +21,9 @@\n-static inline int\n+#ifndef SPA_API_VIDEO_MJPG_UTILS\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_VIDEO_MJPG_UTILS SPA_API_IMPL\n+ #else\n+  #define SPA_API_VIDEO_MJPG_UTILS static inline\n+ #endif\n+#endif\n+\n+SPA_API_VIDEO_MJPG_UTILS int\n@@ -32,1 +40,1 @@\n-static inline struct spa_pod *\n+SPA_API_VIDEO_MJPG_UTILS struct spa_pod *\n@@ -34,1 +42,1 @@\n-               struct spa_video_info_mjpg *info)\n+                const struct spa_video_info_mjpg *info)\n@@ -50,1 +58,1 @@\n-            SPA_FORMAT_VIDEO_maxFramerate,    SPA_POD_Fraction(info->max_framerate), 0);\n+            SPA_FORMAT_VIDEO_maxFramerate,    SPA_POD_Fraction(&info->max_framerate), 0);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/video\/mjpg-utils.h","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -62,2 +62,1 @@\n-                                *   \\ref spa_video_multiview_meta on raw\n-                                *   video buffers. *\/\n+                                *   metadata on raw video buffers. *\/\n@@ -67,1 +66,1 @@\n-                             *   by the \\ref spa_video_multiview_meta *\/\n+                             *   by the metadata *\/\n@@ -100,3 +99,1 @@\n-                                 *   absence or presence of the\n-                                 *   \\ref SPA_VIDEO_BUFFER_FLAG_MULTIPLE_VIEW\n-                                 *   buffer flag. *\/\n+                                 *   absence or presence of a buffer flag. *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/video\/multiview.h","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -19,0 +19,8 @@\n+#ifndef SPA_API_VIDEO_RAW_TYPES\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_VIDEO_RAW_TYPES SPA_API_IMPL\n+ #else\n+  #define SPA_API_VIDEO_RAW_TYPES static inline\n+ #endif\n+#endif\n+\n@@ -23,1 +31,2 @@\n-    { SPA_VIDEO_FORMAT_ENCODED,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"encoded\", NULL },\n+    { SPA_VIDEO_FORMAT_UNKNOWN,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"UNKNOWN\", NULL },\n+    { SPA_VIDEO_FORMAT_ENCODED,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"ENCODED\", NULL },\n@@ -113,0 +122,9 @@\n+SPA_API_VIDEO_RAW_TYPES uint32_t spa_type_video_format_from_short_name(const char *name)\n+{\n+    return spa_type_from_short_name(name, spa_type_video_format, SPA_VIDEO_FORMAT_UNKNOWN);\n+}\n+SPA_API_VIDEO_RAW_TYPES const char * spa_type_video_format_to_short_name(uint32_t type)\n+{\n+    return spa_type_to_short_name(type, spa_type_video_format, \"UNKNOWN\");\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/video\/raw-types.h","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -21,1 +21,9 @@\n-static inline int\n+#ifndef SPA_API_VIDEO_RAW_UTILS\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_VIDEO_RAW_UTILS SPA_API_IMPL\n+ #else\n+  #define SPA_API_VIDEO_RAW_UTILS static inline\n+ #endif\n+#endif\n+\n+SPA_API_VIDEO_RAW_UTILS int\n@@ -26,1 +34,2 @@\n-    if (spa_pod_find_prop (format, NULL, SPA_FORMAT_VIDEO_modifier)) {\n+    const struct spa_pod_prop *mod_prop;\n+    if ((mod_prop = spa_pod_find_prop (format, NULL, SPA_FORMAT_VIDEO_modifier)) != NULL) {\n@@ -28,0 +37,2 @@\n+        if ((mod_prop->flags & SPA_POD_PROP_FLAG_DONT_FIXATE) == SPA_POD_PROP_FLAG_DONT_FIXATE)\n+            info->flags |= SPA_VIDEO_FLAG_MODIFIER_FIXATION_REQUIRED;\n@@ -49,1 +60,1 @@\n-static inline struct spa_pod *\n+SPA_API_VIDEO_RAW_UTILS struct spa_pod *\n@@ -51,1 +62,1 @@\n-               struct spa_video_info_raw *info)\n+               const struct spa_video_info_raw *info)\n@@ -68,3 +79,5 @@\n-    if (info->modifier != 0 || info->flags & SPA_VIDEO_FLAG_MODIFIER)\n-        spa_pod_builder_add(builder,\n-            SPA_FORMAT_VIDEO_modifier,    SPA_POD_Long(info->modifier), 0);\n+    if (info->modifier != 0 || info->flags & SPA_VIDEO_FLAG_MODIFIER) {\n+        spa_pod_builder_prop(builder,\n+            SPA_FORMAT_VIDEO_modifier,    SPA_POD_PROP_FLAG_MANDATORY);\n+        spa_pod_builder_long(builder,           info->modifier);\n+    }\n@@ -73,1 +86,1 @@\n-            SPA_FORMAT_VIDEO_maxFramerate,    SPA_POD_Fraction(info->max_framerate), 0);\n+            SPA_FORMAT_VIDEO_maxFramerate,    SPA_POD_Fraction(&info->max_framerate), 0);\n@@ -82,1 +95,1 @@\n-            SPA_FORMAT_VIDEO_pixelAspectRatio,SPA_POD_Fraction(info->pixel_aspect_ratio), 0);\n+            SPA_FORMAT_VIDEO_pixelAspectRatio, SPA_POD_Fraction(&info->pixel_aspect_ratio), 0);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/video\/raw-utils.h","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -137,5 +137,6 @@\n-    SPA_VIDEO_FLAG_NONE = 0,            \/**< no flags *\/\n-    SPA_VIDEO_FLAG_VARIABLE_FPS = (1 << 0),        \/**< a variable fps is selected, fps_n and fps_d\n-                             *   denote the maximum fps of the video *\/\n-    SPA_VIDEO_FLAG_PREMULTIPLIED_ALPHA = (1 << 1),  \/**< Each color has been scaled by the alpha value. *\/\n-    SPA_VIDEO_FLAG_MODIFIER = (1 << 2),        \/**< use the format modifier *\/\n+    SPA_VIDEO_FLAG_NONE = 0,                \/**< no flags *\/\n+    SPA_VIDEO_FLAG_VARIABLE_FPS = (1 << 0),            \/**< a variable fps is selected, fps_n and fps_d\n+                                 *   denote the maximum fps of the video *\/\n+    SPA_VIDEO_FLAG_PREMULTIPLIED_ALPHA = (1 << 1),        \/**< Each color has been scaled by the alpha value. *\/\n+    SPA_VIDEO_FLAG_MODIFIER = (1 << 2),            \/**< use the format modifier *\/\n+    SPA_VIDEO_FLAG_MODIFIER_FIXATION_REQUIRED = (1 << 3),    \/**< format modifier was not fixated yet *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/param\/video\/raw.h","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,8 @@\n+#ifndef SPA_API_POD_BUILDER\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_POD_BUILDER SPA_API_IMPL\n+ #else\n+  #define SPA_API_POD_BUILDER static inline\n+ #endif\n+#endif\n+\n@@ -52,1 +60,1 @@\n-#define SPA_POD_BUILDER_INIT(buffer,size)  ((struct spa_pod_builder){ (buffer), (size), 0, {}, {} })\n+#define SPA_POD_BUILDER_INIT(buffer,size)  ((struct spa_pod_builder){ (buffer), (size), 0, {0,0,NULL},{NULL,NULL}})\n@@ -54,1 +62,1 @@\n-static inline void\n+SPA_API_POD_BUILDER void\n@@ -60,1 +68,1 @@\n-static inline void\n+SPA_API_POD_BUILDER void\n@@ -67,1 +75,1 @@\n-static inline void\n+SPA_API_POD_BUILDER void\n@@ -77,1 +85,1 @@\n-static inline void spa_pod_builder_init(struct spa_pod_builder *builder, void *data, uint32_t size)\n+SPA_API_POD_BUILDER void spa_pod_builder_init(struct spa_pod_builder *builder, void *data, uint32_t size)\n@@ -82,1 +90,1 @@\n-static inline struct spa_pod *\n+SPA_API_POD_BUILDER struct spa_pod *\n@@ -94,1 +102,1 @@\n-static inline struct spa_pod *\n+SPA_API_POD_BUILDER struct spa_pod *\n@@ -102,1 +110,1 @@\n-static inline void\n+SPA_API_POD_BUILDER void\n@@ -118,1 +126,1 @@\n-static inline int spa_pod_builder_raw(struct spa_pod_builder *builder, const void *data, uint32_t size)\n+SPA_API_POD_BUILDER int spa_pod_builder_raw(struct spa_pod_builder *builder, const void *data, uint32_t size)\n@@ -142,1 +150,1 @@\n-static inline int spa_pod_builder_pad(struct spa_pod_builder *builder, uint32_t size)\n+SPA_API_POD_BUILDER int spa_pod_builder_pad(struct spa_pod_builder *builder, uint32_t size)\n@@ -149,1 +157,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -158,1 +166,1 @@\n-static inline void *spa_pod_builder_pop(struct spa_pod_builder *builder, struct spa_pod_frame *frame)\n+SPA_API_POD_BUILDER void *spa_pod_builder_pop(struct spa_pod_builder *builder, struct spa_pod_frame *frame)\n@@ -175,1 +183,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -201,1 +209,1 @@\n-static inline int spa_pod_builder_none(struct spa_pod_builder *builder)\n+SPA_API_POD_BUILDER int spa_pod_builder_none(struct spa_pod_builder *builder)\n@@ -207,1 +215,1 @@\n-static inline int spa_pod_builder_child(struct spa_pod_builder *builder, uint32_t size, uint32_t type)\n+SPA_API_POD_BUILDER int spa_pod_builder_child(struct spa_pod_builder *builder, uint32_t size, uint32_t type)\n@@ -216,1 +224,1 @@\n-static inline int spa_pod_builder_bool(struct spa_pod_builder *builder, bool val)\n+SPA_API_POD_BUILDER int spa_pod_builder_bool(struct spa_pod_builder *builder, bool val)\n@@ -224,1 +232,1 @@\n-static inline int spa_pod_builder_id(struct spa_pod_builder *builder, uint32_t val)\n+SPA_API_POD_BUILDER int spa_pod_builder_id(struct spa_pod_builder *builder, uint32_t val)\n@@ -232,1 +240,1 @@\n-static inline int spa_pod_builder_int(struct spa_pod_builder *builder, int32_t val)\n+SPA_API_POD_BUILDER int spa_pod_builder_int(struct spa_pod_builder *builder, int32_t val)\n@@ -240,1 +248,1 @@\n-static inline int spa_pod_builder_long(struct spa_pod_builder *builder, int64_t val)\n+SPA_API_POD_BUILDER int spa_pod_builder_long(struct spa_pod_builder *builder, int64_t val)\n@@ -248,1 +256,1 @@\n-static inline int spa_pod_builder_float(struct spa_pod_builder *builder, float val)\n+SPA_API_POD_BUILDER int spa_pod_builder_float(struct spa_pod_builder *builder, float val)\n@@ -256,1 +264,1 @@\n-static inline int spa_pod_builder_double(struct spa_pod_builder *builder, double val)\n+SPA_API_POD_BUILDER int spa_pod_builder_double(struct spa_pod_builder *builder, double val)\n@@ -264,1 +272,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -276,1 +284,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -286,1 +294,1 @@\n-static inline int spa_pod_builder_string(struct spa_pod_builder *builder, const char *str)\n+SPA_API_POD_BUILDER int spa_pod_builder_string(struct spa_pod_builder *builder, const char *str)\n@@ -294,1 +302,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -303,1 +311,1 @@\n-static inline void *\n+SPA_API_POD_BUILDER void *\n@@ -314,1 +322,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -323,1 +331,1 @@\n-static inline int spa_pod_builder_fd(struct spa_pod_builder *builder, int64_t fd)\n+SPA_API_POD_BUILDER int spa_pod_builder_fd(struct spa_pod_builder *builder, int64_t fd)\n@@ -331,1 +339,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -340,1 +348,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -347,1 +355,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -359,1 +367,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -381,1 +389,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -396,1 +404,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -408,1 +416,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -423,1 +431,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -433,1 +441,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -444,1 +452,1 @@\n-static inline uint32_t\n+SPA_API_POD_BUILDER int\n@@ -451,1 +459,1 @@\n-static inline uint32_t spa_choice_from_id(char id)\n+SPA_API_POD_BUILDER uint32_t spa_choice_from_id(char id)\n@@ -484,1 +492,1 @@\n-        spa_pod_builder_float(builder, va_arg(args, double));        \\\n+        spa_pod_builder_float(builder, (float)va_arg(args, double));    \\\n@@ -563,1 +571,1 @@\n-static inline int\n+SPA_API_POD_BUILDER int\n@@ -621,1 +629,1 @@\n-static inline int spa_pod_builder_add(struct spa_pod_builder *builder, ...)\n+SPA_API_POD_BUILDER int spa_pod_builder_add(struct spa_pod_builder *builder, ...)\n@@ -661,1 +669,1 @@\n-static inline struct spa_pod *\n+SPA_API_POD_BUILDER struct spa_pod *\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/pod\/builder.h","additions":51,"deletions":43,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    { { (size), SPA_TYPE_OBJECT },                    \\\n+    { { (size), SPA_TYPE_Object },                    \\\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/pod\/event.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -17,0 +17,8 @@\n+#ifndef SPA_API_POD_ITER\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_POD_ITER SPA_API_IMPL\n+ #else\n+  #define SPA_API_POD_ITER static inline\n+ #endif\n+#endif\n+\n@@ -29,1 +37,1 @@\n-static inline bool spa_pod_is_inside(const void *pod, uint32_t size, const void *iter)\n+SPA_API_POD_ITER bool spa_pod_is_inside(const void *pod, uint32_t size, const void *iter)\n@@ -31,2 +39,4 @@\n-    return SPA_POD_BODY(iter) <= SPA_PTROFF(pod, size, void) &&\n-        SPA_PTROFF(iter, SPA_POD_SIZE(iter), void) <= SPA_PTROFF(pod, size, void);\n+    size_t remaining;\n+\n+    return spa_ptr_type_inside(pod, size, iter, struct spa_pod, &remaining) &&\n+           remaining >= SPA_POD_BODY_SIZE(iter);\n@@ -35,1 +45,1 @@\n-static inline void *spa_pod_next(const void *iter)\n+SPA_API_POD_ITER void *spa_pod_next(const void *iter)\n@@ -40,1 +50,1 @@\n-static inline struct spa_pod_prop *spa_pod_prop_first(const struct spa_pod_object_body *body)\n+SPA_API_POD_ITER struct spa_pod_prop *spa_pod_prop_first(const struct spa_pod_object_body *body)\n@@ -45,1 +55,1 @@\n-static inline bool spa_pod_prop_is_inside(const struct spa_pod_object_body *body,\n+SPA_API_POD_ITER bool spa_pod_prop_is_inside(const struct spa_pod_object_body *body,\n@@ -48,2 +58,4 @@\n-    return SPA_POD_CONTENTS(struct spa_pod_prop, iter) <= SPA_PTROFF(body, size, void) &&\n-        SPA_PTROFF(iter, SPA_POD_PROP_SIZE(iter), void) <= SPA_PTROFF(body, size, void);\n+    size_t remaining;\n+\n+    return spa_ptr_type_inside(body, size, iter, struct spa_pod_prop, &remaining) &&\n+           remaining >= iter->value.size;\n@@ -52,1 +64,1 @@\n-static inline struct spa_pod_prop *spa_pod_prop_next(const struct spa_pod_prop *iter)\n+SPA_API_POD_ITER struct spa_pod_prop *spa_pod_prop_next(const struct spa_pod_prop *iter)\n@@ -57,1 +69,1 @@\n-static inline struct spa_pod_control *spa_pod_control_first(const struct spa_pod_sequence_body *body)\n+SPA_API_POD_ITER struct spa_pod_control *spa_pod_control_first(const struct spa_pod_sequence_body *body)\n@@ -62,1 +74,1 @@\n-static inline bool spa_pod_control_is_inside(const struct spa_pod_sequence_body *body,\n+SPA_API_POD_ITER bool spa_pod_control_is_inside(const struct spa_pod_sequence_body *body,\n@@ -65,2 +77,4 @@\n-    return SPA_POD_CONTENTS(struct spa_pod_control, iter) <= SPA_PTROFF(body, size, void) &&\n-        SPA_PTROFF(iter, SPA_POD_CONTROL_SIZE(iter), void) <= SPA_PTROFF(body, size, void);\n+    size_t remaining;\n+\n+    return spa_ptr_type_inside(body, size, iter, struct spa_pod_control, &remaining) &&\n+           remaining >= iter->value.size;\n@@ -69,1 +83,1 @@\n-static inline struct spa_pod_control *spa_pod_control_next(const struct spa_pod_control *iter)\n+SPA_API_POD_ITER struct spa_pod_control *spa_pod_control_next(const struct spa_pod_control *iter)\n@@ -76,1 +90,1 @@\n-         (iter) < (__typeof__(iter))SPA_PTROFF((body), (_size), void);                \\\n+         (body)->child.size > 0 && spa_ptrinside(body, _size, iter, (body)->child.size, NULL);    \\\n@@ -84,1 +98,1 @@\n-         (iter) < (__typeof__(iter))SPA_PTROFF((body), (_size), void);                \\\n+         (body)->child.size > 0 && spa_ptrinside(body, _size, iter, (body)->child.size, NULL);    \\\n@@ -115,1 +129,1 @@\n-static inline void *spa_pod_from_data(void *data, size_t maxsize, off_t offset, size_t size)\n+SPA_API_POD_ITER void *spa_pod_from_data(void *data, size_t maxsize, off_t offset, size_t size)\n@@ -126,1 +140,1 @@\n-static inline int spa_pod_is_none(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_none(const struct spa_pod *pod)\n@@ -131,1 +145,1 @@\n-static inline int spa_pod_is_bool(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_bool(const struct spa_pod *pod)\n@@ -136,1 +150,1 @@\n-static inline int spa_pod_get_bool(const struct spa_pod *pod, bool *value)\n+SPA_API_POD_ITER int spa_pod_get_bool(const struct spa_pod *pod, bool *value)\n@@ -144,1 +158,1 @@\n-static inline int spa_pod_is_id(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_id(const struct spa_pod *pod)\n@@ -149,1 +163,1 @@\n-static inline int spa_pod_get_id(const struct spa_pod *pod, uint32_t *value)\n+SPA_API_POD_ITER int spa_pod_get_id(const struct spa_pod *pod, uint32_t *value)\n@@ -157,1 +171,1 @@\n-static inline int spa_pod_is_int(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_int(const struct spa_pod *pod)\n@@ -162,1 +176,1 @@\n-static inline int spa_pod_get_int(const struct spa_pod *pod, int32_t *value)\n+SPA_API_POD_ITER int spa_pod_get_int(const struct spa_pod *pod, int32_t *value)\n@@ -170,1 +184,1 @@\n-static inline int spa_pod_is_long(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_long(const struct spa_pod *pod)\n@@ -175,1 +189,1 @@\n-static inline int spa_pod_get_long(const struct spa_pod *pod, int64_t *value)\n+SPA_API_POD_ITER int spa_pod_get_long(const struct spa_pod *pod, int64_t *value)\n@@ -183,1 +197,1 @@\n-static inline int spa_pod_is_float(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_float(const struct spa_pod *pod)\n@@ -188,1 +202,1 @@\n-static inline int spa_pod_get_float(const struct spa_pod *pod, float *value)\n+SPA_API_POD_ITER int spa_pod_get_float(const struct spa_pod *pod, float *value)\n@@ -196,1 +210,1 @@\n-static inline int spa_pod_is_double(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_double(const struct spa_pod *pod)\n@@ -201,1 +215,1 @@\n-static inline int spa_pod_get_double(const struct spa_pod *pod, double *value)\n+SPA_API_POD_ITER int spa_pod_get_double(const struct spa_pod *pod, double *value)\n@@ -209,1 +223,1 @@\n-static inline int spa_pod_is_string(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_string(const struct spa_pod *pod)\n@@ -217,1 +231,1 @@\n-static inline int spa_pod_get_string(const struct spa_pod *pod, const char **value)\n+SPA_API_POD_ITER int spa_pod_get_string(const struct spa_pod *pod, const char **value)\n@@ -225,1 +239,1 @@\n-static inline int spa_pod_copy_string(const struct spa_pod *pod, size_t maxlen, char *dest)\n+SPA_API_POD_ITER int spa_pod_copy_string(const struct spa_pod *pod, size_t maxlen, char *dest)\n@@ -235,1 +249,1 @@\n-static inline int spa_pod_is_bytes(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_bytes(const struct spa_pod *pod)\n@@ -240,1 +254,1 @@\n-static inline int spa_pod_get_bytes(const struct spa_pod *pod, const void **value, uint32_t *len)\n+SPA_API_POD_ITER int spa_pod_get_bytes(const struct spa_pod *pod, const void **value, uint32_t *len)\n@@ -249,1 +263,1 @@\n-static inline int spa_pod_is_pointer(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_pointer(const struct spa_pod *pod)\n@@ -255,1 +269,1 @@\n-static inline int spa_pod_get_pointer(const struct spa_pod *pod, uint32_t *type, const void **value)\n+SPA_API_POD_ITER int spa_pod_get_pointer(const struct spa_pod *pod, uint32_t *type, const void **value)\n@@ -264,1 +278,1 @@\n-static inline int spa_pod_is_fd(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_fd(const struct spa_pod *pod)\n@@ -270,1 +284,1 @@\n-static inline int spa_pod_get_fd(const struct spa_pod *pod, int64_t *value)\n+SPA_API_POD_ITER int spa_pod_get_fd(const struct spa_pod *pod, int64_t *value)\n@@ -278,1 +292,1 @@\n-static inline int spa_pod_is_rectangle(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_rectangle(const struct spa_pod *pod)\n@@ -284,1 +298,1 @@\n-static inline int spa_pod_get_rectangle(const struct spa_pod *pod, struct spa_rectangle *value)\n+SPA_API_POD_ITER int spa_pod_get_rectangle(const struct spa_pod *pod, struct spa_rectangle *value)\n@@ -292,1 +306,1 @@\n-static inline int spa_pod_is_fraction(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_fraction(const struct spa_pod *pod)\n@@ -298,1 +312,1 @@\n-static inline int spa_pod_get_fraction(const struct spa_pod *pod, struct spa_fraction *value)\n+SPA_API_POD_ITER int spa_pod_get_fraction(const struct spa_pod *pod, struct spa_fraction *value)\n@@ -305,1 +319,1 @@\n-static inline int spa_pod_is_bitmap(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_bitmap(const struct spa_pod *pod)\n@@ -311,1 +325,1 @@\n-static inline int spa_pod_is_array(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_array(const struct spa_pod *pod)\n@@ -317,1 +331,1 @@\n-static inline void *spa_pod_get_array(const struct spa_pod *pod, uint32_t *n_values)\n+SPA_API_POD_ITER void *spa_pod_get_array(const struct spa_pod *pod, uint32_t *n_values)\n@@ -324,1 +338,1 @@\n-static inline uint32_t spa_pod_copy_array(const struct spa_pod *pod, uint32_t type,\n+SPA_API_POD_ITER uint32_t spa_pod_copy_array(const struct spa_pod *pod, uint32_t type,\n@@ -336,1 +350,1 @@\n-static inline int spa_pod_is_choice(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_choice(const struct spa_pod *pod)\n@@ -342,1 +356,1 @@\n-static inline struct spa_pod *spa_pod_get_values(const struct spa_pod *pod, uint32_t *n_vals, uint32_t *choice)\n+SPA_API_POD_ITER struct spa_pod *spa_pod_get_values(const struct spa_pod *pod, uint32_t *n_vals, uint32_t *choice)\n@@ -356,1 +370,1 @@\n-static inline int spa_pod_is_struct(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_struct(const struct spa_pod *pod)\n@@ -361,1 +375,1 @@\n-static inline int spa_pod_is_object(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_object(const struct spa_pod *pod)\n@@ -367,1 +381,1 @@\n-static inline bool spa_pod_is_object_type(const struct spa_pod *pod, uint32_t type)\n+SPA_API_POD_ITER bool spa_pod_is_object_type(const struct spa_pod *pod, uint32_t type)\n@@ -372,1 +386,1 @@\n-static inline bool spa_pod_is_object_id(const struct spa_pod *pod, uint32_t id)\n+SPA_API_POD_ITER bool spa_pod_is_object_id(const struct spa_pod *pod, uint32_t id)\n@@ -377,1 +391,1 @@\n-static inline int spa_pod_is_sequence(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_is_sequence(const struct spa_pod *pod)\n@@ -383,1 +397,1 @@\n-static inline const struct spa_pod_prop *spa_pod_object_find_prop(const struct spa_pod_object *pod,\n+SPA_API_POD_ITER const struct spa_pod_prop *spa_pod_object_find_prop(const struct spa_pod_object *pod,\n@@ -403,1 +417,1 @@\n-static inline const struct spa_pod_prop *spa_pod_find_prop(const struct spa_pod *pod,\n+SPA_API_POD_ITER const struct spa_pod_prop *spa_pod_find_prop(const struct spa_pod *pod,\n@@ -411,1 +425,1 @@\n-static inline int spa_pod_object_fixate(struct spa_pod_object *pod)\n+SPA_API_POD_ITER int spa_pod_object_fixate(struct spa_pod_object *pod)\n@@ -422,1 +436,1 @@\n-static inline int spa_pod_fixate(struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_fixate(struct spa_pod *pod)\n@@ -429,1 +443,1 @@\n-static inline int spa_pod_object_is_fixated(const struct spa_pod_object *pod)\n+SPA_API_POD_ITER int spa_pod_object_is_fixated(const struct spa_pod_object *pod)\n@@ -440,1 +454,9 @@\n-static inline int spa_pod_is_fixated(const struct spa_pod *pod)\n+SPA_API_POD_ITER int spa_pod_object_has_props(const struct spa_pod_object *pod)\n+{\n+    struct spa_pod_prop *res;\n+    SPA_POD_OBJECT_FOREACH(pod, res)\n+        return 1;\n+    return 0;\n+}\n+\n+SPA_API_POD_ITER int spa_pod_is_fixated(const struct spa_pod *pod)\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/pod\/iter.h","additions":82,"deletions":60,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -18,0 +18,8 @@\n+#ifndef SPA_API_POD_PARSER\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_POD_PARSER SPA_API_IMPL\n+ #else\n+  #define SPA_API_POD_PARSER static inline\n+ #endif\n+#endif\n+\n@@ -36,1 +44,1 @@\n-#define SPA_POD_PARSER_INIT(buffer,size)  ((struct spa_pod_parser){ (buffer), (size), 0, {} })\n+#define SPA_POD_PARSER_INIT(buffer,size)  ((struct spa_pod_parser){ (buffer), (size), 0, {0,0,NULL}})\n@@ -38,1 +46,1 @@\n-static inline void spa_pod_parser_init(struct spa_pod_parser *parser,\n+SPA_API_POD_PARSER void spa_pod_parser_init(struct spa_pod_parser *parser,\n@@ -44,1 +52,1 @@\n-static inline void spa_pod_parser_pod(struct spa_pod_parser *parser,\n+SPA_API_POD_PARSER void spa_pod_parser_pod(struct spa_pod_parser *parser,\n@@ -50,1 +58,1 @@\n-static inline void\n+SPA_API_POD_PARSER void\n@@ -56,1 +64,1 @@\n-static inline void\n+SPA_API_POD_PARSER void\n@@ -62,1 +70,1 @@\n-static inline struct spa_pod *\n+SPA_API_POD_PARSER struct spa_pod *\n@@ -81,1 +89,1 @@\n-static inline struct spa_pod *spa_pod_parser_frame(struct spa_pod_parser *parser, struct spa_pod_frame *frame)\n+SPA_API_POD_PARSER struct spa_pod *spa_pod_parser_frame(struct spa_pod_parser *parser, struct spa_pod_frame *frame)\n@@ -86,1 +94,1 @@\n-static inline void spa_pod_parser_push(struct spa_pod_parser *parser,\n+SPA_API_POD_PARSER void spa_pod_parser_push(struct spa_pod_parser *parser,\n@@ -96,1 +104,1 @@\n-static inline struct spa_pod *spa_pod_parser_current(struct spa_pod_parser *parser)\n+SPA_API_POD_PARSER struct spa_pod *spa_pod_parser_current(struct spa_pod_parser *parser)\n@@ -103,1 +111,1 @@\n-static inline void spa_pod_parser_advance(struct spa_pod_parser *parser, const struct spa_pod *pod)\n+SPA_API_POD_PARSER void spa_pod_parser_advance(struct spa_pod_parser *parser, const struct spa_pod *pod)\n@@ -108,1 +116,1 @@\n-static inline struct spa_pod *spa_pod_parser_next(struct spa_pod_parser *parser)\n+SPA_API_POD_PARSER struct spa_pod *spa_pod_parser_next(struct spa_pod_parser *parser)\n@@ -116,1 +124,1 @@\n-static inline int spa_pod_parser_pop(struct spa_pod_parser *parser,\n+SPA_API_POD_PARSER int spa_pod_parser_pop(struct spa_pod_parser *parser,\n@@ -124,1 +132,1 @@\n-static inline int spa_pod_parser_get_bool(struct spa_pod_parser *parser, bool *value)\n+SPA_API_POD_PARSER int spa_pod_parser_get_bool(struct spa_pod_parser *parser, bool *value)\n@@ -133,1 +141,1 @@\n-static inline int spa_pod_parser_get_id(struct spa_pod_parser *parser, uint32_t *value)\n+SPA_API_POD_PARSER int spa_pod_parser_get_id(struct spa_pod_parser *parser, uint32_t *value)\n@@ -142,1 +150,1 @@\n-static inline int spa_pod_parser_get_int(struct spa_pod_parser *parser, int32_t *value)\n+SPA_API_POD_PARSER int spa_pod_parser_get_int(struct spa_pod_parser *parser, int32_t *value)\n@@ -151,1 +159,1 @@\n-static inline int spa_pod_parser_get_long(struct spa_pod_parser *parser, int64_t *value)\n+SPA_API_POD_PARSER int spa_pod_parser_get_long(struct spa_pod_parser *parser, int64_t *value)\n@@ -160,1 +168,1 @@\n-static inline int spa_pod_parser_get_float(struct spa_pod_parser *parser, float *value)\n+SPA_API_POD_PARSER int spa_pod_parser_get_float(struct spa_pod_parser *parser, float *value)\n@@ -169,1 +177,1 @@\n-static inline int spa_pod_parser_get_double(struct spa_pod_parser *parser, double *value)\n+SPA_API_POD_PARSER int spa_pod_parser_get_double(struct spa_pod_parser *parser, double *value)\n@@ -178,1 +186,1 @@\n-static inline int spa_pod_parser_get_string(struct spa_pod_parser *parser, const char **value)\n+SPA_API_POD_PARSER int spa_pod_parser_get_string(struct spa_pod_parser *parser, const char **value)\n@@ -187,1 +195,1 @@\n-static inline int spa_pod_parser_get_bytes(struct spa_pod_parser *parser, const void **value, uint32_t *len)\n+SPA_API_POD_PARSER int spa_pod_parser_get_bytes(struct spa_pod_parser *parser, const void **value, uint32_t *len)\n@@ -196,1 +204,1 @@\n-static inline int spa_pod_parser_get_pointer(struct spa_pod_parser *parser, uint32_t *type, const void **value)\n+SPA_API_POD_PARSER int spa_pod_parser_get_pointer(struct spa_pod_parser *parser, uint32_t *type, const void **value)\n@@ -205,1 +213,1 @@\n-static inline int spa_pod_parser_get_fd(struct spa_pod_parser *parser, int64_t *value)\n+SPA_API_POD_PARSER int spa_pod_parser_get_fd(struct spa_pod_parser *parser, int64_t *value)\n@@ -214,1 +222,1 @@\n-static inline int spa_pod_parser_get_rectangle(struct spa_pod_parser *parser, struct spa_rectangle *value)\n+SPA_API_POD_PARSER int spa_pod_parser_get_rectangle(struct spa_pod_parser *parser, struct spa_rectangle *value)\n@@ -223,1 +231,1 @@\n-static inline int spa_pod_parser_get_fraction(struct spa_pod_parser *parser, struct spa_fraction *value)\n+SPA_API_POD_PARSER int spa_pod_parser_get_fraction(struct spa_pod_parser *parser, struct spa_fraction *value)\n@@ -232,1 +240,1 @@\n-static inline int spa_pod_parser_get_pod(struct spa_pod_parser *parser, struct spa_pod **value)\n+SPA_API_POD_PARSER int spa_pod_parser_get_pod(struct spa_pod_parser *parser, struct spa_pod **value)\n@@ -241,1 +249,1 @@\n-static inline int spa_pod_parser_push_struct(struct spa_pod_parser *parser,\n+SPA_API_POD_PARSER int spa_pod_parser_push_struct(struct spa_pod_parser *parser,\n@@ -254,1 +262,1 @@\n-static inline int spa_pod_parser_push_object(struct spa_pod_parser *parser,\n+SPA_API_POD_PARSER int spa_pod_parser_push_object(struct spa_pod_parser *parser,\n@@ -271,1 +279,1 @@\n-static inline bool spa_pod_parser_can_collect(const struct spa_pod *pod, char type)\n+SPA_API_POD_PARSER bool spa_pod_parser_can_collect(const struct spa_pod *pod, char type)\n@@ -446,1 +454,1 @@\n-static inline int spa_pod_parser_getv(struct spa_pod_parser *parser, va_list args)\n+SPA_API_POD_PARSER int spa_pod_parser_getv(struct spa_pod_parser *parser, va_list args)\n@@ -458,1 +466,1 @@\n-        if (ftype == SPA_TYPE_Object) {\n+        if (f && ftype == SPA_TYPE_Object) {\n@@ -499,1 +507,1 @@\n-static inline int spa_pod_parser_get(struct spa_pod_parser *parser, ...)\n+SPA_API_POD_PARSER int spa_pod_parser_get(struct spa_pod_parser *parser, ...)\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/pod\/parser.h","additions":39,"deletions":31,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -12,0 +12,2 @@\n+#include <errno.h>\n+\n@@ -16,0 +18,8 @@\n+#ifndef SPA_API_LOOP\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_LOOP SPA_API_IMPL\n+ #else\n+  #define SPA_API_LOOP static inline\n+ #endif\n+#endif\n+\n@@ -69,1 +79,6 @@\n-    \/** add a source to the loop *\/\n+    \/** Add a source to the loop. Must be called from the loop's own thread.\n+     *\n+     * \\param[in] object The callbacks data.\n+     * \\param[in] source The source.\n+     * \\return 0 on success, negative errno-style value on failure.\n+     *\/\n@@ -73,1 +88,6 @@\n-    \/** update the source io mask *\/\n+    \/** Update the source io mask. Must be called from the loop's own thread.\n+     *\n+     * \\param[in] object The callbacks data.\n+     * \\param[in] source The source.\n+     * \\return 0 on success, negative errno-style value on failure.\n+     *\/\n@@ -77,1 +97,6 @@\n-    \/** remove a source from the loop *\/\n+    \/** Remove a source from the loop. Must be called from the loop's own thread.\n+     *\n+     * \\param[in] object The callbacks data.\n+     * \\param[in] source The source.\n+     * \\return 0 on success, negative errno-style value on failure.\n+     *\/\n@@ -81,1 +106,23 @@\n-    \/** invoke a function in the context of this loop *\/\n+    \/** Invoke a function in the context of this loop.\n+     * May be called from any thread and multiple threads at the same time.\n+     * If called from the loop's thread, all callbacks previously queued with\n+     * invoke() will be run synchronously, which might cause unexpected\n+     * reentrancy problems.\n+     *\n+     * \\param[in] object The callbacks data.\n+     * \\param func The function to be invoked.\n+     * \\param seq An opaque sequence number. This will be made\n+     *            available to func.\n+     * \\param[in] data Data that will be copied into the internal ring buffer and made\n+     *             available to func. Because this data is copied, it is okay to\n+     *             pass a pointer to a local variable, but do not pass a pointer to\n+     *             an object that has identity.\n+     * \\param size The size of data to copy.\n+     * \\param block If \\true, do not return until func has been called. Otherwise,\n+     *              returns immediately. Passing \\true does not risk a deadlock because\n+     *              the data thread is never allowed to wait on any other thread.\n+     * \\param user_data An opaque pointer passed to func.\n+     * \\return `-EPIPE` if the internal ring buffer filled up,\n+     *         if block is \\false, 0 if seq was SPA_ID_INVALID or\n+     *         seq with the ASYNC flag set\n+     *         or the return value of func otherwise. *\/\n@@ -91,15 +138,23 @@\n-#define spa_loop_method(o,method,version,...)                \\\n-({                                    \\\n-    int _res = -ENOTSUP;                        \\\n-    struct spa_loop *_o = o;                    \\\n-    spa_interface_call_res(&_o->iface,                \\\n-            struct spa_loop_methods, _res,            \\\n-            method, version, ##__VA_ARGS__);        \\\n-    _res;                                \\\n-})\n-\n-#define spa_loop_add_source(l,...)    spa_loop_method(l,add_source,0,##__VA_ARGS__)\n-#define spa_loop_update_source(l,...)    spa_loop_method(l,update_source,0,##__VA_ARGS__)\n-#define spa_loop_remove_source(l,...)    spa_loop_method(l,remove_source,0,##__VA_ARGS__)\n-#define spa_loop_invoke(l,...)        spa_loop_method(l,invoke,0,##__VA_ARGS__)\n-\n+SPA_API_LOOP int spa_loop_add_source(struct spa_loop *object, struct spa_source *source)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            spa_loop, &object->iface, add_source, 0, source);\n+}\n+SPA_API_LOOP int spa_loop_update_source(struct spa_loop *object, struct spa_source *source)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            spa_loop, &object->iface, update_source, 0, source);\n+}\n+SPA_API_LOOP int spa_loop_remove_source(struct spa_loop *object, struct spa_source *source)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            spa_loop, &object->iface, remove_source, 0, source);\n+}\n+SPA_API_LOOP int spa_loop_invoke(struct spa_loop *object,\n+        spa_invoke_func_t func, uint32_t seq, const void *data,\n+        size_t size, bool block, void *user_data)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            spa_loop, &object->iface, invoke, 0, func, seq, data,\n+            size, block, user_data);\n+}\n@@ -121,15 +176,13 @@\n-#define spa_loop_control_hook_before(l)                            \\\n-({                                            \\\n-    struct spa_hook_list *_l = l;                            \\\n-    struct spa_hook *_h;                                \\\n-    spa_list_for_each_reverse(_h, &_l->list, link)                    \\\n-        spa_callbacks_call(&_h->cb, struct spa_loop_control_hooks, before, 0);    \\\n-})\n-\n-#define spa_loop_control_hook_after(l)                            \\\n-({                                            \\\n-    struct spa_hook_list *_l = l;                            \\\n-    struct spa_hook *_h;                                \\\n-    spa_list_for_each(_h, &_l->list, link)                        \\\n-        spa_callbacks_call(&_h->cb, struct spa_loop_control_hooks, after, 0);    \\\n-})\n+SPA_API_LOOP void spa_loop_control_hook_before(struct spa_hook_list *l)\n+{\n+    struct spa_hook *h;\n+    spa_list_for_each_reverse(h, &l->list, link)\n+        spa_callbacks_call_fast(&h->cb, struct spa_loop_control_hooks, before, 0);\n+}\n+\n+SPA_API_LOOP void spa_loop_control_hook_after(struct spa_hook_list *l)\n+{\n+    struct spa_hook *h;\n+    spa_list_for_each(h, &l->list, link)\n+        spa_callbacks_call_fast(&h->cb, struct spa_loop_control_hooks, after, 0);\n+}\n@@ -139,0 +192,20 @@\n+ *\n+ * The event loop control function provide API to run the event loop.\n+ *\n+ * The below (pseudo)code is a minimal example outlining the use of the loop\n+ * control:\n+ * \\code{.c}\n+ * spa_loop_control_enter(loop);\n+ * while (running) {\n+ *   spa_loop_control_iterate(loop, -1);\n+ * }\n+ * spa_loop_control_leave(loop);\n+ * \\endcode\n+ *\n+ * It is also possible to add the loop to an existing event loop by using the\n+ * spa_loop_control_get_fd() call. This fd will become readable when activity\n+ * has been detected on the sources in the loop. spa_loop_control_iterate() with\n+ * a 0 timeout should be called to process the pending sources.\n+ *\n+ * spa_loop_control_enter() and spa_loop_control_leave() should be called once\n+ * from the thread that will run the iterate() function.\n@@ -146,0 +219,9 @@\n+    \/** get the loop fd\n+     * \\param object the control to query\n+     *\n+     * Get the fd of this loop control. This fd will be readable when a\n+     * source in the loop has activity. The user should call iterate()\n+     * with a 0 timeout to schedule one iteration of the loop and dispatch\n+     * the sources.\n+     * \\return the fd of the loop\n+     *\/\n@@ -149,1 +231,1 @@\n-     * \\param ctrl the control to change\n+     * \\param object the control to change\n@@ -160,1 +242,1 @@\n-     * \\param ctrl the control\n+     * \\param object the control\n@@ -162,3 +244,4 @@\n-     * Start an iteration of the loop. This function should be called\n-     * before calling iterate and is typically used to capture the thread\n-     * that this loop will run in.\n+     * This function should be called before calling iterate and is\n+     * typically used to capture the thread that this loop will run in.\n+     * It should ideally be called once from the thread that will run\n+     * the loop.\n@@ -168,1 +251,1 @@\n-     * \\param ctrl the control\n+     * \\param object the control\n@@ -170,2 +253,2 @@\n-     * Ends the iteration of a loop. This should be called after calling\n-     * iterate.\n+     * It should ideally be called once after calling iterate when the loop\n+     * will no longer be iterated from the thread that called enter().\n@@ -197,24 +280,37 @@\n-#define spa_loop_control_method_v(o,method,version,...)            \\\n-({                                    \\\n-    struct spa_loop_control *_o = o;                \\\n-    spa_interface_call(&_o->iface,                    \\\n-            struct spa_loop_control_methods,        \\\n-            method, version, ##__VA_ARGS__);        \\\n-})\n-\n-#define spa_loop_control_method_r(o,method,version,...)            \\\n-({                                    \\\n-    int _res = -ENOTSUP;                        \\\n-    struct spa_loop_control *_o = o;                \\\n-    spa_interface_call_res(&_o->iface,                \\\n-            struct spa_loop_control_methods, _res,        \\\n-            method, version, ##__VA_ARGS__);        \\\n-    _res;                                \\\n-})\n-\n-#define spa_loop_control_get_fd(l)        spa_loop_control_method_r(l,get_fd,0)\n-#define spa_loop_control_add_hook(l,...)    spa_loop_control_method_v(l,add_hook,0,__VA_ARGS__)\n-#define spa_loop_control_enter(l)        spa_loop_control_method_v(l,enter,0)\n-#define spa_loop_control_leave(l)        spa_loop_control_method_v(l,leave,0)\n-#define spa_loop_control_iterate(l,...)        spa_loop_control_method_r(l,iterate,0,__VA_ARGS__)\n-#define spa_loop_control_check(l)        spa_loop_control_method_r(l,check,1)\n+SPA_API_LOOP int spa_loop_control_get_fd(struct spa_loop_control *object)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            spa_loop_control, &object->iface, get_fd, 0);\n+}\n+SPA_API_LOOP void spa_loop_control_add_hook(struct spa_loop_control *object,\n+        struct spa_hook *hook, const struct spa_loop_control_hooks *hooks,\n+        void *data)\n+{\n+    spa_api_method_v(spa_loop_control, &object->iface, add_hook, 0,\n+            hook, hooks, data);\n+}\n+SPA_API_LOOP void spa_loop_control_enter(struct spa_loop_control *object)\n+{\n+    spa_api_method_v(spa_loop_control, &object->iface, enter, 0);\n+}\n+SPA_API_LOOP void spa_loop_control_leave(struct spa_loop_control *object)\n+{\n+    spa_api_method_v(spa_loop_control, &object->iface, leave, 0);\n+}\n+SPA_API_LOOP int spa_loop_control_iterate(struct spa_loop_control *object,\n+        int timeout)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            spa_loop_control, &object->iface, iterate, 0, timeout);\n+}\n+SPA_API_LOOP int spa_loop_control_iterate_fast(struct spa_loop_control *object,\n+        int timeout)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP,\n+            spa_loop_control, &object->iface, iterate, 0, timeout);\n+}\n+SPA_API_LOOP int spa_loop_control_check(struct spa_loop_control *object)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            spa_loop_control, &object->iface, check, 1);\n+}\n@@ -271,38 +367,65 @@\n-#define spa_loop_utils_method_v(o,method,version,...)            \\\n-({                                    \\\n-    struct spa_loop_utils *_o = o;                    \\\n-    spa_interface_call(&_o->iface,                    \\\n-            struct spa_loop_utils_methods,            \\\n-            method, version, ##__VA_ARGS__);        \\\n-})\n-\n-#define spa_loop_utils_method_r(o,method,version,...)            \\\n-({                                    \\\n-    int _res = -ENOTSUP;                        \\\n-    struct spa_loop_utils *_o = o;                    \\\n-    spa_interface_call_res(&_o->iface,                \\\n-            struct spa_loop_utils_methods, _res,        \\\n-            method, version, ##__VA_ARGS__);        \\\n-    _res;                                \\\n-})\n-#define spa_loop_utils_method_s(o,method,version,...)            \\\n-({                                    \\\n-    struct spa_source *_res = NULL;                    \\\n-    struct spa_loop_utils *_o = o;                    \\\n-    spa_interface_call_res(&_o->iface,                \\\n-            struct spa_loop_utils_methods, _res,        \\\n-            method, version, ##__VA_ARGS__);        \\\n-    _res;                                \\\n-})\n-\n-\n-#define spa_loop_utils_add_io(l,...)        spa_loop_utils_method_s(l,add_io,0,__VA_ARGS__)\n-#define spa_loop_utils_update_io(l,...)        spa_loop_utils_method_r(l,update_io,0,__VA_ARGS__)\n-#define spa_loop_utils_add_idle(l,...)        spa_loop_utils_method_s(l,add_idle,0,__VA_ARGS__)\n-#define spa_loop_utils_enable_idle(l,...)    spa_loop_utils_method_r(l,enable_idle,0,__VA_ARGS__)\n-#define spa_loop_utils_add_event(l,...)        spa_loop_utils_method_s(l,add_event,0,__VA_ARGS__)\n-#define spa_loop_utils_signal_event(l,...)    spa_loop_utils_method_r(l,signal_event,0,__VA_ARGS__)\n-#define spa_loop_utils_add_timer(l,...)        spa_loop_utils_method_s(l,add_timer,0,__VA_ARGS__)\n-#define spa_loop_utils_update_timer(l,...)    spa_loop_utils_method_r(l,update_timer,0,__VA_ARGS__)\n-#define spa_loop_utils_add_signal(l,...)    spa_loop_utils_method_s(l,add_signal,0,__VA_ARGS__)\n-#define spa_loop_utils_destroy_source(l,...)    spa_loop_utils_method_v(l,destroy_source,0,__VA_ARGS__)\n+SPA_API_LOOP struct spa_source *\n+spa_loop_utils_add_io(struct spa_loop_utils *object, int fd, uint32_t mask,\n+        bool close, spa_source_io_func_t func, void *data)\n+{\n+    return spa_api_method_r(struct spa_source *, NULL,\n+            spa_loop_utils, &object->iface, add_io, 0, fd, mask, close, func, data);\n+}\n+SPA_API_LOOP int spa_loop_utils_update_io(struct spa_loop_utils *object,\n+        struct spa_source *source, uint32_t mask)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            spa_loop_utils, &object->iface, update_io, 0, source, mask);\n+}\n+SPA_API_LOOP struct spa_source *\n+spa_loop_utils_add_idle(struct spa_loop_utils *object, bool enabled,\n+        spa_source_idle_func_t func, void *data)\n+{\n+    return spa_api_method_r(struct spa_source *, NULL,\n+            spa_loop_utils, &object->iface, add_idle, 0, enabled, func, data);\n+}\n+SPA_API_LOOP int spa_loop_utils_enable_idle(struct spa_loop_utils *object,\n+        struct spa_source *source, bool enabled)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            spa_loop_utils, &object->iface, enable_idle, 0, source, enabled);\n+}\n+SPA_API_LOOP struct spa_source *\n+spa_loop_utils_add_event(struct spa_loop_utils *object, spa_source_event_func_t func, void *data)\n+{\n+    return spa_api_method_r(struct spa_source *, NULL,\n+            spa_loop_utils, &object->iface, add_event, 0, func, data);\n+}\n+SPA_API_LOOP int spa_loop_utils_signal_event(struct spa_loop_utils *object,\n+        struct spa_source *source)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            spa_loop_utils, &object->iface, signal_event, 0, source);\n+}\n+SPA_API_LOOP struct spa_source *\n+spa_loop_utils_add_timer(struct spa_loop_utils *object, spa_source_timer_func_t func, void *data)\n+{\n+    return spa_api_method_r(struct spa_source *, NULL,\n+            spa_loop_utils, &object->iface, add_timer, 0, func, data);\n+}\n+SPA_API_LOOP int spa_loop_utils_update_timer(struct spa_loop_utils *object,\n+        struct spa_source *source, struct timespec *value,\n+        struct timespec *interval, bool absolute)\n+{\n+    return spa_api_method_r(int, -ENOTSUP,\n+            spa_loop_utils, &object->iface, update_timer, 0, source,\n+            value, interval, absolute);\n+}\n+SPA_API_LOOP struct spa_source *\n+spa_loop_utils_add_signal(struct spa_loop_utils *object, int signal_number,\n+        spa_source_signal_func_t func, void *data)\n+{\n+    return spa_api_method_r(struct spa_source *, NULL,\n+            spa_loop_utils, &object->iface, add_signal, 0,\n+            signal_number, func, data);\n+}\n+SPA_API_LOOP void spa_loop_utils_destroy_source(struct spa_loop_utils *object,\n+        struct spa_source *source)\n+{\n+    spa_api_method_v(spa_loop_utils, &object->iface, destroy_source, 0, source);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/support\/loop.h","additions":227,"deletions":104,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -15,0 +15,1 @@\n+#include <errno.h>\n@@ -20,0 +21,8 @@\n+#ifndef SPA_API_SYSTEM\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_SYSTEM SPA_API_IMPL\n+ #else\n+  #define SPA_API_SYSTEM static inline\n+ #endif\n+#endif\n+\n@@ -100,36 +109,100 @@\n-#define spa_system_method_r(o,method,version,...)            \\\n-({                                    \\\n-    volatile int _res = -ENOTSUP;                    \\\n-    struct spa_system *_o = o;                    \\\n-    spa_interface_call_res(&_o->iface,                \\\n-            struct spa_system_methods, _res,        \\\n-            method, version, ##__VA_ARGS__);        \\\n-    _res;                                \\\n-})\n-\n-\n-#define spa_system_read(s,...)            spa_system_method_r(s,read,0,__VA_ARGS__)\n-#define spa_system_write(s,...)            spa_system_method_r(s,write,0,__VA_ARGS__)\n-#define spa_system_ioctl(s,...)            spa_system_method_r(s,ioctl,0,__VA_ARGS__)\n-#define spa_system_close(s,...)            spa_system_method_r(s,close,0,__VA_ARGS__)\n-\n-#define spa_system_clock_gettime(s,...)        spa_system_method_r(s,clock_gettime,0,__VA_ARGS__)\n-#define spa_system_clock_getres(s,...)        spa_system_method_r(s,clock_getres,0,__VA_ARGS__)\n-\n-#define spa_system_pollfd_create(s,...)        spa_system_method_r(s,pollfd_create,0,__VA_ARGS__)\n-#define spa_system_pollfd_add(s,...)        spa_system_method_r(s,pollfd_add,0,__VA_ARGS__)\n-#define spa_system_pollfd_mod(s,...)        spa_system_method_r(s,pollfd_mod,0,__VA_ARGS__)\n-#define spa_system_pollfd_del(s,...)        spa_system_method_r(s,pollfd_del,0,__VA_ARGS__)\n-#define spa_system_pollfd_wait(s,...)        spa_system_method_r(s,pollfd_wait,0,__VA_ARGS__)\n-\n-#define spa_system_timerfd_create(s,...)    spa_system_method_r(s,timerfd_create,0,__VA_ARGS__)\n-#define spa_system_timerfd_settime(s,...)    spa_system_method_r(s,timerfd_settime,0,__VA_ARGS__)\n-#define spa_system_timerfd_gettime(s,...)    spa_system_method_r(s,timerfd_gettime,0,__VA_ARGS__)\n-#define spa_system_timerfd_read(s,...)        spa_system_method_r(s,timerfd_read,0,__VA_ARGS__)\n-\n-#define spa_system_eventfd_create(s,...)    spa_system_method_r(s,eventfd_create,0,__VA_ARGS__)\n-#define spa_system_eventfd_write(s,...)        spa_system_method_r(s,eventfd_write,0,__VA_ARGS__)\n-#define spa_system_eventfd_read(s,...)        spa_system_method_r(s,eventfd_read,0,__VA_ARGS__)\n-\n-#define spa_system_signalfd_create(s,...)    spa_system_method_r(s,signalfd_create,0,__VA_ARGS__)\n-#define spa_system_signalfd_read(s,...)        spa_system_method_r(s,signalfd_read,0,__VA_ARGS__)\n+SPA_API_SYSTEM ssize_t spa_system_read(struct spa_system *object, int fd, void *buf, size_t count)\n+{\n+    return spa_api_method_fast_r(ssize_t, -ENOTSUP, spa_system, &object->iface, read, 0, fd, buf, count);\n+}\n+SPA_API_SYSTEM ssize_t spa_system_write(struct spa_system *object, int fd, const void *buf, size_t count)\n+{\n+    return spa_api_method_fast_r(ssize_t, -ENOTSUP, spa_system, &object->iface, write, 0, fd, buf, count);\n+}\n+#define spa_system_ioctl(object,fd,request,...)    \\\n+    spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, ioctl, 0, fd, request, ##__VA_ARGS__)\n+\n+SPA_API_SYSTEM int spa_system_close(struct spa_system *object, int fd)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, close, 0, fd);\n+}\n+SPA_API_SYSTEM int spa_system_clock_gettime(struct spa_system *object,\n+            int clockid, struct timespec *value)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, clock_gettime, 0, clockid, value);\n+}\n+SPA_API_SYSTEM int spa_system_clock_getres(struct spa_system *object,\n+            int clockid, struct timespec *res)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, clock_getres, 0, clockid, res);\n+}\n+\n+SPA_API_SYSTEM int spa_system_pollfd_create(struct spa_system *object, int flags)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, pollfd_create, 0, flags);\n+}\n+SPA_API_SYSTEM int spa_system_pollfd_add(struct spa_system *object, int pfd, int fd, uint32_t events, void *data)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, pollfd_add, 0, pfd, fd, events, data);\n+}\n+SPA_API_SYSTEM int spa_system_pollfd_mod(struct spa_system *object, int pfd, int fd, uint32_t events, void *data)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, pollfd_mod, 0, pfd, fd, events, data);\n+}\n+SPA_API_SYSTEM int spa_system_pollfd_del(struct spa_system *object, int pfd, int fd)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, pollfd_del, 0, pfd, fd);\n+}\n+SPA_API_SYSTEM int spa_system_pollfd_wait(struct spa_system *object, int pfd,\n+            struct spa_poll_event *ev, int n_ev, int timeout)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, pollfd_wait, 0, pfd, ev, n_ev, timeout);\n+}\n+\n+SPA_API_SYSTEM int spa_system_timerfd_create(struct spa_system *object, int clockid, int flags)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, timerfd_create, 0, clockid, flags);\n+}\n+\n+SPA_API_SYSTEM int spa_system_timerfd_settime(struct spa_system *object,\n+            int fd, int flags,\n+            const struct itimerspec *new_value,\n+            struct itimerspec *old_value)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, timerfd_settime, 0,\n+            fd, flags, new_value, old_value);\n+}\n+\n+SPA_API_SYSTEM int spa_system_timerfd_gettime(struct spa_system *object,\n+            int fd, struct itimerspec *curr_value)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, timerfd_gettime, 0,\n+            fd, curr_value);\n+}\n+SPA_API_SYSTEM int spa_system_timerfd_read(struct spa_system *object, int fd, uint64_t *expirations)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, timerfd_read, 0,\n+            fd, expirations);\n+}\n+\n+SPA_API_SYSTEM int spa_system_eventfd_create(struct spa_system *object, int flags)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, eventfd_create, 0, flags);\n+}\n+SPA_API_SYSTEM int spa_system_eventfd_write(struct spa_system *object, int fd, uint64_t count)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, eventfd_write, 0,\n+            fd, count);\n+}\n+SPA_API_SYSTEM int spa_system_eventfd_read(struct spa_system *object, int fd, uint64_t *count)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, eventfd_read, 0,\n+            fd, count);\n+}\n+\n+SPA_API_SYSTEM int spa_system_signalfd_create(struct spa_system *object, int signal, int flags)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, signalfd_create, 0,\n+            signal, flags);\n+}\n+\n+SPA_API_SYSTEM int spa_system_signalfd_read(struct spa_system *object, int fd, int *signal)\n+{\n+    return spa_api_method_fast_r(int, -ENOTSUP, spa_system, &object->iface, signalfd_read, 0,\n+            fd, signal);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/support\/system.h","additions":109,"deletions":36,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2023 PipeWire authors *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_UTILS_CLEANUP_H\n+#define SPA_UTILS_CLEANUP_H\n+\n+#define spa_exchange(var, new_value) \\\n+__extension__ ({ \\\n+    __typeof__(var) *_ptr_ = &(var); \\\n+    __typeof__(var) _old_value_ = *_ptr_; \\\n+    *_ptr_ = (new_value); \\\n+    _old_value_; \\\n+})\n+\n+\/* ========================================================================== *\/\n+\n+#if __GNUC__ >= 10 || defined(__clang__)\n+#define spa_steal_ptr(ptr) ((__typeof__(*(ptr)) *) spa_exchange((ptr), NULL))\n+#else\n+#define spa_steal_ptr(ptr) spa_exchange((ptr), NULL)\n+#endif\n+\n+#define spa_clear_ptr(ptr, destructor) \\\n+__extension__ ({ \\\n+    __typeof__(ptr) _old_value = spa_steal_ptr(ptr); \\\n+    if (_old_value) \\\n+        destructor(_old_value); \\\n+    (void) 0; \\\n+})\n+\n+\/* ========================================================================== *\/\n+\n+#include <errno.h>\n+#include <unistd.h>\n+\n+#define spa_steal_fd(fd) spa_exchange((fd), -1)\n+\n+#define spa_clear_fd(fd) \\\n+__extension__ ({ \\\n+    int _old_value = spa_steal_fd(fd), _res = 0; \\\n+    if (_old_value >= 0) \\\n+        _res = close(_old_value); \\\n+    _res; \\\n+})\n+\n+\/* ========================================================================== *\/\n+\n+#if defined(__has_attribute) && __has_attribute(__cleanup__)\n+\n+#define spa_cleanup(func) __attribute__((__cleanup__(func)))\n+\n+#define SPA_DEFINE_AUTO_CLEANUP(name, type, ...) \\\n+typedef __typeof__(type) _spa_auto_cleanup_type_ ## name; \\\n+static inline void _spa_auto_cleanup_func_ ## name (__typeof__(type) *thing) \\\n+{ \\\n+    int _save_errno = errno; \\\n+    __VA_ARGS__ \\\n+    errno = _save_errno; \\\n+}\n+\n+#define spa_auto(name) \\\n+    spa_cleanup(_spa_auto_cleanup_func_ ## name) \\\n+    _spa_auto_cleanup_type_ ## name\n+\n+#define SPA_DEFINE_AUTOPTR_CLEANUP(name, type, ...) \\\n+typedef __typeof__(type) * _spa_autoptr_cleanup_type_ ## name; \\\n+static inline void _spa_autoptr_cleanup_func_ ## name (__typeof__(type) **thing) \\\n+{ \\\n+    int _save_errno = errno; \\\n+    __VA_ARGS__ \\\n+    errno = _save_errno; \\\n+}\n+\n+#define spa_autoptr(name) \\\n+    spa_cleanup(_spa_autoptr_cleanup_func_ ## name) \\\n+    _spa_autoptr_cleanup_type_ ## name\n+\n+\/* ========================================================================== *\/\n+\n+#include <stdlib.h>\n+\n+static inline void _spa_autofree_cleanup_func(void *p)\n+{\n+    int save_errno = errno;\n+    free(*(void **) p);\n+    errno = save_errno;\n+}\n+#define spa_autofree spa_cleanup(_spa_autofree_cleanup_func)\n+\n+\/* ========================================================================== *\/\n+\n+static inline void _spa_autoclose_cleanup_func(int *fd)\n+{\n+    int save_errno = errno;\n+    spa_clear_fd(*fd);\n+    errno = save_errno;\n+}\n+#define spa_autoclose spa_cleanup(_spa_autoclose_cleanup_func)\n+\n+\/* ========================================================================== *\/\n+\n+#include <stdio.h>\n+\n+SPA_DEFINE_AUTOPTR_CLEANUP(FILE, FILE, {\n+    spa_clear_ptr(*thing, fclose);\n+})\n+\n+\/* ========================================================================== *\/\n+\n+#include <dirent.h>\n+\n+SPA_DEFINE_AUTOPTR_CLEANUP(DIR, DIR, {\n+    spa_clear_ptr(*thing, closedir);\n+})\n+\n+#else\n+\n+#define SPA_DEFINE_AUTO_CLEANUP(name, type, ...)\n+#define SPA_DEFINE_AUTOPTR_CLEANUP(name, type, ...)\n+\n+#endif\n+\n+#endif \/* SPA_UTILS_CLEANUP_H *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/utils\/cleanup.h","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -12,0 +12,1 @@\n+#  define SPA_ALIGNOF alignof\n@@ -13,0 +14,3 @@\n+#elif __STDC_VERSION__ >= 202311L\n+#  define SPA_STATIC_ASSERT_IMPL(expr, msg, ...) static_assert(expr, msg)\n+#  define SPA_ALIGNOF alignof\n@@ -17,0 +21,1 @@\n+#  define SPA_ALIGNOF _Alignof\n@@ -23,0 +28,3 @@\n+#ifndef SPA_ALIGNOF\n+#define SPA_ALIGNOF __alignof__\n+#endif\n@@ -26,0 +34,3 @@\n+#define SPA_CONCAT_NOEXPAND(a, b) a ## b\n+#define SPA_CONCAT(a, b) SPA_CONCAT_NOEXPAND(a, b)\n+\n@@ -125,1 +136,1 @@\n-    for ((ptr) = arr; (void*)(ptr) < SPA_PTROFF(arr, sizeof(arr), void); (ptr)++)\n+    for ((ptr) = arr; (ptr) < (arr) + SPA_N_ELEMENTS(arr); (ptr)++)\n@@ -128,1 +139,1 @@\n-    for (__typeof__((arr)[0])* var = arr; (void*)(var) < SPA_PTROFF(arr, sizeof(arr), void); (var)++)\n+    for (__typeof__((arr)[0])* var = arr; (var) < (arr) + SPA_N_ELEMENTS(arr); (var)++)\n@@ -159,0 +170,4 @@\n+#define SPA_CLAMPD(v,low,high)                \\\n+({                            \\\n+    fmin(fmax(v, low), high);            \\\n+})\n@@ -174,0 +189,10 @@\n+\/** 3-way comparison. NaN > NaN and NaN > finite numbers *\/\n+#define SPA_CMP(a, b)                    \\\n+({                            \\\n+    __typeof__(a) _a = (a);                \\\n+    __typeof__(b) _b = (b);                \\\n+    (_a > _b) ? 1 : (_a == _b) ? 0 : (_a < _b) ? -1 \\\n+        : (_a == _a) ? -1 : (_b == _b) ? 1     \\\n+        : 1;                    \\\n+})\n+\n@@ -181,1 +206,0 @@\n-\n@@ -192,3 +216,0 @@\n-#define SPA_PTR_TO_INT(p) ((int) ((intptr_t) (p)))\n-#define SPA_INT_TO_PTR(u) ((void*) ((intptr_t) (u)))\n-\n@@ -236,0 +257,14 @@\n+#ifndef SPA_API_IMPL\n+#define SPA_API_PROTO static inline\n+#define SPA_API_IMPL static inline\n+#endif\n+\n+#ifndef SPA_API_UTILS_DEFS\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_UTILS_DEFS SPA_API_IMPL\n+ #else\n+  #define SPA_API_UTILS_DEFS static inline\n+ #endif\n+#endif\n+\n+\n@@ -268,1 +303,1 @@\n-#define SPA_PTR_ALIGNMENT(p,align)    ((intptr_t)(p) & ((align)-1))\n+#define SPA_PTR_ALIGNMENT(p,align)    ((uintptr_t)(p) & ((align)-1))\n@@ -282,0 +317,34 @@\n+SPA_API_UTILS_DEFS bool spa_ptrinside(const void *p1, size_t s1, const void *p2, size_t s2,\n+                                 size_t *remaining)\n+{\n+    if (SPA_LIKELY((uintptr_t)p1 <= (uintptr_t)p2 && s2 <= s1 &&\n+                   (uintptr_t)p2 - (uintptr_t)p1 <= s1 - s2)) {\n+        if (remaining != NULL)\n+            *remaining = ((uintptr_t)p1 + s1) - ((uintptr_t)p2 + s2);\n+        return true;\n+    } else {\n+        if (remaining != NULL)\n+            *remaining = 0;\n+        return false;\n+    }\n+}\n+\n+SPA_API_UTILS_DEFS bool spa_ptr_inside_and_aligned(const void *p1, size_t s1,\n+                                              const void *p2, size_t s2, size_t align,\n+                                              size_t *remaining)\n+{\n+    if (SPA_IS_ALIGNED(p2, align)) {\n+        return spa_ptrinside(p1, s1, p2, s2, remaining);\n+    } else {\n+        if (remaining != NULL)\n+            *remaining = 0;\n+        return false;\n+    }\n+}\n+\n+#define spa_ptr_type_inside(p1, s1, p2, type, remaining) \\\n+    spa_ptr_inside_and_aligned(p1, s1, p2, sizeof(type), SPA_ALIGNOF(type), remaining)\n+\n+#define SPA_PTR_TO_INT(p) ((int) ((intptr_t) (p)))\n+#define SPA_INT_TO_PTR(u) ((void*) ((intptr_t) (u)))\n+\n@@ -285,0 +354,8 @@\n+struct spa_error_location {\n+    int line;\n+    int col;\n+    size_t len;\n+    const char *location;\n+    const char *reason;\n+};\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/utils\/defs.h","additions":84,"deletions":7,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -16,0 +16,8 @@\n+#ifndef SPA_API_DICT\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_DICT SPA_API_IMPL\n+ #else\n+  #define SPA_API_DICT static inline\n+ #endif\n+#endif\n+\n@@ -31,1 +39,2 @@\n-#define SPA_DICT_ITEM_INIT(key,value) ((struct spa_dict_item) { (key), (value) })\n+#define SPA_DICT_ITEM(key,value) ((struct spa_dict_item) { (key), (value) })\n+#define SPA_DICT_ITEM_INIT(key,value) SPA_DICT_ITEM(key,value)\n@@ -40,2 +49,6 @@\n-#define SPA_DICT_INIT(items,n_items) ((struct spa_dict) { 0, (n_items), (items) })\n-#define SPA_DICT_INIT_ARRAY(items) ((struct spa_dict) { 0, SPA_N_ELEMENTS(items), (items) })\n+#define SPA_DICT(items,n_items) ((struct spa_dict) { 0, (n_items), (items) })\n+#define SPA_DICT_ARRAY(items) SPA_DICT((items),SPA_N_ELEMENTS(items))\n+#define SPA_DICT_ITEMS(...) SPA_DICT_ARRAY(((struct spa_dict_item[]) { __VA_ARGS__}))\n+\n+#define SPA_DICT_INIT(items,n_items) SPA_DICT(items,n_items)\n+#define SPA_DICT_INIT_ARRAY(items) SPA_DICT_ARRAY(items)\n@@ -48,1 +61,1 @@\n-static inline int spa_dict_item_compare(const void *i1, const void *i2)\n+SPA_API_DICT int spa_dict_item_compare(const void *i1, const void *i2)\n@@ -55,1 +68,1 @@\n-static inline void spa_dict_qsort(struct spa_dict *dict)\n+SPA_API_DICT void spa_dict_qsort(struct spa_dict *dict)\n@@ -63,1 +76,1 @@\n-static inline const struct spa_dict_item *spa_dict_lookup_item(const struct spa_dict *dict,\n+SPA_API_DICT const struct spa_dict_item *spa_dict_lookup_item(const struct spa_dict *dict,\n@@ -86,1 +99,1 @@\n-static inline const char *spa_dict_lookup(const struct spa_dict *dict, const char *key)\n+SPA_API_DICT const char *spa_dict_lookup(const struct spa_dict *dict, const char *key)\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/utils\/dict.h","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,26 @@\n+\/* Spa *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2019 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_ENDIAN_H\n+#define SPA_ENDIAN_H\n+\n+#if defined(__FreeBSD__) || defined(__MidnightBSD__)\n+#include <sys\/endian.h>\n+#define bswap_16 bswap16\n+#define bswap_32 bswap32\n+#define bswap_64 bswap64\n+#elif defined(_MSC_VER) && defined(_WIN32)\n+#include <stdlib.h>\n+#define __LITTLE_ENDIAN 1234\n+#define __BIG_ENDIAN 4321\n+#define __BYTE_ORDER __LITTLE_ENDIAN\n+#define bswap_16 _byteswap_ushort\n+#define bswap_32 _byteswap_ulong\n+#define bswap_64 _byteswap_uint64\n+#else\n+#include <endian.h>\n+#include <byteswap.h>\n+#endif\n+\n+#endif \/* SPA_ENDIAN_H *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/utils\/endian.h","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -13,0 +13,6 @@\n+#include <spa\/pod\/pod.h>\n+\n+\/**\n+ * \\addtogroup spa_types\n+ * \\{\n+ *\/\n@@ -23,2 +29,0 @@\n-#include <spa\/pod\/pod.h>\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/utils\/enum-types.h","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -15,0 +15,8 @@\n+#ifndef SPA_API_HOOK\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_HOOK SPA_API_IMPL\n+ #else\n+  #define SPA_API_HOOK static inline\n+ #endif\n+#endif\n+\n@@ -161,1 +169,1 @@\n-        _f->method((callbacks)->data, ## __VA_ARGS__);            \\\n+        (_f->method)((callbacks)->data, ## __VA_ARGS__);        \\\n@@ -165,0 +173,8 @@\n+#define spa_callbacks_call_fast(callbacks,type,method,vers,...)            \\\n+({                                        \\\n+    const type *_f = (const type *) (callbacks)->funcs;            \\\n+    (_f->method)((callbacks)->data, ## __VA_ARGS__);            \\\n+    true;                                    \\\n+})\n+\n+\n@@ -194,1 +210,1 @@\n-        res = _f->method((callbacks)->data, ## __VA_ARGS__);        \\\n+        res = (_f->method)((callbacks)->data, ## __VA_ARGS__);        \\\n@@ -197,0 +213,5 @@\n+#define spa_callbacks_call_fast_res(callbacks,type,res,method,vers,...)        \\\n+({                                        \\\n+    const type *_f = (const type *) (callbacks)->funcs;            \\\n+    res = (_f->method)((callbacks)->data, ## __VA_ARGS__);            \\\n+})\n@@ -219,0 +240,3 @@\n+#define spa_interface_call_fast(iface,method_type,method,vers,...)        \\\n+    spa_callbacks_call_fast(&(iface)->cb,method_type,method,vers,##__VA_ARGS__)\n+\n@@ -229,0 +253,70 @@\n+#define spa_interface_call_fast_res(iface,method_type,res,method,vers,...)        \\\n+    spa_callbacks_call_fast_res(&(iface)->cb,method_type,res,method,vers,##__VA_ARGS__)\n+\n+\n+#define spa_api_func_v(o,method,version,...)                \\\n+({                                    \\\n+    if (SPA_LIKELY(SPA_CALLBACK_CHECK(o,method,version)))        \\\n+        ((o)->method)(o, ##__VA_ARGS__);            \\\n+})\n+#define spa_api_func_r(rtype,def,o,method,version,...)            \\\n+({                                    \\\n+    rtype _res = def;                        \\\n+    if (SPA_LIKELY(SPA_CALLBACK_CHECK(o,method,version)))        \\\n+        _res = ((o)->method)(o, ##__VA_ARGS__);            \\\n+    _res;                                \\\n+})\n+#define spa_api_func_fast(o,method,...)                    \\\n+({                                    \\\n+    ((o)->method)(o, ##__VA_ARGS__);                \\\n+})\n+\n+#define spa_api_method_v(type,o,method,version,...)            \\\n+({                                    \\\n+    struct spa_interface *_i = o;            \\\n+    spa_interface_call(_i, struct type ##_methods,            \\\n+            method, version, ##__VA_ARGS__);        \\\n+})\n+#define spa_api_method_r(rtype,def,type,o,method,version,...)        \\\n+({                                    \\\n+    rtype _res = def;                        \\\n+    struct spa_interface *_i = o;            \\\n+    spa_interface_call_res(_i, struct type ##_methods,        \\\n+            _res, method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+#define spa_api_method_null_v(type,co,o,method,version,...)        \\\n+({                                    \\\n+    struct type *_co = co;                        \\\n+    if (SPA_LIKELY(_co != NULL)) {                    \\\n+        struct spa_interface *_i = o;                \\\n+        spa_interface_call(_i, struct type ##_methods,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+    }                                \\\n+})\n+#define spa_api_method_null_r(rtype,def,type,co,o,method,version,...)    \\\n+({                                    \\\n+    rtype _res = def;                        \\\n+    struct type *_co = co;                        \\\n+    if (SPA_LIKELY(_co != NULL)) {                    \\\n+        struct spa_interface *_i = o;                \\\n+        spa_interface_call_res(_i, struct type ##_methods,    \\\n+                _res, method, version, ##__VA_ARGS__);    \\\n+    }                                \\\n+    _res;                                \\\n+})\n+#define spa_api_method_fast_v(type,o,method,version,...)        \\\n+({                                    \\\n+    struct spa_interface *_i = o;                    \\\n+    spa_interface_call_fast(_i, struct type ##_methods,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+})\n+#define spa_api_method_fast_r(rtype,def,type,o,method,version,...)    \\\n+({                                    \\\n+    rtype _res = def;                        \\\n+    struct spa_interface *_i = o;                    \\\n+    spa_interface_call_fast_res(_i, struct type ##_methods,        \\\n+            _res, method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n@@ -332,1 +426,1 @@\n-static inline void spa_hook_list_init(struct spa_hook_list *list)\n+SPA_API_HOOK void spa_hook_list_init(struct spa_hook_list *list)\n@@ -337,1 +431,1 @@\n-static inline bool spa_hook_list_is_empty(struct spa_hook_list *list)\n+SPA_API_HOOK bool spa_hook_list_is_empty(struct spa_hook_list *list)\n@@ -343,1 +437,1 @@\n-static inline void spa_hook_list_append(struct spa_hook_list *list,\n+SPA_API_HOOK void spa_hook_list_append(struct spa_hook_list *list,\n@@ -353,1 +447,1 @@\n-static inline void spa_hook_list_prepend(struct spa_hook_list *list,\n+SPA_API_HOOK void spa_hook_list_prepend(struct spa_hook_list *list,\n@@ -363,1 +457,1 @@\n-static inline void spa_hook_remove(struct spa_hook *hook)\n+SPA_API_HOOK void spa_hook_remove(struct spa_hook *hook)\n@@ -372,1 +466,1 @@\n-static inline void spa_hook_list_clean(struct spa_hook_list *list)\n+SPA_API_HOOK void spa_hook_list_clean(struct spa_hook_list *list)\n@@ -379,1 +473,1 @@\n-static inline void\n+SPA_API_HOOK void\n@@ -393,1 +487,1 @@\n-static inline void\n+SPA_API_HOOK void\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/utils\/hook.h","additions":104,"deletions":10,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -12,0 +12,10 @@\n+#include <spa\/utils\/defs.h>\n+\n+#ifndef SPA_API_LIST\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_LIST SPA_API_IMPL\n+ #else\n+  #define SPA_API_LIST static inline\n+ #endif\n+#endif\n+\n@@ -29,1 +39,1 @@\n-static inline void spa_list_init(struct spa_list *list)\n+SPA_API_LIST void spa_list_init(struct spa_list *list)\n@@ -34,1 +44,1 @@\n-static inline int spa_list_is_initialized(struct spa_list *list)\n+SPA_API_LIST int spa_list_is_initialized(struct spa_list *list)\n@@ -41,1 +51,1 @@\n-static inline void spa_list_insert(struct spa_list *list, struct spa_list *elem)\n+SPA_API_LIST void spa_list_insert(struct spa_list *list, struct spa_list *elem)\n@@ -49,1 +59,1 @@\n-static inline void spa_list_insert_list(struct spa_list *list, struct spa_list *other)\n+SPA_API_LIST void spa_list_insert_list(struct spa_list *list, struct spa_list *other)\n@@ -59,1 +69,1 @@\n-static inline void spa_list_remove(struct spa_list *elem)\n+SPA_API_LIST void spa_list_remove(struct spa_list *elem)\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/utils\/list.h","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -20,0 +20,8 @@\n+#ifndef SPA_API_STRING\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_STRING SPA_API_IMPL\n+ #else\n+  #define SPA_API_STRING static inline\n+ #endif\n+#endif\n+\n@@ -36,1 +44,1 @@\n-static inline bool spa_streq(const char *s1, const char *s2)\n+SPA_API_STRING bool spa_streq(const char *s1, const char *s2)\n@@ -46,1 +54,1 @@\n-static inline bool spa_strneq(const char *s1, const char *s2, size_t len)\n+SPA_API_STRING bool spa_strneq(const char *s1, const char *s2, size_t len)\n@@ -57,1 +65,1 @@\n-static inline bool spa_strstartswith(const char *s, const char *prefix)\n+SPA_API_STRING bool spa_strstartswith(const char *s, const char *prefix)\n@@ -73,1 +81,1 @@\n-static inline bool spa_strendswith(const char *s, const char *suffix)\n+SPA_API_STRING bool spa_strendswith(const char *s, const char *suffix)\n@@ -95,1 +103,1 @@\n-static inline bool spa_atoi32(const char *str, int32_t *val, int base)\n+SPA_API_STRING bool spa_atoi32(const char *str, int32_t *val, int base)\n@@ -123,1 +131,1 @@\n-static inline bool spa_atou32(const char *str, uint32_t *val, int base)\n+SPA_API_STRING bool spa_atou32(const char *str, uint32_t *val, int base)\n@@ -151,1 +159,1 @@\n-static inline bool spa_atoi64(const char *str, int64_t *val, int base)\n+SPA_API_STRING bool spa_atoi64(const char *str, int64_t *val, int base)\n@@ -176,1 +184,1 @@\n-static inline bool spa_atou64(const char *str, uint64_t *val, int base)\n+SPA_API_STRING bool spa_atou64(const char *str, uint64_t *val, int base)\n@@ -199,1 +207,1 @@\n-static inline bool spa_atob(const char *str)\n+SPA_API_STRING bool spa_atob(const char *str)\n@@ -213,1 +221,1 @@\n-static inline int spa_vscnprintf(char *buffer, size_t size, const char *format, va_list args)\n+SPA_API_STRING int spa_vscnprintf(char *buffer, size_t size, const char *format, va_list args)\n@@ -236,1 +244,1 @@\n-static inline int spa_scnprintf(char *buffer, size_t size, const char *format, ...)\n+SPA_API_STRING int spa_scnprintf(char *buffer, size_t size, const char *format, ...)\n@@ -256,1 +264,1 @@\n-static inline float spa_strtof(const char *str, char **endptr)\n+SPA_API_STRING float spa_strtof(const char *str, char **endptr)\n@@ -282,1 +290,1 @@\n-static inline bool spa_atof(const char *str, float *val)\n+SPA_API_STRING bool spa_atof(const char *str, float *val)\n@@ -306,1 +314,1 @@\n-static inline double spa_strtod(const char *str, char **endptr)\n+SPA_API_STRING double spa_strtod(const char *str, char **endptr)\n@@ -332,1 +340,1 @@\n-static inline bool spa_atod(const char *str, double *val)\n+SPA_API_STRING bool spa_atod(const char *str, double *val)\n@@ -349,1 +357,1 @@\n-static inline char *spa_dtoa(char *str, size_t size, double val)\n+SPA_API_STRING char *spa_dtoa(char *str, size_t size, double val)\n@@ -365,1 +373,1 @@\n-static inline void spa_strbuf_init(struct spa_strbuf *buf, char *buffer, size_t maxsize)\n+SPA_API_STRING void spa_strbuf_init(struct spa_strbuf *buf, char *buffer, size_t maxsize)\n@@ -370,0 +378,2 @@\n+    if (maxsize > 0)\n+        buf->buffer[0] = '\\0';\n@@ -373,1 +383,1 @@\n-static inline int spa_strbuf_append(struct spa_strbuf *buf, const char *fmt, ...)\n+SPA_API_STRING int spa_strbuf_append(struct spa_strbuf *buf, const char *fmt, ...)\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/utils\/string.h","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -23,4 +23,0 @@\n-static inline bool spa_type_is_a(const char *type, const char *parent)\n-{\n-    return type != NULL && parent != NULL && strncmp(type, parent, strlen(parent)) == 0;\n-}\n@@ -86,0 +82,1 @@\n+    { SPA_TYPE_OBJECT_ParamTag, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_Tag, spa_type_param_tag },\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/utils\/type-info.h","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -13,0 +13,9 @@\n+#include <spa\/utils\/string.h>\n+\n+#ifndef SPA_API_TYPE\n+ #ifdef SPA_API_IMPL\n+  #define SPA_API_TYPE SPA_API_IMPL\n+ #else\n+  #define SPA_API_TYPE static inline\n+ #endif\n+#endif\n@@ -81,0 +90,1 @@\n+    SPA_TYPE_OBJECT_ParamTag,\n@@ -125,0 +135,41 @@\n+SPA_API_TYPE bool spa_type_is_a(const char *type, const char *parent)\n+{\n+    return type != NULL && parent != NULL && strncmp(type, parent, strlen(parent)) == 0;\n+}\n+\n+SPA_API_TYPE const char *spa_type_short_name(const char *name)\n+{\n+    const char *h;\n+    if ((h = strrchr(name, ':')) != NULL)\n+        name = h + 1;\n+    return name;\n+}\n+\n+SPA_API_TYPE uint32_t spa_type_from_short_name(const char *name,\n+        const struct spa_type_info *info, uint32_t unknown)\n+{\n+    int i;\n+    for (i = 0; info[i].name; i++) {\n+        if (spa_streq(name, spa_type_short_name(info[i].name)))\n+            return info[i].type;\n+    }\n+    return unknown;\n+}\n+SPA_API_TYPE const char * spa_type_to_name(uint32_t type,\n+        const struct spa_type_info *info, const char *unknown)\n+{\n+    int i;\n+    for (i = 0; info[i].name; i++) {\n+        if (info[i].type == type)\n+            return info[i].name;\n+    }\n+    return unknown;\n+}\n+\n+SPA_API_TYPE const char * spa_type_to_short_name(uint32_t type,\n+        const struct spa_type_info *info, const char *unknown)\n+{\n+    const char *n = spa_type_to_name(type, info, unknown);\n+    return n ? spa_type_short_name(n) : NULL;\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/libpipewire\/include\/spa\/utils\/type.h","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"}]}