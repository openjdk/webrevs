{"files":[{"patch":"@@ -211,1 +211,2 @@\n-     * @param textRunStart Text run start position.\n+     * @param textRunStart Start position of first Text run where hit info is requested.\n+     *                     For TextFlow this value will be -1 to distinguish it from Text node.\n@@ -213,0 +214,1 @@\n+     *                    For TextFlow this value will be -1  to distinguish it from Text node.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/text\/TextLayout.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -425,0 +425,3 @@\n+        boolean leading = false;\n+        boolean isMirrored = isMirrored(); \/\/ Node orientation is RTL\n+        boolean isMultiRunText = false;\n@@ -427,1 +430,0 @@\n-        boolean leading = false;\n@@ -429,0 +431,1 @@\n+        int LTRIndex = 0;\n@@ -430,0 +433,1 @@\n+        float xHitPos = x;\n@@ -437,1 +441,2 @@\n-            if (isMirrored()) {\n+            boolean isTextFlow = textRunStart == -1 && curRunStart == -1;\n+            if (isMirrored && (isTextFlow || spans == null)) {\n@@ -444,1 +449,0 @@\n-            x -= bounds.getMinX();\n@@ -447,6 +451,26 @@\n-                for (int i = 0; i < runs.length; i++) {\n-                    run = runs[i];\n-                    if (x < run.getWidth()) break;\n-                    if (i + 1 < runs.length) {\n-                        if (runs[i + 1].isLinebreak()) break;\n-                        x -= run.getWidth();\n+                \/\/ To calculate Text and TextFlow hit info\n+                if (isMirrored) {\n+                    int runIndex = -1;\n+                    for (int i = runs.length - 1; i >=0; i--) {\n+                        run = runs[i];\n+                        if (x < run.getWidth() && (isTextFlow || (run.getStart() == curRunStart))) {\n+                            runIndex = i;\n+                            break;\n+                        }\n+                        if (i - 1 >= 0) {\n+                            if (runs[i - 1].isLinebreak()) break;\n+                            x -= run.getWidth();\n+                        }\n+                    }\n+                    for (int i = 0; i < runIndex; i++) {\n+                        xHitPos -= runs[i].getWidth();\n+                    }\n+                    xHitPos -= bounds.getMinX();\n+                } else {\n+                    for (int i = 0; i < runs.length; i++) {\n+                        run = runs[i];\n+                        if (x < run.getWidth()) break;\n+                        if (i + 1 < runs.length) {\n+                            if (runs[i + 1].isLinebreak()) break;\n+                            x -= run.getWidth();\n+                        }\n@@ -456,0 +480,1 @@\n+                \/\/ To calculate hit info of Text embedded in TextFlow\n@@ -463,6 +488,6 @@\n-                int prevNodeLength = 0;\n-                boolean isPrevNodeExcluded = false;\n-                for (TextRun r: runs) {\n-                    if (!r.getTextSpan().getText().equals(text) || (r.getStart() < textRunStart && r.getTextSpan().getText().equals(text))) {\n-                        prevNodeLength += r.getWidth();\n-                        continue;\n+\n+                if (isMirrored) {\n+                    for (TextRun r: runs) {\n+                        if (r.getStart() != curRunStart && r.getTextSpan().getText().equals(text)) {\n+                            isMultiRunText = true;\n+                        }\n@@ -470,6 +495,32 @@\n-                    if (r.getTextSpan() != null && r.getTextSpan().getText().equals(text)) {\n-                        BaseBounds textBounds = new BoxBounds();\n-                        getBounds(r.getTextSpan(), textBounds);\n-                        if (textBounds.getMinX() == 0 && !isPrevNodeExcluded) {\n-                            x -= prevNodeLength;\n-                            isPrevNodeExcluded = true;\n+\n+                    for (int i = 0; i < runs.length; i++) {\n+                        run = runs[i];\n+                        if (run.getStart() != curRunStart && run.getTextSpan().getText().equals(text) && x > run.getWidth()) {\n+                            x -= run.getWidth();\n+                            continue;\n+                        }\n+                        if (run.getTextSpan() != null && run.getTextSpan().getText().equals(text)) {\n+                            if ((x > run.getWidth() && !isMultiRunText) || textWidthPrevLine > 0) {\n+                                BaseBounds textBounds = new BoxBounds();\n+                                getBounds(run.getTextSpan(), textBounds);\n+                                x -= (run.getLocation().x - textBounds.getMinX());\n+                                break;\n+                            }\n+                            if (x > run.getWidth()) {\n+                                x -= run.getWidth();\n+                                relIndex += run.getLength();\n+                                continue;\n+                            }\n+                            for (int j = runs.length - 1; j >= 0; j--) {\n+                                if (runs[j].getTextSpan().getText().equals(text) && runs[j].getStart() != curRunStart) {\n+                                    LTRIndex += runs[j].getLength();\n+                                }\n+                                if (runs[j].getStart() == curRunStart) {\n+                                    break;\n+                                }\n+                            }\n+                            break;\n+                        }\n+                        \/\/ For only English Text embedded in TextFlow in RTL orientation\n+                        if (!run.getTextSpan().getText().equals(text) && x > run.getWidth() && run.getStart() < curRunStart) {\n+                            x -= run.getWidth();\n@@ -477,3 +528,7 @@\n-                        if (x > r.getWidth()) {\n-                            x -= r.getWidth();\n-                            relIndex += r.getLength();\n+                    }\n+                } else {\n+                    boolean isPrevRunPresent = false;\n+                    int prevRunLength = 0;\n+                    for (TextRun r: runs) {\n+                        if (!r.getTextSpan().getText().equals(text) || (r.getStart() < textRunStart && r.getTextSpan().getText().equals(text))) {\n+                            prevRunLength += r.getWidth();\n@@ -482,2 +537,15 @@\n-                        run = r;\n-                        break;\n+                        if (r.getTextSpan() != null && r.getTextSpan().getText().equals(text)) {\n+                            BaseBounds textBounds = new BoxBounds();\n+                            getBounds(r.getTextSpan(), textBounds);\n+                            if (textBounds.getMinX() == 0 && !isPrevRunPresent) {\n+                                x -= prevRunLength;\n+                                isPrevRunPresent = true;\n+                            }\n+                            if (x > r.getWidth()) {\n+                                x -= r.getWidth();\n+                                relIndex += r.getLength();\n+                                continue;\n+                            }\n+                            run = r;\n+                            break;\n+                        }\n@@ -494,0 +562,3 @@\n+                    if (run.getLevel() % 2 != 0) {\n+                        charIndex += LTRIndex;\n+                    }\n@@ -495,1 +566,7 @@\n-                    charIndex = run.getStart() + run.getOffsetAtX(x, trailing);\n+                    int indexOffset;\n+                    if (isMirrored) {\n+                        indexOffset = run.getOffsetAtX(xHitPos, trailing);\n+                    } else {\n+                        indexOffset = run.getOffsetAtX(x, trailing);\n+                    }\n+                    charIndex = run.getStart() + indexOffset;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/PrismTextLayout.java","additions":104,"deletions":27,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -1027,10 +1027,2 @@\n-        int runIndex = 0;\n-        if (runs.length != 0) {\n-            double ptY = localToParent(x, y).getY();\n-            while (runIndex < runs.length - 1) {\n-                if (ptY > runs[runIndex].getLocation().y && ptY < runs[runIndex + 1].getLocation().y) {\n-                    break;\n-                }\n-                runIndex++;\n-            }\n-        }\n+        int runIndex = findRunIndex(x, y, runs);\n+\n@@ -1047,0 +1039,43 @@\n+    private int findRunIndex(double x, double y, GlyphList[] runs) {\n+        int runIndex = 0;\n+        if (runs.length != 0) {\n+            if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {\n+                double yPos = y;\n+                if (runs[runIndex].getTextSpan() == null) {\n+                    while (runIndex < runs.length - 1) {\n+                        if (x > runs[runIndex].getLocation().x && x < runs[runIndex + 1].getLocation().x\n+                                && y > runs[runIndex].getLocation().y && y < runs[runIndex].getHeight()) {\n+                            break;\n+                        }\n+                        runIndex++;\n+                        if (y > runs[runIndex].getHeight() && (runs[runIndex].getLocation().y != runs[runIndex - 1].getLocation().y)) {\n+                            y -= runs[runIndex].getHeight();\n+                        }\n+                    }\n+                } else {\n+                    double ptX = localToParent(x, y).getX();\n+                    double ptY = localToParent(x, y).getY();\n+                    while (runIndex < runs.length - 1) {\n+                        if (ptX > runs[runIndex].getLocation().x && ptX < (runs[runIndex].getLocation().x + runs[runIndex].getWidth()) && ptY >= runs[runIndex].getLocation().y\n+                                && y < runs[runIndex].getHeight()) {\n+                            break;\n+                        }\n+                        runIndex++;\n+                        if (y > runs[runIndex].getHeight() && (runs[runIndex].getLocation().y != runs[runIndex - 1].getLocation().y)) {\n+                            y -= runs[runIndex].getHeight();\n+                        }\n+                    }\n+                }\n+            } else {\n+                double ptY = localToParent(x, y).getY();\n+                while (runIndex < runs.length - 1) {\n+                    if (ptY > runs[runIndex].getLocation().y && ptY < runs[runIndex + 1].getLocation().y) {\n+                        break;\n+                    }\n+                    runIndex++;\n+                }\n+            }\n+        }\n+        return runIndex;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/Text.java","additions":45,"deletions":10,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-            TextLayout.Hit h = layout.getHitInfo((float)x, (float)y, null, 0, 0);\n+            TextLayout.Hit h = layout.getHitInfo((float)x, (float)y, null, -1, -1);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/TextFlow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,383 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.robot.javafx.scene;\n+\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.geometry.NodeOrientation;\n+import javafx.geometry.Point2D;\n+import javafx.geometry.Point3D;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.input.PickResult;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.robot.Robot;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.HitInfo;\n+import javafx.scene.text.Text;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.stage.Window;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import test.util.Util;\n+\n+\/*\n+ * Test for verifying character index of Text nodes in RTL orientation.\n+ *\n+ * There are 6 tests in this file.\n+ * Here, the scene node orientation is set to RTL for all the tests.\n+ * Steps for testTextInfoForRTLEnglishText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add only english text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change from highest value to lowest\n+ *    as expected.\n+ *\n+ * Steps for testTextInfoForRTLArabicText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add only arabic text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should increment as expected since it is RTL text.\n+ *\n+ * Steps for testTextInfoForRTLEnglishArabicText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add both english and arabic text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change in decreasing order for english text\n+ *    and in increasing order for arabic text.\n+ *\n+ * Steps for testTextInfoForMultiLineRTLEnglishText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add two lines of only english text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change in decreasing order as expected.\n+ *\n+ * Steps for testTextInfoForMultiLineRTLEnglishArabicText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add two lines of both english and arabic text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change in decreasing order for english text\n+ *    and increasing order for arabic text.\n+ *\n+ * Steps for testTextInfoForMultiLineRTLArabicText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add two lines of only arabic text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change in increasing order as expected.\n+ *\/\n+\n+public class RTLTextCharacterIndexTest {\n+    static CountDownLatch startupLatch = new CountDownLatch(1);\n+    static Random random;\n+    static Robot robot;\n+    static Text textOne;\n+    static VBox vBox;\n+\n+    static volatile Stage stage;\n+    static volatile Scene scene;\n+\n+    static final int WIDTH = 500;\n+    static final int HEIGHT = 200;\n+\n+    final int Y_OFFSET = 30;\n+    final int X_LEADING_OFFSET = 10;\n+\n+    boolean isLeading;\n+    boolean textFlowIsLeading;\n+    int charIndex;\n+    int insertionIndex;\n+    int textFlowCharIndex;\n+    int textFlowInsertionIndex;\n+\n+    private void mouseClick(double x, double y) {\n+        Util.runAndWait(() -> {\n+            Window w = scene.getWindow();\n+            robot.mouseMove(w.getX() + scene.getX() + x,\n+                    w.getY() + scene.getY() + y);\n+            robot.mouseClick(MouseButton.PRIMARY);\n+        });\n+    }\n+\n+    private void moveMouseOverText(double x, double y) throws Exception {\n+        mouseClick(textOne.getLayoutX() + x,\n+                    textOne.getLayoutY() \/ 2 + y);\n+    }\n+\n+    private void addRTLEnglishText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"This is text\");\n+            textOne.setFont(new Font(48));\n+            vBox.getChildren().setAll(textOne);\n+        });\n+    }\n+\n+    private void addRTLArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"شسيبلاتنم\");\n+            textOne.setFont(new Font(48));\n+            vBox.getChildren().setAll(textOne);\n+        });\n+    }\n+\n+    private void addRTLEnglishArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"Arabic:شسيبلاتنم\");\n+            textOne.setFont(new Font(48));\n+            vBox.getChildren().setAll(textOne);\n+        });\n+    }\n+\n+    private void addMultiLineRTLEnglishText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"This is text\\nThis is text\");\n+            textOne.setFont(new Font(48));\n+            vBox.getChildren().setAll(textOne);\n+        });\n+    }\n+\n+    private void addMultiLineRTLEnglishArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"Arabic:شسيبلاتنم\\nArabic:شسيبلاتنم\");\n+            textOne.setFont(new Font(48));\n+            vBox.getChildren().setAll(textOne);\n+        });\n+    }\n+\n+    private void addMultiLineRTLArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"شسيبلاتنم شسيبلاتنم\\nشسيبلاتنم شسيبلاتنم\");\n+            textOne.setFont(new Font(48));\n+            vBox.getChildren().setAll(textOne);\n+        });\n+    }\n+\n+    @Test\n+    public void testTextInfoForRTLEnglishText() throws Exception {\n+        addRTLEnglishText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverText(x, 0);\n+            if (isLeading) {\n+                Assertions.assertEquals(charIndex, insertionIndex);\n+            } else {\n+                Assertions.assertEquals(charIndex, insertionIndex - 1);\n+            }\n+            Assertions.assertTrue(charIndex < textOneLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForRTLArabicText() throws Exception {\n+        addRTLArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverText(x, 0);\n+            if (isLeading) {\n+                Assertions.assertEquals(charIndex, insertionIndex);\n+            } else {\n+                Assertions.assertEquals(charIndex, insertionIndex - 1);\n+            }\n+            Assertions.assertTrue(charIndex < textOneLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForRTLEnglishArabicText() throws Exception {\n+        addRTLEnglishArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverText(x, 0);\n+            if (isLeading) {\n+                Assertions.assertEquals(charIndex, insertionIndex);\n+            } else {\n+                Assertions.assertEquals(charIndex, insertionIndex - 1);\n+            }\n+            Assertions.assertTrue(charIndex < textOneLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForMultiLineRTLEnglishText() throws Exception {\n+        addMultiLineRTLEnglishText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverText(x, (Y_OFFSET * (y * 2)));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < textOneLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForMultiLineRTLEnglishArabicText() throws Exception {\n+        addMultiLineRTLEnglishArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverText(x, (Y_OFFSET * (y * 2)));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < textOneLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForMultiLineRTLArabicText() throws Exception {\n+        addMultiLineRTLArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverText(x, (Y_OFFSET * (y * 2)));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < textOneLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    private void handleTextMouseEvent(MouseEvent event) {\n+        PickResult pick = event.getPickResult();\n+        Node n = pick.getIntersectedNode();\n+\n+        if (n != null && n instanceof Text t) {\n+            Point3D p3 = pick.getIntersectedPoint();\n+            Point2D p = new Point2D(p3.getX(), p3.getY());\n+            HitInfo hitInfo = t.hitTest(p);\n+\n+            isLeading = hitInfo.isLeading();\n+            charIndex = hitInfo.getCharIndex();\n+            insertionIndex = hitInfo.getInsertionIndex();\n+        }\n+    }\n+\n+    private double step() {\n+        return 1.0 + random.nextDouble() * 8.0;\n+    }\n+\n+    @AfterEach\n+    public void resetUI() {\n+        Platform.runLater(() -> {\n+            textOne.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleTextMouseEvent);\n+        });\n+    }\n+\n+    @BeforeEach\n+    public void setupUI() {\n+        Platform.runLater(() -> {\n+            textOne.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleTextMouseEvent);\n+        });\n+    }\n+\n+    @BeforeAll\n+    public static void initFX() {\n+        long seed = new Random().nextLong();\n+        System.out.println(\"seed=\" + seed);\n+        random = new Random(seed);\n+\n+        Util.launch(startupLatch, TestApp.class);\n+    }\n+\n+    @AfterAll\n+    public static void exit() {\n+        Util.shutdown(stage);\n+    }\n+\n+    public static class TestApp extends Application {\n+        @Override\n+        public void start(Stage primaryStage) {\n+            robot = new Robot();\n+            stage = primaryStage;\n+\n+            textOne = new Text();\n+            vBox = new VBox();\n+\n+            scene = new Scene(vBox, WIDTH, HEIGHT);\n+            scene.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+            stage.setScene(scene);\n+            stage.initStyle(StageStyle.UNDECORATED);\n+            stage.setOnShown(event -> Platform.runLater(startupLatch::countDown));\n+            stage.setAlwaysOnTop(true);\n+            stage.show();\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/RTLTextCharacterIndexTest.java","additions":383,"deletions":0,"binary":false,"changes":383,"status":"added"},{"patch":"@@ -0,0 +1,460 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.robot.javafx.scene;\n+\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.geometry.NodeOrientation;\n+import javafx.geometry.Point2D;\n+import javafx.geometry.Point3D;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.input.PickResult;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.robot.Robot;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.HitInfo;\n+import javafx.scene.text.Text;\n+import javafx.scene.text.TextFlow;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.stage.Window;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import test.util.Util;\n+\n+\/*\n+ * Test for verifying character index of Text nodes embedded in TextFlow in RTL orientation.\n+ *\n+ * There are 5 tests in this file.\n+ * Here, the scene node orientation is set to RTL for all the tests.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLArabicText()\n+ * 1. Create a TextFlow. Add a Text nodes with only arabic text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in ascending order as expected.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLEnglishText()\n+ * 1. Create a TextFlow. Add a Text nodes with only english text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in descending order as expected.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLMultipleTextNodes()\n+ * 1. Create a TextFlow. Add two Text nodes with english and arabic text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in decreasing order for english text\n+ *    and in increasing order for arabic text.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLMultipleMultiLineEnglishArabicTextNodes()\n+ * 1. Create a TextFlow. Add three Text nodes with english and arabic text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in decreasing order for english text\n+ *    and in increasing order for arabic text.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLMultipleMultiLineEnglishTextNodes()\n+ * 1. Create a TextFlow. Add three Text nodes with only english text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in decreasing order for english text.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLMultipleMultiLineArabicTextNodes()\n+ * 1. Create a TextFlow. Add three Text nodes with only arabic text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in increasing order for arabic text.\n+ *\n+ *\/\n+\n+public class RTLTextFlowCharacterIndexTest {\n+    static CountDownLatch startupLatch = new CountDownLatch(1);\n+    static Random random;\n+    static Robot robot;\n+    static TextFlow textFlow;\n+    static Text textOne;\n+    static Text textTwo;\n+    static Text textThree;\n+    static VBox vBox;\n+\n+    static volatile Stage stage;\n+    static volatile Scene scene;\n+\n+    static final int WIDTH = 500;\n+    static final int HEIGHT = 200;\n+\n+    final int Y_OFFSET = 30;\n+    final int X_LEADING_OFFSET = 10;\n+\n+    boolean isLeading;\n+    boolean textFlowIsLeading;\n+    int charIndex;\n+    int insertionIndex;\n+    int textFlowCharIndex;\n+    int textFlowInsertionIndex;\n+\n+    private void mouseClick(double x, double y) {\n+        Util.runAndWait(() -> {\n+            Window w = scene.getWindow();\n+            robot.mouseMove(w.getX() + scene.getX() + x,\n+                    w.getY() + scene.getY() + y);\n+            robot.mouseClick(MouseButton.PRIMARY);\n+        });\n+    }\n+\n+    private void moveMouseOverTextFlow(double x, double y) throws Exception {\n+        mouseClick(textFlow.getLayoutX() + x,\n+                    textFlow.getLayoutY() + y);\n+    }\n+\n+    private void addRTLArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"شسيبلاتنم\");\n+            textOne.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addRTLEnglishText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"This is text\");\n+            textOne.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addMultiNodeRTLEnglishArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"Arabic:\");\n+            textOne.setFont(new Font(48));\n+            textTwo.setText(\"شسيبلاتنم\");\n+            textTwo.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addMultiLineMultiNodeRTLEnglishArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"Arabic:\");\n+            textOne.setFont(new Font(48));\n+            textTwo.setText(\"شسيبلاتنضصثقفغ\");\n+            textTwo.setFont(new Font(48));\n+            textThree.setText(\"حخهعغقثصضشسيبل\");\n+            textThree.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo, textThree);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addMutliLineMultiNodeRTLEnglishText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"First line of text\");\n+            textOne.setFont(new Font(48));\n+            textTwo.setText(\"Second line of text\");\n+            textTwo.setFont(new Font(48));\n+            textThree.setText(\"Third line of text\");\n+            textThree.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo, textThree);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addMutliLineMultiNodeRTLArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"شسيبلا تنضصثقفغ\");\n+            textOne.setFont(new Font(48));\n+            textTwo.setText(\"حخهعغقث صضشسيبل\");\n+            textTwo.setFont(new Font(48));\n+            textThree.setText(\"ضصثقف\");\n+            textThree.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo, textThree);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLArabicText() throws Exception {\n+        addRTLArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverTextFlow(x, Y_OFFSET);\n+            if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+            Assertions.assertTrue(charIndex < textOneLength);\n+            Assertions.assertTrue(textFlowCharIndex < textOneLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLEnglishText() throws Exception {\n+        addRTLEnglishText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverTextFlow(x, Y_OFFSET);\n+            if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+            Assertions.assertTrue(charIndex < textOneLength);\n+            Assertions.assertTrue(textFlowCharIndex < textOneLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLMultipleTextNodes() throws Exception {\n+        addMultiNodeRTLEnglishArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverTextFlow(x, Y_OFFSET);\n+           if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+            Assertions.assertTrue(charIndex < Math.max(textOneLength, textTwoLength));\n+            Assertions.assertTrue(textFlowCharIndex < textOneLength + textTwoLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLMultipleMultiLineEnglishArabicTextNodes() throws Exception {\n+        addMultiLineMultiNodeRTLEnglishArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+        int textThreeLength = textThree.getText().length();\n+\n+        for (int y = 0; y < 3; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < Math.max(textThreeLength, Math.max(textOneLength, textTwoLength)));\n+                Assertions.assertTrue(textFlowCharIndex < textOneLength + textTwoLength + textThreeLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLMultipleMultiLineEnglishTextNodes() throws Exception {\n+        addMutliLineMultiNodeRTLEnglishText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+        int textThreeLength = textThree.getText().length();\n+\n+        for (int y = 0; y < 3; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < Math.max(textThreeLength, Math.max(textOneLength, textTwoLength)));\n+                Assertions.assertTrue(textFlowCharIndex < textOneLength + textTwoLength + textThreeLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLMultipleMultiLineArabicTextNodes() throws Exception {\n+        addMutliLineMultiNodeRTLArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+        int textThreeLength = textThree.getText().length();\n+\n+        for (int y = 0; y < 3; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < Math.max(textThreeLength, Math.max(textOneLength, textTwoLength)));\n+                Assertions.assertTrue(textFlowCharIndex < textOneLength + textTwoLength + textThreeLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    private void handleMouseEvent(MouseEvent event) {\n+        PickResult pick = event.getPickResult();\n+        Node n = pick.getIntersectedNode();\n+\n+        if (n != null && n instanceof Text t) {\n+            Point3D p3 = pick.getIntersectedPoint();\n+            Point2D p = new Point2D(p3.getX(), p3.getY());\n+            HitInfo hitInfo = t.hitTest(p);\n+\n+            isLeading = hitInfo.isLeading();\n+            charIndex = hitInfo.getCharIndex();\n+            insertionIndex = hitInfo.getInsertionIndex();\n+        }\n+\n+        Point2D point = new Point2D(event.getX(), event.getY());\n+        HitInfo textFlowHitInfo = textFlow.hitTest(point);\n+        textFlowIsLeading = textFlowHitInfo.isLeading();\n+        textFlowCharIndex = textFlowHitInfo.getCharIndex();\n+        textFlowInsertionIndex = textFlowHitInfo.getInsertionIndex();\n+    }\n+\n+    private double step() {\n+        return 1.0 + random.nextDouble() * 8.0;\n+    }\n+\n+    @AfterEach\n+    public void resetUI() {\n+        Platform.runLater(() -> {\n+            textFlow.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textOne.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textTwo.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textThree.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+        });\n+    }\n+\n+    @BeforeEach\n+    public void setupUI() {\n+        Platform.runLater(() -> {\n+            textFlow.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textOne.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textTwo.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textThree.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+        });\n+    }\n+\n+    @BeforeAll\n+    public static void initFX() {\n+        long seed = new Random().nextLong();\n+        System.out.println(\"seed=\" + seed);\n+        random = new Random(seed);\n+\n+        Util.launch(startupLatch, TestApp.class);\n+    }\n+\n+    @AfterAll\n+    public static void exit() {\n+        Util.shutdown(stage);\n+    }\n+\n+    public static class TestApp extends Application {\n+        @Override\n+        public void start(Stage primaryStage) {\n+            robot = new Robot();\n+            stage = primaryStage;\n+\n+            textOne = new Text();\n+            textTwo = new Text();\n+            textThree = new Text();\n+            textFlow = new TextFlow();\n+            vBox = new VBox();\n+\n+            scene = new Scene(vBox, WIDTH, HEIGHT);\n+            scene.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+            stage.setScene(scene);\n+            stage.initStyle(StageStyle.UNDECORATED);\n+            stage.setOnShown(event -> Platform.runLater(startupLatch::countDown));\n+            stage.setAlwaysOnTop(true);\n+            stage.show();\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/RTLTextFlowCharacterIndexTest.java","additions":460,"deletions":0,"binary":false,"changes":460,"status":"added"}]}