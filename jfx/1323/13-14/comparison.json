{"files":[{"patch":"@@ -215,1 +215,1 @@\n-    public Hit getHitInfo(float x, float y, String text, int textRunStart, int curRunStart);\n+    public Hit getHitInfo(float x, float y);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/text\/TextLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -424,4 +424,1 @@\n-    public Hit getHitInfo(float x, float y, String text, int textRunStart, int curRunStart) {\n-        boolean leading = false;\n-        boolean isMirrored = isMirrored(); \/\/ Node orientation is RTL\n-        boolean forTextFlow = spans != null && text == null;\n+    public Hit getHitInfo(float x, float y) {\n@@ -430,4 +427,1 @@\n-        int relIndex = 0;\n-        int ltrIndex = 0;\n-        int textWidthPrevLine = 0;\n-        float xHitPos = x;\n+        boolean leading = false;\n@@ -436,1 +430,1 @@\n-        int lineIndex = getLineIndex(y, forTextFlow, curRunStart);\n+        int lineIndex = getLineIndex(y);\n@@ -440,45 +434,0 @@\n-            return new Hit(charIndex, insertionIndex, leading);\n-        }\n-\n-        TextLine line = lines[lineIndex];\n-        TextRun[] runs = line.getRuns();\n-        RectBounds bounds = line.getBounds();\n-        TextRun run = null;\n-        \/\/TODO binary search\n-        if (forTextFlow || spans == null) {\n-            \/* This code branch is used to calculate hit info of Text node\n-             * which are not embedded in TextFlow and hit info requested on TextFlow. *\/\n-            if (isMirrored) {\n-                x = getMirroringWidth() - x;\n-                int runIndex = -1;\n-                for (int i = runs.length - 1; i >= 0; i--) {\n-                    run = runs[i];\n-                    if (x < run.getWidth() && (forTextFlow || (run.getStart() == curRunStart))) {\n-                        runIndex = i;\n-                        break;\n-                    }\n-                    if (i > 0) {\n-                        if (runs[i - 1].isLinebreak()) {\n-                            break;\n-                        }\n-                        x -= run.getWidth();\n-                    }\n-                }\n-                for (int i = 0; i < runIndex; i++) {\n-                    xHitPos -= runs[i].getWidth();\n-                }\n-                xHitPos -= bounds.getMinX();\n-            } else {\n-                for (int i = 0; i < runs.length; i++) {\n-                    run = runs[i];\n-                    if (x < run.getWidth()) {\n-                        break;\n-                    }\n-                    if (i + 1 < runs.length) {\n-                        if (runs[i + 1].isLinebreak()) {\n-                            break;\n-                        }\n-                        x -= run.getWidth();\n-                    }\n-                }\n-            }\n@@ -486,62 +435,12 @@\n-            \/\/ This code branch is used to calculate hit info of Text node embedded in TextFlow.\n-            textWidthPrevLine = getPrevLineWidth(text, lineIndex, textRunStart);\n-\n-            BaseBounds textBounds = new BoxBounds();\n-            if (isMirrored) {\n-                int runIdx = 0;\n-                for (TextRun r: runs) {\n-                    if (r.getStart() == curRunStart) {\n-                        run = r;\n-                        break;\n-                    }\n-                    runIdx++;\n-                }\n-\n-                boolean textFound = false;\n-                for (int i = 0; i <= runIdx; i++) {\n-                    TextRun r = runs[i];\n-                    int textWidth = run.getStart() + run.getTextSpan().getText().length();\n-                    if (r.getStart() != curRunStart && x > r.getWidth() && textWidthPrevLine == 0\n-                            && r.getStart() < textWidth && r.getTextSpan().getText().equals(text)) {\n-                        x -= r.getWidth();\n-                        textFound = true;\n-                        continue;\n-                    }\n-                    if (r.getTextSpan() != null && r.getStart() == curRunStart\n-                            && r.getTextSpan().getText().equals(text)) {\n-                        if (x > r.getWidth() || textWidthPrevLine > 0) {\n-                            getBounds(r.getTextSpan(), textBounds);\n-                            x -= (run.getLocation().x - textBounds.getMinX());\n-                        }\n-                        break;\n-                    }\n-                        \/* This condition handles LTR Text nodes present between\n-                           a Text node containing both LTR and RTL text. *\/\n-                    if (textFound && x > r.getWidth() && r.getStart() < curRunStart\n-                            && !r.getTextSpan().getText().equals(text)) {\n-                        x -= r.getWidth();\n-                    }\n-                }\n-                ltrIndex = getLtrTextWidthInRtlText(runs, text, curRunStart, runIdx);\n-            } else {\n-                boolean isPrevRunPresent = false;\n-                int prevRunLength = 0;\n-                for (TextRun r: runs) {\n-                    if (!r.getTextSpan().getText().equals(text) || (r.getStart() < textRunStart && r.getTextSpan().getText().equals(text))) {\n-                        prevRunLength += r.getWidth();\n-                        continue;\n-                    }\n-                    if (r.getTextSpan() != null && r.getTextSpan().getText().equals(text)) {\n-                        getBounds(r.getTextSpan(), textBounds);\n-                        if (textBounds.getMinX() == 0 && !isPrevRunPresent) {\n-                            x -= prevRunLength;\n-                            isPrevRunPresent = true;\n-                        }\n-                        if (x > r.getWidth()) {\n-                            x -= r.getWidth();\n-                            relIndex += r.getLength();\n-                            continue;\n-                        }\n-                        run = r;\n-                        break;\n-                    }\n+            TextLine line = lines[lineIndex];\n+            TextRun[] runs = line.getRuns();\n+            RectBounds bounds = line.getBounds();\n+            TextRun run = null;\n+            x -= bounds.getMinX();\n+            \/\/TODO binary search\n+            for (int i = 0; i < runs.length; i++) {\n+                run = runs[i];\n+                if (x < run.getWidth()) break;\n+                if (i + 1 < runs.length) {\n+                    if (runs[i + 1].isLinebreak()) break;\n+                    x -= run.getWidth();\n@@ -550,27 +449,9 @@\n-        }\n-\n-        if (run != null) {\n-            int[] trailing = new int[1];\n-            if (forTextFlow || spans == null) {\n-                int indexOffset;\n-                if (isMirrored) {\n-                    indexOffset = run.getOffsetAtX(xHitPos, trailing);\n-                } else {\n-                    indexOffset = run.getOffsetAtX(x, trailing);\n-                }\n-                charIndex = run.getStart() + indexOffset;\n-            } else {\n-                charIndex = run.getOffsetAtX(x, trailing);\n-                charIndex += textWidthPrevLine;\n-                charIndex += relIndex;\n-                \/*  When RTL text has LTR text embedded,\n-                 *  add the LTR index here to get effective character index *\/\n-                charIndex += ltrIndex;\n-            }\n-            leading = (trailing[0] == 0);\n-\n-            insertionIndex = charIndex;\n-            if (insertionIndex < getText().length) {\n-                if (!leading) {\n-                    BreakIterator charIterator = BreakIterator.getCharacterInstance();\n-                    if (forTextFlow) {\n+            if (run != null) {\n+                int[] trailing = new int[1];\n+                charIndex = run.getStart() + run.getOffsetAtX(x, trailing);\n+                leading = (trailing[0] == 0);\n+\n+                insertionIndex = charIndex;\n+                if (getText() != null && insertionIndex < getText().length) {\n+                    if (!leading) {\n+                        BreakIterator charIterator = BreakIterator.getCharacterInstance();\n@@ -578,8 +459,6 @@\n-                    } else {\n-                        charIterator.setText(text);\n-                    }\n-                    int next = charIterator.following(insertionIndex);\n-                    if (next == BreakIterator.DONE) {\n-                        insertionIndex += 1;\n-                    } else {\n-                        insertionIndex = next;\n+                        int next = charIterator.following(insertionIndex);\n+                        if (next == BreakIterator.DONE) {\n+                            insertionIndex += 1;\n+                        } else {\n+                            insertionIndex = next;\n+                        }\n@@ -587,0 +466,2 @@\n+                } else if (!leading) {\n+                    insertionIndex += 1;\n@@ -588,2 +469,5 @@\n-            } else if (!leading) {\n-                insertionIndex += 1;\n+            } else {\n+                \/\/empty line, set to line break leading\n+                charIndex = line.getStart();\n+                leading = true;\n+                insertionIndex = charIndex;\n@@ -591,5 +475,0 @@\n-        } else {\n-            \/\/empty line, set to line break leading\n-            charIndex = line.getStart();\n-            leading = true;\n-            insertionIndex = charIndex;\n@@ -600,28 +479,0 @@\n-    private int getLtrTextWidthInRtlText(TextRun[] runs, String text, int curRunStart, int runIdx) {\n-        TextRun run = runs[runIdx];\n-        int ltrTextWidth = 0;\n-        for (int i = runs.length - 1; i > runIdx; i--) {\n-            TextRun r = runs[i];\n-            boolean addLtrIdx = run.getTextSpan().getText().length() != run.length\n-                                    && (r.length + ltrTextWidth) < run.getTextSpan().getText().length();\n-            if (r.getStart() != curRunStart && !r.isLinebreak() && addLtrIdx\n-                    && r.getTextSpan().getText().equals(text)) {\n-                ltrTextWidth += r.getLength();\n-            }\n-        }\n-        return ltrTextWidth;\n-    }\n-\n-    private int getPrevLineWidth(String text, int lineIndex, int textRunStart) {\n-        int prevLineWidth = 0;\n-        for (int i = 0; i < lineIndex; i++) {\n-            for (TextRun r: lines[i].getRuns()) {\n-                if (r.getTextSpan() != null && r.getStart() >= textRunStart\n-                        && r.getTextSpan().getText().equals(text)) {\n-                    prevLineWidth += r.getLength();\n-                }\n-            }\n-        }\n-        return prevLineWidth;\n-    }\n-\n@@ -852,1 +703,1 @@\n-    private int getLineIndex(float y, boolean forTextFlow, int runStart) {\n+    private int getLineIndex(float y) {\n@@ -855,3 +706,0 @@\n-        \/* Initializing textFound as true when this function is called for\n-         * TextFlow or Text node which is not embedded in TextFlow *\/\n-        boolean textFound = (forTextFlow || spans == null);\n@@ -861,8 +709,0 @@\n-            if (!textFound) {\n-                for (TextRun r : lines[index].getRuns()) {\n-                    if (r.getStart() == runStart) {\n-                        textFound = true;\n-                        break;\n-                    }\n-                }\n-            }\n@@ -870,6 +710,2 @@\n-            if (index + 1 == lineCount) {\n-                bottom -= lines[index].getLeading();\n-            }\n-            if (bottom > y && textFound) {\n-                break;\n-            }\n+            if (index + 1 == lineCount) bottom -= lines[index].getLeading();\n+            if (bottom > y) break;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/PrismTextLayout.java","additions":40,"deletions":204,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -1024,0 +1024,1 @@\n+\n@@ -1027,2 +1028,0 @@\n-        int runIndex = findRunIndex(x, y, runs);\n-\n@@ -1030,1 +1029,0 @@\n-        int curRunStart = 0;\n@@ -1032,2 +1030,10 @@\n-            textRunStart = findFirstRunStart(x, y, runs);\n-            curRunStart = ((TextRun) runs[runIndex]).getStart();\n+            textRunStart = findFirstRunStart(runs);\n+        }\n+\n+        double px = x;\n+        double py = y;\n+\n+        if(isSpan()) {\n+            Point2D pPoint = localToParent(point);\n+            px = pPoint.getX();\n+            py = pPoint.getY();\n@@ -1035,2 +1041,2 @@\n-        TextLayout.Hit h = layout.getHitInfo((float)x, (float)y, getTextInternal(), textRunStart, curRunStart);\n-        return new HitInfo(h.getCharIndex(), h.getInsertionIndex(), h.isLeading());\n+        TextLayout.Hit h = layout.getHitInfo((float)px, (float)py);\n+        return new HitInfo(h.getCharIndex() - textRunStart, h.getInsertionIndex() - textRunStart, h.isLeading());\n@@ -1039,1 +1045,1 @@\n-    private int findFirstRunStart(double x, double y, GlyphList[] runs) {\n+    private int findFirstRunStart(GlyphList[] runs) {\n@@ -1049,55 +1055,0 @@\n-    private int findRunIndex(double x, double y, GlyphList[] runs) {\n-        int runIdx = 0;\n-        int lastIndex = runs.length - 1;\n-\n-        if (runs.length == 0) {\n-            return runIdx;\n-        }\n-\n-        if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {\n-            if (runs[runIdx].getTextSpan() == null) {\n-                while (runIdx < lastIndex) {\n-                    GlyphList run = runs[runIdx];\n-                    GlyphList nextRun = runs[runIdx + 1];\n-                    if ((x > run.getLocation().x &&\n-                            (x < nextRun.getLocation().x || run.getLocation().y < nextRun.getLocation().y))\n-                                && y < run.getHeight()) {\n-                        break;\n-                    }\n-                    runIdx++;\n-                    y = updateY(y, runIdx, runs);\n-                }\n-            } else {\n-                Point2D ptInParent = localToParent(x, y);\n-                double ptX = ptInParent.getX();\n-                double ptY = ptInParent.getY();\n-                while (runIdx < lastIndex) {\n-                    GlyphList run = runs[runIdx];\n-                    if (ptX > run.getLocation().x && ptX < (run.getLocation().x + run.getWidth()) && ptY >= run.getLocation().y\n-                            && y < run.getHeight()) {\n-                        break;\n-                    }\n-                    runIdx++;\n-                    y = updateY(y, runIdx, runs);\n-                }\n-            }\n-        } else {\n-            double ptY = localToParent(x, y).getY();\n-            while (runIdx < lastIndex) {\n-                if (ptY > runs[runIdx].getLocation().y && ptY < runs[runIdx + 1].getLocation().y) {\n-                    break;\n-                }\n-                runIdx++;\n-            }\n-        }\n-        return runIdx;\n-    }\n-\n-    private double updateY(double y, int ix, GlyphList[] runs) {\n-        GlyphList curRun = runs[ix];\n-        if (y > curRun.getHeight() && (curRun.getLocation().y != runs[ix - 1].getLocation().y)) {\n-            y -= curRun.getHeight();\n-        }\n-        return y;\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/Text.java","additions":14,"deletions":63,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-            TextLayout.Hit h = layout.getHitInfo((float)x, (float)y, null, 0, 0);\n+            TextLayout.Hit h = layout.getHitInfo((float)x, (float)y);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/TextFlow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-    public Hit getHitInfo(float x, float y, String text, int textRunStart, int curRunStart) {\n+    public Hit getHitInfo(float x, float y) {\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/pgstub\/StubTextLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}