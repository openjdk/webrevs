{"files":[{"patch":"@@ -32,0 +32,2 @@\n+import java.util.Objects;\n+\n@@ -94,0 +96,22 @@\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(charIndex, insertionIndex, leading);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Hit other = (Hit) obj;\n+            return charIndex == other.charIndex && insertionIndex == other.insertionIndex && leading == other.leading;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Hit[charIndex=\" + charIndex + \", insertionIndex=\" + insertionIndex + \", leading=\" + leading + \"]\";\n+        }\n@@ -208,5 +232,0 @@\n-     * @param text text for which HitInfo needs to be calculated.\n-     *             It is expected to be null in the case of {@link javafx.scene.text.TextFlow}\n-     *             and non-null in the case of {@link javafx.scene.text.Text}\n-     * @param textRunStart Text run start position.\n-     * @param curRunStart starting position of text run where hit info is requested.\n@@ -215,1 +234,1 @@\n-    public Hit getHitInfo(float x, float y, String text, int textRunStart, int curRunStart);\n+    public Hit getHitInfo(float x, float y);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/text\/TextLayout.java","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -424,1 +424,1 @@\n-    public Hit getHitInfo(float x, float y, String text, int textRunStart, int curRunStart) {\n+    public Hit getHitInfo(float x, float y) {\n@@ -428,2 +428,0 @@\n-        int relIndex = 0;\n-        int textWidthPrevLine = 0;\n@@ -432,1 +430,1 @@\n-        int lineIndex = getLineIndex(y, text, curRunStart);\n+        int lineIndex = getLineIndex(y);\n@@ -437,3 +435,0 @@\n-            if (isMirrored()) {\n-                x = getMirroringWidth() - x;\n-            }\n@@ -445,17 +440,4 @@\n-            \/\/TODO binary search\n-            if (text == null || spans == null) {\n-                for (int i = 0; i < runs.length; i++) {\n-                    run = runs[i];\n-                    if (x < run.getWidth()) break;\n-                    if (i + 1 < runs.length) {\n-                        if (runs[i + 1].isLinebreak()) break;\n-                        x -= run.getWidth();\n-                    }\n-                }\n-            } else {\n-                for (int i = 0; i < lineIndex; i++) {\n-                    for (TextRun r: lines[i].runs) {\n-                        if (r.getTextSpan() != null && r.getStart() >= textRunStart && r.getTextSpan().getText().equals(text)) {\n-                            textWidthPrevLine += r.getLength();\n-                        }\n-                    }\n+            for (int i = 0; i < runs.length; i++) {\n+                run = runs[i];\n+                if (x < run.getWidth()) {\n+                    break;\n@@ -463,20 +445,2 @@\n-                int prevNodeLength = 0;\n-                boolean isPrevNodeExcluded = false;\n-                for (TextRun r: runs) {\n-                    if (!r.getTextSpan().getText().equals(text) || (r.getStart() < textRunStart && r.getTextSpan().getText().equals(text))) {\n-                        prevNodeLength += r.getWidth();\n-                        continue;\n-                    }\n-                    if (r.getTextSpan() != null && r.getTextSpan().getText().equals(text)) {\n-                        BaseBounds textBounds = new BoxBounds();\n-                        getBounds(r.getTextSpan(), textBounds);\n-                        if (textBounds.getMinX() == 0 && !isPrevNodeExcluded) {\n-                            x -= prevNodeLength;\n-                            isPrevNodeExcluded = true;\n-                        }\n-                        if (x > r.getWidth()) {\n-                            x -= r.getWidth();\n-                            relIndex += r.getLength();\n-                            continue;\n-                        }\n-                        run = r;\n+                if (i + 1 < runs.length) {\n+                    if (runs[i + 1].isLinebreak()) {\n@@ -485,0 +449,1 @@\n+                    x -= run.getWidth();\n@@ -487,1 +452,0 @@\n-\n@@ -490,7 +454,1 @@\n-                if (text != null && spans != null) {\n-                    charIndex = run.getOffsetAtX(x, trailing);\n-                    charIndex += textWidthPrevLine;\n-                    charIndex += relIndex;\n-                } else {\n-                    charIndex = run.getStart() + run.getOffsetAtX(x, trailing);\n-                }\n+                charIndex = run.getStart() + run.getOffsetAtX(x, trailing);\n@@ -503,5 +461,1 @@\n-                        if (text != null) {\n-                            charIterator.setText(text);\n-                        } else {\n-                            charIterator.setText(new String(getText()));\n-                        }\n+                        charIterator.setText(new String(getText()));\n@@ -752,1 +706,1 @@\n-    private int getLineIndex(float y, String text, int runStart) {\n+    private int getLineIndex(float y) {\n@@ -755,3 +709,0 @@\n-        \/* Initializing textFound as true when text is null\n-         * because when this function is called for TextFlow text parameter will be null *\/\n-        boolean textFound = (text == null);\n@@ -761,10 +712,0 @@\n-            if (!textFound) {\n-                for (TextRun r : lines[index].runs) {\n-                    if (r.getTextSpan() == null || (r.getStart() == runStart && r.getTextSpan().getText().equals(text))) {\n-                        \/* Span will present only for Rich Text.\n-                         * Hence making textFound as true *\/\n-                        textFound = true;\n-                        break;\n-                    }\n-                }\n-            }\n@@ -775,1 +716,1 @@\n-            if (bottom > y && textFound) {\n+            if (bottom > y) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/PrismTextLayout.java","additions":13,"deletions":72,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -1024,0 +1024,1 @@\n+\n@@ -1026,10 +1027,10 @@\n-        GlyphList[] runs = getRuns();\n-        int runIndex = 0;\n-        if (runs.length != 0) {\n-            double ptY = localToParent(x, y).getY();\n-            while (runIndex < runs.length - 1) {\n-                if (ptY > runs[runIndex].getLocation().y && ptY < runs[runIndex + 1].getLocation().y) {\n-                    break;\n-                }\n-                runIndex++;\n-            }\n+\n+        int textRunStart = findFirstRunStart();\n+\n+        double px = x;\n+        double py = y;\n+\n+        if (isSpan()) {\n+            Point2D pPoint = localToParent(point);\n+            px = pPoint.getX();\n+            py = pPoint.getY();\n@@ -1037,5 +1038,11 @@\n-        int textRunStart = 0;\n-        int curRunStart = 0;\n-        if (runs.length != 0) {\n-            textRunStart = ((TextRun) runs[0]).getStart();\n-            curRunStart = ((TextRun) runs[runIndex]).getStart();\n+        TextLayout.Hit h = layout.getHitInfo((float)px, (float)py);\n+        return new HitInfo(h.getCharIndex() - textRunStart, h.getInsertionIndex() - textRunStart, h.isLeading());\n+    }\n+\n+    private int findFirstRunStart() {\n+        int start = Integer.MAX_VALUE;\n+        for (GlyphList r: getRuns()) {\n+            int runStart = ((TextRun) r).getStart();\n+            if (runStart < start) {\n+                start = runStart;\n+            }\n@@ -1043,2 +1050,1 @@\n-        TextLayout.Hit h = layout.getHitInfo((float)x, (float)y, getText(), textRunStart, curRunStart);\n-        return new HitInfo(h.getCharIndex(), h.getInsertionIndex(), h.isLeading());\n+        return start;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/Text.java","additions":23,"deletions":17,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-            TextLayout.Hit h = layout.getHitInfo((float)x, (float)y, null, 0, 0);\n+            TextLayout.Hit h = layout.getHitInfo((float)x, (float)y);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/TextFlow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-    public Hit getHitInfo(float x, float y, String text, int textRunStart, int curRunStart) {\n+    public Hit getHitInfo(float x, float y) {\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/pgstub\/StubTextLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n-\t\t\t<attribute name=\"add-exports\" value=\"javafx.graphics\/com.sun.glass.ui=ALL-UNNAMED:javafx.graphics\/com.sun.glass.ui.monocle=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.sg.prism=ALL-UNNAMED:javafx.graphics\/com.sun.prism.impl=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.image.impl=ALL-UNNAMED:javafx.graphics\/com.sun.glass.events=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.css=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.geom=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.tk=ALL-UNNAMED:javafx.graphics\/com.sun.glass.ui.mac=ALL-UNNAMED\"\/>\n+\t\t\t<attribute name=\"add-exports\" value=\"javafx.graphics\/com.sun.glass.ui=ALL-UNNAMED:javafx.graphics\/com.sun.glass.ui.monocle=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.sg.prism=ALL-UNNAMED:javafx.graphics\/com.sun.prism.impl=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.image.impl=ALL-UNNAMED:javafx.graphics\/com.sun.glass.events=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.css=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.geom=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.tk=ALL-UNNAMED:javafx.graphics\/com.sun.glass.ui.mac=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.scene.text=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.text=ALL-UNNAMED:javafx.graphics\/com.sun.javafx.font=ALL-UNNAMED\"\/>\n","filename":"tests\/system\/src\/test\/.classpath","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+--add-exports javafx.graphics\/com.sun.javafx.scene.text=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.text=ALL-UNNAMED\n","filename":"tests\/system\/src\/test\/addExports","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.text;\n+\n+import static org.junit.Assume.assumeTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.sun.javafx.font.PGFont;\n+import com.sun.javafx.geom.RectBounds;\n+import com.sun.javafx.scene.text.FontHelper;\n+import com.sun.javafx.scene.text.TextLayout.Hit;\n+import com.sun.javafx.scene.text.TextSpan;\n+import com.sun.javafx.text.PrismTextLayout;\n+\n+import javafx.scene.text.Font;\n+\n+public class TextHitInfoTest {\n+    private final PrismTextLayout layout = new PrismTextLayout();\n+    private final PGFont arialFont = (PGFont) FontHelper.getNativeFont(Font.font(\"Arial\", 12));\n+\n+    record TestSpan(String text, Object font) implements TextSpan {\n+        @Override\n+        public String getText() {\n+            return text;\n+        }\n+\n+        @Override\n+        public Object getFont() {\n+            return font;\n+        }\n+\n+        @Override\n+        public RectBounds getBounds() {\n+            return null;\n+        }\n+    }\n+\n+    @Test\n+    void getHitInfoTest() {\n+        assumeArialFontAvailable();\n+\n+        \/*\n+         * Empty line:\n+         *\/\n+\n+        layout.setContent(\"\", arialFont);\n+\n+        \/\/ Checks that hits above the line results in first character:\n+        assertEquals(new Hit(0, 0, true), layout.getHitInfo(0, -30));\n+\n+        \/\/ Checks before start of line:\n+        assertEquals(new Hit(0, 0, true), layout.getHitInfo(-50, 0));\n+\n+        \/\/ Checks position of empty string:\n+        assertEquals(new Hit(0, 0, true), layout.getHitInfo(0, 0));\n+\n+        \/\/ Checks past end of line:\n+        assertEquals(new Hit(0, 0, true), layout.getHitInfo(250, 0));\n+\n+        \/\/ Checks that hits below the line results in last character + 1:\n+        assertEquals(new Hit(0, 1, false), layout.getHitInfo(0, 30));\n+\n+        \/*\n+         * Single line:\n+         *\/\n+\n+        layout.setContent(\"The quick brown fox jumps over the lazy dog\", arialFont);\n+\n+        \/\/ Checks that hits above the line results in first character:\n+        assertEquals(new Hit(0, 0, true), layout.getHitInfo(0, -30));\n+\n+        \/\/ Checks before start of line:\n+        assertEquals(new Hit(0, 0, true), layout.getHitInfo(-50, 0));\n+\n+        \/\/ Checks positions of a few characters:\n+        assertEquals(new Hit(0, 0, true), layout.getHitInfo(0, 0));  \/\/ Start of \"T\"\n+        assertEquals(new Hit(0, 1, false), layout.getHitInfo(5, 0));  \/\/ Past halfway of \"T\"\n+        assertEquals(new Hit(1, 1, true), layout.getHitInfo(10, 0));  \/\/ Start of \"h\"\n+\n+        \/\/ Checks past end of line:\n+        assertEquals(new Hit(42, 43, false), layout.getHitInfo(250, 0));\n+\n+        \/\/ Checks that hits below the line results in last character + 1:\n+        assertEquals(new Hit(43, 44, false), layout.getHitInfo(0, 30));\n+\n+        \/*\n+         * Multi line:\n+         *\/\n+\n+        layout.setContent(\"The\\nquick\\nbrown\\nfox\\n\", arialFont);\n+\n+        \/\/ Checks that hits above the first line results in first character:\n+        assertEquals(new Hit(0, 0, true), layout.getHitInfo(0, -30));\n+\n+        \/\/ Checks before start of first line:\n+        assertEquals(new Hit(0, 0, true), layout.getHitInfo(-50, 0));\n+\n+        \/\/ Checks positions of a few characters on first line:\n+        assertEquals(new Hit(0, 0, true), layout.getHitInfo(0, 0));  \/\/ Start of \"T\"\n+        assertEquals(new Hit(0, 1, false), layout.getHitInfo(5, 0));  \/\/ Halfway past \"T\"\n+        assertEquals(new Hit(1, 1, true), layout.getHitInfo(10, 0));  \/\/ Start of \"h\"\n+\n+        \/\/ Checks past end of first line:\n+        assertEquals(new Hit(2, 3, false), layout.getHitInfo(250, 0));\n+\n+        \/\/ Checks before start of second line:\n+        assertEquals(new Hit(4, 4, true), layout.getHitInfo(-50, 15));\n+\n+        \/\/ Check second line:\n+        assertEquals(new Hit(4, 4, true), layout.getHitInfo(0, 15));  \/\/ Start of \"q\"\n+\n+        \/\/ Checks past end of second line:\n+        assertEquals(new Hit(8, 9, false), layout.getHitInfo(250, 15));\n+\n+        \/*\n+         * Test with two spans:\n+         *\/\n+\n+        layout.setContent(new TestSpan[] {new TestSpan(\"Two\", arialFont), new TestSpan(\"Spans\", arialFont)});\n+\n+        \/\/ Checks that hits above the line results in first character:\n+        assertEquals(new Hit(0, 0, true), layout.getHitInfo(0, -30));\n+\n+        \/\/ Checks before start of line:\n+        assertEquals(new Hit(0, 0, true), layout.getHitInfo(-50, 0));\n+\n+        \/\/ Checks positions of a few characters:\n+        assertEquals(new Hit(0, 0, true), layout.getHitInfo(0, 0));  \/\/ Start of \"T\"\n+        assertEquals(new Hit(0, 1, false), layout.getHitInfo(5, 0));  \/\/ Past halfway of \"T\"\n+        assertEquals(new Hit(1, 1, true), layout.getHitInfo(10, 0));  \/\/ Start of \"w\"\n+\n+        assertEquals(new Hit(7, 8, false), layout.getHitInfo(60, 0));  \/\/ Past halfway of \"s\"\n+\n+        \/\/ Checks past end of line:\n+        assertEquals(new Hit(7, 8, false), layout.getHitInfo(250, 0));\n+\n+        \/\/ Checks that hits below the line results in last character + 1:\n+        assertEquals(new Hit(8, 9, false), layout.getHitInfo(0, 30));\n+\n+        \/*\n+         * Test with zero spans:\n+         *\/\n+\n+        layout.setContent(new TestSpan[] {});\n+\n+        \/\/ Checks that hits above the line results in first character:\n+        assertEquals(new Hit(0, 0, true), layout.getHitInfo(0, -30));\n+\n+        \/\/ Checks before start of line:\n+        assertEquals(new Hit(0, 1, false), layout.getHitInfo(-50, 0));\n+\n+        \/\/ Checks positions of center:\n+        assertEquals(new Hit(0, 1, false), layout.getHitInfo(0, 0));  \/\/ Start of \"T\"\n+\n+        \/\/ Checks past end of line:\n+        assertEquals(new Hit(0, 1, false), layout.getHitInfo(250, 0));\n+\n+        \/\/ Checks that hits below the line results in last character + 1:\n+        assertEquals(new Hit(0, 1, false), layout.getHitInfo(0, 30));\n+\n+    }\n+\n+    private void assumeArialFontAvailable() {\n+        assumeTrue(\"Arial font missing\", arialFont.getName().equals(\"Arial\"));\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/com\/sun\/javafx\/text\/TextHitInfoTest.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,383 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.robot.javafx.scene;\n+\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.geometry.NodeOrientation;\n+import javafx.geometry.Point2D;\n+import javafx.geometry.Point3D;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.input.PickResult;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.robot.Robot;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.HitInfo;\n+import javafx.scene.text.Text;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.stage.Window;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import test.util.Util;\n+\n+\/*\n+ * Test for verifying character index of Text nodes in RTL orientation.\n+ *\n+ * There are 6 tests in this file.\n+ * Here, the scene node orientation is set to RTL for all the tests.\n+ * Steps for testTextInfoForRTLEnglishText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add only english text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change from highest value to lowest\n+ *    as expected.\n+ *\n+ * Steps for testTextInfoForRTLArabicText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add only arabic text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should increment as expected since it is RTL text.\n+ *\n+ * Steps for testTextInfoForRTLEnglishArabicText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add both english and arabic text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change in decreasing order for english text\n+ *    and in increasing order for arabic text.\n+ *\n+ * Steps for testTextInfoForMultiLineRTLEnglishText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add two lines of only english text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change in decreasing order as expected.\n+ *\n+ * Steps for testTextInfoForMultiLineRTLEnglishArabicText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add two lines of both english and arabic text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change in decreasing order for english text\n+ *    and increasing order for arabic text.\n+ *\n+ * Steps for testTextInfoForMultiLineRTLArabicText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add two lines of only arabic text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change in increasing order as expected.\n+ *\/\n+\n+public class RTLTextCharacterIndexTest {\n+    static CountDownLatch startupLatch = new CountDownLatch(1);\n+    static Random random;\n+    static Robot robot;\n+    static Text text;\n+    static VBox vBox;\n+\n+    static volatile Stage stage;\n+    static volatile Scene scene;\n+\n+    static final int WIDTH = 500;\n+    static final int HEIGHT = 200;\n+\n+    static final int Y_OFFSET = 30;\n+    static final int X_LEADING_OFFSET = 10;\n+\n+    boolean isLeading;\n+    boolean textFlowIsLeading;\n+    int charIndex;\n+    int insertionIndex;\n+    int textFlowCharIndex;\n+    int textFlowInsertionIndex;\n+\n+    private void mouseClick(double x, double y) {\n+        Util.runAndWait(() -> {\n+            Window w = scene.getWindow();\n+            robot.mouseMove(w.getX() + scene.getX() + x,\n+                    w.getY() + scene.getY() + y);\n+            robot.mouseClick(MouseButton.PRIMARY);\n+        });\n+    }\n+\n+    private void moveMouseOverText(double x, double y) throws Exception {\n+        mouseClick(text.getLayoutX() + x,\n+                    text.getLayoutY() \/ 2 + y);\n+    }\n+\n+    private void addRTLEnglishText() {\n+        Util.runAndWait(() -> {\n+            text.setText(\"This is text\");\n+            text.setFont(new Font(48));\n+            vBox.getChildren().setAll(text);\n+        });\n+    }\n+\n+    private void addRTLArabicText() {\n+        Util.runAndWait(() -> {\n+            text.setText(\"شسيبلاتنم\");\n+            text.setFont(new Font(48));\n+            vBox.getChildren().setAll(text);\n+        });\n+    }\n+\n+    private void addRTLEnglishArabicText() {\n+        Util.runAndWait(() -> {\n+            text.setText(\"Arabic:شسيبلاتنم\");\n+            text.setFont(new Font(48));\n+            vBox.getChildren().setAll(text);\n+        });\n+    }\n+\n+    private void addMultiLineRTLEnglishText() {\n+        Util.runAndWait(() -> {\n+            text.setText(\"This is text\\nThis is text\");\n+            text.setFont(new Font(48));\n+            vBox.getChildren().setAll(text);\n+        });\n+    }\n+\n+    private void addMultiLineRTLEnglishArabicText() {\n+        Util.runAndWait(() -> {\n+            text.setText(\"Arabic:شسيبلاتنم\\nArabic:شسيبلاتنم\");\n+            text.setFont(new Font(48));\n+            vBox.getChildren().setAll(text);\n+        });\n+    }\n+\n+    private void addMultiLineRTLArabicText() {\n+        Util.runAndWait(() -> {\n+            text.setText(\"شسيبلاتنم شسيبلاتنم\\nشسيبلاتنم شسيبلاتنم\");\n+            text.setFont(new Font(48));\n+            vBox.getChildren().setAll(text);\n+        });\n+    }\n+\n+    @Test\n+    public void testTextInfoForRTLEnglishText() throws Exception {\n+        addRTLEnglishText();\n+        Util.waitForIdle(scene);\n+\n+        int textLength = text.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverText(x, 0);\n+            if (isLeading) {\n+                Assertions.assertEquals(charIndex, insertionIndex);\n+            } else {\n+                Assertions.assertEquals(charIndex, insertionIndex - 1);\n+            }\n+            Assertions.assertTrue(charIndex < textLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForRTLArabicText() throws Exception {\n+        addRTLArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textLength = text.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverText(x, 0);\n+            if (isLeading) {\n+                Assertions.assertEquals(charIndex, insertionIndex);\n+            } else {\n+                Assertions.assertEquals(charIndex, insertionIndex - 1);\n+            }\n+            Assertions.assertTrue(charIndex < textLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForRTLEnglishArabicText() throws Exception {\n+        addRTLEnglishArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textLength = text.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverText(x, 0);\n+            if (isLeading) {\n+                Assertions.assertEquals(charIndex, insertionIndex);\n+            } else {\n+                Assertions.assertEquals(charIndex, insertionIndex - 1);\n+            }\n+            Assertions.assertTrue(charIndex < textLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForMultiLineRTLEnglishText() throws Exception {\n+        addMultiLineRTLEnglishText();\n+        Util.waitForIdle(scene);\n+\n+        int textLength = text.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverText(x, (Y_OFFSET * (y * 2)));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < textLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForMultiLineRTLEnglishArabicText() throws Exception {\n+        addMultiLineRTLEnglishArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textLength = text.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverText(x, (Y_OFFSET * (y * 2)));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < textLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForMultiLineRTLArabicText() throws Exception {\n+        addMultiLineRTLArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textLength = text.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverText(x, (Y_OFFSET * (y * 2)));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < textLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    private void handleTextMouseEvent(MouseEvent event) {\n+        PickResult pick = event.getPickResult();\n+        Node n = pick.getIntersectedNode();\n+\n+        if (n != null && n instanceof Text t) {\n+            Point3D p3 = pick.getIntersectedPoint();\n+            Point2D p = new Point2D(p3.getX(), p3.getY());\n+            HitInfo hitInfo = t.hitTest(p);\n+\n+            isLeading = hitInfo.isLeading();\n+            charIndex = hitInfo.getCharIndex();\n+            insertionIndex = hitInfo.getInsertionIndex();\n+        }\n+    }\n+\n+    private double step() {\n+        return 1.0 + random.nextDouble() * 8.0;\n+    }\n+\n+    @AfterEach\n+    public void resetUI() {\n+        Platform.runLater(() -> {\n+            text.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleTextMouseEvent);\n+        });\n+    }\n+\n+    @BeforeEach\n+    public void setupUI() {\n+        Platform.runLater(() -> {\n+            text.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleTextMouseEvent);\n+        });\n+    }\n+\n+    @BeforeAll\n+    public static void initFX() {\n+        long seed = new Random().nextLong();\n+        System.out.println(\"seed=\" + seed);\n+        random = new Random(seed);\n+\n+        Util.launch(startupLatch, TestApp.class);\n+    }\n+\n+    @AfterAll\n+    public static void exit() {\n+        Util.shutdown(stage);\n+    }\n+\n+    public static class TestApp extends Application {\n+        @Override\n+        public void start(Stage primaryStage) {\n+            robot = new Robot();\n+            stage = primaryStage;\n+\n+            text = new Text();\n+            vBox = new VBox();\n+\n+            scene = new Scene(vBox, WIDTH, HEIGHT);\n+            scene.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+            stage.setScene(scene);\n+            stage.initStyle(StageStyle.UNDECORATED);\n+            stage.setOnShown(event -> Platform.runLater(startupLatch::countDown));\n+            stage.setAlwaysOnTop(true);\n+            stage.show();\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/RTLTextCharacterIndexTest.java","additions":383,"deletions":0,"binary":false,"changes":383,"status":"added"},{"patch":"@@ -0,0 +1,460 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.robot.javafx.scene;\n+\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.geometry.NodeOrientation;\n+import javafx.geometry.Point2D;\n+import javafx.geometry.Point3D;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.input.PickResult;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.robot.Robot;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.HitInfo;\n+import javafx.scene.text.Text;\n+import javafx.scene.text.TextFlow;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.stage.Window;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import test.util.Util;\n+\n+\/*\n+ * Test for verifying character index of Text nodes embedded in TextFlow in RTL orientation.\n+ *\n+ * There are 5 tests in this file.\n+ * Here, the scene node orientation is set to RTL for all the tests.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLArabicText()\n+ * 1. Create a TextFlow. Add a Text nodes with only arabic text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in ascending order as expected.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLEnglishText()\n+ * 1. Create a TextFlow. Add a Text nodes with only english text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in descending order as expected.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLMultipleTextNodes()\n+ * 1. Create a TextFlow. Add two Text nodes with english and arabic text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in decreasing order for english text\n+ *    and in increasing order for arabic text.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLMultipleMultiLineEnglishArabicTextNodes()\n+ * 1. Create a TextFlow. Add three Text nodes with english and arabic text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in decreasing order for english text\n+ *    and in increasing order for arabic text.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLMultipleMultiLineEnglishTextNodes()\n+ * 1. Create a TextFlow. Add three Text nodes with only english text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in decreasing order for english text.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLMultipleMultiLineArabicTextNodes()\n+ * 1. Create a TextFlow. Add three Text nodes with only arabic text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in increasing order for arabic text.\n+ *\n+ *\/\n+\n+public class RTLTextFlowCharacterIndexTest {\n+    static CountDownLatch startupLatch = new CountDownLatch(1);\n+    static Random random;\n+    static Robot robot;\n+    static TextFlow textFlow;\n+    static Text textOne;\n+    static Text textTwo;\n+    static Text textThree;\n+    static VBox vBox;\n+\n+    static volatile Stage stage;\n+    static volatile Scene scene;\n+\n+    static final int WIDTH = 500;\n+    static final int HEIGHT = 200;\n+\n+    static final int Y_OFFSET = 30;\n+    static final int X_LEADING_OFFSET = 10;\n+\n+    boolean isLeading;\n+    boolean textFlowIsLeading;\n+    int charIndex;\n+    int insertionIndex;\n+    int textFlowCharIndex;\n+    int textFlowInsertionIndex;\n+\n+    private void mouseClick(double x, double y) {\n+        Util.runAndWait(() -> {\n+            Window w = scene.getWindow();\n+            robot.mouseMove(w.getX() + scene.getX() + x,\n+                    w.getY() + scene.getY() + y);\n+            robot.mouseClick(MouseButton.PRIMARY);\n+        });\n+    }\n+\n+    private void moveMouseOverTextFlow(double x, double y) throws Exception {\n+        mouseClick(textFlow.getLayoutX() + x,\n+                    textFlow.getLayoutY() + y);\n+    }\n+\n+    private void addRTLArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"شسيبلاتنم\");\n+            textOne.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addRTLEnglishText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"This is text\");\n+            textOne.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addMultiNodeRTLEnglishArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"Arabic:\");\n+            textOne.setFont(new Font(48));\n+            textTwo.setText(\"شسيبلاتنم\");\n+            textTwo.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addMultiLineMultiNodeRTLEnglishArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"Arabic:\");\n+            textOne.setFont(new Font(48));\n+            textTwo.setText(\"شسيبلاتنضصثقفغ\");\n+            textTwo.setFont(new Font(48));\n+            textThree.setText(\"حخهعغقثصضشسيبل\");\n+            textThree.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo, textThree);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addMutliLineMultiNodeRTLEnglishText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"First line of text\");\n+            textOne.setFont(new Font(48));\n+            textTwo.setText(\"Second line of text\");\n+            textTwo.setFont(new Font(48));\n+            textThree.setText(\"Third line of text\");\n+            textThree.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo, textThree);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addMutliLineMultiNodeRTLArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"شسيبلا تنضصثقفغ\");\n+            textOne.setFont(new Font(48));\n+            textTwo.setText(\"حخهعغقث صضشسيبل\");\n+            textTwo.setFont(new Font(48));\n+            textThree.setText(\"ضصثقف\");\n+            textThree.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo, textThree);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLArabicText() throws Exception {\n+        addRTLArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverTextFlow(x, Y_OFFSET);\n+            if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+            Assertions.assertTrue(charIndex < textOneLength);\n+            Assertions.assertTrue(textFlowCharIndex < textOneLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLEnglishText() throws Exception {\n+        addRTLEnglishText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverTextFlow(x, Y_OFFSET);\n+            if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+            Assertions.assertTrue(charIndex < textOneLength);\n+            Assertions.assertTrue(textFlowCharIndex < textOneLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLMultipleTextNodes() throws Exception {\n+        addMultiNodeRTLEnglishArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverTextFlow(x, Y_OFFSET);\n+            if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+            Assertions.assertTrue(charIndex < Math.max(textOneLength, textTwoLength));\n+            Assertions.assertTrue(textFlowCharIndex < textOneLength + textTwoLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLMultipleMultiLineEnglishArabicTextNodes() throws Exception {\n+        addMultiLineMultiNodeRTLEnglishArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+        int textThreeLength = textThree.getText().length();\n+\n+        for (int y = 0; y < 3; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < Math.max(textThreeLength, Math.max(textOneLength, textTwoLength)));\n+                Assertions.assertTrue(textFlowCharIndex < textOneLength + textTwoLength + textThreeLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLMultipleMultiLineEnglishTextNodes() throws Exception {\n+        addMutliLineMultiNodeRTLEnglishText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+        int textThreeLength = textThree.getText().length();\n+\n+        for (int y = 0; y < 3; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < Math.max(textThreeLength, Math.max(textOneLength, textTwoLength)));\n+                Assertions.assertTrue(textFlowCharIndex < textOneLength + textTwoLength + textThreeLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLMultipleMultiLineArabicTextNodes() throws Exception {\n+        addMutliLineMultiNodeRTLArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+        int textThreeLength = textThree.getText().length();\n+\n+        for (int y = 0; y < 3; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < Math.max(textThreeLength, Math.max(textOneLength, textTwoLength)));\n+                Assertions.assertTrue(textFlowCharIndex < textOneLength + textTwoLength + textThreeLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    private void handleMouseEvent(MouseEvent event) {\n+        PickResult pick = event.getPickResult();\n+        Node n = pick.getIntersectedNode();\n+\n+        if (n != null && n instanceof Text t) {\n+            Point3D p3 = pick.getIntersectedPoint();\n+            Point2D p = new Point2D(p3.getX(), p3.getY());\n+            HitInfo hitInfo = t.hitTest(p);\n+\n+            isLeading = hitInfo.isLeading();\n+            charIndex = hitInfo.getCharIndex();\n+            insertionIndex = hitInfo.getInsertionIndex();\n+        }\n+\n+        Point2D point = new Point2D(event.getX(), event.getY());\n+        HitInfo textFlowHitInfo = textFlow.hitTest(point);\n+        textFlowIsLeading = textFlowHitInfo.isLeading();\n+        textFlowCharIndex = textFlowHitInfo.getCharIndex();\n+        textFlowInsertionIndex = textFlowHitInfo.getInsertionIndex();\n+    }\n+\n+    private double step() {\n+        return 1.0 + random.nextDouble() * 8.0;\n+    }\n+\n+    @AfterEach\n+    public void resetUI() {\n+        Platform.runLater(() -> {\n+            textFlow.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textOne.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textTwo.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textThree.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+        });\n+    }\n+\n+    @BeforeEach\n+    public void setupUI() {\n+        Platform.runLater(() -> {\n+            textFlow.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textOne.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textTwo.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textThree.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+        });\n+    }\n+\n+    @BeforeAll\n+    public static void initFX() {\n+        long seed = new Random().nextLong();\n+        System.out.println(\"seed=\" + seed);\n+        random = new Random(seed);\n+\n+        Util.launch(startupLatch, TestApp.class);\n+    }\n+\n+    @AfterAll\n+    public static void exit() {\n+        Util.shutdown(stage);\n+    }\n+\n+    public static class TestApp extends Application {\n+        @Override\n+        public void start(Stage primaryStage) {\n+            robot = new Robot();\n+            stage = primaryStage;\n+\n+            textOne = new Text();\n+            textTwo = new Text();\n+            textThree = new Text();\n+            textFlow = new TextFlow();\n+            vBox = new VBox();\n+\n+            scene = new Scene(vBox, WIDTH, HEIGHT);\n+            scene.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+            stage.setScene(scene);\n+            stage.initStyle(StageStyle.UNDECORATED);\n+            stage.setOnShown(event -> Platform.runLater(startupLatch::countDown));\n+            stage.setAlwaysOnTop(true);\n+            stage.show();\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/RTLTextFlowCharacterIndexTest.java","additions":460,"deletions":0,"binary":false,"changes":460,"status":"added"}]}