{"files":[{"patch":"@@ -211,2 +211,2 @@\n-     * @param textRunStart Text run start position.\n-     * @param curRunStart starting position of text run where hit info is requested.\n+     * @param textRunStart Start position of first Text run where hit info is requested.\n+     * @param curRunStart Start position of text run where hit info is requested.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/text\/TextLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -425,0 +425,3 @@\n+        boolean leading = false;\n+        boolean isMirrored = isMirrored(); \/\/ Node orientation is RTL\n+        boolean forTextFlow = spans != null && text == null;\n@@ -427,1 +430,0 @@\n-        boolean leading = false;\n@@ -429,0 +431,1 @@\n+        int ltrIndex = 0;\n@@ -430,0 +433,1 @@\n+        float xHitPos = x;\n@@ -432,1 +436,1 @@\n-        int lineIndex = getLineIndex(y, text, curRunStart);\n+        int lineIndex = getLineIndex(y, forTextFlow, curRunStart);\n@@ -436,2 +440,12 @@\n-        } else {\n-            if (isMirrored()) {\n+            return new Hit(charIndex, insertionIndex, leading);\n+        }\n+\n+        TextLine line = lines[lineIndex];\n+        TextRun[] runs = line.getRuns();\n+        RectBounds bounds = line.getBounds();\n+        TextRun run = null;\n+        \/\/TODO binary search\n+        if (forTextFlow || spans == null) {\n+            \/* This code branch is used to calculate hit info of Text node\n+             * which are not embedded in TextFlow and hit info requested on TextFlow. *\/\n+            if (isMirrored) {\n@@ -439,8 +453,19 @@\n-            }\n-            TextLine line = lines[lineIndex];\n-            TextRun[] runs = line.getRuns();\n-            RectBounds bounds = line.getBounds();\n-            TextRun run = null;\n-            x -= bounds.getMinX();\n-            \/\/TODO binary search\n-            if (text == null || spans == null) {\n+                int runIndex = -1;\n+                for (int i = runs.length - 1; i >= 0; i--) {\n+                    run = runs[i];\n+                    if (x < run.getWidth() && (forTextFlow || (run.getStart() == curRunStart))) {\n+                        runIndex = i;\n+                        break;\n+                    }\n+                    if (i > 0) {\n+                        if (runs[i - 1].isLinebreak()) {\n+                            break;\n+                        }\n+                        x -= run.getWidth();\n+                    }\n+                }\n+                for (int i = 0; i < runIndex; i++) {\n+                    xHitPos -= runs[i].getWidth();\n+                }\n+                xHitPos -= bounds.getMinX();\n+            } else {\n@@ -449,1 +474,3 @@\n-                    if (x < run.getWidth()) break;\n+                    if (x < run.getWidth()) {\n+                        break;\n+                    }\n@@ -451,1 +478,3 @@\n-                        if (runs[i + 1].isLinebreak()) break;\n+                        if (runs[i + 1].isLinebreak()) {\n+                            break;\n+                        }\n@@ -455,5 +484,31 @@\n-            } else {\n-                for (int i = 0; i < lineIndex; i++) {\n-                    for (TextRun r: lines[i].runs) {\n-                        if (r.getTextSpan() != null && r.getStart() >= textRunStart && r.getTextSpan().getText().equals(text)) {\n-                            textWidthPrevLine += r.getLength();\n+            }\n+        } else {\n+            \/\/ This code branch is used to calculate hit info of Text node embedded in TextFlow.\n+            textWidthPrevLine = getPrevLineWidth(text, lineIndex, textRunStart);\n+\n+            BaseBounds textBounds = new BoxBounds();\n+            if (isMirrored) {\n+                int runIdx = 0;\n+                for (TextRun r: runs) {\n+                    if (r.getStart() == curRunStart) {\n+                        run = r;\n+                        break;\n+                    }\n+                    runIdx++;\n+                }\n+\n+                boolean textFound = false;\n+                for (int i = 0; i <= runIdx; i++) {\n+                    TextRun r = runs[i];\n+                    int textWidth = run.getStart() + run.getTextSpan().getText().length();\n+                    if (r.getStart() != curRunStart && x > r.getWidth() && textWidthPrevLine == 0\n+                            && r.getStart() < textWidth && r.getTextSpan().getText().equals(text)) {\n+                        x -= r.getWidth();\n+                        textFound = true;\n+                        continue;\n+                    }\n+                    if (r.getTextSpan() != null && r.getStart() == curRunStart\n+                            && r.getTextSpan().getText().equals(text)) {\n+                        if (x > r.getWidth() || textWidthPrevLine > 0) {\n+                            getBounds(r.getTextSpan(), textBounds);\n+                            x -= (run.getLocation().x - textBounds.getMinX());\n@@ -461,0 +516,7 @@\n+                        break;\n+                    }\n+                        \/* This condition handles LTR Text nodes present between\n+                           a Text node containing both LTR and RTL text. *\/\n+                    if (textFound && x > r.getWidth() && r.getStart() < curRunStart\n+                            && !r.getTextSpan().getText().equals(text)) {\n+                        x -= r.getWidth();\n@@ -463,2 +525,4 @@\n-                int prevNodeLength = 0;\n-                boolean isPrevNodeExcluded = false;\n+                ltrIndex = getLtrTextWidthInRtlText(runs, text, curRunStart, runIdx);\n+            } else {\n+                boolean isPrevRunPresent = false;\n+                int prevRunLength = 0;\n@@ -467,1 +531,1 @@\n-                        prevNodeLength += r.getWidth();\n+                        prevRunLength += r.getWidth();\n@@ -471,1 +535,0 @@\n-                        BaseBounds textBounds = new BoxBounds();\n@@ -473,3 +536,3 @@\n-                        if (textBounds.getMinX() == 0 && !isPrevNodeExcluded) {\n-                            x -= prevNodeLength;\n-                            isPrevNodeExcluded = true;\n+                        if (textBounds.getMinX() == 0 && !isPrevRunPresent) {\n+                            x -= prevRunLength;\n+                            isPrevRunPresent = true;\n@@ -487,0 +550,1 @@\n+        }\n@@ -488,6 +552,6 @@\n-            if (run != null) {\n-                int[] trailing = new int[1];\n-                if (text != null && spans != null) {\n-                    charIndex = run.getOffsetAtX(x, trailing);\n-                    charIndex += textWidthPrevLine;\n-                    charIndex += relIndex;\n+        if (run != null) {\n+            int[] trailing = new int[1];\n+            if (forTextFlow || spans == null) {\n+                int indexOffset;\n+                if (isMirrored) {\n+                    indexOffset = run.getOffsetAtX(xHitPos, trailing);\n@@ -495,1 +559,1 @@\n-                    charIndex = run.getStart() + run.getOffsetAtX(x, trailing);\n+                    indexOffset = run.getOffsetAtX(x, trailing);\n@@ -497,17 +561,25 @@\n-                leading = (trailing[0] == 0);\n-\n-                insertionIndex = charIndex;\n-                if (getText() != null && insertionIndex < getText().length) {\n-                    if (!leading) {\n-                        BreakIterator charIterator = BreakIterator.getCharacterInstance();\n-                        if (text != null) {\n-                            charIterator.setText(text);\n-                        } else {\n-                            charIterator.setText(new String(getText()));\n-                        }\n-                        int next = charIterator.following(insertionIndex);\n-                        if (next == BreakIterator.DONE) {\n-                            insertionIndex += 1;\n-                        } else {\n-                            insertionIndex = next;\n-                        }\n+                charIndex = run.getStart() + indexOffset;\n+            } else {\n+                charIndex = run.getOffsetAtX(x, trailing);\n+                charIndex += textWidthPrevLine;\n+                charIndex += relIndex;\n+                \/*  When RTL text has LTR text embedded,\n+                 *  add the LTR index here to get effective character index *\/\n+                charIndex += ltrIndex;\n+            }\n+            leading = (trailing[0] == 0);\n+\n+            insertionIndex = charIndex;\n+            if (insertionIndex < getText().length) {\n+                if (!leading) {\n+                    BreakIterator charIterator = BreakIterator.getCharacterInstance();\n+                    if (forTextFlow) {\n+                        charIterator.setText(new String(getText()));\n+                    } else {\n+                        charIterator.setText(text);\n+                    }\n+                    int next = charIterator.following(insertionIndex);\n+                    if (next == BreakIterator.DONE) {\n+                        insertionIndex += 1;\n+                    } else {\n+                        insertionIndex = next;\n@@ -515,2 +587,0 @@\n-                } else if (!leading) {\n-                    insertionIndex += 1;\n@@ -518,5 +588,2 @@\n-            } else {\n-                \/\/empty line, set to line break leading\n-                charIndex = line.getStart();\n-                leading = true;\n-                insertionIndex = charIndex;\n+            } else if (!leading) {\n+                insertionIndex += 1;\n@@ -524,0 +591,5 @@\n+        } else {\n+            \/\/empty line, set to line break leading\n+            charIndex = line.getStart();\n+            leading = true;\n+            insertionIndex = charIndex;\n@@ -528,0 +600,28 @@\n+    private int getLtrTextWidthInRtlText(TextRun[] runs, String text, int curRunStart, int runIdx) {\n+        TextRun run = runs[runIdx];\n+        int ltrTextWidth = 0;\n+        for (int i = runs.length - 1; i > runIdx; i--) {\n+            TextRun r = runs[i];\n+            boolean addLtrIdx = run.getTextSpan().getText().length() != run.length\n+                                    && (r.length + ltrTextWidth) < run.getTextSpan().getText().length();\n+            if (r.getStart() != curRunStart && !r.isLinebreak() && addLtrIdx\n+                    && r.getTextSpan().getText().equals(text)) {\n+                ltrTextWidth += r.getLength();\n+            }\n+        }\n+        return ltrTextWidth;\n+    }\n+\n+    private int getPrevLineWidth(String text, int lineIndex, int textRunStart) {\n+        int prevLineWidth = 0;\n+        for (int i = 0; i < lineIndex; i++) {\n+            for (TextRun r: lines[i].getRuns()) {\n+                if (r.getTextSpan() != null && r.getStart() >= textRunStart\n+                        && r.getTextSpan().getText().equals(text)) {\n+                    prevLineWidth += r.getLength();\n+                }\n+            }\n+        }\n+        return prevLineWidth;\n+    }\n+\n@@ -752,1 +852,1 @@\n-    private int getLineIndex(float y, String text, int runStart) {\n+    private int getLineIndex(float y, boolean forTextFlow, int runStart) {\n@@ -755,3 +855,3 @@\n-        \/* Initializing textFound as true when text is null\n-         * because when this function is called for TextFlow text parameter will be null *\/\n-        boolean textFound = (text == null);\n+        \/* Initializing textFound as true when this function is called for\n+         * TextFlow or Text node which is not embedded in TextFlow *\/\n+        boolean textFound = (forTextFlow || spans == null);\n@@ -762,4 +862,2 @@\n-                for (TextRun r : lines[index].runs) {\n-                    if (r.getTextSpan() == null || (r.getStart() == runStart && r.getTextSpan().getText().equals(text))) {\n-                        \/* Span will present only for Rich Text.\n-                         * Hence making textFound as true *\/\n+                for (TextRun r : lines[index].getRuns()) {\n+                    if (r.getStart() == runStart) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/PrismTextLayout.java","additions":163,"deletions":65,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -1027,1 +1027,4 @@\n-        int runIndex = 0;\n+        int runIndex = findRunIndex(x, y, runs);\n+\n+        int textRunStart = 0;\n+        int curRunStart = 0;\n@@ -1029,0 +1032,53 @@\n+            textRunStart = findFirstRunStart(x, y, runs);\n+            curRunStart = ((TextRun) runs[runIndex]).getStart();\n+        }\n+        TextLayout.Hit h = layout.getHitInfo((float)x, (float)y, getTextInternal(), textRunStart, curRunStart);\n+        return new HitInfo(h.getCharIndex(), h.getInsertionIndex(), h.isLeading());\n+    }\n+\n+    private int findFirstRunStart(double x, double y, GlyphList[] runs) {\n+        int start = Integer.MAX_VALUE;\n+        for (GlyphList r: runs) {\n+            if (((TextRun) r).getStart() < start) {\n+                start = ((TextRun) r).getStart();\n+            }\n+        }\n+        return start;\n+    }\n+\n+    private int findRunIndex(double x, double y, GlyphList[] runs) {\n+        int runIdx = 0;\n+        int lastIndex = runs.length - 1;\n+\n+        if (runs.length == 0) {\n+            return runIdx;\n+        }\n+\n+        if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {\n+            if (runs[runIdx].getTextSpan() == null) {\n+                while (runIdx < lastIndex) {\n+                    GlyphList run = runs[runIdx];\n+                    GlyphList nextRun = runs[runIdx + 1];\n+                    if ((x > run.getLocation().x &&\n+                            (x < nextRun.getLocation().x || run.getLocation().y < nextRun.getLocation().y))\n+                                && y < run.getHeight()) {\n+                        break;\n+                    }\n+                    runIdx++;\n+                    y = updateY(y, runIdx, runs);\n+                }\n+            } else {\n+                Point2D ptInParent = localToParent(x, y);\n+                double ptX = ptInParent.getX();\n+                double ptY = ptInParent.getY();\n+                while (runIdx < lastIndex) {\n+                    GlyphList run = runs[runIdx];\n+                    if (ptX > run.getLocation().x && ptX < (run.getLocation().x + run.getWidth()) && ptY >= run.getLocation().y\n+                            && y < run.getHeight()) {\n+                        break;\n+                    }\n+                    runIdx++;\n+                    y = updateY(y, runIdx, runs);\n+                }\n+            }\n+        } else {\n@@ -1030,2 +1086,2 @@\n-            while (runIndex < runs.length - 1) {\n-                if (ptY > runs[runIndex].getLocation().y && ptY < runs[runIndex + 1].getLocation().y) {\n+            while (runIdx < lastIndex) {\n+                if (ptY > runs[runIdx].getLocation().y && ptY < runs[runIdx + 1].getLocation().y) {\n@@ -1034,1 +1090,1 @@\n-                runIndex++;\n+                runIdx++;\n@@ -1037,5 +1093,7 @@\n-        int textRunStart = 0;\n-        int curRunStart = 0;\n-        if (runs.length != 0) {\n-            textRunStart = ((TextRun) runs[0]).getStart();\n-            curRunStart = ((TextRun) runs[runIndex]).getStart();\n+        return runIdx;\n+    }\n+\n+    private double updateY(double y, int ix, GlyphList[] runs) {\n+        GlyphList curRun = runs[ix];\n+        if (y > curRun.getHeight() && (curRun.getLocation().y != runs[ix - 1].getLocation().y)) {\n+            y -= curRun.getHeight();\n@@ -1043,2 +1101,1 @@\n-        TextLayout.Hit h = layout.getHitInfo((float)x, (float)y, getText(), textRunStart, curRunStart);\n-        return new HitInfo(h.getCharIndex(), h.getInsertionIndex(), h.isLeading());\n+        return y;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/Text.java","additions":68,"deletions":11,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -0,0 +1,383 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.robot.javafx.scene;\n+\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.geometry.NodeOrientation;\n+import javafx.geometry.Point2D;\n+import javafx.geometry.Point3D;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.input.PickResult;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.robot.Robot;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.HitInfo;\n+import javafx.scene.text.Text;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.stage.Window;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import test.util.Util;\n+\n+\/*\n+ * Test for verifying character index of Text nodes in RTL orientation.\n+ *\n+ * There are 6 tests in this file.\n+ * Here, the scene node orientation is set to RTL for all the tests.\n+ * Steps for testTextInfoForRTLEnglishText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add only english text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change from highest value to lowest\n+ *    as expected.\n+ *\n+ * Steps for testTextInfoForRTLArabicText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add only arabic text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should increment as expected since it is RTL text.\n+ *\n+ * Steps for testTextInfoForRTLEnglishArabicText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add both english and arabic text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change in decreasing order for english text\n+ *    and in increasing order for arabic text.\n+ *\n+ * Steps for testTextInfoForMultiLineRTLEnglishText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add two lines of only english text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change in decreasing order as expected.\n+ *\n+ * Steps for testTextInfoForMultiLineRTLEnglishArabicText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add two lines of both english and arabic text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change in decreasing order for english text\n+ *    and increasing order for arabic text.\n+ *\n+ * Steps for testTextInfoForMultiLineRTLArabicText()\n+ * 1. Create a Text node and add it to the scene using a VBox.\n+ * 2. Add two lines of only arabic text to the Text node.\n+ * 3. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 4. Character index should change in increasing order as expected.\n+ *\/\n+\n+public class RTLTextCharacterIndexTest {\n+    static CountDownLatch startupLatch = new CountDownLatch(1);\n+    static Random random;\n+    static Robot robot;\n+    static Text text;\n+    static VBox vBox;\n+\n+    static volatile Stage stage;\n+    static volatile Scene scene;\n+\n+    static final int WIDTH = 500;\n+    static final int HEIGHT = 200;\n+\n+    static final int Y_OFFSET = 30;\n+    static final int X_LEADING_OFFSET = 10;\n+\n+    boolean isLeading;\n+    boolean textFlowIsLeading;\n+    int charIndex;\n+    int insertionIndex;\n+    int textFlowCharIndex;\n+    int textFlowInsertionIndex;\n+\n+    private void mouseClick(double x, double y) {\n+        Util.runAndWait(() -> {\n+            Window w = scene.getWindow();\n+            robot.mouseMove(w.getX() + scene.getX() + x,\n+                    w.getY() + scene.getY() + y);\n+            robot.mouseClick(MouseButton.PRIMARY);\n+        });\n+    }\n+\n+    private void moveMouseOverText(double x, double y) throws Exception {\n+        mouseClick(text.getLayoutX() + x,\n+                    text.getLayoutY() \/ 2 + y);\n+    }\n+\n+    private void addRTLEnglishText() {\n+        Util.runAndWait(() -> {\n+            text.setText(\"This is text\");\n+            text.setFont(new Font(48));\n+            vBox.getChildren().setAll(text);\n+        });\n+    }\n+\n+    private void addRTLArabicText() {\n+        Util.runAndWait(() -> {\n+            text.setText(\"شسيبلاتنم\");\n+            text.setFont(new Font(48));\n+            vBox.getChildren().setAll(text);\n+        });\n+    }\n+\n+    private void addRTLEnglishArabicText() {\n+        Util.runAndWait(() -> {\n+            text.setText(\"Arabic:شسيبلاتنم\");\n+            text.setFont(new Font(48));\n+            vBox.getChildren().setAll(text);\n+        });\n+    }\n+\n+    private void addMultiLineRTLEnglishText() {\n+        Util.runAndWait(() -> {\n+            text.setText(\"This is text\\nThis is text\");\n+            text.setFont(new Font(48));\n+            vBox.getChildren().setAll(text);\n+        });\n+    }\n+\n+    private void addMultiLineRTLEnglishArabicText() {\n+        Util.runAndWait(() -> {\n+            text.setText(\"Arabic:شسيبلاتنم\\nArabic:شسيبلاتنم\");\n+            text.setFont(new Font(48));\n+            vBox.getChildren().setAll(text);\n+        });\n+    }\n+\n+    private void addMultiLineRTLArabicText() {\n+        Util.runAndWait(() -> {\n+            text.setText(\"شسيبلاتنم شسيبلاتنم\\nشسيبلاتنم شسيبلاتنم\");\n+            text.setFont(new Font(48));\n+            vBox.getChildren().setAll(text);\n+        });\n+    }\n+\n+    @Test\n+    public void testTextInfoForRTLEnglishText() throws Exception {\n+        addRTLEnglishText();\n+        Util.waitForIdle(scene);\n+\n+        int textLength = text.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverText(x, 0);\n+            if (isLeading) {\n+                Assertions.assertEquals(charIndex, insertionIndex);\n+            } else {\n+                Assertions.assertEquals(charIndex, insertionIndex - 1);\n+            }\n+            Assertions.assertTrue(charIndex < textLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForRTLArabicText() throws Exception {\n+        addRTLArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textLength = text.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverText(x, 0);\n+            if (isLeading) {\n+                Assertions.assertEquals(charIndex, insertionIndex);\n+            } else {\n+                Assertions.assertEquals(charIndex, insertionIndex - 1);\n+            }\n+            Assertions.assertTrue(charIndex < textLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForRTLEnglishArabicText() throws Exception {\n+        addRTLEnglishArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textLength = text.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverText(x, 0);\n+            if (isLeading) {\n+                Assertions.assertEquals(charIndex, insertionIndex);\n+            } else {\n+                Assertions.assertEquals(charIndex, insertionIndex - 1);\n+            }\n+            Assertions.assertTrue(charIndex < textLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForMultiLineRTLEnglishText() throws Exception {\n+        addMultiLineRTLEnglishText();\n+        Util.waitForIdle(scene);\n+\n+        int textLength = text.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverText(x, (Y_OFFSET * (y * 2)));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < textLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForMultiLineRTLEnglishArabicText() throws Exception {\n+        addMultiLineRTLEnglishArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textLength = text.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverText(x, (Y_OFFSET * (y * 2)));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < textLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInfoForMultiLineRTLArabicText() throws Exception {\n+        addMultiLineRTLArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textLength = text.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverText(x, (Y_OFFSET * (y * 2)));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < textLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    private void handleTextMouseEvent(MouseEvent event) {\n+        PickResult pick = event.getPickResult();\n+        Node n = pick.getIntersectedNode();\n+\n+        if (n != null && n instanceof Text t) {\n+            Point3D p3 = pick.getIntersectedPoint();\n+            Point2D p = new Point2D(p3.getX(), p3.getY());\n+            HitInfo hitInfo = t.hitTest(p);\n+\n+            isLeading = hitInfo.isLeading();\n+            charIndex = hitInfo.getCharIndex();\n+            insertionIndex = hitInfo.getInsertionIndex();\n+        }\n+    }\n+\n+    private double step() {\n+        return 1.0 + random.nextDouble() * 8.0;\n+    }\n+\n+    @AfterEach\n+    public void resetUI() {\n+        Platform.runLater(() -> {\n+            text.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleTextMouseEvent);\n+        });\n+    }\n+\n+    @BeforeEach\n+    public void setupUI() {\n+        Platform.runLater(() -> {\n+            text.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleTextMouseEvent);\n+        });\n+    }\n+\n+    @BeforeAll\n+    public static void initFX() {\n+        long seed = new Random().nextLong();\n+        System.out.println(\"seed=\" + seed);\n+        random = new Random(seed);\n+\n+        Util.launch(startupLatch, TestApp.class);\n+    }\n+\n+    @AfterAll\n+    public static void exit() {\n+        Util.shutdown(stage);\n+    }\n+\n+    public static class TestApp extends Application {\n+        @Override\n+        public void start(Stage primaryStage) {\n+            robot = new Robot();\n+            stage = primaryStage;\n+\n+            text = new Text();\n+            vBox = new VBox();\n+\n+            scene = new Scene(vBox, WIDTH, HEIGHT);\n+            scene.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+            stage.setScene(scene);\n+            stage.initStyle(StageStyle.UNDECORATED);\n+            stage.setOnShown(event -> Platform.runLater(startupLatch::countDown));\n+            stage.setAlwaysOnTop(true);\n+            stage.show();\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/RTLTextCharacterIndexTest.java","additions":383,"deletions":0,"binary":false,"changes":383,"status":"added"},{"patch":"@@ -0,0 +1,460 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.robot.javafx.scene;\n+\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.geometry.NodeOrientation;\n+import javafx.geometry.Point2D;\n+import javafx.geometry.Point3D;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.input.PickResult;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.robot.Robot;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.HitInfo;\n+import javafx.scene.text.Text;\n+import javafx.scene.text.TextFlow;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.stage.Window;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import test.util.Util;\n+\n+\/*\n+ * Test for verifying character index of Text nodes embedded in TextFlow in RTL orientation.\n+ *\n+ * There are 5 tests in this file.\n+ * Here, the scene node orientation is set to RTL for all the tests.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLArabicText()\n+ * 1. Create a TextFlow. Add a Text nodes with only arabic text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in ascending order as expected.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLEnglishText()\n+ * 1. Create a TextFlow. Add a Text nodes with only english text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in descending order as expected.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLMultipleTextNodes()\n+ * 1. Create a TextFlow. Add two Text nodes with english and arabic text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in decreasing order for english text\n+ *    and in increasing order for arabic text.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLMultipleMultiLineEnglishArabicTextNodes()\n+ * 1. Create a TextFlow. Add three Text nodes with english and arabic text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in decreasing order for english text\n+ *    and in increasing order for arabic text.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLMultipleMultiLineEnglishTextNodes()\n+ * 1. Create a TextFlow. Add three Text nodes with only english text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in decreasing order for english text.\n+ *\n+ * Steps for testTextAndTextFlowHitInfoForRTLMultipleMultiLineArabicTextNodes()\n+ * 1. Create a TextFlow. Add three Text nodes with only arabic text.\n+ * 2. Move the cursor from right to left with a random\n+ *    decrement value generated in step() method.\n+ * 3. Character index should change in increasing order for arabic text.\n+ *\n+ *\/\n+\n+public class RTLTextFlowCharacterIndexTest {\n+    static CountDownLatch startupLatch = new CountDownLatch(1);\n+    static Random random;\n+    static Robot robot;\n+    static TextFlow textFlow;\n+    static Text textOne;\n+    static Text textTwo;\n+    static Text textThree;\n+    static VBox vBox;\n+\n+    static volatile Stage stage;\n+    static volatile Scene scene;\n+\n+    static final int WIDTH = 500;\n+    static final int HEIGHT = 200;\n+\n+    static final int Y_OFFSET = 30;\n+    static final int X_LEADING_OFFSET = 10;\n+\n+    boolean isLeading;\n+    boolean textFlowIsLeading;\n+    int charIndex;\n+    int insertionIndex;\n+    int textFlowCharIndex;\n+    int textFlowInsertionIndex;\n+\n+    private void mouseClick(double x, double y) {\n+        Util.runAndWait(() -> {\n+            Window w = scene.getWindow();\n+            robot.mouseMove(w.getX() + scene.getX() + x,\n+                    w.getY() + scene.getY() + y);\n+            robot.mouseClick(MouseButton.PRIMARY);\n+        });\n+    }\n+\n+    private void moveMouseOverTextFlow(double x, double y) throws Exception {\n+        mouseClick(textFlow.getLayoutX() + x,\n+                    textFlow.getLayoutY() + y);\n+    }\n+\n+    private void addRTLArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"شسيبلاتنم\");\n+            textOne.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addRTLEnglishText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"This is text\");\n+            textOne.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addMultiNodeRTLEnglishArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"Arabic:\");\n+            textOne.setFont(new Font(48));\n+            textTwo.setText(\"شسيبلاتنم\");\n+            textTwo.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addMultiLineMultiNodeRTLEnglishArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"Arabic:\");\n+            textOne.setFont(new Font(48));\n+            textTwo.setText(\"شسيبلاتنضصثقفغ\");\n+            textTwo.setFont(new Font(48));\n+            textThree.setText(\"حخهعغقثصضشسيبل\");\n+            textThree.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo, textThree);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addMutliLineMultiNodeRTLEnglishText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"First line of text\");\n+            textOne.setFont(new Font(48));\n+            textTwo.setText(\"Second line of text\");\n+            textTwo.setFont(new Font(48));\n+            textThree.setText(\"Third line of text\");\n+            textThree.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo, textThree);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    private void addMutliLineMultiNodeRTLArabicText() {\n+        Util.runAndWait(() -> {\n+            textOne.setText(\"شسيبلا تنضصثقفغ\");\n+            textOne.setFont(new Font(48));\n+            textTwo.setText(\"حخهعغقث صضشسيبل\");\n+            textTwo.setFont(new Font(48));\n+            textThree.setText(\"ضصثقف\");\n+            textThree.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo, textThree);\n+            vBox.getChildren().setAll(textFlow);\n+        });\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLArabicText() throws Exception {\n+        addRTLArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverTextFlow(x, Y_OFFSET);\n+            if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+            Assertions.assertTrue(charIndex < textOneLength);\n+            Assertions.assertTrue(textFlowCharIndex < textOneLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLEnglishText() throws Exception {\n+        addRTLEnglishText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverTextFlow(x, Y_OFFSET);\n+            if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+            Assertions.assertTrue(charIndex < textOneLength);\n+            Assertions.assertTrue(textFlowCharIndex < textOneLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLMultipleTextNodes() throws Exception {\n+        addMultiNodeRTLEnglishArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+\n+        double x = WIDTH - X_LEADING_OFFSET;\n+        while (x > X_LEADING_OFFSET) {\n+            moveMouseOverTextFlow(x, Y_OFFSET);\n+            if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+            Assertions.assertTrue(charIndex < Math.max(textOneLength, textTwoLength));\n+            Assertions.assertTrue(textFlowCharIndex < textOneLength + textTwoLength);\n+            x -= step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLMultipleMultiLineEnglishArabicTextNodes() throws Exception {\n+        addMultiLineMultiNodeRTLEnglishArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+        int textThreeLength = textThree.getText().length();\n+\n+        for (int y = 0; y < 3; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < Math.max(textThreeLength, Math.max(textOneLength, textTwoLength)));\n+                Assertions.assertTrue(textFlowCharIndex < textOneLength + textTwoLength + textThreeLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLMultipleMultiLineEnglishTextNodes() throws Exception {\n+        addMutliLineMultiNodeRTLEnglishText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+        int textThreeLength = textThree.getText().length();\n+\n+        for (int y = 0; y < 3; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < Math.max(textThreeLength, Math.max(textOneLength, textTwoLength)));\n+                Assertions.assertTrue(textFlowCharIndex < textOneLength + textTwoLength + textThreeLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndTextFlowHitInfoForRTLMultipleMultiLineArabicTextNodes() throws Exception {\n+        addMutliLineMultiNodeRTLArabicText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+        int textThreeLength = textThree.getText().length();\n+\n+        for (int y = 0; y < 3; y++) {\n+            double x = WIDTH - X_LEADING_OFFSET;\n+            while (x > X_LEADING_OFFSET) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assertions.assertEquals(charIndex, insertionIndex);\n+                } else {\n+                    Assertions.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                if (textFlowIsLeading) {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex);\n+                } else {\n+                    Assertions.assertEquals(textFlowCharIndex, textFlowInsertionIndex - 1);\n+                }\n+                Assertions.assertTrue(charIndex < Math.max(textThreeLength, Math.max(textOneLength, textTwoLength)));\n+                Assertions.assertTrue(textFlowCharIndex < textOneLength + textTwoLength + textThreeLength);\n+                x -= step();\n+            }\n+        }\n+    }\n+\n+    private void handleMouseEvent(MouseEvent event) {\n+        PickResult pick = event.getPickResult();\n+        Node n = pick.getIntersectedNode();\n+\n+        if (n != null && n instanceof Text t) {\n+            Point3D p3 = pick.getIntersectedPoint();\n+            Point2D p = new Point2D(p3.getX(), p3.getY());\n+            HitInfo hitInfo = t.hitTest(p);\n+\n+            isLeading = hitInfo.isLeading();\n+            charIndex = hitInfo.getCharIndex();\n+            insertionIndex = hitInfo.getInsertionIndex();\n+        }\n+\n+        Point2D point = new Point2D(event.getX(), event.getY());\n+        HitInfo textFlowHitInfo = textFlow.hitTest(point);\n+        textFlowIsLeading = textFlowHitInfo.isLeading();\n+        textFlowCharIndex = textFlowHitInfo.getCharIndex();\n+        textFlowInsertionIndex = textFlowHitInfo.getInsertionIndex();\n+    }\n+\n+    private double step() {\n+        return 1.0 + random.nextDouble() * 8.0;\n+    }\n+\n+    @AfterEach\n+    public void resetUI() {\n+        Platform.runLater(() -> {\n+            textFlow.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textOne.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textTwo.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textThree.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+        });\n+    }\n+\n+    @BeforeEach\n+    public void setupUI() {\n+        Platform.runLater(() -> {\n+            textFlow.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textOne.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textTwo.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+            textThree.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+        });\n+    }\n+\n+    @BeforeAll\n+    public static void initFX() {\n+        long seed = new Random().nextLong();\n+        System.out.println(\"seed=\" + seed);\n+        random = new Random(seed);\n+\n+        Util.launch(startupLatch, TestApp.class);\n+    }\n+\n+    @AfterAll\n+    public static void exit() {\n+        Util.shutdown(stage);\n+    }\n+\n+    public static class TestApp extends Application {\n+        @Override\n+        public void start(Stage primaryStage) {\n+            robot = new Robot();\n+            stage = primaryStage;\n+\n+            textOne = new Text();\n+            textTwo = new Text();\n+            textThree = new Text();\n+            textFlow = new TextFlow();\n+            vBox = new VBox();\n+\n+            scene = new Scene(vBox, WIDTH, HEIGHT);\n+            scene.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+            stage.setScene(scene);\n+            stage.initStyle(StageStyle.UNDECORATED);\n+            stage.setOnShown(event -> Platform.runLater(startupLatch::countDown));\n+            stage.setAlwaysOnTop(true);\n+            stage.show();\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/RTLTextFlowCharacterIndexTest.java","additions":460,"deletions":0,"binary":false,"changes":460,"status":"added"}]}