{"files":[{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Summary: Internal Interfaces for memory buffers in libxml2\n- * Description: this module describes most of the new xmlBuf buffer\n- *              entry points, those are private routines, with a\n- *              few exceptions exported in tree.h. This was added\n- *              in 2.9.0.\n- *\n- * Copy: See Copyright for the status of this software.\n- *\n- * Author: Daniel Veillard\n- *\/\n-\n-#ifndef __XML_BUF_H__\n-#define __XML_BUF_H__\n-\n-#include <libxml\/tree.h>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-xmlBufPtr xmlBufCreate(void);\n-xmlBufPtr xmlBufCreateSize(size_t size);\n-xmlBufPtr xmlBufCreateStatic(void *mem, size_t size);\n-\n-int xmlBufSetAllocationScheme(xmlBufPtr buf,\n-                              xmlBufferAllocationScheme scheme);\n-int xmlBufGetAllocationScheme(xmlBufPtr buf);\n-\n-void xmlBufFree(xmlBufPtr buf);\n-void xmlBufEmpty(xmlBufPtr buf);\n-\n-\/* size_t xmlBufShrink(xmlBufPtr buf, size_t len); *\/\n-int xmlBufGrow(xmlBufPtr buf, int len);\n-int xmlBufResize(xmlBufPtr buf, size_t len);\n-\n-int xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len);\n-int xmlBufCat(xmlBufPtr buf, const xmlChar *str);\n-int xmlBufCCat(xmlBufPtr buf, const char *str);\n-int xmlBufWriteQuotedString(xmlBufPtr buf, const xmlChar *string);\n-\n-size_t xmlBufAvail(const xmlBufPtr buf);\n-size_t xmlBufLength(const xmlBufPtr buf);\n-\/* size_t xmlBufUse(const xmlBufPtr buf); *\/\n-int xmlBufIsEmpty(const xmlBufPtr buf);\n-int xmlBufAddLen(xmlBufPtr buf, size_t len);\n-\n-\/* const xmlChar * xmlBufContent(const xmlBuf *buf); *\/\n-\/* const xmlChar * xmlBufEnd(xmlBufPtr buf); *\/\n-\n-xmlChar * xmlBufDetach(xmlBufPtr buf);\n-\n-size_t xmlBufDump(FILE *file, xmlBufPtr buf);\n-\n-xmlBufPtr xmlBufFromBuffer(xmlBufferPtr buffer);\n-xmlBufferPtr xmlBufBackToBuffer(xmlBufPtr buf);\n-int xmlBufMergeBuffer(xmlBufPtr buf, xmlBufferPtr buffer);\n-\n-int xmlBufResetInput(xmlBufPtr buf, xmlParserInputPtr input);\n-size_t xmlBufGetInputBase(xmlBufPtr buf, xmlParserInputPtr input);\n-int xmlBufSetInputBaseCur(xmlBufPtr buf, xmlParserInputPtr input,\n-                          size_t base, size_t cur);\n-#ifdef __cplusplus\n-}\n-#endif\n-#endif \/* __XML_BUF_H__ *\/\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/buf.h","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,1982 +0,0 @@\n-\/*\n- * nanoftp.c: basic FTP client support\n- *\n- *  Reference: RFC 959\n- *\/\n-\n-#ifdef TESTING\n-#define STANDALONE\n-#define HAVE_UNISTD_H\n-#define HAVE_SYS_SOCKET_H\n-#define HAVE_NETINET_IN_H\n-#define HAVE_NETDB_H\n-#define HAVE_SYS_TIME_H\n-#endif \/* TESTING *\/\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-\n-#ifdef LIBXML_FTP_ENABLED\n-#include <string.h>\n-#include <stdlib.h>\n-#include <errno.h>\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#elif defined (_WIN32)\n-#include <io.h>\n-#endif\n-#ifdef HAVE_SYS_SOCKET_H\n-#include <sys\/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#include <netinet\/in.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#include <arpa\/inet.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#include <netdb.h>\n-#endif\n-#ifdef HAVE_FCNTL_H\n-#include <fcntl.h>\n-#endif\n-#ifdef HAVE_SYS_TIME_H\n-#include <sys\/time.h>\n-#endif\n-#ifdef HAVE_SYS_SELECT_H\n-#include <sys\/select.h>\n-#endif\n-#ifdef HAVE_SYS_SOCKET_H\n-#include <sys\/socket.h>\n-#endif\n-\n-#include <libxml\/xmlmemory.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/xmlerror.h>\n-#include <libxml\/uri.h>\n-#include <libxml\/nanoftp.h>\n-\n-#include \"private\/error.h\"\n-#include \"private\/io.h\"\n-\n-#if defined(_WIN32)\n-#include <wsockcompat.h>\n-#endif\n-\n-\/**\n- * A couple portability macros\n- *\/\n-#ifndef _WINSOCKAPI_\n-#define closesocket(s) close(s)\n-#endif\n-\n-#ifndef XML_SOCKLEN_T\n-#define XML_SOCKLEN_T unsigned int\n-#endif\n-\n-#define GETHOSTBYNAME_ARG_CAST (char *)\n-#define SEND_ARG2_CAST (char *)\n-\n-#define FTP_COMMAND_OK        200\n-#define FTP_SYNTAX_ERROR    500\n-#define FTP_GET_PASSWD        331\n-#define FTP_BUF_SIZE        1024\n-\n-#define XML_NANO_MAX_URLBUF    4096\n-\n-typedef struct xmlNanoFTPCtxt {\n-    char *protocol;    \/* the protocol name *\/\n-    char *hostname;    \/* the host name *\/\n-    int port;        \/* the port *\/\n-    char *path;        \/* the path within the URL *\/\n-    char *user;        \/* user string *\/\n-    char *passwd;    \/* passwd string *\/\n-#ifdef SUPPORT_IP6\n-    struct sockaddr_storage ftpAddr; \/* this is large enough to hold IPv6 address*\/\n-#else\n-    struct sockaddr_in ftpAddr; \/* the socket address struct *\/\n-#endif\n-    int passive;    \/* currently we support only passive !!! *\/\n-    SOCKET controlFd;    \/* the file descriptor for the control socket *\/\n-    SOCKET dataFd;    \/* the file descriptor for the data socket *\/\n-    int state;        \/* WRITE \/ READ \/ CLOSED *\/\n-    int returnValue;    \/* the protocol return value *\/\n-    \/* buffer for data received from the control connection *\/\n-    char controlBuf[FTP_BUF_SIZE + 1];\n-    int controlBufIndex;\n-    int controlBufUsed;\n-    int controlBufAnswer;\n-} xmlNanoFTPCtxt, *xmlNanoFTPCtxtPtr;\n-\n-static int initialized = 0;\n-static char *proxy = NULL;    \/* the proxy name if any *\/\n-static int proxyPort = 0;    \/* the proxy port if any *\/\n-static char *proxyUser = NULL;    \/* user for proxy authentication *\/\n-static char *proxyPasswd = NULL;\/* passwd for proxy authentication *\/\n-static int proxyType = 0;    \/* uses TYPE or a@b ? *\/\n-\n-#ifdef SUPPORT_IP6\n-static\n-int have_ipv6(void) {\n-    int s;\n-\n-    s = socket (AF_INET6, SOCK_STREAM, 0);\n-    if (s != -1) {\n-    close (s);\n-    return (1);\n-    }\n-    return (0);\n-}\n-#endif\n-\n-\/**\n- * xmlFTPErrMemory:\n- * @extra:  extra information\n- *\n- * Handle an out of memory condition\n- *\/\n-static void\n-xmlFTPErrMemory(const char *extra ATTRIBUTE_UNUSED)\n-{\n-    xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_FTP, NULL);\n-}\n-\n-\/**\n- * xmlNanoFTPInit:\n- *\n- * Initialize the FTP protocol layer.\n- * Currently it just checks for proxy information,\n- * and get the hostname\n- *\/\n-\n-void\n-xmlNanoFTPInit(void) {\n-    const char *env;\n-#ifdef _WINSOCKAPI_\n-    WSADATA wsaData;\n-#endif\n-\n-    if (initialized)\n-    return;\n-\n-#ifdef _WINSOCKAPI_\n-    if (WSAStartup(MAKEWORD(1, 1), &wsaData) != 0)\n-    return;\n-#endif\n-\n-    proxyPort = 21;\n-    env = getenv(\"no_proxy\");\n-    if (env && ((env[0] == '*' ) && (env[1] == 0)))\n-    return;\n-    env = getenv(\"ftp_proxy\");\n-    if (env != NULL) {\n-    xmlNanoFTPScanProxy(env);\n-    } else {\n-    env = getenv(\"FTP_PROXY\");\n-    if (env != NULL) {\n-        xmlNanoFTPScanProxy(env);\n-    }\n-    }\n-    env = getenv(\"ftp_proxy_user\");\n-    if (env != NULL) {\n-    proxyUser = xmlMemStrdup(env);\n-    }\n-    env = getenv(\"ftp_proxy_password\");\n-    if (env != NULL) {\n-    proxyPasswd = xmlMemStrdup(env);\n-    }\n-    initialized = 1;\n-}\n-\n-\/**\n- * xmlNanoFTPCleanup:\n- *\n- * Cleanup the FTP protocol layer. This cleanup proxy information.\n- *\/\n-\n-void\n-xmlNanoFTPCleanup(void) {\n-    if (proxy != NULL) {\n-    xmlFree(proxy);\n-    proxy = NULL;\n-    }\n-    if (proxyUser != NULL) {\n-    xmlFree(proxyUser);\n-    proxyUser = NULL;\n-    }\n-    if (proxyPasswd != NULL) {\n-    xmlFree(proxyPasswd);\n-    proxyPasswd = NULL;\n-    }\n-#ifdef _WINSOCKAPI_\n-    if (initialized)\n-    WSACleanup();\n-#endif\n-    initialized = 0;\n-}\n-\n-\/**\n- * xmlNanoFTPProxy:\n- * @host:  the proxy host name\n- * @port:  the proxy port\n- * @user:  the proxy user name\n- * @passwd:  the proxy password\n- * @type:  the type of proxy 1 for using SITE, 2 for USER a@b\n- *\n- * Setup the FTP proxy information.\n- * This can also be done by using ftp_proxy ftp_proxy_user and\n- * ftp_proxy_password environment variables.\n- *\/\n-\n-void\n-xmlNanoFTPProxy(const char *host, int port, const char *user,\n-            const char *passwd, int type) {\n-    if (proxy != NULL) {\n-    xmlFree(proxy);\n-    proxy = NULL;\n-    }\n-    if (proxyUser != NULL) {\n-    xmlFree(proxyUser);\n-    proxyUser = NULL;\n-    }\n-    if (proxyPasswd != NULL) {\n-    xmlFree(proxyPasswd);\n-    proxyPasswd = NULL;\n-    }\n-    if (host)\n-    proxy = xmlMemStrdup(host);\n-    if (user)\n-    proxyUser = xmlMemStrdup(user);\n-    if (passwd)\n-    proxyPasswd = xmlMemStrdup(passwd);\n-    proxyPort = port;\n-    proxyType = type;\n-}\n-\n-\/**\n- * xmlNanoFTPScanURL:\n- * @ctx:  an FTP context\n- * @URL:  The URL used to initialize the context\n- *\n- * (Re)Initialize an FTP context by parsing the URL and finding\n- * the protocol host port and path it indicates.\n- *\/\n-\n-static void\n-xmlNanoFTPScanURL(void *ctx, const char *URL) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    xmlURIPtr uri;\n-\n-    \/*\n-     * Clear any existing data from the context\n-     *\/\n-    if (ctxt->protocol != NULL) {\n-        xmlFree(ctxt->protocol);\n-    ctxt->protocol = NULL;\n-    }\n-    if (ctxt->hostname != NULL) {\n-        xmlFree(ctxt->hostname);\n-    ctxt->hostname = NULL;\n-    }\n-    if (ctxt->path != NULL) {\n-        xmlFree(ctxt->path);\n-    ctxt->path = NULL;\n-    }\n-    if (URL == NULL) return;\n-\n-    uri = xmlParseURIRaw(URL, 1);\n-    if (uri == NULL)\n-    return;\n-\n-    if ((uri->scheme == NULL) || (uri->server == NULL)) {\n-    xmlFreeURI(uri);\n-    return;\n-    }\n-\n-    ctxt->protocol = xmlMemStrdup(uri->scheme);\n-    ctxt->hostname = xmlMemStrdup(uri->server);\n-    if (uri->path != NULL)\n-    ctxt->path = xmlMemStrdup(uri->path);\n-    else\n-    ctxt->path = xmlMemStrdup(\"\/\");\n-    if (uri->port != 0)\n-    ctxt->port = uri->port;\n-\n-    if (uri->user != NULL) {\n-    char *cptr;\n-    if ((cptr=strchr(uri->user, ':')) == NULL)\n-        ctxt->user = xmlMemStrdup(uri->user);\n-    else {\n-        ctxt->user = (char *)xmlStrndup((xmlChar *)uri->user,\n-                (cptr - uri->user));\n-        ctxt->passwd = xmlMemStrdup(cptr+1);\n-    }\n-    }\n-\n-    xmlFreeURI(uri);\n-\n-}\n-\n-\/**\n- * xmlNanoFTPUpdateURL:\n- * @ctx:  an FTP context\n- * @URL:  The URL used to update the context\n- *\n- * Update an FTP context by parsing the URL and finding\n- * new path it indicates. If there is an error in the\n- * protocol, hostname, port or other information, the\n- * error is raised. It indicates a new connection has to\n- * be established.\n- *\n- * Returns 0 if Ok, -1 in case of error (other host).\n- *\/\n-\n-int\n-xmlNanoFTPUpdateURL(void *ctx, const char *URL) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    xmlURIPtr uri;\n-\n-    if (URL == NULL)\n-    return(-1);\n-    if (ctxt == NULL)\n-    return(-1);\n-    if (ctxt->protocol == NULL)\n-    return(-1);\n-    if (ctxt->hostname == NULL)\n-    return(-1);\n-\n-    uri = xmlParseURIRaw(URL, 1);\n-    if (uri == NULL)\n-    return(-1);\n-\n-    if ((uri->scheme == NULL) || (uri->server == NULL)) {\n-    xmlFreeURI(uri);\n-    return(-1);\n-    }\n-    if ((strcmp(ctxt->protocol, uri->scheme)) ||\n-    (strcmp(ctxt->hostname, uri->server)) ||\n-    ((uri->port != 0) && (ctxt->port != uri->port))) {\n-    xmlFreeURI(uri);\n-    return(-1);\n-    }\n-\n-    if (uri->port != 0)\n-    ctxt->port = uri->port;\n-\n-    if (ctxt->path != NULL) {\n-    xmlFree(ctxt->path);\n-    ctxt->path = NULL;\n-    }\n-\n-    if (uri->path == NULL)\n-        ctxt->path = xmlMemStrdup(\"\/\");\n-    else\n-    ctxt->path = xmlMemStrdup(uri->path);\n-\n-    xmlFreeURI(uri);\n-\n-    return(0);\n-}\n-\n-\/**\n- * xmlNanoFTPScanProxy:\n- * @URL:  The proxy URL used to initialize the proxy context\n- *\n- * (Re)Initialize the FTP Proxy context by parsing the URL and finding\n- * the protocol host port it indicates.\n- * Should be like ftp:\/\/myproxy\/ or ftp:\/\/myproxy:3128\/\n- * A NULL URL cleans up proxy information.\n- *\/\n-\n-void\n-xmlNanoFTPScanProxy(const char *URL) {\n-    xmlURIPtr uri;\n-\n-    if (proxy != NULL) {\n-        xmlFree(proxy);\n-    proxy = NULL;\n-    }\n-    proxyPort = 0;\n-\n-    if (URL == NULL) return;\n-\n-    uri = xmlParseURIRaw(URL, 1);\n-    if ((uri == NULL) || (uri->scheme == NULL) ||\n-    (strcmp(uri->scheme, \"ftp\")) || (uri->server == NULL)) {\n-    __xmlIOErr(XML_FROM_FTP, XML_FTP_URL_SYNTAX, \"Syntax Error\\n\");\n-    if (uri != NULL)\n-        xmlFreeURI(uri);\n-    return;\n-    }\n-\n-    proxy = xmlMemStrdup(uri->server);\n-    if (uri->port != 0)\n-    proxyPort = uri->port;\n-\n-    xmlFreeURI(uri);\n-}\n-\n-\/**\n- * xmlNanoFTPNewCtxt:\n- * @URL:  The URL used to initialize the context\n- *\n- * Allocate and initialize a new FTP context.\n- *\n- * Returns an FTP context or NULL in case of error.\n- *\/\n-\n-void*\n-xmlNanoFTPNewCtxt(const char *URL) {\n-    xmlNanoFTPCtxtPtr ret;\n-    char *unescaped;\n-\n-    ret = (xmlNanoFTPCtxtPtr) xmlMalloc(sizeof(xmlNanoFTPCtxt));\n-    if (ret == NULL) {\n-        xmlFTPErrMemory(\"allocating FTP context\");\n-        return(NULL);\n-    }\n-\n-    memset(ret, 0, sizeof(xmlNanoFTPCtxt));\n-    ret->port = 21;\n-    ret->passive = 1;\n-    ret->returnValue = 0;\n-    ret->controlBufIndex = 0;\n-    ret->controlBufUsed = 0;\n-    ret->controlFd = INVALID_SOCKET;\n-\n-    unescaped = xmlURIUnescapeString(URL, 0, NULL);\n-    if (unescaped != NULL) {\n-    xmlNanoFTPScanURL(ret, unescaped);\n-    xmlFree(unescaped);\n-    } else if (URL != NULL)\n-    xmlNanoFTPScanURL(ret, URL);\n-\n-    return(ret);\n-}\n-\n-\/**\n- * xmlNanoFTPFreeCtxt:\n- * @ctx:  an FTP context\n- *\n- * Frees the context after closing the connection.\n- *\/\n-\n-void\n-xmlNanoFTPFreeCtxt(void * ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    if (ctxt == NULL) return;\n-    if (ctxt->hostname != NULL) xmlFree(ctxt->hostname);\n-    if (ctxt->protocol != NULL) xmlFree(ctxt->protocol);\n-    if (ctxt->path != NULL) xmlFree(ctxt->path);\n-    if (ctxt->user != NULL) xmlFree(ctxt->user);\n-    if (ctxt->passwd != NULL) xmlFree(ctxt->passwd);\n-    ctxt->passive = 1;\n-    if (ctxt->controlFd != INVALID_SOCKET) closesocket(ctxt->controlFd);\n-    ctxt->controlFd = INVALID_SOCKET;\n-    ctxt->controlBufIndex = -1;\n-    ctxt->controlBufUsed = -1;\n-    xmlFree(ctxt);\n-}\n-\n-\/**\n- * xmlNanoFTPParseResponse:\n- * @buf:  the buffer containing the response\n- * @len:  the buffer length\n- *\n- * Parsing of the server answer, we just extract the code.\n- *\n- * returns 0 for errors\n- *     +XXX for last line of response\n- *     -XXX for response to be continued\n- *\/\n-static int\n-xmlNanoFTPParseResponse(char *buf, int len) {\n-    int val = 0;\n-\n-    if (len < 3) return(-1);\n-    if ((*buf >= '0') && (*buf <= '9'))\n-        val = val * 10 + (*buf - '0');\n-    else\n-        return(0);\n-    buf++;\n-    if ((*buf >= '0') && (*buf <= '9'))\n-        val = val * 10 + (*buf - '0');\n-    else\n-        return(0);\n-    buf++;\n-    if ((*buf >= '0') && (*buf <= '9'))\n-        val = val * 10 + (*buf - '0');\n-    else\n-        return(0);\n-    buf++;\n-    if (*buf == '-')\n-        return(-val);\n-    return(val);\n-}\n-\n-\/**\n- * xmlNanoFTPGetMore:\n- * @ctx:  an FTP context\n- *\n- * Read more information from the FTP control connection\n- * Returns the number of bytes read, < 0 indicates an error\n- *\/\n-static int\n-xmlNanoFTPGetMore(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    int len;\n-    int size;\n-\n-    if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);\n-\n-    if ((ctxt->controlBufIndex < 0) || (ctxt->controlBufIndex > FTP_BUF_SIZE)) {\n-    return(-1);\n-    }\n-\n-    if ((ctxt->controlBufUsed < 0) || (ctxt->controlBufUsed > FTP_BUF_SIZE)) {\n-    return(-1);\n-    }\n-    if (ctxt->controlBufIndex > ctxt->controlBufUsed) {\n-    return(-1);\n-    }\n-\n-    \/*\n-     * First pack the control buffer\n-     *\/\n-    if (ctxt->controlBufIndex > 0) {\n-    memmove(&ctxt->controlBuf[0], &ctxt->controlBuf[ctxt->controlBufIndex],\n-        ctxt->controlBufUsed - ctxt->controlBufIndex);\n-    ctxt->controlBufUsed -= ctxt->controlBufIndex;\n-    ctxt->controlBufIndex = 0;\n-    }\n-    size = FTP_BUF_SIZE - ctxt->controlBufUsed;\n-    if (size == 0) {\n-    return(0);\n-    }\n-\n-    \/*\n-     * Read the amount left on the control connection\n-     *\/\n-    if ((len = recv(ctxt->controlFd, &ctxt->controlBuf[ctxt->controlBufIndex],\n-            size, 0)) < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"recv failed\");\n-    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    ctxt->controlBufUsed += len;\n-    ctxt->controlBuf[ctxt->controlBufUsed] = 0;\n-\n-    return(len);\n-}\n-\n-\/**\n- * xmlNanoFTPReadResponse:\n- * @ctx:  an FTP context\n- *\n- * Read the response from the FTP server after a command.\n- * Returns the code number\n- *\/\n-static int\n-xmlNanoFTPReadResponse(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char *ptr, *end;\n-    int len;\n-    int res = -1, cur = -1;\n-\n-    if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);\n-\n-get_more:\n-    \/*\n-     * Assumes everything up to controlBuf[controlBufIndex] has been read\n-     * and analyzed.\n-     *\/\n-    len = xmlNanoFTPGetMore(ctx);\n-    if (len < 0) {\n-        return(-1);\n-    }\n-    if ((ctxt->controlBufUsed == 0) && (len == 0)) {\n-        return(-1);\n-    }\n-    ptr = &ctxt->controlBuf[ctxt->controlBufIndex];\n-    end = &ctxt->controlBuf[ctxt->controlBufUsed];\n-\n-    while (ptr < end) {\n-        cur = xmlNanoFTPParseResponse(ptr, end - ptr);\n-    if (cur > 0) {\n-        \/*\n-         * Successfully scanned the control code, scratch\n-         * till the end of the line, but keep the index to be\n-         * able to analyze the result if needed.\n-         *\/\n-        res = cur;\n-        ptr += 3;\n-        ctxt->controlBufAnswer = ptr - ctxt->controlBuf;\n-        while ((ptr < end) && (*ptr != '\\n')) ptr++;\n-        if (*ptr == '\\n') ptr++;\n-        if (*ptr == '\\r') ptr++;\n-        break;\n-    }\n-    while ((ptr < end) && (*ptr != '\\n')) ptr++;\n-    if (ptr >= end) {\n-        ctxt->controlBufIndex = ctxt->controlBufUsed;\n-        goto get_more;\n-    }\n-    if (*ptr != '\\r') ptr++;\n-    }\n-\n-    if (res < 0) goto get_more;\n-    ctxt->controlBufIndex = ptr - ctxt->controlBuf;\n-\n-    return(res \/ 100);\n-}\n-\n-\/**\n- * xmlNanoFTPGetResponse:\n- * @ctx:  an FTP context\n- *\n- * Get the response from the FTP server after a command.\n- * Returns the code number\n- *\/\n-\n-int\n-xmlNanoFTPGetResponse(void *ctx) {\n-    int res;\n-\n-    res = xmlNanoFTPReadResponse(ctx);\n-\n-    return(res);\n-}\n-\n-\/**\n- * xmlNanoFTPCheckResponse:\n- * @ctx:  an FTP context\n- *\n- * Check if there is a response from the FTP server after a command.\n- * Returns the code number, or 0\n- *\/\n-\n-int\n-xmlNanoFTPCheckResponse(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    fd_set rfd;\n-    struct timeval tv;\n-\n-    if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);\n-    tv.tv_sec = 0;\n-    tv.tv_usec = 0;\n-    FD_ZERO(&rfd);\n-    FD_SET(ctxt->controlFd, &rfd);\n-    switch(select(ctxt->controlFd + 1, &rfd, NULL, NULL, &tv)) {\n-    case 0:\n-        return(0);\n-    case -1:\n-        __xmlIOErr(XML_FROM_FTP, 0, \"select\");\n-        return(-1);\n-\n-    }\n-\n-    return(xmlNanoFTPReadResponse(ctx));\n-}\n-\n-\/**\n- * Send the user authentication\n- *\/\n-\n-static int\n-xmlNanoFTPSendUser(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[200];\n-    int len;\n-    int res;\n-\n-    if (ctxt->user == NULL)\n-    snprintf(buf, sizeof(buf), \"USER anonymous\\r\\n\");\n-    else\n-    snprintf(buf, sizeof(buf), \"USER %s\\r\\n\", ctxt->user);\n-    buf[sizeof(buf) - 1] = 0;\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * Send the password authentication\n- *\/\n-\n-static int\n-xmlNanoFTPSendPasswd(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[200];\n-    int len;\n-    int res;\n-\n-    if (ctxt->passwd == NULL)\n-    snprintf(buf, sizeof(buf), \"PASS anonymous@\\r\\n\");\n-    else\n-    snprintf(buf, sizeof(buf), \"PASS %s\\r\\n\", ctxt->passwd);\n-    buf[sizeof(buf) - 1] = 0;\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlNanoFTPQuit:\n- * @ctx:  an FTP context\n- *\n- * Send a QUIT command to the server\n- *\n- * Returns -1 in case of error, 0 otherwise\n- *\/\n-\n-\n-int\n-xmlNanoFTPQuit(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[200];\n-    int len, res;\n-\n-    if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);\n-\n-    snprintf(buf, sizeof(buf), \"QUIT\\r\\n\");\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlNanoFTPConnect:\n- * @ctx:  an FTP context\n- *\n- * Tries to open a control connection\n- *\n- * Returns -1 in case of error, 0 otherwise\n- *\/\n-\n-int\n-xmlNanoFTPConnect(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    struct hostent *hp;\n-    int port;\n-    int res;\n-    int addrlen = sizeof (struct sockaddr_in);\n-\n-    if (ctxt == NULL)\n-    return(-1);\n-    if (ctxt->hostname == NULL)\n-    return(-1);\n-\n-    \/*\n-     * do the blocking DNS query.\n-     *\/\n-    if (proxy) {\n-        port = proxyPort;\n-    } else {\n-    port = ctxt->port;\n-    }\n-    if (port == 0)\n-    port = 21;\n-\n-    memset (&ctxt->ftpAddr, 0, sizeof(ctxt->ftpAddr));\n-\n-#ifdef SUPPORT_IP6\n-    if (have_ipv6 ()) {\n-    struct addrinfo hints, *tmp, *result;\n-\n-    result = NULL;\n-    memset (&hints, 0, sizeof(hints));\n-    hints.ai_socktype = SOCK_STREAM;\n-\n-    if (proxy) {\n-        if (getaddrinfo (proxy, NULL, &hints, &result) != 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"getaddrinfo failed\");\n-        return (-1);\n-        }\n-    }\n-    else\n-        if (getaddrinfo (ctxt->hostname, NULL, &hints, &result) != 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"getaddrinfo failed\");\n-        return (-1);\n-        }\n-\n-    for (tmp = result; tmp; tmp = tmp->ai_next)\n-        if (tmp->ai_family == AF_INET || tmp->ai_family == AF_INET6)\n-        break;\n-\n-    if (!tmp) {\n-        if (result)\n-        freeaddrinfo (result);\n-        __xmlIOErr(XML_FROM_FTP, 0, \"getaddrinfo failed\");\n-        return (-1);\n-    }\n-    if ((size_t)tmp->ai_addrlen > sizeof(ctxt->ftpAddr)) {\n-        if (result)\n-        freeaddrinfo (result);\n-        __xmlIOErr(XML_FROM_FTP, 0, \"gethostbyname address mismatch\");\n-        return (-1);\n-    }\n-    if (tmp->ai_family == AF_INET6) {\n-        memcpy (&ctxt->ftpAddr, tmp->ai_addr, tmp->ai_addrlen);\n-        ((struct sockaddr_in6 *) &ctxt->ftpAddr)->sin6_port = htons (port);\n-        ctxt->controlFd = socket (AF_INET6, SOCK_STREAM, 0);\n-    }\n-    else {\n-        memcpy (&ctxt->ftpAddr, tmp->ai_addr, tmp->ai_addrlen);\n-        ((struct sockaddr_in *) &ctxt->ftpAddr)->sin_port = htons (port);\n-        ctxt->controlFd = socket (AF_INET, SOCK_STREAM, 0);\n-    }\n-    addrlen = tmp->ai_addrlen;\n-    freeaddrinfo (result);\n-    }\n-    else\n-#endif\n-    {\n-    if (proxy)\n-        hp = gethostbyname (GETHOSTBYNAME_ARG_CAST proxy);\n-    else\n-        hp = gethostbyname (GETHOSTBYNAME_ARG_CAST ctxt->hostname);\n-    if (hp == NULL) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"gethostbyname failed\");\n-        return (-1);\n-    }\n-    if ((unsigned int) hp->h_length >\n-        sizeof(((struct sockaddr_in *)&ctxt->ftpAddr)->sin_addr)) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"gethostbyname address mismatch\");\n-        return (-1);\n-    }\n-\n-    \/*\n-     * Prepare the socket\n-     *\/\n-    ((struct sockaddr_in *)&ctxt->ftpAddr)->sin_family = AF_INET;\n-    memcpy (&((struct sockaddr_in *)&ctxt->ftpAddr)->sin_addr,\n-        hp->h_addr_list[0], hp->h_length);\n-    ((struct sockaddr_in *)&ctxt->ftpAddr)->sin_port =\n-             (unsigned short)htons ((unsigned short)port);\n-    ctxt->controlFd = socket (AF_INET, SOCK_STREAM, 0);\n-    addrlen = sizeof (struct sockaddr_in);\n-    }\n-\n-    if (ctxt->controlFd == INVALID_SOCKET) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"socket failed\");\n-        return(-1);\n-    }\n-\n-    \/*\n-     * Do the connect.\n-     *\/\n-    if (connect(ctxt->controlFd, (struct sockaddr *) &ctxt->ftpAddr,\n-        addrlen) < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"Failed to create a connection\");\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-    return(-1);\n-    }\n-\n-    \/*\n-     * Wait for the HELLO from the server.\n-     *\/\n-    res = xmlNanoFTPGetResponse(ctxt);\n-    if (res != 2) {\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-    return(-1);\n-    }\n-\n-    \/*\n-     * State diagram for the login operation on the FTP server\n-     *\n-     * Reference: RFC 959\n-     *\n-     *                       1\n-     * +---+   USER    +---+------------->+---+\n-     * | B |---------->| W | 2       ---->| E |\n-     * +---+           +---+------  |  -->+---+\n-     *                  | |       | | |\n-     *                3 | | 4,5   | | |\n-     *    --------------   -----  | | |\n-     *   |                      | | | |\n-     *   |                      | | | |\n-     *   |                 ---------  |\n-     *   |               1|     | |   |\n-     *   V                |     | |   |\n-     * +---+   PASS    +---+ 2  |  ------>+---+\n-     * |   |---------->| W |------------->| S |\n-     * +---+           +---+   ---------->+---+\n-     *                  | |   | |     |\n-     *                3 | |4,5| |     |\n-     *    --------------   --------   |\n-     *   |                    | |  |  |\n-     *   |                    | |  |  |\n-     *   |                 -----------\n-     *   |             1,3|   | |  |\n-     *   V                |  2| |  |\n-     * +---+   ACCT    +---+--  |   ----->+---+\n-     * |   |---------->| W | 4,5 -------->| F |\n-     * +---+           +---+------------->+---+\n-     *\n-     * Of course in case of using a proxy this get really nasty and is not\n-     * standardized at all :-(\n-     *\/\n-    if (proxy) {\n-        int len;\n-    char buf[400];\n-\n-        if (proxyUser != NULL) {\n-        \/*\n-         * We need proxy auth\n-         *\/\n-        snprintf(buf, sizeof(buf), \"USER %s\\r\\n\", proxyUser);\n-            buf[sizeof(buf) - 1] = 0;\n-            len = strlen(buf);\n-        res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-        if (res < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-        closesocket(ctxt->controlFd);\n-        ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n-        }\n-        res = xmlNanoFTPGetResponse(ctxt);\n-        switch (res) {\n-        case 2:\n-            if (proxyPasswd == NULL)\n-            break;\n-                    \/* Falls through. *\/\n-        case 3:\n-            if (proxyPasswd != NULL)\n-            snprintf(buf, sizeof(buf), \"PASS %s\\r\\n\", proxyPasswd);\n-            else\n-            snprintf(buf, sizeof(buf), \"PASS anonymous@\\r\\n\");\n-                    buf[sizeof(buf) - 1] = 0;\n-                    len = strlen(buf);\n-            res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-            if (res < 0) {\n-            __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-            closesocket(ctxt->controlFd);\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n-            }\n-            res = xmlNanoFTPGetResponse(ctxt);\n-            if (res > 3) {\n-            closesocket(ctxt->controlFd);\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(-1);\n-            }\n-            break;\n-        case 1:\n-            break;\n-        case 4:\n-        case 5:\n-        case -1:\n-        default:\n-            closesocket(ctxt->controlFd);\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(-1);\n-        }\n-    }\n-\n-    \/*\n-     * We assume we don't need more authentication to the proxy\n-     * and that it succeeded :-\\\n-     *\/\n-    switch (proxyType) {\n-        case 0:\n-        \/* we will try in sequence *\/\n-        case 1:\n-        \/* Using SITE command *\/\n-        snprintf(buf, sizeof(buf), \"SITE %s\\r\\n\", ctxt->hostname);\n-                buf[sizeof(buf) - 1] = 0;\n-                len = strlen(buf);\n-        res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-        if (res < 0) {\n-            __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n-        }\n-        res = xmlNanoFTPGetResponse(ctxt);\n-        if (res == 2) {\n-            \/* we assume it worked :-\\ 1 is error for SITE command *\/\n-            proxyType = 1;\n-            break;\n-        }\n-        if (proxyType == 1) {\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(-1);\n-        }\n-                \/* Falls through. *\/\n-        case 2:\n-        \/* USER user@host command *\/\n-        if (ctxt->user == NULL)\n-            snprintf(buf, sizeof(buf), \"USER anonymous@%s\\r\\n\",\n-                       ctxt->hostname);\n-        else\n-            snprintf(buf, sizeof(buf), \"USER %s@%s\\r\\n\",\n-                       ctxt->user, ctxt->hostname);\n-                buf[sizeof(buf) - 1] = 0;\n-                len = strlen(buf);\n-        res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-        if (res < 0) {\n-            __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n-        }\n-        res = xmlNanoFTPGetResponse(ctxt);\n-        if ((res == 1) || (res == 2)) {\n-            \/* we assume it worked :-\\ *\/\n-            proxyType = 2;\n-            return(0);\n-        }\n-        if (ctxt->passwd == NULL)\n-            snprintf(buf, sizeof(buf), \"PASS anonymous@\\r\\n\");\n-        else\n-            snprintf(buf, sizeof(buf), \"PASS %s\\r\\n\", ctxt->passwd);\n-                buf[sizeof(buf) - 1] = 0;\n-                len = strlen(buf);\n-        res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-        if (res < 0) {\n-            __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n-        }\n-        res = xmlNanoFTPGetResponse(ctxt);\n-        if ((res == 1) || (res == 2)) {\n-            \/* we assume it worked :-\\ *\/\n-            proxyType = 2;\n-            return(0);\n-        }\n-        if (proxyType == 2) {\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(-1);\n-        }\n-                \/* Falls through. *\/\n-        case 3:\n-        \/*\n-         * If you need support for other Proxy authentication scheme\n-         * send the code or at least the sequence in use.\n-         *\/\n-        default:\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    }\n-    \/*\n-     * Non-proxy handling.\n-     *\/\n-    res = xmlNanoFTPSendUser(ctxt);\n-    if (res < 0) {\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-    return(-1);\n-    }\n-    res = xmlNanoFTPGetResponse(ctxt);\n-    switch (res) {\n-    case 2:\n-        return(0);\n-    case 3:\n-        break;\n-    case 1:\n-    case 4:\n-    case 5:\n-        case -1:\n-    default:\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    res = xmlNanoFTPSendPasswd(ctxt);\n-    if (res < 0) {\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-    return(-1);\n-    }\n-    res = xmlNanoFTPGetResponse(ctxt);\n-    switch (res) {\n-    case 2:\n-        break;\n-    case 3:\n-        __xmlIOErr(XML_FROM_FTP, XML_FTP_ACCNT,\n-               \"FTP server asking for ACCNT on anonymous\\n\");\n-           \/* Falls through. *\/\n-    case 1:\n-    case 4:\n-    case 5:\n-        case -1:\n-    default:\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-\n-    return(0);\n-}\n-\n-\/**\n- * xmlNanoFTPConnectTo:\n- * @server:  an FTP server name\n- * @port:  the port (use 21 if 0)\n- *\n- * Tries to open a control connection to the given server\/port\n- *\n- * Returns an fTP context or NULL if it failed\n- *\/\n-\n-void*\n-xmlNanoFTPConnectTo(const char *server, int port) {\n-    xmlNanoFTPCtxtPtr ctxt;\n-    int res;\n-\n-    xmlNanoFTPInit();\n-    if (server == NULL)\n-    return(NULL);\n-    if (port <= 0)\n-    return(NULL);\n-    ctxt = (xmlNanoFTPCtxtPtr) xmlNanoFTPNewCtxt(NULL);\n-    if (ctxt == NULL)\n-        return(NULL);\n-    ctxt->hostname = xmlMemStrdup(server);\n-    if (ctxt->hostname == NULL) {\n-    xmlNanoFTPFreeCtxt(ctxt);\n-    return(NULL);\n-    }\n-    ctxt->port = port;\n-    res = xmlNanoFTPConnect(ctxt);\n-    if (res < 0) {\n-    xmlNanoFTPFreeCtxt(ctxt);\n-    return(NULL);\n-    }\n-    return(ctxt);\n-}\n-\n-\/**\n- * xmlNanoFTPCwd:\n- * @ctx:  an FTP context\n- * @directory:  a directory on the server\n- *\n- * Tries to change the remote directory\n- *\n- * Returns -1 in case of error, 1 if CWD worked, 0 if it failed\n- *\/\n-\n-int\n-xmlNanoFTPCwd(void *ctx, const char *directory) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[400];\n-    int len;\n-    int res;\n-\n-    if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);\n-    if (directory == NULL) return 0;\n-\n-    \/*\n-     * Expected response code for CWD:\n-     *\n-     * CWD\n-     *     250\n-     *     500, 501, 502, 421, 530, 550\n-     *\/\n-    snprintf(buf, sizeof(buf), \"CWD %s\\r\\n\", directory);\n-    buf[sizeof(buf) - 1] = 0;\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n-    }\n-    res = xmlNanoFTPGetResponse(ctxt);\n-    if (res == 4) {\n-    return(-1);\n-    }\n-    if (res == 2) return(1);\n-    if (res == 5) {\n-    return(0);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlNanoFTPDele:\n- * @ctx:  an FTP context\n- * @file:  a file or directory on the server\n- *\n- * Tries to delete an item (file or directory) from server\n- *\n- * Returns -1 in case of error, 1 if DELE worked, 0 if it failed\n- *\/\n-\n-int\n-xmlNanoFTPDele(void *ctx, const char *file) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[400];\n-    int len;\n-    int res;\n-\n-    if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET) ||\n-        (file == NULL)) return(-1);\n-\n-    \/*\n-     * Expected response code for DELE:\n-     *\n-     * DELE\n-     *       250\n-     *       450, 550\n-     *       500, 501, 502, 421, 530\n-     *\/\n-\n-    snprintf(buf, sizeof(buf), \"DELE %s\\r\\n\", file);\n-    buf[sizeof(buf) - 1] = 0;\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n-    }\n-    res = xmlNanoFTPGetResponse(ctxt);\n-    if (res == 4) {\n-    return(-1);\n-    }\n-    if (res == 2) return(1);\n-    if (res == 5) {\n-    return(0);\n-    }\n-    return(0);\n-}\n-\/**\n- * xmlNanoFTPGetConnection:\n- * @ctx:  an FTP context\n- *\n- * Try to open a data connection to the server. Currently only\n- * passive mode is supported.\n- *\n- * Returns -1 in case of error, 0 otherwise\n- *\/\n-\n-SOCKET\n-xmlNanoFTPGetConnection(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[200], *cur;\n-    int len, i;\n-    int res;\n-    unsigned char ad[6], *adp, *portp;\n-    unsigned int temp[6];\n-#ifdef SUPPORT_IP6\n-    struct sockaddr_storage dataAddr;\n-#else\n-    struct sockaddr_in dataAddr;\n-#endif\n-    XML_SOCKLEN_T dataAddrLen;\n-\n-    if (ctxt == NULL) return INVALID_SOCKET;\n-\n-    memset (&dataAddr, 0, sizeof(dataAddr));\n-#ifdef SUPPORT_IP6\n-    if ((ctxt->ftpAddr).ss_family == AF_INET6) {\n-    ctxt->dataFd = socket (AF_INET6, SOCK_STREAM, IPPROTO_TCP);\n-    ((struct sockaddr_in6 *)&dataAddr)->sin6_family = AF_INET6;\n-    dataAddrLen = sizeof(struct sockaddr_in6);\n-    } else\n-#endif\n-    {\n-    ctxt->dataFd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n-    ((struct sockaddr_in *)&dataAddr)->sin_family = AF_INET;\n-    dataAddrLen = sizeof (struct sockaddr_in);\n-    }\n-\n-    if (ctxt->dataFd == INVALID_SOCKET) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"socket failed\");\n-    return INVALID_SOCKET;\n-    }\n-\n-    if (ctxt->passive) {\n-#ifdef SUPPORT_IP6\n-    if ((ctxt->ftpAddr).ss_family == AF_INET6)\n-        snprintf (buf, sizeof(buf), \"EPSV\\r\\n\");\n-    else\n-#endif\n-        snprintf (buf, sizeof(buf), \"PASV\\r\\n\");\n-        len = strlen (buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n-        res = xmlNanoFTPReadResponse(ctx);\n-    if (res != 2) {\n-        if (res == 5) {\n-            closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-        } else {\n-        \/*\n-         * retry with an active connection\n-         *\/\n-            closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-            ctxt->passive = 0;\n-        }\n-    }\n-    cur = &ctxt->controlBuf[ctxt->controlBufAnswer];\n-    while (((*cur < '0') || (*cur > '9')) && *cur != '\\0') cur++;\n-#ifdef SUPPORT_IP6\n-    if ((ctxt->ftpAddr).ss_family == AF_INET6) {\n-        if (sscanf (cur, \"%u\", &temp[0]) != 1) {\n-        __xmlIOErr(XML_FROM_FTP, XML_FTP_EPSV_ANSWER,\n-            \"Invalid answer to EPSV\\n\");\n-        if (ctxt->dataFd != INVALID_SOCKET) {\n-            closesocket (ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        }\n-        return INVALID_SOCKET;\n-        }\n-        memcpy (&((struct sockaddr_in6 *)&dataAddr)->sin6_addr, &((struct sockaddr_in6 *)&ctxt->ftpAddr)->sin6_addr, sizeof(struct in6_addr));\n-        ((struct sockaddr_in6 *)&dataAddr)->sin6_port = htons (temp[0]);\n-    }\n-    else\n-#endif\n-    {\n-        if (sscanf (cur, \"%u,%u,%u,%u,%u,%u\", &temp[0], &temp[1], &temp[2],\n-        &temp[3], &temp[4], &temp[5]) != 6) {\n-        __xmlIOErr(XML_FROM_FTP, XML_FTP_PASV_ANSWER,\n-            \"Invalid answer to PASV\\n\");\n-        if (ctxt->dataFd != INVALID_SOCKET) {\n-            closesocket (ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        }\n-        return INVALID_SOCKET;\n-        }\n-        for (i=0; i<6; i++) ad[i] = (unsigned char) (temp[i] & 0xff);\n-        memcpy (&((struct sockaddr_in *)&dataAddr)->sin_addr, &ad[0], 4);\n-        memcpy (&((struct sockaddr_in *)&dataAddr)->sin_port, &ad[4], 2);\n-    }\n-\n-    if (connect(ctxt->dataFd, (struct sockaddr *) &dataAddr, dataAddrLen) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"Failed to create a data connection\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n-    } else {\n-        getsockname(ctxt->dataFd, (struct sockaddr *) &dataAddr, &dataAddrLen);\n-#ifdef SUPPORT_IP6\n-    if ((ctxt->ftpAddr).ss_family == AF_INET6)\n-        ((struct sockaddr_in6 *)&dataAddr)->sin6_port = 0;\n-    else\n-#endif\n-        ((struct sockaddr_in *)&dataAddr)->sin_port = 0;\n-\n-    if (bind(ctxt->dataFd, (struct sockaddr *) &dataAddr, dataAddrLen) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"bind failed\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n-        getsockname(ctxt->dataFd, (struct sockaddr *) &dataAddr, &dataAddrLen);\n-\n-    if (listen(ctxt->dataFd, 1) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"listen failed\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n-#ifdef SUPPORT_IP6\n-    if ((ctxt->ftpAddr).ss_family == AF_INET6) {\n-        char buf6[INET6_ADDRSTRLEN];\n-        inet_ntop (AF_INET6, &((struct sockaddr_in6 *)&dataAddr)->sin6_addr,\n-            buf6, INET6_ADDRSTRLEN);\n-        adp = (unsigned char *) buf6;\n-        portp = (unsigned char *) &((struct sockaddr_in6 *)&dataAddr)->sin6_port;\n-        snprintf (buf, sizeof(buf), \"EPRT |2|%s|%s|\\r\\n\", adp, portp);\n-        } else\n-#endif\n-    {\n-        adp = (unsigned char *) &((struct sockaddr_in *)&dataAddr)->sin_addr;\n-        portp = (unsigned char *) &((struct sockaddr_in *)&dataAddr)->sin_port;\n-        snprintf (buf, sizeof(buf), \"PORT %d,%d,%d,%d,%d,%d\\r\\n\",\n-        adp[0] & 0xff, adp[1] & 0xff, adp[2] & 0xff, adp[3] & 0xff,\n-        portp[0] & 0xff, portp[1] & 0xff);\n-    }\n-\n-        buf[sizeof(buf) - 1] = 0;\n-        len = strlen(buf);\n-\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n-        res = xmlNanoFTPGetResponse(ctxt);\n-    if (res != 2) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-        }\n-    }\n-    return(ctxt->dataFd);\n-\n-}\n-\n-\/**\n- * xmlNanoFTPCloseConnection:\n- * @ctx:  an FTP context\n- *\n- * Close the data connection from the server\n- *\n- * Returns -1 in case of error, 0 otherwise\n- *\/\n-\n-int\n-xmlNanoFTPCloseConnection(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    int res;\n-    fd_set rfd, efd;\n-    struct timeval tv;\n-\n-    if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);\n-\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    tv.tv_sec = 15;\n-    tv.tv_usec = 0;\n-    FD_ZERO(&rfd);\n-    FD_SET(ctxt->controlFd, &rfd);\n-    FD_ZERO(&efd);\n-    FD_SET(ctxt->controlFd, &efd);\n-    res = select(ctxt->controlFd + 1, &rfd, NULL, &efd, &tv);\n-    if (res < 0) {\n-    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-    return(-1);\n-    }\n-    if (res == 0) {\n-    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-    } else {\n-    res = xmlNanoFTPGetResponse(ctxt);\n-    if (res != 2) {\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlNanoFTPParseList:\n- * @list:  some data listing received from the server\n- * @callback:  the user callback\n- * @userData:  the user callback data\n- *\n- * Parse at most one entry from the listing.\n- *\n- * Returns -1 in case of error, the length of data parsed otherwise\n- *\/\n-\n-static int\n-xmlNanoFTPParseList(const char *list, ftpListCallback callback, void *userData) {\n-    const char *cur = list;\n-    char filename[151];\n-    char attrib[11];\n-    char owner[11];\n-    char group[11];\n-    char month[4];\n-    int year = 0;\n-    int minute = 0;\n-    int hour = 0;\n-    int day = 0;\n-    unsigned long size = 0;\n-    int links = 0;\n-    int i;\n-\n-    if (!strncmp(cur, \"total\", 5)) {\n-        cur += 5;\n-    while (*cur == ' ') cur++;\n-    while ((*cur >= '0') && (*cur <= '9'))\n-        links = (links * 10) + (*cur++ - '0');\n-    while ((*cur == ' ') || (*cur == '\\n')  || (*cur == '\\r'))\n-        cur++;\n-    return(cur - list);\n-    } else if (*list == '+') {\n-    return(0);\n-    } else {\n-    while ((*cur == ' ') || (*cur == '\\n')  || (*cur == '\\r'))\n-        cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while (*cur != ' ') {\n-        if (i < 10)\n-        attrib[i++] = *cur;\n-        cur++;\n-        if (*cur == 0) return(0);\n-    }\n-    attrib[10] = 0;\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    while ((*cur >= '0') && (*cur <= '9'))\n-        links = (links * 10) + (*cur++ - '0');\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while (*cur != ' ') {\n-        if (i < 10)\n-        owner[i++] = *cur;\n-        cur++;\n-        if (*cur == 0) return(0);\n-    }\n-    owner[i] = 0;\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while (*cur != ' ') {\n-        if (i < 10)\n-        group[i++] = *cur;\n-        cur++;\n-        if (*cur == 0) return(0);\n-    }\n-    group[i] = 0;\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    while ((*cur >= '0') && (*cur <= '9'))\n-        size = (size * 10) + (*cur++ - '0');\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while (*cur != ' ') {\n-        if (i < 3)\n-        month[i++] = *cur;\n-        cur++;\n-        if (*cur == 0) return(0);\n-    }\n-    month[i] = 0;\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-        while ((*cur >= '0') && (*cur <= '9'))\n-        day = (day * 10) + (*cur++ - '0');\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    if ((cur[1] == 0) || (cur[2] == 0)) return(0);\n-    if ((cur[1] == ':') || (cur[2] == ':')) {\n-        while ((*cur >= '0') && (*cur <= '9'))\n-        hour = (hour * 10) + (*cur++ - '0');\n-        if (*cur == ':') cur++;\n-        while ((*cur >= '0') && (*cur <= '9'))\n-        minute = (minute * 10) + (*cur++ - '0');\n-    } else {\n-        while ((*cur >= '0') && (*cur <= '9'))\n-        year = (year * 10) + (*cur++ - '0');\n-    }\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while ((*cur != '\\n')  && (*cur != '\\r')) {\n-        if (i < 150)\n-        filename[i++] = *cur;\n-        cur++;\n-        if (*cur == 0) return(0);\n-    }\n-    filename[i] = 0;\n-    if ((*cur != '\\n') && (*cur != '\\r'))\n-        return(0);\n-    while ((*cur == '\\n')  || (*cur == '\\r'))\n-        cur++;\n-    }\n-    if (callback != NULL) {\n-        callback(userData, filename, attrib, owner, group, size, links,\n-         year, month, day, hour, minute);\n-    }\n-    return(cur - list);\n-}\n-\n-\/**\n- * xmlNanoFTPList:\n- * @ctx:  an FTP context\n- * @callback:  the user callback\n- * @userData:  the user callback data\n- * @filename:  optional files to list\n- *\n- * Do a listing on the server. All files info are passed back\n- * in the callbacks.\n- *\n- * Returns -1 in case of error, 0 otherwise\n- *\/\n-\n-int\n-xmlNanoFTPList(void *ctx, ftpListCallback callback, void *userData,\n-           const char *filename) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[4096 + 1];\n-    int len, res;\n-    int indx = 0, base;\n-    fd_set rfd, efd;\n-    struct timeval tv;\n-\n-    if (ctxt == NULL) return (-1);\n-    if (filename == NULL) {\n-        if (xmlNanoFTPCwd(ctxt, ctxt->path) < 1)\n-        return(-1);\n-    ctxt->dataFd = xmlNanoFTPGetConnection(ctxt);\n-    if (ctxt->dataFd == INVALID_SOCKET)\n-        return(-1);\n-    snprintf(buf, sizeof(buf), \"LIST -L\\r\\n\");\n-    } else {\n-    if (filename[0] != '\/') {\n-        if (xmlNanoFTPCwd(ctxt, ctxt->path) < 1)\n-        return(-1);\n-    }\n-    ctxt->dataFd = xmlNanoFTPGetConnection(ctxt);\n-    if (ctxt->dataFd == INVALID_SOCKET)\n-        return(-1);\n-    snprintf(buf, sizeof(buf), \"LIST -L %s\\r\\n\", filename);\n-    }\n-    buf[sizeof(buf) - 1] = 0;\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return(res);\n-    }\n-    res = xmlNanoFTPReadResponse(ctxt);\n-    if (res != 1) {\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return(-res);\n-    }\n-\n-    do {\n-    tv.tv_sec = 1;\n-    tv.tv_usec = 0;\n-    FD_ZERO(&rfd);\n-    FD_SET(ctxt->dataFd, &rfd);\n-    FD_ZERO(&efd);\n-    FD_SET(ctxt->dataFd, &efd);\n-    res = select(ctxt->dataFd + 1, &rfd, NULL, &efd, &tv);\n-    if (res < 0) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    if (res == 0) {\n-        res = xmlNanoFTPCheckResponse(ctxt);\n-        if (res < 0) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-        }\n-        if (res == 2) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(0);\n-        }\n-\n-        continue;\n-    }\n-\n-    if ((len = recv(ctxt->dataFd, &buf[indx], sizeof(buf) - (indx + 1), 0)) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"recv\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    indx += len;\n-    buf[indx] = 0;\n-    base = 0;\n-    do {\n-        res = xmlNanoFTPParseList(&buf[base], callback, userData);\n-        base += res;\n-    } while (res > 0);\n-\n-    memmove(&buf[0], &buf[base], indx - base);\n-    indx -= base;\n-    } while (len != 0);\n-    xmlNanoFTPCloseConnection(ctxt);\n-    return(0);\n-}\n-\n-\/**\n- * xmlNanoFTPGetSocket:\n- * @ctx:  an FTP context\n- * @filename:  the file to retrieve (or NULL if path is in context).\n- *\n- * Initiate fetch of the given file from the server.\n- *\n- * Returns the socket for the data connection, or <0 in case of error\n- *\/\n-\n-\n-SOCKET\n-xmlNanoFTPGetSocket(void *ctx, const char *filename) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[300];\n-    int res, len;\n-    if (ctx == NULL)\n-    return INVALID_SOCKET;\n-    if ((filename == NULL) && (ctxt->path == NULL))\n-    return INVALID_SOCKET;\n-    ctxt->dataFd = xmlNanoFTPGetConnection(ctxt);\n-    if (ctxt->dataFd == INVALID_SOCKET)\n-    return INVALID_SOCKET;\n-\n-    snprintf(buf, sizeof(buf), \"TYPE I\\r\\n\");\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return INVALID_SOCKET;\n-    }\n-    res = xmlNanoFTPReadResponse(ctxt);\n-    if (res != 2) {\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return INVALID_SOCKET;\n-    }\n-    if (filename == NULL)\n-    snprintf(buf, sizeof(buf), \"RETR %s\\r\\n\", ctxt->path);\n-    else\n-    snprintf(buf, sizeof(buf), \"RETR %s\\r\\n\", filename);\n-    buf[sizeof(buf) - 1] = 0;\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return INVALID_SOCKET;\n-    }\n-    res = xmlNanoFTPReadResponse(ctxt);\n-    if (res != 1) {\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return INVALID_SOCKET;\n-    }\n-    return(ctxt->dataFd);\n-}\n-\n-\/**\n- * xmlNanoFTPGet:\n- * @ctx:  an FTP context\n- * @callback:  the user callback\n- * @userData:  the user callback data\n- * @filename:  the file to retrieve\n- *\n- * Fetch the given file from the server. All data are passed back\n- * in the callbacks. The last callback has a size of 0 block.\n- *\n- * Returns -1 in case of error, 0 otherwise\n- *\/\n-\n-int\n-xmlNanoFTPGet(void *ctx, ftpDataCallback callback, void *userData,\n-          const char *filename) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[4096];\n-    int len = 0, res;\n-    fd_set rfd;\n-    struct timeval tv;\n-\n-    if (ctxt == NULL) return(-1);\n-    if ((filename == NULL) && (ctxt->path == NULL))\n-    return(-1);\n-    if (callback == NULL)\n-    return(-1);\n-    if (xmlNanoFTPGetSocket(ctxt, filename) == INVALID_SOCKET)\n-    return(-1);\n-\n-    do {\n-    tv.tv_sec = 1;\n-    tv.tv_usec = 0;\n-    FD_ZERO(&rfd);\n-    FD_SET(ctxt->dataFd, &rfd);\n-    res = select(ctxt->dataFd + 1, &rfd, NULL, NULL, &tv);\n-    if (res < 0) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    if (res == 0) {\n-        res = xmlNanoFTPCheckResponse(ctxt);\n-        if (res < 0) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-        }\n-        if (res == 2) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(0);\n-        }\n-\n-        continue;\n-    }\n-    if ((len = recv(ctxt->dataFd, buf, sizeof(buf), 0)) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"recv failed\");\n-        callback(userData, buf, len);\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    callback(userData, buf, len);\n-    } while (len != 0);\n-\n-    return(xmlNanoFTPCloseConnection(ctxt));\n-}\n-\n-\/**\n- * xmlNanoFTPRead:\n- * @ctx:  the FTP context\n- * @dest:  a buffer\n- * @len:  the buffer length\n- *\n- * This function tries to read @len bytes from the existing FTP connection\n- * and saves them in @dest. This is a blocking call.\n- *\n- * Returns the number of byte read. 0 is an indication of an end of connection.\n- *         -1 indicates a parameter error.\n- *\/\n-int\n-xmlNanoFTPRead(void *ctx, void *dest, int len) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-\n-    if (ctx == NULL) return(-1);\n-    if (ctxt->dataFd == INVALID_SOCKET) return(0);\n-    if (dest == NULL) return(-1);\n-    if (len <= 0) return(0);\n-\n-    len = recv(ctxt->dataFd, dest, len, 0);\n-    if (len <= 0) {\n-    if (len < 0)\n-        __xmlIOErr(XML_FROM_FTP, 0, \"recv failed\");\n-    xmlNanoFTPCloseConnection(ctxt);\n-    }\n-    return(len);\n-}\n-\n-\/**\n- * xmlNanoFTPOpen:\n- * @URL: the URL to the resource\n- *\n- * Start to fetch the given ftp:\/\/ resource\n- *\n- * Returns an FTP context, or NULL\n- *\/\n-\n-void*\n-xmlNanoFTPOpen(const char *URL) {\n-    xmlNanoFTPCtxtPtr ctxt;\n-    SOCKET sock;\n-\n-    xmlNanoFTPInit();\n-    if (URL == NULL) return(NULL);\n-    if (strncmp(\"ftp:\/\/\", URL, 6)) return(NULL);\n-\n-    ctxt = (xmlNanoFTPCtxtPtr) xmlNanoFTPNewCtxt(URL);\n-    if (ctxt == NULL) return(NULL);\n-    if (xmlNanoFTPConnect(ctxt) < 0) {\n-    xmlNanoFTPFreeCtxt(ctxt);\n-    return(NULL);\n-    }\n-    sock = xmlNanoFTPGetSocket(ctxt, ctxt->path);\n-    if (sock == INVALID_SOCKET) {\n-    xmlNanoFTPFreeCtxt(ctxt);\n-    return(NULL);\n-    }\n-    return(ctxt);\n-}\n-\n-\/**\n- * xmlNanoFTPClose:\n- * @ctx: an FTP context\n- *\n- * Close the connection and both control and transport\n- *\n- * Returns -1 in case of error, 0 otherwise\n- *\/\n-\n-int\n-xmlNanoFTPClose(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-\n-    if (ctxt == NULL)\n-    return(-1);\n-\n-    if (ctxt->dataFd != INVALID_SOCKET) {\n-    closesocket(ctxt->dataFd);\n-    ctxt->dataFd = INVALID_SOCKET;\n-    }\n-    if (ctxt->controlFd != INVALID_SOCKET) {\n-    xmlNanoFTPQuit(ctxt);\n-    closesocket(ctxt->controlFd);\n-    ctxt->controlFd = INVALID_SOCKET;\n-    }\n-    xmlNanoFTPFreeCtxt(ctxt);\n-    return(0);\n-}\n-\n-#ifdef STANDALONE\n-\/************************************************************************\n- *                                    *\n- *            Basic test in Standalone mode            *\n- *                                    *\n- ************************************************************************\/\n-static\n-void ftpList(void *userData, const char *filename, const char* attrib,\n-         const char *owner, const char *group, unsigned long size, int links,\n-         int year, const char *month, int day, int hour, int minute) {\n-    fprintf(stderr,\n-        \"%s %s %s %ld %s\\n\", attrib, owner, group, size, filename);\n-}\n-static\n-void ftpData(void *userData, const char *data, int len) {\n-    if (userData == NULL) return;\n-    if (len <= 0) {\n-    fclose((FILE*)userData);\n-    return;\n-    }\n-    fwrite(data, len, 1, (FILE*)userData);\n-}\n-\n-int main(int argc, char **argv) {\n-    void *ctxt;\n-    FILE *output;\n-    char *tstfile = NULL;\n-\n-    xmlNanoFTPInit();\n-    if (argc > 1) {\n-    ctxt = xmlNanoFTPNewCtxt(argv[1]);\n-    if (xmlNanoFTPConnect(ctxt) < 0) {\n-        fprintf(stderr,\n-            \"Couldn't connect to %s\\n\", argv[1]);\n-        exit(1);\n-    }\n-    if (argc > 2)\n-        tstfile = argv[2];\n-    } else\n-    ctxt = xmlNanoFTPConnectTo(\"localhost\", 0);\n-    if (ctxt == NULL) {\n-        fprintf(stderr,\n-        \"Couldn't connect to localhost\\n\");\n-        exit(1);\n-    }\n-    xmlNanoFTPList(ctxt, ftpList, NULL, tstfile);\n-    output = fopen(\"\/tmp\/tstdata\", \"w\");\n-    if (output != NULL) {\n-    if (xmlNanoFTPGet(ctxt, ftpData, (void *) output, tstfile) < 0)\n-        fprintf(stderr,\n-            \"Failed to get file\\n\");\n-\n-    }\n-    xmlNanoFTPClose(ctxt);\n-    exit(0);\n-}\n-#endif \/* STANDALONE *\/\n-#else \/* !LIBXML_FTP_ENABLED *\/\n-#ifdef STANDALONE\n-#include <stdio.h>\n-int main(int argc, char **argv) {\n-    fprintf(stderr,\n-        \"%s : FTP support not compiled in\\n\", argv[0]);\n-    return(0);\n-}\n-#endif \/* STANDALONE *\/\n-#endif \/* LIBXML_FTP_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/nanoftp.c","additions":0,"deletions":1982,"binary":false,"changes":1982,"status":"deleted"}]}